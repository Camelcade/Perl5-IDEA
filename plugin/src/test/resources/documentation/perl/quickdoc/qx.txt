<p><a href="psi_element://perlop">perlop</a>: <a href="psi_element://perlop%2FDESCRIPTION">DESCRIPTION</a></p><h2>Quote and Quote-like Operators
      
          
 </h2><p style="padding-bottom: 10px;">While we usually think of quotes as literal values, in Perl they
function as operators, providing various kinds of interpolating and
pattern matching capabilities.  Perl provides customary quote characters
for these behaviors, but also provides a way for you to choose your
quote character for any of them.  In the following table, a <code>{}</code> represents
any pair of delimiters you choose.</p>
<div style="padding-bottom: 10px;"><pre><code>    Customary  Generic        Meaning	     Interpolates
	''	 q{}	      Literal		  no
	&quot;&quot;	qq{}	      Literal		  yes
	``	qx{}	      Command		  yes*
		qw{}	     Word list		  no
	//	 m{}	   Pattern match	  yes*
		qr{}	      Pattern		  yes*
		 s{}{}	    Substitution	  yes*
		tr{}{}	  Transliteration	  no (but see below)
		 y{}{}	  Transliteration	  no (but see below)
        &lt;&lt;EOF                 here-doc            yes*

	* unless the delimiter is ''.</code></pre></div>
<p style="padding-bottom: 10px;">Non-bracketing delimiters use the same character fore and aft, but the four
sorts of ASCII brackets (round, angle, square, curly) all nest, which means
that</p>
<div style="padding-bottom: 10px;"><pre><code>    q{foo{bar}baz}</code></pre></div>
<p style="padding-bottom: 10px;">is the same as</p>
<div style="padding-bottom: 10px;"><pre><code>    'foo{bar}baz'</code></pre></div>
<p style="padding-bottom: 10px;">Note, however, that this does not always work for quoting Perl code:</p>
<div style="padding-bottom: 10px;"><pre><code>    $s = q{ if($x eq &quot;}&quot;) ... }; # WRONG</code></pre></div>
<p style="padding-bottom: 10px;">is a syntax error.  The <code><a href="psi_element://Text%3A%3ABalanced" style="color:red">Text::Balanced</a></code> module (standard as of v5.8,
and from CPAN before then) is able to do this properly.</p>
<p style="padding-bottom: 10px;">There can (and in some cases, must) be whitespace between the operator
and the quoting
characters, except when <code>#</code> is being used as the quoting character.
<code>q#foo#</code> is parsed as the string <code>foo</code>, while <span style="white-space: nowrap;"><code>q #foo#</code></span> is the
operator <code>q</code> followed by a comment.  Its argument will be taken
from the next line.  This allows you to write:</p>
<div style="padding-bottom: 10px;"><pre><code>    s {foo}  # Replace foo
      {bar}  # with bar.</code></pre></div>
<p style="padding-bottom: 10px;">The cases where whitespace must be used are when the quoting character
is a word character (meaning it matches <code>/\w/</code>):</p>
<div style="padding-bottom: 10px;"><pre><code>    q XfooX # Works: means the string 'foo'
    qXfooX  # WRONG!</code></pre></div>
<p style="padding-bottom: 10px;">The following escape sequences are available in constructs that interpolate,
and in transliterations:
           </p>
<div style="padding-bottom: 10px;"><pre><code>    Sequence     Note  Description
    \t                  tab               (HT, TAB)
    \n                  newline           (NL)
    \r                  return            (CR)
    \f                  form feed         (FF)
    \b                  backspace         (BS)
    \a                  alarm (bell)      (BEL)
    \e                  escape            (ESC)
    \x{263A}     [1,8]  hex char          (example: SMILEY)
    \x1b         [2,8]  restricted range hex char (example: ESC)
    \N{name}     [3]    named Unicode character or character sequence
    \N{U+263D}   [4,8]  Unicode character (example: FIRST QUARTER MOON)
    \c[          [5]    control char      (example: chr(27))
    \o{23072}    [6,8]  octal char        (example: SMILEY)
    \033         [7,8]  restricted range octal char  (example: ESC)</code></pre></div>
<dl><dt style="padding-bottom:4px;font-weight:bold;">[1]</dt><dd style="padding-top:6px;"><p style="padding-bottom: 10px;">The result is the character specified by the hexadecimal number between
the braces.  See <a href="psi_element://perlop%2F%5B8%5D">[8]</a> below for details on which character.</p>
<p style="padding-bottom: 10px;">Only hexadecimal digits are valid between the braces.  If an invalid
character is encountered, a warning will be issued and the invalid
character and all subsequent characters (valid or invalid) within the
braces will be discarded.</p>
<p style="padding-bottom: 10px;">If there are no valid digits between the braces, the generated character is
the NULL character (<code>\x{00}</code>).  However, an explicit empty brace (<code>\x{}</code>)
will not cause a warning (currently).</p></dd>
<dt style="padding-bottom:4px;font-weight:bold;">[2]</dt><dd style="padding-top:6px;"><p style="padding-bottom: 10px;">The result is the character specified by the hexadecimal number in the range
0x00 to 0xFF.  See <a href="psi_element://perlop%2F%5B8%5D">[8]</a> below for details on which character.</p>
<p style="padding-bottom: 10px;">Only hexadecimal digits are valid following <code>\x</code>.  When <code>\x</code> is followed
by fewer than two valid digits, any valid digits will be zero-padded.  This
means that <code>\x7</code> will be interpreted as <code>\x07</code>, and a lone <code>&quot;\x&quot;</code> will be
interpreted as <code>\x00</code>.  Except at the end of a string, having fewer than
two valid digits will result in a warning.  Note that although the warning
says the illegal character is ignored, it is only ignored as part of the
escape and will still be used as the subsequent character in the string.
For example:</p>
<div style="padding-bottom: 10px;"><pre><code>  Original    Result    Warns?
  &quot;\x7&quot;       &quot;\x07&quot;    no
  &quot;\x&quot;        &quot;\x00&quot;    no
  &quot;\x7q&quot;      &quot;\x07q&quot;   yes
  &quot;\xq&quot;       &quot;\x00q&quot;   yes</code></pre></div></dd>
<dt style="padding-bottom:4px;font-weight:bold;">[3]</dt><dd style="padding-top:6px;"><p style="padding-bottom: 10px;">The result is the Unicode character or character sequence given by <i>name</i>.
See <a href="psi_element://charnames" style="color:red">charnames</a>.</p></dd>
<dt style="padding-bottom:4px;font-weight:bold;">[4]</dt><dd style="padding-top:6px;"><p style="padding-bottom: 10px;"><span style="white-space: nowrap;"><code>\N{U+<i>hexadecimal number</i>}</code></span> means the Unicode character whose Unicode code
point is <i>hexadecimal number</i>.</p></dd>
<dt style="padding-bottom:4px;font-weight:bold;">[5]</dt><dd style="padding-top:6px;"><p style="padding-bottom: 10px;">The character following <code>\c</code> is mapped to some other character as shown in the
table:</p>
<div style="padding-bottom: 10px;"><pre><code> Sequence   Value
   \c@      chr(0)
   \cA      chr(1)
   \ca      chr(1)
   \cB      chr(2)
   \cb      chr(2)
   ...
   \cZ      chr(26)
   \cz      chr(26)
   \c[      chr(27)
                     # See below for chr(28)
   \c]      chr(29)
   \c^      chr(30)
   \c_      chr(31)
   \c?      chr(127) # (on ASCII platforms; see below for link to
                     #  EBCDIC discussion)</code></pre></div>
<p style="padding-bottom: 10px;">In other words, it's the character whose code point has had 64 xor'd with
its uppercase.  <code>\c?</code> is DELETE on ASCII platforms because
<span style="white-space: nowrap;"><code>ord(&quot;?&quot;) ^ 64</code></span> is 127, and
<code>\c@</code> is NULL because the ord of <code>&quot;@&quot;</code> is 64, so xor'ing 64 itself produces 0.</p>
<p style="padding-bottom: 10px;">Also, <code>\c\<i>X</i></code> yields <span style="white-space: nowrap;"><code>chr(28) . &quot;<i>X</i>&quot;</code></span> for any <i>X</i>, but cannot come at the
end of a string, because the backslash would be parsed as escaping the end
quote.</p>
<p style="padding-bottom: 10px;">On ASCII platforms, the resulting characters from the list above are the
complete set of ASCII controls.  This isn't the case on EBCDIC platforms; see
<a href="psi_element://perlebcdic%2FOPERATOR+DIFFERENCES">OPERATOR DIFFERENCES in perlebcdic</a> for a full discussion of the
differences between these for ASCII versus EBCDIC platforms.</p>
<p style="padding-bottom: 10px;">Use of any other character following the <code>&quot;c&quot;</code> besides those listed above is
discouraged, and as of Perl v5.20, the only characters actually allowed
are the printable ASCII ones, minus the left brace <code>&quot;{&quot;</code>.  What happens
for any of the allowed other characters is that the value is derived by
xor'ing with the seventh bit, which is 64, and a warning raised if
enabled.  Using the non-allowed characters generates a fatal error.</p>
<p style="padding-bottom: 10px;">To get platform independent controls, you can use <code>\N{...}</code>.</p></dd>
<dt style="padding-bottom:4px;font-weight:bold;">[6]</dt><dd style="padding-top:6px;"><p style="padding-bottom: 10px;">The result is the character specified by the octal number between the braces.
See <a href="psi_element://perlop%2F%5B8%5D">[8]</a> below for details on which character.</p>
<p style="padding-bottom: 10px;">If a character that isn't an octal digit is encountered, a warning is raised,
and the value is based on the octal digits before it, discarding it and all
following characters up to the closing brace.  It is a fatal error if there are
no octal digits at all.</p></dd>
<dt style="padding-bottom:4px;font-weight:bold;">[7]</dt><dd style="padding-top:6px;"><p style="padding-bottom: 10px;">The result is the character specified by the three-digit octal number in the
range 000 to 777 (but best to not use above 077, see next paragraph).  See
<a href="psi_element://perlop%2F%5B8%5D">[8]</a> below for details on which character.</p>
<p style="padding-bottom: 10px;">Some contexts allow 2 or even 1 digit, but any usage without exactly
three digits, the first being a zero, may give unintended results.  (For
example, in a regular expression it may be confused with a backreference;
see <a href="psi_element://perlrebackslash%2FOctal+escapes">Octal escapes in perlrebackslash</a>.)  Starting in Perl 5.14, you may
use <code>\o{}</code> instead, which avoids all these problems.  Otherwise, it is best to
use this construct only for ordinals <code>\077</code> and below, remembering to pad to
the left with zeros to make three digits.  For larger ordinals, either use
<code>\o{}</code>, or convert to something else, such as to hex and use <code>\N{U+}</code>
(which is portable between platforms with different character sets) or
<code>\x{}</code> instead.</p></dd>
<dt style="padding-bottom:4px;font-weight:bold;">[8]</dt><dd style="padding-top:6px;"><p style="padding-bottom: 10px;">Several constructs above specify a character by a number.  That number
gives the character's position in the character set encoding (indexed from 0).
This is called synonymously its ordinal, code position, or code point.  Perl
works on platforms that have a native encoding currently of either ASCII/Latin1
or EBCDIC, each of which allow specification of 256 characters.  In general, if
the number is 255 (0xFF, 0377) or below, Perl interprets this in the platform's
native encoding.  If the number is 256 (0x100, 0400) or above, Perl interprets
it as a Unicode code point and the result is the corresponding Unicode
character.  For example <code>\x{50}</code> and <code>\o{120}</code> both are the number 80 in
decimal, which is less than 256, so the number is interpreted in the native
character set encoding.  In ASCII the character in the 80th position (indexed
from 0) is the letter <code>&quot;P&quot;</code>, and in EBCDIC it is the ampersand symbol <code>&quot;&amp;&quot;</code>.
<code>\x{100}</code> and <code>\o{400}</code> are both 256 in decimal, so the number is interpreted
as a Unicode code point no matter what the native encoding is.  The name of the
character in the 256th position (indexed by 0) in Unicode is
<code>LATIN CAPITAL LETTER A WITH MACRON</code>.</p>
<p style="padding-bottom: 10px;">An exception to the above rule is that <span style="white-space: nowrap;"><code>\N{U+<i>hex number</i>}</code></span> is
always interpreted as a Unicode code point, so that <code>\N{U+0050}</code> is <code>&quot;P&quot;</code> even
on EBCDIC platforms.</p></dd></dl>
<p style="padding-bottom: 10px;"><B>NOTE</B>: Unlike C and other languages, Perl has no <code>\v</code> escape sequence for
the vertical tab (VT, which is 11 in both ASCII and EBCDIC), but you may
use <code>\N{VT}</code>, <code>\ck</code>, <code>\N{U+0b}</code>, or <code>\x0b</code>.  (<code>\v</code>
does have meaning in regular expression patterns in Perl, see <a href="psi_element://perlre">perlre</a>.)</p>
<p style="padding-bottom: 10px;">The following escape sequences are available in constructs that interpolate,
but not in transliterations.
      </p>
<div style="padding-bottom: 10px;"><pre><code>    \l		lowercase next character only
    \u		titlecase (not uppercase!) next character only
    \L		lowercase all characters till \E or end of string
    \U		uppercase all characters till \E or end of string
    \F		foldcase all characters till \E or end of string
    \Q          quote (disable) pattern metacharacters till \E or
                end of string
    \E		end either case modification or quoted section
		(whichever was last seen)</code></pre></div>
<p style="padding-bottom: 10px;">See <a href="psi_element://perlfunc%2Fquotemeta">quotemeta in perlfunc</a> for the exact definition of characters that
are quoted by <code>\Q</code>.</p>
<p style="padding-bottom: 10px;"><code>\L</code>, <code>\U</code>, <code>\F</code>, and <code>\Q</code> can stack, in which case you need one
<code>\E</code> for each.  For example:</p>
<div style="padding-bottom: 10px;"><pre><code> say&quot;This \Qquoting \ubusiness \Uhere isn't quite\E done yet,\E is it?&quot;;
 This quoting\ Business\ HERE\ ISN\'T\ QUITE\ done\ yet\, is it?</code></pre></div>
<p style="padding-bottom: 10px;">If a <span style="white-space: nowrap;"><code>use locale</code></span> form that includes <code>LC_CTYPE</code> is in effect (see
<a href="psi_element://perllocale">perllocale</a>), the case map used by <code>\l</code>, <code>\L</code>, <code>\u</code>, and <code>\U</code> is
taken from the current locale.  If Unicode (for example, <code>\N{}</code> or code
points of 0x100 or beyond) is being used, the case map used by <code>\l</code>,
<code>\L</code>, <code>\u</code>, and <code>\U</code> is as defined by Unicode.  That means that
case-mapping a single character can sometimes produce a sequence of
several characters.
Under <span style="white-space: nowrap;"><code>use locale</code></span>, <code>\F</code> produces the same results as <code>\L</code>
for all locales but a UTF-8 one, where it instead uses the Unicode
definition.</p>
<p style="padding-bottom: 10px;">All systems use the virtual <code>&quot;\n&quot;</code> to represent a line terminator,
called a &quot;newline&quot;.  There is no such thing as an unvarying, physical
newline character.  It is only an illusion that the operating system,
device drivers, C libraries, and Perl all conspire to preserve.  Not all
systems read <code>&quot;\r&quot;</code> as ASCII CR and <code>&quot;\n&quot;</code> as ASCII LF.  For example,
on the ancient Macs (pre-MacOS X) of yesteryear, these used to be reversed,
and on systems without a line terminator,
printing <code>&quot;\n&quot;</code> might emit no actual data.  In general, use <code>&quot;\n&quot;</code> when
you mean a &quot;newline&quot; for your system, but use the literal ASCII when you
need an exact character.  For example, most networking protocols expect
and prefer a CR+LF (<code>&quot;\015\012&quot;</code> or <code>&quot;\cM\cJ&quot;</code>) for line terminators,
and although they often accept just <code>&quot;\012&quot;</code>, they seldom tolerate just
<code>&quot;\015&quot;</code>.  If you get in the habit of using <code>&quot;\n&quot;</code> for networking,
you may be burned some day.
   
  </p>
<p style="padding-bottom: 10px;">For constructs that do interpolate, variables beginning with &quot;<code>$</code>&quot;
or &quot;<code>@</code>&quot; are interpolated.  Subscripted variables such as <code>$a[3]</code> or
<code>$href-&gt;{key}[0]</code> are also interpolated, as are array and hash slices.
But method calls such as <code>$obj-&gt;meth</code> are not.</p>
<p style="padding-bottom: 10px;">Interpolating an array or slice interpolates the elements in order,
separated by the value of <code>$&quot;</code>, so is equivalent to interpolating
<span style="white-space: nowrap;"><code>join $&quot;, @array</code></span>.  &quot;Punctuation&quot; arrays such as <code>@*</code> are usually
interpolated only if the name is enclosed in braces <code>@{*}</code>, but the
arrays <code>@_</code>, <code>@+</code>, and <code>@-</code> are interpolated even without braces.</p>
<p style="padding-bottom: 10px;">For double-quoted strings, the quoting from <code>\Q</code> is applied after
interpolation and escapes are processed.</p>
<div style="padding-bottom: 10px;"><pre><code>    &quot;abc\Qfoo\tbar$s\Exyz&quot;</code></pre></div>
<p style="padding-bottom: 10px;">is equivalent to</p>
<div style="padding-bottom: 10px;"><pre><code>    &quot;abc&quot; . quotemeta(&quot;foo\tbar$s&quot;) . &quot;xyz&quot;</code></pre></div>
<p style="padding-bottom: 10px;">For the pattern of regex operators (<code>qr//</code>, <code>m//</code> and <code>s///</code>),
the quoting from <code>\Q</code> is applied after interpolation is processed,
but before escapes are processed.  This allows the pattern to match
literally (except for <code>$</code> and <code>@</code>).  For example, the following matches:</p>
<div style="padding-bottom: 10px;"><pre><code>    '\s\t' =~ /\Q\s\t/</code></pre></div>
<p style="padding-bottom: 10px;">Because <code>$</code> or <code>@</code> trigger interpolation, you'll need to use something
like <code>/\Quser\E\@\Qhost/</code> to match them literally.</p>
<p style="padding-bottom: 10px;">Patterns are subject to an additional level of interpretation as a
regular expression.  This is done as a second pass, after variables are
interpolated, so that regular expressions may be incorporated into the
pattern from the variables.  If this is not what you want, use <code>\Q</code> to
interpolate a variable literally.</p>
<p style="padding-bottom: 10px;">Apart from the behavior described above, Perl does not expand
multiple levels of interpolation.  In particular, contrary to the
expectations of shell programmers, back-quotes do <i>NOT</i> interpolate
within double quotes, nor do single quotes impede evaluation of
variables when used within double quotes.</p><hr><p><a href="psi_element://perlop">perlop</a>: <a href="psi_element://perlop%2FDESCRIPTION">DESCRIPTION</a>: <a href="psi_element://perlop%2FQuote-Like+Operators">Quote-Like Operators</a></p><dl><dt style="padding-bottom:4px;font-weight:bold;"><code>qx/<i>STRING</i>/</code>
   </dt>
<dt style="padding-bottom:4px;font-weight:bold;"><code>`<i>STRING</i>`</code></dt><dd style="padding-top:6px;"><p style="padding-bottom: 10px;">A string which is (possibly) interpolated and then executed as a
system command with <i>/bin/sh</i> or its equivalent.  Shell wildcards,
pipes, and redirections will be honored.  The collected standard
output of the command is returned; standard error is unaffected.  In
scalar context, it comes back as a single (potentially multi-line)
string, or <code>undef</code> if the command failed.  In list context, returns a
list of lines (however you've defined lines with <code>$/</code> or
<code>$INPUT_RECORD_SEPARATOR</code>), or an empty list if the command failed.</p>
<p style="padding-bottom: 10px;">Because backticks do not affect standard error, use shell file descriptor
syntax (assuming the shell supports this) if you care to address this.
To capture a command's STDERR and STDOUT together:</p>
<div style="padding-bottom: 10px;"><pre><code>    $output = `cmd 2&gt;&amp;1`;</code></pre></div>
<p style="padding-bottom: 10px;">To capture a command's STDOUT but discard its STDERR:</p>
<div style="padding-bottom: 10px;"><pre><code>    $output = `cmd 2&gt;/dev/null`;</code></pre></div>
<p style="padding-bottom: 10px;">To capture a command's STDERR but discard its STDOUT (ordering is
important here):</p>
<div style="padding-bottom: 10px;"><pre><code>    $output = `cmd 2&gt;&amp;1 1&gt;/dev/null`;</code></pre></div>
<p style="padding-bottom: 10px;">To exchange a command's STDOUT and STDERR in order to capture the STDERR
but leave its STDOUT to come out the old STDERR:</p>
<div style="padding-bottom: 10px;"><pre><code>    $output = `cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`;</code></pre></div>
<p style="padding-bottom: 10px;">To read both a command's STDOUT and its STDERR separately, it's easiest
to redirect them separately to files, and then read from those files
when the program is done:</p>
<div style="padding-bottom: 10px;"><pre><code>    system(&quot;program args 1&gt;program.stdout 2&gt;program.stderr&quot;);</code></pre></div>
<p style="padding-bottom: 10px;">The STDIN filehandle used by the command is inherited from Perl's STDIN.
For example:</p>
<div style="padding-bottom: 10px;"><pre><code>    open(SPLAT, &quot;stuff&quot;)   || die &quot;can't open stuff: $!&quot;;
    open(STDIN, &quot;&lt;&amp;SPLAT&quot;) || die &quot;can't dupe SPLAT: $!&quot;;
    print STDOUT `sort`;</code></pre></div>
<p style="padding-bottom: 10px;">will print the sorted contents of the file named <i>&quot;stuff&quot;</i>.</p>
<p style="padding-bottom: 10px;">Using single-quote as a delimiter protects the command from Perl's
double-quote interpolation, passing it on to the shell instead:</p>
<div style="padding-bottom: 10px;"><pre><code>    $perl_info  = qx(ps $$);            # that's Perl's $$
    $shell_info = qx'ps $$';            # that's the new shell's $$</code></pre></div>
<p style="padding-bottom: 10px;">How that string gets evaluated is entirely subject to the command
interpreter on your system.  On most platforms, you will have to protect
shell metacharacters if you want them treated literally.  This is in
practice difficult to do, as it's unclear how to escape which characters.
See <a href="psi_element://perlsec">perlsec</a> for a clean and safe example of a manual <code>fork()</code> and <code>exec()</code>
to emulate backticks safely.</p>
<p style="padding-bottom: 10px;">On some platforms (notably DOS-like ones), the shell may not be
capable of dealing with multiline commands, so putting newlines in
the string may not get you what you want.  You may be able to evaluate
multiple commands in a single line by separating them with the command
separator character, if your shell supports that (for example, <code>;</code> on
many Unix shells and <code>&amp;</code> on the Windows NT <code>cmd</code> shell).</p>
<p style="padding-bottom: 10px;">Perl will attempt to flush all files opened for
output before starting the child process, but this may not be supported
on some platforms (see <a href="psi_element://perlport">perlport</a>).  To be safe, you may need to set
<code>$|</code> (<code>$AUTOFLUSH</code> in <code><a href="psi_element://English" style="color:red">English</a></code>) or call the <code>autoflush()</code> method of
<code><a href="psi_element://IO%3A%3AHandle" style="color:red">IO::Handle</a></code> on any open handles.</p>
<p style="padding-bottom: 10px;">Beware that some command shells may place restrictions on the length
of the command line.  You must ensure your strings don't exceed this
limit after any necessary interpolations.  See the platform-specific
release notes for more details about your particular environment.</p>
<p style="padding-bottom: 10px;">Using this operator can lead to programs that are difficult to port,
because the shell commands called vary between systems, and may in
fact not be present at all.  As one example, the <code>type</code> command under
the POSIX shell is very different from the <code>type</code> command under DOS.
That doesn't mean you should go out of your way to avoid backticks
when they're the right way to get something done.  Perl was made to be
a glue language, and one of the things it glues together is commands.
Just understand what you're getting yourself into.</p>
<p style="padding-bottom: 10px;">Like <code>system</code>, backticks put the child process exit code in <code>$?</code>.
If you'd like to manually inspect failure, you can check all possible
failure modes by inspecting <code>$?</code> like this:</p>
<div style="padding-bottom: 10px;"><pre><code>    if ($? == -1) {
        print &quot;failed to execute: $!\n&quot;;
    }
    elsif ($? &amp; 127) {
        printf &quot;child died with signal %d, %s coredump\n&quot;,
            ($? &amp; 127),  ($? &amp; 128) ? 'with' : 'without';
    }
    else {
        printf &quot;child exited with value %d\n&quot;, $? &gt;&gt; 8;
    }</code></pre></div>
<p style="padding-bottom: 10px;">Use the <a href="psi_element://open" style="color:red">open</a> pragma to control the I/O layers used when reading the
output of the command, for example:</p>
<div style="padding-bottom: 10px;"><pre><code>  use open IN =&gt; &quot;:encoding(UTF-8)&quot;;
  my $x = `cmd-producing-utf-8`;</code></pre></div>
<p style="padding-bottom: 10px;">See <a href="psi_element://perlop%2FI%2FO+Operators">I/O Operators</a> for more discussion.</p></dd></dl><hr><p><a href="psi_element://perlop">perlop</a>: <a href="psi_element://perlop%2FDESCRIPTION">DESCRIPTION</a>: <a href="psi_element://perlop%2FI%2FO+Operators">I/O Operators</a></p><p style="padding-bottom: 10px;">A string enclosed by backticks (grave accents) first undergoes
double-quote interpolation.  It is then interpreted as an external
command, and the output of that command is the value of the
backtick string, like in a shell.  In scalar context, a single string
consisting of all output is returned.  In list context, a list of
values is returned, one per line of output.  (You can set <code>$/</code> to use
a different line terminator.)  The command is executed each time the
pseudo-literal is evaluated.  The status value of the command is
returned in <code>$?</code> (see <a href="psi_element://perlvar">perlvar</a> for the interpretation of <code>$?</code>).
Unlike in <B>csh</B>, no translation is done on the return data--newlines
remain newlines.  Unlike in any of the shells, single quotes do not
hide variable names in the command from interpretation.  To pass a
literal dollar-sign through to the shell you need to hide it with a
backslash.  The generalized form of backticks is <code>qx//</code>.  (Because
backticks always undergo shell expansion as well, see <a href="psi_element://perlsec">perlsec</a> for
security concerns.)
    </p>
<p style="padding-bottom: 10px;">In scalar context, evaluating a filehandle in angle brackets yields
the next line from that file (the newline, if any, included), or
<code>undef</code> at end-of-file or on error.  When <code>$/</code> is set to <code>undef</code>
(sometimes known as file-slurp mode) and the file is empty, it
returns <code>''</code> the first time, followed by <code>undef</code> subsequently.</p>
<p style="padding-bottom: 10px;">Ordinarily you must assign the returned value to a variable, but
there is one situation where an automatic assignment happens.  If
and only if the input symbol is the only thing inside the conditional
of a <code>while</code> statement (even if disguised as a <code>for(;;)</code> loop),
the value is automatically assigned to the global variable <code>$_</code>,
destroying whatever was there previously.  (This may seem like an
odd thing to you, but you'll use the construct in almost every Perl
script you write.)  The <code>$_</code> variable is not implicitly localized.
You'll have to put a <span style="white-space: nowrap;"><code>local $_;</code></span> before the loop if you want that
to happen.  Furthermore, if the input symbol or an explicit assignment
of the input symbol to a scalar is used as a <code>while</code>/<code>for</code> condition,
then the condition actually tests for definedness of the expression's
value, not for its regular truth value.</p>
<p style="padding-bottom: 10px;">Thus the following lines are equivalent:</p>
<div style="padding-bottom: 10px;"><pre><code>    while (defined($_ = &lt;STDIN&gt;)) { print; }
    while ($_ = &lt;STDIN&gt;) { print; }
    while (&lt;STDIN&gt;) { print; }
    for (;&lt;STDIN&gt;;) { print; }
    print while defined($_ = &lt;STDIN&gt;);
    print while ($_ = &lt;STDIN&gt;);
    print while &lt;STDIN&gt;;</code></pre></div>
<p style="padding-bottom: 10px;">This also behaves similarly, but assigns to a lexical variable
instead of to <code>$_</code>:</p>
<div style="padding-bottom: 10px;"><pre><code>    while (my $line = &lt;STDIN&gt;) { print $line }</code></pre></div>
<p style="padding-bottom: 10px;">In these loop constructs, the assigned value (whether assignment
is automatic or explicit) is then tested to see whether it is
defined.  The defined test avoids problems where the line has a string
value that would be treated as false by Perl; for example a &quot;&quot; or
a <code>&quot;0&quot;</code> with no trailing newline.  If you really mean for such values
to terminate the loop, they should be tested for explicitly:</p>
<div style="padding-bottom: 10px;"><pre><code>    while (($_ = &lt;STDIN&gt;) ne '0') { ... }
    while (&lt;STDIN&gt;) { last unless $_; ... }</code></pre></div>
<p style="padding-bottom: 10px;">In other boolean contexts, <code>&lt;<i>FILEHANDLE</i>&gt;</code> without an
explicit <code>defined</code> test or comparison elicits a warning if the
<span style="white-space: nowrap;"><code>use warnings</code></span> pragma or the <B>-w</B>
command-line switch (the <code>$^W</code> variable) is in effect.</p>
<p style="padding-bottom: 10px;">The filehandles STDIN, STDOUT, and STDERR are predefined.  (The
filehandles <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> will also work except
in packages, where they would be interpreted as local identifiers
rather than global.)  Additional filehandles may be created with
the <code>open()</code> function, amongst others.  See <a href="psi_element://perlopentut">perlopentut</a> and
<a href="psi_element://perlfunc%2Fopen">open in perlfunc</a> for details on this.
  </p>
<p style="padding-bottom: 10px;">If a <code>&lt;<i>FILEHANDLE</i>&gt;</code> is used in a context that is looking for
a list, a list comprising all input lines is returned, one line per
list element.  It's easy to grow to a rather large data space this
way, so use with care.</p>
<p style="padding-bottom: 10px;"><code>&lt;<i>FILEHANDLE</i>&gt;</code>  may also be spelled <code>readline(*<i>FILEHANDLE</i>)</code>.
See <a href="psi_element://perlfunc%2Freadline">readline in perlfunc</a>.</p>
<p style="padding-bottom: 10px;">The null filehandle <code>&lt;&gt;</code> is special: it can be used to emulate the
behavior of <B>sed</B> and <B>awk</B>, and any other Unix filter program
that takes a list of filenames, doing the same to each line
of input from all of them.  Input from <code>&lt;&gt;</code> comes either from
standard input, or from each file listed on the command line.  Here's
how it works: the first time <code>&lt;&gt;</code> is evaluated, the <code>@ARGV</code> array is
checked, and if it is empty, <code>$ARGV[0]</code> is set to <code>&quot;-&quot;</code>, which when opened
gives you standard input.  The <code>@ARGV</code> array is then processed as a list
of filenames.  The loop</p>
<div style="padding-bottom: 10px;"><pre><code>    while (&lt;&gt;) {
	...			# code for each line
    }</code></pre></div>
<p style="padding-bottom: 10px;">is equivalent to the following Perl-like pseudo code:</p>
<div style="padding-bottom: 10px;"><pre><code>    unshift(@ARGV, '-') unless @ARGV;
    while ($ARGV = shift) {
	open(ARGV, $ARGV);
	while (&lt;ARGV&gt;) {
	    ...		# code for each line
	}
    }</code></pre></div>
<p style="padding-bottom: 10px;">except that it isn't so cumbersome to say, and will actually work.
It really does shift the <code>@ARGV</code> array and put the current filename
into the <code>$ARGV</code> variable.  It also uses filehandle <i>ARGV</i>
internally.  <code>&lt;&gt;</code> is just a synonym for <code>&lt;ARGV&gt;</code>, which
is magical.  (The pseudo code above doesn't work because it treats
<code>&lt;ARGV&gt;</code> as non-magical.)</p>
<p style="padding-bottom: 10px;">Since the null filehandle uses the two argument form of <a href="psi_element://perlfunc%2Fopen">open in perlfunc</a>
it interprets special characters, so if you have a script like this:</p>
<div style="padding-bottom: 10px;"><pre><code>    while (&lt;&gt;) {
        print;
    }</code></pre></div>
<p style="padding-bottom: 10px;">and call it with <span style="white-space: nowrap;"><code>perl dangerous.pl 'rm -rfv *|'</code></span>, it actually opens a
pipe, executes the <code>rm</code> command and reads <code>rm</code>'s output from that pipe.
If you want all items in <code>@ARGV</code> to be interpreted as file names, you
can use the module <code>ARGV::readonly</code> from CPAN, or use the double bracket:</p>
<div style="padding-bottom: 10px;"><pre><code>    while (&lt;&lt;&gt;&gt;) {
        print;
    }</code></pre></div>
<p style="padding-bottom: 10px;">Using double angle brackets inside of a while causes the open to use the
three argument form (with the second argument being <code>&lt;</code>), so all
arguments in <code>ARGV</code> are treated as literal filenames (including <code>&quot;-&quot;</code>).
(Note that for convenience, if you use <code>&lt;&lt;&gt;&gt;</code> and if <code>@ARGV</code> is
empty, it will still read from the standard input.)</p>
<p style="padding-bottom: 10px;">You can modify <code>@ARGV</code> before the first <code>&lt;&gt;</code> as long as the array ends up
containing the list of filenames you really want.  Line numbers (<code>$.</code>)
continue as though the input were one big happy file.  See the example
in <a href="psi_element://perlfunc%2Feof">eof in perlfunc</a> for how to reset line numbers on each file.</p>
<p style="padding-bottom: 10px;">If you want to set <code>@ARGV</code> to your own list of files, go right ahead.
This sets <code>@ARGV</code> to all plain text files if no <code>@ARGV</code> was given:</p>
<div style="padding-bottom: 10px;"><pre><code>    @ARGV = grep { -f &amp;&amp; -T } glob('*') unless @ARGV;</code></pre></div>
<p style="padding-bottom: 10px;">You can even set them to pipe commands.  For example, this automatically
filters compressed arguments through <B>gzip</B>:</p>
<div style="padding-bottom: 10px;"><pre><code>    @ARGV = map { /\.(gz|Z)$/ ? &quot;gzip -dc &lt; $_ |&quot; : $_ } @ARGV;</code></pre></div>
<p style="padding-bottom: 10px;">If you want to pass switches into your script, you can use one of the
<code>Getopts</code> modules or put a loop on the front like this:</p>
<div style="padding-bottom: 10px;"><pre><code>    while ($_ = $ARGV[0], /^-/) {
	shift;
        last if /^--$/;
	if (/^-D(.*)/) { $debug = $1 }
	if (/^-v/)     { $verbose++  }
	# ...		# other switches
    }

    while (&lt;&gt;) {
	# ...		# code for each line
    }</code></pre></div>
<p style="padding-bottom: 10px;">The <code>&lt;&gt;</code> symbol will return <code>undef</code> for end-of-file only once.
If you call it again after this, it will assume you are processing another
<code>@ARGV</code> list, and if you haven't set <code>@ARGV</code>, will read input from STDIN.</p>
<p style="padding-bottom: 10px;">If what the angle brackets contain is a simple scalar variable (for example,
<code>$foo</code>), then that variable contains the name of the
filehandle to input from, or its typeglob, or a reference to the
same.  For example:</p>
<div style="padding-bottom: 10px;"><pre><code>    $fh = \*STDIN;
    $line = &lt;$fh&gt;;</code></pre></div>
<p style="padding-bottom: 10px;">If what's within the angle brackets is neither a filehandle nor a simple
scalar variable containing a filehandle name, typeglob, or typeglob
reference, it is interpreted as a filename pattern to be globbed, and
either a list of filenames or the next filename in the list is returned,
depending on context.  This distinction is determined on syntactic
grounds alone.  That means <code>&lt;$x&gt;</code> is always a <code>readline()</code> from
an indirect handle, but <code>&lt;$hash{key}&gt;</code> is always a <code>glob()</code>.
That's because <code>$x</code> is a simple scalar variable, but <code>$hash{key}</code> is
not--it's a hash element.  Even <code>&lt;$x &gt;</code> (note the extra space)
is treated as <code>glob(&quot;$x &quot;)</code>, not <code>readline($x)</code>.</p>
<p style="padding-bottom: 10px;">One level of double-quote interpretation is done first, but you can't
say <code>&lt;$foo&gt;</code> because that's an indirect filehandle as explained
in the previous paragraph.  (In older versions of Perl, programmers
would insert curly brackets to force interpretation as a filename glob:
<code>&lt;${foo}&gt;</code>.  These days, it's considered cleaner to call the
internal function directly as <code>glob($foo)</code>, which is probably the right
way to have done it in the first place.)  For example:</p>
<div style="padding-bottom: 10px;"><pre><code>    while (&lt;*.c&gt;) {
	chmod 0644, $_;
    }</code></pre></div>
<p style="padding-bottom: 10px;">is roughly equivalent to:</p>
<div style="padding-bottom: 10px;"><pre><code>    open(FOO, &quot;echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|&quot;);
    while (&lt;FOO&gt;) {
	chomp;
	chmod 0644, $_;
    }</code></pre></div>
<p style="padding-bottom: 10px;">except that the globbing is actually done internally using the standard
<code><a href="psi_element://File%3A%3AGlob" style="color:red">File::Glob</a></code> extension.  Of course, the shortest way to do the above is:</p>
<div style="padding-bottom: 10px;"><pre><code>    chmod 0644, &lt;*.c&gt;;</code></pre></div>
<p style="padding-bottom: 10px;">A (file)glob evaluates its (embedded) argument only when it is
starting a new list.  All values must be read before it will start
over.  In list context, this isn't important because you automatically
get them all anyway.  However, in scalar context the operator returns
the next value each time it's called, or <code>undef</code> when the list has
run out.  As with filehandle reads, an automatic <code>defined</code> is
generated when the glob occurs in the test part of a <code>while</code>,
because legal glob returns (for example,
a file called <i>0</i>) would otherwise
terminate the loop.  Again, <code>undef</code> is returned only once.  So if
you're expecting a single value from a glob, it is much better to
say</p>
<div style="padding-bottom: 10px;"><pre><code>    ($file) = &lt;blurch*&gt;;</code></pre></div>
<p style="padding-bottom: 10px;">than</p>
<div style="padding-bottom: 10px;"><pre><code>    $file = &lt;blurch*&gt;;</code></pre></div>
<p style="padding-bottom: 10px;">because the latter will alternate between returning a filename and
returning false.</p>
<p style="padding-bottom: 10px;">If you're trying to do variable interpolation, it's definitely better
to use the <code>glob()</code> function, because the older notation can cause people
to become confused with the indirect filehandle notation.</p>
<div style="padding-bottom: 10px;"><pre><code>    @files = glob(&quot;$dir/*.[ch]&quot;);
    @files = glob($files[$i]);</code></pre></div>
<p style="padding-bottom: 10px;">If an angle-bracket-based globbing expression is used as the condition of
a <code>while</code> or <code>for</code> loop, then it will be implicitly assigned to <code>$_</code>.
If either a globbing expression or an explicit assignment of a globbing
expression to a scalar is used as a <code>while</code>/<code>for</code> condition, then
the condition actually tests for definedness of the expression's value,
not for its regular truth value.</p>

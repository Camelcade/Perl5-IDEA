
package MOP::Point;

use strict;
use warnings;
use metaclass;

__PACKAGE__->meta->add_attribute('x' => (accessor => 'x', default => 10));
__PACKAGE__->meta->add_attribute('y' => (accessor => 'y'));

sub new {
    my $class = shift;
    $class->meta->new_object(@_);
}

sub clear {
    my $self = shift;
    $self->x(0);
    $self->y(0);
}

1;


use lib reverse @INC;

package MOP::Installed::Point;

use strict;
use warnings;
use metaclass;

__PACKAGE__->meta->add_attribute('x' => (accessor => 'x', default => 10));
__PACKAGE__->meta->add_attribute('y' => (accessor => 'y'));

sub new {
    my $class = shift;
    $class->meta->new_object(@_);
}

sub clear {
    my $self = shift;
    $self->x(0);
    $self->y(0);
}

1;


use lib reverse @INC;

package MOP::Installed::Point3D;

use strict;
use warnings;
use metaclass;

use base 'MOP::Point';

__PACKAGE__->meta->add_attribute('z' => (accessor => 'z'));

sub clear {
    my $self = shift;
    $self->SUPER::clear();
    $self->z(0);
}

1;


package MOP::Immutable::Point;

use strict;
use warnings;
use metaclass;

__PACKAGE__->meta->add_attribute('x' => (accessor => 'x', default => 10));
__PACKAGE__->meta->add_attribute('y' => (accessor => 'y'));

sub clear {
    my $self = shift;
    $self->x(0);
    $self->y(0);
}

__PACKAGE__->meta->make_immutable;

1;


package MOP::Immutable::Point3D;

use strict;
use warnings;
use metaclass;

use base 'MOP::Point';

__PACKAGE__->meta->add_attribute('z' => (accessor => 'z'));

sub clear {
    my $self = shift;
    $self->SUPER::clear();
    $self->z(0);
}

__PACKAGE__->meta->make_immutable;

1;


package MOP::Point3D;

use strict;
use warnings;
use metaclass;

use base 'MOP::Point';

__PACKAGE__->meta->add_attribute('z' => (accessor => 'z'));

sub clear {
    my $self = shift;
    $self->SUPER::clear();
    $self->z(0);
}

1;

#!/usr/bin/perl

package Plain::Point;

use strict;
use warnings;

sub new {
    my ( $class, %params ) = @_;

    return bless {
        x => $params{x} || 10,
        y => $params{y},
    }, $class;
}

sub x {
    my ( $self, @args ) = @_;

    if ( @args ) {
        $self->{x} = $args[0];
    }

    return $self->{x};
}

sub y {
    my ( $self, @args ) = @_;

    if ( @args ) {
        $self->{y} = $args[0];
    }

    return $self->{y};
}

sub clear {
    my $self = shift;
    @{$self}{qw/x y/} = (0, 0);
}

__PACKAGE__;

#!/usr/bin/perl

package Plain::Point3D;

use strict;
use warnings;

use base 'Plain::Point';

sub new {
    my ( $class, %params ) = @_;
    my $self = $class->SUPER::new( %params );
    $self->{z} = $params{z};
    return $self;
}

sub z {
    my ( $self, @args ) = @_;

    if ( @args ) {
        $self->{z} = $args[0];
    }

    return $self->{z};
}

sub clear {
    my $self = shift;
    $self->SUPER::clear();
    $self->{z} = 0;
}

__PACKAGE__;

#!/usr/bin/perl

package Bench::Run;
use Moose;

use Benchmark qw/:hireswallclock :all/;

has classes => (
    isa => "ArrayRef",
    is  => "rw",
    auto_deref => 1,
);

has benchmarks => (
    isa => "ArrayRef",
    is  => "rw",
    auto_deref => 1,
);

has min_time => (
    isa => "Num",
    is  => "rw",
    default => 5,
);

sub run {
    my $self = shift;

    foreach my $bench ( $self->benchmarks ) {
        my $bench_class = delete $bench->{class};
        my $name        = delete $bench->{name} || $bench_class;
        my @bench_args  = %$bench;

        eval "require $bench_class";
        die $@ if $@;

        my %res;

        foreach my $class ( $self->classes ) {
            eval "require $class";
            die $@ if $@;

            my $b = $bench_class->new( @bench_args, class => $class );
            $res{$class} = countit( $self->min_time, $b->code );
        }

        print "- $name:\n";
        cmpthese( \%res );
        print "\n";
    }
}

__PACKAGE__;

#!/usr/bin/perl

package Bench::Construct;
use Moose;
use Moose::Util::TypeConstraints;

has class => (
    isa => "Str",
    is  => "ro",
);

eval {
coerce ArrayRef
    => from HashRef
        => via { [ %$_ ] };
};

has args => (
    isa => "ArrayRef",
    is  => "ro",
    auto_deref => 1,
    coerce     => 1,
);

sub code {
    my $self = shift;

    my $class = $self->class;
    my @args  = $self->args;

    sub { my $obj = $class->new( @args ) }
}

__PACKAGE__;

#!/usr/bin/perl

package Bench::Accessor;
use Moose;
use Moose::Util::TypeConstraints;

eval {
coerce ArrayRef
    => from HashRef
        => via { [ %$_ ] };
};

has class => (
    isa => "Str",
    is  => "ro",
);

has construct => (
    isa => "ArrayRef",
    is  => "ro",
    auto_deref => 1,
    coerce     => 1,
);

has accessor => (
    isa => "Str",
    is  => "ro",
);

has accessor_args => (
    isa => "ArrayRef",
    is  => "ro",
    auto_deref => 1,
    coerce     => 1,
);

sub code {
    my $self = shift;

    my $obj = $self->class->new( $self->construct );
    my @accessor_args = $self->accessor_args;
    my $accessor = $self->accessor;

    sub { $obj->$accessor( @accessor_args ) };
}

__PACKAGE__;

package NoInlineAttribute;

use Moose::Meta::Class;
use Moose::Role;

around accessor_metaclass => sub {
    my $orig = shift;
    my $self = shift;

    my $class = $self->$orig();

    return Moose::Meta::Class->create_anon_class(
        superclasses => [$class],
        roles        => ['NoInlineAccessor'],
        cache        => 1,
    )->name;
};

no Moose::Role;

{
    package NoInlineAccessor;

    use Moose::Role;

    sub is_inline { 0 }
}

1;
package Bar;
use Moose;
use Moose::Util::TypeConstraints;

type Baz => where { 1 };

subtype Bling => as Baz => where { 1 };

1;package Role::Child;
use Moose::Role;

with 'Role::Parent' => { -alias => { meth1 => 'aliased_meth1', } };

sub meth1 { }

1;
package Role::BreakOnLoad;
use Moose::Role;

sub meth1 { }

this role has a syntax error and should crash on load.

1;
package Role::Parent;
use Moose::Role;

sub meth2  { }
sub meth1 { }

1;
package Role::Interface;
use Moose::Role;

requires "meth2";

1;
package Real::Package;
use strict;
use warnings;

sub foo { }

1;
package MyMetaclassRole;
use Moose::Role;

1;
package Foo;
use Moose;

has 'bar' => (is => 'rw');

1;
package OverloadingTests;

use strict;
use warnings;

use Test::More 0.88;
use Devel::OverloadInfo 0.004 'is_overloaded';

sub test_overloading_for_package {
    my $package = shift;

    ok(
        is_overloaded($package),
        "$package is overloaded"
    );
    ok(
        overload::Method( $package, q{""} ),
        "$package overloads stringification"
    );
}

sub test_no_overloading_for_package {
    my $package = shift;

    ok(
        !is_overloaded($package),
        "$package is not overloaded"
    );
    ok(
        !overload::Method( $package, q{""} ),
        "$package does not overload stringification"
    );
}

sub test_overloading_for_object {
    my $class = shift;
    my $thing = shift || "$class object";

    my $object = ref $class ? $class : $class->new( { message => 'foo' } );

    is(
        "$object",
        'foo',
        "$thing stringifies to value of message attribute"
    );
}

1;
package MyMooseObject;

use strict;
use warnings;
use parent 'Moose::Object';

1;
package Overloading::RoleWithOverloads;

use Moose::Role;

use overload
    q{""}    => 'as_string',
    fallback => 1;

has message => (
    is  => 'rw',
    isa => 'Str',
);

sub as_string { shift->message }

1;
package Overloading::ClassWithOneRole;

use Moose;

with 'Overloading::RoleWithOverloads';

1;
package Overloading::ClassWithCombiningRole;

use Moose;

with 'Overloading::CombiningRole';

1;
package Overloading::ClassConsumesRoleConsumesOverloads;

use Moose;

with 'Overloading::RoleConsumesOverloads';

1;
package Overloading::CombiningClass;

use Moose;

with 'Overloading::RoleWithOverloads', 'Overloading::RoleWithoutOverloads';

1;
package Overloading::CombiningRole;

use Moose::Role;

with 'Overloading::RoleWithOverloads', 'Overloading::RoleWithoutOverloads';

1;
package Overloading::RoleConsumesOverloads;

use Moose::Role;

with 'Overloading::RoleWithOverloads';

1;
package Overloading::RoleWithoutOverloads;

use Moose::Role;

1;
package MyExporter;
use Moose::Exporter;
use Test::More;

Moose::Exporter->setup_import_methods(
    with_meta => [qw(with_prototype)],
    as_is     => [qw(as_is_prototype)],
);

sub with_prototype (&) {
    my ($class, $code) = @_;
    isa_ok($code, 'CODE', 'with_prototype received a coderef');
    $code->();
}

sub as_is_prototype (&) {
    my ($code) = @_;
    isa_ok($code, 'CODE', 'as_is_prototype received a coderef');
    $code->();
}

1;
package MyMooseB;

use Moose;

1;package MyMooseA;

use Moose;

has 'b' => (is => 'rw', isa => 'MyMooseB');

1;package Bar7::Meta::Trait;
use Moose::Role;

around _immutable_options => sub { };

no Moose::Role;

1;
package Bar7::Meta::Trait2;
use Moose::Role;

has foo => (
    traits  => ['Array'],
    handles => {
        push_foo => 'push',
    },
);

no Moose::Role;

1;
package Moose::Meta::Attribute::Custom::Bar;

sub register_implementation { 'My::Bar' }


package My::Bar;

use Moose::Role;

1;
package Moose::Meta::Attribute::Custom::Foo;

use Moose::Role;

1;
package Moose::Meta::Attribute::Custom::Trait::Bar;

sub register_implementation { 'My::Trait::Bar' }


package My::Trait::Bar;

use Moose::Role;

1;
package Moose::Meta::Attribute::Custom::Trait::Foo;

use Moose::Role;

1;
package # hide the package from PAUSE
    ArrayBasedStorage::Instance;

use strict;
use warnings;
use Scalar::Util qw/refaddr/;

use Carp 'confess';

our $VERSION = '0.01';
my $unbound = \'empty-slot-value';

use parent 'Class::MOP::Instance';

sub new {
    my ($class, $meta, @attrs) = @_;
    my $self = $class->SUPER::new($meta, @attrs);
    my $index = 0;
    $self->{'slot_index_map'} = { map { $_ => $index++ } $self->get_all_slots };
    return $self;
}

sub create_instance {
    my $self = shift;
    my $instance = bless [], $self->_class_name;
    $self->initialize_all_slots($instance);
    return $instance;
}

sub clone_instance {
    my ($self, $instance) = shift;
    $self->bless_instance_structure([ @$instance ]);
}

# operations on meta instance

sub get_slot_index_map { (shift)->{'slot_index_map'} }

sub initialize_slot {
    my ($self, $instance, $slot_name) = @_;
    $self->set_slot_value($instance, $slot_name, $unbound);
}

sub deinitialize_slot {
    my ( $self, $instance, $slot_name ) = @_;
    $self->set_slot_value($instance, $slot_name, $unbound);
}

sub get_all_slots {
    my $self = shift;
    return sort $self->SUPER::get_all_slots;
}

sub get_slot_value {
    my ($self, $instance, $slot_name) = @_;
    my $value = $instance->[ $self->{'slot_index_map'}->{$slot_name} ];
    return $value unless ref $value;
    refaddr $value eq refaddr $unbound ? undef : $value;
}

sub set_slot_value {
    my ($self, $instance, $slot_name, $value) = @_;
    $instance->[ $self->{'slot_index_map'}->{$slot_name} ] = $value;
}

sub is_slot_initialized {
    my ($self, $instance, $slot_name) = @_;
    # NOTE: maybe use CLOS's *special-unbound-value* for this?
    my $value = $instance->[ $self->{'slot_index_map'}->{$slot_name} ];
    return 1 unless ref $value;
    refaddr $value eq refaddr $unbound ? 0 : 1;
}

sub is_dependent_on_superclasses { 1 }

1;

package MyMetaClass::Instance;

use strict;
use warnings;

use parent 'Class::MOP::Instance';

1;
package MyMetaClass::Method;

use strict;
use warnings;

use parent 'Class::MOP::Method';

1;
package MyMetaClass::Random;

use strict;
use warnings;

1;
package MyMetaClass::Attribute;

use strict;
use warnings;

use parent 'Class::MOP::Attribute';

1;
package # hide the package from PAUSE
    InstanceCountingClass;

use strict;
use warnings;

our $VERSION = '0.03';

use parent 'Class::MOP::Class';

InstanceCountingClass->meta->add_attribute('count' => (
    reader  => 'get_count',
    default => 0
));

InstanceCountingClass->meta->add_before_method_modifier('_construct_instance' => sub {
    my ($class) = @_;
    $class->{'count'}++;
});

1;

package # hide the package from PAUSE
    ClassEncapsulatedAttributes;

use strict;
use warnings;

our $VERSION = '0.06';

use parent 'Class::MOP::Class';

sub initialize {
    (shift)->SUPER::initialize(@_,
        # use the custom attribute metaclass here
        'attribute_metaclass' => 'ClassEncapsulatedAttributes::Attribute',
    );
}

sub construct_instance {
    my ($class, %params) = @_;

    my $meta_instance = $class->get_meta_instance;
    my $instance = $meta_instance->create_instance();

    # initialize *ALL* attributes, including masked ones (as opposed to applicable)
    foreach my $current_class ($class->class_precedence_list()) {
        my $meta = $current_class->meta;
        foreach my $attr_name ($meta->get_attribute_list()) {
            my $attr = $meta->get_attribute($attr_name);
            $attr->initialize_instance_slot($meta_instance, $instance, \%params);
        }
    }

    return $instance;
}

package # hide the package from PAUSE
    ClassEncapsulatedAttributes::Attribute;

use strict;
use warnings;

our $VERSION = '0.04';

use parent 'Class::MOP::Attribute';

# alter the way parameters are specified
sub initialize_instance_slot {
    my ($self, $meta_instance, $instance, $params) = @_;
    # if the attr has an init_arg, use that, otherwise,
    # use the attributes name itself as the init_arg
    my $init_arg = $self->init_arg();
    # try to fetch the init arg from the %params ...
    my $class = $self->associated_class;
    my $val;
    $val = $params->{$class->name}->{$init_arg}
        if exists $params->{$class->name} &&
           exists ${$params->{$class->name}}{$init_arg};
    # if nothing was in the %params, we can use the
    # attribute's default value (if it has one)
    if (!defined $val && $self->has_default) {
        $val = $self->default($instance);
    }

    # now add this to the instance structure
    $meta_instance->set_slot_value($instance, $self->name, $val);
}

sub name {
    my $self = shift;
    return ($self->associated_class->name . '::' . $self->SUPER::name)
}

1;

package # hide the package from PAUSE
    InsideOutClass::Attribute;

use strict;
use warnings;

our $VERSION = '0.02';

use Carp         'confess';
use Scalar::Util 'refaddr';

use parent 'Class::MOP::Attribute';

sub initialize_instance_slot {
    my ($self, $meta_instance, $instance, $params) = @_;
    my $init_arg = $self->init_arg;
    # try to fetch the init arg from the %params ...
    my $val;
    $val = $params->{$init_arg} if exists $params->{$init_arg};
    # if nothing was in the %params, we can use the
    # attribute's default value (if it has one)
    if (!defined $val && defined $self->default) {
        $val = $self->default($instance);
    }
    my $_meta_instance = $self->associated_class->get_meta_instance;
    $_meta_instance->initialize_slot($instance, $self->name);
    $_meta_instance->set_slot_value($instance, $self->name, $val);
}

sub accessor_metaclass { 'InsideOutClass::Method::Accessor' }

package # hide the package from PAUSE
    InsideOutClass::Method::Accessor;

use strict;
use warnings;

our $VERSION = '0.01';

use Carp         'confess';
use Scalar::Util 'refaddr';

use parent 'Class::MOP::Method::Accessor';

## Method generation helpers

sub _generate_accessor_method {
    my $attr       = (shift)->associated_attribute;
    my $meta_class = $attr->associated_class;
    my $attr_name  = $attr->name;
    return sub {
        my $meta_instance = $meta_class->get_meta_instance;
        $meta_instance->set_slot_value($_[0], $attr_name, $_[1]) if scalar(@_) == 2;
        $meta_instance->get_slot_value($_[0], $attr_name);
    };
}

sub _generate_reader_method {
    my $attr       = (shift)->associated_attribute;
    my $meta_class = $attr->associated_class;
    my $attr_name  = $attr->name;
    return sub {
        confess "Cannot assign a value to a read-only accessor" if @_ > 1;
        $meta_class->get_meta_instance
                   ->get_slot_value($_[0], $attr_name);
    };
}

sub _generate_writer_method {
    my $attr       = (shift)->associated_attribute;
    my $meta_class = $attr->associated_class;
    my $attr_name  = $attr->name;
    return sub {
        $meta_class->get_meta_instance
                   ->set_slot_value($_[0], $attr_name, $_[1]);
    };
}

sub _generate_predicate_method {
    my $attr       = (shift)->associated_attribute;
    my $meta_class = $attr->associated_class;
    my $attr_name  = $attr->name;
    return sub {
        defined $meta_class->get_meta_instance
                           ->get_slot_value($_[0], $attr_name) ? 1 : 0;
    };
}

package # hide the package from PAUSE
    InsideOutClass::Instance;

use strict;
use warnings;

our $VERSION = '0.01';

use Carp         'confess';
use Scalar::Util 'refaddr';

use parent 'Class::MOP::Instance';

sub create_instance {
    my ($self, $class) = @_;
        bless \(my $instance), $self->_class_name;
}

sub get_slot_value {
    my ($self, $instance, $slot_name) = @_;
    $self->associated_metaclass->get_package_symbol('%' . $slot_name)->{refaddr $instance};
}

sub set_slot_value {
    my ($self, $instance, $slot_name, $value) = @_;
    $self->associated_metaclass->get_package_symbol('%' . $slot_name)->{refaddr $instance} = $value;
}

sub initialize_slot {
    my ($self, $instance, $slot_name) = @_;
    $self->associated_metaclass->add_package_symbol(('%' . $slot_name) => {})
        unless $self->associated_metaclass->has_package_symbol('%' . $slot_name);
    $self->associated_metaclass->get_package_symbol('%' . $slot_name)->{refaddr $instance} = undef;
}

sub is_slot_initialized {
    my ($self, $instance, $slot_name) = @_;
    return 0 unless $self->associated_metaclass->has_package_symbol('%' . $slot_name);
    return exists $self->associated_metaclass->get_package_symbol('%' . $slot_name)->{refaddr $instance} ? 1 : 0;
}

1;

package # hide the package from PAUSE
    LazyClass::Attribute;

use strict;
use warnings;

use Carp 'confess';

our $VERSION = '0.05';

use parent 'Class::MOP::Attribute';

sub initialize_instance_slot {
    my ($self, $meta_instance, $instance, $params) = @_;

    # if the attr has an init_arg, use that, otherwise,
    # use the attributes name itself as the init_arg
    my $init_arg = $self->init_arg();

    if ( exists $params->{$init_arg} ) {
        my $val = $params->{$init_arg};
        $meta_instance->set_slot_value($instance, $self->name, $val);
    }
}

sub accessor_metaclass { 'LazyClass::Method::Accessor' }

package # hide the package from PAUSE
    LazyClass::Method::Accessor;

use strict;
use warnings;

use Carp 'confess';

our $VERSION = '0.01';

use parent 'Class::MOP::Method::Accessor';

sub _generate_accessor_method {
    my $attr = (shift)->associated_attribute;

    my $attr_name = $attr->name;
    my $meta_instance = $attr->associated_class->get_meta_instance;

    sub {
        if (scalar(@_) == 2) {
            $meta_instance->set_slot_value($_[0], $attr_name, $_[1]);
        }
        else {
            unless ( $meta_instance->is_slot_initialized($_[0], $attr_name) ) {
                my $value = $attr->has_default ? $attr->default($_[0]) : undef;
                $meta_instance->set_slot_value($_[0], $attr_name, $value);
            }

            $meta_instance->get_slot_value($_[0], $attr_name);
        }
    };
}

sub _generate_reader_method {
    my $attr = (shift)->associated_attribute;

    my $attr_name = $attr->name;
    my $meta_instance = $attr->associated_class->get_meta_instance;

    sub {
        confess "Cannot assign a value to a read-only accessor" if @_ > 1;

        unless ( $meta_instance->is_slot_initialized($_[0], $attr_name) ) {
            my $value = $attr->has_default ? $attr->default($_[0]) : undef;
            $meta_instance->set_slot_value($_[0], $attr_name, $value);
        }

        $meta_instance->get_slot_value($_[0], $attr_name);
    };
}

package # hide the package from PAUSE
    LazyClass::Instance;

use strict;
use warnings;

our $VERSION = '0.01';

use parent 'Class::MOP::Instance';

sub initialize_all_slots {}

1;

package MyMetaClass;

use strict;
use warnings;

use parent 'Class::MOP::Class';

sub mymetaclass_attributes{
  my $self = shift;
  return grep { $_->isa("MyMetaClass::Attribute") }
    $self->get_all_attributes;
}

1;
package # hide from PAUSE
    C3MethodDispatchOrder;

use strict;
use warnings;

use Carp 'confess';
use Algorithm::C3;

our $VERSION = '0.03';

use parent 'Class::MOP::Class';

my $_find_method = sub {
    my ($class, $method) = @_;
    foreach my $super ($class->class_precedence_list) {
        return $super->meta->get_method($method)
            if $super->meta->has_method($method);
    }
};

C3MethodDispatchOrder->meta->add_around_method_modifier('initialize' => sub {
    my $cont = shift;
    my $meta = $cont->(@_);

    # we need to look at $AUTOLOAD in the package where the coderef belongs
    # if subname works, then it'll be where this AUTOLOAD method was installed
    # otherwise, it'll be $C3MethodDispatchOrder::AUTOLOAD. get_code_info
    # tells us where AUTOLOAD will look
    my $autoload;
    $autoload = sub {
        my ($package) = Class::MOP::get_code_info($autoload);
        my $label = ${ $package->meta->get_package_symbol('$AUTOLOAD') };
        my $method_name = (split /\:\:/ => $label)[-1];
        my $method = $_find_method->($_[0]->meta, $method_name);
        (defined $method) || confess "Method ($method_name) not found";
        goto &$method;
    };

    $meta->add_method('AUTOLOAD' => $autoload)
        unless $meta->has_method('AUTOLOAD');

    $meta->add_method('can' => sub {
        $_find_method->($_[0]->meta, $_[1]);
    }) unless $meta->has_method('can');

    return $meta;
});

sub superclasses {
    my $self = shift;

    $self->add_package_symbol('@SUPERS' => [])
        unless $self->has_package_symbol('@SUPERS');

    if (@_) {
        my @supers = @_;
        @{$self->get_package_symbol('@SUPERS')} = @supers;
    }
    @{$self->get_package_symbol('@SUPERS')};
}

sub class_precedence_list {
    my $self = shift;
    return map {
        $_->name;
    } Algorithm::C3::merge($self, sub {
        my $class = shift;
        map { $_->meta } $class->superclasses;
    });
}

1;

package SyntaxError;
use strict;
use warnings;

# this syntax error is intentional!

    {

1;
package # hide the package from PAUSE
    Perl6Attribute;

use strict;
use warnings;

our $VERSION = '0.02';

use parent 'Class::MOP::Attribute';

Perl6Attribute->meta->add_around_method_modifier('new' => sub {
    my $cont = shift;
    my ($class, $attribute_name, %options) = @_;

    # extract the sigil and accessor name
    my ($sigil, $accessor_name) = ($attribute_name =~ /^([\$\@\%])\.(.*)$/);

    # pass the accessor name
    $options{accessor} = $accessor_name;

    # create a default value based on the sigil
    $options{default} = sub { [] } if ($sigil eq '@');
    $options{default} = sub { {} } if ($sigil eq '%');

    $cont->($class, $attribute_name, %options);
});

1;

package BinaryTree;

use strict;
use warnings;
use Carp qw/confess/;

use metaclass;

our $VERSION = '0.02';

BinaryTree->meta->add_attribute('uid' => (
    reader  => 'getUID',
    writer  => 'setUID',
    default => sub {
        my $instance = shift;
        ("$instance" =~ /\((.*?)\)$/)[0];
    }
));

BinaryTree->meta->add_attribute('node' => (
    reader   => 'getNodeValue',
    writer   => 'setNodeValue',
    clearer  => 'clearNodeValue',
    init_arg => ':node'
));

BinaryTree->meta->add_attribute('parent' => (
    predicate => 'hasParent',
    reader    => 'getParent',
    writer    => 'setParent',
    clearer   => 'clearParent',
));

BinaryTree->meta->add_attribute('left' => (
    predicate => 'hasLeft',
    clearer   => 'clearLeft',
    reader    => 'getLeft',
    writer => {
        'setLeft' => sub {
            my ($self, $tree) = @_;
            confess "undef left" unless defined $tree;
                $tree->setParent($self) if defined $tree;
            $self->{'left'} = $tree;
            $self;
        }
   },
));

BinaryTree->meta->add_attribute('right' => (
    predicate => 'hasRight',
    clearer   => 'clearRight',
    reader    => 'getRight',
    writer => {
        'setRight' => sub {
            my ($self, $tree) = @_;
            confess "undef right" unless defined $tree;
                $tree->setParent($self) if defined $tree;
            $self->{'right'} = $tree;
            $self;
        }
    }
));

sub new {
    my $class = shift;
    $class->meta->new_object(':node' => shift);
}

sub removeLeft {
    my ($self) = @_;
    my $left = $self->getLeft();
    $left->clearParent;
    $self->clearLeft;
    return $left;
}

sub removeRight {
    my ($self) = @_;
    my $right = $self->getRight;
    $right->clearParent;
    $self->clearRight;
    return $right;
}

sub isLeaf {
        my ($self) = @_;
        return (!$self->hasLeft && !$self->hasRight);
}

sub isRoot {
        my ($self) = @_;
        return !$self->hasParent;
}

sub traverse {
        my ($self, $func) = @_;
    $func->($self);
    $self->getLeft->traverse($func)  if $self->hasLeft;
    $self->getRight->traverse($func) if $self->hasRight;
}

sub mirror {
    my ($self) = @_;
    # swap left for right
    if( $self->hasLeft && $self->hasRight) {
      my $left = $self->getLeft;
      my $right = $self->getRight;
      $self->setLeft($right);
      $self->setRight($left);
    } elsif( $self->hasLeft && !$self->hasRight){
      my $left = $self->getLeft;
      $self->clearLeft;
      $self->setRight($left);
    } elsif( !$self->hasLeft && $self->hasRight){
      my $right = $self->getRight;
      $self->clearRight;
      $self->setLeft($right);
    }

    # and recurse
    $self->getLeft->mirror  if $self->hasLeft;
    $self->getRight->mirror if $self->hasRight;
    $self;
}

sub size {
    my ($self) = @_;
    my $size = 1;
    $size += $self->getLeft->size  if $self->hasLeft;
    $size += $self->getRight->size if $self->hasRight;
    return $size;
}

sub height {
    my ($self) = @_;
    my ($left_height, $right_height) = (0, 0);
    $left_height = $self->getLeft->height()   if $self->hasLeft();
    $right_height = $self->getRight->height() if $self->hasRight();
    return 1 + (($left_height > $right_height) ? $left_height : $right_height);
}

1;
package # hide the package from PAUSE
    AttributesWithHistory;

use strict;
use warnings;

our $VERSION = '0.05';

use parent 'Class::MOP::Attribute';

# this is for an extra attribute constructor
# option, which is to be able to create a
# way for the class to access the history
AttributesWithHistory->meta->add_attribute('history_accessor' => (
    reader    => 'history_accessor',
    init_arg  => 'history_accessor',
    predicate => 'has_history_accessor',
));

# this is a place to store the actual
# history of the attribute
AttributesWithHistory->meta->add_attribute('_history' => (
    accessor => '_history',
    default  => sub { {} },
));

sub accessor_metaclass { 'AttributesWithHistory::Method::Accessor' }

AttributesWithHistory->meta->add_after_method_modifier('install_accessors' => sub {
    my ($self) = @_;
    # and now add the history accessor
    $self->associated_class->add_method(
        $self->_process_accessors('history_accessor' => $self->history_accessor())
    ) if $self->has_history_accessor();
});

package # hide the package from PAUSE
    AttributesWithHistory::Method::Accessor;

use strict;
use warnings;

our $VERSION = '0.01';

use parent 'Class::MOP::Method::Accessor';

# generate the methods

sub _generate_history_accessor_method {
    my $attr_name = (shift)->associated_attribute->name;
    eval qq{sub {
        unless (ref \$_[0]->meta->get_attribute('$attr_name')->_history()->\{\$_[0]\}) \{
            \$_[0]->meta->get_attribute('$attr_name')->_history()->\{\$_[0]\} = [];
        \}
        \@\{\$_[0]->meta->get_attribute('$attr_name')->_history()->\{\$_[0]\}\};
    }};
}

sub _generate_accessor_method {
    my $attr_name = (shift)->associated_attribute->name;
    eval qq{sub {
        if (scalar(\@_) == 2) {
            unless (ref \$_[0]->meta->get_attribute('$attr_name')->_history()->\{\$_[0]\}) \{
                \$_[0]->meta->get_attribute('$attr_name')->_history()->\{\$_[0]\} = [];
            \}
            push \@\{\$_[0]->meta->get_attribute('$attr_name')->_history()->\{\$_[0]\}\} => \$_[1];
            \$_[0]->{'$attr_name'} = \$_[1];
        }
        \$_[0]->{'$attr_name'};
    }};
}

sub _generate_writer_method {
    my $attr_name = (shift)->associated_attribute->name;
    eval qq{sub {
        unless (ref \$_[0]->meta->get_attribute('$attr_name')->_history()->\{\$_[0]\}) \{
            \$_[0]->meta->get_attribute('$attr_name')->_history()->\{\$_[0]\} = [];
        \}
        push \@\{\$_[0]->meta->get_attribute('$attr_name')->_history()->\{\$_[0]\}\} => \$_[1];
        \$_[0]->{'$attr_name'} = \$_[1];
    }};
}

1;

=pod

=head1 NAME

AttributesWithHistory - An example attribute metaclass which keeps a history of changes

=head1 SYSNOPSIS

  package Foo;

  Foo->meta->add_attribute(AttributesWithHistory->new('foo' => (
      accessor         => 'foo',
      history_accessor => 'get_foo_history',
  )));

  Foo->meta->add_attribute(AttributesWithHistory->new('bar' => (
      reader           => 'get_bar',
      writer           => 'set_bar',
      history_accessor => 'get_bar_history',
  )));

  sub new  {
      my $class = shift;
      $class->meta->new_object(@_);
  }

=head1 DESCRIPTION

This is an example of an attribute metaclass which keeps a
record of all the values it has been assigned. It stores the
history as a field in the attribute meta-object, and will
autogenerate a means of accessing that history for the class
which these attributes are added too.

=head1 AUTHORS

Stevan Little E<lt>stevan@iinteractive.comE<gt>

Yuval Kogman E<lt>nothingmuch@woobling.comE<gt>

=cut
package metaclass;
our $VERSION = '2.2204';

use strict;
use warnings;

use Module::Runtime 'use_package_optimistically', 'use_module';
use Class::MOP;

sub import {
    my ( $class, @args ) = @_;

    unshift @args, "metaclass" if @args % 2 == 1;
    my %options = @args;

    my $meta_name = exists $options{meta_name} ? $options{meta_name} : 'meta';
    my $metaclass = delete $options{metaclass};

    unless ( defined $metaclass ) {
        $metaclass = "Class::MOP::Class";
    } else {
        use_package_optimistically($metaclass);
    }

    ($metaclass->isa('Class::MOP::Class'))
        || die use_module('Moose::Exception::MetaclassMustBeDerivedFromClassMOPClass')->new( class_name => $metaclass );

    # make sure the custom metaclasses get loaded
    foreach my $key (grep { /_(?:meta)?class$/ } keys %options) {
        unless ( ref( my $class = $options{$key} ) ) {
            use_package_optimistically($class)
        }
    }

    my $package = caller();

    # create a meta object so we can install &meta
    my $meta = $metaclass->initialize($package => %options);
    $meta->_add_meta_method($meta_name)
        if defined $meta_name;
}

1;

# ABSTRACT: a pragma for installing and using Class::MOP metaclasses

package oose;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Util ();

BEGIN {
    my $package;
    sub import {
        $package = $_[1] || 'Class';
        if ($package =~ /^\+/) {
            $package =~ s/^\+//;
            Moose::Util::_load_user_class($package);
        }
    }
    use Filter::Simple sub { s/^/package $package;\nuse Moose;use Moose::Util::TypeConstraints;\n/; }
}

1;

# ABSTRACT: syntactic sugar to make Moose one-liners easier

package Class::MOP::Package;
our $VERSION = '2.2204';

use strict;
use warnings;

use Scalar::Util 'blessed', 'weaken';
use Devel::GlobalDestruction 'in_global_destruction';
use Module::Runtime 'module_notional_filename';
use Package::Stash;

use parent 'Class::MOP::Object';

# creation ...

sub initialize {
    my ( $class, @args ) = @_;

    unshift @args, "package" if @args % 2;

    my %options = @args;
    my $package_name = delete $options{package};

    # we hand-construct the class until we can bootstrap it
    if ( my $meta = Class::MOP::get_metaclass_by_name($package_name) ) {
        return $meta;
    } else {
        my $meta = ( ref $class || $class )->_new({
            'package'   => $package_name,
            %options,
        });
        Class::MOP::store_metaclass_by_name($package_name, $meta);

        Class::MOP::weaken_metaclass($package_name) if $options{weaken};


        return $meta;
    }
}

sub reinitialize {
    my ( $class, @args ) = @_;

    unshift @args, "package" if @args % 2;

    my %options = @args;
    my $package_name = delete $options{package};

    (defined $package_name && $package_name
      && (!blessed $package_name || $package_name->isa('Class::MOP::Package')))
        || $class->_throw_exception( MustPassAPackageNameOrAnExistingClassMOPPackageInstance => params => \%options,
                                                                                       class  => $class
                          );

    $package_name = $package_name->name
        if blessed $package_name;

    Class::MOP::remove_metaclass_by_name($package_name);

    $class->initialize($package_name, %options); # call with first arg form for compat
}

sub create {
    my $class = shift;
    my @args = @_;

    my $meta = $class->initialize(@args);
    my $filename = module_notional_filename($meta->name);
    $INC{$filename} = '(set by Moose)'
        unless exists $INC{$filename};

    return $meta;
}

## ANON packages

{
    # NOTE:
    # this should be sufficient, if you have a
    # use case where it is not, write a test and
    # I will change it.
    my $ANON_SERIAL = 0;

    my %ANON_PACKAGE_CACHE;

    # NOTE:
    # we need a sufficiently annoying prefix
    # this should suffice for now, this is
    # used in a couple of places below, so
    # need to put it up here for now.
    sub _anon_package_prefix { 'Class::MOP::Package::__ANON__::SERIAL::' }

    sub is_anon {
        my $self = shift;
        no warnings 'uninitialized';
        my $prefix = $self->_anon_package_prefix;
        $self->name =~ /^\Q$prefix/;
    }

    sub create_anon {
        my ($class, %options) = @_;

        my $cache_ok = delete $options{cache};
        $options{weaken} = !$cache_ok unless exists $options{weaken};

        my $cache_key;
        if ($cache_ok) {
            $cache_key = $class->_anon_cache_key(%options);
            undef $cache_ok if !defined($cache_key);
        }

        if ($cache_ok) {
            if (defined $ANON_PACKAGE_CACHE{$cache_key}) {
                return $ANON_PACKAGE_CACHE{$cache_key};
            }
        }

        my $package_name = $class->_anon_package_prefix . ++$ANON_SERIAL;

        my $meta = $class->create($package_name, %options);

        if ($cache_ok) {
            $ANON_PACKAGE_CACHE{$cache_key} = $meta;
            weaken($ANON_PACKAGE_CACHE{$cache_key});
        }

        return $meta;
    }

    sub _anon_cache_key {
        my $class = shift;
        my %options = @_;
        $class->_throw_exception( PackagesAndModulesAreNotCachable => class_name => $class,
                                                             params     => \%options,
                                                             is_module  => 0
                       );
    }

    sub DESTROY {
        my $self = shift;

        return if in_global_destruction(); # it'll happen soon anyway and this just makes things more complicated

        $self->_free_anon
            if $self->is_anon;
    }

    sub _free_anon {
        my $self = shift;
        my $name = $self->name;

        # Moose does a weird thing where it replaces the metaclass for
        # class when fixing metaclass incompatibility. In that case,
        # we don't want to clean out the namespace now. We can detect
        # that because Moose will explicitly update the singleton
        # cache in Class::MOP using store_metaclass_by_name, which
        # means that the new metaclass will already exist in the cache
        # by this point.
        # The other options here are that $current_meta can be undef if
        # remove_metaclass_by_name is called explicitly (since the hash
        # entry is removed first, and then this destructor is called),
        # or that $current_meta can be the same as $self, which happens
        # when the metaclass goes out of scope (since the weak reference
        # in the metaclass cache won't be freed until after this
        # destructor runs).
        my $current_meta = Class::MOP::get_metaclass_by_name($name);
        return if defined($current_meta) && $current_meta ne $self;

        my ($first_fragments, $last_fragment) = ($name =~ /^(.*)::(.*)$/);

        no strict 'refs';
        # clear @ISA first, to avoid a memory leak
        # see https://rt.perl.org/rt3/Public/Bug/Display.html?id=92708
        @{$name . '::ISA'} = ();
        %{$name . '::'}    = ();
        delete ${$first_fragments . '::'}{$last_fragment . '::'};

        Class::MOP::remove_metaclass_by_name($name);

        delete $INC{module_notional_filename($name)};
    }

}

sub _new {
    my $class = shift;

    return Class::MOP::Class->initialize($class)->new_object(@_)
        if $class ne __PACKAGE__;

    my $params = @_ == 1 ? $_[0] : {@_};

    return bless {
        # Need to quote package to avoid a problem with PPI mis-parsing this
        # as a package statement.
        'package' => $params->{package},

        # NOTE:
        # because of issues with the Perl API
        # to the typeglob in some versions, we
        # need to just always grab a new
        # reference to the hash in the accessor.
        # Ideally we could just store a ref and
        # it would Just Work, but oh well :\

        namespace => \undef,

    } => $class;
}

# Attributes

# NOTE:
# all these attribute readers will be bootstrapped
# away in the Class::MOP bootstrap section

sub _package_stash {
    $_[0]->{_package_stash} ||= Package::Stash->new($_[0]->name)
}
sub namespace {
    $_[0]->_package_stash->namespace
}

# Class attributes

# ... these functions have to touch the symbol table itself,.. yuk

sub add_package_symbol {
    my $self = shift;
    $self->_package_stash->add_symbol(@_);
}

sub remove_package_glob {
    my $self = shift;
    $self->_package_stash->remove_glob(@_);
}

# ... these functions deal with stuff on the namespace level

sub has_package_symbol {
    my $self = shift;
    $self->_package_stash->has_symbol(@_);
}

sub get_package_symbol {
    my $self = shift;
    $self->_package_stash->get_symbol(@_);
}

sub get_or_add_package_symbol {
    my $self = shift;
    $self->_package_stash->get_or_add_symbol(@_);
}

sub remove_package_symbol {
    my $self = shift;
    $self->_package_stash->remove_symbol(@_);
}

sub list_all_package_symbols {
    my $self = shift;
    $self->_package_stash->list_all_symbols(@_);
}

sub get_all_package_symbols {
    my $self = shift;
    $self->_package_stash->get_all_symbols(@_);
}

1;

# ABSTRACT: Package Meta Object

package Class::MOP::MiniTrait;
our $VERSION = '2.2204';

use strict;
use warnings;

use Module::Runtime 'use_package_optimistically';

sub apply {
    my ( $to_class, $trait ) = @_;

    for ( grep { !ref } $to_class, $trait ) {
        use_package_optimistically($_);
        $_ = Class::MOP::Class->initialize($_);
    }

    for my $meth ( grep { $_->package_name ne 'UNIVERSAL' } $trait->get_all_methods ) {
        my $meth_name = $meth->name;
        next if index($meth_name, '__') == 0;   # skip private subs

        if ( $to_class->find_method_by_name($meth_name) ) {
            $to_class->add_around_method_modifier( $meth_name, $meth->body );
        }
        else {
            $to_class->add_method( $meth_name, $meth->clone );
        }
    }
}

# We can't load this with use, since it may be loaded and used from Class::MOP
# (via Class::MOP::Class, etc). However, if for some reason this module is loaded
# _without_ first loading Class::MOP we need to require Class::MOP so we can
# use it and Class::MOP::Class.
require Class::MOP;

1;

# ABSTRACT: Extremely limited trait application

package Class::MOP::Instance;
our $VERSION = '2.2204';

use strict;
use warnings;

use Scalar::Util 'isweak', 'weaken', 'blessed';

use parent 'Class::MOP::Object';

# make this not a valid method name, to avoid (most) attribute conflicts
my $RESERVED_MOP_SLOT = '<<MOP>>';

sub BUILDARGS {
    my ($class, @args) = @_;

    if ( @args == 1 ) {
        unshift @args, "associated_metaclass";
    } elsif ( @args >= 2 && blessed($args[0]) && $args[0]->isa("Class::MOP::Class") ) {
        # compat mode
        my ( $meta, @attrs ) = @args;
        @args = ( associated_metaclass => $meta, attributes => \@attrs );
    }

    my %options = @args;
    # FIXME lazy_build
    $options{slots} ||= [ map { $_->slots } @{ $options{attributes} || [] } ];
    $options{slot_hash} = { map { $_ => undef } @{ $options{slots} } }; # FIXME lazy_build

    return \%options;
}

sub new {
    my $class = shift;
    my $options = $class->BUILDARGS(@_);

    # FIXME replace with a proper constructor
    my $instance = $class->_new(%$options);

    # FIXME weak_ref => 1,
    weaken($instance->{'associated_metaclass'});

    return $instance;
}

sub _new {
    my $class = shift;
    return Class::MOP::Class->initialize($class)->new_object(@_)
      if $class ne __PACKAGE__;

    my $params = @_ == 1 ? $_[0] : {@_};
    return bless {
        # NOTE:
        # I am not sure that it makes
        # sense to pass in the meta
        # The ideal would be to just
        # pass in the class name, but
        # that is placing too much of
        # an assumption on bless(),
        # which is *probably* a safe
        # assumption,.. but you can
        # never tell <:)
        'associated_metaclass' => $params->{associated_metaclass},
        'attributes'           => $params->{attributes},
        'slots'                => $params->{slots},
        'slot_hash'            => $params->{slot_hash},
    } => $class;
}

sub _class_name { $_[0]->{_class_name} ||= $_[0]->associated_metaclass->name }

sub create_instance {
    my $self = shift;
    bless {}, $self->_class_name;
}

sub clone_instance {
    my ($self, $instance) = @_;

    my $clone = $self->create_instance;
    for my $attr ($self->get_all_attributes) {
        next unless $attr->has_value($instance);
        for my $slot ($attr->slots) {
            my $val = $self->get_slot_value($instance, $slot);
            $self->set_slot_value($clone, $slot, $val);
            $self->weaken_slot_value($clone, $slot)
                if $self->slot_value_is_weak($instance, $slot);
        }
    }

    $self->_set_mop_slot($clone, $self->_get_mop_slot($instance))
        if $self->_has_mop_slot($instance);

    return $clone;
}

# operations on meta instance

sub get_all_slots {
    my $self = shift;
    return @{$self->{'slots'}};
}

sub get_all_attributes {
    my $self = shift;
    return @{$self->{attributes}};
}

sub is_valid_slot {
    my ($self, $slot_name) = @_;
    exists $self->{'slot_hash'}->{$slot_name};
}

# operations on created instances

sub get_slot_value {
    my ($self, $instance, $slot_name) = @_;
    $instance->{$slot_name};
}

sub set_slot_value {
    my ($self, $instance, $slot_name, $value) = @_;
    $instance->{$slot_name} = $value;
}

sub initialize_slot {
    my ($self, $instance, $slot_name) = @_;
    return;
}

sub deinitialize_slot {
    my ( $self, $instance, $slot_name ) = @_;
    delete $instance->{$slot_name};
}

sub initialize_all_slots {
    my ($self, $instance) = @_;
    foreach my $slot_name ($self->get_all_slots) {
        $self->initialize_slot($instance, $slot_name);
    }
}

sub deinitialize_all_slots {
    my ($self, $instance) = @_;
    foreach my $slot_name ($self->get_all_slots) {
        $self->deinitialize_slot($instance, $slot_name);
    }
}

sub is_slot_initialized {
    my ($self, $instance, $slot_name, $value) = @_;
    exists $instance->{$slot_name};
}

sub weaken_slot_value {
    my ($self, $instance, $slot_name) = @_;
    weaken $instance->{$slot_name};
}

sub slot_value_is_weak {
    my ($self, $instance, $slot_name) = @_;
    isweak $instance->{$slot_name};
}

sub strengthen_slot_value {
    my ($self, $instance, $slot_name) = @_;
    $self->set_slot_value($instance, $slot_name, $self->get_slot_value($instance, $slot_name));
}

sub rebless_instance_structure {
    my ($self, $instance, $metaclass) = @_;

    # we use $_[1] here because of t/cmop/rebless_overload.t regressions
    # on 5.8.8
    bless $_[1], $metaclass->name;
}

sub is_dependent_on_superclasses {
    return; # for meta instances that require updates on inherited slot changes
}

sub _get_mop_slot {
    my ($self, $instance) = @_;
    $self->get_slot_value($instance, $RESERVED_MOP_SLOT);
}

sub _has_mop_slot {
    my ($self, $instance) = @_;
    $self->is_slot_initialized($instance, $RESERVED_MOP_SLOT);
}

sub _set_mop_slot {
    my ($self, $instance, $value) = @_;
    $self->set_slot_value($instance, $RESERVED_MOP_SLOT, $value);
}

sub _clear_mop_slot {
    my ($self, $instance) = @_;
    $self->deinitialize_slot($instance, $RESERVED_MOP_SLOT);
}

# inlinable operation snippets

sub is_inlinable { 1 }

sub inline_create_instance {
    my ($self, $class_variable) = @_;
    'bless {} => ' . $class_variable;
}

sub inline_slot_access {
    my ($self, $instance, $slot_name) = @_;
    sprintf q[%s->{"%s"}], $instance, quotemeta($slot_name);
}

sub inline_get_is_lvalue { 1 }

sub inline_get_slot_value {
    my ($self, $instance, $slot_name) = @_;
    $self->inline_slot_access($instance, $slot_name);
}

sub inline_set_slot_value {
    my ($self, $instance, $slot_name, $value) = @_;
    $self->inline_slot_access($instance, $slot_name) . " = $value",
}

sub inline_initialize_slot {
    my ($self, $instance, $slot_name) = @_;
    return '';
}

sub inline_deinitialize_slot {
    my ($self, $instance, $slot_name) = @_;
    "delete " . $self->inline_slot_access($instance, $slot_name);
}
sub inline_is_slot_initialized {
    my ($self, $instance, $slot_name) = @_;
    "exists " . $self->inline_slot_access($instance, $slot_name);
}

sub inline_weaken_slot_value {
    my ($self, $instance, $slot_name) = @_;
    sprintf "Scalar::Util::weaken( %s )", $self->inline_slot_access($instance, $slot_name);
}

sub inline_strengthen_slot_value {
    my ($self, $instance, $slot_name) = @_;
    $self->inline_set_slot_value($instance, $slot_name, $self->inline_slot_access($instance, $slot_name));
}

sub inline_rebless_instance_structure {
    my ($self, $instance, $class_variable) = @_;
    "bless $instance => $class_variable";
}

sub _inline_get_mop_slot {
    my ($self, $instance) = @_;
    $self->inline_get_slot_value($instance, $RESERVED_MOP_SLOT);
}

sub _inline_set_mop_slot {
    my ($self, $instance, $value) = @_;
    $self->inline_set_slot_value($instance, $RESERVED_MOP_SLOT, $value);
}

sub _inline_clear_mop_slot {
    my ($self, $instance) = @_;
    $self->inline_deinitialize_slot($instance, $RESERVED_MOP_SLOT);
}

1;

# ABSTRACT: Instance Meta Object

package Class::MOP::Overload;
our $VERSION = '2.2204';

use strict;
use warnings;

use overload ();
use Scalar::Util qw( blessed weaken );
use Try::Tiny;

use parent 'Class::MOP::Object';

my %Operators = (
    map { $_ => 1 }
    grep { $_ ne 'fallback' }
    map  { split /\s+/ } values %overload::ops
);

sub new {
    my ( $class, %params ) = @_;

    unless ( defined $params{operator} ) {
        $class->_throw_exception('OverloadRequiresAnOperator');
    }
    unless ( $Operators{ $params{operator} } ) {
        $class->_throw_exception(
            'InvalidOverloadOperator',
            operator => $params{operator},
        );
    }

    unless ( defined $params{method_name} || $params{coderef} ) {
        $class->_throw_exception(
            'OverloadRequiresAMethodNameOrCoderef',
            operator => $params{operator},
        );
    }

    if ( $params{coderef} ) {
        unless ( defined $params{coderef_package}
            && defined $params{coderef_name} ) {

            $class->_throw_exception('OverloadRequiresNamesForCoderef');
        }
    }

    if ( $params{method}
        && !try { $params{method}->isa('Class::MOP::Method') } ) {

        $class->_throw_exception('OverloadRequiresAMetaMethod');
    }

    if ( $params{associated_metaclass}
        && !try { $params{associated_metaclass}->isa('Class::MOP::Module') } )
    {

        $class->_throw_exception('OverloadRequiresAMetaClass');
    }

    my @optional_attrs
        = qw( method_name coderef coderef_package coderef_name method associated_metaclass );

    return bless {
        operator => $params{operator},
        map { defined $params{$_} ? ( $_ => $params{$_} ) : () }
            @optional_attrs
        },
        $class;
}

sub operator { $_[0]->{operator} }

sub method_name { $_[0]->{method_name} }
sub has_method_name { exists $_[0]->{method_name} }

sub method { $_[0]->{method} }
sub has_method { exists $_[0]->{method} }

sub coderef { $_[0]->{coderef} }
sub has_coderef { exists $_[0]->{coderef} }

sub coderef_package { $_[0]->{coderef_package} }
sub has_coderef_package { exists $_[0]->{coderef_package} }

sub coderef_name { $_[0]->{coderef_name} }
sub has_coderef_name { exists $_[0]->{coderef_name} }

sub associated_metaclass { $_[0]->{associated_metaclass} }

sub is_anonymous {
    my $self = shift;
    return $self->has_coderef && $self->coderef_name eq '__ANON__';
}

sub attach_to_class {
    my ( $self, $class ) = @_;
    $self->{associated_metaclass} = $class;
    weaken $self->{associated_metaclass};
}

sub clone {
    my $self = shift;

    my $clone = bless { %{$self}, @_ }, blessed($self);
    weaken $clone->{associated_metaclass} if $clone->{associated_metaclass};

    $clone->_set_original_overload($self);

    return $clone;
}

sub original_overload { $_[0]->{original_overload} }
sub _set_original_overload { $_[0]->{original_overload} = $_[1] }

sub _is_equal_to {
    my $self  = shift;
    my $other = shift;

    if ( $self->has_coderef ) {
        return unless $other->has_coderef;
        return $self->coderef == $other->coderef;
    }
    else {
        return $self->method_name eq $other->method_name;
    }
}

1;

# ABSTRACT: Overload Meta Object

package Class::MOP::Mixin::HasAttributes;
our $VERSION = '2.2204';

use strict;
use warnings;

use Scalar::Util 'blessed';

use parent 'Class::MOP::Mixin';

sub add_attribute {
    my $self = shift;

    my $attribute
        = blessed( $_[0] ) ? $_[0] : $self->attribute_metaclass->new(@_);

    ( $attribute->isa('Class::MOP::Mixin::AttributeCore') )
        || $self->_throw_exception( AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass => attribute  => $attribute,
                                                                                     class_name => $self->name,
                          );

    $self->_attach_attribute($attribute);

    my $attr_name = $attribute->name;

    $self->remove_attribute($attr_name)
        if $self->has_attribute($attr_name);

    my $order = ( scalar keys %{ $self->_attribute_map } );
    $attribute->_set_insertion_order($order);

    $self->_attribute_map->{$attr_name} = $attribute;

    # This method is called to allow for installing accessors. Ideally, we'd
    # use method overriding, but then the subclass would be responsible for
    # making the attribute, which would end up with lots of code
    # duplication. Even more ideally, we'd use augment/inner, but this is
    # Class::MOP!
    $self->_post_add_attribute($attribute)
        if $self->can('_post_add_attribute');

    return $attribute;
}

sub has_attribute {
    my ( $self, $attribute_name ) = @_;

    ( defined $attribute_name )
        || $self->_throw_exception( MustDefineAnAttributeName => class_name => $self->name );

    exists $self->_attribute_map->{$attribute_name};
}

sub get_attribute {
    my ( $self, $attribute_name ) = @_;

    ( defined $attribute_name )
        || $self->_throw_exception( MustDefineAnAttributeName => class_name => $self->name );

    return $self->_attribute_map->{$attribute_name};
}

sub remove_attribute {
    my ( $self, $attribute_name ) = @_;

    ( defined $attribute_name )
        || $self->_throw_exception( MustDefineAnAttributeName => class_name => $self->name );

    my $removed_attribute = $self->_attribute_map->{$attribute_name};
    return unless defined $removed_attribute;

    delete $self->_attribute_map->{$attribute_name};

    return $removed_attribute;
}

sub get_attribute_list {
    my $self = shift;
    keys %{ $self->_attribute_map };
}

sub _restore_metaattributes_from {
    my $self = shift;
    my ($old_meta) = @_;

    for my $attr (sort { $a->insertion_order <=> $b->insertion_order }
                       map { $old_meta->get_attribute($_) }
                           $old_meta->get_attribute_list) {
        $attr->_make_compatible_with($self->attribute_metaclass);
        $self->add_attribute($attr);
    }
}

1;

# ABSTRACT: Methods for metaclasses which have attributes

package Class::MOP::Mixin::HasOverloads;
our $VERSION = '2.2204';

use strict;
use warnings;

use Class::MOP::Overload;

use Devel::OverloadInfo 0.005 'overload_info', 'overload_op_info';
use Scalar::Util 'blessed';

use overload ();

use parent 'Class::MOP::Mixin';

sub is_overloaded {
    my $self = shift;
    Devel::OverloadInfo::is_overloaded($self->name);
}

sub get_overload_list {
    my $self = shift;

    my $info = $self->_overload_info;
    return grep { $_ ne 'fallback' } keys %{$info}
}

sub get_all_overloaded_operators {
    my $self = shift;
    return map { $self->_overload_for($_) } $self->get_overload_list;
}

sub has_overloaded_operator {
    my $self = shift;
    my ($op) = @_;
    return defined $self->_overload_info_for($op);
}

sub _overload_map {
    $_[0]->{_overload_map} ||= {};
}

sub get_overloaded_operator {
    my $self = shift;
    my ($op) = @_;
    return $self->_overload_map->{$op} ||= $self->_overload_for($op);
}

use constant _SET_FALLBACK_EACH_TIME => "$]" < 5.120;

sub add_overloaded_operator {
    my $self = shift;
    my ( $op, $overload ) = @_;

    my %p = ( associated_metaclass => $self );
    if ( !ref $overload ) {
        %p = (
            %p,
            operator             => $op,
            method_name          => $overload,
            associated_metaclass => $self,
        );
        $p{method} = $self->get_method($overload)
            if $self->has_method($overload);
        $overload = Class::MOP::Overload->new(%p);
    }
    elsif ( !blessed $overload) {
        my ($coderef_package, $coderef_name) = Class::MOP::get_code_info($overload);
        $overload = Class::MOP::Overload->new(
            operator        => $op,
            coderef         => $overload,
            coderef_name    => $coderef_name,
            coderef_package => $coderef_package,
            %p,
        );
    }

    $overload->attach_to_class($self);
    $self->_overload_map->{$op} = $overload;

    my %overload = (
          $op => $overload->has_coderef
        ? $overload->coderef
        : $overload->method_name
    );

    # Perl 5.10 and earlier appear to have a bug where setting a new
    # overloading operator wipes out the fallback value unless we pass it each
    # time.
    if (_SET_FALLBACK_EACH_TIME) {
        $overload{fallback} = $self->get_overload_fallback_value;
    }

    $self->name->overload::OVERLOAD(%overload);
}

sub remove_overloaded_operator {
    my $self = shift;
    my ($op) = @_;

    delete $self->_overload_map->{$op};

    # overload.pm provides no api for this - but the problem that makes this
    # necessary has been fixed in 5.18
    $self->get_or_add_package_symbol('%OVERLOAD')->{dummy}++
        if "$]" < 5.017000;

    $self->remove_package_symbol('&(' . $op);
}

sub get_overload_fallback_value {
    my $self = shift;
    return ($self->_overload_info_for('fallback') || {})->{value};
}

sub set_overload_fallback_value {
    my $self  = shift;
    my $value = shift;

    $self->name->overload::OVERLOAD( fallback => $value );
}

# We could cache this but we'd need some logic to clear it at all the right
# times, which seems more tedious than it's worth.
sub _overload_info {
    my $self = shift;
    return overload_info( $self->name ) || {};
}

sub _overload_info_for {
    my $self = shift;
    my $op   = shift;
    return overload_op_info( $self->name, $op );
}

sub _overload_for {
    my $self = shift;
    my $op   = shift;

    my $map = $self->_overload_map;
    return $map->{$op} if $map->{$op};

    my $info = $self->_overload_info_for($op);
    return unless $info;

    my %p = (
        operator             => $op,
        associated_metaclass => $self,
    );

    if ( $info->{code} && !$info->{method_name} ) {
        $p{coderef} = $info->{code};
        @p{ 'coderef_package', 'coderef_name' }
            = $info->{code_name} =~ /(.+)::([^:]+)/;
    }
    else {
        $p{method_name} = $info->{method_name};
        if ( $self->has_method( $p{method_name} ) ) {
            $p{method} = $self->get_method( $p{method_name} );
        }
    }

    return $map->{$op} = Class::MOP::Overload->new(%p);
}

1;

# ABSTRACT: Methods for metaclasses which have overloads

package Class::MOP::Mixin::AttributeCore;
our $VERSION = '2.2204';

use strict;
use warnings;

use Scalar::Util 'blessed';

use parent 'Class::MOP::Mixin';

sub has_accessor        { defined $_[0]->{'accessor'} }
sub has_reader          { defined $_[0]->{'reader'} }
sub has_writer          { defined $_[0]->{'writer'} }
sub has_predicate       { defined $_[0]->{'predicate'} }
sub has_clearer         { defined $_[0]->{'clearer'} }
sub has_builder         { defined $_[0]->{'builder'} }
sub has_init_arg        { defined $_[0]->{'init_arg'} }
sub has_default         { exists  $_[0]->{'default'} }
sub has_initializer     { defined $_[0]->{'initializer'} }
sub has_insertion_order { defined $_[0]->{'insertion_order'} }

sub _set_insertion_order { $_[0]->{'insertion_order'} = $_[1] }

sub has_read_method  { $_[0]->has_reader || $_[0]->has_accessor }
sub has_write_method { $_[0]->has_writer || $_[0]->has_accessor }

sub is_default_a_coderef {
    # Uber hack because it is called from CMOP::Attribute constructor as
    # $class->is_default_a_coderef(\%options)
    my ($value) = ref $_[0] ? $_[0]->{'default'} : $_[1]->{'default'};

    return unless ref($value);

    return ref($value) eq 'CODE'
        || ( blessed($value) && $value->isa('Class::MOP::Method') );
}

sub default {
    my ( $self, $instance ) = @_;
    if ( defined $instance && $self->is_default_a_coderef ) {
        # if the default is a CODE ref, then we pass in the instance and
        # default can return a value based on that instance. Somewhat crude,
        # but works.
        return $self->{'default'}->($instance);
    }
    $self->{'default'};
}

1;

# ABSTRACT: Core attributes shared by attribute metaclasses

package Class::MOP::Mixin::HasMethods;
our $VERSION = '2.2204';

use strict;
use warnings;

use Class::MOP::Method::Meta;

use Scalar::Util 'blessed', 'reftype';
use Sub::Util 1.40 'set_subname';

use parent 'Class::MOP::Mixin';

sub _meta_method_class { 'Class::MOP::Method::Meta' }

sub _add_meta_method {
    my $self = shift;
    my ($name) = @_;
    my $existing_method = $self->can('find_method_by_name')
                              ? $self->find_method_by_name($name)
                              : $self->get_method($name);
    return if $existing_method
           && $existing_method->isa($self->_meta_method_class);
    $self->add_method(
        $name => $self->_meta_method_class->wrap(
            name                 => $name,
            package_name         => $self->name,
            associated_metaclass => $self,
        )
    );
}

sub wrap_method_body {
    my ( $self, %args ) = @_;

    ( $args{body} && 'CODE' eq reftype $args{body} )
        || $self->_throw_exception( CodeBlockMustBeACodeRef => instance => $self,
                                                                    params   => \%args
                                       );
    $self->method_metaclass->wrap(
        package_name => $self->name,
        %args,
    );
}

sub add_method {
    my ( $self, $method_name, $method ) = @_;
    ( defined $method_name && length $method_name )
        || $self->_throw_exception( MustDefineAMethodName => instance => $self );

    my $package_name = $self->name;

    my $body;
    if ( blessed($method) && $method->isa('Class::MOP::Method') ) {
        $body = $method->body;
        if ( $method->package_name ne $package_name ) {
            $method = $method->clone(
                package_name => $package_name,
                name         => $method_name,
            );
        }

        $method->attach_to_class($self);
    }
    else {
        # If a raw code reference is supplied, its method object is not created.
        # The method object won't be created until required.
        $body = $method;
    }

    $self->_method_map->{$method_name} = $method;

    my ($current_package, $current_name) = Class::MOP::get_code_info($body);

    set_subname($package_name . '::' . $method_name, $body)
        unless defined $current_name && $current_name !~ /^__ANON__/;

    $self->add_package_symbol("&$method_name", $body);

    # we added the method to the method map too, so it's still valid
    $self->update_package_cache_flag;
}

sub _code_is_mine {
    my ( $self, $code ) = @_;

    my ( $code_package, $code_name ) = Class::MOP::get_code_info($code);

    return ( $code_package && $code_package eq $self->name )
        || ( $code_package eq 'constant' && $code_name eq '__ANON__' );
}

sub has_method {
    my ( $self, $method_name ) = @_;

    ( defined $method_name && length $method_name )
        || $self->_throw_exception( MustDefineAMethodName => instance => $self );

    my $method = $self->_get_maybe_raw_method($method_name);
    return if not $method;

    return defined($self->_method_map->{$method_name} = $method);
}

sub get_method {
    my ( $self, $method_name ) = @_;

    ( defined $method_name && length $method_name )
        || $self->_throw_exception( MustDefineAMethodName => instance => $self );

    my $method = $self->_get_maybe_raw_method($method_name);
    return if not $method;

    return $method if blessed($method) && $method->isa('Class::MOP::Method');

    return $self->_method_map->{$method_name} = $self->wrap_method_body(
        body                 => $method,
        name                 => $method_name,
        associated_metaclass => $self,
    );
}

sub _get_maybe_raw_method {
    my ( $self, $method_name ) = @_;

    my $map_entry = $self->_method_map->{$method_name};
    return $map_entry if defined $map_entry;

    my $code = $self->get_package_symbol("&$method_name");

    return unless $code && $self->_code_is_mine($code);

    return $code;
}

sub remove_method {
    my ( $self, $method_name ) = @_;

    ( defined $method_name && length $method_name )
        || $self->_throw_exception( MustDefineAMethodName => instance => $self );

    my $removed_method = delete $self->_method_map->{$method_name};

    $self->remove_package_symbol("&$method_name");

    $removed_method->detach_from_class
        if blessed($removed_method) && $removed_method->isa('Class::MOP::Method');

    # still valid, since we just removed the method from the map
    $self->update_package_cache_flag;

    return $removed_method;
}

sub get_method_list {
    my $self = shift;

    return keys %{ $self->_full_method_map };
}

sub _get_local_methods {
    my $self = shift;

    return values %{ $self->_full_method_map };
}

sub _restore_metamethods_from {
    my $self = shift;
    my ($old_meta) = @_;

    my $package_name = $self->name;

    # Check if Perl debugger is enabled
    my $debugger_enabled = ($^P & 0x10);
    my $debug_method_info;

    for my $method ($old_meta->_get_local_methods) {
        my $method_name = $method->name;

        # Track DB::sub information for this method if debugger is enabled.
        # This contains original method filename and line numbers.
        $debug_method_info = '';
        if ($debugger_enabled) {
            $debug_method_info = $DB::sub{$package_name . "::" . $method_name}
        }

        $method->_make_compatible_with($self->method_metaclass);
        $self->add_method($method_name => $method);

        # Restore method debug information, which can be clobbered by add_method.
        # Note that we handle this here instead of in add_method, because we
        # only want to preserve the original debug info in cases where we are
        # restoring a method, not overwriting a method.
        if ($debugger_enabled && $debug_method_info) {
            $DB::sub{$package_name . "::" . $method_name} = $debug_method_info;
        }
    }
}

sub reset_package_cache_flag  { (shift)->{'_package_cache_flag'} = undef }
sub update_package_cache_flag {
    my $self = shift;
    # NOTE:
    # we can manually update the cache number
    # since we are actually adding the method
    # to our cache as well. This avoids us
    # having to regenerate the method_map.
    # - SL
    $self->{'_package_cache_flag'} = Class::MOP::check_package_cache_flag($self->name);
}

sub _full_method_map {
    my $self = shift;

    my $pkg_gen = Class::MOP::check_package_cache_flag($self->name);

    if (($self->{_package_cache_flag_full} || -1) != $pkg_gen) {
        # forcibly reify all method map entries
        $self->get_method($_)
            for $self->list_all_package_symbols('CODE');
        $self->{_package_cache_flag_full} = $pkg_gen;
    }

    return $self->_method_map;
}

1;

# ABSTRACT: Methods for metaclasses which have methods

package Class::MOP::Class;
our $VERSION = '2.2204';

use strict;
use warnings;

use Class::MOP::Instance;
use Class::MOP::Method::Wrapped;
use Class::MOP::Method::Accessor;
use Class::MOP::Method::Constructor;
use Class::MOP::MiniTrait;

use Carp 'confess';
use Module::Runtime 'use_package_optimistically';
use Scalar::Util 'blessed';
use Sub::Util 1.40 'set_subname';
use Try::Tiny;
use List::Util 1.33 'all';

use parent 'Class::MOP::Module',
         'Class::MOP::Mixin::HasAttributes',
         'Class::MOP::Mixin::HasMethods',
         'Class::MOP::Mixin::HasOverloads';

# Creation

sub initialize {
    my $class = shift;

    my $package_name;

    if ( @_ % 2 ) {
        $package_name = shift;
    } else {
        my %options = @_;
        $package_name = $options{package};
    }

    ($package_name && !ref($package_name))
        || ($class||__PACKAGE__)->_throw_exception( InitializeTakesUnBlessedPackageName => package_name => $package_name );
    return Class::MOP::get_metaclass_by_name($package_name)
        || $class->_construct_class_instance(package => $package_name, @_);
}

sub reinitialize {
    my ( $class, @args ) = @_;
    unshift @args, "package" if @args % 2;
    my %options = @args;
    my $old_metaclass = blessed($options{package})
        ? $options{package}
        : Class::MOP::get_metaclass_by_name($options{package});
    $options{weaken} = Class::MOP::metaclass_is_weak($old_metaclass->name)
        if !exists $options{weaken}
        && blessed($old_metaclass)
        && $old_metaclass->isa('Class::MOP::Class');
    $old_metaclass->_remove_generated_metaobjects
        if $old_metaclass && $old_metaclass->isa('Class::MOP::Class');
    my $new_metaclass = $class->SUPER::reinitialize(%options);
    $new_metaclass->_restore_metaobjects_from($old_metaclass)
        if $old_metaclass && $old_metaclass->isa('Class::MOP::Class');
    return $new_metaclass;
}

# NOTE: (meta-circularity)
# this is a special form of _construct_instance
# (see below), which is used to construct class
# meta-object instances for any Class::MOP::*
# class. All other classes will use the more
# normal &construct_instance.
sub _construct_class_instance {
    my $class        = shift;
    my $options      = @_ == 1 ? $_[0] : {@_};
    my $package_name = $options->{package};
    (defined $package_name && $package_name)
        || $class->_throw_exception("ConstructClassInstanceTakesPackageName");
    # NOTE:
    # return the metaclass if we have it cached,
    # and it is still defined (it has not been
    # reaped by DESTROY yet, which can happen
    # annoyingly enough during global destruction)

    if (defined(my $meta = Class::MOP::get_metaclass_by_name($package_name))) {
        return $meta;
    }

    $class
        = ref $class
        ? $class->_real_ref_name
        : $class;

    # now create the metaclass
    my $meta;
    if ($class eq 'Class::MOP::Class') {
        $meta = $class->_new($options);
    }
    else {
        # NOTE:
        # it is safe to use meta here because
        # class will always be a subclass of
        # Class::MOP::Class, which defines meta
        $meta = $class->meta->_construct_instance($options)
    }

    # and check the metaclass compatibility
    $meta->_check_metaclass_compatibility();

    Class::MOP::store_metaclass_by_name($package_name, $meta);

    # NOTE:
    # we need to weaken any anon classes
    # so that they can call DESTROY properly
    Class::MOP::weaken_metaclass($package_name) if $options->{weaken};

    $meta;
}

sub _real_ref_name {
    my $self = shift;

    # NOTE: we need to deal with the possibility of class immutability here,
    # and then get the name of the class appropriately
    return $self->is_immutable
        ? $self->_get_mutable_metaclass_name()
        : ref $self;
}

sub _new {
    my $class = shift;

    return Class::MOP::Class->initialize($class)->new_object(@_)
        if $class ne __PACKAGE__;

    my $options = @_ == 1 ? $_[0] : {@_};

    return bless {
        # inherited from Class::MOP::Package
        'package' => $options->{package},

        # NOTE:
        # since the following attributes will
        # actually be loaded from the symbol
        # table, and actually bypass the instance
        # entirely, we can just leave these things
        # listed here for reference, because they
        # should not actually have a value associated
        # with the slot.
        'namespace' => \undef,
        'methods'   => {},

        # inherited from Class::MOP::Module
        'version'   => \undef,
        'authority' => \undef,

        # defined in Class::MOP::Class
        'superclasses' => \undef,

        'attributes' => {},
        'attribute_metaclass' =>
            ( $options->{'attribute_metaclass'} || 'Class::MOP::Attribute' ),
        'method_metaclass' =>
            ( $options->{'method_metaclass'} || 'Class::MOP::Method' ),
        'wrapped_method_metaclass' => (
            $options->{'wrapped_method_metaclass'}
                || 'Class::MOP::Method::Wrapped'
        ),
        'instance_metaclass' =>
            ( $options->{'instance_metaclass'} || 'Class::MOP::Instance' ),
        'immutable_trait' => (
            $options->{'immutable_trait'}
                || 'Class::MOP::Class::Immutable::Trait'
        ),
        'constructor_name' => ( $options->{constructor_name} || 'new' ),
        'constructor_class' => (
            $options->{constructor_class} || 'Class::MOP::Method::Constructor'
        ),
        'destructor_class' => $options->{destructor_class},
    }, $class;
}

## Metaclass compatibility
{
    my %base_metaclass = (
        attribute_metaclass      => 'Class::MOP::Attribute',
        method_metaclass         => 'Class::MOP::Method',
        wrapped_method_metaclass => 'Class::MOP::Method::Wrapped',
        instance_metaclass       => 'Class::MOP::Instance',
        constructor_class        => 'Class::MOP::Method::Constructor',
        destructor_class         => 'Class::MOP::Method::Destructor',
    );

    sub _base_metaclasses { %base_metaclass }
}

sub _check_metaclass_compatibility {
    my $self = shift;

    my @superclasses = $self->superclasses
        or return;

    $self->_fix_metaclass_incompatibility(@superclasses);

    my %base_metaclass = $self->_base_metaclasses;

    # this is always okay ...
    return
        if ref($self) eq 'Class::MOP::Class'
            && all {
                my $meta = $self->$_;
                !defined($meta) || $meta eq $base_metaclass{$_};
        }
        keys %base_metaclass;

    for my $superclass (@superclasses) {
        $self->_check_class_metaclass_compatibility($superclass);
    }

    for my $metaclass_type ( keys %base_metaclass ) {
        next unless defined $self->$metaclass_type;
        for my $superclass (@superclasses) {
            $self->_check_single_metaclass_compatibility( $metaclass_type,
                $superclass );
        }
    }
}

sub _check_class_metaclass_compatibility {
    my $self = shift;
    my ( $superclass_name ) = @_;

    if (!$self->_class_metaclass_is_compatible($superclass_name)) {
        my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);

        my $super_meta_type = $super_meta->_real_ref_name;

        $self->_throw_exception( IncompatibleMetaclassOfSuperclass => class_name           => $self->name,
                                                              class_meta_type      => ref( $self ),
                                                              superclass_name      => $superclass_name,
                                                              superclass_meta_type => $super_meta_type
                       );
    }
}

sub _class_metaclass_is_compatible {
    my $self = shift;
    my ( $superclass_name ) = @_;

    my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name)
        || return 1;

    my $super_meta_name = $super_meta->_real_ref_name;

    return $self->_is_compatible_with($super_meta_name);
}

sub _check_single_metaclass_compatibility {
    my $self = shift;
    my ( $metaclass_type, $superclass_name ) = @_;

    if (!$self->_single_metaclass_is_compatible($metaclass_type, $superclass_name)) {
        my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);

        $self->_throw_exception( MetaclassTypeIncompatible => class_name      => $self->name,
                                                      superclass_name => $superclass_name,
                                                      metaclass_type  => $metaclass_type
                       );
    }
}

sub _single_metaclass_is_compatible {
    my $self = shift;
    my ( $metaclass_type, $superclass_name ) = @_;

    my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name)
        || return 1;

    # for instance, Moose::Meta::Class has a error_class attribute, but
    # Class::MOP::Class doesn't - this shouldn't be an error
    return 1 unless $super_meta->can($metaclass_type);
    # for instance, Moose::Meta::Class has a destructor_class, but
    # Class::MOP::Class doesn't - this shouldn't be an error
    return 1 unless defined $super_meta->$metaclass_type;
    # if metaclass is defined in superclass but not here, it's not compatible
    # this is a really odd case
    return 0 unless defined $self->$metaclass_type;

    return $self->$metaclass_type->_is_compatible_with($super_meta->$metaclass_type);
}

sub _fix_metaclass_incompatibility {
    my $self = shift;
    my @supers = map { Class::MOP::Class->initialize($_) } @_;

    my $necessary = 0;
    for my $super (@supers) {
        $necessary = 1
            if $self->_can_fix_metaclass_incompatibility($super);
    }
    return unless $necessary;

    for my $super (@supers) {
        if (!$self->_class_metaclass_is_compatible($super->name)) {
            $self->_fix_class_metaclass_incompatibility($super);
        }
    }

    my %base_metaclass = $self->_base_metaclasses;
    for my $metaclass_type (keys %base_metaclass) {
        for my $super (@supers) {
            if (!$self->_single_metaclass_is_compatible($metaclass_type, $super->name)) {
                $self->_fix_single_metaclass_incompatibility(
                    $metaclass_type, $super
                );
            }
        }
    }
}

sub _can_fix_metaclass_incompatibility {
    my $self = shift;
    my ($super_meta) = @_;

    return 1 if $self->_class_metaclass_can_be_made_compatible($super_meta);

    my %base_metaclass = $self->_base_metaclasses;
    for my $metaclass_type (keys %base_metaclass) {
        return 1 if $self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type);
    }

    return;
}

sub _class_metaclass_can_be_made_compatible {
    my $self = shift;
    my ($super_meta) = @_;

    return $self->_can_be_made_compatible_with($super_meta->_real_ref_name);
}

sub _single_metaclass_can_be_made_compatible {
    my $self = shift;
    my ($super_meta, $metaclass_type) = @_;

    my $specific_meta = $self->$metaclass_type;

    return unless $super_meta->can($metaclass_type);
    my $super_specific_meta = $super_meta->$metaclass_type;

    # for instance, Moose::Meta::Class has a destructor_class, but
    # Class::MOP::Class doesn't - this shouldn't be an error
    return unless defined $super_specific_meta;

    # if metaclass is defined in superclass but not here, it's fixable
    # this is a really odd case
    return 1 unless defined $specific_meta;

    return 1 if $specific_meta->_can_be_made_compatible_with($super_specific_meta);
}

sub _fix_class_metaclass_incompatibility {
    my $self = shift;
    my ( $super_meta ) = @_;

    if ($self->_class_metaclass_can_be_made_compatible($super_meta)) {
        ($self->is_pristine)
            || $self->_throw_exception( CannotFixMetaclassCompatibility => class_name => $self->name,
                                                                   superclass => $super_meta
                              );

        my $super_meta_name = $super_meta->_real_ref_name;

        $self->_make_compatible_with($super_meta_name);
    }
}

sub _fix_single_metaclass_incompatibility {
    my $self = shift;
    my ( $metaclass_type, $super_meta ) = @_;

    if ($self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type)) {
        ($self->is_pristine)
            || $self->_throw_exception( CannotFixMetaclassCompatibility => class_name     => $self->name,
                                                                   superclass     => $super_meta,
                                                                   metaclass_type => $metaclass_type
                              );

        my $new_metaclass = $self->$metaclass_type
            ? $self->$metaclass_type->_get_compatible_metaclass($super_meta->$metaclass_type)
            : $super_meta->$metaclass_type;
        $self->{$metaclass_type} = $new_metaclass;
    }
}

sub _restore_metaobjects_from {
    my $self = shift;
    my ($old_meta) = @_;

    $self->_restore_metamethods_from($old_meta);
    $self->_restore_metaattributes_from($old_meta);
}

sub _remove_generated_metaobjects {
    my $self = shift;

    for my $attr (map { $self->get_attribute($_) } $self->get_attribute_list) {
        $attr->remove_accessors;
    }
}

# creating classes with MOP ...

sub create {
    my $class = shift;
    my @args = @_;

    unshift @args, 'package' if @args % 2 == 1;
    my %options = @args;

    (ref $options{superclasses} eq 'ARRAY')
        || __PACKAGE__->_throw_exception( CreateMOPClassTakesArrayRefOfSuperclasses => class  => $class,
                                                                         params => \%options
                          )
            if exists $options{superclasses};

    (ref $options{attributes} eq 'ARRAY')
        || __PACKAGE__->_throw_exception( CreateMOPClassTakesArrayRefOfAttributes => class  => $class,
                                                                       params => \%options
                          )
            if exists $options{attributes};

    (ref $options{methods} eq 'HASH')
        || __PACKAGE__->_throw_exception( CreateMOPClassTakesHashRefOfMethods => class  => $class,
                                                                   params => \%options
                          )
            if exists $options{methods};

    my $package      = delete $options{package};
    my $superclasses = delete $options{superclasses};
    my $attributes   = delete $options{attributes};
    my $methods      = delete $options{methods};
    my $meta_name    = exists $options{meta_name}
                         ? delete $options{meta_name}
                         : 'meta';

    my $meta = $class->SUPER::create($package => %options);

    $meta->_add_meta_method($meta_name)
        if defined $meta_name;

    $meta->superclasses(@{$superclasses})
        if defined $superclasses;
    # NOTE:
    # process attributes first, so that they can
    # install accessors, but locally defined methods
    # can then overwrite them. It is maybe a little odd, but
    # I think this should be the order of things.
    if (defined $attributes) {
        foreach my $attr (@{$attributes}) {
            $meta->add_attribute($attr);
        }
    }
    if (defined $methods) {
        foreach my $method_name (keys %{$methods}) {
            $meta->add_method($method_name, $methods->{$method_name});
        }
    }
    return $meta;
}

# XXX: something more intelligent here?
sub _anon_package_prefix { 'Class::MOP::Class::__ANON__::SERIAL::' }

sub create_anon_class { shift->create_anon(@_) }
sub is_anon_class     { shift->is_anon(@_)     }

sub _anon_cache_key {
    my $class = shift;
    my %options = @_;
    # Makes something like Super::Class|Super::Class::2
    return join '=' => (
        join( '|', sort @{ $options{superclasses} || [] } ),
    );
}

# Instance Construction & Cloning

sub new_object {
    my $class = shift;

    # NOTE:
    # we need to protect the integrity of the
    # Class::MOP::Class singletons here, so we
    # delegate this to &construct_class_instance
    # which will deal with the singletons
    return $class->_construct_class_instance(@_)
        if $class->name->isa('Class::MOP::Class');
    return $class->_construct_instance(@_);
}

sub _construct_instance {
    my $class = shift;
    my $params = @_ == 1 ? $_[0] : {@_};
    my $meta_instance = $class->get_meta_instance();
    # FIXME:
    # the code below is almost certainly incorrect
    # but this is foreign inheritance, so we might
    # have to kludge it in the end.
    my $instance;
    if (my $instance_class = blessed($params->{__INSTANCE__})) {
        ($instance_class eq $class->name)
            || $class->_throw_exception( InstanceBlessedIntoWrongClass => class_name => $class->name,
                                                                 params     => $params,
                                                                 instance   => $params->{__INSTANCE__}
                              );
        $instance = $params->{__INSTANCE__};
    }
    elsif (exists $params->{__INSTANCE__}) {
        $class->_throw_exception( InstanceMustBeABlessedReference => class_name => $class->name,
                                                            params     => $params,
                                                            instance   => $params->{__INSTANCE__}
                       );
    }
    else {
        $instance = $meta_instance->create_instance();
    }
    foreach my $attr ($class->get_all_attributes()) {
        $attr->initialize_instance_slot($meta_instance, $instance, $params);
    }
    if (Class::MOP::metaclass_is_weak($class->name)) {
        $meta_instance->_set_mop_slot($instance, $class);
    }
    return $instance;
}

sub _inline_new_object {
    my $self = shift;

    return (
        'my $class = shift;',
        '$class = Scalar::Util::blessed($class) || $class;',
        $self->_inline_fallback_constructor('$class'),
        $self->_inline_params('$params', '$class'),
        $self->_inline_generate_instance('$instance', '$class'),
        $self->_inline_slot_initializers,
        $self->_inline_preserve_weak_metaclasses,
        $self->_inline_extra_init,
        'return $instance',
    );
}

sub _inline_fallback_constructor {
    my $self = shift;
    my ($class) = @_;
    return (
        'return ' . $self->_generate_fallback_constructor($class),
            'if ' . $class . ' ne \'' . $self->name . '\';',
    );
}

sub _generate_fallback_constructor {
    my $self = shift;
    my ($class) = @_;
    return 'Class::MOP::Class->initialize(' . $class . ')->new_object(@_)',
}

sub _inline_params {
    my $self = shift;
    my ($params, $class) = @_;
    return (
        'my ' . $params . ' = @_ == 1 ? $_[0] : {@_};',
    );
}

sub _inline_generate_instance {
    my $self = shift;
    my ($inst, $class) = @_;
    return (
        'my ' . $inst . ' = ' . $self->_inline_create_instance($class) . ';',
    );
}

sub _inline_create_instance {
    my $self = shift;

    return $self->get_meta_instance->inline_create_instance(@_);
}

sub _inline_slot_initializers {
    my $self = shift;

    my $idx = 0;

    return map { $self->_inline_slot_initializer($_, $idx++) }
               sort { $a->name cmp $b->name } $self->get_all_attributes;
}

sub _inline_slot_initializer {
    my $self  = shift;
    my ($attr, $idx) = @_;

    if (defined(my $init_arg = $attr->init_arg)) {
        my @source = (
            'if (exists $params->{\'' . $init_arg . '\'}) {',
                $self->_inline_init_attr_from_constructor($attr, $idx),
            '}',
        );
        if (my @default = $self->_inline_init_attr_from_default($attr, $idx)) {
            push @source, (
                'else {',
                    @default,
                '}',
            );
        }
        return @source;
    }
    elsif (my @default = $self->_inline_init_attr_from_default($attr, $idx)) {
        return (
            '{',
                @default,
            '}',
        );
    }
    else {
        return ();
    }
}

sub _inline_init_attr_from_constructor {
    my $self = shift;
    my ($attr, $idx) = @_;

    my @initial_value = $attr->_inline_set_value(
        '$instance', '$params->{\'' . $attr->init_arg . '\'}',
    );

    push @initial_value, (
        '$attrs->[' . $idx . ']->set_initial_value(',
            '$instance,',
            $attr->_inline_instance_get('$instance'),
        ');',
    ) if $attr->has_initializer;

    return @initial_value;
}

sub _inline_init_attr_from_default {
    my $self = shift;
    my ($attr, $idx) = @_;

    my $default = $self->_inline_default_value($attr, $idx);
    return unless $default;

    my @initial_value = $attr->_inline_set_value('$instance', $default);

    push @initial_value, (
        '$attrs->[' . $idx . ']->set_initial_value(',
            '$instance,',
            $attr->_inline_instance_get('$instance'),
        ');',
    ) if $attr->has_initializer;

    return @initial_value;
}

sub _inline_default_value {
    my $self = shift;
    my ($attr, $index) = @_;

    if ($attr->has_default) {
        # NOTE:
        # default values can either be CODE refs
        # in which case we need to call them. Or
        # they can be scalars (strings/numbers)
        # in which case we can just deal with them
        # in the code we eval.
        if ($attr->is_default_a_coderef) {
            return '$defaults->[' . $index . ']->($instance)';
        }
        else {
            return '$defaults->[' . $index . ']';
        }
    }
    elsif ($attr->has_builder) {
        return '$instance->' . $attr->builder;
    }
    else {
        return;
    }
}

sub _inline_preserve_weak_metaclasses {
    my $self = shift;
    if (Class::MOP::metaclass_is_weak($self->name)) {
        return (
            $self->_inline_set_mop_slot(
                '$instance', 'Class::MOP::class_of($class)'
            ) . ';'
        );
    }
    else {
        return ();
    }
}

sub _inline_extra_init { }

sub _eval_environment {
    my $self = shift;

    my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;

    my $defaults = [map { $_->default } @attrs];

    return {
        '$defaults' => \$defaults,
    };
}


sub get_meta_instance {
    my $self = shift;
    $self->{'_meta_instance'} ||= $self->_create_meta_instance();
}

sub _create_meta_instance {
    my $self = shift;

    my $instance = $self->instance_metaclass->new(
        associated_metaclass => $self,
        attributes => [ $self->get_all_attributes() ],
    );

    $self->add_meta_instance_dependencies()
        if $instance->is_dependent_on_superclasses();

    return $instance;
}

# TODO: this is actually not being used!
sub _inline_rebless_instance {
    my $self = shift;

    return $self->get_meta_instance->inline_rebless_instance_structure(@_);
}

sub _inline_get_mop_slot {
    my $self = shift;

    return $self->get_meta_instance->_inline_get_mop_slot(@_);
}

sub _inline_set_mop_slot {
    my $self = shift;

    return $self->get_meta_instance->_inline_set_mop_slot(@_);
}

sub _inline_clear_mop_slot {
    my $self = shift;

    return $self->get_meta_instance->_inline_clear_mop_slot(@_);
}

sub clone_object {
    my $class    = shift;
    my $instance = shift;
    (blessed($instance) && $instance->isa($class->name))
        || $class->_throw_exception( CloneObjectExpectsAnInstanceOfMetaclass => class_name => $class->name,
                                                                       instance   => $instance,
                          );
    # NOTE:
    # we need to protect the integrity of the
    # Class::MOP::Class singletons here, they
    # should not be cloned.
    return $instance if $instance->isa('Class::MOP::Class');
    $class->_clone_instance($instance, @_);
}

sub _clone_instance {
    my ($class, $instance, %params) = @_;
    (blessed($instance))
        || $class->_throw_exception( OnlyInstancesCanBeCloned => class_name => $class->name,
                                                        instance   => $instance,
                                                        params     => \%params
                          );
    my $meta_instance = $class->get_meta_instance();
    my $clone = $meta_instance->clone_instance($instance);
    foreach my $attr ($class->get_all_attributes()) {
        if ( defined( my $init_arg = $attr->init_arg ) ) {
            if (exists $params{$init_arg}) {
                $attr->set_value($clone, $params{$init_arg});
            }
        }
    }
    return $clone;
}

sub _force_rebless_instance {
    my ($self, $instance, %params) = @_;
    my $old_metaclass = Class::MOP::class_of($instance);

    $old_metaclass->rebless_instance_away($instance, $self, %params)
        if $old_metaclass;

    my $meta_instance = $self->get_meta_instance;

    if (Class::MOP::metaclass_is_weak($old_metaclass->name)) {
        $meta_instance->_clear_mop_slot($instance);
    }

    # rebless!
    # we use $_[1] here because of t/cmop/rebless_overload.t regressions
    # on 5.8.8
    $meta_instance->rebless_instance_structure($_[1], $self);

    $self->_fixup_attributes_after_rebless($instance, $old_metaclass, %params);

    if (Class::MOP::metaclass_is_weak($self->name)) {
        $meta_instance->_set_mop_slot($instance, $self);
    }
}

sub rebless_instance {
    my ($self, $instance, %params) = @_;
    my $old_metaclass = Class::MOP::class_of($instance);

    my $old_class = $old_metaclass ? $old_metaclass->name : blessed($instance);
    $self->name->isa($old_class)
        || $self->_throw_exception( CanReblessOnlyIntoASubclass => class_name     => $self->name,
                                                           instance       => $instance,
                                                           instance_class => blessed( $instance ),
                                                           params         => \%params,
                          );

    $self->_force_rebless_instance($_[1], %params);

    return $instance;
}

sub rebless_instance_back {
    my ( $self, $instance ) = @_;
    my $old_metaclass = Class::MOP::class_of($instance);
    my $old_class
        = $old_metaclass ? $old_metaclass->name : blessed($instance);
    $old_class->isa( $self->name )
        || $self->_throw_exception( CanReblessOnlyIntoASuperclass => class_name     => $self->name,
                                                             instance       => $instance,
                                                             instance_class => blessed( $instance ),
                          );

    $self->_force_rebless_instance($_[1]);

    return $instance;
}

sub rebless_instance_away {
    # this intentionally does nothing, it is just a hook
}

sub _fixup_attributes_after_rebless {
    my $self = shift;
    my ($instance, $rebless_from, %params) = @_;
    my $meta_instance = $self->get_meta_instance;

    for my $attr ( $rebless_from->get_all_attributes ) {
        next if $self->find_attribute_by_name( $attr->name );
        $meta_instance->deinitialize_slot( $instance, $_ ) for $attr->slots;
    }

    foreach my $attr ( $self->get_all_attributes ) {
        if ( $attr->has_value($instance) ) {
            if ( defined( my $init_arg = $attr->init_arg ) ) {
                $params{$init_arg} = $attr->get_value($instance)
                    unless exists $params{$init_arg};
            }
            else {
                $attr->set_value($instance, $attr->get_value($instance));
            }
        }
    }

    foreach my $attr ($self->get_all_attributes) {
        $attr->initialize_instance_slot($meta_instance, $instance, \%params);
    }
}

sub _attach_attribute {
    my ($self, $attribute) = @_;
    $attribute->attach_to_class($self);
}

sub _post_add_attribute {
    my ( $self, $attribute ) = @_;

    $self->invalidate_meta_instances;

    # invalidate package flag here
    try {
        local $SIG{__DIE__};
        $attribute->install_accessors;
    }
    catch {
        $self->remove_attribute( $attribute->name );
        die $_;
    };
}

sub remove_attribute {
    my $self = shift;

    my $removed_attribute = $self->SUPER::remove_attribute(@_)
        or return;

    $self->invalidate_meta_instances;

    $removed_attribute->remove_accessors;
    $removed_attribute->detach_from_class;

    return$removed_attribute;
}

sub find_attribute_by_name {
    my ( $self, $attr_name ) = @_;

    foreach my $class ( $self->linearized_isa ) {
        # fetch the meta-class ...
        my $meta = Class::MOP::Class->initialize($class);
        return $meta->get_attribute($attr_name)
            if $meta->has_attribute($attr_name);
    }

    return;
}

sub get_all_attributes {
    my $self = shift;
    my %attrs = map { %{ Class::MOP::Class->initialize($_)->_attribute_map } }
        reverse $self->linearized_isa;
    return values %attrs;
}

# Inheritance

sub superclasses {
    my $self     = shift;

    my $isa = $self->get_or_add_package_symbol('@ISA');

    if (@_) {
        my @supers = @_;
        @{$isa} = @supers;

        # NOTE:
        # on 5.8 and below, we need to call
        # a method to get Perl to detect
        # a cycle in the class hierarchy
        my $class = $self->name;
        $class->isa($class);

        # NOTE:
        # we need to check the metaclass
        # compatibility here so that we can
        # be sure that the superclass is
        # not potentially creating an issues
        # we don't know about

        $self->_check_metaclass_compatibility();
        $self->_superclasses_updated();
    }

    return @{$isa};
}

sub _superclasses_updated {
    my $self = shift;
    $self->update_meta_instance_dependencies();
    # keep strong references to all our parents, so they don't disappear if
    # they are anon classes and don't have any direct instances
    $self->_superclass_metas(
        map { Class::MOP::class_of($_) } $self->superclasses
    );
}

sub _superclass_metas {
    my $self = shift;
    $self->{_superclass_metas} = [@_];
}

sub subclasses {
    my $self = shift;
    my $super_class = $self->name;

    return @{ $super_class->mro::get_isarev() };
}

sub direct_subclasses {
    my $self = shift;
    my $super_class = $self->name;

    return grep {
        grep {
            $_ eq $super_class
        } Class::MOP::Class->initialize($_)->superclasses
    } $self->subclasses;
}

sub linearized_isa {
    return @{ mro::get_linear_isa( (shift)->name ) };
}

sub class_precedence_list {
    my $self = shift;
    my $name = $self->name;

    unless (Class::MOP::IS_RUNNING_ON_5_10()) {
        # NOTE:
        # We need to check for circular inheritance here
        # if we are not on 5.10, cause 5.8 detects it late.
        # This will do nothing if all is well, and blow up
        # otherwise. Yes, it's an ugly hack, better
        # suggestions are welcome.
        # - SL
        ($name || return)->isa('This is a test for circular inheritance')
    }

    # if our mro is c3, we can
    # just grab the linear_isa
    if (mro::get_mro($name) eq 'c3') {
        return @{ mro::get_linear_isa($name) }
    }
    else {
        # NOTE:
        # we can't grab the linear_isa for dfs
        # since it has all the duplicates
        # already removed.
        return (
            $name,
            map {
                Class::MOP::Class->initialize($_)->class_precedence_list()
            } $self->superclasses()
        );
    }
}

sub _method_lookup_order {
    return (shift->linearized_isa, 'UNIVERSAL');
}

## Methods

{
    my $fetch_and_prepare_method = sub {
        my ($self, $method_name) = @_;
        my $wrapped_metaclass = $self->wrapped_method_metaclass;
        # fetch it locally
        my $method = $self->get_method($method_name);
        # if we don't have local ...
        unless ($method) {
            # try to find the next method
            $method = $self->find_next_method_by_name($method_name);
            # die if it does not exist
            (defined $method)
                || $self->_throw_exception( MethodNameNotFoundInInheritanceHierarchy => class_name  => $self->name,
                                                                                method_name => $method_name
                                  );
            # and now make sure to wrap it
            # even if it is already wrapped
            # because we need a new sub ref
            $method = $wrapped_metaclass->wrap($method,
                package_name => $self->name,
                name         => $method_name,
            );
        }
        else {
            # now make sure we wrap it properly
            $method = $wrapped_metaclass->wrap($method,
                package_name => $self->name,
                name         => $method_name,
            ) unless $method->isa($wrapped_metaclass);
        }
        $self->add_method($method_name => $method);
        return $method;
    };

    sub add_before_method_modifier {
        my ($self, $method_name, $method_modifier) = @_;
        (defined $method_name && length $method_name)
            || $self->_throw_exception( MethodModifierNeedsMethodName => class_name => $self->name );
        my $method = $fetch_and_prepare_method->($self, $method_name);
        $method->add_before_modifier(
            set_subname(':before' => $method_modifier)
        );
    }

    sub add_after_method_modifier {
        my ($self, $method_name, $method_modifier) = @_;
        (defined $method_name && length $method_name)
            || $self->_throw_exception( MethodModifierNeedsMethodName => class_name => $self->name );
        my $method = $fetch_and_prepare_method->($self, $method_name);
        $method->add_after_modifier(
            set_subname(':after' => $method_modifier)
        );
    }

    sub add_around_method_modifier {
        my ($self, $method_name, $method_modifier) = @_;
        (defined $method_name && length $method_name)
            || $self->_throw_exception( MethodModifierNeedsMethodName => class_name => $self->name );
        my $method = $fetch_and_prepare_method->($self, $method_name);
        $method->add_around_modifier(
            set_subname(':around' => $method_modifier)
        );
    }

    # NOTE:
    # the methods above used to be named like this:
    #    ${pkg}::${method}:(before|after|around)
    # but this proved problematic when using one modifier
    # to wrap multiple methods (something which is likely
    # to happen pretty regularly IMO). So instead of naming
    # it like this, I have chosen to just name them purely
    # with their modifier names, like so:
    #    :(before|after|around)
    # The fact is that in a stack trace, it will be fairly
    # evident from the context what method they are attached
    # to, and so don't need the fully qualified name.
}

sub find_method_by_name {
    my ($self, $method_name) = @_;
    (defined $method_name && length $method_name)
        || $self->_throw_exception( MethodNameNotGiven => class_name => $self->name );
    foreach my $class ($self->_method_lookup_order) {
        my $method = Class::MOP::Class->initialize($class)->get_method($method_name);
        return $method if defined $method;
    }
    return;
}

sub get_all_methods {
    my $self = shift;

    my %methods;
    for my $class ( reverse $self->_method_lookup_order ) {
        my $meta = Class::MOP::Class->initialize($class);

        $methods{ $_->name } = $_ for $meta->_get_local_methods;
    }

    return values %methods;
}

sub get_all_method_names {
    my $self = shift;
    map { $_->name } $self->get_all_methods;
}

sub find_all_methods_by_name {
    my ($self, $method_name) = @_;
    (defined $method_name && length $method_name)
        || $self->_throw_exception( MethodNameNotGiven => class_name => $self->name );
    my @methods;
    foreach my $class ($self->_method_lookup_order) {
        # fetch the meta-class ...
        my $meta = Class::MOP::Class->initialize($class);
        push @methods => {
            name  => $method_name,
            class => $class,
            code  => $meta->get_method($method_name)
        } if $meta->has_method($method_name);
    }
    return @methods;
}

sub find_next_method_by_name {
    my ($self, $method_name) = @_;
    (defined $method_name && length $method_name)
        || $self->_throw_exception( MethodNameNotGiven => class_name => $self->name );
    my @cpl = ($self->_method_lookup_order);
    shift @cpl; # discard ourselves
    foreach my $class (@cpl) {
        my $method = Class::MOP::Class->initialize($class)->get_method($method_name);
        return $method if defined $method;
    }
    return;
}

sub update_meta_instance_dependencies {
    my $self = shift;

    if ( $self->{meta_instance_dependencies} ) {
        return $self->add_meta_instance_dependencies;
    }
}

sub add_meta_instance_dependencies {
    my $self = shift;

    $self->remove_meta_instance_dependencies;

    my @attrs = $self->get_all_attributes();

    my %seen;
    my @classes = grep { not $seen{ $_->name }++ }
        map { $_->associated_class } @attrs;

    foreach my $class (@classes) {
        $class->add_dependent_meta_instance($self);
    }

    $self->{meta_instance_dependencies} = \@classes;
}

sub remove_meta_instance_dependencies {
    my $self = shift;

    if ( my $classes = delete $self->{meta_instance_dependencies} ) {
        foreach my $class (@$classes) {
            $class->remove_dependent_meta_instance($self);
        }

        return $classes;
    }

    return;

}

sub add_dependent_meta_instance {
    my ( $self, $metaclass ) = @_;
    push @{ $self->{dependent_meta_instances} }, $metaclass;
}

sub remove_dependent_meta_instance {
    my ( $self, $metaclass ) = @_;
    my $name = $metaclass->name;
    @$_ = grep { $_->name ne $name } @$_
        for $self->{dependent_meta_instances};
}

sub invalidate_meta_instances {
    my $self = shift;
    $_->invalidate_meta_instance()
        for $self, @{ $self->{dependent_meta_instances} };
}

sub invalidate_meta_instance {
    my $self = shift;
    undef $self->{_meta_instance};
}

# check if we can reinitialize
sub is_pristine {
    my $self = shift;

    # if any local attr is defined
    return if $self->get_attribute_list;

    # or any non-declared methods
    for my $method ( map { $self->get_method($_) } $self->get_method_list ) {
        return if $method->isa("Class::MOP::Method::Generated");
        # FIXME do we need to enforce this too? return unless $method->isa( $self->method_metaclass );
    }

    return 1;
}

## Class closing

sub is_mutable   { 1 }
sub is_immutable { 0 }

sub immutable_options { %{ $_[0]{__immutable}{options} || {} } }

sub _immutable_options {
    my ( $self, @args ) = @_;

    return (
        inline_accessors   => 1,
        inline_constructor => 1,
        inline_destructor  => 0,
        debug              => 0,
        immutable_trait    => $self->immutable_trait,
        constructor_name   => $self->constructor_name,
        constructor_class  => $self->constructor_class,
        destructor_class   => $self->destructor_class,
        @args,
    );
}

sub make_immutable {
    my ( $self, @args ) = @_;

    return $self unless $self->is_mutable;

    my ($file, $line) = (caller)[1..2];

    $self->_initialize_immutable(
        file => $file,
        line => $line,
        $self->_immutable_options(@args),
    );
    $self->_rebless_as_immutable(@args);

    return $self;
}

sub make_mutable {
    my $self = shift;

    if ( $self->is_immutable ) {
        my @args = $self->immutable_options;
        $self->_rebless_as_mutable();
        $self->_remove_inlined_code(@args);
        delete $self->{__immutable};
        return $self;
    }
    else {
        return;
    }
}

sub _rebless_as_immutable {
    my ( $self, @args ) = @_;

    $self->{__immutable}{original_class} = ref $self;

    bless $self => $self->_immutable_metaclass(@args);
}

sub _immutable_metaclass {
    my ( $self, %args ) = @_;

    if ( my $class = $args{immutable_metaclass} ) {
        return $class;
    }

    my $trait = $args{immutable_trait} = $self->immutable_trait
        || $self->_throw_exception( NoImmutableTraitSpecifiedForClass => class_name => $self->name,
                                                                 params     => \%args
                          );

    my $meta      = $self->meta;
    my $meta_attr = $meta->find_attribute_by_name("immutable_trait");

    my $class_name;

    if ( $meta_attr and $trait eq $meta_attr->default ) {
        # if the trait is the same as the default we try and pick a
        # predictable name for the immutable metaclass
        $class_name = 'Class::MOP::Class::Immutable::' . ref($self);
    }
    else {
        $class_name = join '::', 'Class::MOP::Class::Immutable::CustomTrait',
            $trait, 'ForMetaClass', ref($self);
    }

    return $class_name
        if Class::MOP::does_metaclass_exist($class_name);

    # If the metaclass is a subclass of CMOP::Class which has had
    # metaclass roles applied (via Moose), then we want to make sure
    # that we preserve that anonymous class (see Fey::ORM for an
    # example of where this matters).
    my $meta_name = $meta->_real_ref_name;

    my $immutable_meta = $meta_name->create(
        $class_name,
        superclasses => [ ref $self ],
    );

    Class::MOP::MiniTrait::apply( $immutable_meta, $trait );

    $immutable_meta->make_immutable(
        inline_constructor => 0,
        inline_accessors   => 0,
    );

    return $class_name;
}

sub _remove_inlined_code {
    my $self = shift;

    $self->remove_method( $_->name ) for $self->_inlined_methods;

    delete $self->{__immutable}{inlined_methods};
}

sub _inlined_methods { @{ $_[0]{__immutable}{inlined_methods} || [] } }

sub _add_inlined_method {
    my ( $self, $method ) = @_;

    push @{ $self->{__immutable}{inlined_methods} ||= [] }, $method;
}

sub _initialize_immutable {
    my ( $self, %args ) = @_;

    $self->{__immutable}{options} = \%args;
    $self->_install_inlined_code(%args);
}

sub _install_inlined_code {
    my ( $self, %args ) = @_;

    # FIXME
    $self->_inline_accessors(%args)   if $args{inline_accessors};
    $self->_inline_constructor(%args) if $args{inline_constructor};
    $self->_inline_destructor(%args)  if $args{inline_destructor};
}

sub _rebless_as_mutable {
    my $self = shift;

    bless $self, $self->_get_mutable_metaclass_name;

    return $self;
}

sub _inline_accessors {
    my $self = shift;

    foreach my $attr_name ( $self->get_attribute_list ) {
        $self->get_attribute($attr_name)->install_accessors(1);
    }
}

sub _inline_constructor {
    my ( $self, %args ) = @_;

    my $name = $args{constructor_name};
    # A class may not even have a constructor, and that's okay.
    return unless defined $name;

    if ( $self->has_method($name) && !$args{replace_constructor} ) {
        my $class = $self->name;
        warn "Not inlining a constructor for $class since it defines"
            . " its own constructor.\n"
            . "If you are certain you don't need to inline your"
            . " constructor, specify inline_constructor => 0 in your"
            . " call to $class->meta->make_immutable\n";
        return;
    }

    my $constructor_class = $args{constructor_class};

    {
        local $@;
        use_package_optimistically($constructor_class);
    }

    my $constructor = $constructor_class->new(
        options      => \%args,
        metaclass    => $self,
        is_inline    => 1,
        package_name => $self->name,
        name         => $name,
        definition_context => {
            description => "constructor " . $self->name . "::" . $name,
            file        => $args{file},
            line        => $args{line},
        },
    );

    if ( $args{replace_constructor} or $constructor->can_be_inlined ) {
        $self->add_method( $name => $constructor );
        $self->_add_inlined_method($constructor);
    }
}

sub _inline_destructor {
    my ( $self, %args ) = @_;

    ( exists $args{destructor_class} && defined $args{destructor_class} )
        || $self->_throw_exception( NoDestructorClassSpecified => class_name => $self->name,
                                                          params     => \%args,
                          );

    if ( $self->has_method('DESTROY') && ! $args{replace_destructor} ) {
        my $class = $self->name;
        warn "Not inlining a destructor for $class since it defines"
            . " its own destructor.\n";
        return;
    }

    my $destructor_class = $args{destructor_class};

    {
        local $@;
        use_package_optimistically($destructor_class);
    }

    return unless $destructor_class->is_needed($self);

    my $destructor = $destructor_class->new(
        options      => \%args,
        metaclass    => $self,
        package_name => $self->name,
        name         => 'DESTROY',
        definition_context => {
            description => "destructor " . $self->name . "::DESTROY",
            file        => $args{file},
            line        => $args{line},
        },
    );

    if ( $args{replace_destructor} or $destructor->can_be_inlined ) {
        $self->add_method( 'DESTROY' => $destructor );
        $self->_add_inlined_method($destructor);
    }
}

1;

# ABSTRACT: Class Meta Object

package Class::MOP::Mixin;
our $VERSION = '2.2204';

use strict;
use warnings;

use Scalar::Util 'blessed';
use Module::Runtime 'use_module';

sub meta {
    require Class::MOP::Class;
    Class::MOP::Class->initialize( blessed( $_[0] ) || $_[0] );
}

sub _throw_exception {
    my ($class, $exception_type, @args_to_exception) = @_;
    die use_module( "Moose::Exception::$exception_type" )->new( @args_to_exception );
}

1;

# ABSTRACT: Base class for mixin classes

package Class::MOP::Class::Immutable::Trait;
our $VERSION = '2.2204';

use strict;
use warnings;

use MRO::Compat;
use Module::Runtime 'use_module';

# the original class of the metaclass instance
sub _get_mutable_metaclass_name { $_[0]{__immutable}{original_class} }

sub is_mutable   { 0 }
sub is_immutable { 1 }

sub _immutable_metaclass { ref $_[1] }

sub _immutable_read_only {
    my $name = shift;
    __throw_exception( CallingReadOnlyMethodOnAnImmutableInstance => method_name => $name );
}

sub _immutable_cannot_call {
    my $name = shift;
    __throw_exception( CallingMethodOnAnImmutableInstance => method_name => $name );
}

for my $name (qw/superclasses/) {
    no strict 'refs';
    *{__PACKAGE__."::$name"} = sub {
        my $orig = shift;
        my $self = shift;
        _immutable_read_only($name) if @_;
        $self->$orig;
    };
}

for my $name (qw/add_method alias_method remove_method add_attribute remove_attribute remove_package_symbol add_package_symbol/) {
    no strict 'refs';
    *{__PACKAGE__."::$name"} = sub { _immutable_cannot_call($name) };
}

sub class_precedence_list {
    my $orig = shift;
    my $self = shift;
    @{ $self->{__immutable}{class_precedence_list}
            ||= [ $self->$orig ] };
}

sub linearized_isa {
    my $orig = shift;
    my $self = shift;
    @{ $self->{__immutable}{linearized_isa} ||= [ $self->$orig ] };
}

sub get_all_methods {
    my $orig = shift;
    my $self = shift;
    @{ $self->{__immutable}{get_all_methods} ||= [ $self->$orig ] };
}

sub get_all_method_names {
    my $orig = shift;
    my $self = shift;
    @{ $self->{__immutable}{get_all_method_names} ||= [ $self->$orig ] };
}

sub get_all_attributes {
    my $orig = shift;
    my $self = shift;
    @{ $self->{__immutable}{get_all_attributes} ||= [ $self->$orig ] };
}

sub get_meta_instance {
    my $orig = shift;
    my $self = shift;
    $self->{__immutable}{get_meta_instance} ||= $self->$orig;
}

sub _method_map {
    my $orig = shift;
    my $self = shift;
    $self->{__immutable}{_method_map} ||= $self->$orig;
}

# private method, for this file only -
# if we declare a method here, it will behave differently depending on what
# class this trait is applied to, so we won't have a reliable parameter list.
sub __throw_exception {
    my ($exception_type, @args_to_exception) = @_;
    die use_module( "Moose::Exception::$exception_type" )->new( @args_to_exception );
}

1;

# ABSTRACT: Implements immutability for metaclass objects

package Class::MOP::Object;
our $VERSION = '2.2204';

use strict;
use warnings;

use parent 'Class::MOP::Mixin';
use Scalar::Util 'blessed';
use Module::Runtime;

# introspection

sub throw_error {
    shift->_throw_exception( Legacy => message => join('', @_) );
}

sub _inline_throw_error {
    my ( $self, $message ) = @_;
    return 'die Module::Runtime::use_module("Moose::Exception::Legacy")->new(message => ' . $message. ')';
}

sub _new {
    Class::MOP::class_of(shift)->new_object(@_);
}

# RANT:
# Cmon, how many times have you written
# the following code while debugging:
#
#  use Data::Dumper;
#  warn Dumper $obj;
#
# It can get seriously annoying, so why
# not just do this ...
sub dump {
    my $self = shift;
    require Data::Dumper;
    local $Data::Dumper::Maxdepth = shift || 1;
    Data::Dumper::Dumper $self;
}

sub _real_ref_name {
    my $self = shift;
    return blessed($self);
}

sub _is_compatible_with {
    my $self = shift;
    my ($other_name) = @_;

    return $self->isa($other_name);
}

sub _can_be_made_compatible_with {
    my $self = shift;
    return !$self->_is_compatible_with(@_)
        && defined($self->_get_compatible_metaclass(@_));
}

sub _make_compatible_with {
    my $self = shift;
    my ($other_name) = @_;

    my $new_metaclass = $self->_get_compatible_metaclass($other_name);

    unless ( defined $new_metaclass ) {
        $self->_throw_exception( CannotMakeMetaclassCompatible => superclass_name => $other_name,
                                                                       class           => $self,
                                    );
    }

    # can't use rebless_instance here, because it might not be an actual
    # subclass in the case of, e.g. moose role reconciliation
    $new_metaclass->meta->_force_rebless_instance($self)
        if blessed($self) ne $new_metaclass;

    return $self;
}

sub _get_compatible_metaclass {
    my $self = shift;
    my ($other_name) = @_;

    return $self->_get_compatible_metaclass_by_subclassing($other_name);
}

sub _get_compatible_metaclass_by_subclassing {
    my $self = shift;
    my ($other_name) = @_;
    my $meta_name = blessed($self) ? $self->_real_ref_name : $self;

    if ($meta_name->isa($other_name)) {
        return $meta_name;
    }
    elsif ($other_name->isa($meta_name)) {
        return $other_name;
    }

    return;
}

1;

# ABSTRACT: Base class for metaclasses

package Class::MOP::Method;
our $VERSION = '2.2204';

use strict;
use warnings;

use Scalar::Util 'weaken', 'reftype', 'blessed';

use parent 'Class::MOP::Object';

# NOTE:
# if poked in the right way,
# they should act like CODE refs.
use overload
    '&{}' => sub { $_[0]->body },
    'bool' => sub { 1 },
    '""' => sub { overload::StrVal($_[0]) },
    fallback => 1;

# construction

sub wrap {
    my ( $class, @args ) = @_;

    unshift @args, 'body' if @args % 2 == 1;

    my %params = @args;
    my $code = $params{body};

    if (blessed($code) && $code->isa(__PACKAGE__)) {
        my $method = $code->clone;
        delete $params{body};
        Class::MOP::class_of($class)->rebless_instance($method, %params);
        return $method;
    }
    elsif (!ref $code || 'CODE' ne reftype($code)) {
        $class->_throw_exception( WrapTakesACodeRefToBless => params => \%params,
                                                                  class  => $class,
                                                                  code   => $code
                                    );
    }

    ($params{package_name} && $params{name})
        || $class->_throw_exception( PackageNameAndNameParamsNotGivenToWrap => params => \%params,
                                                                                   class  => $class,
                                                                                   code   => $code
                                       );

    my $self = $class->_new(\%params);

    weaken($self->{associated_metaclass}) if $self->{associated_metaclass};

    return $self;
}

sub _new {
    my $class = shift;

    return Class::MOP::Class->initialize($class)->new_object(@_)
        if $class ne __PACKAGE__;

    my $params = @_ == 1 ? $_[0] : {@_};

    return bless {
        'body'                 => $params->{body},
        'associated_metaclass' => $params->{associated_metaclass},
        'package_name'         => $params->{package_name},
        'name'                 => $params->{name},
        'original_method'      => $params->{original_method},
    } => $class;
}

## accessors

sub associated_metaclass { shift->{'associated_metaclass'} }

sub attach_to_class {
    my ( $self, $class ) = @_;
    $self->{associated_metaclass} = $class;
    weaken($self->{associated_metaclass});
}

sub detach_from_class {
    my $self = shift;
    delete $self->{associated_metaclass};
}

sub fully_qualified_name {
    my $self = shift;
    $self->package_name . '::' . $self->name;
}

sub original_method { (shift)->{'original_method'} }

sub _set_original_method { $_[0]->{'original_method'} = $_[1] }

# It's possible that this could cause a loop if there is a circular
# reference in here. That shouldn't ever happen in normal
# circumstances, since original method only gets set when clone is
# called. We _could_ check for such a loop, but it'd involve some sort
# of package-lexical variable, and wouldn't be terribly subclassable.
sub original_package_name {
    my $self = shift;

    $self->original_method
        ? $self->original_method->original_package_name
        : $self->package_name;
}

sub original_name {
    my $self = shift;

    $self->original_method
        ? $self->original_method->original_name
        : $self->name;
}

sub original_fully_qualified_name {
    my $self = shift;

    $self->original_method
        ? $self->original_method->original_fully_qualified_name
        : $self->fully_qualified_name;
}

sub execute {
    my $self = shift;
    $self->body->(@_);
}

# We used to go through use Class::MOP::Class->clone_instance to do this, but
# this was awfully slow. This method may be called a number of times when
# classes are loaded (especially during Moose role application), so it is
# worth optimizing. - DR
sub clone {
    my $self = shift;

    my $clone = bless { %{$self}, @_ }, blessed($self);
    weaken($clone->{associated_metaclass}) if $clone->{associated_metaclass};

    $clone->_set_original_method($self);

    return $clone;
}

sub _inline_throw_exception {
    my ( $self, $exception_type, $throw_args ) = @_;
    return
          'die Module::Runtime::use_module("Moose::Exception::'
        . $exception_type
        . '")->new('
        . ( $throw_args || '' ) . ')';
}

1;

# ABSTRACT: Method Meta Object

package Class::MOP::Method::Wrapped;
our $VERSION = '2.2204';

use strict;
use warnings;

use Scalar::Util 'blessed';
use Sub::Util 1.40 'set_subname';

use parent 'Class::MOP::Method';

# NOTE:
# this ugly beast is the result of trying
# to micro optimize this as much as possible
# while not completely loosing maintainability.
# At this point it's "fast enough", after all
# you can't get something for nothing :)
my $_build_wrapped_method = sub {
    my $modifier_table = shift;
    my ($before, $after, $around) = (
        $modifier_table->{before},
        $modifier_table->{after},
        $modifier_table->{around},
    );
    if (@$before && @$after) {
        $modifier_table->{cache} = sub {
            for my $c (@$before) { $c->(@_) };
            my @rval;
            ((defined wantarray) ?
                ((wantarray) ?
                    (@rval = $around->{cache}->(@_))
                    :
                    ($rval[0] = $around->{cache}->(@_)))
                :
                $around->{cache}->(@_));
            for my $c (@$after) { $c->(@_) };
            return unless defined wantarray;
            return wantarray ? @rval : $rval[0];
        }
    }
    elsif (@$before) {
        $modifier_table->{cache} = sub {
            for my $c (@$before) { $c->(@_) };
            return $around->{cache}->(@_);
        }
    }
    elsif (@$after) {
        $modifier_table->{cache} = sub {
            my @rval;
            ((defined wantarray) ?
                ((wantarray) ?
                    (@rval = $around->{cache}->(@_))
                    :
                    ($rval[0] = $around->{cache}->(@_)))
                :
                $around->{cache}->(@_));
            for my $c (@$after) { $c->(@_) };
            return unless defined wantarray;
            return wantarray ? @rval : $rval[0];
        }
    }
    else {
        $modifier_table->{cache} = $around->{cache};
    }
};

sub wrap {
    my ( $class, $code, %params ) = @_;

    (blessed($code) && $code->isa('Class::MOP::Method'))
        || $class->_throw_exception( CanOnlyWrapBlessedCode => params => \%params,
                                                      class  => $class,
                                                      code   => $code
                          );

    my $modifier_table = {
        cache  => undef,
        orig   => $code->body,
        before => [],
        after  => [],
        around => {
            cache   => $code->body,
            methods => [],
        },
    };
    $_build_wrapped_method->($modifier_table);

    # get these from the original unless explicitly overridden
    my $pkg_name    = $params{package_name} || $code->package_name;
    my $method_name = $params{name}         || $code->name;

    return $class->SUPER::wrap(
        sub {
            my $wrapped
                = set_subname( "${pkg_name}::_wrapped_${method_name}" =>
                    $modifier_table->{cache} );
            return $wrapped->(@_) ;
        },
        package_name    => $pkg_name,
        name            => $method_name,
        original_method => $code,
        modifier_table  => $modifier_table,
    );
}

sub _new {
    my $class = shift;
    return Class::MOP::Class->initialize($class)->new_object(@_)
        if $class ne __PACKAGE__;

    my $params = @_ == 1 ? $_[0] : {@_};

    return bless {
        # inherited from Class::MOP::Method
        'body'                 => $params->{body},
        'associated_metaclass' => $params->{associated_metaclass},
        'package_name'         => $params->{package_name},
        'name'                 => $params->{name},
        'original_method'      => $params->{original_method},

        # defined in this class
        'modifier_table'       => $params->{modifier_table}
    } => $class;
}

sub get_original_method {
    my $code = shift;
    $code->original_method;
}

sub add_before_modifier {
    my $code     = shift;
    my $modifier = shift;
    unshift @{$code->{'modifier_table'}->{before}} => $modifier;
    $_build_wrapped_method->($code->{'modifier_table'});
}

sub before_modifiers {
    my $code = shift;
    return @{$code->{'modifier_table'}->{before}};
}

sub add_after_modifier {
    my $code     = shift;
    my $modifier = shift;
    push @{$code->{'modifier_table'}->{after}} => $modifier;
    $_build_wrapped_method->($code->{'modifier_table'});
}

sub after_modifiers {
    my $code = shift;
    return @{$code->{'modifier_table'}->{after}};
}

{
    # NOTE:
    # this is another possible candidate for
    # optimization as well. There is an overhead
    # associated with the currying that, if
    # eliminated might make around modifiers
    # more manageable.
    my $compile_around_method = sub {{
        my $f1 = pop;
        return $f1 unless @_;
        my $f2 = pop;
        push @_, sub { $f2->( $f1, @_ ) };
        redo;
    }};

    sub add_around_modifier {
        my $code     = shift;
        my $modifier = shift;
        unshift @{$code->{'modifier_table'}->{around}->{methods}} => $modifier;
        $code->{'modifier_table'}->{around}->{cache} = $compile_around_method->(
            @{$code->{'modifier_table'}->{around}->{methods}},
            $code->{'modifier_table'}->{orig}
        );
        $_build_wrapped_method->($code->{'modifier_table'});
    }
}

sub around_modifiers {
    my $code = shift;
    return @{$code->{'modifier_table'}->{around}->{methods}};
}

sub _make_compatible_with {
    my $self = shift;
    my ($other) = @_;

    # XXX: this is pretty gross. the issue here is that CMOP::Method::Wrapped
    # objects are subclasses of CMOP::Method, but when we get to moose, they'll
    # need to be compatible with Moose::Meta::Method, which isn't possible. the
    # right solution here is to make ::Wrapped into a role that gets applied to
    # whatever the method_metaclass happens to be and get rid of
    # wrapped_method_metaclass entirely, but that's not going to happen until
    # we ditch cmop and get roles into the bootstrapping, so. i'm not
    # maintaining the previous behavior of turning them into instances of the
    # new method_metaclass because that's equally broken, and at least this way
    # any issues will at least be detectable and potentially fixable. -doy
    return $self unless $other->_is_compatible_with($self->_real_ref_name);

    return $self->SUPER::_make_compatible_with(@_);
}

1;

# ABSTRACT: Method Meta Object for methods with before/after/around modifiers

package Class::MOP::Method::Generated;
our $VERSION = '2.2204';

use strict;
use warnings;

use Eval::Closure;

use parent 'Class::MOP::Method';

## accessors

sub new {
    $_[0]->_throw_exception( CannotCallAnAbstractBaseMethod => package_name => __PACKAGE__ );
}

sub _initialize_body {
    $_[0]->_throw_exception( NoBodyToInitializeInAnAbstractBaseClass => package_name => __PACKAGE__ );
}

sub _generate_description {
    my ( $self, $context ) = @_;
    $context ||= $self->definition_context;

    my $desc = "generated method";
    my $origin = "unknown origin";

    if (defined $context) {
        if (defined $context->{description}) {
            $desc = $context->{description};
        }

        if (defined $context->{file} || defined $context->{line}) {
            $origin = "defined at "
                    . (defined $context->{file}
                        ? $context->{file} : "<unknown file>")
                    . " line "
                    . (defined $context->{line}
                        ? $context->{line} : "<unknown line>");
        }
    }

    return "$desc ($origin)";
}

sub _compile_code {
    my ( $self, @args ) = @_;
    unshift @args, 'source' if @args % 2;
    my %args = @args;

    my $context = delete $args{context};
    my $environment = $self->can('_eval_environment')
        ? $self->_eval_environment
        : {};

    return eval_closure(
        environment => $environment,
        description => $self->_generate_description($context),
        %args,
    );
}

1;

# ABSTRACT: Abstract base class for generated methods

package Class::MOP::Method::Inlined;
our $VERSION = '2.2204';

use strict;
use warnings;

use Scalar::Util 'refaddr';

use parent 'Class::MOP::Method::Generated';

sub _uninlined_body {
    my $self = shift;

    my $super_method
        = $self->associated_metaclass->find_next_method_by_name( $self->name )
        or return;

    if ( $super_method->isa(__PACKAGE__) ) {
        return $super_method->_uninlined_body;
    }
    else {
        return $super_method->body;
    }
}

sub can_be_inlined {
    my $self      = shift;
    my $metaclass = $self->associated_metaclass;
    my $class     = $metaclass->name;

    # If we don't find an inherited method, this is a rather weird
    # case where we have no method in the inheritance chain even
    # though we're expecting one to be there
    my $inherited_method
        = $metaclass->find_next_method_by_name( $self->name );

    if (   $inherited_method
        && $inherited_method->isa('Class::MOP::Method::Wrapped') ) {
        warn "Not inlining '"
            . $self->name
            . "' for $class since it "
            . "has method modifiers which would be lost if it were inlined\n";

        return 0;
    }

    my $expected_class = $self->_expected_method_class
        or return 1;

    # if we are shadowing a method we first verify that it is
    # compatible with the definition we are replacing it with
    my $expected_method = $expected_class->can( $self->name );

    if ( ! $expected_method ) {
        warn "Not inlining '"
            . $self->name
            . "' for $class since ${expected_class}::"
            . $self->name
            . " is not defined\n";

        return 0;
    }

    my $actual_method = $class->can( $self->name )
        or return 1;

    # the method is what we wanted (probably Moose::Object::new)
    return 1
        if refaddr($expected_method) == refaddr($actual_method);

    # otherwise we have to check that the actual method is an inlined
    # version of what we're expecting
    if ( $inherited_method->isa(__PACKAGE__) ) {
        if ( $inherited_method->_uninlined_body
             && refaddr( $inherited_method->_uninlined_body )
             == refaddr($expected_method) ) {
            return 1;
        }
    }
    elsif ( refaddr( $inherited_method->body )
            == refaddr($expected_method) ) {
        return 1;
    }

    my $warning
        = "Not inlining '"
        . $self->name
        . "' for $class since it is not"
        . " inheriting the default ${expected_class}::"
        . $self->name . "\n";

    if ( $self->isa("Class::MOP::Method::Constructor") ) {

        # FIXME kludge, refactor warning generation to a method
        $warning
            .= "If you are certain you don't need to inline your"
            . " constructor, specify inline_constructor => 0 in your"
            . " call to $class->meta->make_immutable\n";
    }

    warn $warning;

    return 0;
}

1;

# ABSTRACT: Method base class for methods which have been inlined

package Class::MOP::Method::Meta;
our $VERSION = '2.2204';

use strict;
use warnings;

use Carp         'confess';
use Scalar::Util 'blessed', 'weaken';

use constant DEBUG_NO_META => $ENV{DEBUG_NO_META} ? 1 : 0;

use parent 'Class::MOP::Method';

sub _is_caller_mop_internal {
    my $self = shift;
    my ($caller) = @_;
    return $caller =~ /^(?:Class::MOP|metaclass)(?:::|$)/;
}

sub _generate_meta_method {
    my $method_self = shift;
    my $metaclass   = shift;
    weaken($metaclass);

    sub {
        # this will be compiled out if the env var wasn't set
        if (DEBUG_NO_META) {
            confess "'meta' method called by MOP internals"
                # it's okay to call meta methods on metaclasses, since we
                # explicitly ask for them
                if !$_[0]->isa('Class::MOP::Object')
                && !$_[0]->isa('Class::MOP::Mixin')
                # it's okay if the test itself calls ->meta, we only care about
                # if the mop internals call ->meta
                && $method_self->_is_caller_mop_internal(scalar caller);
        }
        # we must re-initialize so that it
        # works as expected in subclasses,
        # since metaclass instances are
        # singletons, this is not really a
        # big deal anyway.
        $metaclass->initialize(blessed($_[0]) || $_[0])
    };
}

sub wrap {
    my ($class, @args) = @_;

    unshift @args, 'body' if @args % 2 == 1;
    my %params = @args;
    $class->_throw_exception( CannotOverrideBodyOfMetaMethods => params => \%params,
                                                                     class  => $class
                                )
        if $params{body};

    my $metaclass_class = $params{associated_metaclass}->meta;
    $params{body} = $class->_generate_meta_method($metaclass_class);
    return $class->SUPER::wrap(%params);
}

sub _make_compatible_with {
    my $self = shift;
    my ($other) = @_;

    # XXX: this is pretty gross. the issue here is that CMOP::Method::Meta
    # objects are subclasses of CMOP::Method, but when we get to moose, they'll
    # need to be compatible with Moose::Meta::Method, which isn't possible. the
    # right solution here is to make ::Meta into a role that gets applied to
    # whatever the method_metaclass happens to be and get rid of
    # _meta_method_metaclass entirely, but that's not going to happen until
    # we ditch cmop and get roles into the bootstrapping, so. i'm not
    # maintaining the previous behavior of turning them into instances of the
    # new method_metaclass because that's equally broken, and at least this way
    # any issues will at least be detectable and potentially fixable. -doy
    return $self unless $other->_is_compatible_with($self->_real_ref_name);

    return $self->SUPER::_make_compatible_with(@_);
}

1;

# ABSTRACT: Method Meta Object for C<meta> methods

package Class::MOP::Method::Constructor;
our $VERSION = '2.2204';

use strict;
use warnings;

use Scalar::Util 'blessed', 'weaken';
use Try::Tiny;

use parent 'Class::MOP::Method::Inlined';

sub new {
    my $class   = shift;
    my %options = @_;

    (blessed $options{metaclass} && $options{metaclass}->isa('Class::MOP::Class'))
        || $class->_throw_exception( MustSupplyAMetaclass => params => \%options,
                                                    class  => $class
                          )
            if $options{is_inline};

    ($options{package_name} && $options{name})
        || $class->_throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                            class  => $class
                          );

    my $self = $class->_new(\%options);

    # we don't want this creating
    # a cycle in the code, if not
    # needed
    weaken($self->{'associated_metaclass'});

    $self->_initialize_body;

    return $self;
}

sub _new {
    my $class = shift;

    return Class::MOP::Class->initialize($class)->new_object(@_)
        if $class ne __PACKAGE__;

    my $params = @_ == 1 ? $_[0] : {@_};

    return bless {
        # inherited from Class::MOP::Method
        body                 => $params->{body},
        # associated_metaclass => $params->{associated_metaclass}, # overridden
        package_name         => $params->{package_name},
        name                 => $params->{name},
        original_method      => $params->{original_method},

        # inherited from Class::MOP::Generated
        is_inline            => $params->{is_inline} || 0,
        definition_context   => $params->{definition_context},

        # inherited from Class::MOP::Inlined
        _expected_method_class => $params->{_expected_method_class},

        # defined in this subclass
        options              => $params->{options} || {},
        associated_metaclass => $params->{metaclass},
    }, $class;
}

## accessors

sub options              { (shift)->{'options'}              }
sub associated_metaclass { (shift)->{'associated_metaclass'} }

## method

sub _initialize_body {
    my $self        = shift;
    my $method_name = '_generate_constructor_method';

    $method_name .= '_inline' if $self->is_inline;

    $self->{'body'} = $self->$method_name;
}

sub _eval_environment {
    my $self = shift;
    return $self->associated_metaclass->_eval_environment;
}

sub _generate_constructor_method {
    return sub { Class::MOP::Class->initialize(shift)->new_object(@_) }
}

sub _generate_constructor_method_inline {
    my $self = shift;

    my $meta = $self->associated_metaclass;

    my @source = (
        'sub {',
            $meta->_inline_new_object,
        '}',
    );

    warn join("\n", @source) if $self->options->{debug};

    my $code = try {
        $self->_compile_code(\@source);
    }
    catch {
        my $source = join("\n", @source);
        $self->_throw_exception( CouldNotEvalConstructor => constructor_method => $self,
                                                    source             => $source,
                                                    error              => $_
                       );
    };

    return $code;
}

1;

# ABSTRACT: Method Meta Object for constructors

package Class::MOP::Method::Accessor;
our $VERSION = '2.2204';

use strict;
use warnings;

use Scalar::Util 'blessed', 'weaken';
use Try::Tiny;

use parent 'Class::MOP::Method::Generated';

sub new {
    my $class   = shift;
    my %options = @_;

    (exists $options{attribute})
        || $class->_throw_exception( MustSupplyAnAttributeToConstructWith => params => \%options,
                                                                    class  => $class,
                          );

    (exists $options{accessor_type})
        || $class->_throw_exception( MustSupplyAnAccessorTypeToConstructWith => params => \%options,
                                                                       class  => $class,
                          );

    (blessed($options{attribute}) && $options{attribute}->isa('Class::MOP::Attribute'))
        || $class->_throw_exception( MustSupplyAClassMOPAttributeInstance => params => \%options,
                                                                    class  => $class
                          );

    ($options{package_name} && $options{name})
        || $class->_throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                            class  => $class
                          );

    my $self = $class->_new(\%options);

    # we don't want this creating
    # a cycle in the code, if not
    # needed
    weaken($self->{'attribute'});

    $self->_initialize_body;

    return $self;
}

sub _new {
    my $class = shift;

    return Class::MOP::Class->initialize($class)->new_object(@_)
        if $class ne __PACKAGE__;

    my $params = @_ == 1 ? $_[0] : {@_};

    return bless {
        # inherited from Class::MOP::Method
        body                 => $params->{body},
        associated_metaclass => $params->{associated_metaclass},
        package_name         => $params->{package_name},
        name                 => $params->{name},
        original_method      => $params->{original_method},

        # inherit from Class::MOP::Generated
        is_inline            => $params->{is_inline} || 0,
        definition_context   => $params->{definition_context},

        # defined in this class
        attribute            => $params->{attribute},
        accessor_type        => $params->{accessor_type},
    } => $class;
}

## accessors

sub associated_attribute { (shift)->{'attribute'}     }
sub accessor_type        { (shift)->{'accessor_type'} }

## factory

sub _initialize_body {
    my $self = shift;

    my $method_name = join "_" => (
        '_generate',
        $self->accessor_type,
        'method',
        ($self->is_inline ? 'inline' : ())
    );

    $self->{'body'} = $self->$method_name();
}

## generators

sub _generate_accessor_method {
    my $self = shift;
    my $attr = $self->associated_attribute;

    return sub {
        if (@_ >= 2) {
            $attr->set_value($_[0], $_[1]);
        }
        $attr->get_value($_[0]);
    };
}

sub _generate_accessor_method_inline {
    my $self = shift;
    my $attr = $self->associated_attribute;

    return try {
        $self->_compile_code([
            'sub {',
                'if (@_ > 1) {',
                    $attr->_inline_set_value('$_[0]', '$_[1]'),
                '}',
                $attr->_inline_get_value('$_[0]'),
            '}',
        ]);
    }
    catch {
        $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                  error    => $_,
                                                                  option   => "accessor"
                       );
    };
}

sub _generate_reader_method {
    my $self = shift;
    my $attr = $self->associated_attribute;
    my $class = $attr->associated_class;

    return sub {
        $self->_throw_exception( CannotAssignValueToReadOnlyAccessor => class_name => $class->name,
                                                                value      => $_[1],
                                                                attribute  => $attr
                       )
            if @_ > 1;
        $attr->get_value($_[0]);
    };
}

sub _generate_reader_method_inline {
    my $self = shift;
    my $attr = $self->associated_attribute;
    my $attr_name = $attr->name;

    return try {
        $self->_compile_code([
            'sub {',
                'if (@_ > 1) {',
                    $self->_inline_throw_exception( CannotAssignValueToReadOnlyAccessor =>
                                                    'class_name                          => ref $_[0],'.
                                                    'value                               => $_[1],'.
                                                    "attribute_name                      => '".$attr_name."'",
                    ) . ';',
                '}',
                $attr->_inline_get_value('$_[0]'),
            '}',
        ]);
    }
    catch {
        $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                  error    => $_,
                                                                  option   => "reader"
                       );
    };
}

sub _generate_writer_method {
    my $self = shift;
    my $attr = $self->associated_attribute;

    return sub {
        $attr->set_value($_[0], $_[1]);
    };
}

sub _generate_writer_method_inline {
    my $self = shift;
    my $attr = $self->associated_attribute;

    return try {
        $self->_compile_code([
            'sub {',
                $attr->_inline_set_value('$_[0]', '$_[1]'),
            '}',
        ]);
    }
    catch {
        $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                  error    => $_,
                                                                  option   => "writer"
                       );
    };
}

sub _generate_predicate_method {
    my $self = shift;
    my $attr = $self->associated_attribute;

    return sub {
        $attr->has_value($_[0])
    };
}

sub _generate_predicate_method_inline {
    my $self = shift;
    my $attr = $self->associated_attribute;

    return try {
        $self->_compile_code([
            'sub {',
                $attr->_inline_has_value('$_[0]'),
            '}',
        ]);
    }
    catch {
        $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                  error    => $_,
                                                                  option   => "predicate"
                       );
    };
}

sub _generate_clearer_method {
    my $self = shift;
    my $attr = $self->associated_attribute;

    return sub {
        $attr->clear_value($_[0])
    };
}

sub _generate_clearer_method_inline {
    my $self = shift;
    my $attr = $self->associated_attribute;

    return try {
        $self->_compile_code([
            'sub {',
                $attr->_inline_clear_value('$_[0]'),
            '}',
        ]);
    }
    catch {
        $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                  error    => $_,
                                                                  option   => "clearer"
                       );
    };
}

1;

# ABSTRACT: Method Meta Object for accessors

package Class::MOP::Attribute;
our $VERSION = '2.2204';

use strict;
use warnings;

use Class::MOP::Method::Accessor;

use Carp         'confess';
use Scalar::Util 'blessed', 'weaken';
use Try::Tiny;

use parent 'Class::MOP::Object', 'Class::MOP::Mixin::AttributeCore';

# NOTE: (meta-circularity)
# This method will be replaced in the
# boostrap section of Class::MOP, by
# a new version which uses the
# &Class::MOP::Class::construct_instance
# method to build an attribute meta-object
# which itself is described with attribute
# meta-objects.
#     - Ain't meta-circularity grand? :)
sub new {
    my ( $class, @args ) = @_;

    unshift @args, "name" if @args % 2 == 1;
    my %options = @args;

    my $name = $options{name};

    (defined $name)
        || $class->_throw_exception( MOPAttributeNewNeedsAttributeName => class  => $class,
                                                                 params => \%options
                          );

    $options{init_arg} = $name
        if not exists $options{init_arg};
    if(exists $options{builder}){
        $class->_throw_exception( BuilderMustBeAMethodName => class  => $class,
                                                     params => \%options
                       )
            if ref $options{builder} || !(defined $options{builder});
        $class->_throw_exception( BothBuilderAndDefaultAreNotAllowed => class  => $class,
                                                               params => \%options
                       )
            if exists $options{default};
    } else {
        ($class->is_default_a_coderef(\%options))
            || $class->_throw_exception( ReferencesAreNotAllowedAsDefault => class          => $class,
                                                                    params         => \%options,
                                                                    attribute_name => $options{name}
                              )
                if exists $options{default} && ref $options{default};
    }

    if( $options{required} and not( defined($options{builder}) || defined($options{init_arg}) || exists $options{default} ) ) {
        $class->_throw_exception( RequiredAttributeLacksInitialization => class  => $class,
                                                                 params => \%options
                       );
    }

    $class->_new(\%options);
}

sub _new {
    my $class = shift;

    return Class::MOP::Class->initialize($class)->new_object(@_)
        if $class ne __PACKAGE__;

    my $options = @_ == 1 ? $_[0] : {@_};

    bless {
        'name'               => $options->{name},
        'accessor'           => $options->{accessor},
        'reader'             => $options->{reader},
        'writer'             => $options->{writer},
        'predicate'          => $options->{predicate},
        'clearer'            => $options->{clearer},
        'builder'            => $options->{builder},
        'init_arg'           => $options->{init_arg},
        exists $options->{default}
            ? ('default'     => $options->{default})
            : (),
        'initializer'        => $options->{initializer},
        'definition_context' => $options->{definition_context},
        # keep a weakened link to the
        # class we are associated with
        'associated_class' => undef,
        # and a list of the methods
        # associated with this attr
        'associated_methods' => [],
        # this let's us keep track of
        # our order inside the associated
        # class
        'insertion_order'    => undef,
    }, $class;
}

# NOTE:
# this is a primitive (and kludgy) clone operation
# for now, it will be replaced in the Class::MOP
# bootstrap with a proper one, however we know
# that this one will work fine for now.
sub clone {
    my $self    = shift;
    my %options = @_;
    (blessed($self))
        || confess "Can only clone an instance";
    # this implementation is overwritten by the bootstrap process,
    # so this exception will never trigger. If it ever does occur,
    # it indicates a gigantic problem with the most internal parts
    # of Moose, so we wouldn't want a Moose-based exception object anyway

    return bless { %{$self}, %options } => ref($self);
}

sub initialize_instance_slot {
    my ($self, $meta_instance, $instance, $params) = @_;
    my $init_arg = $self->{'init_arg'};

    # try to fetch the init arg from the %params ...

    # if nothing was in the %params, we can use the
    # attribute's default value (if it has one)
    if(defined $init_arg and exists $params->{$init_arg}){
        $self->_set_initial_slot_value(
            $meta_instance,
            $instance,
            $params->{$init_arg},
        );
    }
    elsif (exists $self->{'default'}) {
        $self->_set_initial_slot_value(
            $meta_instance,
            $instance,
            $self->default($instance),
        );
    }
    elsif (defined( my $builder = $self->{'builder'})) {
        if ($builder = $instance->can($builder)) {
            $self->_set_initial_slot_value(
                $meta_instance,
                $instance,
                $instance->$builder,
            );
        }
        else {
            $self->_throw_exception( BuilderMethodNotSupportedForAttribute => attribute => $self,
                                                                      instance  => $instance
                           );
        }
    }
}

sub _set_initial_slot_value {
    my ($self, $meta_instance, $instance, $value) = @_;

    my $slot_name = $self->name;

    return $meta_instance->set_slot_value($instance, $slot_name, $value)
        unless $self->has_initializer;

    my $callback = $self->_make_initializer_writer_callback(
        $meta_instance, $instance, $slot_name
    );

    my $initializer = $self->initializer;

    # most things will just want to set a value, so make it first arg
    $instance->$initializer($value, $callback, $self);
}

sub _make_initializer_writer_callback {
    my $self = shift;
    my ($meta_instance, $instance, $slot_name) = @_;

    return sub {
        $meta_instance->set_slot_value($instance, $slot_name, $_[0]);
    };
}

sub get_read_method  {
    my $self   = shift;
    my $reader = $self->reader || $self->accessor;
    # normal case ...
    return $reader unless ref $reader;
    # the HASH ref case
    my ($name) = %$reader;
    return $name;
}

sub get_write_method {
    my $self   = shift;
    my $writer = $self->writer || $self->accessor;
    # normal case ...
    return $writer unless ref $writer;
    # the HASH ref case
    my ($name) = %$writer;
    return $name;
}

sub get_read_method_ref {
    my $self = shift;
    if ((my $reader = $self->get_read_method) && $self->associated_class) {
        return $self->associated_class->get_method($reader);
    }
    else {
        my $code = sub { $self->get_value(@_) };
        if (my $class = $self->associated_class) {
            return $class->method_metaclass->wrap(
                $code,
                package_name => $class->name,
                name         => '__ANON__'
            );
        }
        else {
            return $code;
        }
    }
}

sub get_write_method_ref {
    my $self = shift;
    if ((my $writer = $self->get_write_method) && $self->associated_class) {
        return $self->associated_class->get_method($writer);
    }
    else {
        my $code = sub { $self->set_value(@_) };
        if (my $class = $self->associated_class) {
            return $class->method_metaclass->wrap(
                $code,
                package_name => $class->name,
                name         => '__ANON__'
            );
        }
        else {
            return $code;
        }
    }
}

# slots

sub slots { (shift)->name }

# class association

sub attach_to_class {
    my ($self, $class) = @_;
    (blessed($class) && $class->isa('Class::MOP::Class'))
        || $self->_throw_exception( AttachToClassNeedsAClassMOPClassInstanceOrASubclass => attribute => $self,
                                                                                   class     => $class
                          );
    weaken($self->{'associated_class'} = $class);
}

sub detach_from_class {
    my $self = shift;
    $self->{'associated_class'} = undef;
}

# method association

sub associate_method {
    my ($self, $method) = @_;
    push @{$self->{'associated_methods'}} => $method;
}

## Slot management

sub set_initial_value {
    my ($self, $instance, $value) = @_;
    $self->_set_initial_slot_value(
        Class::MOP::Class->initialize(ref($instance))->get_meta_instance,
        $instance,
        $value
    );
}

sub set_value { shift->set_raw_value(@_) }

sub set_raw_value {
    my $self = shift;
    my ($instance, $value) = @_;

    my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
    return $mi->set_slot_value($instance, $self->name, $value);
}

sub _inline_set_value {
    my $self = shift;
    return $self->_inline_instance_set(@_) . ';';
}

sub _inline_instance_set {
    my $self = shift;
    my ($instance, $value) = @_;

    my $mi = $self->associated_class->get_meta_instance;
    return $mi->inline_set_slot_value($instance, $self->name, $value);
}

sub get_value { shift->get_raw_value(@_) }

sub get_raw_value {
    my $self = shift;
    my ($instance) = @_;

    my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
    return $mi->get_slot_value($instance, $self->name);
}

sub _inline_get_value {
    my $self = shift;
    return $self->_inline_instance_get(@_) . ';';
}

sub _inline_instance_get {
    my $self = shift;
    my ($instance) = @_;

    my $mi = $self->associated_class->get_meta_instance;
    return $mi->inline_get_slot_value($instance, $self->name);
}

sub has_value {
    my $self = shift;
    my ($instance) = @_;

    my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
    return $mi->is_slot_initialized($instance, $self->name);
}

sub _inline_has_value {
    my $self = shift;
    return $self->_inline_instance_has(@_) . ';';
}

sub _inline_instance_has {
    my $self = shift;
    my ($instance) = @_;

    my $mi = $self->associated_class->get_meta_instance;
    return $mi->inline_is_slot_initialized($instance, $self->name);
}

sub clear_value {
    my $self = shift;
    my ($instance) = @_;

    my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
    return $mi->deinitialize_slot($instance, $self->name);
}

sub _inline_clear_value {
    my $self = shift;
    return $self->_inline_instance_clear(@_) . ';';
}

sub _inline_instance_clear {
    my $self = shift;
    my ($instance) = @_;

    my $mi = $self->associated_class->get_meta_instance;
    return $mi->inline_deinitialize_slot($instance, $self->name);
}

## load em up ...

sub accessor_metaclass { 'Class::MOP::Method::Accessor' }

sub _process_accessors {
    my ($self, $type, $accessor, $generate_as_inline_methods) = @_;

    my $method_ctx = { %{ $self->definition_context || {} } };

    if (ref($accessor)) {
        (ref($accessor) eq 'HASH')
            || $self->_throw_exception( BadOptionFormat => attribute    => $self,
                                                   option_value => $accessor,
                                                   option_name  => $type
                              );

        my ($name, $method) = %{$accessor};

        $method_ctx->{description} = $self->_accessor_description($name, $type);

        $method = $self->accessor_metaclass->wrap(
            $method,
            attribute    => $self,
            package_name => $self->associated_class->name,
            name         => $name,
            associated_metaclass => $self->associated_class,
            definition_context => $method_ctx,
        );
        $self->associate_method($method);
        return ($name, $method);
    }
    else {
        my $inline_me = ($generate_as_inline_methods && $self->associated_class->instance_metaclass->is_inlinable);
        my $method;
        try {
            $method_ctx->{description} = $self->_accessor_description($accessor, $type);

            $method = $self->accessor_metaclass->new(
                attribute     => $self,
                is_inline     => $inline_me,
                accessor_type => $type,
                package_name  => $self->associated_class->name,
                name          => $accessor,
                associated_metaclass => $self->associated_class,
                definition_context => $method_ctx,
            );
        }
        catch {
            $self->_throw_exception( CouldNotCreateMethod => attribute    => $self,
                                                     option_value => $accessor,
                                                     option_name  => $type,
                                                     error        => $_
                           );
        };
        $self->associate_method($method);
        return ($accessor, $method);
    }
}

sub _accessor_description {
    my $self = shift;
    my ($name, $type) = @_;

    my $desc = "$type " . $self->associated_class->name . "::$name";
    if ( $name ne $self->name ) {
        $desc .= " of attribute " . $self->name;
    }

    return $desc;
}

sub install_accessors {
    my $self   = shift;
    my $inline = shift;
    my $class  = $self->associated_class;

    $class->add_method(
        $self->_process_accessors('accessor' => $self->accessor(), $inline)
    ) if $self->has_accessor();

    $class->add_method(
        $self->_process_accessors('reader' => $self->reader(), $inline)
    ) if $self->has_reader();

    $class->add_method(
        $self->_process_accessors('writer' => $self->writer(), $inline)
    ) if $self->has_writer();

    $class->add_method(
        $self->_process_accessors('predicate' => $self->predicate(), $inline)
    ) if $self->has_predicate();

    $class->add_method(
        $self->_process_accessors('clearer' => $self->clearer(), $inline)
    ) if $self->has_clearer();

    return;
}

{
    my $_remove_accessor = sub {
        my ($accessor, $class) = @_;
        if (ref($accessor) && ref($accessor) eq 'HASH') {
            ($accessor) = keys %{$accessor};
        }
        my $method = $class->get_method($accessor);
        $class->remove_method($accessor)
            if (ref($method) && $method->isa('Class::MOP::Method::Accessor'));
    };

    sub remove_accessors {
        my $self = shift;
        # TODO:
        # we really need to make sure to remove from the
        # associates methods here as well. But this is
        # such a slimly used method, I am not worried
        # about it right now.
        $_remove_accessor->($self->accessor(),  $self->associated_class()) if $self->has_accessor();
        $_remove_accessor->($self->reader(),    $self->associated_class()) if $self->has_reader();
        $_remove_accessor->($self->writer(),    $self->associated_class()) if $self->has_writer();
        $_remove_accessor->($self->predicate(), $self->associated_class()) if $self->has_predicate();
        $_remove_accessor->($self->clearer(),   $self->associated_class()) if $self->has_clearer();
        return;
    }

}

1;

# ABSTRACT: Attribute Meta Object

package Class::MOP::Deprecated;
our $VERSION = '2.2204';

use strict;
use warnings;

use Package::DeprecationManager -deprecations => {
    'Class::Load wrapper functions' => '2.1100',
};

1;

# ABSTRACT: Manages deprecation warnings for Class::MOP

package Class::MOP::Module;
our $VERSION = '2.2204';

use strict;
use warnings;

use parent 'Class::MOP::Package';

sub _new {
    my $class = shift;
    return Class::MOP::Class->initialize($class)->new_object(@_)
        if $class ne __PACKAGE__;

    my $params = @_ == 1 ? $_[0] : {@_};
    return bless {
        # Need to quote package to avoid a problem with PPI mis-parsing this
        # as a package statement.

        # from Class::MOP::Package
        'package' => $params->{package},
        namespace => \undef,

        # attributes
        version   => \undef,
        authority => \undef
    } => $class;
}

sub version {
    my $self = shift;
    ${$self->get_or_add_package_symbol('$VERSION')};
}

sub authority {
    my $self = shift;
    ${$self->get_or_add_package_symbol('$AUTHORITY')};
}

sub identifier {
    my $self = shift;
    join '-' => (
        $self->name,
        ($self->version   || ()),
        ($self->authority || ()),
    );
}

sub create {
    my $class = shift;
    my @args = @_;

    unshift @args, 'package' if @args % 2 == 1;
    my %options = @args;

    my $package   = delete $options{package};
    my $version   = delete $options{version};
    my $authority = delete $options{authority};

    my $meta = $class->SUPER::create($package => %options);

    $meta->_instantiate_module($version, $authority);

    return $meta;
}

sub _anon_package_prefix { 'Class::MOP::Module::__ANON__::SERIAL::' }

sub _anon_cache_key {
    my $class = shift;
    my %options = @_;
    $class->_throw_exception( PackagesAndModulesAreNotCachable => class_name => $class,
                                                         params     => \%options,
                                                         is_module  => 1
                   );
}

sub _instantiate_module {
    my($self, $version, $authority) = @_;
    my $package_name = $self->name;

    $self->add_package_symbol('$VERSION' => $version)
        if defined $version;
    $self->add_package_symbol('$AUTHORITY' => $authority)
        if defined $authority;

    return;
}

1;

# ABSTRACT: Module Meta Object

package Class::MOP;
our $VERSION = '2.2204';

use strict;
use warnings;

use 5.008003;

use MRO::Compat;
use Class::Load 0.07 ();
use Scalar::Util  'weaken', 'isweak', 'blessed';
use Data::OptList;

use Class::MOP::Mixin::AttributeCore;
use Class::MOP::Mixin::HasAttributes;
use Class::MOP::Mixin::HasMethods;
use Class::MOP::Mixin::HasOverloads;
use Class::MOP::Class;
use Class::MOP::Attribute;
use Class::MOP::Method;

BEGIN {
    *IS_RUNNING_ON_5_10 = ("$]" < 5.009_005)
        ? sub () { 0 }
        : sub () { 1 };

    # this is either part of core or set up appropriately by MRO::Compat
    *check_package_cache_flag = \&mro::get_pkg_gen;
}

XSLoader::load(
    'Moose',
    $VERSION,
);

{
    # Metaclasses are singletons, so we cache them here.
    # there is no need to worry about destruction though
    # because they should die only when the program dies.
    # After all, do package definitions even get reaped?
    # Anonymous classes manage their own destruction.
    my %METAS;

    sub get_all_metaclasses         {        %METAS         }
    sub get_all_metaclass_instances { values %METAS         }
    sub get_all_metaclass_names     { keys   %METAS         }
    sub get_metaclass_by_name       { $METAS{$_[0]}         }
    sub store_metaclass_by_name     { $METAS{$_[0]} = $_[1] }
    sub weaken_metaclass            { weaken($METAS{$_[0]}) }
    sub metaclass_is_weak           { isweak($METAS{$_[0]}) }
    sub does_metaclass_exist        { exists $METAS{$_[0]} && defined $METAS{$_[0]} }
    sub remove_metaclass_by_name    { delete $METAS{$_[0]}; return }

    # This handles instances as well as class names
    sub class_of {
        return unless defined $_[0];
        my $class = blessed($_[0]) || $_[0];
        return $METAS{$class};
    }

    # NOTE:
    # We only cache metaclasses, meaning instances of
    # Class::MOP::Class. We do not cache instance of
    # Class::MOP::Package or Class::MOP::Module. Mostly
    # because I don't yet see a good reason to do so.
}

sub load_class {
    Class::MOP::Deprecated::deprecated(
        message => 'Class::MOP::load_class is deprecated',
        feature => 'Class::Load wrapper functions',
    );
    require Class::Load;
    goto &Class::Load::load_class;
}

sub load_first_existing_class {
    Class::MOP::Deprecated::deprecated(
        message => 'Class::MOP::load_first_existing_class is deprecated',
        feature => 'Class::Load wrapper functions',
    );
    require Class::Load;
    goto &Class::Load::load_first_existing_class;
}

sub is_class_loaded {
    Class::MOP::Deprecated::deprecated(
        message => 'Class::MOP::is_class_loaded is deprecated',
        feature => 'Class::Load wrapper functions',
    );
    require Class::Load;
    goto &Class::Load::is_class_loaded;
}

sub _definition_context {
    my %context;
    @context{qw(package file line)} = caller(0);

    return (
        definition_context => \%context,
    );
}

## ----------------------------------------------------------------------------
## Setting up our environment ...
## ----------------------------------------------------------------------------
## Class::MOP needs to have a few things in the global perl environment so
## that it can operate effectively. Those things are done here.
## ----------------------------------------------------------------------------

# ... nothing yet actually ;)

## ----------------------------------------------------------------------------
## Bootstrapping
## ----------------------------------------------------------------------------
## The code below here is to bootstrap our MOP with itself. This is also
## sometimes called "tying the knot". By doing this, we make it much easier
## to extend the MOP through subclassing and such since now you can use the
## MOP itself to extend itself.
##
## Yes, I know, that's weird and insane, but it's a good thing, trust me :)
## ----------------------------------------------------------------------------

# We need to add in the meta-attributes here so that
# any subclass of Class::MOP::* will be able to
# inherit them using _construct_instance

## --------------------------------------------------------
## Class::MOP::Mixin::HasMethods

Class::MOP::Mixin::HasMethods->meta->add_attribute(
    Class::MOP::Attribute->new('_methods' => (
        reader   => {
            # NOTE:
            # we just alias the original method
            # rather than re-produce it here
            '_method_map' => \&Class::MOP::Mixin::HasMethods::_method_map
        },
        default => sub { {} },
        _definition_context(),
    ))
);

Class::MOP::Mixin::HasMethods->meta->add_attribute(
    Class::MOP::Attribute->new('method_metaclass' => (
        reader   => {
            # NOTE:
            # we just alias the original method
            # rather than re-produce it here
            'method_metaclass' => \&Class::MOP::Mixin::HasMethods::method_metaclass
        },
        default  => 'Class::MOP::Method',
        _definition_context(),
    ))
);

Class::MOP::Mixin::HasMethods->meta->add_attribute(
    Class::MOP::Attribute->new('wrapped_method_metaclass' => (
        reader   => {
            # NOTE:
            # we just alias the original method
            # rather than re-produce it here
            'wrapped_method_metaclass' => \&Class::MOP::Mixin::HasMethods::wrapped_method_metaclass
        },
        default  => 'Class::MOP::Method::Wrapped',
        _definition_context(),
    ))
);

## --------------------------------------------------------
## Class::MOP::Mixin::HasAttributes

Class::MOP::Mixin::HasAttributes->meta->add_attribute(
    Class::MOP::Attribute->new('attributes' => (
        reader   => {
            # NOTE: we need to do this in order
            # for the instance meta-object to
            # not fall into meta-circular death
            #
            # we just alias the original method
            # rather than re-produce it here
            '_attribute_map' => \&Class::MOP::Mixin::HasAttributes::_attribute_map
        },
        default  => sub { {} },
        _definition_context(),
    ))
);

Class::MOP::Mixin::HasAttributes->meta->add_attribute(
    Class::MOP::Attribute->new('attribute_metaclass' => (
        reader   => {
            # NOTE:
            # we just alias the original method
            # rather than re-produce it here
            'attribute_metaclass' => \&Class::MOP::Mixin::HasAttributes::attribute_metaclass
        },
        default  => 'Class::MOP::Attribute',
        _definition_context(),
    ))
);

## --------------------------------------------------------
## Class::MOP::Mixin::HasOverloads

Class::MOP::Mixin::HasOverloads->meta->add_attribute(
    Class::MOP::Attribute->new('_overload_map' => (
        reader   => {
            '_overload_map' => \&Class::MOP::Mixin::HasOverloads::_overload_map
        },
        clearer => '_clear_overload_map',
        default => sub { {} },
        _definition_context(),
    ))
);

## --------------------------------------------------------
## Class::MOP::Package

Class::MOP::Package->meta->add_attribute(
    Class::MOP::Attribute->new('package' => (
        reader   => {
            # NOTE: we need to do this in order
            # for the instance meta-object to
            # not fall into meta-circular death
            #
            # we just alias the original method
            # rather than re-produce it here
            'name' => \&Class::MOP::Package::name
        },
        _definition_context(),
    ))
);

Class::MOP::Package->meta->add_attribute(
    Class::MOP::Attribute->new('namespace' => (
        reader => {
            # NOTE:
            # we just alias the original method
            # rather than re-produce it here
            'namespace' => \&Class::MOP::Package::namespace
        },
        init_arg => undef,
        default  => sub { \undef },
        _definition_context(),
    ))
);

## --------------------------------------------------------
## Class::MOP::Module

# NOTE:
# yeah this is kind of stretching things a bit,
# but truthfully the version should be an attribute
# of the Module, the weirdness comes from having to
# stick to Perl 5 convention and store it in the
# $VERSION package variable. Basically if you just
# squint at it, it will look how you want it to look.
# Either as a package variable, or as a attribute of
# the metaclass, isn't abstraction great :)

Class::MOP::Module->meta->add_attribute(
    Class::MOP::Attribute->new('version' => (
        reader => {
            # NOTE:
            # we just alias the original method
            # rather than re-produce it here
            'version' => \&Class::MOP::Module::version
        },
        init_arg => undef,
        default  => sub { \undef },
        _definition_context(),
    ))
);

# NOTE:
# By following the same conventions as version here,
# we are opening up the possibility that people can
# use the $AUTHORITY in non-Class::MOP modules as
# well.

Class::MOP::Module->meta->add_attribute(
    Class::MOP::Attribute->new('authority' => (
        reader => {
            # NOTE:
            # we just alias the original method
            # rather than re-produce it here
            'authority' => \&Class::MOP::Module::authority
        },
        init_arg => undef,
        default  => sub { \undef },
        _definition_context(),
    ))
);

## --------------------------------------------------------
## Class::MOP::Class

Class::MOP::Class->meta->add_attribute(
    Class::MOP::Attribute->new('superclasses' => (
        accessor => {
            # NOTE:
            # we just alias the original method
            # rather than re-produce it here
            'superclasses' => \&Class::MOP::Class::superclasses
        },
        init_arg => undef,
        default  => sub { \undef },
        _definition_context(),
    ))
);

Class::MOP::Class->meta->add_attribute(
    Class::MOP::Attribute->new('instance_metaclass' => (
        reader   => {
            # NOTE: we need to do this in order
            # for the instance meta-object to
            # not fall into meta-circular death
            #
            # we just alias the original method
            # rather than re-produce it here
            'instance_metaclass' => \&Class::MOP::Class::instance_metaclass
        },
        default  => 'Class::MOP::Instance',
        _definition_context(),
    ))
);

Class::MOP::Class->meta->add_attribute(
    Class::MOP::Attribute->new('immutable_trait' => (
        reader   => {
            'immutable_trait' => \&Class::MOP::Class::immutable_trait
        },
        default => "Class::MOP::Class::Immutable::Trait",
        _definition_context(),
    ))
);

Class::MOP::Class->meta->add_attribute(
    Class::MOP::Attribute->new('constructor_name' => (
        reader   => {
            'constructor_name' => \&Class::MOP::Class::constructor_name,
        },
        default => "new",
        _definition_context(),
    ))
);

Class::MOP::Class->meta->add_attribute(
    Class::MOP::Attribute->new('constructor_class' => (
        reader   => {
            'constructor_class' => \&Class::MOP::Class::constructor_class,
        },
        default => "Class::MOP::Method::Constructor",
        _definition_context(),
    ))
);


Class::MOP::Class->meta->add_attribute(
    Class::MOP::Attribute->new('destructor_class' => (
        reader   => {
            'destructor_class' => \&Class::MOP::Class::destructor_class,
        },
        _definition_context(),
    ))
);

# NOTE:
# we don't actually need to tie the knot with
# Class::MOP::Class here, it is actually handled
# within Class::MOP::Class itself in the
# _construct_class_instance method.

## --------------------------------------------------------
## Class::MOP::Mixin::AttributeCore
Class::MOP::Mixin::AttributeCore->meta->add_attribute(
    Class::MOP::Attribute->new('name' => (
        reader   => {
            # NOTE: we need to do this in order
            # for the instance meta-object to
            # not fall into meta-circular death
            #
            # we just alias the original method
            # rather than re-produce it here
            'name' => \&Class::MOP::Mixin::AttributeCore::name
        },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore->meta->add_attribute(
    Class::MOP::Attribute->new('accessor' => (
        reader    => { 'accessor'     => \&Class::MOP::Mixin::AttributeCore::accessor     },
        predicate => { 'has_accessor' => \&Class::MOP::Mixin::AttributeCore::has_accessor },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore->meta->add_attribute(
    Class::MOP::Attribute->new('reader' => (
        reader    => { 'reader'     => \&Class::MOP::Mixin::AttributeCore::reader     },
        predicate => { 'has_reader' => \&Class::MOP::Mixin::AttributeCore::has_reader },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore->meta->add_attribute(
    Class::MOP::Attribute->new('initializer' => (
        reader    => { 'initializer'     => \&Class::MOP::Mixin::AttributeCore::initializer     },
        predicate => { 'has_initializer' => \&Class::MOP::Mixin::AttributeCore::has_initializer },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore->meta->add_attribute(
    Class::MOP::Attribute->new('definition_context' => (
        reader    => { 'definition_context'     => \&Class::MOP::Mixin::AttributeCore::definition_context     },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore->meta->add_attribute(
    Class::MOP::Attribute->new('writer' => (
        reader    => { 'writer'     => \&Class::MOP::Mixin::AttributeCore::writer     },
        predicate => { 'has_writer' => \&Class::MOP::Mixin::AttributeCore::has_writer },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore->meta->add_attribute(
    Class::MOP::Attribute->new('predicate' => (
        reader    => { 'predicate'     => \&Class::MOP::Mixin::AttributeCore::predicate     },
        predicate => { 'has_predicate' => \&Class::MOP::Mixin::AttributeCore::has_predicate },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore->meta->add_attribute(
    Class::MOP::Attribute->new('clearer' => (
        reader    => { 'clearer'     => \&Class::MOP::Mixin::AttributeCore::clearer     },
        predicate => { 'has_clearer' => \&Class::MOP::Mixin::AttributeCore::has_clearer },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore->meta->add_attribute(
    Class::MOP::Attribute->new('builder' => (
        reader    => { 'builder'     => \&Class::MOP::Mixin::AttributeCore::builder     },
        predicate => { 'has_builder' => \&Class::MOP::Mixin::AttributeCore::has_builder },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore->meta->add_attribute(
    Class::MOP::Attribute->new('init_arg' => (
        reader    => { 'init_arg'     => \&Class::MOP::Mixin::AttributeCore::init_arg     },
        predicate => { 'has_init_arg' => \&Class::MOP::Mixin::AttributeCore::has_init_arg },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore->meta->add_attribute(
    Class::MOP::Attribute->new('default' => (
        # default has a custom 'reader' method ...
        predicate => { 'has_default' => \&Class::MOP::Mixin::AttributeCore::has_default },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore->meta->add_attribute(
    Class::MOP::Attribute->new('insertion_order' => (
        reader      => { 'insertion_order' => \&Class::MOP::Mixin::AttributeCore::insertion_order },
        writer      => { '_set_insertion_order' => \&Class::MOP::Mixin::AttributeCore::_set_insertion_order },
        predicate   => { 'has_insertion_order' => \&Class::MOP::Mixin::AttributeCore::has_insertion_order },
        _definition_context(),
    ))
);

## --------------------------------------------------------
## Class::MOP::Attribute
Class::MOP::Attribute->meta->add_attribute(
    Class::MOP::Attribute->new('associated_class' => (
        reader   => {
            # NOTE: we need to do this in order
            # for the instance meta-object to
            # not fall into meta-circular death
            #
            # we just alias the original method
            # rather than re-produce it here
            'associated_class' => \&Class::MOP::Attribute::associated_class
        },
        _definition_context(),
    ))
);

Class::MOP::Attribute->meta->add_attribute(
    Class::MOP::Attribute->new('associated_methods' => (
        reader   => { 'associated_methods' => \&Class::MOP::Attribute::associated_methods },
        default  => sub { [] },
        _definition_context(),
    ))
);

Class::MOP::Attribute->meta->add_method('clone' => sub {
    my $self  = shift;
    $self->meta->clone_object($self, @_);
});

## --------------------------------------------------------
## Class::MOP::Method
Class::MOP::Method->meta->add_attribute(
    Class::MOP::Attribute->new('body' => (
        reader   => { 'body' => \&Class::MOP::Method::body },
        _definition_context(),
    ))
);

Class::MOP::Method->meta->add_attribute(
    Class::MOP::Attribute->new('associated_metaclass' => (
        reader   => { 'associated_metaclass' => \&Class::MOP::Method::associated_metaclass },
        _definition_context(),
    ))
);

Class::MOP::Method->meta->add_attribute(
    Class::MOP::Attribute->new('package_name' => (
        reader   => { 'package_name' => \&Class::MOP::Method::package_name },
        _definition_context(),
    ))
);

Class::MOP::Method->meta->add_attribute(
    Class::MOP::Attribute->new('name' => (
        reader   => { 'name' => \&Class::MOP::Method::name },
        _definition_context(),
    ))
);

Class::MOP::Method->meta->add_attribute(
    Class::MOP::Attribute->new('original_method' => (
        reader   => { 'original_method'      => \&Class::MOP::Method::original_method },
        writer   => { '_set_original_method' => \&Class::MOP::Method::_set_original_method },
        _definition_context(),
    ))
);

## --------------------------------------------------------
## Class::MOP::Method::Wrapped

# NOTE:
# the way this item is initialized, this
# really does not follow the standard
# practices of attributes, but we put
# it here for completeness
Class::MOP::Method::Wrapped->meta->add_attribute(
    Class::MOP::Attribute->new('modifier_table' => (
        _definition_context(),
    ))
);

## --------------------------------------------------------
## Class::MOP::Method::Generated

Class::MOP::Method::Generated->meta->add_attribute(
    Class::MOP::Attribute->new('is_inline' => (
        reader   => { 'is_inline' => \&Class::MOP::Method::Generated::is_inline },
        default  => 0,
        _definition_context(),
    ))
);

Class::MOP::Method::Generated->meta->add_attribute(
    Class::MOP::Attribute->new('definition_context' => (
        reader   => { 'definition_context' => \&Class::MOP::Method::Generated::definition_context },
        _definition_context(),
    ))
);


## --------------------------------------------------------
## Class::MOP::Method::Inlined

Class::MOP::Method::Inlined->meta->add_attribute(
    Class::MOP::Attribute->new('_expected_method_class' => (
        reader   => { '_expected_method_class' => \&Class::MOP::Method::Inlined::_expected_method_class },
        _definition_context(),
    ))
);

## --------------------------------------------------------
## Class::MOP::Method::Accessor

Class::MOP::Method::Accessor->meta->add_attribute(
    Class::MOP::Attribute->new('attribute' => (
        reader   => {
            'associated_attribute' => \&Class::MOP::Method::Accessor::associated_attribute
        },
        _definition_context(),
    ))
);

Class::MOP::Method::Accessor->meta->add_attribute(
    Class::MOP::Attribute->new('accessor_type' => (
        reader   => { 'accessor_type' => \&Class::MOP::Method::Accessor::accessor_type },
        _definition_context(),
    ))
);

## --------------------------------------------------------
## Class::MOP::Method::Constructor

Class::MOP::Method::Constructor->meta->add_attribute(
    Class::MOP::Attribute->new('options' => (
        reader   => {
            'options' => \&Class::MOP::Method::Constructor::options
        },
        default  => sub { +{} },
        _definition_context(),
    ))
);

Class::MOP::Method::Constructor->meta->add_attribute(
    Class::MOP::Attribute->new('associated_metaclass' => (
        init_arg => "metaclass", # FIXME alias and rename
        reader   => {
            'associated_metaclass' => \&Class::MOP::Method::Constructor::associated_metaclass
        },
        _definition_context(),
    ))
);

## --------------------------------------------------------
## Class::MOP::Overload

Class::MOP::Overload->meta->add_attribute(
    Class::MOP::Attribute->new(
        'operator' => (
            reader   => { 'operator' => \&Class::MOP::Overload::operator },
            required => 1,
            _definition_context(),
        )
    )
);

for my $attr (qw( method_name coderef coderef_package coderef_name method )) {
    Class::MOP::Overload->meta->add_attribute(
        Class::MOP::Attribute->new(
            $attr => (
                reader    => { $attr => Class::MOP::Overload->can($attr) },
                predicate => {
                    'has_'
                        . $attr => Class::MOP::Overload->can( 'has_' . $attr )
                },
                _definition_context(),
            )
        )
    );
}

Class::MOP::Overload->meta->add_attribute(
    Class::MOP::Attribute->new(
        'associated_metaclass' => (
            reader => {
                'associated_metaclass' =>
                    \&Class::MOP::Overload::associated_metaclass
            },
            _definition_context(),
        )
    )
);

## --------------------------------------------------------
## Class::MOP::Instance

# NOTE:
# these don't yet do much of anything, but are just
# included for completeness

Class::MOP::Instance->meta->add_attribute(
    Class::MOP::Attribute->new('associated_metaclass',
        reader   => { associated_metaclass => \&Class::MOP::Instance::associated_metaclass },
        _definition_context(),
    ),
);

Class::MOP::Instance->meta->add_attribute(
    Class::MOP::Attribute->new('_class_name',
        init_arg => undef,
        reader   => { _class_name => \&Class::MOP::Instance::_class_name },
        #lazy     => 1, # not yet supported by Class::MOP but out our version does it anyway
        #default  => sub { $_[0]->associated_metaclass->name },
        _definition_context(),
    ),
);

Class::MOP::Instance->meta->add_attribute(
    Class::MOP::Attribute->new('attributes',
        reader   => { attributes => \&Class::MOP::Instance::get_all_attributes },
        _definition_context(),
    ),
);

Class::MOP::Instance->meta->add_attribute(
    Class::MOP::Attribute->new('slots',
        reader   => { slots => \&Class::MOP::Instance::slots },
        _definition_context(),
    ),
);

Class::MOP::Instance->meta->add_attribute(
    Class::MOP::Attribute->new('slot_hash',
        reader   => { slot_hash => \&Class::MOP::Instance::slot_hash },
        _definition_context(),
    ),
);

## --------------------------------------------------------
## Class::MOP::Object

# need to replace the meta method there with a real meta method object
Class::MOP::Object->meta->_add_meta_method('meta');

## --------------------------------------------------------
## Class::MOP::Mixin

# need to replace the meta method there with a real meta method object
Class::MOP::Mixin->meta->_add_meta_method('meta');

require Class::MOP::Deprecated unless our $no_deprecated;

# we need the meta instance of the meta instance to be created now, in order
# for the constructor to be able to use it
Class::MOP::Instance->meta->get_meta_instance;

# pretend the add_method never happened. it hasn't yet affected anything
undef Class::MOP::Instance->meta->{_package_cache_flag};

## --------------------------------------------------------
## Now close all the Class::MOP::* classes

# NOTE: we don't need to inline the accessors this only lengthens the compile
# time of the MOP, and gives us no actual benefits.

$_->meta->make_immutable(
    inline_constructor  => 0,
    constructor_name    => "_new",
    inline_accessors => 0,
) for qw/
    Class::MOP::Package
    Class::MOP::Module
    Class::MOP::Class

    Class::MOP::Attribute
    Class::MOP::Method
    Class::MOP::Instance

    Class::MOP::Object

    Class::MOP::Method::Generated
    Class::MOP::Method::Inlined

    Class::MOP::Method::Accessor
    Class::MOP::Method::Constructor
    Class::MOP::Method::Wrapped

    Class::MOP::Method::Meta

    Class::MOP::Overload
/;

$_->meta->make_immutable(
    inline_constructor  => 0,
    constructor_name    => undef,
    inline_accessors => 0,
) for qw/
    Class::MOP::Mixin
    Class::MOP::Mixin::AttributeCore
    Class::MOP::Mixin::HasAttributes
    Class::MOP::Mixin::HasMethods
    Class::MOP::Mixin::HasOverloads
/;

1;

# ABSTRACT: A Meta Object Protocol for Perl 5

use strict;
use warnings;
package Moose;
our $VERSION = '2.2204';
our $AUTHORITY = 'cpan:STEVAN';

use 5.008003;

use Scalar::Util ();
use Carp         'carp';
use Module::Runtime 'module_notional_filename';
use Class::Load  'is_class_loaded';

use Moose::Deprecated;
use Moose::Exporter;

use Class::MOP;

die "Class::MOP version $Moose::VERSION required--this is version $Class::MOP::VERSION"
    if $Class::MOP::VERSION ne $Moose::VERSION;

use Moose::Meta::Class;
use Moose::Meta::TypeConstraint;
use Moose::Meta::TypeCoercion;
use Moose::Meta::Attribute;
use Moose::Meta::Instance;

use Moose::Object;

use Moose::Meta::Role;
use Moose::Meta::Role::Composite;
use Moose::Meta::Role::Application;
use Moose::Meta::Role::Application::RoleSummation;
use Moose::Meta::Role::Application::ToClass;
use Moose::Meta::Role::Application::ToRole;
use Moose::Meta::Role::Application::ToInstance;

use Moose::Util::TypeConstraints;
use Moose::Util 'throw_exception';

use Moose::Meta::Attribute::Native;

sub extends {
    my $meta = shift;

    unless ( @_ )
    {
        throw_exception( ExtendsMissingArgs => class_name => $meta->name );
    }
    # this checks the metaclass to make sure
    # it is correct, sometimes it can get out
    # of sync when the classes are being built
    $meta->superclasses(@_);
}

sub with {
    Moose::Util::apply_all_roles(shift, @_);
}

sub throw_error {
    shift;
    Class::MOP::Object->throw_error(@_);
}

sub has {
    my $meta = shift;
    my $name = shift;

    my %context = Moose::Util::_caller_info;
    $context{context} = 'has declaration';
    $context{type} = 'class';
    my @options = ( definition_context => \%context, @_ );
    my $attrs = ( ref($name) eq 'ARRAY' ) ? $name : [ ($name) ];
    $meta->add_attribute( $_, @options ) for @$attrs;
}

sub before {
    Moose::Util::add_method_modifier(shift, 'before', \@_);
}

sub after {
    Moose::Util::add_method_modifier(shift, 'after', \@_);
}

sub around {
    Moose::Util::add_method_modifier(shift, 'around', \@_);
}

our $SUPER_PACKAGE;
our $SUPER_BODY;
our @SUPER_ARGS;

sub super {
    if (@_) {
        carp 'Arguments passed to super() are ignored';
    }

    # This check avoids a recursion loop - see
    # t/bugs/super_recursion.t
    return if defined $SUPER_PACKAGE && $SUPER_PACKAGE ne caller();
    return unless $SUPER_BODY; $SUPER_BODY->(@SUPER_ARGS);
}

sub override {
    my $meta = shift;
    my ( $name, $method ) = @_;
    $meta->add_override_method_modifier( $name => $method );
}

sub inner {
    my $pkg = caller();
    our ( %INNER_BODY, %INNER_ARGS );

    if ( my $body = $INNER_BODY{$pkg} ) {
        my @args = @{ $INNER_ARGS{$pkg} };
        local $INNER_ARGS{$pkg};
        local $INNER_BODY{$pkg};
        return $body->(@args);
    } else {
        return;
    }
}

sub augment {
    my $meta = shift;
    my ( $name, $method ) = @_;
    $meta->add_augment_method_modifier( $name => $method );
}

Moose::Exporter->setup_import_methods(
    with_meta => [
        qw( extends with has before after around override augment )
    ],
    as_is => [
        qw( super inner ),
        'Carp::confess',
        'Scalar::Util::blessed',
    ],
);

sub init_meta {
    shift;
    my %args = @_;

    my $class = $args{for_class}
        or throw_exception( InitMetaRequiresClass => params => \%args );

    my $base_class = $args{base_class} || 'Moose::Object';
    my $metaclass  = $args{metaclass}  || 'Moose::Meta::Class';
    my $meta_name  = exists $args{meta_name} ? $args{meta_name} : 'meta';

    throw_exception( MetaclassNotLoaded => class_name => $metaclass )
        unless is_class_loaded($metaclass);

    throw_exception( MetaclassMustBeASubclassOfMooseMetaClass => class_name => $metaclass )
        unless $metaclass->isa('Moose::Meta::Class');

    # make a subtype for each Moose class
    class_type($class)
        unless find_type_constraint($class);

    my $meta;

    if ( $meta = Class::MOP::get_metaclass_by_name($class) ) {
        unless ( $meta->isa("Moose::Meta::Class") ) {
            if ( $meta->isa('Moose::Meta::Role') ) {
                throw_exception( MetaclassIsARoleNotASubclassOfGivenMetaclass => role_name => $class,
                                                                                 metaclass => $metaclass,
                                                                                 role      => $meta
                               );
            } else {
                throw_exception( MetaclassIsNotASubclassOfGivenMetaclass => class_name => $class,
                                                                            metaclass  => $metaclass,
                                                                            class      => $meta
                               );
            }
        }
    } else {
        # no metaclass

        # now we check whether our ancestors have metaclass, and if so borrow that
        my ( undef, @isa ) = @{ mro::get_linear_isa($class) };

        foreach my $ancestor ( @isa ) {
            my $ancestor_meta = Class::MOP::get_metaclass_by_name($ancestor) || next;

            my $ancestor_meta_class = $ancestor_meta->_real_ref_name;

            # if we have an ancestor metaclass that inherits $metaclass, we use
            # that. This is like _fix_metaclass_incompatibility, but we can do it now.

            # the case of having an ancestry is not very common, but arises in
            # e.g. Reaction
            unless ( $metaclass->isa( $ancestor_meta_class ) ) {
                if ( $ancestor_meta_class->isa($metaclass) ) {
                    $metaclass = $ancestor_meta_class;
                }
            }
        }

        $meta = $metaclass->initialize($class);
        my $filename = module_notional_filename($meta->name);
        $INC{$filename} = '(set by Moose)'
            unless exists $INC{$filename};
    }

    if (defined $meta_name) {
        # also check for inherited non moose 'meta' method?
        my $existing = $meta->get_method($meta_name);
        if ($existing && !$existing->isa('Class::MOP::Method::Meta')) {
            Carp::cluck "Moose is overwriting an existing method named "
                      . "$meta_name in class $class with a method "
                      . "which returns the class's metaclass. If this is "
                      . "actually what you want, you should remove the "
                      . "existing method, otherwise, you should rename or "
                      . "disable this generated method using the "
                      . "'-meta_name' option to 'use Moose'.";
        }
        $meta->_add_meta_method($meta_name);
    }

    # make sure they inherit from Moose::Object
    $meta->superclasses($base_class)
      unless $meta->superclasses();

    return $meta;
}

# This may be used in some older MooseX extensions.
sub _get_caller {
    goto &Moose::Exporter::_get_caller;
}

## make 'em all immutable

$_->make_immutable(
    inline_constructor => 1,
    constructor_name   => "_new",
    # these are Class::MOP accessors, so they need inlining
    inline_accessors => 1
    ) for grep { $_->is_mutable }
    map { $_->meta }
    qw(
    Moose::Meta::Attribute
    Moose::Meta::Class
    Moose::Meta::Instance

    Moose::Meta::TypeCoercion
    Moose::Meta::TypeCoercion::Union

    Moose::Meta::Method
    Moose::Meta::Method::Constructor
    Moose::Meta::Method::Destructor
    Moose::Meta::Method::Overridden
    Moose::Meta::Method::Augmented

    Moose::Meta::Role
    Moose::Meta::Role::Attribute
    Moose::Meta::Role::Method
    Moose::Meta::Role::Method::Required
    Moose::Meta::Role::Method::Conflicting

    Moose::Meta::Role::Composite

    Moose::Meta::Role::Application
    Moose::Meta::Role::Application::RoleSummation
    Moose::Meta::Role::Application::ToClass
    Moose::Meta::Role::Application::ToRole
    Moose::Meta::Role::Application::ToInstance
);

$_->make_immutable(
    inline_constructor => 0,
    constructor_name   => undef,
    # these are Class::MOP accessors, so they need inlining
    inline_accessors => 1
    ) for grep { $_->is_mutable }
    map { $_->meta }
    qw(
    Moose::Meta::Method::Accessor
    Moose::Meta::Method::Delegation
    Moose::Meta::Mixin::AttributeCore
);

1;

# ABSTRACT: A postmodern object system for Perl 5

use strict;
use warnings;
package Moose::Role;
our $VERSION = '2.2204';

use Scalar::Util ();
use Carp ();
use Class::Load  'is_class_loaded';
use Module::Runtime 'module_notional_filename';

use Sub::Exporter;

use Moose       ();
use Moose::Util 'throw_exception';

use Moose::Exporter;
use Moose::Meta::Role;
use Moose::Util::TypeConstraints;

sub extends {
    throw_exception("RolesDoNotSupportExtends");
}

sub with {
    Moose::Util::apply_all_roles( shift, @_ );
}

sub requires {
    my $meta = shift;
    throw_exception( MustSpecifyAtleastOneMethod => role_name => $meta->name ) unless @_;
    $meta->add_required_methods(@_);
}

sub excludes {
    my $meta = shift;
    throw_exception( MustSpecifyAtleastOneRole => role_name => $meta->name ) unless @_;
    $meta->add_excluded_roles(@_);
}

sub has {
    my $meta = shift;
    my $name = shift;
    throw_exception( InvalidHasProvidedInARole => role_name       => $meta->name,
                                                  attribute_name  => $name,
                   )
        if @_ == 1;
    my %context = Moose::Util::_caller_info;
    $context{context} = 'has declaration';
    $context{type} = 'role';
    my %options = ( definition_context => \%context, @_ );
    my $attrs = ( ref($name) eq 'ARRAY' ) ? $name : [ ($name) ];
    $meta->add_attribute( $_, %options ) for @$attrs;
}

sub _add_method_modifier {
    my $type = shift;
    my $meta = shift;

    if ( ref($_[0]) eq 'Regexp' ) {
        throw_exception( RolesDoNotSupportRegexReferencesForMethodModifiers => modifier_type => $type,
                                                                               role_name     => $meta->name,
                       );
    }

    Moose::Util::add_method_modifier($meta, $type, \@_);
}

sub before { _add_method_modifier('before', @_) }

sub after  { _add_method_modifier('after',  @_) }

sub around { _add_method_modifier('around', @_) }

# see Moose.pm for discussion
sub super {
    return unless $Moose::SUPER_BODY;
    $Moose::SUPER_BODY->(@Moose::SUPER_ARGS);
}

sub override {
    my $meta = shift;
    my ( $name, $code ) = @_;
    $meta->add_override_method_modifier( $name, $code );
}

sub inner {
    throw_exception("RolesDoNotSupportInner");
}

sub augment {
    throw_exception("RolesDoNotSupportAugment");
}

Moose::Exporter->setup_import_methods(
    with_meta => [
        qw( with requires excludes has before after around override )
    ],
    as_is => [
        qw( extends super inner augment ),
        'Carp::confess',
        'Scalar::Util::blessed',
    ],
);

sub init_meta {
    shift;
    my %args = @_;

    my $role = $args{for_class};

    unless ($role) {
        require Moose;
        throw_exception( InitMetaRequiresClass => params => \%args );
    }

    my $metaclass = $args{metaclass} || "Moose::Meta::Role";
    my $meta_name = exists $args{meta_name} ? $args{meta_name} : 'meta';

    throw_exception( MetaclassNotLoaded => class_name => $metaclass )
        unless is_class_loaded($metaclass);

    throw_exception( MetaclassMustBeASubclassOfMooseMetaRole => role_name => $metaclass )
        unless $metaclass->isa('Moose::Meta::Role');

    # make a subtype for each Moose role
    role_type $role unless find_type_constraint($role);

    my $meta;
    if ( $meta = Class::MOP::get_metaclass_by_name($role) ) {
        unless ( $meta->isa("Moose::Meta::Role") ) {
            if ( $meta->isa('Moose::Meta::Class') ) {
                throw_exception( MetaclassIsAClassNotASubclassOfGivenMetaclass => class_name => $role,
                                                                                  metaclass  => $metaclass,
                               );
            } else {
                throw_exception( MetaclassIsNotASubclassOfGivenMetaclass => class_name => $role,
                                                                            metaclass  => $metaclass,
                               );
            }
        }
    }
    else {
        $meta = $metaclass->initialize($role);
        my $filename = module_notional_filename($meta->name);
        $INC{$filename} = '(set by Moose)'
            unless exists $INC{$filename};
    }

    if (defined $meta_name) {
        # also check for inherited non moose 'meta' method?
        my $existing = $meta->get_method($meta_name);
        if ($existing && !$existing->isa('Class::MOP::Method::Meta')) {
            Carp::cluck "Moose::Role is overwriting an existing method named "
                      . "$meta_name in role $role with a method "
                      . "which returns the class's metaclass. If this is "
                      . "actually what you want, you should remove the "
                      . "existing method, otherwise, you should rename or "
                      . "disable this generated method using the "
                      . "'-meta_name' option to 'use Moose::Role'.";
        }
        $meta->_add_meta_method($meta_name);
    }

    return $meta;
}

1;

# ABSTRACT: The Moose Role

package Moose::Exporter;
our $VERSION = '2.2204';

use strict;
use warnings;

use Class::Load qw(is_class_loaded);
use Class::MOP;
use List::Util 1.45 qw( uniq );
use Moose::Util::MetaRole;
use Scalar::Util 1.40 qw(reftype);
use Sub::Exporter 0.980;
use Sub::Util 1.40 qw(set_subname);

use Moose::Util 'throw_exception';

my %EXPORT_SPEC;

sub setup_import_methods {
    my ( $class, %args ) = @_;

    $args{exporting_package} ||= caller();

    $class->build_import_methods(
        %args,
        install => [qw(import unimport init_meta)]
    );
}

# A reminder to intrepid Moose hackers
# there may be more than one level of exporter
# don't make doy cry. -- perigrin

sub build_import_methods {
    my ( $class, %args ) = @_;

    my $exporting_package = $args{exporting_package} ||= caller();

    my $meta_lookup = $args{meta_lookup} || sub { Class::MOP::class_of(shift) };

    $EXPORT_SPEC{$exporting_package} = \%args;

    my @exports_from = $class->_follow_also($exporting_package);

    my $export_recorder = {};
    my $is_reexport     = {};

    my $exports = $class->_make_sub_exporter_params(
        [ $exporting_package, @exports_from ],
        $export_recorder,
        $is_reexport,
        $args{meta_lookup}, # so that we don't pass through the default
    );

    my $exporter = $class->_make_exporter(
        $exports,
        $is_reexport,
        $meta_lookup,
    );

    my %methods;
    $methods{import} = $class->_make_import_sub(
        $exporting_package,
        $exporter,
        \@exports_from,
        $is_reexport,
        $meta_lookup,
    );

    $methods{unimport} = $class->_make_unimport_sub(
        $exporting_package,
        $exports,
        $export_recorder,
        $is_reexport,
        $meta_lookup,
    );

    $methods{init_meta} = $class->_make_init_meta(
        $exporting_package,
        \%args,
        $meta_lookup,
    );

    my $package = Class::MOP::Package->initialize($exporting_package);
    for my $to_install ( @{ $args{install} || [] } ) {
        my $symbol = '&' . $to_install;

        next
            unless $methods{$to_install}
                && !$package->has_package_symbol($symbol);
        $package->add_package_symbol(
            $symbol,
            set_subname( $exporting_package . '::'
                    . $to_install => $methods{$to_install} )
        );
    }

    return ( $methods{import}, $methods{unimport}, $methods{init_meta} );
}

sub _make_exporter {
    my ($class, $exports, $is_reexport, $meta_lookup) = @_;

    return Sub::Exporter::build_exporter(
        {
            exports   => $exports,
            groups    => { default => [':all'] },
            installer => sub {
                my ($arg, $to_export) = @_;
                my $meta = $meta_lookup->($arg->{into});

                goto &Sub::Exporter::default_installer unless $meta;

                # don't overwrite existing symbols with our magically flagged
                # version of it if we would install the same sub that's already
                # in the importer

                my @filtered_to_export;
                my %installed;
                for (my $i = 0; $i < @{ $to_export }; $i += 2) {
                    my ($as, $cv) = @{ $to_export }[$i, $i + 1];

                    next if !ref($as)
                         && $meta->has_package_symbol('&' . $as)
                         && $meta->get_package_symbol('&' . $as) == $cv;

                    push @filtered_to_export, $as, $cv;
                    $installed{$as} = 1 unless ref $as;
                }

                Sub::Exporter::default_installer($arg, \@filtered_to_export);

                for my $name ( keys %{$is_reexport} ) {
                    no strict 'refs';
                    no warnings 'once';
                    next unless exists $installed{$name};
                    _flag_as_reexport( \*{ join q{::}, $arg->{into}, $name } );
                }
            },
        }
    );
}

sub _follow_also {
    my $class             = shift;
    my $exporting_package = shift;

    _die_if_cycle_found_in_also_list_for_package($exporting_package);

    return uniq( _follow_also_real($exporting_package) );
}

sub _follow_also_real {
    my $exporting_package = shift;
    my @also              = _also_list_for_package($exporting_package);

    return map { $_, _follow_also_real($_) } @also;
}

sub _also_list_for_package {
    my $package = shift;

    if ( !exists $EXPORT_SPEC{$package} ) {
        my $loaded = is_class_loaded($package);

        throw_exception( PackageDoesNotUseMooseExporter => package   => $package,
                                                           is_loaded => $loaded
                       );
    }

    my $also = $EXPORT_SPEC{$package}{also};

    return unless defined $also;

    return ref $also ? @$also : $also;
}

# this is no Tarjan algorithm, but for the list sizes expected,
# brute force will probably be fine (and more maintainable)
sub _die_if_cycle_found_in_also_list_for_package {
    my $package = shift;
    _die_if_also_list_cycles_back_to_existing_stack(
        [ _also_list_for_package($package) ],
        [$package],
    );
}

sub _die_if_also_list_cycles_back_to_existing_stack {
    my ( $also_list, $existing_stack ) = @_;

    return unless @$also_list && @$existing_stack;

    for my $also_member (@$also_list) {
        for my $stack_member (@$existing_stack) {
            next unless $also_member eq $stack_member;

            throw_exception( CircularReferenceInAlso => also_parameter => $also_member,
                                                        stack          => $existing_stack
                           );
        }

        _die_if_also_list_cycles_back_to_existing_stack(
            [ _also_list_for_package($also_member) ],
            [ $also_member, @$existing_stack ],
        );
    }
}

sub _parse_trait_aliases {
    my $class   = shift;
    my ($package, $aliases) = @_;

    my @ret;
    for my $alias (@$aliases) {
        my $name;
        if (ref($alias)) {
            reftype($alias) eq 'ARRAY'
                or throw_exception( InvalidArgumentsToTraitAliases => class_name   => $class,
                                                                      package_name => $package,
                                                                      alias        => $alias
                                  );
            ($alias, $name) = @$alias;
        }
        else {
            ($name = $alias) =~ s/.*:://;
        }
        push @ret, set_subname( "${package}::${name}" => sub () {$alias} );
    }

    return @ret;
}

sub _make_sub_exporter_params {
    my $class                = shift;
    my $packages             = shift;
    my $export_recorder      = shift;
    my $is_reexport          = shift;
    my $meta_lookup_override = shift;

    my %exports;
    my $current_meta_lookup;

    for my $package ( @{$packages} ) {
        my $args = $EXPORT_SPEC{$package}
            or die "The $package package does not use Moose::Exporter\n";

        $current_meta_lookup = $meta_lookup_override || $args->{meta_lookup};
        $meta_lookup_override = $current_meta_lookup;

        my $meta_lookup = $current_meta_lookup
                       || sub { Class::MOP::class_of(shift) };

        for my $name ( @{ $args->{with_meta} } ) {
            my $sub = $class->_sub_from_package( $package, $name )
                or next;

            my $fq_name = $package . '::' . $name;

            $exports{$name} = $class->_make_wrapped_sub_with_meta(
                $fq_name,
                $sub,
                $export_recorder,
                $meta_lookup,
            ) unless exists $exports{$name};
        }

        for my $name ( @{ $args->{with_caller} } ) {
            my $sub = $class->_sub_from_package( $package, $name )
                or next;

            my $fq_name = $package . '::' . $name;

            $exports{$name} = $class->_make_wrapped_sub(
                $fq_name,
                $sub,
                $export_recorder,
            ) unless exists $exports{$name};
        }

        my @extra_exports = $class->_parse_trait_aliases(
            $package, $args->{trait_aliases},
        );
        for my $name ( @{ $args->{as_is} }, @extra_exports ) {
            my ( $sub, $coderef_name );

            if ( ref $name ) {
                $sub = $name;

                my $coderef_pkg;
                ( $coderef_pkg, $coderef_name )
                    = Class::MOP::get_code_info($name);

                if ( $coderef_pkg ne $package ) {
                    $is_reexport->{$coderef_name} = 1;
                }
            }
            elsif ( $name =~ /^(.*)::([^:]+)$/ ) {
                $sub = $class->_sub_from_package( "$1", "$2" )
                    or next;

                $coderef_name = "$2";

                if ( $1 ne $package ) {
                    $is_reexport->{$coderef_name} = 1;
                }
            }
            else {
                $sub = $class->_sub_from_package( $package, $name )
                    or next;

                $coderef_name = $name;
            }

            $export_recorder->{$sub} = 1;

            $exports{$coderef_name} = sub { $sub }
                unless exists $exports{$coderef_name};
        }
    }

    return \%exports;
}

sub _sub_from_package {
    my $sclass  = shift;
    my $package = shift;
    my $name    = shift;

    my $sub = do {
        no strict 'refs';
        \&{ $package . '::' . $name };
    };

    return $sub if defined &$sub;

    Carp::cluck "Trying to export undefined sub ${package}::${name}";

    return;
}

our $CALLER;

sub _make_wrapped_sub {
    my $self            = shift;
    my $fq_name         = shift;
    my $sub             = shift;
    my $export_recorder = shift;

    # We need to set the package at import time, so that when
    # package Foo imports has(), we capture "Foo" as the
    # package. This lets other packages call Foo::has() and get
    # the right package. This is done for backwards compatibility
    # with existing production code, not because this is a good
    # idea ;)
    return sub {
        my $caller = $CALLER;

        my $wrapper = $self->_curry_wrapper( $sub, $fq_name, $caller );

        my $sub = set_subname( $fq_name => $wrapper );

        $export_recorder->{$sub} = 1;

        return $sub;
    };
}

sub _make_wrapped_sub_with_meta {
    my $self            = shift;
    my $fq_name         = shift;
    my $sub             = shift;
    my $export_recorder = shift;
    my $meta_lookup     = shift;

    return sub {
        my $caller = $CALLER;

        my $wrapper = $self->_late_curry_wrapper(
            $sub, $fq_name,
            $meta_lookup => $caller
        );

        my $sub = set_subname( $fq_name => $wrapper );

        $export_recorder->{$sub} = 1;

        return $sub;
    };
}

sub _curry_wrapper {
    my $class   = shift;
    my $sub     = shift;
    my $fq_name = shift;
    my @extra   = @_;

    my $wrapper = sub { $sub->( @extra, @_ ) };
    if ( my $proto = prototype $sub ) {

        # XXX - Perl's prototype sucks. Use & to make set_prototype
        # ignore the fact that we're passing "private variables"
        &Scalar::Util::set_prototype( $wrapper, $proto );
    }
    return $wrapper;
}

sub _late_curry_wrapper {
    my $class   = shift;
    my $sub     = shift;
    my $fq_name = shift;
    my $extra   = shift;
    my @ex_args = @_;

    my $wrapper = sub {

        # resolve curried arguments at runtime via this closure
        my @curry = ( $extra->(@ex_args) );
        return $sub->( @curry, @_ );
    };

    if ( my $proto = prototype $sub ) {

        # XXX - Perl's prototype sucks. Use & to make set_prototype
        # ignore the fact that we're passing "private variables"
        &Scalar::Util::set_prototype( $wrapper, $proto );
    }
    return $wrapper;
}

sub _make_import_sub {
    shift;
    my $exporting_package = shift;
    my $exporter          = shift;
    my $exports_from      = shift;
    my $is_reexport       = shift;
    my $meta_lookup       = shift;

    return sub {

        # I think we could use Sub::Exporter's collector feature
        # to do this, but that would be rather gross, since that
        # feature isn't really designed to return a value to the
        # caller of the exporter sub.
        #
        # Also, this makes sure we preserve backwards compat for
        # _get_caller, so it always sees the arguments in the
        # expected order.
        my $traits;
        ( $traits, @_ ) = _strip_traits(@_);

        my $metaclass;
        ( $metaclass, @_ ) = _strip_metaclass(@_);
        $metaclass
            = Moose::Util::resolve_metaclass_alias( 'Class' => $metaclass )
            if defined $metaclass && length $metaclass;

        my $meta_name;
        ( $meta_name, @_ ) = _strip_meta_name(@_);

        # Normally we could look at $_[0], but in some weird cases
        # (involving goto &Moose::import), $_[0] ends as something
        # else (like Squirrel).
        my $class = $exporting_package;

        $CALLER = _get_caller(@_);

        # this works because both pragmas set $^H (see perldoc
        # perlvar) which affects the current compilation -
        # i.e. the file who use'd us - which is why we don't need
        # to do anything special to make it affect that file
        # rather than this one (which is already compiled)

        strict->import;
        warnings->import;

        my $did_init_meta;
        for my $c ( grep { $_->can('init_meta') } $class, @{$exports_from} ) {

            # init_meta can apply a role, which when loaded uses
            # Moose::Exporter, which in turn sets $CALLER, so we need
            # to protect against that.
            local $CALLER = $CALLER;
            $c->init_meta(
                for_class => $CALLER,
                metaclass => $metaclass,
                meta_name => $meta_name,
            );
            $did_init_meta = 1;
        }

        {
            # The metaroles will use Moose::Role, which in turn uses
            # Moose::Exporter, which in turn sets $CALLER, so we need
            # to protect against that.
            local $CALLER = $CALLER;
            _apply_metaroles(
                $CALLER,
                [$class, @$exports_from],
                $meta_lookup
            );
        }

        if ( $did_init_meta && @{$traits} ) {

            # The traits will use Moose::Role, which in turn uses
            # Moose::Exporter, which in turn sets $CALLER, so we need
            # to protect against that.
            local $CALLER = $CALLER;
            _apply_meta_traits( $CALLER, $traits, $meta_lookup );
        }
        elsif ( @{$traits} ) {
            throw_exception( ClassDoesNotHaveInitMeta => class_name => $class,
                                                         traits     => $traits
                           );
        }

        my ( undef, @args ) = @_;
        my $extra = shift @args if ref $args[0] eq 'HASH';

        $extra ||= {};
        if ( !$extra->{into} ) {
            $extra->{into_level} ||= 0;
            $extra->{into_level}++;
        }

        $class->$exporter( $extra, @args );
    };
}

sub _strip_option {
    my $option_name = shift;
    my $default = shift;
    for my $i ( 0 .. $#_ - 1 ) {
        if (($_[$i] || '') eq $option_name) {
            (undef, my $value) = splice @_, $i, 2;
            return ( $value, @_ );
        }
    }
    return ( $default, @_ );
}

sub _strip_traits {
    my ($traits, @other) = _strip_option('-traits', [], @_);
    $traits = ref $traits ? $traits : [ $traits ];
    return ( $traits, @other );
}

sub _strip_metaclass {
    _strip_option('-metaclass', undef, @_);
}

sub _strip_meta_name {
    _strip_option('-meta_name', 'meta', @_);
}

sub _apply_metaroles {
    my ($class, $exports_from, $meta_lookup) = @_;

    my $metaroles = _collect_metaroles($exports_from);
    my $base_class_roles = delete $metaroles->{base_class_roles};

    my $meta = $meta_lookup->($class);
    # for instance, Moose.pm uses Moose::Util::TypeConstraints
    return unless $meta;

    Moose::Util::MetaRole::apply_metaroles(
        for => $meta,
        %$metaroles,
    ) if keys %$metaroles;

    Moose::Util::MetaRole::apply_base_class_roles(
        for   => $meta,
        roles => $base_class_roles,
    ) if $meta->isa('Class::MOP::Class')
      && $base_class_roles && @$base_class_roles;
}

sub _collect_metaroles {
    my ($exports_from) = @_;

    my @old_style_role_types = map { "${_}_roles" } qw(
        metaclass
        attribute_metaclass
        method_metaclass
        wrapped_method_metaclass
        instance_metaclass
        constructor_class
        destructor_class
        error_class
    );

    my %class_metaroles;
    my %role_metaroles;
    my @base_class_roles;
    my %old_style_roles;

    for my $exporter (@$exports_from) {
        my $data = $EXPORT_SPEC{$exporter};

        if (exists $data->{class_metaroles}) {
            for my $type (keys %{ $data->{class_metaroles} }) {
                push @{ $class_metaroles{$type} ||= [] },
                     @{ $data->{class_metaroles}{$type} };
            }
        }

        if (exists $data->{role_metaroles}) {
            for my $type (keys %{ $data->{role_metaroles} }) {
                push @{ $role_metaroles{$type} ||= [] },
                     @{ $data->{role_metaroles}{$type} };
            }
        }

        if (exists $data->{base_class_roles}) {
            push @base_class_roles, @{ $data->{base_class_roles} };
        }

        for my $type (@old_style_role_types) {
            if (exists $data->{$type}) {
                push @{ $old_style_roles{$type} ||= [] },
                     @{ $data->{$type} };
            }
        }
    }

    return {
        (keys(%class_metaroles)
            ? (class_metaroles  => \%class_metaroles)
            : ()),
        (keys(%role_metaroles)
            ? (role_metaroles   => \%role_metaroles)
            : ()),
        (@base_class_roles
            ? (base_class_roles => \@base_class_roles)
            : ()),
        %old_style_roles,
    };
}

sub _apply_meta_traits {
    my ( $class, $traits, $meta_lookup ) = @_;

    return unless @{$traits};

    my $meta = $meta_lookup->($class);

    my $type = $meta->isa('Moose::Meta::Role') ? 'Role'
             : $meta->isa('Class::MOP::Class') ? 'Class'
             : confess('Cannot determine metaclass type for '
                           . 'trait application. Meta isa '
                           . ref $meta);

    my @resolved_traits = map {
        ref $_
            ? $_
            : Moose::Util::resolve_metatrait_alias( $type => $_ )
    } @$traits;

    return unless @resolved_traits;

    my %args = ( for => $class );

    if ( $meta->isa('Moose::Meta::Role') ) {
        $args{role_metaroles} = { role => \@resolved_traits };
    }
    else {
        $args{class_metaroles} = { class => \@resolved_traits };
    }

    Moose::Util::MetaRole::apply_metaroles(%args);
}

sub _get_caller {

    # 1 extra level because it's called by import so there's a layer
    # of indirection
    my $offset = 1;

    return
          ( ref $_[1] && defined $_[1]->{into} ) ? $_[1]->{into}
        : ( ref $_[1] && defined $_[1]->{into_level} )
        ? caller( $offset + $_[1]->{into_level} )
        : caller($offset);
}

sub _make_unimport_sub {
    shift;
    my $exporting_package = shift;
    my $exports           = shift;
    my $export_recorder   = shift;
    my $is_reexport       = shift;
    my $meta_lookup       = shift;

    return sub {
        my $caller = _get_caller(@_);
        Moose::Exporter->_remove_keywords(
            $caller,
            [ keys %{$exports} ],
            $export_recorder,
            $is_reexport,
        );
    };
}

sub _remove_keywords {
    shift;
    my $package          = shift;
    my $keywords         = shift;
    my $recorded_exports = shift;
    my $is_reexport      = shift;

    no strict 'refs';

    foreach my $name ( @{$keywords} ) {
        if ( defined &{ $package . '::' . $name } ) {
            my $sub = \&{ $package . '::' . $name };

            # make sure it is from us
            next unless $recorded_exports->{$sub};

            if ( $is_reexport->{$name} ) {
                no strict 'refs';
                next
                    unless _export_is_flagged(
                            \*{ join q{::} => $package, $name } );
            }

            # and if it is from us, then undef the slot
            delete ${ $package . '::' }{$name};
        }
    }
}

# maintain this for now for backcompat
# make sure to return a sub to install in the same circumstances as previously
# but this functionality now happens at the end of ->import
sub _make_init_meta {
    shift;
    my $class          = shift;
    my $args           = shift;
    my $meta_lookup    = shift;

    my %old_style_roles;
    for my $role (
        map {"${_}_roles"}
        qw(
        metaclass
        attribute_metaclass
        method_metaclass
        wrapped_method_metaclass
        instance_metaclass
        constructor_class
        destructor_class
        error_class
        )
        ) {
        $old_style_roles{$role} = $args->{$role}
            if exists $args->{$role};
    }

    my %base_class_roles;
    %base_class_roles = ( roles => $args->{base_class_roles} )
        if exists $args->{base_class_roles};

    my %new_style_roles = map { $_ => $args->{$_} }
        grep { exists $args->{$_} } qw( class_metaroles role_metaroles );

    return unless %new_style_roles || %old_style_roles || %base_class_roles;

    return sub {
        shift;
        my %opts = @_;
        $meta_lookup->($opts{for_class});
    };
}

sub import {
    strict->import;
    warnings->import;
}

1;

# ABSTRACT: make an import() and unimport() just like Moose.pm

package Moose::Util;
our $VERSION = '2.2204';

use strict;
use warnings;

use Module::Runtime 0.014 'use_package_optimistically', 'module_notional_filename';
use Data::OptList;
use Sub::Exporter;
use Scalar::Util 'blessed';
use List::Util 1.33 qw(first any all);
use overload ();
use Try::Tiny;


my @exports = qw[
    find_meta
    is_role
    does_role
    search_class_by_role
    ensure_all_roles
    apply_all_roles
    with_traits
    get_all_init_args
    get_all_attribute_values
    resolve_metatrait_alias
    resolve_metaclass_alias
    add_method_modifier
    english_list
    meta_attribute_alias
    meta_class_alias
    throw_exception
];

Sub::Exporter::setup_exporter({
    exports => \@exports,
    groups  => { all => \@exports }
});

# Things that need to ->import from Moose::Util
# should be loaded after Moose::Util defines ->import
require Class::MOP;

sub throw_exception {
    my ($class_name, @args_to_exception) = @_;
    my $class = "Moose::Exception::$class_name";
    _load_user_class( $class );
    die $class->new( @args_to_exception );
}

## some utils for the utils ...

sub find_meta { Class::MOP::class_of(@_) }

## the functions ...

sub is_role {
    my $package_or_obj = shift;

    my $meta = find_meta($package_or_obj);
    return if not $meta;
    return $meta->isa('Moose::Meta::Role');
}

sub does_role {
    my ($class_or_obj, $role) = @_;

    if (try { $class_or_obj->isa('Moose::Object') }) {
        return $class_or_obj->does($role);
    }

    my $meta = find_meta($class_or_obj);

    return unless defined $meta;
    return unless $meta->can('does_role');
    return 1 if $meta->does_role($role);
    return;
}

sub search_class_by_role {
    my ($class_or_obj, $role) = @_;

    my $meta = find_meta($class_or_obj);

    return unless defined $meta;

    my $role_name = blessed $role ? $role->name : $role;

    foreach my $class ($meta->class_precedence_list) {

        my $_meta = find_meta($class);

        next unless defined $_meta;

        foreach my $role (@{ $_meta->roles || [] }) {
            return $class if $role->name eq $role_name;
        }
    }

    return;
}

# this can possibly behave in unexpected ways because the roles being composed
# before being applied could differ from call to call; I'm not sure if or how
# to document this possible quirk.
sub ensure_all_roles {
    my $applicant = shift;
    _apply_all_roles($applicant, sub { !does_role($applicant, $_) }, @_);
}

sub apply_all_roles {
    my $applicant = shift;
    _apply_all_roles($applicant, undef, @_);
}

sub _apply_all_roles {
    my $applicant = shift;
    my $role_filter = shift;

    unless (@_) {
        require Moose;
        throw_exception( MustSpecifyAtleastOneRoleToApplicant => applicant => $applicant );
    }

    # If @_ contains role meta objects, mkopt will think that they're values,
    # because they're references.  In other words (roleobj1, roleobj2,
    # roleobj3) will become [ [ roleobj1, roleobj2 ], [ roleobj3, undef ] ]
    # -- this is no good.  We'll preprocess @_ first to eliminate the potential
    # bug.
    # -- rjbs, 2011-04-08
    my $roles = Data::OptList::mkopt( [@_], {
      moniker   => 'role',
      name_test => sub {
        ! ref $_[0] or blessed($_[0]) && $_[0]->isa('Moose::Meta::Role')
      }
    });

    my @role_metas;
    foreach my $role (@$roles) {
        my $meta;

        if ( blessed $role->[0] ) {
            $meta = $role->[0];
        }
        else {
            _load_user_class( $role->[0] , $role->[1] );
            $meta = find_meta( $role->[0] );
        }

        unless ($meta && $meta->isa('Moose::Meta::Role') ) {
            throw_exception( CanOnlyConsumeRole => role_name => $role->[0] );
        }

        push @role_metas, [ $meta, $role->[1] ];
    }

    if ( defined $role_filter ) {
        @role_metas = grep { local $_ = $_->[0]; $role_filter->() } @role_metas;
    }

    return unless @role_metas;

    _load_user_class($applicant)
        unless blessed($applicant)
            || Class::MOP::class_of($applicant);

    my $meta = ( blessed $applicant ? $applicant : Moose::Meta::Class->initialize($applicant) );

    if ( scalar @role_metas == 1 ) {
        my ( $role, $params ) = @{ $role_metas[0] };
        $role->apply( $meta, ( defined $params ? %$params : () ) );
    }
    else {
        Moose::Meta::Role->combine(@role_metas)->apply($meta);
    }
}

sub with_traits {
    my ($class, @roles) = @_;
    return $class unless @roles;
    return Moose::Meta::Class->create_anon_class(
        superclasses => [$class],
        roles        => \@roles,
        cache        => 1,
    )->name;
}

# instance deconstruction ...

sub get_all_attribute_values {
    my ($class, $instance) = @_;
    return +{
        map { $_->name => $_->get_value($instance) }
            grep { $_->has_value($instance) }
                $class->get_all_attributes
    };
}

sub get_all_init_args {
    my ($class, $instance) = @_;
    return +{
        map { $_->init_arg => $_->get_value($instance) }
            grep { $_->has_value($instance) }
                grep { defined($_->init_arg) }
                    $class->get_all_attributes
    };
}

sub resolve_metatrait_alias {
    return resolve_metaclass_alias( @_, trait => 1 );
}

sub _build_alias_package_name {
    my ($type, $name, $trait) = @_;
    return 'Moose::Meta::'
         . $type
         . '::Custom::'
         . ( $trait ? 'Trait::' : '' )
         . $name;
}

{
    my %cache;

    sub resolve_metaclass_alias {
        my ( $type, $metaclass_name, %options ) = @_;

        my $cache_key = $type . q{ } . ( $options{trait} ? '-Trait' : '' );
        return $cache{$cache_key}{$metaclass_name}
            if $cache{$cache_key}{$metaclass_name};

        my $possible_full_name = _build_alias_package_name(
            $type, $metaclass_name, $options{trait}
        );

        my @possible = ($possible_full_name, $metaclass_name);
        for my $package (@possible) {
            use_package_optimistically($package);
            if ($package->can('register_implementation')) {
                return $cache{$cache_key}{$metaclass_name} =
                    $package->register_implementation;
            }
            elsif (find_meta($package)) {
                return $cache{$cache_key}{$metaclass_name} = $package;
            }
        }

        throw_exception( CannotLocatePackageInINC => possible_packages => _english_list_or(@possible),
                                                     INC               => \@INC,
                                                     type              => $type,
                                                     metaclass_name    => $metaclass_name,
                                                     params            => \%options
                       );
    }
}

sub add_method_modifier {
    my ( $class_or_obj, $modifier_name, $args ) = @_;
    my $meta
        = $class_or_obj->can('add_before_method_modifier')
        ? $class_or_obj
        : find_meta($class_or_obj);
    my $code                = pop @{$args};
    my $add_modifier_method = 'add_' . $modifier_name . '_method_modifier';
    if ( my $method_modifier_type = ref( $args->[0] ) ) {
        if ( $method_modifier_type eq 'Regexp' ) {
            my @all_methods = $meta->get_all_methods;
            my @matched_methods
                = grep { $_->name =~ $args->[0] } @all_methods;
            $meta->$add_modifier_method( $_->name, $code )
                for @matched_methods;
        }
        elsif ($method_modifier_type eq 'ARRAY') {
            $meta->$add_modifier_method( $_, $code ) for @{$args->[0]};
        }
        else {
            throw_exception( IllegalMethodTypeToAddMethodModifier => class_or_object => $class_or_obj,
                                                                     modifier_name   => $modifier_name,
                                                                     params          => $args
                           );
        }
    }
    else {
        $meta->$add_modifier_method( $_, $code ) for @{$args};
    }
}

sub english_list {
    _english_list_and(@_);
}

sub _english_list_and {
    _english_list('and', \@_);
}

sub _english_list_or {
    _english_list('or', \@_);
}

sub _english_list {
    my ($conjunction, $items) = @_;

    my @items = sort @$items;

    return $items[0] if @items == 1;
    return "$items[0] $conjunction $items[1]" if @items == 2;

    my $tail = pop @items;
    my $list = join ', ', @items;
    $list .= ", $conjunction " . $tail;

    return $list;
}

sub _caller_info {
    my $level = @_ ? ($_[0] + 1) : 2;
    my %info;
    @info{qw(package file line)} = caller($level);
    return %info;
}

sub _create_alias {
    my ($type, $name, $trait, $for) = @_;
    my $package = _build_alias_package_name($type, $name, $trait);
    Class::MOP::Class->initialize($package)->add_method(
        register_implementation => sub { $for }
    );
}

sub meta_attribute_alias {
    my ($to, $from) = @_;
    $from ||= caller;
    my $meta = Class::MOP::class_of($from);
    my $trait = $meta->isa('Moose::Meta::Role');
    _create_alias('Attribute', $to, $trait, $from);
}

sub meta_class_alias {
    my ($to, $from) = @_;
    $from ||= caller;
    my $meta = Class::MOP::class_of($from);
    my $trait = $meta->isa('Moose::Meta::Role');
    _create_alias('Class', $to, $trait, $from);
}

sub _load_user_class {
    my ($class, $opts) = @_;
    &use_package_optimistically(
        $class,
        $opts && $opts->{-version} ? $opts->{-version} : ()
    );
}

# XXX - this should be added to Params::Util
sub _STRINGLIKE0 ($) {
    return 0 if !defined $_[0];
    return 1 if !ref $_[0];
    return 1 if overload::OverloadedStringify($_[0]);
    return 0;
}

sub _reconcile_roles_for_metaclass {
    my ($class_meta_name, $super_meta_name) = @_;

    my @role_differences = _role_differences(
        $class_meta_name, $super_meta_name,
    );

    # handle the case where we need to fix compatibility between a class and
    # its parent, but all roles in the class are already also done by the
    # parent
    # see t/metaclasses/metaclass_compat_no_fixing_bug.t
    return $super_meta_name
        unless @role_differences;

    return Moose::Meta::Class->create_anon_class(
        superclasses => [$super_meta_name],
        roles        => [map { $_->name } @role_differences],
        cache        => 1,
    )->name;
}

sub _role_differences {
    my ($class_meta_name, $super_meta_name) = @_;
    my @super_role_metas = map {
        $_->isa('Moose::Meta::Role::Composite')
            ? (@{ $_->get_roles })
            : ($_)
    } $super_meta_name->meta->can('_roles_with_inheritance')
        ? $super_meta_name->meta->_roles_with_inheritance
    : $super_meta_name->meta->can('roles')
        ? @{ $super_meta_name->meta->roles }
    :     ();
    my @role_metas = map {
        $_->isa('Moose::Meta::Role::Composite')
            ? (@{ $_->get_roles })
            : ($_)
    } $class_meta_name->meta->can('_roles_with_inheritance')
        ? $class_meta_name->meta->_roles_with_inheritance
    : $class_meta_name->meta->can('roles')
        ? @{ $class_meta_name->meta->roles }
    :     ();
    my @differences;
    for my $role_meta (@role_metas) {
        push @differences, $role_meta
            unless any { $_->name eq $role_meta->name } @super_role_metas;
    }
    return @differences;
}

sub _classes_differ_by_roles_only {
    my ( $self_meta_name, $super_meta_name ) = @_;

    my $common_base_name
        = _find_common_base( $self_meta_name, $super_meta_name );

    return unless defined $common_base_name;

    my @super_meta_name_ancestor_names
        = _get_ancestors_until( $super_meta_name, $common_base_name );
    my @class_meta_name_ancestor_names
        = _get_ancestors_until( $self_meta_name, $common_base_name );

    return
        unless all { _is_role_only_subclass($_) }
        @super_meta_name_ancestor_names,
        @class_meta_name_ancestor_names;

    return 1;
}

sub _find_common_base {
    my ($meta1, $meta2) = map { Class::MOP::class_of($_) } @_;
    return unless defined $meta1 && defined $meta2;

    # FIXME? This doesn't account for multiple inheritance (not sure
    # if it needs to though). For example, if somewhere in $meta1's
    # history it inherits from both ClassA and ClassB, and $meta2
    # inherits from ClassB & ClassA, does it matter? And what crazy
    # fool would do that anyway?

    my %meta1_parents = map { $_ => 1 } $meta1->linearized_isa;

    return first { $meta1_parents{$_} } $meta2->linearized_isa;
}

sub _get_ancestors_until {
    my ($start_name, $until_name) = @_;

    my @ancestor_names;
    for my $ancestor_name (Class::MOP::class_of($start_name)->linearized_isa) {
        last if $ancestor_name eq $until_name;
        push @ancestor_names, $ancestor_name;
    }
    return @ancestor_names;
}

sub _is_role_only_subclass {
    my ($meta_name) = @_;
    my $meta = Class::MOP::Class->initialize($meta_name);
    my @parent_names = $meta->superclasses;

    # XXX: don't feel like messing with multiple inheritance here... what would
    # that even do?
    return unless @parent_names == 1;
    my ($parent_name) = @parent_names;
    my $parent_meta = Class::MOP::Class->initialize($parent_name);

    # only get the roles attached to this particular class, don't look at
    # superclasses
    my @roles = $meta->can('calculate_all_roles')
                    ? $meta->calculate_all_roles
                    : ();

    # it's obviously not a role-only subclass if it doesn't do any roles
    return unless @roles;

    # loop over all methods that are a part of the current class
    # (not inherited)
    for my $method ( $meta->_get_local_methods ) {
        # always ignore meta
        next if $method->isa('Class::MOP::Method::Meta');
        # we'll deal with attributes below
        next if $method->can('associated_attribute');
        # if the method comes from a role we consumed, ignore it
        next if $meta->can('does_role')
             && $meta->does_role($method->original_package_name);
        # FIXME - this really isn't right. Just because a modifier is
        # defined in a role doesn't mean it isn't _also_ defined in the
        # subclass.
        next if $method->isa('Class::MOP::Method::Wrapped')
             && (
                 (!scalar($method->around_modifiers)
               || any { $_->has_around_method_modifiers($method->name) } @roles)
              && (!scalar($method->before_modifiers)
               || any { $_->has_before_method_modifiers($method->name) } @roles)
              && (!scalar($method->after_modifiers)
               || any { $_->has_after_method_modifiers($method->name) } @roles)
                );

        return 0;
    }

    # loop over all attributes that are a part of the current class
    # (not inherited)
    # FIXME - this really isn't right. Just because an attribute is
    # defined in a role doesn't mean it isn't _also_ defined in the
    # subclass.
    for my $attr (map { $meta->get_attribute($_) } $meta->get_attribute_list) {
        next if any { $_->has_attribute($attr->name) } @roles;

        return 0;
    }

    return 1;
}

sub _is_package_loaded {
    my ($package) = @_;
    defined $INC{module_notional_filename($package)};
}

1;

# ABSTRACT: Utilities for working with Moose classes

package Moose::Meta::Role;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use Scalar::Util 'blessed';

use Moose::Meta::Class;
use Moose::Meta::Role::Attribute;
use Moose::Meta::Role::Method;
use Moose::Meta::Role::Method::Required;
use Moose::Meta::Role::Method::Conflicting;
use Moose::Meta::Method::Meta;
use Moose::Util qw/throw_exception/;
use Class::MOP::MiniTrait;

use parent 'Class::MOP::Module',
         'Class::MOP::Mixin::HasAttributes',
         'Class::MOP::Mixin::HasMethods',
         'Class::MOP::Mixin::HasOverloads';

Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');

## ------------------------------------------------------------------
## NOTE:
## I normally don't do this, but I am doing
## a whole bunch of meta-programmin' in this
## module, so it just makes sense. For a clearer
## picture of what is going on in the next
## several lines of code, look at the really
## big comment at the end of this file (right
## before the POD).
## - SL
## ------------------------------------------------------------------

my $META = __PACKAGE__->meta;

## ------------------------------------------------------------------
## attributes ...

# NOTE:
# since roles are lazy, we hold all the attributes
# of the individual role in 'stasis' until which
# time when it is applied to a class. This means
# keeping a lot of things in hash maps, so we are
# using a little of that meta-programmin' magic
# here and saving lots of extra typin'. And since
# many of these attributes above require similar
# functionality to support them, so we again use
# the wonders of meta-programmin' to deliver a
# very compact solution to this normally verbose
# problem.
# - SL

foreach my $action (
    {
        name        => 'excluded_roles_map',
        attr_reader => 'get_excluded_roles_map' ,
        methods     => {
            add       => 'add_excluded_roles',
            get_keys  => 'get_excluded_roles_list',
            existence => 'excludes_role',
        }
    },
    {
        name        => 'required_methods',
        attr_reader => 'get_required_methods_map',
        methods     => {
            remove     => 'remove_required_methods',
            get_values => 'get_required_method_list',
            existence  => 'requires_method',
        }
    },
) {

    my $attr_reader = $action->{attr_reader};
    my $methods     = $action->{methods};

    # create the attribute
    $META->add_attribute($action->{name} => (
        reader  => $attr_reader,
        default => sub { {} },
        Class::MOP::_definition_context(),
    ));

    # create some helper methods
    $META->add_method($methods->{add} => sub {
        my ($self, @values) = @_;
        $self->$attr_reader->{$_} = undef foreach @values;
    }) if exists $methods->{add};

    $META->add_method($methods->{get_keys} => sub {
        my ($self) = @_;
        keys %{$self->$attr_reader};
    }) if exists $methods->{get_keys};

    $META->add_method($methods->{get_values} => sub {
        my ($self) = @_;
        values %{$self->$attr_reader};
    }) if exists $methods->{get_values};

    $META->add_method($methods->{get} => sub {
        my ($self, $name) = @_;
        $self->$attr_reader->{$name}
    }) if exists $methods->{get};

    $META->add_method($methods->{existence} => sub {
        my ($self, $name) = @_;
        exists $self->$attr_reader->{$name} ? 1 : 0;
    }) if exists $methods->{existence};

    $META->add_method($methods->{remove} => sub {
        my ($self, @values) = @_;
        delete $self->$attr_reader->{$_} foreach @values;
    }) if exists $methods->{remove};
}

$META->add_attribute(
    'method_metaclass',
    reader  => 'method_metaclass',
    default => 'Moose::Meta::Role::Method',
    Class::MOP::_definition_context(),
);

$META->add_attribute(
    'required_method_metaclass',
    reader  => 'required_method_metaclass',
    default => 'Moose::Meta::Role::Method::Required',
    Class::MOP::_definition_context(),
);

$META->add_attribute(
    'conflicting_method_metaclass',
    reader  => 'conflicting_method_metaclass',
    default => 'Moose::Meta::Role::Method::Conflicting',
    Class::MOP::_definition_context(),
);

$META->add_attribute(
    'application_to_class_class',
    reader  => 'application_to_class_class',
    default => 'Moose::Meta::Role::Application::ToClass',
    Class::MOP::_definition_context(),
);

$META->add_attribute(
    'application_to_role_class',
    reader  => 'application_to_role_class',
    default => 'Moose::Meta::Role::Application::ToRole',
    Class::MOP::_definition_context(),
);

$META->add_attribute(
    'application_to_instance_class',
    reader  => 'application_to_instance_class',
    default => 'Moose::Meta::Role::Application::ToInstance',
    Class::MOP::_definition_context(),
);

$META->add_attribute(
    'applied_attribute_metaclass',
    reader  => 'applied_attribute_metaclass',
    default => 'Moose::Meta::Attribute',
    Class::MOP::_definition_context(),
);

# More or less copied from Moose::Meta::Class
sub initialize {
    my $class = shift;
    my @args = @_;
    unshift @args, 'package' if @args % 2;
    my %opts = @args;
    my $package = delete $opts{package};
    return Class::MOP::get_metaclass_by_name($package)
        || $class->SUPER::initialize($package,
                'attribute_metaclass' => 'Moose::Meta::Role::Attribute',
                %opts,
            );
}

sub reinitialize {
    my $self = shift;
    my $pkg  = shift;

    my $meta = blessed $pkg ? $pkg : Class::MOP::class_of($pkg);

    my %existing_classes;
    if ($meta) {
        %existing_classes = map { $_ => $meta->$_() } qw(
            attribute_metaclass
            method_metaclass
            wrapped_method_metaclass
            required_method_metaclass
            conflicting_method_metaclass
            application_to_class_class
            application_to_role_class
            application_to_instance_class
            applied_attribute_metaclass
        );
    }

    my %options = @_;
    $options{weaken} = Class::MOP::metaclass_is_weak($meta->name)
        if !exists $options{weaken}
        && blessed($meta)
        && $meta->isa('Moose::Meta::Role');

    # don't need to remove generated metaobjects here yet, since we don't
    # yet generate anything in roles. this may change in the future though...
    # keep an eye on that
    my $new_meta = $self->SUPER::reinitialize(
        $pkg,
        %existing_classes,
        %options,
    );
    $new_meta->_restore_metaobjects_from($meta)
        if $meta && $meta->isa('Moose::Meta::Role');
    return $new_meta;
}

sub _restore_metaobjects_from {
    my $self = shift;
    my ($old_meta) = @_;

    $self->_restore_metamethods_from($old_meta);
    $self->_restore_metaattributes_from($old_meta);

    for my $role ( @{ $old_meta->get_roles } ) {
        $self->add_role($role);
    }
}

sub add_attribute {
    my $self = shift;

    if (blessed $_[0] && ! $_[0]->isa('Moose::Meta::Role::Attribute') ) {
        my $class = ref $_[0];
        throw_exception( CannotAddAsAnAttributeToARole => role_name       => $self->name,
                                                          attribute_class => $class,
                       );
    }
    elsif (!blessed($_[0]) && defined($_[0]) && $_[0] =~ /^\+(.*)/) {
        throw_exception( AttributeExtensionIsNotSupportedInRoles => attribute_name => $_[0],
                                                                    role_name      => $self->name,
                       );
    }

    return $self->SUPER::add_attribute(@_);
}

sub _attach_attribute {
    my ( $self, $attribute ) = @_;

    $attribute->attach_to_role($self);
}

sub add_required_methods {
    my $self = shift;

    for (@_) {
        my $method = $_;
        if (!blessed($method)) {
            $method = $self->required_method_metaclass->new(
                name => $method,
            );
        }
        $self->get_required_methods_map->{$method->name} = $method;
    }
}

sub add_conflicting_method {
    my $self = shift;

    my $method;
    if (@_ == 1 && blessed($_[0])) {
        $method = shift;
    }
    else {
        $method = $self->conflicting_method_metaclass->new(@_);
    }

    $self->add_required_methods($method);
}

## ------------------------------------------------------------------
## method modifiers

# NOTE:
# the before/around/after method modifiers are
# stored by name, but there can be many methods
# then associated with that name. So again we have
# lots of similar functionality, so we can do some
# meta-programmin' and save some time.
# - SL

foreach my $modifier_type (qw[ before around after ]) {

    my $attr_reader = "get_${modifier_type}_method_modifiers_map";

    # create the attribute ...
    $META->add_attribute("${modifier_type}_method_modifiers" => (
        reader  => $attr_reader,
        default => sub { {} },
        Class::MOP::_definition_context(),
    ));

    # and some helper methods ...
    $META->add_method("get_${modifier_type}_method_modifiers" => sub {
        my ($self, $method_name) = @_;
        #return () unless exists $self->$attr_reader->{$method_name};
        my $mm = $self->$attr_reader->{$method_name};
        $mm ? @$mm : ();
    });

    $META->add_method("has_${modifier_type}_method_modifiers" => sub {
        my ($self, $method_name) = @_;
        # NOTE:
        # for now we assume that if it exists,..
        # it has at least one modifier in it
        (exists $self->$attr_reader->{$method_name}) ? 1 : 0;
    });

    $META->add_method("add_${modifier_type}_method_modifier" => sub {
        my ($self, $method_name, $method) = @_;

        $self->$attr_reader->{$method_name} = []
            unless exists $self->$attr_reader->{$method_name};

        my $modifiers = $self->$attr_reader->{$method_name};

        # NOTE:
        # check to see that we aren't adding the
        # same code twice. We err in favor of the
        # first on here, this may not be as expected
        foreach my $modifier (@{$modifiers}) {
            return if $modifier == $method;
        }

        push @{$modifiers} => $method;
    });

}

## ------------------------------------------------------------------
## override method modifiers

$META->add_attribute('override_method_modifiers' => (
    reader  => 'get_override_method_modifiers_map',
    default => sub { {} },
    Class::MOP::_definition_context(),
));

# NOTE:
# these are a little different because there
# can only be one per name, whereas the other
# method modifiers can have multiples.
# - SL

sub add_override_method_modifier {
    my ($self, $method_name, $method) = @_;
    (!$self->has_method($method_name))
        || throw_exception( CannotOverrideALocalMethod => method_name => $method_name,
                                                          role_name   => $self->name,
                          );
    $self->get_override_method_modifiers_map->{$method_name} = $method;
}

sub has_override_method_modifier {
    my ($self, $method_name) = @_;
    # NOTE:
    # for now we assume that if it exists,..
    # it has at least one modifier in it
    (exists $self->get_override_method_modifiers_map->{$method_name}) ? 1 : 0;
}

sub get_override_method_modifier {
    my ($self, $method_name) = @_;
    $self->get_override_method_modifiers_map->{$method_name};
}

## general list accessor ...

sub get_method_modifier_list {
    my ($self, $modifier_type) = @_;
    my $accessor = "get_${modifier_type}_method_modifiers_map";
    keys %{$self->$accessor};
}

sub _meta_method_class { 'Moose::Meta::Method::Meta' }

## ------------------------------------------------------------------
## subroles

$META->add_attribute('roles' => (
    reader  => 'get_roles',
    default => sub { [] },
    Class::MOP::_definition_context(),
));

sub add_role {
    my ($self, $role) = @_;
    (blessed($role) && $role->isa('Moose::Meta::Role'))
        || throw_exception( AddRoleToARoleTakesAMooseMetaRole => role_to_be_added => $role,
                                                                 role_name        => $self->name,
                          );
    push @{$self->get_roles} => $role;
    $self->reset_package_cache_flag;
}

sub calculate_all_roles {
    my $self = shift;
    my %seen;
    grep {
        !$seen{$_->name}++
    } ($self, map {
                  $_->calculate_all_roles
              } @{ $self->get_roles });
}

sub does_role {
    my ($self, $role) = @_;
    (defined $role)
        || throw_exception( RoleNameRequiredForMooseMetaRole => role_name => $self->name );
    my $role_name = blessed $role ? $role->name : $role;
    # if we are it,.. then return true
    return 1 if $role_name eq $self->name;
    # otherwise.. check our children
    foreach my $role (@{$self->get_roles}) {
        return 1 if $role->does_role($role_name);
    }
    return 0;
}

sub find_method_by_name { (shift)->get_method(@_) }

## ------------------------------------------------------------------
## role construction
## ------------------------------------------------------------------

sub apply {
    my ($self, $other, %args) = @_;

    (blessed($other))
        || throw_exception( ApplyTakesABlessedInstance => param     => $other,
                                                          role_name => $self->name,
                          );

    my $application_class;
    if ($other->isa('Moose::Meta::Role')) {
        $application_class = $self->application_to_role_class;
    }
    elsif ($other->isa('Moose::Meta::Class')) {
        $application_class = $self->application_to_class_class;
    }
    else {
        $application_class = $self->application_to_instance_class;
    }

    Moose::Util::_load_user_class($application_class);

    if ( exists $args{'-excludes'} ) {
        # I wish we had coercion here :)
        $args{'-excludes'} = (
            ref $args{'-excludes'} eq 'ARRAY'
            ? $args{'-excludes'}
            : [ $args{'-excludes'} ]
        );
    }

    return $application_class->new(%args)->apply($self, $other, \%args);
}

sub composition_class_roles { }

sub combine {
    my ($class, @role_specs) = @_;

    require Moose::Meta::Role::Composite;

    my (@roles, %role_params);
    while (@role_specs) {
        my ($role, $params) = @{ splice @role_specs, 0, 1 };
        my $requested_role
            = blessed $role
            ? $role
            : Class::MOP::class_of($role);

        my $actual_role = $requested_role->_role_for_combination($params);
        push @roles => $actual_role;

        next unless defined $params;
        $role_params{$actual_role->name} = $params;
    }

    my $c = Moose::Meta::Role::Composite->new(roles => \@roles);
    return $c->apply_params(\%role_params);
}

sub _role_for_combination {
    my ($self, $params) = @_;
    return $self;
}

sub create {
    my $class = shift;
    my @args = @_;

    unshift @args, 'package' if @args % 2 == 1;
    my %options = @args;

    (ref $options{attributes} eq 'HASH')
        || throw_exception( CreateTakesHashRefOfAttributes => params           => \%options,
                                                              attribute_class  => $class
                          )
            if exists $options{attributes};

    (ref $options{methods} eq 'HASH')
        || throw_exception( CreateTakesHashRefOfMethods => params           => \%options,
                                                           attribute_class  => $class
                          )
            if exists $options{methods};

    (ref $options{roles} eq 'ARRAY')
        || throw_exception( CreateTakesArrayRefOfRoles => params           => \%options,
                                                          attribute_class  => $class
                          )
            if exists $options{roles};

    my $package      = delete $options{package};
    my $roles        = delete $options{roles};
    my $attributes   = delete $options{attributes};
    my $methods      = delete $options{methods};
    my $meta_name    = exists $options{meta_name}
                         ? delete $options{meta_name}
                         : 'meta';

    my $meta = $class->SUPER::create($package => %options);

    $meta->_add_meta_method($meta_name)
        if defined $meta_name;

    if (defined $attributes) {
        foreach my $attribute_name (keys %{$attributes}) {
            my $attr = $attributes->{$attribute_name};
            $meta->add_attribute(
                $attribute_name => blessed $attr ? $attr : %{$attr} );
        }
    }

    if (defined $methods) {
        foreach my $method_name (keys %{$methods}) {
            $meta->add_method($method_name, $methods->{$method_name});
        }
    }

    if ($roles) {
        Moose::Util::apply_all_roles($meta, @$roles);
    }

    return $meta;
}

sub consumers {
    my $self = shift;
    my @consumers;
    for my $meta (Class::MOP::get_all_metaclass_instances) {
        next if $meta->name eq $self->name;
        next unless $meta->isa('Moose::Meta::Class')
                 || $meta->isa('Moose::Meta::Role');
        push @consumers, $meta->name
            if $meta->does_role($self->name);
    }
    return @consumers;
}

# XXX: something more intelligent here?
sub _anon_package_prefix { 'Moose::Meta::Role::__ANON__::SERIAL::' }

sub create_anon_role { shift->create_anon(@_) }
sub is_anon_role     { shift->is_anon(@_)     }

sub _anon_cache_key {
    my $class = shift;
    my %options = @_;

    # XXX fix this duplication (see MMC::_anon_cache_key
    my $roles = Data::OptList::mkopt(($options{roles} || []), {
        moniker  => 'role',
        val_test => sub { ref($_[0]) eq 'HASH' },
    });

    my @role_keys;
    for my $role_spec (@$roles) {
        my ($role, $params) = @$role_spec;
        $params = { %$params };

        my $key = blessed($role) ? $role->name : $role;

        if ($params && %$params) {
            my $alias    = delete $params->{'-alias'}
                        || delete $params->{'alias'}
                        || {};
            my $excludes = delete $params->{'-excludes'}
                        || delete $params->{'excludes'}
                        || [];
            $excludes = [$excludes] unless ref($excludes) eq 'ARRAY';

            if (%$params) {
                warn "Roles with parameters cannot be cached. Consider "
                   . "applying the parameters before calling "
                   . "create_anon_class, or using 'weaken => 0' instead";
                return;
            }

            my $alias_key = join('%',
                map { $_ => $alias->{$_} } sort keys %$alias
            );
            my $excludes_key = join('%',
                sort @$excludes
            );
            $key .= '<' . join('+', 'a', $alias_key, 'e', $excludes_key) . '>';
        }

        push @role_keys, $key;
    }

    # Makes something like Role|Role::1
    return join('|', sort @role_keys);
}

#####################################################################
## NOTE:
## This is Moose::Meta::Role as defined by Moose (plus the use of
## MooseX::AttributeHelpers module). It is here as a reference to
## make it easier to see what is happening above with all the meta
## programming. - SL
#####################################################################
#
# has 'roles' => (
#     metaclass => 'Array',
#     reader    => 'get_roles',
#     isa       => 'ArrayRef[Moose::Meta::Role]',
#     default   => sub { [] },
#     provides  => {
#         'push' => 'add_role',
#     }
# );
#
# has 'excluded_roles_map' => (
#     metaclass => 'Hash',
#     reader    => 'get_excluded_roles_map',
#     isa       => 'HashRef[Str]',
#     provides  => {
#         # Not exactly set, cause it sets multiple
#         'set'    => 'add_excluded_roles',
#         'keys'   => 'get_excluded_roles_list',
#         'exists' => 'excludes_role',
#     }
# );
#
# has 'required_methods' => (
#     metaclass => 'Hash',
#     reader    => 'get_required_methods_map',
#     isa       => 'HashRef[Moose::Meta::Role::Method::Required]',
#     provides  => {
#         # not exactly set, or delete since it works for multiple
#         'set'    => 'add_required_methods',
#         'delete' => 'remove_required_methods',
#         'keys'   => 'get_required_method_list',
#         'exists' => 'requires_method',
#     }
# );
#
# # the before, around and after modifiers are
# # HASH keyed by method-name, with ARRAY of
# # CODE refs to apply in that order
#
# has 'before_method_modifiers' => (
#     metaclass => 'Hash',
#     reader    => 'get_before_method_modifiers_map',
#     isa       => 'HashRef[ArrayRef[CodeRef]]',
#     provides  => {
#         'keys'   => 'get_before_method_modifiers',
#         'exists' => 'has_before_method_modifiers',
#         # This actually makes sure there is an
#         # ARRAY at the given key, and pushed onto
#         # it. It also checks for duplicates as well
#         # 'add'  => 'add_before_method_modifier'
#     }
# );
#
# has 'after_method_modifiers' => (
#     metaclass => 'Hash',
#     reader    =>'get_after_method_modifiers_map',
#     isa       => 'HashRef[ArrayRef[CodeRef]]',
#     provides  => {
#         'keys'   => 'get_after_method_modifiers',
#         'exists' => 'has_after_method_modifiers',
#         # This actually makes sure there is an
#         # ARRAY at the given key, and pushed onto
#         # it. It also checks for duplicates as well
#         # 'add'  => 'add_after_method_modifier'
#     }
# );
#
# has 'around_method_modifiers' => (
#     metaclass => 'Hash',
#     reader    =>'get_around_method_modifiers_map',
#     isa       => 'HashRef[ArrayRef[CodeRef]]',
#     provides  => {
#         'keys'   => 'get_around_method_modifiers',
#         'exists' => 'has_around_method_modifiers',
#         # This actually makes sure there is an
#         # ARRAY at the given key, and pushed onto
#         # it. It also checks for duplicates as well
#         # 'add'  => 'add_around_method_modifier'
#     }
# );
#
# # override is similar to the other modifiers
# # except that it is not an ARRAY of code refs
# # but instead just a single name->code mapping
#
# has 'override_method_modifiers' => (
#     metaclass => 'Hash',
#     reader    =>'get_override_method_modifiers_map',
#     isa       => 'HashRef[CodeRef]',
#     provides  => {
#         'keys'   => 'get_override_method_modifier',
#         'exists' => 'has_override_method_modifier',
#         'add'    => 'add_override_method_modifier', # checks for local method ..
#     }
# );
#
#####################################################################


1;

# ABSTRACT: The Moose Role metaclass

package Moose::Meta::TypeCoercion;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use Moose::Meta::Attribute;
use Moose::Util::TypeConstraints ();

use Moose::Util 'throw_exception';

__PACKAGE__->meta->add_attribute('type_coercion_map' => (
    reader  => 'type_coercion_map',
    default => sub { [] },
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute(
    Moose::Meta::Attribute->new('type_constraint' => (
        reader   => 'type_constraint',
        weak_ref => 1,
        Class::MOP::_definition_context(),
    ))
);

# private accessor
__PACKAGE__->meta->add_attribute('compiled_type_coercion' => (
    accessor => '_compiled_type_coercion',
    Class::MOP::_definition_context(),
));

sub new {
    my $class = shift;
    my $self  = Class::MOP::class_of($class)->new_object(@_);
    $self->compile_type_coercion;
    return $self;
}

sub compile_type_coercion {
    my $self = shift;
    my @coercion_map = @{$self->type_coercion_map};
    my @coercions;
    while (@coercion_map) {
        my ($constraint_name, $action) = splice(@coercion_map, 0, 2);
        my $type_constraint = ref $constraint_name ? $constraint_name : Moose::Util::TypeConstraints::find_or_parse_type_constraint($constraint_name);

        unless ( defined $type_constraint ) {
            throw_exception( CouldNotFindTypeConstraintToCoerceFrom => constraint_name => $constraint_name,
                                                                       instance        => $self
                           );
        }

        push @coercions => [
            $type_constraint->_compiled_type_constraint,
            $action
        ];
    }
    $self->_compiled_type_coercion(sub {
        my $thing = shift;
        foreach my $coercion (@coercions) {
            my ($constraint, $converter) = @$coercion;
            if ($constraint->($thing)) {
                local $_ = $thing;
                return $converter->($thing);
            }
        }
        return $thing;
    });
}

sub has_coercion_for_type {
    my ($self, $type_name) = @_;
    my %coercion_map = @{$self->type_coercion_map};
    exists $coercion_map{$type_name} ? 1 : 0;
}

sub add_type_coercions {
    my ($self, @new_coercion_map) = @_;

    my $coercion_map = $self->type_coercion_map;
    my %has_coercion = @$coercion_map;

    while (@new_coercion_map) {
        my ($constraint_name, $action) = splice(@new_coercion_map, 0, 2);

        if ( exists $has_coercion{$constraint_name} ) {
            throw_exception( CoercionAlreadyExists => constraint_name => $constraint_name,
                                                      instance        => $self
                           );
        }

        push @{$coercion_map} => ($constraint_name, $action);
    }

    # and re-compile ...
    $self->compile_type_coercion;
}

sub coerce { $_[0]->_compiled_type_coercion->($_[1]) }


1;

# ABSTRACT: The Moose Type Coercion metaclass

package Moose::Meta::Role::Composite;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use Scalar::Util 'blessed';
use Moose::Util 'throw_exception';
use parent 'Moose::Meta::Role';

# NOTE:
# we need to override the ->name
# method from Class::MOP::Package
# since we don't have an actual
# package for this.
# - SL
__PACKAGE__->meta->add_attribute('name' => (
    reader => 'name',
    Class::MOP::_definition_context(),
));

# NOTE:
# Again, since we don't have a real
# package to store our methods in,
# we use a HASH ref instead.
# - SL
__PACKAGE__->meta->add_attribute('_methods' => (
    reader  => '_method_map',
    default => sub { {} },
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('_overloads' => (
    reader  => '_overload_map',
    default => sub { {} },
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('_overload_fallback' => (
    accessor  => '_overload_fallback',
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute(
    'application_role_summation_class',
    reader  => 'application_role_summation_class',
    default => 'Moose::Meta::Role::Application::RoleSummation',
    Class::MOP::_definition_context(),
);

sub new {
    my ($class, %params) = @_;

    # the roles param is required ...
    foreach ( @{$params{roles}} ) {
        unless ( $_->isa('Moose::Meta::Role') ) {
            throw_exception( RolesListMustBeInstancesOfMooseMetaRole => params => \%params,
                                                                        role   => $_,
                                                                        class  => $class
                           );
        }
    }

    my @composition_roles = map {
        $_->composition_class_roles
    } @{ $params{roles} };

    if (@composition_roles) {
        my $meta = Moose::Meta::Class->create_anon_class(
            superclasses => [ $class ],
            roles        => [ @composition_roles ],
            cache        => 1,
        );
        $class = $meta->name;
    }

    # and the name is created from the
    # roles if one has not been provided
    $params{name} ||= (join "|" => map { $_->name } @{$params{roles}});
    $class->_new(\%params);
}

# There's no such thing as an anonymous composite role since composites are an
# artifact of Moose's internals. However, a composite role that contains an
# anon role may _look_ like an anon role since $self->name =~ /$anon_key/ can
# return true if the first role in the composite is anonymous itself.
sub is_anon { 0 }

# This is largely a copy of what's in Moose::Meta::Role (itself
# largely a copy of Class::MOP::Class). However, we can't actually
# call add_package_symbol, because there's no package into which to
# add the symbol.
sub add_method {
    my ($self, $method_name, $method) = @_;

    unless ( defined $method_name && $method_name ) {
        throw_exception( MustDefineAMethodName => instance => $self );
    }

    my $body;
    if (blessed($method)) {
        $body = $method->body;
        if ($method->package_name ne $self->name) {
            $method = $method->clone(
                package_name => $self->name,
                name         => $method_name
            ) if $method->can('clone');
        }
    }
    else {
        $body = $method;
        $method = $self->wrap_method_body( body => $body, name => $method_name );
    }

    $self->_method_map->{$method_name} = $method;
}

sub get_method_list {
    my $self = shift;
    return keys %{ $self->_method_map };
}

sub _get_local_methods {
    my $self = shift;
    return values %{ $self->_method_map };
}

sub has_method {
    my ($self, $method_name) = @_;

    return exists $self->_method_map->{$method_name};
}

sub get_method {
    my ($self, $method_name) = @_;

    return $self->_method_map->{$method_name};
}

sub is_overloaded {
    my ($self) = @_;
    return keys %{ $self->_overload_map };
}

sub add_overloaded_operator {
    my ( $self, $op_name, $overload ) = @_;

    unless ( defined $op_name && $op_name ) {
        throw_exception(
            'MustDefineAnOverloadOperator',
            instance => $self,
        );
    }

    $self->_overload_map->{$op_name} = $overload;
}

sub get_overload_fallback_value {
    my ($self) = @_;
    return $self->_overload_fallback;
}

sub set_overload_fallback_value {
    my $self = shift;
    $self->_overload_fallback(shift);
}

sub get_all_overloaded_operators {
    my ( $self, $method_name ) = @_;
    return values %{ $self->_overload_map };
}

sub apply_params {
    my ($self, $role_params) = @_;
    Moose::Util::_load_user_class($self->application_role_summation_class);

    $self->application_role_summation_class->new(
        role_params => $role_params,
    )->apply($self);

    return $self;
}

sub reinitialize {
    my ( $class, $old_meta, @args ) = @_;

    throw_exception( CannotInitializeMooseMetaRoleComposite => old_meta       => $old_meta,
                                                               args           => \@args,
                                                               role_composite => $class
                   )
        if !blessed $old_meta
            || !$old_meta->isa('Moose::Meta::Role::Composite');

    my %existing_classes = map { $_ => $old_meta->$_() } qw(
        application_role_summation_class
    );

    return $old_meta->meta->clone_object( $old_meta, %existing_classes, @args );
}

1;

# ABSTRACT: An object to represent the set of roles

package Moose::Meta::Role::Method;
our $VERSION = '2.2204';

use strict;
use warnings;

use parent 'Moose::Meta::Method';

sub _make_compatible_with {
    my $self = shift;
    my ($other) = @_;

    # XXX: this is pretty gross. the issue here is blah blah blah
    # see the comments in CMOP::Method::Meta and CMOP::Method::Wrapped
    return $self unless $other->_is_compatible_with($self->_real_ref_name);

    return $self->SUPER::_make_compatible_with(@_);
}

1;

# ABSTRACT: A Moose Method metaclass for Roles

package Moose::Meta::Role::Application;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;
use overload ();

use List::Util 1.33 qw( all );

use Moose::Util 'throw_exception';

__PACKAGE__->meta->add_attribute('method_exclusions' => (
    init_arg => '-excludes',
    reader   => 'get_method_exclusions',
    default  => sub { [] },
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('method_aliases' => (
    init_arg => '-alias',
    reader   => 'get_method_aliases',
    default  => sub { {} },
    Class::MOP::_definition_context(),
));

sub new {
    my ($class, %params) = @_;
    $class->_new(\%params);
}

sub is_method_excluded {
    my ($self, $method_name) = @_;
    foreach (@{$self->get_method_exclusions}) {
        return 1 if $_ eq $method_name;
    }
    return 0;
}

sub is_method_aliased {
    my ($self, $method_name) = @_;
    exists $self->get_method_aliases->{$method_name} ? 1 : 0
}

sub is_aliased_method {
    my ($self, $method_name) = @_;
    my %aliased_names = reverse %{$self->get_method_aliases};
    exists $aliased_names{$method_name} ? 1 : 0;
}

sub apply {
    my $self = shift;

    $self->check_role_exclusions(@_);
    $self->check_required_methods(@_);
    $self->check_required_attributes(@_);

    $self->apply_overloading(@_);
    $self->apply_attributes(@_);
    $self->apply_methods(@_);

    $self->apply_override_method_modifiers(@_);

    $self->apply_before_method_modifiers(@_);
    $self->apply_around_method_modifiers(@_);
    $self->apply_after_method_modifiers(@_);
}

sub check_role_exclusions           { throw_exception( "CannotCallAnAbstractMethod" ); }
sub check_required_methods          { throw_exception( "CannotCallAnAbstractMethod" ); }
sub check_required_attributes       { throw_exception( "CannotCallAnAbstractMethod" ); }

sub apply_attributes                { throw_exception( "CannotCallAnAbstractMethod" ); }
sub apply_methods                   { throw_exception( "CannotCallAnAbstractMethod" ); }
sub apply_override_method_modifiers { throw_exception( "CannotCallAnAbstractMethod" ); }
sub apply_method_modifiers          { throw_exception( "CannotCallAnAbstractMethod" ); }

sub apply_before_method_modifiers   { (shift)->apply_method_modifiers('before' => @_) }
sub apply_around_method_modifiers   { (shift)->apply_method_modifiers('around' => @_) }
sub apply_after_method_modifiers    { (shift)->apply_method_modifiers('after'  => @_) }

sub apply_overloading {
    my ( $self, $role, $other ) = @_;

    return unless $role->is_overloaded;

    unless ( $other->is_overloaded ) {
        $other->set_overload_fallback_value(
            $role->get_overload_fallback_value );
    }

    for my $overload ( $role->get_all_overloaded_operators ) {
        next if $other->has_overloaded_operator( $overload->operator );
        $other->add_overloaded_operator(
            $overload->operator => $overload->clone );
    }
}

1;

# ABSTRACT: A base class for role application

package Moose::Meta::Role::Method::Required;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use overload
    '""' => sub { shift->name },   # stringify to method name
    'bool' => sub { 1 },
    fallback => 1;

use parent 'Class::MOP::Object';

# This is not a Moose::Meta::Role::Method because it has no implementation, it
# is just a name

__PACKAGE__->meta->add_attribute('name' => (
    reader   => 'name',
    required => 1,
    Class::MOP::_definition_context(),
));

sub new { shift->_new(@_) }

1;

# ABSTRACT: A Moose metaclass for required methods in Roles

package Moose::Meta::Role::Method::Conflicting;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Util;

use parent 'Moose::Meta::Role::Method::Required';

__PACKAGE__->meta->add_attribute('roles' => (
    reader   => 'roles',
    required => 1,
    Class::MOP::_definition_context(),
));

sub roles_as_english_list {
    my $self = shift;
    Moose::Util::english_list( map { q{'} . $_ . q{'} } @{ $self->roles } );
}

1;

# ABSTRACT: A Moose metaclass for conflicting methods in Roles

package Moose::Meta::Role::Application::ToRole;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use parent 'Moose::Meta::Role::Application';

use Moose::Util 'throw_exception';

sub apply {
    my ($self, $role1, $role2) = @_;
    $self->SUPER::apply($role1, $role2);
    $role2->add_role($role1);
}

sub check_role_exclusions {
    my ($self, $role1, $role2) = @_;
    if ( $role2->excludes_role($role1->name) ) {
        throw_exception( ConflictDetectedInCheckRoleExclusions => role_name          => $role2->name,
                                                                  excluded_role_name => $role1->name,
                       );
    }
    foreach my $excluded_role_name ($role1->get_excluded_roles_list) {
        if ( $role2->does_role($excluded_role_name) ) {
            throw_exception( RoleDoesTheExcludedRole => role_name          => $role2->name,
                                                        excluded_role_name => $excluded_role_name,
                                                        second_role_name   => $role1->name,
                           );
        }
        $role2->add_excluded_roles($excluded_role_name);
    }
}

sub check_required_methods {
    my ($self, $role1, $role2) = @_;
    foreach my $required_method ($role1->get_required_method_list) {
        my $required_method_name = $required_method->name;

        next if $self->is_aliased_method($required_method_name);

        $role2->add_required_methods($required_method)
            unless $role2->find_method_by_name($required_method_name);
    }
}

sub check_required_attributes {

}

sub apply_attributes {
    my ($self, $role1, $role2) = @_;
    foreach my $attribute_name ($role1->get_attribute_list) {
        # it if it has one already
        if ($role2->has_attribute($attribute_name) &&
            # make sure we haven't seen this one already too
            $role2->get_attribute($attribute_name) != $role1->get_attribute($attribute_name)) {

            my $role2_name = $role2->name;

            throw_exception( AttributeConflictInRoles => role_name        => $role1->name,
                                                         second_role_name => $role2->name,
                                                         attribute_name   => $attribute_name
                           );
        }
        else {
            $role2->add_attribute(
                $role1->get_attribute($attribute_name)->clone
            );
        }
    }
}

sub apply_methods {
    my ( $self, $role1, $role2 ) = @_;
    foreach my $method ( $role1->_get_local_methods ) {

        my $method_name = $method->name;

        next if $method->isa('Class::MOP::Method::Meta');

        unless ( $self->is_method_excluded($method_name) ) {

            my $role2_method = $role2->get_method($method_name);
            if (   $role2_method
                && $role2_method->body != $method->body ) {

                # method conflicts between roles used to result in the method
                # becoming a requirement but now are permitted just like
                # for classes, hence no code in this branch anymore.
            }
            else {
                $role2->add_method(
                    $method_name,
                    $method,
                );
            }
        }

        next unless $self->is_method_aliased($method_name);

        my $aliased_method_name = $self->get_method_aliases->{$method_name};

        my $role2_method = $role2->get_method($aliased_method_name);

        if (   $role2_method
            && $role2_method->body != $method->body ) {

            throw_exception( CannotCreateMethodAliasLocalMethodIsPresent => aliased_method_name     => $aliased_method_name,
                                                                            method                  => $method,
                                                                            role_name               => $role2->name,
                                                                            role_being_applied_name => $role1->name,
                           );
        }

        $role2->add_method(
            $aliased_method_name,
            $role1->get_method($method_name)
        );

        if ( !$role2->has_method($method_name) ) {
            $role2->add_required_methods($method_name)
                unless $self->is_method_excluded($method_name);
        }
    }
}

sub apply_override_method_modifiers {
    my ($self, $role1, $role2) = @_;
    foreach my $method_name ($role1->get_method_modifier_list('override')) {
        # it if it has one already then ...
        if ($role2->has_method($method_name)) {
            # if it is being composed into another role
            # we have a conflict here, because you cannot
            # combine an overridden method with a locally
            # defined one
            throw_exception( OverrideConflictInComposition => role_name               => $role2->name,
                                                              role_being_applied_name => $role1->name,
                                                              method_name             => $method_name
                           );
        }
        else {
            # if we are a role, we need to make sure
            # we don't have a conflict with the role
            # we are composing into
            if ($role2->has_override_method_modifier($method_name) &&
                $role1->get_override_method_modifier($method_name) != $role2->get_override_method_modifier($method_name)) {

                throw_exception( OverrideConflictInComposition => role_name               => $role2->name,
                                                                  role_being_applied_name => $role1->name,
                                                                  method_name             => $method_name,
                                                                  two_overrides_found     => 1
                               );
            }
            else {
                # if there is no conflict,
                # just add it to the role
                $role2->add_override_method_modifier(
                    $method_name,
                    $role1->get_override_method_modifier($method_name)
                );
            }
        }
    }
}

sub apply_method_modifiers {
    my ($self, $modifier_type, $role1, $role2) = @_;
    my $add = "add_${modifier_type}_method_modifier";
    my $get = "get_${modifier_type}_method_modifiers";
    foreach my $method_name ($role1->get_method_modifier_list($modifier_type)) {
        $role2->$add(
            $method_name,
            $_
        ) foreach $role1->$get($method_name);
    }
}

1;

# ABSTRACT: Compose a role into another role

package Moose::Meta::Role::Application::ToInstance;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use Scalar::Util 'blessed';
use List::Util 1.33 'all';
use Devel::OverloadInfo 0.004 'is_overloaded';

use parent 'Moose::Meta::Role::Application';

__PACKAGE__->meta->add_attribute('rebless_params' => (
    reader  => 'rebless_params',
    default => sub { {} },
    Class::MOP::_definition_context(),
));

use constant _NEED_OVERLOAD_HACK_FOR_OBJECTS => "$]" < 5.008009;

sub apply {
    my ( $self, $role, $object, $args ) = @_;

    my $obj_meta = Class::MOP::class_of($object) || 'Moose::Meta::Class';

    # This is a special case to handle the case where the object's metaclass
    # is a Class::MOP::Class, but _not_ a Moose::Meta::Class (for example,
    # when applying a role to a Moose::Meta::Attribute object).
    $obj_meta = 'Moose::Meta::Class'
        unless $obj_meta->isa('Moose::Meta::Class');

    my $class = $obj_meta->create_anon_class(
        superclasses => [ blessed($object) ],
        roles => [ $role, keys(%$args) ? ($args) : () ],
        cache => (all { $_ eq '-alias' || $_ eq '-excludes' } keys %$args),
    );

    $class->rebless_instance( $object, %{ $self->rebless_params } );

    if ( _NEED_OVERLOAD_HACK_FOR_OBJECTS
        && is_overloaded( ref $object ) ) {

        # need to use $_[2] here to apply to the object in the caller
        _reset_amagic($_[2]);
    }

    return $object;
}

1;

# ABSTRACT: Compose a role into an instance

package Moose::Meta::Role::Application::ToClass;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use List::Util 'first';
use Moose::Util 'throw_exception';
use Scalar::Util 'weaken';

use parent 'Moose::Meta::Role::Application';

__PACKAGE__->meta->add_attribute('role' => (
    reader => 'role',
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('class' => (
    accessor => 'class',
    Class::MOP::_definition_context(),
));

sub apply {
    my ($self, $role, $class) = @_;

    # We need weak_ref in CMOP :(
    weaken($self->{role}  = $role);
    weaken($self->{class} = $class);

    $self->SUPER::apply($role, $class);

    $class->add_role($role);
    $class->add_role_application($self);
}

sub check_role_exclusions {
    my ($self, $role, $class) = @_;
    if ($class->excludes_role($role->name)) {
        throw_exception( ConflictDetectedInCheckRoleExclusionsInToClass => class_name => $class->name,
                                                                           role_name  => $role->name,
                       );
    }
    foreach my $excluded_role_name ($role->get_excluded_roles_list) {
        if ($class->does_role($excluded_role_name)) {
            throw_exception( ClassDoesTheExcludedRole => role_name          => $role->name,
                                                         excluded_role_name => $excluded_role_name,
                                                         class_name         => $class->name,
                           );
        }
    }
}

sub check_required_methods {
    my ($self, $role, $class) = @_;

    my @missing;
    my @is_attr;

    # NOTE:
    # we might need to move this down below the
    # the attributes so that we can require any
    # attribute accessors. However I am thinking
    # that maybe those are somehow exempt from
    # the require methods stuff.
    foreach my $required_method ($role->get_required_method_list) {
        my $required_method_name = $required_method->name;

        if (!$class->find_method_by_name($required_method_name)) {

            next if $self->is_aliased_method($required_method_name);

            push @missing, $required_method;
        }
    }

    return unless @missing;

    my $error = '';

    @missing = sort { $a->name cmp $b->name } @missing;
    my @conflicts = grep { $_->isa('Moose::Meta::Role::Method::Conflicting') } @missing;

    if (@conflicts) {
        my $conflict = $conflicts[0];
        my $roles = $conflict->roles_as_english_list;

        my @same_role_conflicts = grep { $_->roles_as_english_list eq $roles } @conflicts;

        throw_exception( MethodNameConflictInRoles => conflict   => \@same_role_conflicts,
                                                      class_name => $class->name
                       );
    }
    elsif (@missing) {
        if (my $meth = first { $class->name->can($_) } @missing) {
            throw_exception( RequiredMethodsImportedByClass => class_name      => $class->name,
                                                               role_name       => $role->name,
                                                               missing_methods => \@missing,
                                                               imported_method => $meth
                           );
        }
        else {
            throw_exception( RequiredMethodsNotImplementedByClass => class_name      => $class->name,
                                                                     role_name       => $role->name,
                                                                     missing_methods => \@missing,
                           );
        }
    }
}

sub check_required_attributes {

}

sub apply_attributes {
    my ($self, $role, $class) = @_;

    foreach my $attribute_name ($role->get_attribute_list) {
        # it if it has one already
        if ($class->has_attribute($attribute_name) &&
            # make sure we haven't seen this one already too
            $class->get_attribute($attribute_name) != $role->get_attribute($attribute_name)) {
            next;
        }
        else {
            $class->add_attribute(
                $role->get_attribute($attribute_name)->attribute_for_class
            );
        }
    }
}

sub apply_methods {
    my ( $self, $role, $class ) = @_;

    foreach my $method ( $role->_get_local_methods ) {
        my $method_name = $method->name;

        next if $method->isa('Class::MOP::Method::Meta');

        unless ( $self->is_method_excluded($method_name) ) {

            my $class_method = $class->get_method($method_name);

            next if $class_method && $class_method->body != $method->body;

            $class->add_method(
                $method_name,
                $method,
            );
        }

        next unless $self->is_method_aliased($method_name);

        my $aliased_method_name = $self->get_method_aliases->{$method_name};

        my $class_method = $class->get_method($aliased_method_name);

        if ( $class_method && $class_method->body != $method->body ) {
            throw_exception( CannotCreateMethodAliasLocalMethodIsPresentInClass => aliased_method_name => $aliased_method_name,
                                                                                   method              => $method,
                                                                                   role_name           => $role->name,
                                                                                   class_name          => $class->name,
                           );
        }

        $class->add_method(
            $aliased_method_name,
            $method,
        );
    }

    # we must reset the cache here since
    # we are just aliasing methods, otherwise
    # the modifiers go wonky.
    $class->reset_package_cache_flag;
}

sub apply_override_method_modifiers {
    my ($self, $role, $class) = @_;
    foreach my $method_name ($role->get_method_modifier_list('override')) {
        # it if it has one already then ...
        if ($class->has_method($method_name)) {
            next;
        }
        else {
            # if this is not a role, then we need to
            # find the original package of the method
            # so that we can tell the class were to
            # find the right super() method
            my $method = $role->get_override_method_modifier($method_name);
            my ($package) = Class::MOP::get_code_info($method);
            # if it is a class, we just add it
            $class->add_override_method_modifier($method_name, $method, $package);
        }
    }
}

sub apply_method_modifiers {
    my ($self, $modifier_type, $role, $class) = @_;
    my $add = "add_${modifier_type}_method_modifier";
    my $get = "get_${modifier_type}_method_modifiers";
    foreach my $method_name ($role->get_method_modifier_list($modifier_type)) {
        $class->$add(
            $method_name,
            $_
        ) foreach $role->$get($method_name);
    }
}

1;

# ABSTRACT: Compose a role into a class

package Moose::Meta::Role::Application::RoleSummation;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use List::Util 1.33 qw( all );
use Scalar::Util 'blessed';

use Moose::Meta::Role::Composite;

use parent 'Moose::Meta::Role::Application';

use Moose::Util 'throw_exception';

__PACKAGE__->meta->add_attribute('role_params' => (
    reader  => 'role_params',
    default => sub { {} },
    Class::MOP::_definition_context(),
));

sub get_exclusions_for_role {
    my ($self, $role) = @_;
    $role = $role->name if blessed $role;
    my $excludes_key = exists $self->role_params->{$role}->{'-excludes'} ?
                           '-excludes' : 'excludes';
    if ($self->role_params->{$role} && defined $self->role_params->{$role}->{$excludes_key}) {
        if (ref $self->role_params->{$role}->{$excludes_key} eq 'ARRAY') {
            return $self->role_params->{$role}->{$excludes_key};
        }
        return [ $self->role_params->{$role}->{$excludes_key} ];
    }
    return [];
}

sub get_method_aliases_for_role {
    my ($self, $role) = @_;
    $role = $role->name if blessed $role;
    my $alias_key = exists $self->role_params->{$role}->{'-alias'} ?
                        '-alias' : 'alias';
    if ($self->role_params->{$role} && defined $self->role_params->{$role}->{$alias_key}) {
        return $self->role_params->{$role}->{$alias_key};
    }
    return {};
}

sub is_method_excluded {
    my ($self, $role, $method_name) = @_;
    foreach ($self->get_exclusions_for_role($role->name)) {
        return 1 if $_ eq $method_name;
    }
    return 0;
}

sub is_method_aliased {
    my ($self, $role, $method_name) = @_;
    exists $self->get_method_aliases_for_role($role->name)->{$method_name} ? 1 : 0
}

sub is_aliased_method {
    my ($self, $role, $method_name) = @_;
    my %aliased_names = reverse %{$self->get_method_aliases_for_role($role->name)};
    exists $aliased_names{$method_name} ? 1 : 0;
}

sub check_role_exclusions {
    my ($self, $c) = @_;

    my %excluded_roles;
    for my $role (@{ $c->get_roles }) {
        my $name = $role->name;

        for my $excluded ($role->get_excluded_roles_list) {
            push @{ $excluded_roles{$excluded} }, $name;
        }
    }

    foreach my $role (@{$c->get_roles}) {
        foreach my $excluded (keys %excluded_roles) {
            next unless $role->does_role($excluded);

            my @excluding = @{ $excluded_roles{$excluded} };

            throw_exception( RoleExclusionConflict => roles     => \@excluding,
                                                      role_name => $excluded
                           );
        }
    }

    $c->add_excluded_roles(keys %excluded_roles);
}

sub check_required_methods {
    my ($self, $c) = @_;

    my %all_required_methods =
        map { $_->name => $_ }
        map { $_->get_required_method_list }
        @{$c->get_roles};

    foreach my $role (@{$c->get_roles}) {
        foreach my $required (keys %all_required_methods) {

            delete $all_required_methods{$required}
                if $role->has_method($required)
                || $self->is_aliased_method($role, $required);
        }
    }

    $c->add_required_methods(values %all_required_methods);
}

sub check_required_attributes {

}

sub apply_attributes {
    my ($self, $c) = @_;

    my @all_attributes;

    for my $role ( @{ $c->get_roles } ) {
        push @all_attributes,
            map { $role->get_attribute($_) } $role->get_attribute_list;
    }

    my %seen;
    foreach my $attr (@all_attributes) {
        my $name = $attr->name;

        if ( exists $seen{$name} ) {
            next if $seen{$name}->is_same_as($attr);

            my $role1 = $seen{$name}->associated_role->name;
            my $role2 = $attr->associated_role->name;

            throw_exception( AttributeConflictInSummation => attribute_name   => $name,
                                                             role_name        => $role1,
                                                             second_role_name => $role2,
                           );
        }

        $seen{$name} = $attr;
    }

    foreach my $attr (@all_attributes) {
        $c->add_attribute( $attr->clone );
    }
}

sub apply_methods {
    my ($self, $c) = @_;

    my @all_methods = map {
        my $role     = $_;
        my $aliases  = $self->get_method_aliases_for_role($role);
        my %excludes = map { $_ => undef } @{ $self->get_exclusions_for_role($role) };
        (
            (map {
                exists $excludes{$_} ? () :
                +{
                    role   => $role,
                    name   => $_,
                    method => $role->get_method($_),
                }
            } map { $_->name }
              grep { !$_->isa('Class::MOP::Method::Meta') }
                   $role->_get_local_methods),
            (map {
                +{
                    role   => $role,
                    name   => $aliases->{$_},
                    method => $role->get_method($_),
                }
            } keys %$aliases)
        );
    } @{$c->get_roles};

    my (%seen, %conflicts, %method_map);
    foreach my $method (@all_methods) {
        next if $conflicts{$method->{name}};
        my $seen = $seen{$method->{name}};

        if ($seen) {
            if ($seen->{method}->body != $method->{method}->body) {
                $c->add_conflicting_method(
                    name  => $method->{name},
                    roles => [$method->{role}->name, $seen->{role}->name],
                );

                delete $method_map{$method->{name}};
                $conflicts{$method->{name}} = 1;
                next;
            }
        }

        $seen{$method->{name}}       = $method;
        $method_map{$method->{name}} = $method->{method};
    }

    $c->add_method($_ => $method_map{$_}) for keys %method_map;
}

sub apply_override_method_modifiers {
    my ($self, $c) = @_;

    my @all_overrides = map {
        my $role = $_;
        map {
            +{
                name   => $_,
                method => $role->get_override_method_modifier($_),
            }
        } $role->get_method_modifier_list('override');
    } @{$c->get_roles};

    my %seen;
    foreach my $override (@all_overrides) {
        my @role_names = map { $_->name } @{$c->get_roles};
        if ( $c->has_method($override->{name}) ){
            throw_exception( OverrideConflictInSummation => role_names       => \@role_names,
                                                            role_application => $self,
                                                            method_name      => $override->{name}
                           );
        }
        if (exists $seen{$override->{name}}) {
            if ( $seen{$override->{name}} != $override->{method} ) {
                throw_exception( OverrideConflictInSummation => role_names          => \@role_names,
                                                                role_application    => $self,
                                                                method_name         => $override->{name},
                                                                two_overrides_found => 1
                               );
            }
        }
        $seen{$override->{name}} = $override->{method};
    }

    $c->add_override_method_modifier(
        $_->{name}, $_->{method}
    ) for @all_overrides;

}

sub apply_method_modifiers {
    my ($self, $modifier_type, $c) = @_;
    my $add = "add_${modifier_type}_method_modifier";
    my $get = "get_${modifier_type}_method_modifiers";
    foreach my $role (@{$c->get_roles}) {
        foreach my $method_name ($role->get_method_modifier_list($modifier_type)) {
            $c->$add(
                $method_name,
                $_
            ) foreach $role->$get($method_name);
        }
    }
}

sub apply_overloading {
    my ( $self, $c ) = @_;

    my @overloaded_roles = grep { $_->is_overloaded } @{ $c->get_roles };
    return unless @overloaded_roles;

    my %fallback;
    for my $role (@overloaded_roles) {
        $fallback{ $role->name } = $role->get_overload_fallback_value;
    }

    for my $role_name ( keys %fallback ) {
        for my $other_role_name ( grep { $_ ne $role_name } keys %fallback ) {
            my @fb_values = @fallback{ $role_name, $other_role_name };
            if ( all {defined} @fb_values ) {
                next if $fallback{$role_name} eq $fallback{$other_role_name};
                throw_exception(
                    'OverloadConflictInSummation',
                    role_names       => [ $role_name, $other_role_name ],
                    role_application => $self,
                    overloaded_op    => 'fallback',
                );
            }

            next if all { !defined } @fb_values;
            throw_exception(
                'OverloadConflictInSummation',
                role_names       => [ $role_name, $other_role_name ],
                role_application => $self,
                overloaded_op    => 'fallback',
            );
        }
    }

    if ( keys %fallback ) {
        $c->set_overload_fallback_value( ( values %fallback )[0] );
    }

    my %overload_map;
    for my $role (@overloaded_roles) {
        for my $overload ( $role->get_all_overloaded_operators ) {
            $overload_map{ $overload->operator }{ $role->name } = $overload;
        }
    }

    for my $op_name ( keys %overload_map ) {
        my @roles = keys %{ $overload_map{$op_name} };
        my $overload = $overload_map{$op_name}{ $roles[0] };

        if ( @roles > 1 && !all { $overload->_is_equal_to($_) }
            values %{ $overload_map{$op_name} } ) {

            throw_exception(
                'OverloadConflictInSummation',
                role_names       => [ @roles[ 0, 1 ] ],
                role_application => $self,
                overloaded_op    => $op_name,
            );
        }

        $c->add_overloaded_operator(
            $op_name => $overload_map{$op_name}{ $roles[0] } );
    }
}

1;

# ABSTRACT: Combine two or more roles

package Moose::Meta::Role::Attribute;
our $VERSION = '2.2204';

use strict;
use warnings;

use List::Util 1.33 'all';
use Scalar::Util 'blessed', 'weaken';

use parent 'Moose::Meta::Mixin::AttributeCore', 'Class::MOP::Object';

use Moose::Util 'throw_exception';

__PACKAGE__->meta->add_attribute(
    'metaclass' => (
        reader => 'metaclass',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'associated_role' => (
        reader => 'associated_role',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    '_original_role' => (
        reader => '_original_role',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'is' => (
        reader => 'is',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'original_options' => (
        reader => 'original_options',
        Class::MOP::_definition_context(),
    )
);

sub new {
    my ( $class, $name, %options ) = @_;

    (defined $name)
        || throw_exception( MustProvideANameForTheAttribute => params => \%options,
                                                               class  => $class
                          );

    my $role = delete $options{_original_role};

    return bless {
        name             => $name,
        original_options => \%options,
        _original_role   => $role,
        %options,
    }, $class;
}

sub attach_to_role {
    my ( $self, $role ) = @_;

    ( blessed($role) && $role->isa('Moose::Meta::Role') )
        || throw_exception( MustPassAMooseMetaRoleInstanceOrSubclass => class  => $self,
                                                                        role   => $role
                          );

    weaken( $self->{'associated_role'} = $role );
}

sub original_role {
    my $self = shift;

    return $self->_original_role || $self->associated_role;
}

sub attribute_for_class {
    my $self = shift;

    my $metaclass = $self->original_role->applied_attribute_metaclass;

    return $metaclass->interpolate_class_and_new(
        $self->name    => %{ $self->original_options },
        role_attribute => $self,
    );
}

sub clone {
    my $self = shift;

    my $role = $self->original_role;

    return ( ref $self )->new(
        $self->name,
        %{ $self->original_options },
        _original_role => $role,
    );
}

sub is_same_as {
    my $self = shift;
    my $attr = shift;

    my $self_options = $self->original_options;
    my $other_options = $attr->original_options;

    return 0
        unless ( join q{|}, sort keys %{$self_options} ) eq ( join q{|}, sort keys %{$other_options} );

    for my $key ( keys %{$self_options} ) {
        return 0 if defined $self_options->{$key} && ! defined $other_options->{$key};
        return 0 if ! defined $self_options->{$key} && defined $other_options->{$key};

        next if all { ! defined } $self_options->{$key}, $other_options->{$key};

        return 0 unless $self_options->{$key} eq $other_options->{$key};
    }

    return 1;
}

1;

# ABSTRACT: The Moose attribute metaclass for Roles

package Moose::Meta::Instance;
our $VERSION = '2.2204';

use strict;
use warnings;

use Class::MOP::MiniTrait;

use parent 'Class::MOP::Instance';

Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');

1;

# ABSTRACT: The Moose Instance metaclass

package Moose::Meta::TypeCoercion::Union;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use Scalar::Util 'blessed';

use parent 'Moose::Meta::TypeCoercion';

use Moose::Util 'throw_exception';

sub compile_type_coercion {
    my $self            = shift;
    my $type_constraint = $self->type_constraint;

    (blessed $type_constraint && $type_constraint->isa('Moose::Meta::TypeConstraint::Union'))
     || throw_exception( NeedsTypeConstraintUnionForTypeCoercionUnion => type_coercion_union_object => $self,
                                                                         type_name                  => $type_constraint->name
                       );

    $self->_compiled_type_coercion(
        sub {
            my $value = shift;

            foreach my $type ( grep { $_->has_coercion }
                @{ $type_constraint->type_constraints } ) {
                my $temp = $type->coerce($value);
                return $temp if $type_constraint->check($temp);
            }

            return $value;
        }
    );
}

sub has_coercion_for_type { 0 }

sub add_type_coercions {
    my $self = shift;
    throw_exception( CannotAddAdditionalTypeCoercionsToUnion => type_coercion_union_object => $self );
}

1;

# ABSTRACT: The Moose Type Coercion metaclass for Unions

package Moose::Meta::Attribute::Native::Trait::Hash;
our $VERSION = '2.2204';

use Moose::Role;
with 'Moose::Meta::Attribute::Native::Trait';

sub _helper_type { 'HashRef' }

no Moose::Role;

1;

# ABSTRACT: Helper trait for HashRef attributes

package Moose::Meta::Attribute::Native::Trait::Counter;
our $VERSION = '2.2204';

use Moose::Role;
with 'Moose::Meta::Attribute::Native::Trait';

sub _helper_type { 'Num' }
sub _root_types { 'Num', 'Int' }

no Moose::Role;

1;

# ABSTRACT: Helper trait for Int attributes which represent counters

package Moose::Meta::Attribute::Native::Trait::Code;
our $VERSION = '2.2204';

use Moose::Role;
with 'Moose::Meta::Attribute::Native::Trait';

sub _helper_type { 'CodeRef' }

no Moose::Role;

1;

# ABSTRACT: Helper trait for CodeRef attributes

package Moose::Meta::Attribute::Native::Trait::Number;
our $VERSION = '2.2204';

use Moose::Role;
with 'Moose::Meta::Attribute::Native::Trait';

sub _helper_type { 'Num' }

no Moose::Role;

1;

# ABSTRACT: Helper trait for Num attributes

package Moose::Meta::Attribute::Native::Trait::Bool;
our $VERSION = '2.2204';

use Moose::Role;
with 'Moose::Meta::Attribute::Native::Trait';

sub _helper_type { 'Bool' }

no Moose::Role;

1;

# ABSTRACT: Helper trait for Bool attributes

package Moose::Meta::Attribute::Native::Trait::String;
our $VERSION = '2.2204';

use Moose::Role;
with 'Moose::Meta::Attribute::Native::Trait';

sub _helper_type { 'Str' }

no Moose::Role;

1;

# ABSTRACT: Helper trait for Str attributes

package Moose::Meta::Attribute::Native::Trait::Array;
our $VERSION = '2.2204';

use Moose::Role;
with 'Moose::Meta::Attribute::Native::Trait';

sub _helper_type { 'ArrayRef' }

no Moose::Role;

1;

# ABSTRACT: Helper trait for ArrayRef attributes

package Moose::Meta::Attribute::Native::Trait;
our $VERSION = '2.2204';

use Moose::Role;
use Module::Runtime 'require_module';
use Moose::Deprecated;
use Moose::Util 'throw_exception';
use Moose::Util::TypeConstraints;

requires '_helper_type';

before '_process_options' => sub {
    my ( $self, $name, $options ) = @_;

    $self->_check_helper_type( $options, $name );
};

sub _check_helper_type {
    my ( $self, $options, $name ) = @_;

    my $type = $self->_helper_type;

    $options->{isa} = $type
        unless exists $options->{isa};

    my $isa;
    my $isa_name;

    if (   blessed( $options->{isa} )
        && $options->{isa}->can('does')
        && $options->{isa}->does('Specio::Constraint::Role::Interface') ) {

        $isa = $options->{isa};
        require Specio::Library::Builtins;
        return if $isa->is_a_type_of( Specio::Library::Builtins::t($type) );
        $isa_name = $isa->name() || $isa->description();
    }
    else {
        $isa = Moose::Util::TypeConstraints::find_or_create_type_constraint(
            $options->{isa} );
        return if $isa->is_a_type_of($type);
        $isa_name = $isa->name();
    }

    throw_exception( WrongTypeConstraintGiven => required_type  => $type,
                                                 given_type     => $isa_name,
                                                 attribute_name => $name,
                                                 params         => $options
                   );
}

before 'install_accessors' => sub { (shift)->_check_handles_values };

sub _check_handles_values {
    my $self = shift;

    my %handles = $self->_canonicalize_handles;

    for my $original_method ( values %handles ) {
        my $name = $original_method->[0];

        my $accessor_class = $self->_native_accessor_class_for($name);

        ( $accessor_class && $accessor_class->can('new') )
            || confess
            "$name is an unsupported method type - $accessor_class";
    }
}

around '_canonicalize_handles' => sub {
    shift;
    my $self    = shift;
    my $handles = $self->handles;

    return unless $handles;

    unless ( 'HASH' eq ref $handles ) {
       throw_exception( HandlesMustBeAHashRef => instance      => $self,
                                                 given_handles => $handles
                      );
    }

    return
        map { $_ => $self->_canonicalize_handles_value( $handles->{$_} ) }
        keys %$handles;
};

sub _canonicalize_handles_value {
    my $self  = shift;
    my $value = shift;

    if ( ref $value && 'ARRAY' ne ref $value ) {
        throw_exception( InvalidHandleValue => instance     => $self,
                                               handle_value => $value
                       );
    }

    return ref $value ? $value : [$value];
}

around '_make_delegation_method' => sub {
    my $next = shift;
    my ( $self, $handle_name, $method_to_call ) = @_;

    my ( $name, @curried_args ) = @$method_to_call;

    my $accessor_class = $self->_native_accessor_class_for($name);

    die "Cannot find an accessor class for $name"
        unless $accessor_class && $accessor_class->can('new');

    return $accessor_class->new(
        name               => $handle_name,
        package_name       => $self->associated_class->name,
        delegate_to_method => $name,
        attribute          => $self,
        is_inline          => 1,
        curried_arguments  => \@curried_args,
        root_types         => [ $self->_root_types ],
    );
};

sub _root_types {
    return $_[0]->_helper_type;
}

sub _native_accessor_class_for {
    my ( $self, $suffix ) = @_;

    my $role
        = 'Moose::Meta::Method::Accessor::Native::'
        . $self->_native_type . '::'
        . $suffix;

    require_module($role);
    return Moose::Meta::Class->create_anon_class(
        superclasses =>
            [ $self->accessor_metaclass, $self->delegation_metaclass ],
        roles => [$role],
        cache => 1,
    )->name;
}

sub _build_native_type {
    my $self = shift;

    for my $role_name ( map { $_->name } $self->meta->calculate_all_roles ) {
        return $1 if $role_name =~ /::Native::Trait::(\w+)$/;
    }

    throw_exception( CannotCalculateNativeType => instance => $self );
}

has '_native_type' => (
    is      => 'ro',
    isa     => 'Str',
    lazy    => 1,
    builder => '_build_native_type',
);

no Moose::Role;
no Moose::Util::TypeConstraints;

1;

# ABSTRACT: Shared role for native delegation traits

use strict;
use warnings;
package Moose::Meta::Attribute::Native;
our $VERSION = '2.2204';

use Module::Runtime 'require_module';

my @trait_names = qw(Bool Counter Number String Array Hash Code);

for my $trait_name (@trait_names) {
    my $trait_class = "Moose::Meta::Attribute::Native::Trait::$trait_name";
    my $meta = Class::MOP::Class->initialize(
        "Moose::Meta::Attribute::Custom::Trait::$trait_name"
    );

    if ($meta->find_method_by_name('register_implementation')) {
        my $class = $meta->name->register_implementation;
        die "An implementation for $trait_name already exists " .
            "(found '$class' when trying to register '$trait_class')"
    }
    $meta->add_method(register_implementation => sub {
        # resolve_metatrait_alias will load classes anyway, but throws away
        # their error message; we WANT to die if there's a problem
        require_module($trait_class);
        return $trait_class;
    });
}

1;

# ABSTRACT: Delegate to native Perl types

package Moose::Meta::Mixin::AttributeCore;
our $VERSION = '2.2204';

use strict;
use warnings;

use parent 'Class::MOP::Mixin::AttributeCore';

__PACKAGE__->meta->add_attribute(
    'isa' => (
        reader => '_isa_metadata',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'does' => (
        reader => '_does_metadata',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'is' => (
        reader => '_is_metadata',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'required' => (
        reader => 'is_required',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'lazy' => (
        reader => 'is_lazy',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'lazy_build' => (
        reader => 'is_lazy_build',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'coerce' => (
        reader => 'should_coerce',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'weak_ref' => (
        reader => 'is_weak_ref',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'auto_deref' => (
        reader => 'should_auto_deref',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'type_constraint' => (
        reader    => 'type_constraint',
        predicate => 'has_type_constraint',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'trigger' => (
        reader    => 'trigger',
        predicate => 'has_trigger',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'handles' => (
        reader    => 'handles',
        writer    => '_set_handles',
        predicate => 'has_handles',
        Class::MOP::_definition_context(),
    )
);

__PACKAGE__->meta->add_attribute(
    'documentation' => (
        reader    => 'documentation',
        predicate => 'has_documentation',
        Class::MOP::_definition_context(),
    )
);

1;

# ABSTRACT: Core attributes shared by attribute metaclasses

package Moose::Meta::Class;
our $VERSION = '2.2204';

use strict;
use warnings;

use Class::MOP;
use Data::OptList;
use List::Util 1.33 qw( any );
use Scalar::Util 'blessed';

use Moose::Meta::Method::Overridden;
use Moose::Meta::Method::Augmented;
use Moose::Meta::Class::Immutable::Trait;
use Moose::Meta::Method::Constructor;
use Moose::Meta::Method::Destructor;
use Moose::Meta::Method::Meta;
use Moose::Util 'throw_exception';
use Class::MOP::MiniTrait;

use parent 'Class::MOP::Class';

Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');

__PACKAGE__->meta->add_attribute('roles' => (
    reader  => 'roles',
    default => sub { [] },
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('role_applications' => (
    reader  => '_get_role_applications',
    default => sub { [] },
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute(
    Class::MOP::Attribute->new('immutable_trait' => (
        accessor => "immutable_trait",
        default  => 'Moose::Meta::Class::Immutable::Trait',
        Class::MOP::_definition_context(),
    ))
);

__PACKAGE__->meta->add_attribute('constructor_class' => (
    accessor => 'constructor_class',
    default  => 'Moose::Meta::Method::Constructor',
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('destructor_class' => (
    accessor => 'destructor_class',
    default  => 'Moose::Meta::Method::Destructor',
    Class::MOP::_definition_context(),
));

sub initialize {
    my $class = shift;
    my @args = @_;
    unshift @args, 'package' if @args % 2;
    my %opts = @args;
    my $package = delete $opts{package};
    return Class::MOP::get_metaclass_by_name($package)
        || $class->SUPER::initialize($package,
                'attribute_metaclass' => 'Moose::Meta::Attribute',
                'method_metaclass'    => 'Moose::Meta::Method',
                'instance_metaclass'  => 'Moose::Meta::Instance',
                %opts,
            );
}

sub create {
    my $class = shift;
    my @args = @_;

    unshift @args, 'package' if @args % 2 == 1;
    my %options = @args;

    (ref $options{roles} eq 'ARRAY')
        || throw_exception( RolesInCreateTakesAnArrayRef => params => \%options )
            if exists $options{roles};

    my $package = delete $options{package};
    my $roles   = delete $options{roles};

    my $new_meta = $class->SUPER::create($package, %options);

    if ($roles) {
        Moose::Util::apply_all_roles( $new_meta, @$roles );
    }

    return $new_meta;
}

sub _meta_method_class { 'Moose::Meta::Method::Meta' }

sub _anon_package_prefix { 'Moose::Meta::Class::__ANON__::SERIAL::' }

sub _anon_cache_key {
    my $class = shift;
    my %options = @_;

    my $superclass_key = join('|',
        map { $_->[0] } @{ Data::OptList::mkopt($options{superclasses} || []) }
    );

    my $roles = Data::OptList::mkopt(($options{roles} || []), {
        moniker  => 'role',
        name_test => sub {
            ! ref $_[0] or blessed($_[0]) && $_[0]->isa('Moose::Meta::Role')
        },
    });

    my @role_keys;
    for my $role_spec (@$roles) {
        my ($role, $params) = @$role_spec;
        $params = { %$params } if $params;

        my $key = blessed($role) ? $role->name : $role;

        if ($params && %$params) {
            my $alias    = delete $params->{'-alias'}
                        || delete $params->{'alias'}
                        || {};
            my $excludes = delete $params->{'-excludes'}
                        || delete $params->{'excludes'}
                        || [];
            $excludes = [$excludes] unless ref($excludes) eq 'ARRAY';

            if (%$params) {
                warn "Roles with parameters cannot be cached. Consider "
                   . "applying the parameters before calling "
                   . "create_anon_class, or using 'weaken => 0' instead";
                return;
            }

            my $alias_key = join('%',
                map { $_ => $alias->{$_} } sort keys %$alias
            );
            my $excludes_key = join('%',
                sort @$excludes
            );
            $key .= '<' . join('+', 'a', $alias_key, 'e', $excludes_key) . '>';
        }

        push @role_keys, $key;
    }

    my $role_key = join('|', sort @role_keys);

    # Makes something like Super::Class|Super::Class::2=Role|Role::1
    return join('=', $superclass_key, $role_key);
}

sub reinitialize {
    my $self = shift;
    my $pkg  = shift;

    my $meta = blessed $pkg ? $pkg : Class::MOP::class_of($pkg);

    my %existing_classes;
    if ($meta) {
        %existing_classes = map { $_ => $meta->$_() } qw(
            attribute_metaclass
            method_metaclass
            wrapped_method_metaclass
            instance_metaclass
            constructor_class
            destructor_class
        );
    }

    return $self->SUPER::reinitialize(
        $pkg,
        %existing_classes,
        @_,
    );
}

sub add_role {
    my ($self, $role) = @_;
    (blessed($role) && $role->isa('Moose::Meta::Role'))
        || throw_exception( AddRoleTakesAMooseMetaRoleInstance => role_to_be_added => $role,
                                                                  class_name       => $self->name,
                          );
    push @{$self->roles} => $role;
}

sub role_applications {
    my ($self) = @_;

    return @{$self->_get_role_applications};
}

sub add_role_application {
    my ($self, $application) = @_;

    (blessed($application) && $application->isa('Moose::Meta::Role::Application::ToClass'))
        || throw_exception( InvalidRoleApplication => class_name  => $self->name,
                                                      application => $application,
                          );

    push @{$self->_get_role_applications} => $application;
}

sub calculate_all_roles {
    my $self = shift;
    my %seen;
    grep { !$seen{$_->name}++ } map { $_->calculate_all_roles } @{ $self->roles };
}

sub _roles_with_inheritance {
    my $self = shift;
    my %seen;
    grep { !$seen{$_->name}++ }
         map { Class::MOP::class_of($_)->can('roles')
                   ? @{ Class::MOP::class_of($_)->roles }
                   : () }
             $self->linearized_isa;
}

sub calculate_all_roles_with_inheritance {
    my $self = shift;
    my %seen;
    grep { !$seen{$_->name}++ }
         map { Class::MOP::class_of($_)->can('calculate_all_roles')
                   ? Class::MOP::class_of($_)->calculate_all_roles
                   : () }
             $self->linearized_isa;
}

sub does_role {
    my ($self, $role_name) = @_;

    (defined $role_name)
        || throw_exception( RoleNameRequired => class_name => $self->name );

    foreach my $class ($self->class_precedence_list) {
        my $meta = Class::MOP::class_of($class);
        # when a Moose metaclass is itself extended with a role,
        # this check needs to be done since some items in the
        # class_precedence_list might in fact be Class::MOP
        # based still.
        next unless $meta && $meta->can('roles');
        foreach my $role (@{$meta->roles}) {
            return 1 if $role->does_role($role_name);
        }
    }
    return 0;
}

sub excludes_role {
    my ($self, $role_name) = @_;

    (defined $role_name)
        || throw_exception( RoleNameRequired => class_name => $self->name );

    foreach my $class ($self->class_precedence_list) {
        my $meta = Class::MOP::class_of($class);
        # when a Moose metaclass is itself extended with a role,
        # this check needs to be done since some items in the
        # class_precedence_list might in fact be Class::MOP
        # based still.
        next unless $meta && $meta->can('roles');
        foreach my $role (@{$meta->roles}) {
            return 1 if $role->excludes_role($role_name);
        }
    }
    return 0;
}

sub new_object {
    my $self   = shift;
    my $params = @_ == 1 ? $_[0] : {@_};
    my $object = $self->SUPER::new_object($params);

    $self->_call_all_triggers($object, $params);

    $object->BUILDALL($params) if $object->can('BUILDALL');

    return $object;
}

sub _call_all_triggers {
    my ($self, $object, $params) = @_;

    foreach my $attr ( $self->get_all_attributes() ) {

        next unless $attr->can('has_trigger') && $attr->has_trigger;

        my $init_arg = $attr->init_arg;
        next unless defined $init_arg;
        next unless exists $params->{$init_arg};

        $attr->trigger->(
            $object,
            (
                  $attr->should_coerce
                ? $attr->get_read_method_ref->($object)
                : $params->{$init_arg}
            ),
        );
    }
}

sub _generate_fallback_constructor {
    my $self = shift;
    my ($class) = @_;
    return $class . '->Moose::Object::new(@_)'
}

sub _inline_params {
    my $self = shift;
    my ($params, $class) = @_;
    return (
        'my ' . $params . ' = ',
        $self->_inline_BUILDARGS($class, '@_'),
        ';',
    );
}

sub _inline_BUILDARGS {
    my $self = shift;
    my ($class, $args) = @_;

    my $buildargs = $self->find_method_by_name("BUILDARGS");

    if ($args eq '@_'
     && (!$buildargs or $buildargs->body == \&Moose::Object::BUILDARGS)) {
        return (
            'do {',
                'my $params;',
                'if (scalar @_ == 1) {',
                    'if (!defined($_[0]) || ref($_[0]) ne \'HASH\') {',
                        $self->_inline_throw_exception(
                            'SingleParamsToNewMustBeHashRef'
                        ) . ';',
                    '}',
                    '$params = { %{ $_[0] } };',
                '}',
                'elsif (@_ % 2) {',
                    'Carp::carp(',
                        '"The new() method for ' . $class . ' expects a '
                      . 'hash reference or a key/value list. You passed an '
                      . 'odd number of arguments"',
                    ');',
                    '$params = {@_, undef};',
                '}',
                'else {',
                    '$params = {@_};',
                '}',
                '$params;',
            '}',
        );
    }
    else {
        return $class . '->BUILDARGS(' . $args . ')';
    }
}

sub _inline_slot_initializer {
    my $self  = shift;
    my ($attr, $idx) = @_;

    return (
        '## ' . $attr->name,
        $self->_inline_check_required_attr($attr),
        $self->SUPER::_inline_slot_initializer(@_),
    );
}

sub _inline_check_required_attr {
    my $self = shift;
    my ($attr) = @_;

    return unless defined $attr->init_arg;
    return unless $attr->can('is_required') && $attr->is_required;
    return if $attr->has_default || $attr->has_builder;

    my $throw = $self->_inline_throw_exception(
        'AttributeIsRequired',
        sprintf(
            <<'EOF', quotemeta( $attr->name ), quotemeta( $attr->init_arg ) ), );
params             => $params,
class_name         => $class_name,
attribute_name     => "%s",
attribute_init_arg => "%s",
EOF

    return sprintf( <<'EOF', quotemeta( $attr->init_arg ), $throw )
if ( !exists $params->{"%s"} ) {
    %s;
}
EOF
}

# XXX: these two are duplicated from cmop, because we have to pass the tc stuff
# through to _inline_set_value - this should probably be fixed, but i'm not
# quite sure how. -doy
sub _inline_init_attr_from_constructor {
    my $self = shift;
    my ($attr, $idx) = @_;

    my @initial_value = $attr->_inline_set_value(
        '$instance',
        '$params->{\'' . $attr->init_arg . '\'}',
        '$type_constraint_bodies[' . $idx . ']',
        '$type_coercions[' . $idx . ']',
        '$type_constraint_messages[' . $idx . ']',
        'for constructor',
    );

    push @initial_value, (
        '$attrs->[' . $idx . ']->set_initial_value(',
            '$instance,',
            $attr->_inline_instance_get('$instance'),
        ');',
    ) if $attr->has_initializer;

    return @initial_value;
}

sub _inline_init_attr_from_default {
    my $self = shift;
    my ($attr, $idx) = @_;

    return if $attr->can('is_lazy') && $attr->is_lazy;
    my $default = $self->_inline_default_value($attr, $idx);
    return unless $default;

    my @initial_value = (
        'my $default = ' . $default . ';',
        $attr->_inline_set_value(
            '$instance',
            '$default',
            '$type_constraint_bodies[' . $idx . ']',
            '$type_coercions[' . $idx . ']',
            '$type_constraint_messages[' . $idx . ']',
            'for constructor',
        ),
    );

    push @initial_value, (
        '$attrs->[' . $idx . ']->set_initial_value(',
            '$instance,',
            $attr->_inline_instance_get('$instance'),
        ');',
    ) if $attr->has_initializer;

    return @initial_value;
}

sub _inline_extra_init {
    my $self = shift;
    return (
        $self->_inline_triggers,
        $self->_inline_BUILDALL,
    );
}

sub _inline_triggers {
    my $self = shift;
    my @trigger_calls;

    my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
    for my $i (0 .. $#attrs) {
        my $attr = $attrs[$i];

        next unless $attr->can('has_trigger') && $attr->has_trigger;

        my $init_arg = $attr->init_arg;
        next unless defined $init_arg;

        push @trigger_calls,
            'if (exists $params->{\'' . $init_arg . '\'}) {',
                '$triggers->[' . $i . ']->(',
                    '$instance,',
                    $attr->_inline_instance_get('$instance') . ',',
                ');',
            '}';
    }

    return @trigger_calls;
}

sub _inline_BUILDALL {
    my $self = shift;

    my @methods = reverse $self->find_all_methods_by_name('BUILD');
    return () unless @methods;

    my @BUILD_calls;

    foreach my $method (@methods) {
        push @BUILD_calls,
            '$instance->' . $method->{class} . '::BUILD($params);';
    }

    return (
        'if (!$params->{__no_BUILD__}) {',
        @BUILD_calls,
        '}',
    );
}

sub _eval_environment {
    my $self = shift;

    my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;

    my $triggers = [
        map { $_->can('has_trigger') && $_->has_trigger ? $_->trigger : undef }
            @attrs
    ];

    # We need to check if the attribute ->can('type_constraint')
    # since we may be trying to immutabilize a Moose meta class,
    # which in turn has attributes which are Class::MOP::Attribute
    # objects, rather than Moose::Meta::Attribute. And
    # Class::MOP::Attribute attributes have no type constraints.
    # However we need to make sure we leave an undef value there
    # because the inlined code is using the index of the attributes
    # to determine where to find the type constraint

    my @type_constraints = map {
        $_->can('type_constraint') ? $_->type_constraint : undef
    } @attrs;

    my @type_constraint_bodies = map {
        defined $_ ? $_->_compiled_type_constraint : undef;
    } @type_constraints;

    my @type_coercions = map {
        defined $_ && $_->has_coercion
            ? $_->coercion->_compiled_type_coercion
            : undef
    } @type_constraints;

    my @type_constraint_messages = map {
        defined $_
            ? ($_->has_message ? $_->message : $_->_default_message)
            : undef
    } @type_constraints;

    return {
        %{ $self->SUPER::_eval_environment },
        ((any { defined && $_->has_initializer } @attrs)
            ? ('$attrs' => \[@attrs])
            : ()),
        '$triggers' => \$triggers,
        '@type_coercions' => \@type_coercions,
        '@type_constraint_bodies' => \@type_constraint_bodies,
        '@type_constraint_messages' => \@type_constraint_messages,
        ( map { defined($_) ? %{ $_->inline_environment } : () }
              @type_constraints ),
        # pretty sure this is only going to be closed over if you use a custom
        # error class at this point, but we should still get rid of this
        # at some point
        '$meta'  => \$self,
        '$class_name' => \($self->name),
    };
}

sub superclasses {
    my $self = shift;
    my $supers = Data::OptList::mkopt(\@_);
    foreach my $super (@{ $supers }) {
        my ($name, $opts) = @{ $super };
        Moose::Util::_load_user_class($name, $opts);
        my $meta = Class::MOP::class_of($name);
        throw_exception( CanExtendOnlyClasses => role_name => $meta->name )
            if $meta && $meta->isa('Moose::Meta::Role')
    }
    return $self->SUPER::superclasses(map { $_->[0] } @{ $supers });
}

### ---------------------------------------------

sub add_attribute {
    my $self = shift;
    my $attr =
        (blessed $_[0] && $_[0]->isa('Class::MOP::Attribute')
            ? $_[0]
            : $self->_process_attribute(@_));
    $self->SUPER::add_attribute($attr);
    # it may be a Class::MOP::Attribute, theoretically, which doesn't have
    # 'bare' and doesn't implement this method
    if ($attr->can('_check_associated_methods')) {
        $attr->_check_associated_methods;
    }
    return $attr;
}

sub add_override_method_modifier {
    my ($self, $name, $method, $_super_package) = @_;

    my $existing_method = $self->get_method($name);
    (!$existing_method)
        || throw_exception( CannotOverrideLocalMethodIsPresent => class_name => $self->name,
                                                                  method     => $existing_method,
                          );
    $self->add_method($name => Moose::Meta::Method::Overridden->new(
        method  => $method,
        class   => $self,
        package => $_super_package, # need this for roles
        name    => $name,
    ));
}

sub add_augment_method_modifier {
    my ($self, $name, $method) = @_;
    my $existing_method = $self->get_method($name);
    throw_exception( CannotAugmentIfLocalMethodPresent => class_name => $self->name,
                                                          method     => $existing_method,
                   )
        if( $existing_method );

    $self->add_method($name => Moose::Meta::Method::Augmented->new(
        method  => $method,
        class   => $self,
        name    => $name,
    ));
}

## Private Utility methods ...

sub _find_next_method_by_name_which_is_not_overridden {
    my ($self, $name) = @_;
    foreach my $method ($self->find_all_methods_by_name($name)) {
        return $method->{code}
            if blessed($method->{code}) && !$method->{code}->isa('Moose::Meta::Method::Overridden');
    }
    return undef;
}

## Metaclass compatibility

sub _base_metaclasses {
    my $self = shift;
    my %metaclasses = $self->SUPER::_base_metaclasses;
    for my $class (keys %metaclasses) {
        $metaclasses{$class} =~ s/^Class::MOP/Moose::Meta/;
    }
    return (
        %metaclasses,
    );
}

sub _fix_class_metaclass_incompatibility {
    my $self = shift;
    my ($super_meta) = @_;

    $self->SUPER::_fix_class_metaclass_incompatibility(@_);

    if ($self->_class_metaclass_can_be_made_compatible($super_meta)) {
        ($self->is_pristine)
            || throw_exception( CannotFixMetaclassCompatibility => class      => $self,
                                                                   superclass => $super_meta
                              );
        my $super_meta_name = $super_meta->_real_ref_name;
        my $class_meta_subclass_meta_name = Moose::Util::_reconcile_roles_for_metaclass(blessed($self), $super_meta_name);
        my $new_self = $class_meta_subclass_meta_name->reinitialize(
            $self->name,
        );

        $self->_replace_self( $new_self, $class_meta_subclass_meta_name );
    }
}

sub _fix_single_metaclass_incompatibility {
    my $self = shift;
    my ($metaclass_type, $super_meta) = @_;

    $self->SUPER::_fix_single_metaclass_incompatibility(@_);

    if ($self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type)) {
        ($self->is_pristine)
            || throw_exception( CannotFixMetaclassCompatibility => class          => $self,
                                                                   superclass     => $super_meta,
                                                                   metaclass_type => $metaclass_type
                              );
        my $super_meta_name = $super_meta->_real_ref_name;
        my $class_specific_meta_subclass_meta_name = Moose::Util::_reconcile_roles_for_metaclass($self->$metaclass_type, $super_meta->$metaclass_type);
        my $new_self = $super_meta->reinitialize(
            $self->name,
            $metaclass_type => $class_specific_meta_subclass_meta_name,
        );

        $self->_replace_self( $new_self, $super_meta_name );
    }
}

sub _replace_self {
    my $self      = shift;
    my ( $new_self, $new_class)   = @_;

    %$self = %$new_self;
    bless $self, $new_class;

    # We need to replace the cached metaclass instance or else when it goes
    # out of scope Class::MOP::Class destroy's the namespace for the
    # metaclass's class, causing much havoc.
    my $weaken = Class::MOP::metaclass_is_weak( $self->name );
    Class::MOP::store_metaclass_by_name( $self->name, $self );
    Class::MOP::weaken_metaclass( $self->name ) if $weaken;
}

sub _process_attribute {
    my ( $self, $name, @args ) = @_;

    @args = %{$args[0]} if scalar @args == 1 && ref($args[0]) eq 'HASH';

    if (($name || '') =~ /^\+(.*)/) {
        return $self->_process_inherited_attribute($1, @args);
    }
    else {
        return $self->_process_new_attribute($name, @args);
    }
}

sub _process_new_attribute {
    my ( $self, $name, @args ) = @_;

    $self->attribute_metaclass->interpolate_class_and_new($name, @args);
}

sub _process_inherited_attribute {
    my ($self, $attr_name, %options) = @_;

    my $inherited_attr = $self->find_attribute_by_name($attr_name);
    (defined $inherited_attr)
        || throw_exception( NoAttributeFoundInSuperClass => class_name     => $self->name,
                                                            attribute_name => $attr_name,
                                                            params         => \%options
                          );
    if ($inherited_attr->isa('Moose::Meta::Attribute')) {
        return $inherited_attr->clone_and_inherit_options(%options);
    }
    else {
        # NOTE:
        # kind of a kludge to handle Class::MOP::Attributes
        return $inherited_attr->Moose::Meta::Attribute::clone_and_inherit_options(%options);
    }
}

# reinitialization support

sub _restore_metaobjects_from {
    my $self = shift;
    my ($old_meta) = @_;

    $self->SUPER::_restore_metaobjects_from($old_meta);

    for my $role ( @{ $old_meta->roles } ) {
        $self->add_role($role);
    }

    for my $application ( @{ $old_meta->_get_role_applications } ) {
        $application->class($self);
        $self->add_role_application ($application);
    }
}

## Immutability

sub _immutable_options {
    my ( $self, @args ) = @_;

    $self->SUPER::_immutable_options(
        inline_destructor => 1,

        # Moose always does this when an attribute is created
        inline_accessors => 0,

        @args,
    );
}

sub _fixup_attributes_after_rebless {
    my $self = shift;
    my ($instance, $rebless_from, %params) = @_;

    $self->SUPER::_fixup_attributes_after_rebless(
        $instance,
        $rebless_from,
        %params
    );

    $self->_call_all_triggers( $instance, \%params );
}

## -------------------------------------------------

our $error_level;

sub _inline_throw_exception {
    my ( $self, $exception_type, $throw_args ) = @_;
    return 'die Module::Runtime::use_module("Moose::Exception::' . $exception_type . '")->new(' . ($throw_args || '') . ')';
}

1;

# ABSTRACT: The Moose metaclass

package Moose::Meta::TypeConstraint;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use overload '0+'     => sub { refaddr(shift) }, # id an object
             '""'     => sub { shift->name },   # stringify to tc name
             bool     => sub { 1 },
             fallback => 1;

use Eval::Closure;
use Scalar::Util qw(refaddr);
use Sub::Util qw(set_subname);
use Try::Tiny;

use parent 'Class::MOP::Object';

use Moose::Util 'throw_exception';

__PACKAGE__->meta->add_attribute('name'       => (
    reader => 'name',
    Class::MOP::_definition_context(),
));
__PACKAGE__->meta->add_attribute('parent'     => (
    reader    => 'parent',
    predicate => 'has_parent',
    Class::MOP::_definition_context(),
));

my $null_constraint = sub { 1 };
__PACKAGE__->meta->add_attribute('constraint' => (
    reader  => 'constraint',
    writer  => '_set_constraint',
    default => sub { $null_constraint },
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('message'   => (
    accessor  => 'message',
    predicate => 'has_message',
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('_default_message' => (
    accessor  => '_default_message',
    Class::MOP::_definition_context(),
));

# can't make this a default because it has to close over the type name, and
# cmop attributes don't have lazy
my $_default_message_generator = sub {
    my $name = shift;
    sub {
        my $value = shift;
        # have to load it late like this, since it uses Moose itself
        my $can_partialdump = try {
            # versions prior to 0.14 had a potential infinite loop bug
            require Devel::PartialDump;
            Devel::PartialDump->VERSION(0.14);
            1;
        };
        if ($can_partialdump) {
            $value = Devel::PartialDump->new->dump($value);
        }
        else {
            $value = (defined $value ? overload::StrVal($value) : 'undef');
        }
        return "Validation failed for '" . $name . "' with value $value";
    }
};
__PACKAGE__->meta->add_attribute('coercion'   => (
    accessor  => 'coercion',
    predicate => 'has_coercion',
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('inlined' => (
    init_arg  => 'inlined',
    accessor  => 'inlined',
    predicate => '_has_inlined_type_constraint',
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('inline_environment' => (
    init_arg => 'inline_environment',
    accessor => '_inline_environment',
    default  => sub { {} },
    Class::MOP::_definition_context(),
));

sub parents {
    my $self = shift;
    $self->parent;
}

# private accessors

__PACKAGE__->meta->add_attribute('compiled_type_constraint' => (
    accessor  => '_compiled_type_constraint',
    predicate => '_has_compiled_type_constraint',
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('package_defined_in' => (
    accessor => '_package_defined_in',
    Class::MOP::_definition_context(),
));

sub new {
    my $class = shift;
    my ($first, @rest) = @_;
    my %args = ref $first ? %$first : $first ? ($first, @rest) : ();
    $args{name} = $args{name} ? "$args{name}" : "__ANON__";

    if ( exists $args{message}
      && (!ref($args{message}) || ref($args{message}) ne 'CODE') ) {
        throw_exception( MessageParameterMustBeCodeRef => params => \%args,
                                                          class  => $class
                       );
    }

    my $self  = $class->_new(%args);
    $self->compile_type_constraint()
        unless $self->_has_compiled_type_constraint;
    $self->_default_message($_default_message_generator->($self->name))
        unless $self->has_message;
    return $self;
}



sub coerce {
    my $self = shift;

    my $coercion = $self->coercion;

    unless ($coercion) {
        throw_exception( CoercingWithoutCoercions => type_name => $self->name );
    }

    return $_[0] if $self->check($_[0]);

    return $coercion->coerce(@_);
}

sub assert_coerce {
    my $self = shift;

    my $result = $self->coerce(@_);

    $self->assert_valid($result);

    return $result;
}

sub check {
    my ($self, @args) = @_;
    my $constraint_subref = $self->_compiled_type_constraint;
    return $constraint_subref->(@args) ? 1 : undef;
}

sub validate {
    my ($self, $value) = @_;
    if ($self->_compiled_type_constraint->($value)) {
        return undef;
    }
    else {
        $self->get_message($value);
    }
}

sub can_be_inlined {
    my $self = shift;

    if ( $self->has_parent && $self->constraint == $null_constraint ) {
        return $self->parent->can_be_inlined;
    }

    return $self->_has_inlined_type_constraint;
}

sub _inline_check {
    my $self = shift;

    unless ( $self->can_be_inlined ) {
        throw_exception( CannotInlineTypeConstraintCheck => type_name => $self->name );
    }

    if ( $self->has_parent && $self->constraint == $null_constraint ) {
        return $self->parent->_inline_check(@_);
    }

    return '( do { ' . $self->inlined->( $self, @_ ) . ' } )';
}

sub inline_environment {
    my $self = shift;

    if ( $self->has_parent && $self->constraint == $null_constraint ) {
        return $self->parent->inline_environment;
    }

    return $self->_inline_environment;
}

sub assert_valid {
    my ( $self, $value ) = @_;

    return 1 if $self->check($value);

    throw_exception(
        'ValidationFailedForTypeConstraint',
        type  => $self,
        value => $value
    );
}

sub get_message {
    my ($self, $value) = @_;
    my $msg = $self->has_message
        ? $self->message
        : $self->_default_message;
    local $_ = $value;
    return $msg->($value);
}

## type predicates ...

sub equals {
    my ( $self, $type_or_name ) = @_;

    my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
    return if not $other;

    return 1 if $self == $other;

    return unless $self->constraint == $other->constraint;

    if ( $self->has_parent ) {
        return unless $other->has_parent;
        return unless $self->parent->equals( $other->parent );
    } else {
        return if $other->has_parent;
    }

    return;
}

sub is_a_type_of {
    my ($self, $type_or_name) = @_;

    my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
    return if not $type;

    ($self->equals($type) || $self->is_subtype_of($type));
}

sub is_subtype_of {
    my ($self, $type_or_name) = @_;

    my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
    return if not $type;

    my $current = $self;

    while (my $parent = $current->parent) {
        return 1 if $parent->equals($type);
        $current = $parent;
    }

    return 0;
}

## compiling the type constraint

sub compile_type_constraint {
    my $self = shift;
    $self->_compiled_type_constraint($self->_actually_compile_type_constraint);
}

## type compilers ...

sub _actually_compile_type_constraint {
    my $self = shift;

    if ( $self->can_be_inlined ) {
        return eval_closure(
            source      => 'sub { ' . $self->_inline_check('$_[0]') . ' }',
            environment => $self->inline_environment,
        );
    }

    my $check = $self->constraint;
    unless ( defined $check ) {
        throw_exception( NoConstraintCheckForTypeConstraint => type_name => $self->name );
    }

    return $self->_compile_subtype($check)
        if $self->has_parent;

    return $self->_compile_type($check);
}

sub _compile_subtype {
    my ($self, $check) = @_;

    # gather all the parent constraints in order
    my @parents;
    foreach my $parent ($self->_collect_all_parents) {
        push @parents => $parent->constraint;
    }

    @parents = grep { $_ != $null_constraint } reverse @parents;

    unless ( @parents ) {
        return $self->_compile_type($check);
    } else {
        # general case, check all the constraints, from the first parent to ourselves
        my @checks = @parents;
        push @checks, $check if $check != $null_constraint;
        return set_subname(
            $self->name => sub {
                my (@args) = @_;
                local $_ = $args[0];
                foreach my $check (@checks) {
                    return undef unless $check->(@args);
                }
                return 1;
            }
        );
    }
}

sub _compile_type {
    my ($self, $check) = @_;

    return $check if $check == $null_constraint; # Item, Any

    return set_subname(
        $self->name => sub {
            my (@args) = @_;
            local $_ = $args[0];
            $check->(@args);
        }
    );
}

## other utils ...

sub _collect_all_parents {
    my $self = shift;
    my @parents;
    my $current = $self->parent;
    while (defined $current) {
        push @parents => $current;
        $current = $current->parent;
    }
    return @parents;
}

sub create_child_type {
    my ($self, %opts) = @_;
    my $class = ref $self;
    return $class->new(%opts, parent => $self);
}

1;

# ABSTRACT: The Moose Type Constraint metaclass

package Moose::Meta::Class::Immutable::Trait;
our $VERSION = '2.2204';

use strict;
use warnings;

use Class::MOP;
use Scalar::Util qw( blessed );

use parent 'Class::MOP::Class::Immutable::Trait';

use Moose::Util 'throw_exception';

sub add_role { $_[1]->_immutable_cannot_call }

sub calculate_all_roles {
    my $orig = shift;
    my $self = shift;
    @{ $self->{__immutable}{calculate_all_roles} ||= [ $self->$orig ] };
}

sub calculate_all_roles_with_inheritance {
    my $orig = shift;
    my $self = shift;
    @{ $self->{__immutable}{calculate_all_roles_with_inheritance} ||= [ $self->$orig ] };
}

sub does_role {
    shift;
    my $self = shift;
    my $role = shift;

    (defined $role)
        || throw_exception( RoleNameRequired => class_name => $self->name );

    $self->{__immutable}{does_role} ||= { map { $_->name => 1 } $self->calculate_all_roles_with_inheritance };

    my $name = blessed $role ? $role->name : $role;

    return $self->{__immutable}{does_role}{$name};
}

1;

# ABSTRACT: Implements immutability for metaclass objects

package Moose::Meta::Method;
our $VERSION = '2.2204';

use strict;
use warnings;

use Class::MOP::MiniTrait;

use parent 'Class::MOP::Method';

Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');

1;

# ABSTRACT: A Moose Method metaclass

package Moose::Meta::Object::Trait;
our $VERSION = '2.2204';

use Scalar::Util qw(blessed);

sub _get_compatible_metaclass {
    my $orig = shift;
    my $self = shift;
    return $self->$orig(@_)
        || $self->_get_compatible_metaclass_by_role_reconciliation(@_);
}

sub _get_compatible_metaclass_by_role_reconciliation {
    my $self = shift;
    my ($other_name) = @_;
    my $meta_name = blessed($self) ? $self->_real_ref_name : $self;

    return unless Moose::Util::_classes_differ_by_roles_only(
        $meta_name, $other_name
    );

    return Moose::Util::_reconcile_roles_for_metaclass(
        $meta_name, $other_name
    );
}

1;

# ABSTRACT: Some overrides for L<Class::MOP::Object> functionality

package Moose::Meta::Method::Overridden;
our $VERSION = '2.2204';

use strict;
use warnings;

use parent 'Moose::Meta::Method';

use Moose::Util 'throw_exception';

sub new {
    my ( $class, %args ) = @_;

    # the package can be overridden by roles
    # it is really more like body's compilation stash
    # this is where we need to override the definition of super() so that the
    # body of the code can call the right overridden version
    my $super_package = $args{package} || $args{class}->name;

    my $name = $args{name};

    my $super = $args{class}->find_next_method_by_name($name);

    (defined $super)
        || throw_exception( CannotOverrideNoSuperMethod => class       => $class,
                                                           params      => \%args,
                                                           method_name => $name
                          );

    my $super_body = $super->body;

    my $method = $args{method};

    my $body = sub {
        local $Moose::SUPER_PACKAGE = $super_package;
        local @Moose::SUPER_ARGS = @_;
        local $Moose::SUPER_BODY = $super_body;
        return $method->(@_);
    };

    # FIXME do we need this make sure this works for next::method?
    # subname "${super_package}::${name}", $method;

    # FIXME store additional attrs
    $class->wrap(
        $body,
        package_name => $args{class}->name,
        name         => $name
    );
}

1;

# ABSTRACT: A Moose Method metaclass for overridden methods

package Moose::Meta::Method::Delegation;
our $VERSION = '2.2204';

use strict;
use warnings;

use Scalar::Util 'blessed', 'weaken';
use Try::Tiny;

use parent 'Moose::Meta::Method',
         'Class::MOP::Method::Generated';

use Moose::Util 'throw_exception';

sub new {
    my $class   = shift;
    my %options = @_;

    ( exists $options{attribute} )
        || throw_exception( MustSupplyAnAttributeToConstructWith => params => \%options,
                                                                    class  => $class
                          );

    ( blessed( $options{attribute} )
            && $options{attribute}->isa('Moose::Meta::Attribute') )
        || throw_exception( MustSupplyAMooseMetaAttributeInstance => params => \%options,
                                                                     class  => $class
                          );

    ( $options{package_name} && $options{name} )
        || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                            class  => $class
                          );

    ( $options{delegate_to_method} && ( !ref $options{delegate_to_method} )
            || ( 'CODE' eq ref $options{delegate_to_method} ) )
        || throw_exception( MustSupplyADelegateToMethod => params => \%options,
                                                           class  => $class
                          );

    exists $options{curried_arguments}
        || ( $options{curried_arguments} = [] );

    ( $options{curried_arguments} &&
        ( 'ARRAY' eq ref $options{curried_arguments} ) )
        || throw_exception( MustSupplyArrayRefAsCurriedArguments => params     => \%options,
                                                                    class_name => $class
                          );

    my $self = $class->_new( \%options );

    weaken( $self->{'attribute'} );

    $self->_initialize_body;

    return $self;
}

sub _new {
    my $class = shift;
    my $options = @_ == 1 ? $_[0] : {@_};

    return bless $options, $class;
}

sub curried_arguments { (shift)->{'curried_arguments'} }

sub associated_attribute { (shift)->{'attribute'} }

sub delegate_to_method { (shift)->{'delegate_to_method'} }

sub _initialize_body {
    my $self = shift;

    my $method_to_call = $self->delegate_to_method;
    return $self->{body} = $method_to_call
        if ref $method_to_call;

    # We don't inline because it's faster, we do it because when the method is
    # inlined, any errors thrown because of the delegated method have a _much_
    # nicer stack trace, as the trace doesn't include any Moose internals.
    $self->{body} = $self->_generate_inline_method;

    return;
}

sub _generate_inline_method {
    my $self = shift;

    my $attr = $self->associated_attribute;
    my $delegate = $self->delegate_to_method;

    my $method_name = B::perlstring( $self->name );
    my $attr_name   = B::perlstring( $self->associated_attribute->name );

    my $undefined_attr_throw = $self->_inline_throw_exception(
        'AttributeValueIsNotDefined',
        sprintf( <<'EOF', $method_name, $attr_name ) );
method    => $self->meta->find_method_by_name(%s),
instance  => $self,
attribute => $self->meta->find_attribute_by_name(%s),
EOF

    my $not_an_object_throw = $self->_inline_throw_exception(
        'AttributeValueIsNotAnObject',
        sprintf( <<'EOF', $method_name, $attr_name ) );
method      => $self->meta->find_method_by_name(%s),
instance    => $self,
attribute   => $self->meta->find_attribute_by_name(%s),
given_value => $proxy,
EOF

    my $get_proxy
        = $attr->has_read_method ? $attr->get_read_method : '$reader';

    my $args = @{ $self->curried_arguments } ? '@curried, @_' : '@_';
    my $source = sprintf(
        <<'EOF', $get_proxy, $undefined_attr_throw, $not_an_object_throw, $delegate, $args );
sub {
    my $self = shift;

    my $proxy = $self->%s;
    if ( !defined $proxy ) {
        %s;
    }
    elsif ( ref $proxy && !Scalar::Util::blessed($proxy) ) {
        %s;
    }
    return $proxy->%s( %s );
}
EOF

    my $description
        = 'inline delegation in '
        . $self->package_name . ' for '
        . $attr->name . '->'
        . $delegate;

    my $definition = $attr->definition_context;
    # While all attributes created in the usual way (via Moose's has()) will
    # define this, there's no guarantee that this must be defined. For
    # example, when Moo inflates a class to Moose it does not define these (as
    # of Moo 2.003).
    $description .= " (attribute declared in $definition->{file} at line $definition->{line})"
        if defined $definition->{file} && defined $definition->{line};

    return try {
        $self->_compile_code(
            source      => $source,
            description => $description,
        );
    }
    catch {
        $self->_throw_exception(
            'CouldNotGenerateInlineAttributeMethod',
            instance => $self,
            error    => $_,
            option   => 'handles for ' . $attr->name . '->' . $delegate,
        );
    };
}

sub _eval_environment {
    my $self = shift;

    my %env;
    if ( @{ $self->curried_arguments } ) {
        $env{'@curried'} = $self->curried_arguments;
    }

    unless ( $self->associated_attribute->has_read_method ) {
        $env{'$reader'} = \( $self->_get_delegate_accessor );
    }

    return \%env;
}

sub _get_delegate_accessor {
    my $self = shift;

    my $accessor = $self->associated_attribute->get_read_method_ref;

    # If it's blessed it's a Moose::Meta::Method
    return blessed $accessor
        ? ( $accessor->body )
        : $accessor;
}

1;

# ABSTRACT: A Moose Method metaclass for delegation methods

package Moose::Meta::Method::Meta;
our $VERSION = '2.2204';

use strict;
use warnings;

use parent 'Moose::Meta::Method',
         'Class::MOP::Method::Meta';

sub _is_caller_mop_internal {
    my $self = shift;
    my ($caller) = @_;
    return 1 if $caller =~ /^Moose(?:::|$)/;
    return $self->SUPER::_is_caller_mop_internal($caller);
}

# XXX: ugh multiple inheritance
sub wrap {
    my $class = shift;
    return $class->Class::MOP::Method::Meta::wrap(@_);
}

sub _make_compatible_with {
    my $self = shift;
    return $self->Class::MOP::Method::Meta::_make_compatible_with(@_);
}

1;

# ABSTRACT: A Moose Method metaclass for C<meta> methods

package Moose::Meta::Method::Destructor;
our $VERSION = '2.2204';

use strict;
use warnings;

use Devel::GlobalDestruction ();
use Scalar::Util 'blessed', 'weaken';
use Try::Tiny;

use parent 'Moose::Meta::Method',
         'Class::MOP::Method::Inlined';

use Moose::Util 'throw_exception';

sub new {
    my $class   = shift;
    my %options = @_;

    (ref $options{options} eq 'HASH')
        || throw_exception( MustPassAHashOfOptions => params => \%options,
                                                      class  => $class
                          );

    ($options{package_name} && $options{name})
        || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                            class  => $class
                          );

    my $self = bless {
        # from our superclass
        'body'                 => undef,
        'package_name'         => $options{package_name},
        'name'                 => $options{name},
        # ...
        'options'              => $options{options},
        'definition_context'   => $options{definition_context},
        'associated_metaclass' => $options{metaclass},
    } => $class;

    # we don't want this creating
    # a cycle in the code, if not
    # needed
    weaken($self->{'associated_metaclass'});

    $self->_initialize_body;

    return $self;
}

## accessors

sub options              { (shift)->{'options'}              }

## method

sub is_needed {
    my $self      = shift;
    my $metaclass = shift;

    ( blessed $metaclass && $metaclass->isa('Class::MOP::Class') )
        || throw_exception( MethodExpectedAMetaclassObject => metaclass => $metaclass,
                                                              class     => $self
                          );

    return $metaclass->find_method_by_name("DEMOLISHALL");
}

sub _initialize_body {
    my $self = shift;
    # TODO:
    # the %options should also include a both
    # a call 'initializer' and call 'SUPER::'
    # options, which should cover approx 90%
    # of the possible use cases (even if it
    # requires some adaption on the part of
    # the author, after all, nothing is free)

    my $class = $self->associated_metaclass->name;
    my @source = (
        'sub {',
            'my $self = shift;',
            'return ' . $self->_generate_fallback_destructor('$self'),
                'if Scalar::Util::blessed($self) ne \'' . $class . '\';',
            $self->_generate_DEMOLISHALL('$self'),
            'return;',
        '}',
    );
    warn join("\n", @source) if $self->options->{debug};

    my $code = try {
        $self->_compile_code(source => \@source);
    }
    catch {
        my $source = join("\n", @source);
        throw_exception( CouldNotEvalDestructor => method_destructor_object => $self,
                                                   source                   => $source,
                                                   error                    => $_
                       );
    };

    $self->{'body'} = $code;
}

sub _generate_fallback_destructor {
    my $self = shift;
    my ($inv) = @_;

    return $inv . '->Moose::Object::DESTROY(@_)';
}

sub _generate_DEMOLISHALL {
    my $self = shift;
    my ($inv) = @_;

    my @methods = $self->associated_metaclass->find_all_methods_by_name('DEMOLISH');
    return unless @methods;

    return (
        'local $?;',
        'my $igd = Devel::GlobalDestruction::in_global_destruction;',
        'Try::Tiny::try {',
            (map { $inv . '->' . $_->{class} . '::DEMOLISH($igd);' } @methods),
        '}',
        'Try::Tiny::catch {',
            'die $_;',
        '};',
    );
}


1;

# ABSTRACT: Method Meta Object for destructors

package Moose::Meta::Method::Constructor;
our $VERSION = '2.2204';

use strict;
use warnings;

use Scalar::Util 'weaken';

use parent 'Moose::Meta::Method',
         'Class::MOP::Method::Constructor';

use Moose::Util 'throw_exception';

sub new {
    my $class   = shift;
    my %options = @_;

    my $meta = $options{metaclass};

    (ref $options{options} eq 'HASH')
        || throw_exception( MustPassAHashOfOptions => params => \%options,
                                                      class  => $class
                          );

    ($options{package_name} && $options{name})
        || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                            class  => $class
                          );

    my $self = bless {
        'body'          => undef,
        'package_name'  => $options{package_name},
        'name'          => $options{name},
        'options'       => $options{options},
        'associated_metaclass' => $meta,
        'definition_context' => $options{definition_context},
        '_expected_method_class' => $options{_expected_method_class} || 'Moose::Object',
    } => $class;

    # we don't want this creating
    # a cycle in the code, if not
    # needed
    weaken($self->{'associated_metaclass'});

    $self->_initialize_body;

    return $self;
}

## method

sub _initialize_body {
    my $self = shift;
    $self->{'body'} = $self->_generate_constructor_method_inline;
}

1;

# ABSTRACT: Method Meta Object for constructors

package Moose::Meta::Method::Accessor::Native::Hash;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

sub _inline_check_var_is_valid_key {
    my $self = shift;
    my ($var) = @_;

    return (
        'if (!defined(' . $var . ')) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => '.$var.','.
                                            'method_name             => "'.$self->delegate_to_method.'",'.
                                            'type_of_argument        => "defined value",'.
                                            'type                    => "Defined",'.
                                            'argument_noun           => "key"',
            ) . ';',
        '}',
    );
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Writer;
our $VERSION = '2.2204';

use strict;
use warnings;

use List::Util 1.33 qw( any );
use Moose::Util;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native';

requires '_potential_value';

sub _generate_method {
    my $self = shift;

    my $inv         = '$self';
    my $slot_access = $self->_get_value($inv);

    return (
        'sub {',
            'my ' . $inv . ' = shift;',
            $self->_inline_curried_arguments,
            $self->_inline_writer_core($inv, $slot_access),
        '}',
    );
}

sub _inline_writer_core {
    my $self = shift;
    my ($inv, $slot_access) = @_;

    my $potential = $self->_potential_value($slot_access);
    my $old       = '@old';

    my @code;
    push @code, (
        $self->_inline_check_argument_count,
        $self->_inline_process_arguments($inv, $slot_access),
        $self->_inline_check_arguments('for writer'),
        $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
    );

    if ($self->_return_value($slot_access)) {
        # some writers will save the return value in this variable when they
        # generate the potential value.
        push @code, 'my @return;'
    }

    push @code, (
        $self->_inline_coerce_new_values,
        $self->_inline_copy_native_value(\$potential),
        $self->_inline_tc_code($potential, '$type_constraint', '$type_coercion', '$type_message'),
        $self->_inline_get_old_value_for_trigger($inv, $old),
        $self->_inline_capture_return_value($slot_access),
        $self->_inline_set_new_value($inv, $potential, $slot_access),
        $self->_inline_trigger($inv, $slot_access, $old),
        $self->_inline_return_value($slot_access, 'for writer'),
    );

    return @code;
}

sub _inline_process_arguments { return }

sub _inline_check_arguments { return }

sub _inline_coerce_new_values { return }

sub _writer_value_needs_copy {
    my $self = shift;

    return $self->_constraint_must_be_checked;
}

sub _constraint_must_be_checked {
    my $self = shift;

    my $attr = $self->associated_attribute;

    return $attr->has_type_constraint
        && ( !$self->_is_root_type( $attr->type_constraint )
        || ( $attr->should_coerce && $attr->type_constraint->has_coercion ) );
}

sub _is_root_type {
    my $self = shift;
    my $type = shift;

    if (   blessed($type)
        && $type->can('does')
        && $type->does('Specio::Constraint::Role::Interface') )
    {
        require Specio::Library::Builtins;
        return
            any { $type->is_same_type_as( Specio::Library::Builtins::t($_) ) }
        @{ $self->root_types };
    }
    else {
        my $name = $type->name;
        return any { $name eq $_ } @{ $self->root_types };
    }
}

sub _inline_copy_native_value {
    my $self = shift;
    my ($potential_ref) = @_;

    return unless $self->_writer_value_needs_copy;

    my $code = 'my $potential = ' . ${$potential_ref} . ';';

    ${$potential_ref} = '$potential';

    return $code;
}

around _inline_tc_code => sub {
    my $orig = shift;
    my $self = shift;
    my ($value, $tc, $coercion, $message, $for_lazy) = @_;

    return unless $for_lazy || $self->_constraint_must_be_checked;

    return $self->$orig(@_);
};

around _inline_check_constraint => sub {
    my $orig = shift;
    my $self = shift;
    my ($value, $tc, $message, $for_lazy) = @_;

    return unless $for_lazy || $self->_constraint_must_be_checked;

    return $self->$orig(@_);
};

sub _inline_capture_return_value { return }

sub _inline_set_new_value {
    my $self = shift;

    return $self->_inline_store_value(@_)
        if $self->_writer_value_needs_copy
        || !$self->_slot_access_can_be_inlined
        || !$self->_get_is_lvalue;

    return $self->_inline_optimized_set_new_value(@_);
}

sub _get_is_lvalue {
    my $self = shift;

    return $self->associated_attribute->associated_class->instance_metaclass->inline_get_is_lvalue;
}

sub _inline_optimized_set_new_value {
    my $self = shift;

    return $self->_inline_store_value(@_);
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access;
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Reader;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native';

requires '_return_value';

sub _generate_method {
    my $self = shift;

    my $inv         = '$self';
    my $slot_access = $self->_get_value($inv);

    return (
        'sub {',
            'my ' . $inv . ' = shift;',
            $self->_inline_curried_arguments,
            $self->_inline_reader_core($inv, $slot_access, @_),
        '}',
    );
}

sub _inline_reader_core {
    my $self = shift;
    my ($inv, $slot_access, @extra) = @_;

    return (
        $self->_inline_check_argument_count,
        $self->_inline_process_arguments($inv, $slot_access),
        $self->_inline_check_arguments,
        $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
        $self->_inline_return_value($slot_access),
    );
}

sub _inline_process_arguments { return }

sub _inline_check_arguments { return }

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Counter::Writer;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _constraint_must_be_checked {
    my $self = shift;

    my $attr = $self->associated_attribute;

    return $attr->has_type_constraint
        && ($attr->type_constraint->name =~ /^(?:Num|Int)$/
         || ($attr->should_coerce && $attr->type_constraint->has_coercion)
           );
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Counter::dec;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _minimum_arguments { 0 }
sub _maximum_arguments { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . ' - (defined $_[0] ? $_[0] : 1)';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' -= defined $_[0] ? $_[0] : 1;';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Counter::reset;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _maximum_arguments { 0 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    my $attr = $self->associated_attribute;

    return '(do { '
             . join(' ', $attr->_inline_generate_default(
                   '$self', '$default_for_reset'
               )) . ' '
             . '$default_for_reset; '
         . '})';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' = ' . $self->_potential_value . ';';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Counter::set;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _minimum_arguments { 1 }
sub _maximum_arguments { 1 }

sub _potential_value { '$_[0]' }

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' = $_[0];';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Counter::inc;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _minimum_arguments { 0 }
sub _maximum_arguments { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . ' + (defined $_[0] ? $_[0] : 1)';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' += defined $_[0] ? $_[0] : 1;';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Bool::unset;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _maximum_arguments { 0 }

sub _potential_value { 0 }

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' = 0;';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Bool::set;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _maximum_arguments { 0 }

sub _potential_value { 1 }

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' = 1;';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Bool::not;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '!' . $slot_access;
}

1;
package Moose::Meta::Method::Accessor::Native::Bool::toggle;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _maximum_arguments { 0 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . ' ? 0 : 1';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' = ' . $slot_access . ' ? 0 : 1;';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::String::length;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'length ' . $slot_access;
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::String::match;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Util ();
use Params::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return (
        'if (!Moose::Util::_STRINGLIKE0($_[0]) && !Params::Util::_REGEX($_[0])) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[0],'.
                                            'type                    => "Str|RegexpRef",'.
                                            'type_of_argument        => "string or regexp reference",'.
                                            'method_name             => "match"',
            ) . ';',
        '}',
    );
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . ' =~ $_[0]';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::String::substr;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader',
     'Moose::Meta::Method::Accessor::Native::Writer';

sub _generate_method {
    my $self = shift;

    my $inv         = '$self';
    my $slot_access = $self->_get_value($inv);

    return (
        'sub {',
            'my ' . $inv . ' = shift;',
            $self->_inline_curried_arguments,
            'if (@_ == 1 || @_ == 2) {',
                $self->_inline_reader_core($inv, $slot_access),
            '}',
            'elsif (@_ == 3) {',
                $self->_inline_writer_core($inv, $slot_access),
            '}',
            'else {',
                $self->_inline_check_argument_count,
            '}',
        '}',
    );
}

sub _minimum_arguments { 1 }
sub _maximum_arguments { 3 }

sub _inline_process_arguments {
    my $self = shift;
    my ($inv, $slot_access) = @_;

    return (
        'my $offset = shift;',
        'my $length = @_ ? shift : length ' . $slot_access . ';',
        'my $replacement = shift;',
    );
}

sub _inline_check_arguments {
    my $self = shift;
    my ($for_writer) = @_;

    my @code = (
        'if ($offset !~ /^-?\d+$/) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $offset,'.
                                            'ordinal                 => "first",'.
                                            'type_of_argument        => "integer",'.
                                            'method_name             => "substr",'.
                                            'type                    => "Int"',
            ) . ';',
        '}',
        'if ($length !~ /^-?\d+$/) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $length,'.
                                            'ordinal                 => "second",'.
                                            'type_of_argument        => "integer",'.
                                            'method_name             => "substr",'.
                                            'type                    => "Int"',
            ) . ';',
        '}',
    );

    if ($for_writer) {
        push @code, (
            'if (!Moose::Util::_STRINGLIKE0($replacement)) {',
                $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                                'argument                => $replacement,'.
                                                'ordinal                 => "third",'.
                                                'type_of_argument        => "string",'.
                                                'method_name             => "substr",'.
                                                'type                    => "Str"',
                ) . ';',
            '}',
        );
    }

    return @code;
}

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '(do { '
             . 'my $potential = ' . $slot_access . '; '
             . '@return = substr $potential, $offset, $length, $replacement; '
             . '$potential; '
         . '})';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return '@return = substr ' . $slot_access . ', '
                           . '$offset, $length, $replacement;';
}

sub _return_value {
    my $self = shift;
    my ($slot_access, $for_writer) = @_;

    return '$return[0]' if $for_writer;

    return 'substr ' . $slot_access . ', $offset, $length';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::String::prepend;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '$_[0] . ' . $slot_access;
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' = $_[0] . ' . $slot_access . ';';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::String::chomp;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _maximum_arguments { 0 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '(do { '
             . 'my $val = ' . $slot_access . '; '
             . '@return = chomp $val; '
             . '$val '
         . '})';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return '@return = chomp ' . $slot_access . ';';
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '$return[0]';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::String::chop;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _maximum_arguments { 0 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '(do { '
             . 'my $val = ' . $slot_access . '; '
             . '@return = chop $val; '
             . '$val; '
         . '})';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return '@return = chop ' . $slot_access . ';';
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '$return[0]';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::String::replace;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Util ();
use Params::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 2 }

sub _inline_check_arguments {
    my $self = shift;

    return (
        'if (!Moose::Util::_STRINGLIKE0($_[0]) && !Params::Util::_REGEX($_[0])) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[0],'.
                                            'method_name             => "replace",'.
                                            'ordinal                 => "first",'.
                                            'type_of_argument        => "string or regexp reference",'.
                                            'type                    => "Str|RegexpRef"',
            ) . ';',
        '}',
        'if (!Moose::Util::_STRINGLIKE0($_[1]) && !Params::Util::_CODELIKE($_[1])) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[1],'.
                                            'method_name             => "replace",'.
                                            'ordinal                 => "second",'.
                                            'type_of_argument        => "string or code reference",'.
                                            'type                    => "Str|CodeRef"',
            ) . ';',
        '}',
    );
}

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '(do { '
             . 'my $val = ' . $slot_access . '; '
             . 'ref $_[1] '
                 . '? $val =~ s/$_[0]/$_[1]->()/e '
                 . ': $val =~ s/$_[0]/$_[1]/; '
             . '$val; '
         . '})';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return (
        'ref $_[1]',
            '? ' . $slot_access . ' =~ s/$_[0]/$_[1]->()/e',
            ': ' . $slot_access . ' =~ s/$_[0]/$_[1]/;',
     );
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::String::append;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '( ' . $slot_access . ' . $_[0] )';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' .= $_[0];';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::String::clear;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _maximum_arguments { 0 }

sub _potential_value { '""' }

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' = "";';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::String::inc;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _maximum_arguments { 0 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '(do { '
             . 'my $val = ' . $slot_access . '; '
             . '$val++; '
             . '$val; '
         . '})';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . '++;';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Collection;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

requires qw( _adds_members _new_members );

sub _inline_coerce_new_values {
    my $self = shift;

    return unless $self->associated_attribute->should_coerce;

    return unless $self->_tc_member_type_can_coerce;

    return (
        '(' . $self->_new_members . ') = map { $member_coercion->($_) }',
                                             $self->_new_members . ';',
    );
}

sub _tc_member_type_can_coerce {
    my $self = shift;

    my $member_tc = $self->_tc_member_type;

    return $member_tc && $member_tc->has_coercion;
}

sub _tc_member_type {
    my $self = shift;

    my $tc = $self->associated_attribute->type_constraint;
    while ($tc) {
        return $tc->type_parameter
            if $tc->can('type_parameter');
        $tc = $tc->parent;
    }

    return;
}

sub _writer_value_needs_copy {
    my $self = shift;

    return $self->_constraint_must_be_checked
        && !$self->_check_new_members_only;
}

sub _inline_tc_code {
    my $self = shift;
    my ($value, $tc, $coercion, $message, $is_lazy) = @_;

    return unless $self->_constraint_must_be_checked;

    if ($self->_check_new_members_only) {
        return unless $self->_adds_members;

        return $self->_inline_check_member_constraint($self->_new_members);
    }
    else {
        return (
            $self->_inline_check_coercion($value, $tc, $coercion, $is_lazy),
            $self->_inline_check_constraint($value, $tc, $message, $is_lazy),
        );
    }
}

sub _check_new_members_only {
    my $self = shift;

    my $attr = $self->associated_attribute;

    my $tc = $attr->type_constraint;

    # If we have a coercion, we could come up with an entirely new value after
    # coercing, so we need to check everything,
    return 0 if $attr->should_coerce && $tc->has_coercion;

    # If the parent is our root type (ArrayRef, HashRef, etc), that means we
    # can just check the new members of the collection, because we know that
    # we will always be generating an appropriate collection type.
    #
    # However, if this type has its own constraint (it's Parameteriz_able_,
    # not Paramet_erized_), we don't know what is being checked by the
    # constraint, so we need to check the whole value, not just the members.
    return 1
        if $self->_is_root_type( $tc->parent )
            && ( $tc->isa('Moose::Meta::TypeConstraint::Parameterized')
                 || !$tc->can('parameterize') );

    return 0;
}

sub _inline_check_member_constraint {
    my $self = shift;
    my ($new_value) = @_;

    my $attr_name = $self->associated_attribute->name;

    my $check
        = $self->_tc_member_type->can_be_inlined
        ? '! (' . $self->_tc_member_type->_inline_check('$new_val') . ')'
        : ' !$member_tc->($new_val) ';

    return (
        'for my $new_val (' . $new_value . ') {',
            "if ($check) {",
                'my $msg = do { local $_ = $new_val; $member_message->($new_val) };'.
                $self->_inline_throw_exception( ValidationFailedForInlineTypeConstraint =>
                                                "attribute_name          => '".$attr_name."',".
                                                'type_constraint_message => $msg,'.
                                                'class_name              => $class_name,'.
                                                'value                   => $new_val,'.
                                                'new_member              => 1',
                ) . ';',
            '}',
        '}',
    );
}

sub _inline_get_old_value_for_trigger {
    my $self = shift;
    my ($instance, $old) = @_;

    my $attr = $self->associated_attribute;
    return unless $attr->has_trigger;

    return (
        'my ' . $old . ' = ' . $self->_has_value($instance),
            '? ' . $self->_copy_old_value($self->_get_value($instance)),
            ': ();',
    );
}

around _eval_environment => sub {
    my $orig = shift;
    my $self = shift;

    my $env = $self->$orig(@_);

    my $member_tc = $self->_tc_member_type;

    return $env unless $member_tc;

    $env->{'$member_tc'} = \( $member_tc->_compiled_type_constraint );
    $env->{'$member_coercion'} = \(
        $member_tc->coercion->_compiled_type_coercion
    ) if $member_tc->has_coercion;
    $env->{'$member_message'} = \(
        $member_tc->has_message
            ? $member_tc->message
            : $member_tc->_default_message
    );

    my $tc_env = $member_tc->inline_environment();

    $env = { %{$env}, %{$tc_env} };

    return $env;
};

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

sub _inline_check_var_is_valid_index {
    my $self = shift;
    my ($var) = @_;

    return (
        'if (!defined(' . $var . ') || ' . $var . ' !~ /^-?\d+$/) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => '.$var.','.
                                            'method_name             => "'.$self->delegate_to_method.'",'.
                                            'type_of_argument        => "integer",'.
                                            'type                    => "Int",'.
                                            'argument_noun           => "index"',
            ) . ';',
        '}',
    );
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Number::add;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . ' + $_[0]';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' += $_[0];';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Number::mod;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . ' % $_[0]';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' %= $_[0];';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Number::mul;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . ' * $_[0]';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' *= $_[0];';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Number::abs;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _maximum_arguments { 0 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'abs(' . $slot_access . ')';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' = abs(' . $slot_access . ');';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Number::div;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . ' / $_[0]';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' /= $_[0];';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Number::set;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _minimum_arguments { 1 }
sub _maximum_arguments { 1 }

sub _potential_value { '$_[0]' }

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' = $_[0];';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Number::sub;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . ' - $_[0]';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' -= $_[0];';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::insert;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Array::Writer';

sub _minimum_arguments { 2 }

sub _maximum_arguments { 2 }

sub _adds_members { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '(do { '
             . 'my @potential = @{ (' . $slot_access . ') }; '
             . 'splice @potential, $_[0], 0, $_[1]; '
             . '\@potential; '
         . '})';
}

# We need to override this because while @_ can be written to, we cannot write
# directly to $_[1].
sub _inline_coerce_new_values {
    my $self = shift;

    return unless $self->associated_attribute->should_coerce;

    return unless $self->_tc_member_type_can_coerce;

    return '@_ = ($_[0], $member_coercion->($_[1]));';
};

sub _new_members { '$_[1]' }

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return 'splice @{ (' . $slot_access . ') }, $_[0], 0, $_[1];';
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . '->[ $_[0] ]';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::Writer;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer',
     'Moose::Meta::Method::Accessor::Native::Array',
     'Moose::Meta::Method::Accessor::Native::Collection';

sub _inline_coerce_new_values {
    my $self = shift;
    $self->Moose::Meta::Method::Accessor::Native::Collection::_inline_coerce_new_values(@_);
}

sub _new_members { '@_' }

sub _copy_old_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '[ @{(' . $slot_access . ')} ]';
}

1;
package Moose::Meta::Method::Accessor::Native::Array::get;
our $VERSION = '2.2204';

use strict;
use warnings;

use Class::MOP::MiniTrait;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader',
     'Moose::Meta::Method::Accessor::Native::Array';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return $self->_inline_check_var_is_valid_index('$_[0]');
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . '->[ $_[0] ]';
}

1;
package Moose::Meta::Method::Accessor::Native::Array::count;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'scalar @{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::first_index;
our $VERSION = '2.2204';

use strict;
use warnings;

use Params::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return (
        'if (!Params::Util::_CODELIKE($_[0])) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[0],'.
                                            'method_name             => "first_index",'.
                                            'type_of_argument        => "code reference",'.
                                            'type                    => "CodeRef",',
            ) . ';',
        '}',
    );
}

sub _inline_return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return join '',
        'my @values = @{ (' . $slot_access . ') };',
        'my $f = $_[0];',
        'foreach my $i ( 0 .. $#values ) {',
            'local *_ = \\$values[$i];',
            'return $i if $f->();',
        '}',
        'return -1;';
}

# Not called, but needed to satisfy the Reader role
sub _return_value { }

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::reduce;
our $VERSION = '2.2204';

use strict;
use warnings;

use List::Util ();
use Params::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return (
        'if (!Params::Util::_CODELIKE($_[0])) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[0],'.
                                            'method_name             => "reduce",'.
                                            'type_of_argument        => "code reference",'.
                                            'type                    => "CodeRef",',
            ) . ';',
        '}',
    );
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'List::Util::reduce { $_[0]->($a, $b) } @{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::natatime;
our $VERSION = '2.2204';

use strict;
use warnings;

use Params::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 2 }

sub _inline_check_arguments {
    my $self = shift;

    return (
        'if (!defined($_[0]) || $_[0] !~ /^\d+$/) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[0],'.
                                            'method_name             => "natatime",'.
                                            'type_of_argument        => "integer",'.
                                            'type                    => "Int",'.
                                            'argument_noun           => "n value"',
            ) . ';',
        '}',
        'if (@_ == 2 && !Params::Util::_CODELIKE($_[1])) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[1],'.
                                            'method_name             => "natatime",'.
                                            'type_of_argument        => "code reference",'.
                                            'type                    => "CodeRef",'.
                                            'ordinal                 => "second"',
            ) . ';',
        '}',
    );
}

sub _inline_return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return (
        'my $step = $_[0];',
        'my @values = @{ (' . $slot_access . ') };',
        'my $iter = sub { splice @values, 0, $step };',
        'if ($_[1]) {',
            'while (my @vals = $iter->()) {',
                '$_[1]->(@vals);',
            '}',
        '}',
        'else {',
            'return $iter;',
        '}',
    );
}

# Not called, but needed to satisfy the Reader role
sub _return_value { }

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::sort_in_place;
our $VERSION = '2.2204';

use strict;
use warnings;

use Params::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Array::Writer';

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return (
        'if (@_ && !Params::Util::_CODELIKE($_[0])) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[0],'.
                                            'method_name             => "sort_in_place",'.
                                            'type_of_argument        => "code reference",'.
                                            'type                    => "CodeRef",',
            ) . ';',
        '}',
    );
}

sub _adds_members { 0 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '[ $_[0] '
             . '? sort { $_[0]->($a, $b) } @{ (' . $slot_access . ') } '
             . ': sort @{ (' . $slot_access . ') } ]';
}

sub _return_value { '' }

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::push;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Array::Writer';

sub _adds_members { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '[ @{ (' . $slot_access . ') }, @_ ]';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return 'push @{ (' . $slot_access . ') }, @_;';
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'scalar @{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::unshift;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Array::Writer';

sub _adds_members { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '[ @_, @{ (' . $slot_access . ') } ]';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return 'unshift @{ (' . $slot_access . ') }, @_;';
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'scalar @{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::accessor;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Array::set',
     'Moose::Meta::Method::Accessor::Native::Array::get';

sub _inline_process_arguments {
    my $self = shift;
    $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_process_arguments(@_);
}

sub _inline_check_arguments {
    my $self = shift;
    $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_check_arguments(@_);
}

sub _return_value {
    my $self = shift;
    $self->Moose::Meta::Method::Accessor::Native::Array::get::_return_value(@_);
}

sub _generate_method {
    my $self = shift;

    my $inv         = '$self';
    my $slot_access = $self->_get_value($inv);

    return (
        'sub {',
            'my ' . $inv . ' = shift;',
            $self->_inline_curried_arguments,
            $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
            # get
            'if (@_ == 1) {',
                $self->_inline_check_var_is_valid_index('$_[0]'),
                $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_return_value($slot_access),
            '}',
            # set
            'else {',
                $self->_inline_writer_core($inv, $slot_access),
            '}',
        '}',
    );
}

sub _minimum_arguments { 1 }
sub _maximum_arguments { 2 }

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::splice;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Array::Writer';

sub _minimum_arguments { 1 }

sub _adds_members { 1 }

sub _inline_process_arguments {
    return (
        'my $idx = shift;',
        'my $len = @_ ? shift : undef;',
    );
}

sub _inline_check_arguments {
    my $self = shift;

    return (
        $self->_inline_check_var_is_valid_index('$idx'),
        'if (defined($len) && $len !~ /^-?\d+$/) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $len,'.
                                            'method_name             => "splice",'.
                                            'type_of_argument        => "integer",'.
                                            'type                    => "Int",'.
                                            'argument_noun           => "length argument"',
            ) . ';',
        '}',
    );
}

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '(do { '
             . 'my @potential = @{ (' . $slot_access . ') }; '
             . '@return = defined $len '
                 . '? (splice @potential, $idx, $len, @_) '
                 . ': (splice @potential, $idx); '
                 . '\@potential;'
         . '})';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return (
        '@return = defined $len',
            '? (splice @{ (' . $slot_access . ') }, $idx, $len, @_)',
            ': (splice @{ (' . $slot_access . ') }, $idx);',
    );
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'wantarray ? @return : $return[-1]';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::first;
our $VERSION = '2.2204';

use strict;
use warnings;

use List::Util ();
use Params::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return (
        'if (!Params::Util::_CODELIKE($_[0])) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[0],'.
                                            'method_name             => "first",'.
                                            'type_of_argument        => "code reference",'.
                                            'type                    => "CodeRef",',
            ) . ';',
        '}',
    );
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '&List::Util::first($_[0], @{ (' . $slot_access . ') })';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::elements;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '@{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::shallow_clone;
our $VERSION = '2.2204';

use strict;
use warnings;

use Params::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _minimum_arguments { 0 }

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '[ @{ (' . $slot_access . ') } ]';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::shuffle;
our $VERSION = '2.2204';

use strict;
use warnings;

use List::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'List::Util::shuffle @{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::clear;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Array::Writer';

sub _maximum_arguments { 0 }

sub _adds_members { 0 }

sub _potential_value { '[]' }

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' = [];';
}

sub _return_value { '' }

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::set;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Array::Writer';

sub _minimum_arguments { 2 }

sub _maximum_arguments { 2 }

sub _inline_check_arguments {
    my $self = shift;

    return $self->_inline_check_var_is_valid_index('$_[0]');
}

sub _adds_members { 1 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '(do { '
             . 'my @potential = @{ (' . $slot_access . ') }; '
             . '$potential[$_[0]] = $_[1]; '
             . '\@potential; '
         . '})';
}

# We need to override this because while @_ can be written to, we cannot write
# directly to $_[1].
sub _inline_coerce_new_values {
    my $self = shift;

    return unless $self->associated_attribute->should_coerce;

    return unless $self->_tc_member_type_can_coerce;

    return '@_ = ($_[0], $member_coercion->($_[1]));';
};

sub _new_members { '$_[1]' }

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . '->[$_[0]] = $_[1];';
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . '->[$_[0]]';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::is_empty;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '@{ (' . $slot_access . ') } ? 0 : 1';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::grep;
our $VERSION = '2.2204';

use strict;
use warnings;

use Params::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return (
        'if (!Params::Util::_CODELIKE($_[0])) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[0],'.
                                            'method_name             => "grep",'.
                                            'type_of_argument        => "code reference",'.
                                            'type                    => "CodeRef",',
            ) . ';',
        '}',
    );
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'grep { $_[0]->() } @{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::sort;
our $VERSION = '2.2204';

use strict;
use warnings;

use Params::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return (
        'if (@_ && !Params::Util::_CODELIKE($_[0])) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[0],'.
                                            'method_name             => "sort",'.
                                            'type_of_argument        => "code reference",'.
                                            'type                    => "CodeRef",',
            ) . ';',
        '}',
    );
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return
        'wantarray ? ( ' .
            '$_[0] '
                . '? sort { $_[0]->($a, $b) } @{ (' . $slot_access . ') } '
                . ': sort @{ (' . $slot_access . ') }'
            . ' ) : @{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::pop;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Array::Writer';

sub _maximum_arguments { 0 }

sub _adds_members { 0 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '[ @{ (' . $slot_access . ') } > 1 '
             . '? @{ (' . $slot_access . ') }[0..$#{ (' . $slot_access . ') } - 1] '
             . ': () ]';
}

sub _inline_capture_return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'my $old = ' . $slot_access . '->[-1];';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return 'pop @{ (' . $slot_access . ') };';
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '$old';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::join;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return (
        'if (!Moose::Util::_STRINGLIKE0($_[0])) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[0],'.
                                            'method_name             => "join",'.
                                            'type_of_argument        => "string",'.
                                            'type                    => "Str",',
            ) . ';',
        '}',
    );
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'join $_[0], @{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::shift;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Array::Writer';

sub _maximum_arguments { 0 }

sub _adds_members { 0 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '[ @{ (' . $slot_access . ') } > 1 '
             . '? @{ (' . $slot_access . ') }[1..$#{ (' . $slot_access . ') }] '
             . ': () ]';
}

sub _inline_capture_return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'my $old = ' . $slot_access . '->[0];';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return 'shift @{ (' . $slot_access . ') };';
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '$old';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::map;
our $VERSION = '2.2204';

use strict;
use warnings;

use Params::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return (
        'if (!Params::Util::_CODELIKE($_[0])) {',
            $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                            'argument                => $_[0],'.
                                            'method_name             => "map",'.
                                            'type_of_argument        => "code reference",'.
                                            'type                    => "CodeRef",',
            ) . ';',
        '}',
    );
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'map { $_[0]->() } @{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::delete;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Array::Writer';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return $self->_inline_check_var_is_valid_index('$_[0]');
}

sub _adds_members { 0 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '(do { '
             . 'my @potential = @{ (' . $slot_access . ') }; '
             . '@return = splice @potential, $_[0], 1; '
             . '\@potential; '
         . '})';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return '@return = splice @{ (' . $slot_access . ') }, $_[0], 1;';
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '$return[0]';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Array::uniq;
our $VERSION = '2.2204';

use strict;
use warnings;

use List::Util 1.45 ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'List::Util::uniq @{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Code::execute;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . '->(@_)';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Code::execute_method;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return $slot_access . '->($self, @_)';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::Writer;
our $VERSION = '2.2204';

use strict;
use warnings;

use Class::MOP::MiniTrait;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Writer',
     'Moose::Meta::Method::Accessor::Native::Hash',
     'Moose::Meta::Method::Accessor::Native::Collection';

sub _inline_coerce_new_values {
    my $self = shift;

    return unless $self->associated_attribute->should_coerce;

    return unless $self->_tc_member_type_can_coerce;

    return <<'EOF';
if (@_) {
    my %h = @_;
    @h{ sort keys %h } = map { $member_coercion->($_) } @h{ sort keys %h };
}
EOF
}

sub _new_members { 'values %{ { @_ } }' }

sub _copy_old_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '{ %{ (' . $slot_access . ') } }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::get;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader',
     'Moose::Meta::Method::Accessor::Native::Hash';

sub _minimum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return (
        'for (@_) {',
            $self->_inline_check_var_is_valid_key('$_'),
        '}',
    );
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '@_ > 1 '
             . '? @{ (' . $slot_access . ') }{@_} '
             . ': ' . $slot_access . '->{$_[0]}';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::count;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'scalar keys %{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::defined;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader',
     'Moose::Meta::Method::Accessor::Native::Hash';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return $self->_inline_check_var_is_valid_key('$_[0]');
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'defined ' . $slot_access . '->{ $_[0] }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::accessor;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Hash::set',
     'Moose::Meta::Method::Accessor::Native::Hash::get';

sub _inline_process_arguments {
    my $self = shift;
    $self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_process_arguments(@_);
}

sub _inline_check_argument_count {
    my $self = shift;
    $self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_check_argument_count(@_);
}

sub _inline_check_arguments {
    my $self = shift;
    $self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_check_arguments(@_);
}

sub _return_value {
    my $self = shift;
    $self->Moose::Meta::Method::Accessor::Native::Hash::set::_return_value(@_);
}

sub _generate_method {
    my $self = shift;

    my $inv         = '$self';
    my $slot_access = $self->_get_value($inv);

    return (
        'sub {',
            'my ' . $inv . ' = shift;',
            $self->_inline_curried_arguments,
            $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
            # get
            'if (@_ == 1) {',
                $self->_inline_check_var_is_valid_key('$_[0]'),
                $slot_access . '->{$_[0]}',
            '}',
            # set
            'else {',
                $self->_inline_writer_core($inv, $slot_access),
            '}',
        '}',
    );
}

sub _minimum_arguments { 1 }
sub _maximum_arguments { 2 }

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::exists;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader',
     'Moose::Meta::Method::Accessor::Native::Hash';

sub _minimum_arguments { 1 }

sub _maximum_arguments { 1 }

sub _inline_check_arguments {
    my $self = shift;

    return $self->_inline_check_var_is_valid_key('$_[0]');
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = shift;

    return 'exists ' . $slot_access . '->{ $_[0] }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::elements;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'map { $_, ' . $slot_access . '->{$_} } '
             . 'keys %{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::shallow_clone;
our $VERSION = '2.2204';

use strict;
use warnings;

use Params::Util ();

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _minimum_arguments { 0 }

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '{ %{ (' . $slot_access . ') } }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::kv;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'map { [ $_, ' . $slot_access . '->{$_} ] } '
             . 'keys %{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::clear;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';

sub _maximum_arguments { 0 }

sub _adds_members { 0 }

# The inner () in this expression is for the benefit of inlining code that
# might end up looking like "values %{ {} }". This is a syntax error in perl
# but 'values %{ { () } }' is not.
sub _potential_value { '{ ( ) }' }

# There are no new members so we don't need to coerce new values (none exist)
# and we always want to check the new (empty) hash as a whole.
sub _inline_coerce_new_values { '' }

sub _check_new_members_only { 0 }

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return $slot_access . ' = {};';
}

sub _return_value { '' }

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::set;
our $VERSION = '2.2204';

use strict;
use warnings;

use List::Util 1.32;
use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';

sub _minimum_arguments { 2 }

sub _maximum_arguments { undef }

around _inline_check_argument_count => sub {
    my $orig = shift;
    my $self = shift;

    return (
        $self->$orig(@_),
        'if (@_ % 2) {',
            $self->_inline_throw_exception( MustPassEvenNumberOfArguments =>
                                            "method_name => '".$self->delegate_to_method."',".
                                            'args        => \@_',
            ) . ';',
        '}',
    );
};

sub _inline_process_arguments {
    my $self = shift;

    return (
        'my @keys_idx = grep { ! ($_ % 2) } 0..$#_;',
        'my @values_idx = grep { $_ % 2 } 0..$#_;',
    );
}

sub _inline_check_arguments {
    my $self = shift;

    return (
        'for (@keys_idx) {',
            'if (!defined($_[$_])) {',
                $self->_inline_throw_exception( UndefinedHashKeysPassedToMethod =>
                                                'hash_keys                       => \@keys_idx,'.
                                                "method_name                     => '".$self->delegate_to_method."'",
                ) . ';',
            '}',
        '}',
    );
}

sub _adds_members { 1 }

# We need to override this because while @_ can be written to, we cannot write
# directly to $_[1].
sub _inline_coerce_new_values {
    my $self = shift;

    return unless $self->associated_attribute->should_coerce;

    return unless $self->_tc_member_type_can_coerce;

    # Is there a simpler way to do this?
    return (
        '@_ = List::Util::pairmap { $a => $member_coercion->($b) } @_;',
    );
};

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '{ %{ (' . $slot_access . ') }, @_ }';
}

sub _new_members { '@_[ @values_idx ]' }

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return '@{ (' . $slot_access . ') }{ @_[@keys_idx] } = @_[@values_idx];';
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'wantarray '
             . '? @{ (' . $slot_access . ') }{ @_[@keys_idx] } '
             . ': ' . $slot_access . '->{ $_[$keys_idx[0]] }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::keys;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'keys %{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::is_empty;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'scalar keys %{ (' . $slot_access . ') } ? 0 : 1';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::values;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Reader';

sub _maximum_arguments { 0 }

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'values %{ (' . $slot_access . ') }';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native::Hash::delete;
our $VERSION = '2.2204';

use strict;
use warnings;

use Moose::Role;

with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';

sub _adds_members { 0 }

# There are no new members so we don't need to coerce new values (none exist)
# and we always want to check the new (empty) hash as a whole.
sub _inline_coerce_new_values { '' }

sub _check_new_members_only { 0 }

sub _potential_value {
    my $self = shift;
    my ($slot_access) = @_;

    return '(do { '
             . 'my %potential = %{ (' . $slot_access . ') }; '
             . '@return = delete @potential{@_}; '
             . '\%potential; '
         . '})';
}

sub _inline_optimized_set_new_value {
    my $self = shift;
    my ($inv, $new, $slot_access) = @_;

    return '@return = delete @{ (' . $slot_access . ') }{@_};';
}

sub _return_value {
    my $self = shift;
    my ($slot_access) = @_;

    return 'wantarray ? @return : $return[-1]';
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor::Native;
our $VERSION = '2.2204';

use strict;
use warnings;

use Carp qw( confess );
use Scalar::Util qw( blessed );

use Moose::Role;

use Moose::Util 'throw_exception';

around new => sub {
    my $orig = shift;
    my $class   = shift;
    my %options = @_;

    $options{curried_arguments} = []
        unless exists $options{curried_arguments};

    throw_exception( MustSupplyArrayRefAsCurriedArguments => params     => \%options,
                                                             class_name => $class
                   )
        unless $options{curried_arguments}
            && ref($options{curried_arguments}) eq 'ARRAY';

    my $attr_context = $options{attribute}->definition_context;
    my $desc = 'native delegation method ';
    $desc   .= $options{attribute}->associated_class->name;
    $desc   .= '::' . $options{name};
    $desc   .= " ($options{delegate_to_method})";
    $desc   .= " of attribute " . $options{attribute}->name;
    $options{definition_context} = {
        %{ $attr_context || {} },
        description => $desc,
    };

    $options{accessor_type} = 'native';

    return $class->$orig(%options);
};

sub _new {
    my $class = shift;
    my $options = @_ == 1 ? $_[0] : {@_};

    return bless $options, $class;
}

sub root_types { (shift)->{'root_types'} }

sub _initialize_body {
    my $self = shift;

    $self->{'body'} = $self->_compile_code( [$self->_generate_method] );

    return;
}

sub _inline_curried_arguments {
    my $self = shift;

    return unless @{ $self->curried_arguments };

    return 'unshift @_, @curried;';
}

sub _inline_check_argument_count {
    my $self = shift;

    my @code;

    if (my $min = $self->_minimum_arguments) {
        push @code, (
            'if (@_ < ' . $min . ') {',
                $self->_inline_throw_exception( MethodExpectsMoreArgs =>
                                                'method_name           => "'.$self->delegate_to_method.'",'.
                                                "minimum_args          => ".$min,
                ) . ';',
            '}',
        );
    }

    if (defined(my $max = $self->_maximum_arguments)) {
        push @code, (
            'if (@_ > ' . $max . ') {',
                $self->_inline_throw_exception( MethodExpectsFewerArgs =>
                                                'method_name            => "'.$self->delegate_to_method.'",'.
                                                'maximum_args           => '.$max,
                ) . ';',
            '}',
        );
    }

    return @code;
}

sub _inline_return_value {
    my $self = shift;
    my ($slot_access, $for_writer) = @_;

    return 'return ' . $self->_return_value($slot_access, $for_writer) . ';';
}

sub _minimum_arguments { 0 }
sub _maximum_arguments { undef }

override _get_value => sub {
    my $self = shift;
    my ($instance) = @_;

    return $self->_slot_access_can_be_inlined
        ? super()
        : $instance . '->$reader';
};

override _inline_store_value => sub {
    my $self = shift;
    my ($instance, $value) = @_;

    return $self->_slot_access_can_be_inlined
        ? super()
        : $instance . '->$writer(' . $value . ');';
};

override _eval_environment => sub {
    my $self = shift;

    my $env = super();

    $env->{'@curried'} = $self->curried_arguments;

    return $env if $self->_slot_access_can_be_inlined;

    my $reader = $self->associated_attribute->get_read_method_ref;
    $reader = $reader->body if blessed $reader;

    $env->{'$reader'} = \$reader;

    my $writer = $self->associated_attribute->get_write_method_ref;
    $writer = $writer->body if blessed $writer;

    $env->{'$writer'} = \$writer;

    return $env;
};

sub _slot_access_can_be_inlined {
    my $self = shift;

    return $self->is_inline && $self->_instance_is_inlinable;
}

no Moose::Role;

1;
package Moose::Meta::Method::Accessor;
our $VERSION = '2.2204';

use strict;
use warnings;

use Try::Tiny;

use parent 'Moose::Meta::Method',
         'Class::MOP::Method::Accessor';

use Moose::Util 'throw_exception';

# multiple inheritance is terrible
sub new {
    goto &Class::MOP::Method::Accessor::new;
}

sub _new {
    goto &Class::MOP::Method::Accessor::_new;
}

sub _error_thrower {
    my $self = shift;
    return $self->associated_attribute
        if ref($self) && defined($self->associated_attribute);
    return $self->SUPER::_error_thrower;
}

sub _compile_code {
    my $self = shift;
    my @args = @_;
    try {
        $self->SUPER::_compile_code(@args);
    }
    catch {
        throw_exception( CouldNotCreateWriter => attribute      => $self->associated_attribute,
                                                 error          => $_,
                                                 instance       => $self
                       );
    };
}

sub _eval_environment {
    my $self = shift;
    return $self->associated_attribute->_eval_environment;
}

sub _instance_is_inlinable {
    my $self = shift;
    return $self->associated_attribute->associated_class->instance_metaclass->is_inlinable;
}

sub _generate_reader_method {
    my $self = shift;
    $self->_instance_is_inlinable ? $self->_generate_reader_method_inline(@_)
                                  : $self->SUPER::_generate_reader_method(@_);
}

sub _generate_writer_method {
    my $self = shift;
    $self->_instance_is_inlinable ? $self->_generate_writer_method_inline(@_)
                                  : $self->SUPER::_generate_writer_method(@_);
}

sub _generate_accessor_method {
    my $self = shift;
    $self->_instance_is_inlinable ? $self->_generate_accessor_method_inline(@_)
                                  : $self->SUPER::_generate_accessor_method(@_);
}

sub _generate_predicate_method {
    my $self = shift;
    $self->_instance_is_inlinable ? $self->_generate_predicate_method_inline(@_)
                                  : $self->SUPER::_generate_predicate_method(@_);
}

sub _generate_clearer_method {
    my $self = shift;
    $self->_instance_is_inlinable ? $self->_generate_clearer_method_inline(@_)
                                  : $self->SUPER::_generate_clearer_method(@_);
}

sub _writer_value_needs_copy {
    shift->associated_attribute->_writer_value_needs_copy(@_);
}

sub _inline_tc_code {
    shift->associated_attribute->_inline_tc_code(@_);
}

sub _inline_check_coercion {
    shift->associated_attribute->_inline_check_coercion(@_);
}

sub _inline_check_constraint {
    shift->associated_attribute->_inline_check_constraint(@_);
}

sub _inline_check_lazy {
    shift->associated_attribute->_inline_check_lazy(@_);
}

sub _inline_store_value {
    shift->associated_attribute->_inline_instance_set(@_) . ';';
}

sub _inline_get_old_value_for_trigger {
    shift->associated_attribute->_inline_get_old_value_for_trigger(@_);
}

sub _inline_trigger {
    shift->associated_attribute->_inline_trigger(@_);
}

sub _get_value {
    shift->associated_attribute->_inline_instance_get(@_);
}

sub _has_value {
    shift->associated_attribute->_inline_instance_has(@_);
}

1;

# ABSTRACT: A Moose Method metaclass for accessors

package Moose::Meta::Method::Augmented;
our $VERSION = '2.2204';

use strict;
use warnings;

use parent 'Moose::Meta::Method';

use Moose::Util 'throw_exception';

sub new {
    my ( $class, %args ) = @_;

    # the package can be overridden by roles
    # it is really more like body's compilation stash
    # this is where we need to override the definition of super() so that the
    # body of the code can call the right overridden version
    my $name = $args{name};
    my $meta = $args{class};

    my $super = $meta->find_next_method_by_name($name);

    (defined $super)
        || throw_exception( CannotAugmentNoSuperMethod => params      => \%args,
                                                          class       => $class,
                                                          method_name => $name
                          );

    my $_super_package = $super->package_name;
    # BUT!,... if this is an overridden method ....
    if ($super->isa('Moose::Meta::Method::Overridden')) {
        # we need to be sure that we actually
        # find the next method, which is not
        # an 'override' method, the reason is
        # that an 'override' method will not
        # be the one calling inner()
        my $real_super = $meta->_find_next_method_by_name_which_is_not_overridden($name);
        $_super_package = $real_super->package_name;
    }

    my $super_body = $super->body;

    my $method = $args{method};

    my $body = sub {
        local $Moose::INNER_ARGS{$_super_package} = [ @_ ];
        local $Moose::INNER_BODY{$_super_package} = $method;
        $super_body->(@_);
    };

    # FIXME store additional attrs
    $class->wrap(
        $body,
        package_name => $meta->name,
        name         => $name
    );
}

1;

# ABSTRACT: A Moose Method metaclass for augmented methods

package Moose::Meta::TypeConstraint::Role;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use B;
use Moose::Util::TypeConstraints ();
use Moose::Util ();

use parent 'Moose::Meta::TypeConstraint';

__PACKAGE__->meta->add_attribute('role' => (
    reader => 'role',
    Class::MOP::_definition_context(),
));

my $inliner = sub {
    my $self = shift;
    my $val  = shift;

    return 'Moose::Util::does_role('
             . $val . ', '
             . B::perlstring($self->role)
         . ')';
};

sub new {
    my ( $class, %args ) = @_;

    $args{parent} = Moose::Util::TypeConstraints::find_type_constraint('Object');

    my $role_name = $args{role};
    $args{constraint} = sub { Moose::Util::does_role( $_[0], $role_name ) };

    $args{inlined} = $inliner;

    my $self = $class->SUPER::new( \%args );

    $self->compile_type_constraint();

    return $self;
}

sub parents {
    my $self = shift;
    return (
        $self->parent,
        map {
            # FIXME find_type_constraint might find a TC named after the role but that isn't really it
            # I did this anyway since it's a convention that preceded TypeConstraint::Role, and it should DWIM
            # if anybody thinks this problematic please discuss on IRC.
            # a possible fix is to add by attr indexing to the type registry to find types of a certain property
            # regardless of their name
            Moose::Util::TypeConstraints::find_type_constraint($_)
                ||
            __PACKAGE__->new( role => $_, name => "__ANON__" )
        } @{ Class::MOP::class_of($self->role)->get_roles },
    );
}

sub equals {
    my ( $self, $type_or_name ) = @_;

    my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);

    return unless defined $other;
    return unless $other->isa(__PACKAGE__);

    return $self->role eq $other->role;
}

sub is_a_type_of {
    my ($self, $type_or_name) = @_;

    my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);

    ($self->equals($type) || $self->is_subtype_of($type_or_name));
}

sub is_subtype_of {
    my ($self, $type_or_name_or_role ) = @_;

    if ( not ref $type_or_name_or_role ) {
        # it might be a role
        my $class = Class::MOP::class_of($self->role);
        return 1 if defined($class) && $class->does_role( $type_or_name_or_role );
    }

    my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_role);

    return unless defined $type;

    if ( $type->isa(__PACKAGE__) ) {
        # if $type_or_name_or_role isn't a role, it might be the TC name of another ::Role type
        # or it could also just be a type object in this branch
        my $class = Class::MOP::class_of($self->role);
        return defined($class) && $class->does_role( $type->role );
    } else {
        # the only other thing we are a subtype of is Object
        $self->SUPER::is_subtype_of($type);
    }
}

sub create_child_type {
    my ($self, @args) = @_;
    return Moose::Meta::TypeConstraint->new(@args, parent => $self);
}

1;

# ABSTRACT: Role/TypeConstraint parallel hierarchy

package Moose::Meta::TypeConstraint::DuckType;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use B;
use Scalar::Util 'blessed';
use List::Util 1.33 qw(all);
use Moose::Util 'english_list';

use Moose::Util::TypeConstraints ();

use parent 'Moose::Meta::TypeConstraint';

__PACKAGE__->meta->add_attribute('methods' => (
    accessor => 'methods',
    Class::MOP::_definition_context(),
));

my $inliner = sub {
    my $self = shift;
    my $val  = shift;

    return $self->parent->_inline_check($val)
         . ' && do {' . "\n"
             . 'my $val = ' . $val . ';' . "\n"
             . '&List::Util::all(' . "\n"
                 . 'sub { $val->can($_) },' . "\n"
                 . join(', ', map { B::perlstring($_) } @{ $self->methods })
             . ');' . "\n"
         . '}';
};

sub new {
    my ( $class, %args ) = @_;

    $args{parent}
        = Moose::Util::TypeConstraints::find_type_constraint('Object');

    my @methods = @{ $args{methods} };
    $args{constraint} = sub {
        my $val = $_[0];
        return all { $val->can($_) } @methods;
    };

    $args{inlined} = $inliner;

    my $self = $class->SUPER::new(\%args);

    $self->compile_type_constraint()
        unless $self->_has_compiled_type_constraint;

    return $self;
}

sub equals {
    my ( $self, $type_or_name ) = @_;

    my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);

    return unless $other->isa(__PACKAGE__);

    my @self_methods  = sort @{ $self->methods };
    my @other_methods = sort @{ $other->methods };

    return unless @self_methods == @other_methods;

    while ( @self_methods ) {
        my $method = shift @self_methods;
        my $other_method = shift @other_methods;

        return unless $method eq $other_method;
    }

    return 1;
}

sub create_child_type {
    my ($self, @args) = @_;
    return Moose::Meta::TypeConstraint->new(@args, parent => $self);
}

sub get_message {
    my $self = shift;
    my ($value) = @_;

    if ($self->has_message) {
        return $self->SUPER::get_message(@_);
    }

    return $self->SUPER::get_message($value) unless blessed($value);

    my @methods = grep { !$value->can($_) } @{ $self->methods };
    my $class = blessed $value;
    $class ||= $value;

    return $class
         . " is missing methods "
         . english_list(map { "'$_'" } @methods);
}

1;

# ABSTRACT: Type constraint for duck typing

package Moose::Meta::TypeConstraint::Registry;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use Scalar::Util 'blessed';

use parent 'Class::MOP::Object';

use Moose::Util 'throw_exception';

__PACKAGE__->meta->add_attribute('parent_registry' => (
    reader    => 'get_parent_registry',
    writer    => 'set_parent_registry',
    predicate => 'has_parent_registry',
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('type_constraints' => (
    reader  => 'type_constraints',
    default => sub { {} },
    Class::MOP::_definition_context(),
));

sub new {
    my $class = shift;
    my $self  = $class->_new(@_);
    return $self;
}

sub has_type_constraint {
    my ($self, $type_name) = @_;
    ($type_name and exists $self->type_constraints->{$type_name}) ? 1 : 0
}

sub get_type_constraint {
    my ($self, $type_name) = @_;
    return unless defined $type_name;
    $self->type_constraints->{$type_name}
}

sub add_type_constraint {
    my ($self, $type) = @_;

    unless ( $type && blessed $type && $type->isa('Moose::Meta::TypeConstraint') ) {
        throw_exception( InvalidTypeConstraint => registry_object => $self,
                                                  type            => $type
                       );
    }

    $self->type_constraints->{$type->name} = $type;
}

sub find_type_constraint {
    my ($self, $type_name) = @_;
    return $self->get_type_constraint($type_name)
        if $self->has_type_constraint($type_name);
    return $self->get_parent_registry->find_type_constraint($type_name)
        if $self->has_parent_registry;
    return;
}

1;

# ABSTRACT: registry for type constraints

package Moose::Meta::TypeConstraint::Parameterizable;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use parent 'Moose::Meta::TypeConstraint';
use Moose::Meta::TypeConstraint::Parameterized;
use Moose::Util::TypeConstraints ();

use Moose::Util 'throw_exception';

use Carp 'confess';

__PACKAGE__->meta->add_attribute('constraint_generator' => (
    accessor  => 'constraint_generator',
    predicate => 'has_constraint_generator',
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('inline_generator' => (
    accessor  => 'inline_generator',
    predicate => 'has_inline_generator',
    Class::MOP::_definition_context(),
));

sub generate_constraint_for {
    my ($self, $type) = @_;

    return unless $self->has_constraint_generator;

    return $self->constraint_generator->($type->type_parameter)
        if $type->is_subtype_of($self->name);

    return $self->_can_coerce_constraint_from($type)
        if $self->has_coercion
        && $self->coercion->has_coercion_for_type($type->parent->name);

    return;
}

sub _can_coerce_constraint_from {
    my ($self, $type) = @_;
    my $coercion   = $self->coercion;
    my $constraint = $self->constraint_generator->($type->type_parameter);
    return sub {
        local $_ = $coercion->coerce($_);
        $constraint->(@_);
    };
}

sub generate_inline_for {
    my ($self, $type, $val) = @_;

    throw_exception( CannotGenerateInlineConstraint => parameterizable_type_object_name => $self->name,
                                                       type_name                        => $type->name,
                                                       value                            => $val,
                   )
        unless $self->has_inline_generator;

    return '( do { ' . $self->inline_generator->( $self, $type, $val ) . ' } )';
}

sub _parse_type_parameter {
    my ($self, $type_parameter) = @_;
    return Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($type_parameter);
}

sub parameterize {
    my ($self, $type_parameter) = @_;

    my $contained_tc = $self->_parse_type_parameter($type_parameter);

    ## The type parameter should be a subtype of the parent's type parameter
    ## if there is one.

    if(my $parent = $self->parent) {
        if($parent->can('type_parameter')) {
            unless ( $contained_tc->is_a_type_of($parent->type_parameter) ) {
                throw_exception( ParameterIsNotSubtypeOfParent => type_parameter => $type_parameter,
                                                                  type_name      => $self->name,
                               );
            }
        }
    }

    if ( $contained_tc->isa('Moose::Meta::TypeConstraint') ) {
        my $tc_name = $self->name . '[' . $contained_tc->name . ']';
        return Moose::Meta::TypeConstraint::Parameterized->new(
            name               => $tc_name,
            parent             => $self,
            type_parameter     => $contained_tc,
            parameterized_from => $self,
        );
    }
    else {
        confess("The type parameter must be a Moose meta type");
    }
}


1;

# ABSTRACT: Type constraints which can take a parameter (ArrayRef)

package Moose::Meta::TypeConstraint::Parameterized;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use Scalar::Util 'blessed';
use Moose::Util::TypeConstraints;
use Moose::Meta::TypeConstraint::Parameterizable;
use Moose::Util 'throw_exception';

use parent 'Moose::Meta::TypeConstraint';

__PACKAGE__->meta->add_attribute('type_parameter' => (
    accessor  => 'type_parameter',
    predicate => 'has_type_parameter',
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('parameterized_from' => (
    accessor   => 'parameterized_from',
    predicate  => 'has_parameterized_from',
    Class::MOP::_definition_context(),
));

sub equals {
    my ( $self, $type_or_name ) = @_;

    my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);

    return unless $other->isa(__PACKAGE__);

    return (
        $self->type_parameter->equals( $other->type_parameter )
            and
        $self->parent->equals( $other->parent )
    );
}

sub compile_type_constraint {
    my $self = shift;

    unless ( $self->has_type_parameter ) {
        throw_exception( CannotCreateHigherOrderTypeWithoutATypeParameter => type_name => $self->name );
    }

    my $type_parameter = $self->type_parameter;

    unless ( blessed $type_parameter && $type_parameter->isa('Moose::Meta::TypeConstraint') ) {
        throw_exception( TypeParameterMustBeMooseMetaType => type_name => $self->name );
    }

    foreach my $type (Moose::Util::TypeConstraints::get_all_parameterizable_types()) {
        if (my $constraint = $type->generate_constraint_for($self)) {
            $self->_set_constraint($constraint);
            return $self->SUPER::compile_type_constraint;
        }
    }

    # if we get here, then we couldn't
    # find a way to parameterize this type
    throw_exception( TypeConstraintCannotBeUsedForAParameterizableType => type_name        => $self->name,
                                                                          parent_type_name => $self->parent->name,
                   );
}

sub can_be_inlined {
    my $self = shift;

    return
           $self->has_parameterized_from
        && $self->parameterized_from->has_inline_generator
        && $self->type_parameter->can_be_inlined;
}

sub inline_environment {
    my $self = shift;

    return {
        ($self->has_parameterized_from
            ? (%{ $self->parameterized_from->inline_environment })
            : ()),
        ($self->has_type_parameter
            ? (%{ $self->type_parameter->inline_environment })
            : ()),
    };
}

sub _inline_check {
    my $self = shift;

    return unless $self->can_be_inlined;

    return $self->parameterized_from->generate_inline_for( $self->type_parameter, @_ );
}

sub create_child_type {
    my ($self, %opts) = @_;
    return Moose::Meta::TypeConstraint::Parameterizable->new(%opts, parent=>$self);
}

1;

# ABSTRACT: Type constraints with a bound parameter (ArrayRef[Int])

package Moose::Meta::TypeConstraint::Enum;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use B;
use Moose::Util::TypeConstraints ();

use parent 'Moose::Meta::TypeConstraint';

use Moose::Util 'throw_exception';

__PACKAGE__->meta->add_attribute('values' => (
    accessor => 'values',
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('_inline_var_name' => (
    accessor => '_inline_var_name',
    Class::MOP::_definition_context(),
));

my $inliner = sub {
    my $self = shift;
    my $val  = shift;

    return 'defined(' . $val . ') '
             . '&& !ref(' . $val . ') '
             . '&& $' . $self->_inline_var_name . '{' . $val . '}';
};

my $var_suffix = 0;

sub new {
    my ( $class, %args ) = @_;

    $args{parent} = Moose::Util::TypeConstraints::find_type_constraint('Str');
    $args{inlined} = $inliner;

    if ( scalar @{ $args{values} } < 1 ) {
        throw_exception( MustHaveAtLeastOneValueToEnumerate => params => \%args,
                                                               class  => $class
                       );
    }

    for (@{ $args{values} }) {
        if (!defined($_)) {
            throw_exception( EnumValuesMustBeString => params => \%args,
                                                       class  => $class,
                                                       value  => $_
                           );
        }
        elsif (ref($_)) {
            throw_exception( EnumValuesMustBeString => params => \%args,
                                                       class  => $class,
                                                       value  => $_
                           );
        }
    }

    my %values = map { $_ => 1 } @{ $args{values} };
    $args{constraint} = sub { $values{ $_[0] } };

    my $var_name = 'enums' . $var_suffix++;;
    $args{_inline_var_name} = $var_name;
    $args{inline_environment} = { '%' . $var_name => \%values };

    my $self = $class->SUPER::new(\%args);

    $self->compile_type_constraint()
        unless $self->_has_compiled_type_constraint;

    $self->message( sub {
        my $value = shift;
        sprintf(
            '%s. Value must be equal to %s.',
            $self->_default_message->( $value ),
            Moose::Util::_english_list_or( map B::perlstring($_), @{ $self->values } ),
        )
    } );

    return $self;
}

sub equals {
    my ( $self, $type_or_name ) = @_;

    my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);

    return unless $other->isa(__PACKAGE__);

    my @self_values  = sort @{ $self->values };
    my @other_values = sort @{ $other->values };

    return unless @self_values == @other_values;

    while ( @self_values ) {
        my $value = shift @self_values;
        my $other_value = shift @other_values;

        return unless $value eq $other_value;
    }

    return 1;
}

sub constraint {
    my $self = shift;

    my %values = map { $_ => undef } @{ $self->values };

    return sub { exists $values{$_[0]} };
}

sub create_child_type {
    my ($self, @args) = @_;
    return Moose::Meta::TypeConstraint->new(@args, parent => $self);
}

1;

# ABSTRACT: Type constraint for enumerated values.

package Moose::Meta::TypeConstraint::Class;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use B;
use Scalar::Util ();
use Moose::Util::TypeConstraints ();

use parent 'Moose::Meta::TypeConstraint';

__PACKAGE__->meta->add_attribute('class' => (
    reader => 'class',
    Class::MOP::_definition_context(),
));

my $inliner = sub {
    my $self = shift;
    my $val  = shift;

    return 'Scalar::Util::blessed(' . $val . ')'
             . ' && ' . $val . '->isa(' . B::perlstring($self->class) . ')';
};

sub new {
    my ( $class, %args ) = @_;

    $args{parent}
        = Moose::Util::TypeConstraints::find_type_constraint('Object');

    my $class_name = $args{class};
    $args{constraint} = sub { $_[0]->isa($class_name) };

    $args{inlined} = $inliner;

    my $self = $class->SUPER::new( \%args );

    $self->compile_type_constraint();

    return $self;
}

sub parents {
    my $self = shift;
    return (
        $self->parent,
        map {
            # FIXME find_type_constraint might find a TC named after the class but that isn't really it
            # I did this anyway since it's a convention that preceded TypeConstraint::Class, and it should DWIM
            # if anybody thinks this problematic please discuss on IRC.
            # a possible fix is to add by attr indexing to the type registry to find types of a certain property
            # regardless of their name
            Moose::Util::TypeConstraints::find_type_constraint($_)
                ||
            __PACKAGE__->new( class => $_, name => "__ANON__" )
        } Class::MOP::class_of($self->class)->superclasses,
    );
}

sub equals {
    my ( $self, $type_or_name ) = @_;

    my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);

    if (!defined($other)) {
        if (!ref($type_or_name)) {
            return $self->class eq $type_or_name;
        }
        return;
    }

    return unless $other->isa(__PACKAGE__);

    return $self->class eq $other->class;
}

sub is_a_type_of {
    my ($self, $type_or_name) = @_;

    ($self->equals($type_or_name) || $self->is_subtype_of($type_or_name));
}

sub is_subtype_of {
    my ($self, $type_or_name_or_class ) = @_;

    my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_class);

    if ( not defined $type ) {
        if ( not ref $type_or_name_or_class ) {
            # it might be a class
            my $class = $self->class;
            return 1 if $class ne $type_or_name_or_class
                     && $class->isa( $type_or_name_or_class );
        }
        return;
    }

    if ( $type->isa(__PACKAGE__) && $type->class ne $self->class) {
        # if $type_or_name_or_class isn't a class, it might be the TC name of another ::Class type
        # or it could also just be a type object in this branch
        return $self->class->isa( $type->class );
    } else {
        # the only other thing we are a subtype of is Object
        $self->SUPER::is_subtype_of($type);
    }
}

# This is a bit counter-intuitive, but a child type of a Class type
# constraint is not itself a Class type constraint (it has no class
# attribute). This whole create_child_type thing needs some changing
# though, probably making MMC->new a factory or something.
sub create_child_type {
    my ($self, @args) = @_;
    return Moose::Meta::TypeConstraint->new(@args, parent => $self);
}

sub get_message {
    my $self = shift;
    my ($value) = @_;

    if ($self->has_message) {
        return $self->SUPER::get_message(@_);
    }

    $value = (defined $value ? overload::StrVal($value) : 'undef');
    return "Validation failed for '" . $self->name . "' with value $value (not isa " . $self->class . ")";
}

1;

# ABSTRACT: Class/TypeConstraint parallel hierarchy

package Moose::Meta::TypeConstraint::Union;
our $VERSION = '2.2204';

use strict;
use warnings;
use metaclass;

use Moose::Meta::TypeCoercion::Union;

use List::Util 1.33 qw(first all);

use parent 'Moose::Meta::TypeConstraint';

__PACKAGE__->meta->add_attribute('type_constraints' => (
    accessor  => 'type_constraints',
    default   => sub { [] },
    Class::MOP::_definition_context(),
));

sub new {
    my ($class, %options) = @_;

    my $name = join '|' => sort { $a cmp $b }
        map { $_->name } @{ $options{type_constraints} };

    my $self = $class->SUPER::new(
        name => $name,
        %options,
    );

    $self->_set_constraint( $self->_compiled_type_constraint );

    return $self;
}

# XXX - this is a rather gross implementation of laziness for the benefit of
# MX::Types. If we try to call ->has_coercion on the objects during object
# construction, this does not work when defining a recursive constraint with
# MX::Types.
sub coercion {
    my $self = shift;

    return $self->{coercion} if exists $self->{coercion};

    # Using any instead of grep here causes a weird error with some corner
    # cases when MX::Types is in use. See RT #61001.
    if ( grep { $_->has_coercion } @{ $self->type_constraints } ) {
        return $self->{coercion} = Moose::Meta::TypeCoercion::Union->new(
            type_constraint => $self );
    }
    else {
        return $self->{coercion} = undef;
    }
}

sub has_coercion {
    return defined $_[0]->coercion;
}

sub _actually_compile_type_constraint {
    my $self = shift;

    my @constraints = @{ $self->type_constraints };

    return sub {
        my $value = shift;
        foreach my $type (@constraints) {
            return 1 if $type->check($value);
        }
        return undef;
    };
}

sub can_be_inlined {
    my $self = shift;

    # This was originally done with all() from List::MoreUtils, but that
    # caused some sort of bizarro parsing failure under 5.10.
    for my $tc ( @{ $self->type_constraints } ) {
        return 0 unless $tc->can_be_inlined;
    }

    return 1;
}

sub _inline_check {
    my $self = shift;
    my $val  = shift;

    return '('
               . (
                  join ' || ', map { '(' . $_->_inline_check($val) . ')' }
                  @{ $self->type_constraints }
                 )
           . ')';
}

sub inline_environment {
    my $self = shift;

    return { map { %{ $_->inline_environment } }
            @{ $self->type_constraints } };
}

sub equals {
    my ( $self, $type_or_name ) = @_;

    my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);

    return unless $other->isa(__PACKAGE__);

    my @self_constraints  = @{ $self->type_constraints };
    my @other_constraints = @{ $other->type_constraints };

    return unless @self_constraints == @other_constraints;

    # FIXME presort type constraints for efficiency?
    constraint: foreach my $constraint ( @self_constraints ) {
        for ( my $i = 0; $i < @other_constraints; $i++ ) {
            if ( $constraint->equals($other_constraints[$i]) ) {
                splice @other_constraints, $i, 1;
                next constraint;
            }
        }
    }

    return @other_constraints == 0;
}

sub parent {
    my $self = shift;

    my ($first, @rest) = @{ $self->type_constraints };

    for my $parent ( $first->_collect_all_parents ) {
        return $parent if all { $_->is_a_type_of($parent) } @rest;
    }

    return;
}

sub validate {
    my ($self, $value) = @_;
    my $message;
    foreach my $type (@{$self->type_constraints}) {
        my $err = $type->validate($value);
        return unless defined $err;
        $message .= ($message ? ' and ' : '') . $err
            if defined $err;
    }
    return ($message . ' in (' . $self->name . ')') ;
}

sub find_type_for {
    my ($self, $value) = @_;

    return first { $_->check($value) } @{ $self->type_constraints };
}

sub is_a_type_of {
    my ($self, $type_name) = @_;

    return all { $_->is_a_type_of($type_name) } @{ $self->type_constraints };
}

sub is_subtype_of {
    my ($self, $type_name) = @_;

    return all { $_->is_subtype_of($type_name) } @{ $self->type_constraints };
}

sub create_child_type {
    my ( $self, %opts ) = @_;

    my $constraint
        = Moose::Meta::TypeConstraint->new( %opts, parent => $self );

    # if we have a type constraint union, and no
    # type check, this means we are just aliasing
    # the union constraint, which means we need to
    # handle this differently.
    # - SL
    if ( not( defined $opts{constraint} )
        && $self->has_coercion ) {
        $constraint->coercion(
            Moose::Meta::TypeCoercion::Union->new(
                type_constraint => $self,
            )
        );
    }

    return $constraint;
}

1;

# ABSTRACT: A union of Moose type constraints

use strict;
use warnings;
package Moose::Meta::Attribute;
our $VERSION = '2.2204';

use B ();
use Scalar::Util 'blessed';
use List::Util 1.33 'any';
use Try::Tiny;
use overload     ();

use Moose::Deprecated;
use Moose::Meta::Method::Accessor;
use Moose::Meta::Method::Delegation;
use Moose::Util 'throw_exception';
use Moose::Util::TypeConstraints ();
use Class::MOP::MiniTrait;

use parent 'Class::MOP::Attribute', 'Moose::Meta::Mixin::AttributeCore';

use Carp 'confess';

Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');

__PACKAGE__->meta->add_attribute('traits' => (
    reader    => 'applied_traits',
    predicate => 'has_applied_traits',
    Class::MOP::_definition_context(),
));

__PACKAGE__->meta->add_attribute('role_attribute' => (
    reader    => 'role_attribute',
    predicate => 'has_role_attribute',
    Class::MOP::_definition_context(),
));

# we need to have a ->does method in here to
# more easily support traits, and the introspection
# of those traits. We extend the does check to look
# for metatrait aliases.
sub does {
    my ($self, $role_name) = @_;
    my $name = try {
        Moose::Util::resolve_metatrait_alias(Attribute => $role_name)
    };
    return 0 if !defined($name); # failed to load class
    return $self->Moose::Object::does($name);
}

sub _inline_throw_exception {
    my ( $self, $exception_type, $throw_args ) = @_;
    return 'die Module::Runtime::use_module("Moose::Exception::' . $exception_type . '")->new(' . ($throw_args || '') . ')';
}

sub new {
    my ($class, $name, %options) = @_;
    $class->_process_options($name, \%options) unless $options{__hack_no_process_options}; # used from clone()... YECHKKK FIXME ICKY YUCK GROSS

    delete $options{__hack_no_process_options};

    my %attrs =
        ( map { $_ => 1 }
          grep { defined }
          map { $_->init_arg() }
          $class->meta()->get_all_attributes()
        );

    my @bad = sort grep { ! $attrs{$_} }  keys %options;

    if (@bad)
    {
        my $s = @bad > 1 ? 's' : '';
        my $list = join "', '", @bad;

        my $package = $options{definition_context}{package};
        my $context = $options{definition_context}{context}
                   || 'attribute constructor';
        my $type = $options{definition_context}{type} || 'class';

        my $location = '';
        if (defined($package)) {
            $location = " in ";
            $location .= "$type " if $type;
            $location .= $package;
        }

        Carp::cluck "Found unknown argument$s '$list' in the $context for '$name'$location";
    }

    return $class->SUPER::new($name, %options);
}

sub interpolate_class_and_new {
    my $class = shift;
    my $name  = shift;

    throw_exception( MustPassEvenNumberOfAttributeOptions => attribute_name => $name,
                                                             options        => \@_
                   )
        if @_ % 2 == 1;

    my %args = @_;

    my ( $new_class, @traits ) = $class->interpolate_class(\%args);
    $new_class->new($name, %args, ( scalar(@traits) ? ( traits => \@traits ) : () ) );
}

sub interpolate_class {
    my ($class, $options) = @_;

    $class = ref($class) || $class;

    if ( my $metaclass_name = delete $options->{metaclass} ) {
        my $new_class = Moose::Util::resolve_metaclass_alias( Attribute => $metaclass_name );

        if ( $class ne $new_class ) {
            if ( $new_class->can("interpolate_class") ) {
                return $new_class->interpolate_class($options);
            } else {
                $class = $new_class;
            }
        }
    }

    my @traits;

    if (my $traits = $options->{traits}) {
        my $i = 0;
        my $has_foreign_options = 0;

        while ($i < @$traits) {
            my $trait = $traits->[$i++];
            next if ref($trait); # options to a trait we discarded

            $trait = Moose::Util::resolve_metatrait_alias(Attribute => $trait)
                  || $trait;

            next if $class->does($trait);

            push @traits, $trait;

            # are there options?
            if ($traits->[$i] && ref($traits->[$i])) {
                $has_foreign_options = 1
                    if any { $_ ne '-alias' && $_ ne '-excludes' } keys %{ $traits->[$i] };

                push @traits, $traits->[$i++];
            }
        }

        if (@traits) {
            my %options = (
                superclasses => [ $class ],
                roles        => [ @traits ],
            );

            if ($has_foreign_options) {
                $options{weaken} = 0;
            }
            else {
                $options{cache} = 1;
            }

            my $anon_class = Moose::Meta::Class->create_anon_class(%options);
            $class = $anon_class->name;
        }
    }

    return ( wantarray ? ( $class, @traits ) : $class );
}

# ...

# method-generating options shouldn't be overridden
sub illegal_options_for_inheritance {
    qw(reader writer accessor clearer predicate)
}

# NOTE/TODO
# This method *must* be able to handle
# Class::MOP::Attribute instances as
# well. Yes, I know that is wrong, but
# apparently we didn't realize it was
# doing that and now we have some code
# which is dependent on it. The real
# solution of course is to push this
# feature back up into Class::MOP::Attribute
# but I not right now, I am too lazy.
# However if you are reading this and
# looking for something to do,.. please
# be my guest.
# - stevan
sub clone_and_inherit_options {
    my ($self, %options) = @_;

    # NOTE:
    # we may want to extends a Class::MOP::Attribute
    # in which case we need to be able to use the
    # core set of legal options that have always
    # been here. But we allows Moose::Meta::Attribute
    # instances to changes them.
    # - SL
    my @illegal_options = $self->can('illegal_options_for_inheritance')
        ? $self->illegal_options_for_inheritance
        : ();

    my @found_illegal_options = grep { exists $options{$_} && exists $self->{$_} ? $_ : undef } @illegal_options;
    (scalar @found_illegal_options == 0)
        || throw_exception( IllegalInheritedOptions => illegal_options => \@found_illegal_options,
                                                       params          => \%options
                          );

    $self->_process_isa_option( $self->name, \%options );
    $self->_process_does_option( $self->name, \%options );

    # NOTE:
    # this doesn't apply to Class::MOP::Attributes,
    # so we can ignore it for them.
    # - SL
    if ($self->can('interpolate_class')) {
        ( $options{metaclass}, my @traits ) = $self->interpolate_class(\%options);

        my %seen;
        my @all_traits = grep { $seen{$_}++ } @{ $self->applied_traits || [] }, @traits;
        $options{traits} = \@all_traits if @all_traits;
    }

    # This method can be called on a CMOP::Attribute object, so we need to
    # make sure we can call this method.
    $self->_process_lazy_build_option( $self->name, \%options )
        if $self->can('_process_lazy_build_option');

    $self->clone(%options);
}

sub clone {
    my ( $self, %params ) = @_;

    my $class = delete $params{metaclass} || ref $self;

    my ( @init, @non_init );

    foreach my $attr ( grep { $_->has_value($self) } Class::MOP::class_of($self)->get_all_attributes ) {
        push @{ $attr->has_init_arg ? \@init : \@non_init }, $attr;
    }

    my %new_params = ( ( map { $_->init_arg => $_->get_value($self) } @init ), %params );

    my $name = delete $new_params{name};

    my $clone = $class->new($name, %new_params, __hack_no_process_options => 1 );

    foreach my $attr ( @non_init ) {
        $attr->set_value($clone, $attr->get_value($self));
    }

    return $clone;
}

sub _process_options {
    my ( $class, $name, $options ) = @_;

    $class->_process_is_option( $name, $options );
    $class->_process_isa_option( $name, $options );
    $class->_process_does_option( $name, $options );
    $class->_process_coerce_option( $name, $options );
    $class->_process_trigger_option( $name, $options );
    $class->_process_auto_deref_option( $name, $options );
    $class->_process_lazy_build_option( $name, $options );
    $class->_process_lazy_option( $name, $options );
    $class->_process_required_option( $name, $options );
}

sub _process_is_option {
    my ( $class, $name, $options ) = @_;

    return unless $options->{is};

    ### -------------------------
    ## is => ro, writer => _foo    # turns into (reader => foo, writer => _foo) as before
    ## is => rw, writer => _foo    # turns into (reader => foo, writer => _foo)
    ## is => rw, accessor => _foo  # turns into (accessor => _foo)
    ## is => ro, accessor => _foo  # error, accesor is rw
    ### -------------------------

    if ( $options->{is} eq 'ro' ) {
        throw_exception("AccessorMustReadWrite" => attribute_name => $name,
                                                   params         => $options,
                       )
            if exists $options->{accessor};
        $options->{reader} ||= $name;
    }
    elsif ( $options->{is} eq 'rw' ) {
        if ( ! $options->{accessor} ) {
            if ( $options->{writer}) {
                $options->{reader} ||= $name;
            }
            else {
                $options->{accessor} = $name;
            }
        }
    }
    elsif ( $options->{is} eq 'bare' ) {
        return;
        # do nothing, but don't complain (later) about missing methods
    }
    else {
        throw_exception( InvalidValueForIs => attribute_name => $name,
                                              params         => $options,
                       );
    }
}

sub _process_isa_option {
    my ( $class, $name, $options ) = @_;

    return unless exists $options->{isa};

    if ( exists $options->{does} ) {
        if ( try { $options->{isa}->can('does') } ) {
            ( $options->{isa}->does( $options->{does} ) )
                || throw_exception( IsaDoesNotDoTheRole => attribute_name => $name,
                                                           params         => $options,
                                  );
        }
        else {
            throw_exception( IsaLacksDoesMethod => attribute_name => $name,
                                                   params         => $options,
                           );
        }
    }

    # allow for anon-subtypes here ...
    #
    # There are a _lot_ of methods that we expect from TC objects, but
    # checking for a specific parent class via ->isa is gross, so we'll check
    # for at least one method.
    if ( blessed( $options->{isa} )
        && $options->{isa}->can('has_coercion') ) {

        $options->{type_constraint} = $options->{isa};
    }
    else {
        $options->{type_constraint}
            = Moose::Util::TypeConstraints::find_or_create_isa_type_constraint(
            $options->{isa},
            { package_defined_in => $options->{definition_context}->{package} }
        );
    }
}

sub _process_does_option {
    my ( $class, $name, $options ) = @_;

    return unless exists $options->{does} && ! exists $options->{isa};

    # allow for anon-subtypes here ...
    if ( blessed( $options->{does} )
        && $options->{does}->can('has_coercion') ) {

        $options->{type_constraint} = $options->{does};
    }
    else {
        $options->{type_constraint}
            = Moose::Util::TypeConstraints::find_or_create_does_type_constraint(
            $options->{does},
            { package_defined_in => $options->{definition_context}->{package} }
        );
    }
}

sub _process_coerce_option {
    my ( $class, $name, $options ) = @_;

    return unless $options->{coerce};

    ( exists $options->{type_constraint} )
        || throw_exception( CoercionNeedsTypeConstraint => attribute_name => $name,
                                                           params         => $options,
                          );

    throw_exception( CannotCoerceAWeakRef => attribute_name => $name,
                                             params         => $options,
                   )
        if $options->{weak_ref};

    unless ( $options->{type_constraint}->has_coercion ) {
        my $type = $options->{type_constraint}->name;

        throw_exception( CannotCoerceAttributeWhichHasNoCoercion => attribute_name => $name,
                                                                    type_name      => $type,
                                                                    params         => $options
                       );
    }
}

sub _process_trigger_option {
    my ( $class, $name, $options ) = @_;

    return unless exists $options->{trigger};

    ( 'CODE' eq ref $options->{trigger} )
        || throw_exception( TriggerMustBeACodeRef => attribute_name => $name,
                                                     params         => $options,
                          );
}

sub _process_auto_deref_option {
    my ( $class, $name, $options ) = @_;

    return unless $options->{auto_deref};

    ( exists $options->{type_constraint} )
        || throw_exception( CannotAutoDerefWithoutIsa => attribute_name => $name,
                                                         params         => $options,
                          );

    ( $options->{type_constraint}->is_a_type_of('ArrayRef')
      || $options->{type_constraint}->is_a_type_of('HashRef') )
        || throw_exception( AutoDeRefNeedsArrayRefOrHashRef => attribute_name => $name,
                                                               params         => $options,
                          );
}

sub _process_lazy_build_option {
    my ( $class, $name, $options ) = @_;

    return unless $options->{lazy_build};

    throw_exception( CannotUseLazyBuildAndDefaultSimultaneously => attribute_name => $name,
                                                                   params         => $options,
                   )
        if exists $options->{default};

    $options->{lazy} = 1;
    $options->{builder} ||= "_build_${name}";

    if ( $name =~ /^_/ ) {
        $options->{clearer}   ||= "_clear${name}";
        $options->{predicate} ||= "_has${name}";
    }
    else {
        $options->{clearer}   ||= "clear_${name}";
        $options->{predicate} ||= "has_${name}";
    }
}

sub _process_lazy_option {
    my ( $class, $name, $options ) = @_;

    return unless $options->{lazy};

    ( exists $options->{default} || defined $options->{builder} )
        || throw_exception( LazyAttributeNeedsADefault => params         => $options,
                                                          attribute_name => $name,
                          );
}

sub _process_required_option {
    my ( $class, $name, $options ) = @_;

    if (
        $options->{required}
        && !(
            ( !exists $options->{init_arg} || defined $options->{init_arg} )
            || exists $options->{default}
            || defined $options->{builder}
        )
        ) {
        throw_exception( RequiredAttributeNeedsADefault => params         => $options,
                                                           attribute_name => $name,
                       );
    }
}

sub initialize_instance_slot {
    my ($self, $meta_instance, $instance, $params) = @_;
    my $init_arg = $self->init_arg();
    # try to fetch the init arg from the %params ...

    my $val;
    my $value_is_set;
    if ( defined($init_arg) and exists $params->{$init_arg}) {
        $val = $params->{$init_arg};
        $value_is_set = 1;
    }
    else {
        # skip it if it's lazy
        return if $self->is_lazy;
        # and die if it's required and doesn't have a default value
        my $class_name = blessed( $instance );
        throw_exception(
            'AttributeIsRequired',
            attribute_name => $self->name,
            ( defined $init_arg ? ( attribute_init_arg => $init_arg ) : () ),
            class_name => $class_name,
            params     => $params,
            )
            if $self->is_required
            && !$self->has_default
            && !$self->has_builder;

        # if nothing was in the %params, we can use the
        # attribute's default value (if it has one)
        if ($self->has_default) {
            $val = $self->default($instance);
            $value_is_set = 1;
        }
        elsif ($self->has_builder) {
            $val = $self->_call_builder($instance);
            $value_is_set = 1;
        }
    }

    return unless $value_is_set;

    $val = $self->_coerce_and_verify( $val, $instance );

    $self->set_initial_value($instance, $val);

    if ( ref $val && $self->is_weak_ref ) {
        $self->_weaken_value($instance);
    }
}

sub _call_builder {
    my ( $self, $instance ) = @_;

    my $builder = $self->builder();

    return $instance->$builder()
        if $instance->can( $self->builder );

    throw_exception( BuilderDoesNotExist => instance  => $instance,
                                            attribute => $self,
                   );
}

## Slot management

sub _make_initializer_writer_callback {
    my $self = shift;
    my ($meta_instance, $instance, $slot_name) = @_;
    my $old_callback = $self->SUPER::_make_initializer_writer_callback(@_);
    return sub {
        $old_callback->($self->_coerce_and_verify($_[0], $instance));
    };
}

sub set_value {
    my ($self, $instance, @args) = @_;
    my $value = $args[0];

    my $class_name = blessed( $instance );
    if ($self->is_required and not @args) {
        throw_exception(
            'AttributeIsRequired',
            attribute_name => $self->name,
            (
                defined $self->init_arg
                ? ( attribute_init_arg => $self->init_arg )
                : ()
            ),
            class_name => $class_name,
        );
    }

    $value = $self->_coerce_and_verify( $value, $instance );

    my @old;
    if ( $self->has_trigger && $self->has_value($instance) ) {
        @old = $self->get_value($instance, 'for trigger');
    }

    $self->SUPER::set_value($instance, $value);

    if ( ref $value && $self->is_weak_ref ) {
        $self->_weaken_value($instance);
    }

    if ($self->has_trigger) {
        $self->trigger->($instance, $value, @old);
    }
}

sub _inline_set_value {
    my $self = shift;
    my ($instance, $value, $tc, $coercion, $message, $for_constructor) = @_;

    my $old     = '@old';
    my $copy    = '$val';
    $tc       ||= '$type_constraint';
    $coercion ||= '$type_coercion';
    $message  ||= '$type_message';

    my @code;
    if ($self->_writer_value_needs_copy) {
        push @code, $self->_inline_copy_value($value, $copy);
        $value = $copy;
    }

    # constructors already handle required checks
    push @code, $self->_inline_check_required
        unless $for_constructor;

    push @code, $self->_inline_tc_code($value, $tc, $coercion, $message);

    # constructors do triggers all at once at the end
    push @code, $self->_inline_get_old_value_for_trigger($instance, $old)
        unless $for_constructor;

    push @code, (
        $self->SUPER::_inline_set_value($instance, $value),
        $self->_inline_weaken_value($instance, $value),
    );

    # constructors do triggers all at once at the end
    push @code, $self->_inline_trigger($instance, $value, $old)
        unless $for_constructor;

    return @code;
}

sub _writer_value_needs_copy {
    my $self = shift;
    return $self->should_coerce;
}

sub _inline_copy_value {
    my $self = shift;
    my ($value, $copy) = @_;

    return 'my ' . $copy . ' = ' . $value . ';'
}

sub _inline_check_required {
    my $self = shift;

    return unless $self->is_required;

    my $throw_params = sprintf( <<'EOF', quotemeta( $self->name ) );
attribute_name => "%s",
class_name     => $class_name,
EOF
    $throw_params .= sprintf(
        'attribute_init_arg => "%s",',
        quotemeta( $self->init_arg )
    ) if defined $self->init_arg;

    my $throw = $self->_inline_throw_exception(
        'AttributeIsRequired',
        $throw_params
    );

    return sprintf( <<'EOF', $throw );
if ( @_ < 2 ) {
    %s;
}
EOF
}

sub _inline_tc_code {
    my $self = shift;
    my ($value, $tc, $coercion, $message, $is_lazy) = @_;
    return (
        $self->_inline_check_coercion(
            $value, $tc, $coercion, $is_lazy,
        ),
        $self->_inline_check_constraint(
            $value, $tc, $message, $is_lazy,
        ),
    );
}

sub _inline_check_coercion {
    my $self = shift;
    my ($value, $tc, $coercion) = @_;

    return unless $self->should_coerce && $self->type_constraint->has_coercion;

    if ( $self->type_constraint->can_be_inlined ) {
        return (
            'if (! (' . $self->type_constraint->_inline_check($value) . ')) {',
                $value . ' = ' . $coercion . '->(' . $value . ');',
            '}',
        );
    }
    else {
        return (
            'if (!' . $tc . '->(' . $value . ')) {',
                $value . ' = ' . $coercion . '->(' . $value . ');',
            '}',
        );
    }
}

sub _inline_check_constraint {
    my $self = shift;
    my ($value, $tc, $message) = @_;

    return unless $self->has_type_constraint;

    my $attr_name = quotemeta($self->name);

    if ( $self->type_constraint->can_be_inlined ) {
        return (
            'if (! (' . $self->type_constraint->_inline_check($value) . ')) {',
                'my $msg = do { local $_ = ' . $value . '; '
                . $message . '->(' . $value . ');'
                . '};'.
                $self->_inline_throw_exception( ValidationFailedForInlineTypeConstraint =>
                                                'type_constraint_message => $msg , '.
                                                'class_name              => $class_name, '.
                                                'attribute_name          => "'.$attr_name.'",'.
                                                'value                   => '.$value
                ).';',
            '}',
        );
    }
    else {
        return (
            'if (!' . $tc . '->(' . $value . ')) {',
                'my $msg = do { local $_ = ' . $value . '; '
                . $message . '->(' . $value . ');'
                . '};'.
                $self->_inline_throw_exception( ValidationFailedForInlineTypeConstraint =>
                                                'type_constraint_message => $msg , '.
                                                'class_name              => $class_name, '.
                                                'attribute_name          => "'.$attr_name.'",'.
                                                'value                   => '.$value
                ).';',
            '}',
        );
    }
}

sub _inline_get_old_value_for_trigger {
    my $self = shift;
    my ($instance, $old) = @_;

    return unless $self->has_trigger;

    return (
        'my ' . $old . ' = ' . $self->_inline_instance_has($instance),
            '? ' . $self->_inline_instance_get($instance),
            ': ();',
    );
}

sub _inline_weaken_value {
    my $self = shift;
    my ($instance, $value) = @_;

    return unless $self->is_weak_ref;

    my $mi = $self->associated_class->get_meta_instance;
    return (
        $mi->inline_weaken_slot_value($instance, $self->name),
            'if ref ' . $value . ';',
    );
}

sub _inline_trigger {
    my $self = shift;
    my ($instance, $value, $old) = @_;

    return unless $self->has_trigger;

    return '$trigger->(' . $instance . ', ' . $value . ', ' . $old . ');';
}

sub _eval_environment {
    my $self = shift;

    my $env = { };

    $env->{'$trigger'} = \($self->trigger)
        if $self->has_trigger;
    $env->{'$attr_default'} = \($self->default)
        if $self->has_default;

    if ($self->has_type_constraint) {
        my $tc_obj = $self->type_constraint;

        $env->{'$type_constraint'} = \(
            $tc_obj->_compiled_type_constraint
        ) unless $tc_obj->can_be_inlined;
        # these two could probably get inlined versions too
        $env->{'$type_coercion'} = \(
            $tc_obj->coercion->_compiled_type_coercion
        ) if $tc_obj->has_coercion;
        $env->{'$type_message'} = \(
            $tc_obj->has_message ? $tc_obj->message : $tc_obj->_default_message
        );

        $env = { %$env, %{ $tc_obj->inline_environment } };
    }

    $env->{'$class_name'} = \($self->associated_class->name);

    # XXX ugh, fix these
    $env->{'$attr'} = \$self
        if $self->has_initializer && $self->is_lazy;
    # pretty sure this is only going to be closed over if you use a custom
    # error class at this point, but we should still get rid of this
    # at some point
    $env->{'$meta'} = \($self->associated_class);

    return $env;
}

sub _weaken_value {
    my ( $self, $instance ) = @_;

    my $meta_instance = Class::MOP::Class->initialize( blessed($instance) )
        ->get_meta_instance;

    $meta_instance->weaken_slot_value( $instance, $self->name );
}

sub get_value {
    my ($self, $instance, $for_trigger) = @_;

    if ($self->is_lazy) {
        unless ($self->has_value($instance)) {
            my $value;
            if ($self->has_default) {
                $value = $self->default($instance);
            } elsif ( $self->has_builder ) {
                $value = $self->_call_builder($instance);
            }

            $value = $self->_coerce_and_verify( $value, $instance );

            $self->set_initial_value($instance, $value);

            if ( ref $value && $self->is_weak_ref ) {
                $self->_weaken_value($instance);
            }
        }
    }

    if ( $self->should_auto_deref && ! $for_trigger ) {

        my $type_constraint = $self->type_constraint;

        if ($type_constraint->is_a_type_of('ArrayRef')) {
            my $rv = $self->SUPER::get_value($instance);
            return unless defined $rv;
            return wantarray ? @{ $rv } : $rv;
        }
        elsif ($type_constraint->is_a_type_of('HashRef')) {
            my $rv = $self->SUPER::get_value($instance);
            return unless defined $rv;
            return wantarray ? %{ $rv } : $rv;
        }
        else {
            throw_exception( CannotAutoDereferenceTypeConstraint => type_name => $type_constraint->name,
                                                                    instance  => $instance,
                                                                    attribute => $self
                           );
        }

    }
    else {

        return $self->SUPER::get_value($instance);
    }
}

sub _inline_get_value {
    my $self = shift;
    my ($instance, $tc, $coercion, $message) = @_;

    my $slot_access = $self->_inline_instance_get($instance);
    $tc           ||= '$type_constraint';
    $coercion     ||= '$type_coercion';
    $message      ||= '$type_message';

    return (
        $self->_inline_check_lazy($instance, $tc, $coercion, $message),
        $self->_inline_return_auto_deref($slot_access),
    );
}

sub _inline_check_lazy {
    my $self = shift;
    my ($instance, $tc, $coercion, $message) = @_;

    return unless $self->is_lazy;

    my $slot_exists = $self->_inline_instance_has($instance);

    return (
        'if (!' . $slot_exists . ') {',
            $self->_inline_init_from_default($instance, '$default', $tc, $coercion, $message, 'lazy'),
        '}',
    );
}

sub _inline_init_from_default {
    my $self = shift;
    my ($instance, $default, $tc, $coercion, $message, $for_lazy) = @_;

    if (!($self->has_default || $self->has_builder)) {
        throw_exception( LazyAttributeNeedsADefault => attribute => $self );
    }

    return (
        $self->_inline_generate_default($instance, $default),
        # intentionally not using _inline_tc_code, since that can be overridden
        # to do things like possibly only do member tc checks, which isn't
        # appropriate for checking the result of a default
        $self->has_type_constraint
            ? ($self->_inline_check_coercion($default, $tc, $coercion, $for_lazy),
               $self->_inline_check_constraint($default, $tc, $message, $for_lazy))
            : (),
        $self->_inline_init_slot($instance, $default),
        $self->_inline_weaken_value($instance, $default),
    );
}

sub _inline_generate_default {
    my $self = shift;
    my ($instance, $default) = @_;

    if ($self->has_default) {
        my $source = 'my ' . $default . ' = $attr_default';
        $source .= '->(' . $instance . ')'
            if $self->is_default_a_coderef;
        return $source . ';';
    }
    elsif ($self->has_builder) {
        my $builder = B::perlstring($self->builder);
        my $builder_str = quotemeta($self->builder);
        my $attr_name_str = quotemeta($self->name);
        return (
            'my ' . $default . ';',
            'if (my $builder = ' . $instance . '->can(' . $builder . ')) {',
                $default . ' = ' . $instance . '->$builder;',
            '}',
            'else {',
                'my $class = ref(' . $instance . ') || ' . $instance . ';',
                $self->_inline_throw_exception(
                    BuilderMethodNotSupportedForInlineAttribute =>
                    'class_name     => $class,'.
                    'attribute_name => "'.$attr_name_str.'",'.
                    'instance       => '.$instance.','.
                    'builder        => "'.$builder_str.'"'
                ) . ';',
            '}',
        );
    }
    else {
        confess(
            "Can't generate a default for " . $self->name
          . " since no default or builder was specified"
        );
    }
}

sub _inline_init_slot {
    my $self = shift;
    my ($inv, $value) = @_;

    if ($self->has_initializer) {
        return '$attr->set_initial_value(' . $inv . ', ' . $value . ');';
    }
    else {
        return $self->_inline_instance_set($inv, $value) . ';';
    }
}

sub _inline_return_auto_deref {
    my $self = shift;

    return 'return ' . $self->_auto_deref(@_) . ';';
}

sub _auto_deref {
    my $self = shift;
    my ($ref_value) = @_;

    return $ref_value unless $self->should_auto_deref;

    my $type_constraint = $self->type_constraint;

    my $sigil;
    if ($type_constraint->is_a_type_of('ArrayRef')) {
        $sigil = '@';
    }
    elsif ($type_constraint->is_a_type_of('HashRef')) {
        $sigil = '%';
    }
    else {
        confess(
            'Can not auto de-reference the type constraint \''
          . $type_constraint->name
          . '\''
        );
    }

    return 'wantarray '
             . '? ' . $sigil . '{ (' . $ref_value . ') || return } '
             . ': (' . $ref_value . ')';
}

## installing accessors

sub accessor_metaclass { 'Moose::Meta::Method::Accessor' }

sub install_accessors {
    my $self = shift;
    $self->SUPER::install_accessors(@_);
    $self->install_delegation if $self->has_handles;
    return;
}

sub _check_associated_methods {
    my $self = shift;
    unless (
        @{ $self->associated_methods }
        || ($self->_is_metadata || '') eq 'bare'
    ) {
        Carp::cluck(
            'Attribute (' . $self->name . ') of class '
            . $self->associated_class->name
            . ' has no associated methods'
            . ' (did you mean to provide an "is" argument?)'
            . "\n"
        )
    }
}

sub _process_accessors {
    my $self = shift;
    my ($type, $accessor, $generate_as_inline_methods) = @_;

    $accessor = ( keys %$accessor )[0] if ( ref($accessor) || '' ) eq 'HASH';
    my $method = $self->associated_class->get_method($accessor);

    if (   $method
        && $method->isa('Class::MOP::Method::Accessor') ) {

        # This is a special case that is very unlikely to occur outside of the
        # Moose bootstrapping process. We do not want to warn if the method
        # we're about to replace is for this same attribute, _and_ we're
        # replacing a non-inline method with an inlined version.
        #
        # This would never occur in normal user code because Moose inlines all
        # accessors. However, Moose metaclasses are instances of
        # Class::MOP::Class, which _does not_ inline accessors by
        # default. However, in Class::MOP & Moose.pm, we iterate over all of
        # our internal metaclasses and make them immutable after they're fully
        # defined. This ends up replacing the attribute accessors.
        unless ( $method->associated_attribute->name eq $self->name
            && ( $generate_as_inline_methods && !$method->is_inline ) ) {

            my $other_attr = $method->associated_attribute;

            my $msg = sprintf(
                'You are overwriting a %s (%s) for the %s attribute',
                $method->accessor_type,
                $accessor,
                $other_attr->name,
            );

            if ( my $method_context = $method->definition_context ) {
                $msg .= sprintf(
                    ' (defined at %s line %s)',
                    $method_context->{file},
                    $method_context->{line},
                    )
                    if defined $method_context->{file}
                    && $method_context->{line};
            }

            $msg .= sprintf(
                ' with a new %s method for the %s attribute',
                $type,
                $self->name,
            );

            if ( my $self_context = $self->definition_context ) {
                $msg .= sprintf(
                    ' (defined at %s line %s)',
                    $self_context->{file},
                    $self_context->{line},
                    )
                    if defined $self_context->{file}
                    && $self_context->{line};
            }

            Carp::cluck($msg);
        }
    }

    if (
           $method
        && !$method->is_stub
        && !$method->isa('Class::MOP::Method::Accessor')
        && (  !$self->definition_context
            || $method->package_name eq $self->definition_context->{package} )
        ) {

        Carp::cluck(
            "You are overwriting a locally defined method ($accessor) with "
                . "an accessor" );
    }

    if (  !$self->associated_class->has_method($accessor)
        && $self->associated_class->has_package_symbol( '&' . $accessor ) ) {

        Carp::cluck(
            "You are overwriting a locally defined function ($accessor) with "
                . "an accessor" );
    }

    $self->SUPER::_process_accessors(@_);
}

sub remove_accessors {
    my $self = shift;
    $self->SUPER::remove_accessors(@_);
    $self->remove_delegation if $self->has_handles;
    return;
}

sub install_delegation {
    my $self = shift;

    # NOTE:
    # Here we canonicalize the 'handles' option
    # this will sort out any details and always
    # return an hash of methods which we want
    # to delegate to, see that method for details
    my %handles = $self->_canonicalize_handles;

    # install the delegation ...
    my $associated_class = $self->associated_class;
    my $class_name = $associated_class->name;

    foreach my $handle ( sort keys %handles ) {
        my $method_to_call = $handles{$handle};
        my $name           = "${class_name}::${handle}";

        if ( my $method = $associated_class->get_method($handle) ) {
            throw_exception(
                CannotDelegateLocalMethodIsPresent => attribute => $self,
                method                             => $method,
            ) unless $method->is_stub;
        }

        # NOTE:
        # handles is not allowed to delegate
        # any of these methods, as they will
        # override the ones in your class, which
        # is almost certainly not what you want.

        # FIXME warn when $handle was explicitly specified, but not if the source is a regex or something
        #cluck("Not delegating method '$handle' because it is a core method") and
        next
            if $class_name->isa("Moose::Object")
            and $handle =~ /^BUILD|DEMOLISH$/ || Moose::Object->can($handle);

        my $method = $self->_make_delegation_method($handle, $method_to_call);

        $self->associated_class->add_method($method->name, $method);
        $self->associate_method($method);
    }
}

sub remove_delegation {
    my $self = shift;
    my %handles = $self->_canonicalize_handles;
    my $associated_class = $self->associated_class;
    foreach my $handle (keys %handles) {
        next unless any { $handle eq $_ }
                    map { $_->name }
                    @{ $self->associated_methods };
        $self->associated_class->remove_method($handle);
    }
}

# private methods to help delegation ...

sub _canonicalize_handles {
    my $self    = shift;
    my $handles = $self->handles;
    if (my $handle_type = ref($handles)) {
        if ($handle_type eq 'HASH') {
            return %{$handles};
        }
        elsif ($handle_type eq 'ARRAY') {
            return map { $_ => $_ } @{$handles};
        }
        elsif ($handle_type eq 'Regexp') {
            ($self->has_type_constraint)
                || throw_exception( CannotDelegateWithoutIsa => attribute => $self );
            return map  { ($_ => $_) }
                   grep { /$handles/ } $self->_get_delegate_method_list;
        }
        elsif ($handle_type eq 'CODE') {
            return $handles->($self, $self->_find_delegate_metaclass);
        }
        elsif (blessed($handles) && $handles->isa('Moose::Meta::TypeConstraint::DuckType')) {
            return map { $_ => $_ } @{ $handles->methods };
        }
        elsif (blessed($handles) && $handles->isa('Moose::Meta::TypeConstraint::Role')) {
            $handles = $handles->role;
        }
        else {
            throw_exception( UnableToCanonicalizeHandles => attribute => $self,
                                                            handles   => $handles
                           );
        }
    }

    Moose::Util::_load_user_class($handles);
    my $role_meta = Class::MOP::class_of($handles);

    (blessed $role_meta && $role_meta->isa('Moose::Meta::Role'))
        || throw_exception( UnableToCanonicalizeNonRolePackage => attribute => $self,
                                                                  handles   => $handles
                          );

    return map { $_ => $_ }
        map { $_->name }
        grep { !$_->isa('Class::MOP::Method::Meta') } (
        $role_meta->_get_local_methods,
        $role_meta->get_required_method_list,
        );
}

sub _get_delegate_method_list {
    my $self = shift;
    my $meta = $self->_find_delegate_metaclass;
    if ($meta->isa('Class::MOP::Class')) {
        return map  { $_->name }  # NOTE: !never! delegate &meta
               grep { $_->package_name ne 'Moose::Object' && !$_->isa('Class::MOP::Method::Meta') }
                    $meta->get_all_methods;
    }
    elsif ($meta->isa('Moose::Meta::Role')) {
        return $meta->get_method_list;
    }
    else {
        throw_exception( UnableToRecognizeDelegateMetaclass => attribute          => $self,
                                                               delegate_metaclass => $meta
                       );
    }
}

sub _find_delegate_metaclass {
    my $self = shift;
    my $class = $self->_isa_metadata;
    my $role = $self->_does_metadata;

    if ( $class ) {
        # make sure isa is actually a class
        unless ( $self->type_constraint->isa("Moose::Meta::TypeConstraint::Class") ) {
            throw_exception( DelegationToATypeWhichIsNotAClass => attribute => $self );
        }

        # make sure the class is loaded
        unless ( Moose::Util::_is_package_loaded($class) ) {
            throw_exception( DelegationToAClassWhichIsNotLoaded => attribute  => $self,
                                                                   class_name => $class
                           );
        }
        # we might be dealing with a non-Moose class,
        # and need to make our own metaclass. if there's
        # already a metaclass, it will be returned
        return Class::MOP::Class->initialize($class);
    }
    elsif ( $role ) {
        unless ( Moose::Util::_is_package_loaded($role) ) {
            throw_exception( DelegationToARoleWhichIsNotLoaded => attribute => $self,
                                                                  role_name => $role
                           );
        }

        return Class::MOP::class_of($role);
    }
    else {
        throw_exception( CannotFindDelegateMetaclass => attribute => $self );
    }
}

sub delegation_metaclass { 'Moose::Meta::Method::Delegation' }

sub _make_delegation_method {
    my ( $self, $handle_name, $method_to_call ) = @_;

    my @curried_arguments;

    ($method_to_call, @curried_arguments) = @$method_to_call
        if 'ARRAY' eq ref($method_to_call);

    return $self->delegation_metaclass->new(
        name               => $handle_name,
        package_name       => $self->associated_class->name,
        attribute          => $self,
        delegate_to_method => $method_to_call,
        curried_arguments  => \@curried_arguments,
    );
}

sub _coerce_and_verify {
    my $self     = shift;
    my $val      = shift;
    my $instance = shift;

    return $val unless $self->has_type_constraint;

    $val = $self->type_constraint->coerce($val)
        if $self->should_coerce && $self->type_constraint->has_coercion;

    $self->verify_against_type_constraint($val, instance => $instance);

    return $val;
}

sub verify_against_type_constraint {
    my $self = shift;
    my $val  = shift;

    return 1 if !$self->has_type_constraint;

    my $type_constraint = $self->type_constraint;

    $type_constraint->check($val)
        || throw_exception( ValidationFailedForTypeConstraint => type      => $type_constraint,
                                                                 value     => $val,
                                                                 attribute => $self,
                          );
}

package  # hide from PAUSE
    Moose::Meta::Attribute::Custom::Moose;

sub register_implementation { 'Moose::Meta::Attribute' }
1;

# ABSTRACT: The Moose attribute metaclass

package Moose::Util::TypeConstraints;
our $VERSION = '2.2204';

use Carp ();
use Scalar::Util qw( blessed );
use Moose::Exporter;
use Moose::Deprecated;

## --------------------------------------------------------
# Prototyped subs must be predeclared because we have a
# circular dependency with Moose::Meta::Attribute et. al.
# so in case of us being use'd first the predeclaration
# ensures the prototypes are in scope when consumers are
# compiled.

# dah sugah!
sub where (&);
sub via (&);
sub message (&);
sub inline_as (&);

## --------------------------------------------------------

use Moose::Meta::TypeConstraint;
use Moose::Meta::TypeConstraint::Union;
use Moose::Meta::TypeConstraint::Parameterized;
use Moose::Meta::TypeConstraint::Parameterizable;
use Moose::Meta::TypeConstraint::Class;
use Moose::Meta::TypeConstraint::Role;
use Moose::Meta::TypeConstraint::Enum;
use Moose::Meta::TypeConstraint::DuckType;
use Moose::Meta::TypeCoercion;
use Moose::Meta::TypeCoercion::Union;
use Moose::Meta::TypeConstraint::Registry;

use Moose::Util 'throw_exception';

Moose::Exporter->setup_import_methods(
    as_is => [
        qw(
            type subtype class_type role_type maybe_type duck_type
            as where message inline_as
            coerce from via
            enum union
            find_type_constraint
            register_type_constraint
            match_on_type )
    ],
);

## --------------------------------------------------------
## type registry and some useful functions for it
## --------------------------------------------------------

my $REGISTRY = Moose::Meta::TypeConstraint::Registry->new;

sub get_type_constraint_registry {$REGISTRY}
sub list_all_type_constraints    { keys %{ $REGISTRY->type_constraints } }

sub export_type_constraints_as_functions {
    my $pkg = caller();
    no strict 'refs';
    foreach my $constraint ( keys %{ $REGISTRY->type_constraints } ) {
        my $tc = $REGISTRY->get_type_constraint($constraint)
            ->_compiled_type_constraint;
        *{"${pkg}::${constraint}"}
            = sub { $tc->( $_[0] ) ? 1 : undef };    # the undef is for compat
    }
}

sub create_type_constraint_union {
    _create_type_constraint_union(\@_);
}

sub create_named_type_constraint_union {
    my $name = shift;
    _create_type_constraint_union($name, \@_);
}

sub _create_type_constraint_union {
    my $name;
    $name = shift if @_ > 1;
    my @tcs = @{ shift() };

    my @type_constraint_names;

    if ( scalar @tcs == 1 && _detect_type_constraint_union( $tcs[0] ) ) {
        @type_constraint_names = _parse_type_constraint_union( $tcs[0] );
    }
    else {
        @type_constraint_names = @tcs;
    }

    ( scalar @type_constraint_names >= 2 )
        || throw_exception("UnionTakesAtleastTwoTypeNames");

    my @type_constraints = map {
        find_or_parse_type_constraint($_)
            || throw_exception( CouldNotLocateTypeConstraintForUnion => type_name => $_ );
    } @type_constraint_names;

    my %options = (
      type_constraints => \@type_constraints
    );
    $options{name} = $name if defined $name;

    return Moose::Meta::TypeConstraint::Union->new(%options);
}


sub create_parameterized_type_constraint {
    my $type_constraint_name = shift;
    my ( $base_type, $type_parameter )
        = _parse_parameterized_type_constraint($type_constraint_name);

    ( defined $base_type && defined $type_parameter )
        || throw_exception( InvalidTypeGivenToCreateParameterizedTypeConstraint => type_name => $type_constraint_name );

    if ( $REGISTRY->has_type_constraint($base_type) ) {
        my $base_type_tc = $REGISTRY->get_type_constraint($base_type);
        return _create_parameterized_type_constraint(
            $base_type_tc,
            $type_parameter
        );
    }
    else {
        throw_exception( InvalidBaseTypeGivenToCreateParameterizedTypeConstraint => type_name => $base_type );
    }
}

sub _create_parameterized_type_constraint {
    my ( $base_type_tc, $type_parameter ) = @_;
    if ( $base_type_tc->can('parameterize') ) {
        return $base_type_tc->parameterize($type_parameter);
    }
    else {
        return Moose::Meta::TypeConstraint::Parameterized->new(
            name   => $base_type_tc->name . '[' . $type_parameter . ']',
            parent => $base_type_tc,
            type_parameter =>
                find_or_create_isa_type_constraint($type_parameter),
        );
    }
}

#should we also support optimized checks?
sub create_class_type_constraint {
    my ( $class, $options ) = @_;

# too early for this check
#find_type_constraint("ClassName")->check($class)
#    || __PACKAGE__->_throw_error("Can't create a class type constraint because '$class' is not a class name");

    my $pkg_defined_in = $options->{package_defined_in} || scalar( caller(1) );

    if (my $type = $REGISTRY->get_type_constraint($class)) {
        if (!($type->isa('Moose::Meta::TypeConstraint::Class') && $type->class eq $class)) {
            throw_exception( TypeConstraintIsAlreadyCreated => package_defined_in => $pkg_defined_in,
                                                               type_name          => $type->name,
                           );
        }
        else {
            return $type;
        }
    }

    my %options = (
        class              => $class,
        name               => $class,
        package_defined_in => $pkg_defined_in,
        %{ $options || {} },    # overrides options from above
    );

    $options{name} ||= "__ANON__";

    my $tc = Moose::Meta::TypeConstraint::Class->new(%options);
    $REGISTRY->add_type_constraint($tc);
    return $tc;
}

sub create_role_type_constraint {
    my ( $role, $options ) = @_;

# too early for this check
#find_type_constraint("ClassName")->check($class)
#    || __PACKAGE__->_throw_error("Can't create a class type constraint because '$class' is not a class name");

    my $pkg_defined_in = $options->{package_defined_in} || scalar( caller(1) );

    if (my $type = $REGISTRY->get_type_constraint($role)) {
        if (!($type->isa('Moose::Meta::TypeConstraint::Role') && $type->role eq $role)) {
            throw_exception( TypeConstraintIsAlreadyCreated => type_name          => $type->name,
                                                               package_defined_in => $pkg_defined_in
                           );
        }
        else {
            return $type;
        }
    }

    my %options = (
        role               => $role,
        name               => $role,
        package_defined_in => $pkg_defined_in,
        %{ $options || {} },
    );

    $options{name} ||= "__ANON__";

    my $tc = Moose::Meta::TypeConstraint::Role->new(%options);
    $REGISTRY->add_type_constraint($tc);
    return $tc;
}

sub find_or_create_type_constraint {
    my ( $type_constraint_name, $options_for_anon_type ) = @_;

    if ( my $constraint
        = find_or_parse_type_constraint($type_constraint_name) ) {
        return $constraint;
    }
    elsif ( defined $options_for_anon_type ) {

        # NOTE:
        # if there is no $options_for_anon_type
        # specified, then we assume they don't
        # want to create one, and return nothing.

        # otherwise assume that we should create
        # an ANON type with the $options_for_anon_type
        # options which can be passed in. It should
        # be noted that these don't get registered
        # so we need to return it.
        # - SL
        return Moose::Meta::TypeConstraint->new(
            name => '__ANON__',
            %{$options_for_anon_type}
        );
    }

    return;
}

sub find_or_create_isa_type_constraint {
    my ($type_constraint_name, $options) = @_;
    find_or_parse_type_constraint($type_constraint_name)
        || create_class_type_constraint($type_constraint_name, $options);
}

sub find_or_create_does_type_constraint {
    my ($type_constraint_name, $options) = @_;
    find_or_parse_type_constraint($type_constraint_name)
        || create_role_type_constraint($type_constraint_name, $options);
}

sub find_or_parse_type_constraint {
    my $type_constraint_name = normalize_type_constraint_name(shift);
    my $constraint;

    if ( $constraint = find_type_constraint($type_constraint_name) ) {
        return $constraint;
    }
    elsif ( _detect_type_constraint_union($type_constraint_name) ) {
        $constraint = create_type_constraint_union($type_constraint_name);
    }
    elsif ( _detect_parameterized_type_constraint($type_constraint_name) ) {
        $constraint
            = create_parameterized_type_constraint($type_constraint_name);
    }
    else {
        return;
    }

    $REGISTRY->add_type_constraint($constraint);
    return $constraint;
}

sub normalize_type_constraint_name {
    my $type_constraint_name = shift;
    $type_constraint_name =~ s/\s//g;
    return $type_constraint_name;
}

sub _confess {
    my $error = shift;

    local $Carp::CarpLevel = $Carp::CarpLevel + 1;
    Carp::confess($error);
}

## --------------------------------------------------------
## exported functions ...
## --------------------------------------------------------

sub find_type_constraint {
    my $type = shift;

    if ( blessed $type and $type->isa("Moose::Meta::TypeConstraint") ) {
        return $type;
    }
    else {
        return unless $REGISTRY->has_type_constraint($type);
        return $REGISTRY->get_type_constraint($type);
    }
}

sub register_type_constraint {
    my $constraint = shift;
    throw_exception( CannotRegisterUnnamedTypeConstraint => type => $constraint )
        unless defined $constraint->name;
    $REGISTRY->add_type_constraint($constraint);
    return $constraint;
}

# type constructors

sub type {
    my $name = shift;

    my %p = map { %{$_} } @_;

    return _create_type_constraint(
        $name, undef, $p{where}, $p{message},
        $p{inline_as},
    );
}

sub subtype {
    if ( @_ == 1 && !ref $_[0] ) {
        throw_exception( NoParentGivenToSubtype => name => $_[0] );
    }

    # The blessed check is mostly to accommodate MooseX::Types, which
    # uses an object which overloads stringification as a type name.
    my $name = ref $_[0] && !blessed $_[0] ? undef : shift;

    my %p = map { %{$_} } @_;

    # subtype Str => where { ... };
    if ( !exists $p{as} ) {
        $p{as} = $name;
        $name = undef;
    }

    return _create_type_constraint(
        $name, $p{as}, $p{where}, $p{message},
        $p{inline_as},
    );
}

sub class_type {
    create_class_type_constraint(@_);
}

sub role_type ($;$) {
    create_role_type_constraint(@_);
}

sub maybe_type {
    my ($type_parameter) = @_;

    register_type_constraint(
        $REGISTRY->get_type_constraint('Maybe')->parameterize($type_parameter)
    );
}

sub duck_type {
    my ( $type_name, @methods ) = @_;
    if ( ref $type_name eq 'ARRAY' && !@methods ) {
        @methods   = ($type_name);
        $type_name = undef;
    }
    if ( @methods == 1 && ref $methods[0] eq 'ARRAY' ) {
        @methods = @{ $methods[0] };
    }
    else {
        Moose::Deprecated::deprecated(
            feature => 'non-arrayref form of duck_type',
            message => "Passing a list of values to duck_type is deprecated. "
                     . "The method names should be wrapped in an arrayref.",
        );
    }

    register_type_constraint(
        create_duck_type_constraint(
            $type_name,
            \@methods,
        )
    );
}

sub coerce {
    my ( $type_name, @coercion_map ) = @_;
    _install_type_coercions( $type_name, \@coercion_map );
}

# The trick of returning @_ lets us avoid having to specify a
# prototype. Perl will parse this:
#
# subtype 'Foo'
#     => as 'Str'
#     => where { ... }
#
# as this:
#
# subtype( 'Foo', as( 'Str', where { ... } ) );
#
# If as() returns all its extra arguments, this just works, and
# preserves backwards compatibility.
sub as { +{ as => shift }, @_ }
sub where (&)       { +{ where       => $_[0] } }
sub message (&)     { +{ message     => $_[0] } }
sub inline_as (&)   { +{ inline_as   => $_[0] } }

sub from    { @_ }
sub via (&) { $_[0] }

sub enum {
    my ( $type_name, @values ) = @_;

    # NOTE:
    # if only an array-ref is passed then
    # you get an anon-enum
    # - SL
    if ( ref $type_name eq 'ARRAY' ) {
        @values == 0
            || throw_exception( EnumCalledWithAnArrayRefAndAdditionalArgs => array => $type_name,
                                                                             args  => \@values
                              );
        @values    = ($type_name);
        $type_name = undef;
    }
    if ( @values == 1 && ref $values[0] eq 'ARRAY' ) {
        @values = @{ $values[0] };
    }
    else {
        Moose::Deprecated::deprecated(
            feature => 'non-arrayref form of enum',
            message => "Passing a list of values to enum is deprecated. "
                     . "Enum values should be wrapped in an arrayref.",
        );
    }

    register_type_constraint(
        create_enum_type_constraint(
            $type_name,
            \@values,
        )
    );
}

sub union {
  my ( $type_name, @constraints ) = @_;
  if ( ref $type_name eq 'ARRAY' ) {
    @constraints == 0
      || throw_exception( UnionCalledWithAnArrayRefAndAdditionalArgs => array => $type_name,
                                                                        args  => \@constraints
                        );
    @constraints = @$type_name;
    $type_name   = undef;
  }
  if ( @constraints == 1 && ref $constraints[0] eq 'ARRAY' ) {
    @constraints = @{ $constraints[0] };
  }
  if ( defined $type_name ) {
    return register_type_constraint(
      create_named_type_constraint_union( $type_name, @constraints )
    );
  }
  return create_type_constraint_union( @constraints );
}

sub create_enum_type_constraint {
    my ( $type_name, $values ) = @_;

    Moose::Meta::TypeConstraint::Enum->new(
        name => $type_name || '__ANON__',
        values => $values,
    );
}

sub create_duck_type_constraint {
    my ( $type_name, $methods ) = @_;

    Moose::Meta::TypeConstraint::DuckType->new(
        name => $type_name || '__ANON__',
        methods => $methods,
    );
}

sub match_on_type {
    my ($to_match, @cases) = @_;
    my $default;
    if (@cases % 2 != 0) {
        $default = pop @cases;
        (ref $default eq 'CODE')
            || throw_exception( DefaultToMatchOnTypeMustBeCodeRef => to_match            => $to_match,
                                                                     default_action      => $default,
                                                                     cases_to_be_matched => \@cases
                              );
    }
    while (@cases) {
        my ($type, $action) = splice @cases, 0, 2;

        unless (blessed $type && $type->isa('Moose::Meta::TypeConstraint')) {
            $type = find_or_parse_type_constraint($type)
                 || throw_exception( CannotFindTypeGivenToMatchOnType => type     => $type,
                                                                         to_match => $to_match,
                                                                         action   => $action
                                   );
        }

        (ref $action eq 'CODE')
            || throw_exception( MatchActionMustBeACodeRef => type_name => $type->name,
                                                             action    => $action,
                                                             to_match  => $to_match
                              );

        if ($type->check($to_match)) {
            local $_ = $to_match;
            return $action->($to_match);
        }
    }
    (defined $default)
        || throw_exception( NoCasesMatched => to_match            => $to_match,
                                              cases_to_be_matched => \@cases
                          );
    {
        local $_ = $to_match;
        return $default->($to_match);
    }
}


## --------------------------------------------------------
## desugaring functions ...
## --------------------------------------------------------

sub _create_type_constraint ($$$;$) {
    my $name      = shift;
    my $parent    = shift;
    my $check     = shift;
    my $message   = shift;
    my $inlined   = shift;

    my $pkg_defined_in = scalar( caller(1) );

    if ( defined $name ) {
        my $type = $REGISTRY->get_type_constraint($name);

        ( $type->_package_defined_in eq $pkg_defined_in )
            || throw_exception( TypeConstraintIsAlreadyCreated => package_defined_in => $pkg_defined_in,
                                                                  type_name          => $type->name,
                              )
            if defined $type;

        if( $name !~ /^[\w:\.]+$/ ) {
            throw_exception( InvalidNameForType => name => $name );
        }
    }

    my %opts = (
        name               => $name,
        package_defined_in => $pkg_defined_in,

        ( $check     ? ( constraint => $check )     : () ),
        ( $message   ? ( message    => $message )   : () ),
        ( $inlined   ? ( inlined    => $inlined )   : () ),
    );

    my $constraint;
    if (
        defined $parent
        and $parent
        = blessed $parent
        ? $parent
        : find_or_create_isa_type_constraint($parent)
        ) {
        $constraint = $parent->create_child_type(%opts);
    }
    else {
        $constraint = Moose::Meta::TypeConstraint->new(%opts);
    }

    $REGISTRY->add_type_constraint($constraint)
        if defined $name;

    return $constraint;
}

sub _install_type_coercions ($$) {
    my ( $type_name, $coercion_map ) = @_;
    my $type = find_type_constraint($type_name);
    ( defined $type )
        || throw_exception( CannotFindType => type_name => $type_name );

    if ( $type->has_coercion ) {
        $type->coercion->add_type_coercions(@$coercion_map);
    }
    else {
        my $type_coercion = Moose::Meta::TypeCoercion->new(
            type_coercion_map => $coercion_map,
            type_constraint   => $type
        );
        $type->coercion($type_coercion);
    }
}

## --------------------------------------------------------
## type notation parsing ...
## --------------------------------------------------------

{

    # All I have to say is mugwump++ cause I know
    # do not even have enough regexp-fu to be able
    # to have written this (I can only barely
    # understand it as it is)
    # - SL

    use re "eval";

    my $valid_chars = qr{[\w:\.]};
    my $type_atom   = qr{ (?>$valid_chars+) }x;
    my $ws          = qr{ (?>\s*) }x;
    my $op_union    = qr{ $ws \| $ws }x;

    my ($type, $type_capture_parts, $type_with_parameter, $union, $any);
    if (Class::MOP::IS_RUNNING_ON_5_10) {
        my $type_pattern
            = q{  (?&type_atom)  (?: \[ (?&ws)  (?&any)  (?&ws) \] )? };
        my $type_capture_parts_pattern
            = q{ ((?&type_atom)) (?: \[ (?&ws) ((?&any)) (?&ws) \] )? };
        my $type_with_parameter_pattern
            = q{  (?&type_atom)      \[ (?&ws)  (?&any)  (?&ws) \]    };
        my $union_pattern
            = q{ (?&type) (?> (?: (?&op_union) (?&type) )+ ) };
        my $any_pattern
            = q{ (?&type) | (?&union) };

        my $defines = qr{(?(DEFINE)
            (?<valid_chars>         $valid_chars)
            (?<type_atom>           $type_atom)
            (?<ws>                  $ws)
            (?<op_union>            $op_union)
            (?<type>                $type_pattern)
            (?<type_capture_parts>  $type_capture_parts_pattern)
            (?<type_with_parameter> $type_with_parameter_pattern)
            (?<union>               $union_pattern)
            (?<any>                 $any_pattern)
        )}x;

        $type                = qr{ $type_pattern                $defines }x;
        $type_capture_parts  = qr{ $type_capture_parts_pattern  $defines }x;
        $type_with_parameter = qr{ $type_with_parameter_pattern $defines }x;
        $union               = qr{ $union_pattern               $defines }x;
        $any                 = qr{ $any_pattern                 $defines }x;
    }
    else {
        $type
            = qr{  $type_atom  (?: \[ $ws  (??{$any})  $ws \] )? }x;
        $type_capture_parts
            = qr{ ($type_atom) (?: \[ $ws ((??{$any})) $ws \] )? }x;
        $type_with_parameter
            = qr{  $type_atom      \[ $ws  (??{$any})  $ws \]    }x;
        $union
            = qr{ $type (?> (?: $op_union $type )+ ) }x;
        $any
            = qr{ $type | $union }x;
    }


    sub _parse_parameterized_type_constraint {
        { no warnings 'void'; $any; }  # force capture of interpolated lexical
        $_[0] =~ m{ $type_capture_parts }x;
        return ( $1, $2 );
    }

    sub _detect_parameterized_type_constraint {
        { no warnings 'void'; $any; }  # force capture of interpolated lexical
        $_[0] =~ m{ ^ $type_with_parameter $ }x;
    }

    sub _parse_type_constraint_union {
        { no warnings 'void'; $any; }  # force capture of interpolated lexical
        my $given = shift;
        my @rv;
        while ( $given =~ m{ \G (?: $op_union )? ($type) }gcx ) {
            push @rv => $1;
        }
        ( pos($given) eq length($given) )
            || throw_exception( CouldNotParseType => type     => $given,
                                                     position => pos($given)
                              );
        @rv;
    }

    sub _detect_type_constraint_union {
        { no warnings 'void'; $any; }  # force capture of interpolated lexical
        $_[0] =~ m{^ $type $op_union $type ( $op_union .* )? $}x;
    }
}

## --------------------------------------------------------
# define some basic built-in types
## --------------------------------------------------------

# By making these classes immutable before creating all the types in
# Moose::Util::TypeConstraints::Builtin , we avoid repeatedly calling the slow
# MOP-based accessors.
$_->make_immutable(
    inline_constructor => 1,
    constructor_name   => "_new",

    # these are Class::MOP accessors, so they need inlining
    inline_accessors => 1
    ) for grep { $_->is_mutable }
    map { Class::MOP::class_of($_) }
    qw(
    Moose::Meta::TypeConstraint
    Moose::Meta::TypeConstraint::Union
    Moose::Meta::TypeConstraint::Parameterized
    Moose::Meta::TypeConstraint::Parameterizable
    Moose::Meta::TypeConstraint::Class
    Moose::Meta::TypeConstraint::Role
    Moose::Meta::TypeConstraint::Enum
    Moose::Meta::TypeConstraint::DuckType
    Moose::Meta::TypeConstraint::Registry
);

require Moose::Util::TypeConstraints::Builtins;
Moose::Util::TypeConstraints::Builtins::define_builtins($REGISTRY);

my @PARAMETERIZABLE_TYPES
    = map { $REGISTRY->get_type_constraint($_) } qw[ScalarRef ArrayRef HashRef Maybe];

sub get_all_parameterizable_types {@PARAMETERIZABLE_TYPES}

sub add_parameterizable_type {
    my $type = shift;
    ( blessed $type
            && $type->isa('Moose::Meta::TypeConstraint::Parameterizable') )
        || throw_exception( AddParameterizableTypeTakesParameterizableType => type_name => $type );

    push @PARAMETERIZABLE_TYPES => $type;
}

## --------------------------------------------------------
# end of built-in types ...
## --------------------------------------------------------

{
    my @BUILTINS = list_all_type_constraints();
    sub list_all_builtin_type_constraints {@BUILTINS}
}

1;

# ABSTRACT: Type constraint system for Moose

package Moose::Util::TypeConstraints::Builtins;
our $VERSION = '2.2204';

use strict;
use warnings;

use Class::Load qw( is_class_loaded );
use List::Util 1.33 ();
use Scalar::Util qw( blessed );

sub type { goto &Moose::Util::TypeConstraints::type }
sub subtype { goto &Moose::Util::TypeConstraints::subtype }
sub as { goto &Moose::Util::TypeConstraints::as }
sub where (&) { goto &Moose::Util::TypeConstraints::where }
sub inline_as (&) { goto &Moose::Util::TypeConstraints::inline_as }

sub define_builtins {
    my $registry = shift;

    type 'Any'    # meta-type including all
        => where {1}
        => inline_as { '1' };

    subtype 'Item'  # base type
        => as 'Any'
        => inline_as { '1' };

    subtype 'Undef'
        => as 'Item'
        => where { !defined($_) }
        => inline_as {
            '!defined(' . $_[1] . ')'
        };

    subtype 'Defined'
        => as 'Item'
        => where { defined($_) }
        => inline_as {
            'defined(' . $_[1] . ')'
        };

    subtype 'Bool'
        => as 'Item'
        => where { !defined($_) || $_ eq "" || "$_" eq '1' || "$_" eq '0' }
        => inline_as {
            '('
                . '!defined(' . $_[1] . ') '
                . '|| ' . $_[1] . ' eq "" '
                . '|| (' . $_[1] . '."") eq "1" '
                . '|| (' . $_[1] . '."") eq "0"'
            . ')'
        };

    subtype 'Value'
        => as 'Defined'
        => where { !ref($_) }
        => inline_as {
            $_[0]->parent()->_inline_check($_[1])
            . ' && !ref(' . $_[1] . ')'
        };

    subtype 'Ref'
        => as 'Defined'
        => where { ref($_) }
            # no need to call parent - ref also checks for definedness
        => inline_as { 'ref(' . $_[1] . ')' };

    subtype 'Str'
        => as 'Value'
        => where { ref(\$_) eq 'SCALAR' || ref(\(my $val = $_)) eq 'SCALAR' }
        => inline_as {
            $_[0]->parent()->_inline_check($_[1])
            . ' && ('
                . 'ref(\\' . $_[1] . ') eq "SCALAR"'
                . ' || ref(\\(my $val = ' . $_[1] . ')) eq "SCALAR"'
            . ')'
        };

    my $value_type = Moose::Util::TypeConstraints::find_type_constraint('Value');
    subtype 'Num'
        => as 'Str'
        => where {
        my $val = $_;
        ($val =~ /\A[+-]?[0-9]+\z/) ||
        ( $val =~ /\A(?:[+-]?)              # matches optional +- in the beginning
        (?=[0-9]|\.[0-9])                   # matches previous +- only if there is something like 3 or .3
        [0-9]*                              # matches 0-9 zero or more times
        (?:\.[0-9]+)?                       # matches optional .89 or nothing
        (?:[Ee](?:[+-]?[0-9]+))?            # matches E1 or e1 or e-1 or e+1 etc
        \z/x );
           }
        => inline_as {
            # the long Str tests are redundant here
        #storing $_[1] in a temporary value,
        #so that $_[1] won't get converted to a string for regex match
        #see t/attributes/numeric_defaults.t for more details
        'my $val = '.$_[1].';'.
        $value_type->_inline_check('$val')
        .' && ( $val =~ /\A[+-]?[0-9]+\z/ || '
        . '$val =~ /\A(?:[+-]?)             # matches optional +- in the beginning
                (?=[0-9]|\.[0-9])           # matches previous +- only if there is something like 3 or .3
                [0-9]*                      # matches 0-9 zero or more times
                (?:\.[0-9]+)?               # matches optional .89 or nothing
                (?:[Ee](?:[+-]?[0-9]+))?    # matches E1 or e1 or e-1 or e+1 etc
                \z/x ); '
        };

    subtype 'Int'
        => as 'Num'
        => where { (my $val = $_) =~ /\A-?[0-9]+\z/ }
        => inline_as {
            $value_type->_inline_check($_[1])
            . ' && (my $val = ' . $_[1] . ') =~ /\A-?[0-9]+\z/'
        };

    subtype 'CodeRef'
        => as 'Ref'
        => where { ref($_) eq 'CODE' }
        => inline_as { 'ref(' . $_[1] . ') eq "CODE"' };

    subtype 'RegexpRef'
        => as 'Ref'
        => where( \&_RegexpRef )
        => inline_as {
            'Moose::Util::TypeConstraints::Builtins::_RegexpRef(' . $_[1] . ')'
        };

    subtype 'GlobRef'
        => as 'Ref'
        => where { ref($_) eq 'GLOB' }
        => inline_as { 'ref(' . $_[1] . ') eq "GLOB"' };

    # NOTE: scalar filehandles are GLOB refs, but a GLOB ref is not always a
    # filehandle
    subtype 'FileHandle'
        => as 'Ref'
        => where {
            (ref($_) eq "GLOB" && Scalar::Util::openhandle($_))
         || (blessed($_) && $_->isa("IO::Handle"));
        }
        => inline_as {
            '(ref(' . $_[1] . ') eq "GLOB" '
            . '&& Scalar::Util::openhandle(' . $_[1] . ')) '
            . '|| (Scalar::Util::blessed(' . $_[1] . ') '
            . '&& ' . $_[1] . '->isa("IO::Handle"))'
        };

    subtype 'Object'
        => as 'Ref'
        => where { blessed($_) }
        => inline_as { 'Scalar::Util::blessed(' . $_[1] . ')' };

    subtype 'ClassName'
        => as 'Str'
        => where { is_class_loaded($_) }
            # the long Str tests are redundant here
        => inline_as { 'Class::Load::is_class_loaded(' . $_[1] . ')' };

    subtype 'RoleName'
        => as 'ClassName'
        => where {
            (Class::MOP::class_of($_) || return)->isa('Moose::Meta::Role');
        }
        => inline_as {
            $_[0]->parent()->_inline_check($_[1])
            . ' && do {'
                . 'my $meta = Class::MOP::class_of(' . $_[1] . ');'
                . '$meta && $meta->isa("Moose::Meta::Role");'
            . '}'
        };

    $registry->add_type_constraint(
        Moose::Meta::TypeConstraint::Parameterizable->new(
            name               => 'ScalarRef',
            package_defined_in => __PACKAGE__,
            parent =>
                Moose::Util::TypeConstraints::find_type_constraint('Ref'),
            constraint => sub { ref($_) eq 'SCALAR' || ref($_) eq 'REF' },
            constraint_generator => sub {
                my $type_parameter = shift;
                my $check = $type_parameter->_compiled_type_constraint;
                return sub {
                    return $check->( ${$_} );
                };
            },
            inlined => sub {
                'ref(' . $_[1] . ') eq "SCALAR" '
                  . '|| ref(' . $_[1] . ') eq "REF"'
            },
            inline_generator => sub {
                my $self           = shift;
                my $type_parameter = shift;
                my $val            = shift;
                '(ref(' . $val . ') eq "SCALAR" || ref(' . $val . ') eq "REF") '
                  . '&& ' . $type_parameter->_inline_check('${(' . $val . ')}')
            },
        )
    );

    $registry->add_type_constraint(
        Moose::Meta::TypeConstraint::Parameterizable->new(
            name               => 'ArrayRef',
            package_defined_in => __PACKAGE__,
            parent =>
                Moose::Util::TypeConstraints::find_type_constraint('Ref'),
            constraint => sub { ref($_) eq 'ARRAY' },
            constraint_generator => sub {
                my $type_parameter = shift;
                my $check = $type_parameter->_compiled_type_constraint;
                return sub {
                    foreach my $x (@$_) {
                        ( $check->($x) ) || return;
                    }
                    1;
                    }
            },
            inlined          => sub { 'ref(' . $_[1] . ') eq "ARRAY"' },
            inline_generator => sub {
                my $self           = shift;
                my $type_parameter = shift;
                my $val            = shift;

                'do {'
                    . 'my $check = ' . $val . ';'
                    . 'ref($check) eq "ARRAY" '
                        . '&& &List::Util::all('
                            . 'sub { ' . $type_parameter->_inline_check('$_') . ' }, '
                            . '@{$check}'
                        . ')'
                . '}';
            },
        )
    );

    $registry->add_type_constraint(
        Moose::Meta::TypeConstraint::Parameterizable->new(
            name               => 'HashRef',
            package_defined_in => __PACKAGE__,
            parent =>
                Moose::Util::TypeConstraints::find_type_constraint('Ref'),
            constraint => sub { ref($_) eq 'HASH' },
            constraint_generator => sub {
                my $type_parameter = shift;
                my $check = $type_parameter->_compiled_type_constraint;
                return sub {
                    foreach my $x ( values %$_ ) {
                        ( $check->($x) ) || return;
                    }
                    1;
                    }
            },
            inlined          => sub { 'ref(' . $_[1] . ') eq "HASH"' },
            inline_generator => sub {
                my $self           = shift;
                my $type_parameter = shift;
                my $val            = shift;

                'do {'
                    . 'my $check = ' . $val . ';'
                    . 'ref($check) eq "HASH" '
                        . '&& &List::Util::all('
                            . 'sub { ' . $type_parameter->_inline_check('$_') . ' }, '
                            . 'values %{$check}'
                        . ')'
                . '}';
            },
        )
    );

    $registry->add_type_constraint(
        Moose::Meta::TypeConstraint::Parameterizable->new(
            name               => 'Maybe',
            package_defined_in => __PACKAGE__,
            parent =>
                Moose::Util::TypeConstraints::find_type_constraint('Item'),
            constraint           => sub {1},
            constraint_generator => sub {
                my $type_parameter = shift;
                my $check = $type_parameter->_compiled_type_constraint;
                return sub {
                    return 1 if not( defined($_) ) || $check->($_);
                    return;
                    }
            },
            inlined          => sub {'1'},
            inline_generator => sub {
                my $self           = shift;
                my $type_parameter = shift;
                my $val            = shift;
                '!defined(' . $val . ') '
                  . '|| (' . $type_parameter->_inline_check($val) . ')'
            },
        )
    );
}

1;

package Moose::Util::MetaRole;
our $VERSION = '2.2204';

use strict;
use warnings;
use Scalar::Util 'blessed';

use List::Util 1.33 qw( first all );
use Moose::Deprecated;
use Moose::Util 'throw_exception';

sub apply_metaroles {
    my %args = @_;

    my $for = _metathing_for( $args{for} );

    if ( $for->isa('Moose::Meta::Role') ) {
        return _make_new_metaclass( $for, $args{role_metaroles}, 'role' );
    }
    else {
        return _make_new_metaclass( $for, $args{class_metaroles}, 'class' );
    }
}

sub _metathing_for {
    my $passed = shift;

    my $found
        = blessed $passed
        ? $passed
        : Class::MOP::class_of($passed);

    return $found
        if defined $found
            && blessed $found
            && (   $found->isa('Moose::Meta::Role')
                || $found->isa('Moose::Meta::Class') );

    local $Carp::CarpLevel = $Carp::CarpLevel + 1;

    throw_exception( InvalidArgPassedToMooseUtilMetaRole => argument => $passed );
}

sub _make_new_metaclass {
    my $for     = shift;
    my $roles   = shift;
    my $primary = shift;

    return $for unless keys %{$roles};

    my $new_metaclass
        = exists $roles->{$primary}
        ? _make_new_class( ref $for, $roles->{$primary} )
        : blessed $for;

    my %classes;

    for my $key ( grep { $_ ne $primary } keys %{$roles} ) {
        my $attr = first {$_}
            map { $for->meta->find_attribute_by_name($_) } (
            $key . '_metaclass',
            $key . '_class'
        );

        my $reader = $attr->get_read_method;

        $classes{ $attr->init_arg }
            = _make_new_class( $for->$reader(), $roles->{$key} );
    }

    my $new_meta = $new_metaclass->reinitialize( $for, %classes );

    return $new_meta;
}

sub apply_base_class_roles {
    my %args = @_;

    my $meta = _metathing_for( $args{for} || $args{for_class} );
    throw_exception( CannotApplyBaseClassRolesToRole => params    => \%args,
                                                        role_name => $meta->name,
                   )
        if $meta->isa('Moose::Meta::Role');

    my $new_base = _make_new_class(
        $meta->name,
        $args{roles},
        [ $meta->superclasses() ],
    );

    $meta->superclasses($new_base)
        if $new_base ne $meta->name();
}

sub _make_new_class {
    my $existing_class = shift;
    my $roles          = shift;
    my $superclasses   = shift || [$existing_class];

    return $existing_class unless $roles;

    my $meta = Class::MOP::Class->initialize($existing_class);

    return $existing_class
        if $meta->can('does_role') && all  { $meta->does_role($_) }
                                      grep { !ref $_ } @{$roles};

    return Moose::Meta::Class->create_anon_class(
        superclasses => $superclasses,
        roles        => $roles,
        cache        => 1,
    )->name();
}

1;

# ABSTRACT: Apply roles to any metaclass, as well as the object base class

package Moose::Object;
our $VERSION = '2.2204';

use strict;
use warnings;

use Carp ();
use Devel::GlobalDestruction ();
use MRO::Compat ();
use Scalar::Util ();
use Try::Tiny ();

use Moose::Util ();

use if ( not our $__mx_is_compiled ), 'Moose::Meta::Class';
use if ( not our $__mx_is_compiled ), metaclass => 'Moose::Meta::Class';

sub new {
    my $class = shift;
    my $real_class = Scalar::Util::blessed($class) || $class;

    my $params = $real_class->BUILDARGS(@_);

    return Class::MOP::Class->initialize($real_class)->new_object($params);
}

sub BUILDARGS {
    my $class = shift;
    if ( scalar @_ == 1 ) {
        unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
            Moose::Util::throw_exception( "SingleParamsToNewMustBeHashRef" );
        }
        return { %{ $_[0] } };
    }
    elsif ( @_ % 2 ) {
        Carp::carp(
            "The new() method for $class expects a hash reference or a key/value list."
                . " You passed an odd number of arguments" );
        return { @_, undef };
    }
    else {
        return { @_ };
    }
}

sub BUILDALL {
    # NOTE: we ask Perl if we even
    # need to do this first, to avoid
    # extra meta level calls
    return unless $_[0]->can('BUILD');
    my ($self, $params) = @_;
    return if $params->{__no_BUILD__};
    foreach my $method (reverse Class::MOP::class_of($self)->find_all_methods_by_name('BUILD')) {
        $method->{code}->execute($self, $params);
    }
}

sub DEMOLISHALL {
    my $self = shift;
    my ($in_global_destruction) = @_;

    # NOTE: we ask Perl if we even
    # need to do this first, to avoid
    # extra meta level calls
    return unless $self->can('DEMOLISH');

    my @isa;
    if ( my $meta = Class::MOP::class_of($self ) ) {
        @isa = $meta->linearized_isa;
    } else {
        # We cannot count on being able to retrieve a previously made
        # metaclass, _or_ being able to make a new one during global
        # destruction. However, we should still be able to use mro at
        # that time (at least tests suggest so ;)
        my $class_name = ref $self;
        @isa = @{ mro::get_linear_isa($class_name) }
    }

    foreach my $class (@isa) {
        no strict 'refs';
        my $demolish = *{"${class}::DEMOLISH"}{CODE};
        $self->$demolish($in_global_destruction)
            if defined $demolish;
    }
}

sub DESTROY {
    my $self = shift;

    local $?;

    # < doy> if the destructor is being called because an exception is thrown, then $@ will be set
    # < doy> but if DEMOLISH does an eval which succeeds, that will clear $@
    # < doy> which is broken
    # < doy> try::tiny implicitly localizes $@ in the try block, which fixes that
    Try::Tiny::try {
        $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
    }
    Try::Tiny::catch {
        die $_;
    };

    return;
}

# support for UNIVERSAL::DOES ...
BEGIN {
    my $does = UNIVERSAL->can("DOES") ? "SUPER::DOES" : "isa";
    eval 'sub DOES {
        my ( $self, $class_or_role_name ) = @_;
        return $self->'.$does.'($class_or_role_name)
            || $self->does($class_or_role_name);
    }';
}

# new does() methods will be created
# as appropriate see Moose::Meta::Role
sub does {
    my ($self, $role_name) = @_;
    my $class = Scalar::Util::blessed($self) || $self;
    my $meta = Class::MOP::Class->initialize($class);
    (defined $role_name)
        || Moose::Util::throw_exception( DoesRequiresRoleName => class_name => $meta->name );
    return 1 if $meta->can('does_role') && $meta->does_role($role_name);
    return 0;
}

sub dump {
    my $self = shift;
    require Data::Dumper;
    local $Data::Dumper::Maxdepth = shift if @_;
    Data::Dumper::Dumper $self;
}

1;

# ABSTRACT: The base object for Moose

package Moose::Exception::CouldNotLocateTypeConstraintForUnion;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

sub _build_message {
    my $self = shift;
    "Could not locate type constraint (".$self->type_name.") for the union";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::IncompatibleMetaclassOfSuperclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

has [qw/superclass_name superclass_meta_type class_meta_type/] => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    my $self            = shift;
    my $class_name      = $self->class_name;
    my $class_meta_type = $self->class_meta_type;
    my $superclass_name = $self->superclass_name;
    my $supermeta_type  = $self->superclass_meta_type;

    return "The metaclass of $class_name ($class_meta_type)" .
           " is not compatible with the metaclass of its superclass, " .
           "$superclass_name ($supermeta_type)";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InitMetaRequiresClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

sub _build_message {
    "Cannot call init_meta without specifying a for_class";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::ParameterIsNotSubtypeOfParent;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

use Moose::Util::TypeConstraints qw/find_type_constraint/;

has 'type_parameter' => (
    is => 'ro',
    isa => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $type_parameter = $self->type_parameter;
    my $type           = find_type_constraint( $self->type_name );
    my $parent         = $type->parent->type_parameter;

    return "$type_parameter is not a subtype of $parent";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CanReblessOnlyIntoASubclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::InstanceClass';

sub _build_message {
    my $self           = shift;
    my $instance_class = $self->instance_class;
    "You may rebless only into a subclass of ($instance_class), of which (". $self->class_name .") isn't."
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresent;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::Method';

has 'role_being_applied_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'aliased_method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "Cannot create a method alias if a local method of the same name exists";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotAssignValueToReadOnlyAccessor;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::EitherAttributeOrAttributeName';

has 'value' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    my $self = shift;
    "Cannot assign a value to a read-only accessor";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MOPAttributeNewNeedsAttributeName;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "You must provide a name for the attribute";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::UnionTakesAtleastTwoTypeNames;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    "You must pass in at least 2 type names to make a union";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustPassEvenNumberOfAttributeOptions;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'options' => (
    is       => 'ro',
    isa      => 'ArrayRef',
    required => 1
);

has 'attribute_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    return 'You must pass an even number of attribute options';
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::TypeParameterMustBeMooseMetaType;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

sub _build_message {
    "The type parameter must be a Moose meta type";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::ClassDoesNotHaveInitMeta;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

has 'traits' => (
    is       => 'ro',
    isa      => 'ArrayRef',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $class = $self->class_name;

    return "Cannot provide traits when $class does not have an init_meta() method";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InvalidArgPassedToMooseUtilMetaRole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'argument' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $error = 'When using Moose::Util::MetaRole, you must pass a Moose class name,'
        . ' role name, metaclass object, or metarole object.';

    my $arg = $self->argument;
    my $found = blessed $arg ? $arg : Class::MOP::class_of($arg);

    my $error2;

    if ( defined $found && blessed $found ) {
        $error2 = " You passed ".$arg.", and we resolved this to a "
            . ( blessed $found )
            . ' object.';
    }
    elsif ( !defined $found ) {
        $error2 = " You passed ".( defined $arg ? $arg : "undef" ).", and this did not resolve to a metaclass or metarole."
            . ' Maybe you need to call Moose->init_meta to initialize the metaclass first?';
    }
    else {
        $error2 = " You passed an undef."
            . ' Maybe you need to call Moose->init_meta to initialize the metaclass first?';
    }

    $error.$error2;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MethodExpectsMoreArgs;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'minimum_args' => (
    is       => 'ro',
    isa      => 'Int',
    required => 1
);

sub _build_message {
    my $self = shift;
    "Cannot call ".$self->method_name." without at least ".$self->minimum_args." argument".($self->minimum_args == 1 ? '' : 's');
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CreateTakesArrayRefOfRoles;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::RoleForCreate';

sub _build_message {
    "You must pass an ARRAY ref of roles";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CallingMethodOnAnImmutableInstance;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "The '".$self->method_name."' method cannot be called on an immutable instance";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::DelegationToAClassWhichIsNotLoaded;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute';

has 'class_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "The ".$self->attribute->name." attribute is trying to delegate to a class which has not been loaded - ".$self->class_name;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MethodModifierNeedsMethodName;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

sub _build_message {
    "You must pass in a method name";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotDelegateWithoutIsa;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute';

sub _build_message {
    "Cannot delegate methods based on a Regexp without a type constraint (isa)";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::NoBodyToInitializeInAnAbstractBaseClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'package_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "No body to initialize, " .$self->package_name. " is an abstract base class";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustPassAMooseMetaRoleInstanceOrSubclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'role' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    "You must pass a Moose::Meta::Role instance (or a subclass)";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::DefaultToMatchOnTypeMustBeCodeRef;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'to_match' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

has 'default_action' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

has 'cases_to_be_matched' => (
    is       => 'ro',
    isa      => 'ArrayRef',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $default = $self->default_action;

    return "Default case must be a CODE ref, not $default";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustDefineAnOverloadOperator;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Instance';

sub _build_message {
    "You must define an overload operator";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::OverloadRequiresAMetaClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    my $self = shift;
    'If you provide an associated_metaclass parameter to the Moose::Meta::Overload constructor it must be a Class::MOP::Module object';
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotDelegateLocalMethodIsPresent;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Method';

sub _build_message {
    my $self = shift;
    "You cannot overwrite a locally defined method (".$self->method->name.") with a delegation";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustSupplyADelegateToMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "You must supply a delegate_to_method which is a method name or a CODE reference";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotOverrideBodyOfMetaMethods;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "Overriding the body of meta methods is not allowed";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InvalidBaseTypeGivenToCreateParameterizedTypeConstraint;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

sub _build_message {
    my $self = shift;
    "Could not locate the base type (".$self->type_name.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotApplyBaseClassRolesToRole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Role';

sub _build_message {
    "You can only apply base class roles to a Moose class, not a role.";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InvalidArgumentsToTraitAliases;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

use Scalar::Util qw(reftype);

has 'alias' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

has 'package_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $alias = $self->alias;
    my $reftype_alias = reftype($alias);

    return "$reftype_alias references are not "
        . "valid arguments to the 'trait_aliases' option";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CreateMOPClassTakesHashRefOfMethods;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::RoleForCreateMOPClass';

sub _build_message {
    "You must pass an HASH ref of methods";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RoleNameRequiredForMooseMetaRole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

sub _build_message {
    "You must supply a role name to look for";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AttributeValueIsNotDefined;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::Attribute';

has 'method' => (
    is       => 'ro',
    isa      => 'Moose::Meta::Method::Delegation',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "Cannot delegate ".$self->method->name." to "
    .$self->method->delegate_to_method." because the value of "
    . $self->attribute->name . " is not defined";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RoleExclusionConflict;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

has 'roles' => (
    is         => 'ro',
    isa        => 'ArrayRef',
    required   => 1,
);

sub _build_message {
    my $self = shift;

    my @roles_array = @{$self->roles};
    my $role_noun = "Role".( @roles_array == 1 ? '' : 's');
    my $all_roles = join(', ', @roles_array);
    my $verb = "exclude".( @roles_array == 1 ? 's' : '' );
    my $role_name = $self->role_name;

    return "Conflict detected: $role_noun $all_roles $verb role '$role_name'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MethodNameNotFoundInInheritanceHierarchy;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

has 'method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "The method '".$self->method_name."' was not found in the inheritance hierarchy for ".$self->class_name;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::LazyAttributeNeedsADefault;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::EitherAttributeOrAttributeName';

sub _build_message {
    my $self = shift;
    "You cannot have a lazy attribute (".$self->attribute_name.") without specifying a default value for it";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::ConstructClassInstanceTakesPackageName;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    "You must pass a package name";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AutoDeRefNeedsArrayRefOrHashRef;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::InvalidAttributeOptions';

sub _build_message {
    my $self = shift;
    "You cannot auto-dereference anything other than a ArrayRef or HashRef on attribute (".$self->attribute_name.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::OnlyInstancesCanBeCloned;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';

has 'instance' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "You can only clone instances, (".$self->instance.") is not a blessed instance";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MetaclassMustBeDerivedFromClassMOPClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'class_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "The metaclass (".$self->class_name.") must be derived from Class::MOP::Class";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotOverrideNoSuperMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "You cannot override '".$self->method_name."' because it has no super method";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CouldNotCreateWriter;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::EitherAttributeOrAttributeName', 'Moose::Exception::Role::Instance';

has 'error' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $error = $self->error;
    my $attribute_name = $self->attribute_name;

    return "Could not create writer for '$attribute_name' "
        . "because $error";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::ReferencesAreNotAllowedAsDefault;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'attribute_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "References are not allowed as default values, you must wrap the default of '".
        $self->attribute_name."' in a CODE reference (ex: sub { [] } and not [])";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustSupplyAnAccessorTypeToConstructWith;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "You must supply an accessor_type to construct with";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::Role::Role;
our $VERSION = '2.2204';

# use Moose::Util 'throw_exception';
use Moose::Role;

has 'role_name' => (
    is            => 'ro',
    isa           => 'Str',
    required      => 1,
    documentation => "This attribute can be used for fetching the class's metaclass instance:\n".
                     "    my \$metaclass_instance = Moose::Util::find_meta( \$exception->role_name );\n",

);

1;
package Moose::Exception::Role::ParamsHash;
our $VERSION = '2.2204';

use Moose::Role;

has 'params' => (
    is       => 'ro',
    isa      => 'HashRef',
    required => 1,
);

1;
package Moose::Exception::Role::InstanceClass;
our $VERSION = '2.2204';

use Moose::Role;

has 'instance_class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

1;
package Moose::Exception::Role::Instance;
our $VERSION = '2.2204';

use Moose::Role;

has 'instance' => (
    is       => 'ro',
    isa      => 'Object',
    required => 1,
);

1;
package Moose::Exception::Role::AttributeName;
our $VERSION = '2.2204';

use Moose::Role;

has 'attribute_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

1;
package Moose::Exception::Role::Class;
our $VERSION = '2.2204';

use Moose::Role;

has 'class_name' => (
    is            => 'ro',
    isa           => 'Str',
    required      => 1,
    documentation => "This attribute can be used for fetching metaclass instance:\n".
                     "    my \$metaclass_instance = Moose::Util::find_meta( \$exception->class_name );\n",
);

1;
package Moose::Exception::Role::TypeConstraint;
our $VERSION = '2.2204';

use Moose::Role;

has 'type_name' => (
    is            => 'ro',
    isa           => 'Str',
    required      => 1,
    documentation => "This attribute can be used for fetching type constraint(Moose::Meta::TypeConstraint):\n".
                     "    my \$type_constraint =  Moose::Util::TypeConstraints::find_type_constraint( \$exception->type_name );\n",
);

1;
package Moose::Exception::Role::RoleForCreate;
our $VERSION = '2.2204';

use Moose::Role;
with 'Moose::Exception::Role::ParamsHash';

has 'attribute_class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

1;
package Moose::Exception::Role::RoleForCreateMOPClass;
our $VERSION = '2.2204';

use Moose::Role;
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

1;
package Moose::Exception::Role::Method;
our $VERSION = '2.2204';

use Moose::Role;

has 'method' => (
    is       => 'ro',
    isa      => 'Moose::Meta::Method',
    required => 1,
);

1;
package Moose::Exception::Role::EitherAttributeOrAttributeName;
our $VERSION = '2.2204';

use Moose::Util 'throw_exception';
use Moose::Role;

has 'attribute_name' => (
    is         => 'ro',
    isa        => 'Str',
    lazy_build => 1
);

has 'attribute' => (
    is        => 'ro',
    isa       => 'Class::MOP::Attribute',
    predicate => 'has_attribute'
);

has 'params' => (
    is        => 'ro',
    isa       => 'HashRef',
    predicate => 'has_params',
);

sub _build_attribute_name {
    my $self = shift;

    if( !$self->has_attribute )
    {
        throw_exception("NeitherAttributeNorAttributeNameIsGiven");
    }

    return $self->attribute->name;
}

after "BUILD" => sub {
    my $self = $_[0];

    if( $self->has_attribute_name &&
        $self->has_attribute &&
        ( $self->attribute->name ne $self->attribute_name ) )
    {
        throw_exception( AttributeNamesDoNotMatch => attribute_name => $self->attribute_name,
                                                     attribute      => $self->attribute
                       );
    }
};

1;
package Moose::Exception::Role::InvalidAttributeOptions;
our $VERSION = '2.2204';

use Moose::Role;
with 'Moose::Exception::Role::ParamsHash';

has 'attribute_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

1;
package Moose::Exception::Role::Attribute;
our $VERSION = '2.2204';

use Moose::Role;

has 'attribute' => (
    is        => 'ro',
    isa       => 'Class::MOP::Attribute',
    predicate => 'is_attribute_set'
);

1;
package Moose::Exception::InvalidHasProvidedInARole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

has 'attribute_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    "Usage: has 'name' => ( key => value, ... )";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RolesListMustBeInstancesOfMooseMetaRole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'role' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    my $self = shift;
    "The list of roles must be instances of Moose::Meta::Role, not ".$self->role;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::PackageNameAndNameParamsNotGivenToWrap;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'code' => (
    is       => 'ro',
    isa      => 'CodeRef',
    required => 1
);

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "You must supply the package_name and name parameters";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::ClassDoesTheExcludedRole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::Class';

has 'excluded_role_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self               = shift;
    my $excluded_role_name = $self->excluded_role_name;
    my $class_name         = $self->class_name;
    return "The class $class_name does the excluded role '$excluded_role_name'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotCallAnAbstractBaseMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'package_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    $self->package_name. " is an abstract base class, you must provide a constructor.";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotCallAnAbstractMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    "Abstract method";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::IllegalInheritedOptions;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'illegal_options' => (
    is       => 'ro',
    traits   => ['Array'],
    handles  => {
        _join_options => 'join',
    },
    required => 1,
);

sub _build_message {
    my $self = shift;
    "Illegal inherited options => (".$self->_join_options(', ').")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::WrongTypeConstraintGiven;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has [qw/required_type given_type attribute_name/] => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "The type constraint for ".$self->attribute_name." must be a subtype of "
    .$self->required_type." but it's a ".$self->given_type;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::NeitherRoleNorRoleNameIsGiven;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    "You need to give role or role_name or both";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::NoParentGivenToSubtype;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "A subtype cannot consist solely of a name, it must have a parent";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RolesDoNotSupportInner;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    "Roles cannot support 'inner'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustSpecifyAtleastOneMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

sub _build_message {
    "Must specify at least one method";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::UnableToRecognizeDelegateMetaclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute';

has 'delegate_metaclass' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $meta = $self->delegate_metaclass;

    return "Unable to recognize the delegate metaclass '$meta'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotUseLazyBuildAndDefaultSimultaneously;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::InvalidAttributeOptions';

sub _build_message {
    my $self = shift;
    "You can not use lazy_build and default for the same attribute (".$self->attribute_name.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CanExtendOnlyClasses;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

sub _build_message {
    my $self      = shift;
    my $role_name = $self->role_name;
    return "You cannot inherit from a Moose Role ($role_name)";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::UndefinedHashKeysPassedToMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'hash_keys' => (
    is         => 'ro',
    isa        => 'ArrayRef',
    required   => 1
);

has 'method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "Hash keys passed to ".$self->method_name." must be defined";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustHaveAtLeastOneValueToEnumerate;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "You must have at least one value to enumerate through";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotCreateHigherOrderTypeWithoutATypeParameter;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

sub _build_message {
    "You cannot create a Higher Order type without a type parameter";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotFixMetaclassCompatibility;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

has 'superclass' => (
    is       => 'ro',
    isa      => 'Object',
    required => 1
);

has 'metaclass_type' => (
    is       => 'ro',
    isa      => 'Str',
);

sub _build_message {
    my $self = shift;
    my $class_name = $self->class_name;
    "Can't fix metaclass incompatibility for $class_name because it is not pristine.";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustPassEvenNumberOfArguments;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'args' => (
    is         => 'ro',
    isa        => 'ArrayRef',
    required   => 1
);

has 'method_name' => (
    is         => 'ro',
    isa        => 'Str',
    required   => 1
);

sub _build_message {
    my $self = shift;
    "You must pass an even number of arguments to ".$self->method_name;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustSupplyAClassMOPAttributeInstance;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "You must supply an attribute which is a 'Class::MOP::Attribute' instance";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::UnableToCanonicalizeHandles;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute';

has 'handles' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "Unable to canonicalize the 'handles' option with ".$self->handles;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MetaclassTypeIncompatible;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

use Moose::Util 'find_meta';

has [qw(superclass_name metaclass_type)] => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $class_name = $self->class_name;
    my $superclass_name = $self->superclass_name;
    my $metaclass_type = $self->metaclass_type;

    my $metaclass_type_name = $metaclass_type;
    $metaclass_type_name =~ s/_(?:meta)?class$//;
    $metaclass_type_name =~ s/_/ /g;

    my $class = find_meta( $class_name );

    my $self_metaclass_type = $class->$metaclass_type;

    my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
    my $super_metatype = $super_meta->$metaclass_type;

   return "The $metaclass_type metaclass for $class_name"
   . " ($self_metaclass_type) is not compatible with the $metaclass_type_name"
   . " metaclass of its superclass, $superclass_name ($super_metatype)";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CodeBlockMustBeACodeRef;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Instance';

sub _build_message {
    "Your code block must be a CODE reference";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RequiredAttributeLacksInitialization;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "A required attribute must have either 'init_arg', 'builder', or 'default'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotCalculateNativeType;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Instance';

sub _build_message {
    my $self = shift;
    "Cannot calculate native type for " . ref $self->instance;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustSupplyPackageNameAndName;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "You must supply the package_name and name parameters";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::ClassNamesDoNotMatch;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has class_name => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

has class => (
    is       => 'ro',
    isa      => 'Class::MOP::Class',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "class_name (".$self-> class_name.") does not match class->name (".$self->class->name.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::BuilderMethodNotSupportedForAttribute;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Instance';

sub _build_message {
    my $self = shift;
    blessed($self->instance)." does not support builder method '". $self->attribute->builder ."' for attribute '" . $self->attribute->name . "'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RolesInCreateTakesAnArrayRef;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

sub _build_message {
    my $self = shift;
    "You must pass an ARRAY ref of roles";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotCoerceAWeakRef;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::InvalidAttributeOptions';

sub _build_message {
    my $self = shift;
    "You cannot have a weak reference to a coerced value on attribute (".$self->attribute_name.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CanOnlyConsumeRole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'role_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "You can only consume roles, ".$self->role_name." is not a Moose role";
}
__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresentInClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::Method', 'Moose::Exception::Role::Class';

has 'aliased_method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "Cannot create a method alias if a local method of the same name exists";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CoercingWithoutCoercions;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

sub _build_message {
    my $self = shift;
    "Cannot coerce without a type coercion";
}
1;
package Moose::Exception::OverloadRequiresNamesForCoderef;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    my $self = shift;
    'If you provide a coderef parameter to the Moose::Meta::Overload constructor you must also provide coderef_package and coderef_name parameters';
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::ConflictDetectedInCheckRoleExclusionsInToClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Role';

sub _build_message {
    my $self       = shift;
    my $class_name = $self->class_name;
    my $role_name  = $self->role_name;
    return "Conflict detected: $class_name excludes role '$role_name'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::TriggerMustBeACodeRef;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::InvalidAttributeOptions';

sub _build_message {
    my $self = shift;
    "Trigger must be a CODE ref on attribute (".$self->attribute_name.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InvalidOverloadOperator;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has operator => (
    is       => 'ro',
    isa      => 'Defined',
    required => 1,
);

sub _build_message {
    my $self = shift;
    'The operator parameter you passed to the Moose::Meta::Overload constructor ('
        . $self->operator()
        . ') was not a valid overloading operator';
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::ValidationFailedForTypeConstraint;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute';

has 'value' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1,
);

has 'type' => (
    is       => 'ro',
    isa      => Moose::Util::TypeConstraints->duck_type(["get_message", "name"]),
    required => 1
);

sub _build_message {
    my $self = shift;

    my $error = $self->type->get_message( $self->value );

    return $error unless $self->is_attribute_set;

    my $attribute_name = $self->attribute->name;
    return
        "Attribute ($attribute_name) does not pass the type constraint because: $error";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RolesDoNotSupportExtends;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    "Roles do not support 'extends' (you can use 'with' to specialize a role)";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::EnumCalledWithAnArrayRefAndAdditionalArgs;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'array' => (
    is       => 'ro',
    isa      => 'ArrayRef',
    required => 1
);

has 'args' => (
    is       => 'ro',
    isa      => 'ArrayRef',
    required => 1
);

sub _build_message {
    "enum called with an array reference and additional arguments. Did you mean to parenthesize the enum call's parameters?";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustDefineAMethodName;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Instance';

sub _build_message {
    "You must define a method name";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::NoCasesMatched;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'to_match' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

has 'cases_to_be_matched' => (
    is       => 'ro',
    isa      => 'ArrayRef',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $to_match = $self->to_match;

    return "No cases matched for $to_match";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustPassAPackageNameOrAnExistingClassMOPPackageInstance;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    "You must pass a package name or an existing Class::MOP::Package instance";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RequiredAttributeNeedsADefault;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::InvalidAttributeOptions';

sub _build_message {
    my $self = shift;
    "You cannot have a required attribute (".$self->attribute_name.") without a default, builder, or an init_arg";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotAddAsAnAttributeToARole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

has 'attribute_class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "Cannot add a ".$self->attribute_class." as an attribute to a role";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CreateMOPClassTakesArrayRefOfSuperclasses;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::RoleForCreateMOPClass';

sub _build_message {
    "You must pass an ARRAY ref of superclasses";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AttributeIsRequired;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

has 'attribute_name' => (
    is            => 'ro',
    isa           => 'Str',
    required      => 1,
    documentation => "This attribute can be used for fetching attribute instance:\n".
                     "    my \$class = Moose::Util::find_meta( \$exception->class_name );\n".
                     "    my \$attribute = \$class->get_attribute( \$exception->attribute_name );\n",
);

has 'attribute_init_arg' => (
    is  => 'ro',
    isa => 'Str',
);

has 'params' => (
    is        => 'ro',
    isa       => 'HashRef',
    predicate => 'has_params',
);

sub _build_message {
    my $self = shift;

    my $name = $self->attribute_name;
    my $msg  = "Attribute ($name)";

    my $init_arg = $self->attribute_init_arg;
    if ( defined $init_arg && $name ne $init_arg ) {
        $msg .= ", passed as ($init_arg),";
    }

    $msg .= ' is required';

    return $msg;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotInitializeMooseMetaRoleComposite;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'role_composite' => (
    is       => 'ro',
    isa      => 'Moose::Meta::Role::Composite',
    required => 1
);

has 'old_meta' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

has 'args' => (
    is       => 'ro',
    isa      => 'ArrayRef',
    required => 1
);

sub _build_message {
    'Moose::Meta::Role::Composite instances can only be reinitialized from an existing metaclass instance';
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InitializeTakesUnBlessedPackageName;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'package_name' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1,
);

sub _build_message {
    "You must pass a package name and it cannot be blessed";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CouldNotFindTypeConstraintToCoerceFrom;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Instance';

has 'constraint_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "Could not find the type constraint (".$self->constraint_name.") to coerce from";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotInlineTypeConstraintCheck;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

sub _build_message {
    my $self = shift;
    'Cannot inline a type constraint check for ' . $self->type_name;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::UnionCalledWithAnArrayRefAndAdditionalArgs;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'array' => (
    is       => 'ro',
    isa      => 'ArrayRef',
    required => 1
);

has 'args' => (
    is       => 'ro',
    isa      => 'ArrayRef',
    required => 1
);

sub _build_message {
    "union called with an array reference and additional arguments";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InvalidValueForIs;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::InvalidAttributeOptions';

sub _build_message {
    my $self = shift;
    "I do not understand this option (is => ".$self->params->{is}.") on attribute (".$self->attribute_name.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::NeitherClassNorClassNameIsGiven;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    "You need to give class or class_name or both";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::HandlesMustBeAHashRef;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Instance';

has 'given_handles' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    my $self = shift;
    "The 'handles' option must be a HASH reference, not ".$self->given_handles;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustSupplyAMetaclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "You must pass a metaclass instance if you want to inline";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::NoConstraintCheckForTypeConstraint;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

sub _build_message {
    my $self = shift;
    "Could not compile type constraint '".$self->type_name."' because no constraint check";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustSupplyArrayRefAsCurriedArguments;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class';

sub _build_message {
    "You must supply a curried_arguments which is an ARRAY reference";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotAutoDereferenceTypeConstraint;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::TypeConstraint';

sub _build_message {
    my $self = shift;
    "Can not auto de-reference the type constraint '" . $self->type_name . "'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotAddAdditionalTypeCoercionsToUnion;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'type_coercion_union_object' => (
    is       => 'ro',
    isa      => 'Moose::Meta::TypeCoercion::Union',
    required => 1
);

sub _build_message {
    return "Cannot add additional type coercions to Union types";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MetaclassIsARoleNotASubclassOfGivenMetaclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

use Moose::Util 'find_meta';

has 'metaclass' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $role_name = $self->role_name;
    my $role      = find_meta( $role_name );
    my $metaclass = $self->metaclass;
    return "$role_name already has a metaclass, but it does not inherit $metaclass ($role). "
        ."You cannot make the same thing a role and a class. Remove either Moose or Moose::Role.";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RoleDoesTheExcludedRole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

has 'excluded_role_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'second_role_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self               = shift;
    my $role_name          = $self->role_name;
    my $excluded_role_name = $self->excluded_role_name;
    return "The role $role_name does the excluded role '$excluded_role_name'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AttributeNamesDoNotMatch;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has attribute_name => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

has attribute => (
    is       => 'ro',
    isa      => 'Class::MOP::Attribute',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "attribute_name (".$self-> attribute_name.") does not match attribute->name (".$self->attribute->name.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustProvideANameForTheAttribute;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "You must provide a name for the attribute";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::TypeConstraintCannotBeUsedForAParameterizableType;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

has 'parent_type_name' => (
    is            => 'ro',
    isa           => 'Str',
    required      => 1,
    documentation => "This attribute can be used for fetching type constraint(Moose::Meta::TypeConstraint):\n".
                     "    my \$type_constraint =  Moose::Util::TypeConstraints::find_type_constraint( \$exception->parent_type_name );\n",
);

sub _build_message {
    my $self             = shift;
    my $type_name        = $self->type_name;
    my $parent_type_name = $self->parent_type_name;
    "The $type_name constraint cannot be used, because "
        . "$parent_type_name doesn't subtype or coerce from a parameterizable type.";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MetaclassIsNotASubclassOfGivenMetaclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

use Moose::Util 'find_meta';

has 'metaclass' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $class = find_meta( $self->class_name );
    $self->class_name." already has a metaclass, but it does not inherit ".$self->metaclass." ($class).";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::ApplyTakesABlessedInstance;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

has 'param' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1,
);

sub _build_message {
    "You must pass in an blessed instance";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CreateTakesHashRefOfMethods;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::RoleForCreate';

sub _build_message {
    "You must pass a HASH ref of methods";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CanOnlyWrapBlessedCode;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'code' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    "Can only wrap blessed CODE";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MethodNameConflictInRoles;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

has 'conflict' => (
    traits     => ['Array'],
    is         => 'ro',
    isa        => 'ArrayRef[Moose::Meta::Role::Method::Conflicting]',
    handles    => { conflict_methods_count => 'count',
                    get_method_at          => 'get',
                    get_all_methods        => 'elements',
    },
    required   => 1
);

sub _get_method_names {
    my $self = shift;

    return ( $self->conflict_methods_count == 1 ?
        "'".$self->get_method_at(0)->name."'":
        Moose::Util::english_list( map { q{'} . $_->name . q{'} } $self->get_all_methods ) );
}

sub _build_message {
    my $self = shift;
    my $count = $self->conflict_methods_count;
    my $roles = $self->get_method_at(0)->roles_as_english_list;

    if( $count == 1 )
    {
        "Due to a method name conflict in roles "
        .$roles.", the method ".$self->_get_method_names
        ." must be implemented or excluded by '".$self->class_name."'";
    }
    else
    {
        "Due to method name conflicts in roles "
        .$roles.", the methods ".$self->_get_method_names
        ." must be implemented or excluded by '".$self->class_name."'";
    }
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::OverrideConflictInSummation;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

use Moose::Util 'find_meta';

has 'role_application' => (
    is       => 'ro',
    isa      => 'Moose::Meta::Role::Application::RoleSummation',
    required => 1
);

has 'role_names' => (
    traits   => ['Array'],
    is       => 'bare',
    isa      => 'ArrayRef[Str]',
    handles  => {
        role_names      => 'elements',
    },
    required => 1,
    documentation => "This attribute is an ArrayRef containing role names, if you want metaobjects\n".
                     "associated with these role names, then call method roles on the exception object.\n",
);

has 'method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'two_overrides_found' => (
    is       => 'ro',
    isa      => 'Bool',
    required => 1,
    default  => 0
);

sub roles {
    my $self = shift;
    my @role_names = $self->role_names;
    my @roles = map { find_meta($_) } @role_names;
    return @roles;
}

sub _build_message {
    my $self = shift;

    my @roles = $self->role_names;
    my $role_names = join "|", @roles;

    if( $self->two_overrides_found ) {
        return "We have encountered an 'override' method conflict ".
               "during composition (Two 'override' methods of the same name encountered). ".
               "This is a fatal error.";
    }
    else {
        return "Role '$role_names' has encountered an 'override' method conflict " .
               "during composition (A local method of the same name has been found). This " .
               "is a fatal error." ;
    }
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MessageParameterMustBeCodeRef;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "The 'message' parameter must be a coderef";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotAutoDerefWithoutIsa;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::InvalidAttributeOptions';

sub _build_message {
    my $self = shift;
    "You cannot auto-dereference without specifying a type constraint on attribute (".$self->attribute_name.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotFindDelegateMetaclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute';

sub _build_message {
    my $self = shift;
    "Cannot find delegate metaclass for attribute ".$self->attribute->name;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::NeitherTypeNorTypeNameIsGiven;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    "You need to give type or type_name or both";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AttributeExtensionIsNotSupportedInRoles;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

has 'attribute_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    "has '+attr' is not supported in roles";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::ConflictDetectedInCheckRoleExclusions;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

has 'excluded_role_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self               = shift;
    my $role_name          = $self->role_name;
    my $excluded_role_name = $self->excluded_role_name;
    return "Conflict detected: $role_name excludes role '$excluded_role_name'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::DelegationToATypeWhichIsNotAClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute';

sub _build_message {
    my $self = shift;
    "The ".$self->attribute->name." attribute is trying to delegate to a type (".$self->attribute->type_constraint->name.") that is not backed by a class";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InvalidTypeConstraint;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'registry_object' => (
    is       => 'ro',
    isa      => 'Moose::Meta::TypeConstraint::Registry',
    required => 1
);

has 'type' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    return "No type supplied / type is not a valid type constraint";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotFindType;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'type_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "Cannot find type '".$self->type_name."', perhaps you forgot to load it";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::IsaLacksDoesMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::InvalidAttributeOptions';

sub _build_message {
    my $self = shift;
    "Cannot have an isa option which cannot ->does() on attribute (".$self->attribute_name.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CoercionAlreadyExists;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Instance';

has 'constraint_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "A coercion action already exists for '".$self->constraint_name."'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotFindTypeGivenToMatchOnType;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'to_match' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

has 'action' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

has 'type' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $type = $self->type;

    return "Cannot find or parse the type '$type'"
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::NoAttributeFoundInSuperClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::InvalidAttributeOptions';

sub _build_message {
    my $self = shift;
    "Could not find an attribute by the name of '".$self->attribute_name."' to inherit from in ".$self->class_name;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AttributeConflictInRoles;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

has 'second_role_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'attribute_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self             = shift;
    my $role_name        = $self->role_name;
    my $second_role_name = $self->second_role_name;
    my $attribute_name   = $self->attribute_name;
    "Role '$role_name' has encountered an attribute conflict"
    . " while being composed into '$second_role_name'."
    . " This is a fatal error and cannot be disambiguated."
    . " The conflicting attribute is named '$attribute_name'.";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InvalidRoleApplication;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

has 'application' => (
    is       => 'ro',
    isa      => "Any",
    required => 1,
);

sub _build_message {
    "Role applications must be instances of Moose::Meta::Role::Application::ToClass";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotLocatePackageInINC;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'INC' => (
    is       => 'ro',
    isa      => 'ArrayRef',
    required => 1
);

has 'possible_packages' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'metaclass_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'type' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    my $self = shift;
    my $possible_packages = $self->possible_packages;
    my @inc = @{$self->INC};

    return "Can't locate $possible_packages in \@INC (\@INC contains: @INC)."
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustSpecifyAtleastOneRole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

sub _build_message {
    "Must specify at least one role";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::IllegalMethodTypeToAddMethodModifier;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'class_or_object' => (
    is       => 'ro',
    isa      => "Any",
    required => 1,
);

has 'params' => (
    is       => 'ro',
    isa      => 'ArrayRef',
    required => 1,
);

has 'modifier_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "Methods passed to ".$self->modifier_name." must be provided as a list, arrayref or regex, not ".$self->params->[0];
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MetaclassIsAClassNotASubclassOfGivenMetaclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

use Moose::Util 'find_meta';

has 'metaclass' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $class = find_meta( $self->class_name );
    $self->class_name." already has a metaclass, but it does not inherit ".$self->metaclass.
        " ($class). You cannot make the same thing a role and a class. Remove either Moose or Moose::Role.";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CreateMOPClassTakesArrayRefOfAttributes;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::RoleForCreateMOPClass';

sub _build_message {
    "You must pass an ARRAY ref of attributes";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::OverloadRequiresAMetaMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    my $self = shift;
    'If you provide a method parameter to the Moose::Meta::Overload constructor it must be a Class::MOP::Method object';
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustSpecifyAtleastOneRoleToApplicant;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'applicant' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "Must specify at least one role to apply to ".$self->applicant;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::BuilderMethodNotSupportedForInlineAttribute;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::Class';

has 'attribute_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'builder' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    $self->class_name." does not support builder method '". $self->builder ."' for attribute '" . $self->attribute_name . "'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotMakeMetaclassCompatible;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

has 'superclass_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $class_name = $self->class_name;
    my $superclass = $self->superclass_name;

    return "Can't make $class_name compatible with metaclass $superclass";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustSupplyAMooseMetaAttributeInstance;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "You must supply an attribute which is a 'Moose::Meta::Attribute' instance";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::Legacy;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotGenerateInlineConstraint;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

has 'parameterizable_type_object_name' => (
    is            => 'ro',
    isa           => 'Str',
    required      => 1,
    documentation => "This attribute can be used for fetching parameterizable type constraint(Moose::Meta::TypeConstraint::Parameterizable):\n".
                     "    my \$type_constraint =  Moose::Util::TypeConstraints::find_type_constraint( \$exception->type_name );\n",
);

has 'value' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $type = $self->type_name;

    return "Can't generate an inline constraint for $type, since none was defined";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotAugmentNoSuperMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "You cannot augment '".$self->method_name."' because it has no super method";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AddRoleTakesAMooseMetaRoleInstance;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

has 'role_to_be_added' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1,
);

sub _build_message {
    "Roles must be instances of Moose::Meta::Role";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AccessorMustReadWrite;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::InvalidAttributeOptions';

sub _build_message {
    my $self = shift;
    "Cannot define an accessor name on a read-only attribute, accessors are read/write";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MethodExpectedAMetaclassObject;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'metaclass' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    "The is_needed method expected a metaclass object as its arugment";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustSupplyAnAttributeToConstructWith;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "You must supply an attribute to construct with";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::DelegationToARoleWhichIsNotLoaded;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute';

has 'role_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "The ".$self->attribute->name." attribute is trying to delegate to a role which has not been loaded - ".$self->role_name;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CanReblessOnlyIntoASuperclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::InstanceClass';

sub _build_message {
    my $self = shift;
    "You may rebless only into a superclass of (".blessed( $self->instance )."), of which (". $self->class_name .") isn't."
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AddRoleToARoleTakesAMooseMetaRole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

has 'role_to_be_added' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1,
);

sub _build_message {
    "Roles must be instances of Moose::Meta::Role";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::WrapTakesACodeRefToBless;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'code' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "You must supply a CODE reference to bless, not (" . ( $self->code ? $self->code : 'undef' ) . ")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::NeitherAttributeNorAttributeNameIsGiven;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    "You need to give attribute or attribute_name or both";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::OverloadConflictInSummation;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

use Moose::Util 'find_meta';

has 'role_application' => (
    is       => 'ro',
    isa      => 'Moose::Meta::Role::Application::RoleSummation',
    required => 1
);

has 'role_names' => (
    traits  => ['Array'],
    is      => 'bare',
    isa     => 'ArrayRef[Str]',
    handles => {
        role_names => 'elements',
    },
    required => 1,
    documentation =>
        "This attribute is an ArrayRef containing role names, if you want metaobjects\n"
        . "associated with these role names, then call method roles on the exception object.\n",
);

has 'overloaded_op' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub roles {
    my $self = shift;
    my @role_names = $self->role_names;
    my @roles = map { find_meta($_) } @role_names;
    return @roles;
}

sub _build_message {
    my $self = shift;

    my @roles = $self->role_names;
    my $role_names = join "|", @roles;

    my $op = $self->overloaded_op;
    if ( $op eq 'fallback' ) {
        return
              'We have encountered an overloading conflict for the fallback '
            . 'during composition. This is a fatal error.';
    }
    else {
        return
              "Role '$role_names' has encountered an overloading conflict "
            . "during composition. The two roles both overload the '$op' operator. "
            . 'This is a fatal error.';
    }
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::BuilderMustBeAMethodName;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "builder must be a defined scalar value which is a method name";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InvalidTypeGivenToCreateParameterizedTypeConstraint;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

sub _build_message {
    my $self = shift;
    "Could not parse type name (".$self->type_name.") correctly";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotCoerceAttributeWhichHasNoCoercion;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::InvalidAttributeOptions', 'Moose::Exception::Role::TypeConstraint';

sub _build_message {
    my $self = shift;
    my $name = $self->attribute_name;
    my $type = $self->type_name;

    return "You cannot coerce an attribute ($name) unless its type ($type) has a coercion";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MetaclassMustBeASubclassOfMooseMetaClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

sub _build_message {
    my $self = shift;
    "The Metaclass ".$self->class_name." must be a subclass of Moose::Meta::Class."
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::OverrideConflictInComposition;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

has 'role_being_applied_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'two_overrides_found' => (
    is       => 'ro',
    isa      => 'Bool',
    required => 1,
    default  => 0
);

sub _build_message {
    my $self = shift;

    if( $self->two_overrides_found ) {
        return "Role '" . $self->role_being_applied_name . "' has encountered an 'override' method conflict " .
               "during composition (Two 'override' methods of the same name encountered). " .
               "This is a fatal error.";
    }
    else {
        return "Role '".$self->role_being_applied_name."' has encountered an 'override' method conflict ".
               "during composition (A local method of the same name as been found). ".
               "This is a fatal error.";
    }
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::NoDestructorClassSpecified;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';

sub _build_message {
    "The 'inline_destructor' option is present, but no destructor class was specified";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotOverrideALocalMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

has 'method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "Cannot add an override of method '".$self->method_name."' because there is a local version of '".$self->method_name."'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AttachToClassNeedsAClassMOPClassInstanceOrASubclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute';

has 'class' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    "You must pass a Class::MOP::Class instance (or a subclass)";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CoercionNeedsTypeConstraint;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::InvalidAttributeOptions';

sub _build_message {
    my $self = shift;
    "You cannot have coercion without specifying a type constraint on attribute (".$self->attribute_name.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RoleNameRequired;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

sub _build_message {
    "You must supply a role name to look for";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MethodExpectsFewerArgs;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

has 'maximum_args' => (
    is       => 'ro',
    isa      => 'Int',
    required => 1,
);

sub _build_message {
    my $self = shift;
    my $max = $self->maximum_args;
    "Cannot call ".$self->method_name." with ".
        ( $max ? "more than $max" : 'any'). " argument".( $max == 1 ? '' : 's' );
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::SingleParamsToNewMustBeHashRef;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    "Single parameters to new() must be a HASH ref";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CouldNotParseType;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'type' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'position' => (
    is       => 'ro',
    isa      => 'Int',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $type = $self->type;
    my $length = length($type);
    my $position = $self->position;

    return "'$type' didn't parse (parse-pos=$position"
        . " and str-length=$length)";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::BothBuilderAndDefaultAreNotAllowed;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "Setting both default and builder is not allowed.";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::IsaDoesNotDoTheRole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::InvalidAttributeOptions';

sub _build_message {
    my $self = shift;
    "Cannot have an isa option and a does option if the isa does not do the does on attribute (".$self->attribute_name.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MethodNameNotGiven;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

sub _build_message {
    "You must define a method name to find";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AttributeConflictInSummation;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::AttributeName';

has 'second_role_name' => (
    is         => 'ro',
    isa        => 'Str',
    required   => 1,
);

sub _build_message {
    my $self = shift;

    my $role1     = $self->role_name;
    my $role2     = $self->second_role_name;
    my $attr_name = $self->attribute_name;

    return "We have encountered an attribute conflict with '$attr_name'"
           . " during role composition. "
           . " This attribute is defined in both $role1 and $role2."
           . " This is a fatal error and cannot be disambiguated.";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotAugmentIfLocalMethodPresent;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Method';

sub _build_message {
    "Cannot add an augment method if a local method is already present";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::ExtendsMissingArgs;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

sub _build_message {
    "Must derive at least one class";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InstanceBlessedIntoWrongClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Instance';

sub _build_message {
    my $self = shift;
    "Objects passed as the __INSTANCE__ parameter must already be blessed into the correct class, but ".$self->instance." is not a " . $self->class_name;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MatchActionMustBeACodeRef;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

has 'to_match' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1,
);

has 'action' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $action = $self->action;

    return "Match action must be a CODE ref, not $action";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::UnableToCanonicalizeNonRolePackage;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute';

has 'handles' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "Unable to canonicalize the 'handles' option with ".$self->handles." because its metaclass is not a Moose::Meta::Role";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustDefineAnAttributeName;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

sub _build_message {
    "You must define an attribute name";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CreateTakesHashRefOfAttributes;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::RoleForCreate';

sub _build_message {
    "You must pass a HASH ref of attributes";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::OverloadRequiresAnOperator;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    my $self = shift;
    'You must provide an operator parameter when constructing a Moose::Meta::Overload object';
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::TypeConstraintIsAlreadyCreated;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

use Moose::Util::TypeConstraints 'find_type_constraint';

has 'package_defined_in' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    my $self                    = shift;
    my $type_name               = $self->type_name;
    my $type                    = find_type_constraint( $type_name );
    my $type_package_defined_in = $type->_package_defined_in;
    my $package_defined_in      = $self->package_defined_in;
    return "The type constraint '$type_name' has already been created in $type_package_defined_in and cannot be created again in $package_defined_in";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

has 'attribute' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    "Your attribute must be an instance of Class::MOP::Mixin::AttributeCore (or a subclass)";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::ValidationFailedForInlineTypeConstraint;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

has 'type_constraint_message' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'attribute_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'value' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

has 'new_member' => (
    is        => 'ro',
    isa       => 'Bool',
    default   => 0,
    predicate => 'is_a_new_member'
);

sub _build_message {
    my $self = shift;

    my $line1;

    if( $self->new_member ) {
        $line1 = "A new member value for ".$self->attribute_name." does not pass its type constraint because: "
    }
    else {
        $line1 = "Attribute (".$self->attribute_name.") does not pass the type constraint because: ";
    }

    return $line1 . $self->type_constraint_message;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RequiredMethodsImportedByClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Role';

has 'missing_methods' => (
    traits   => ['Array'],
    is       => 'ro',
    isa      => 'ArrayRef[Moose::Meta::Role::Method::Required]',
    handles  => { method_count    => 'count',
                  get_method_at   => 'get',
                  get_all_methods => 'elements',
    },
    required => 1
);

has 'imported_method' => (
    is       => 'ro',
    isa      => 'Moose::Meta::Role::Method::Required',
    required => 1
);

sub _build_message {
    my $self = shift;

    my $noun = $self->method_count == 1 ? 'method' : 'methods';
    my $list = Moose::Util::english_list( map { q{'} . $_ . q{'} } $self->get_all_methods );

    my ($class, $role, $method) = ($self->class_name,
                                   $self->role_name,
                                   $self->imported_method);

    my ($class_quoted, $role_quoted) = ("'".$class."'","'".$role."'");

    "$role_quoted requires the $noun $list "
        . "to be implemented by $class_quoted. "
        . "If you imported functions intending to use them as "
        . "methods, you need to explicitly mark them as such, via "
        . "$class->meta->add_method($method"
        . " => \\&$method)";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::NoImmutableTraitSpecifiedForClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';

use Moose::Util 'find_meta';

sub _build_message {
    my $self  = shift;
    my $class = find_meta( $self->class_name );
    "no immutable trait specified for $class";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::DoesRequiresRoleName;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

sub _build_message {
    "You must supply a role name to does()";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::BadOptionFormat;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute';

has 'option_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'option_value' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    "bad accessor/reader/writer/predicate/clearer format, must be a HASH ref";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::PackagesAndModulesAreNotCachable;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';

has 'is_module' => (
    is       => 'ro',
    isa      => 'Bool',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $is_module = $self->is_module;

    if( $is_module ) {
        return "Modules are not cacheable";
    } else {
        return "Packages are not cacheable";
    }
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::NeedsTypeConstraintUnionForTypeCoercionUnion;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::TypeConstraint';

# use Moose::Util::TypeConstraints 'find_type_constraint';

has 'type_coercion_union_object' => (
    is       => 'ro',
    isa      => 'Moose::Meta::TypeCoercion::Union',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $type_constraint = $self->type_name;

    return "You can only create a Moose::Meta::TypeCoercion::Union for a " .
           "Moose::Meta::TypeConstraint::Union, not a $type_constraint"
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AddParameterizableTypeTakesParameterizableType;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'type_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "Type must be a Moose::Meta::TypeConstraint::Parameterizable not ".$self->type_name;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotRegisterUnnamedTypeConstraint;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    "can't register an unnamed type constraint";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CannotOverrideLocalMethodIsPresent;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Method';

sub _build_message {
    "Cannot add an override method if a local method is already present";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InstanceMustBeABlessedReference;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class';

has 'instance' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    my $self = shift;
    "The __INSTANCE__ parameter must be a blessed reference, not ". $self->instance;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CallingReadOnlyMethodOnAnImmutableInstance;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'method_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "The '".$self->method_name."' method is read-only when called on an immutable instance";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MustPassAHashOfOptions;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "You must pass a hash of options";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MetaclassMustBeASubclassOfMooseMetaRole;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

sub _build_message {
    my $self = shift;
    "The Metaclass ".$self->role_name." must be a subclass of Moose::Meta::Role."
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CloneObjectExpectsAnInstanceOfMetaclass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

has 'instance' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "You must pass an instance of the metaclass (" .$self->class_name. "), not (".$self->instance.")";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InvalidHandleValue;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Instance';

has 'handle_value' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    my $self = shift;
    "All values passed to handles must be strings or ARRAY references, not ".$self->handle_value;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CircularReferenceInAlso;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'also_parameter' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'stack' => (
    is       => 'ro',
    isa      => 'ArrayRef',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $also_member = $self->also_parameter;

    my @stack = @{$self->stack};
    my $existing_stack = join( ', ', @stack);

    return "Circular reference in 'also' parameter to Moose::Exporter between "
           ."$existing_stack and $also_member";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::BuilderDoesNotExist;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Instance';

sub _build_message {
    my $self = shift;
    blessed($self->instance)." does not support builder method '".$self->attribute->builder."' for attribute '".$self->attribute->name."'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CouldNotGenerateInlineAttributeMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Instance';

has 'option' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'error' => (
    is       => 'ro',
    isa      => 'Str|Moose::Exception',
    required => 1
);

sub _build_message {
    my $self = shift;
    "Could not generate inline ".$self->option." because : ".$self->error;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::PackageDoesNotUseMooseExporter;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'package' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'is_loaded' => (
    is       => 'ro',
    isa      => 'Bool',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $package = $self->package;
    return "Package in also ($package) does not seem to "
           . "use Moose::Exporter"
           . ( $self->is_loaded ? "" : " (is it loaded?)" );
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InvalidArgumentToMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'argument' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

has [qw(type type_of_argument method_name)] => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'ordinal' => (
    is        => 'ro',
    isa       => 'Str',
    predicate => 'is_ordinal_set'
);

has 'argument_noun' => (
    is      => 'ro',
    isa     => 'Str',
    default => 'argument'
);

sub _build_message {
    my $self = shift;
    my $article = ( $self->type_of_argument =~ /^[aeiou]/ ? 'an ' : 'a ');
    my $arg_noun = $self->argument_noun;

    if( $self->is_ordinal_set ) {
        "The ".$self->ordinal." $arg_noun passed to ".$self->method_name." must be ".$article.$self->type_of_argument;
    }
    else {
        "The $arg_noun passed to ".$self->method_name." must be ".$article.$self->type_of_argument;
    }
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RequiredMethodsNotImplementedByClass;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Role';

has 'missing_methods' => (
    traits     => ['Array'],
    is         => 'ro',
    isa        => 'ArrayRef[Moose::Meta::Role::Method::Required]',
    handles    => { method_count    => 'count',
                    get_method_at   => 'get',
                    get_all_methods => 'elements',
    },
    required   => 1
);

sub _build_message {
    my $self = shift;

    my $noun = $self->method_count == 1 ? 'method' : 'methods';
    my $list = Moose::Util::english_list( map { q{'} . $_ . q{'} } $self->get_all_methods );
    my ($role_name, $class_name) = ($self->role_name, $self->class_name);

    return "'$role_name' requires the $noun $list "
        . "to be implemented by '$class_name'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CouldNotEvalConstructor;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'constructor_method' => (
    is       => 'ro',
    isa      => 'Class::MOP::Method::Constructor',
    required => 1
);

has 'source' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'error' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $error = $self->error;
    my $source = $self->source;

    return "Could not eval the constructor :\n\n$source\n\nbecause :\n\n$error";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::InvalidNameForType;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
);

sub _build_message {
    my $self = shift;
    $self->name." contains invalid characters for a type name. Names can contain alphanumeric characters, ':', and '.'";
}
1;
package Moose::Exception::CouldNotCreateMethod;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Attribute';

has 'option_name' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'option_value' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

has 'error' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "Could not create the '".$self->option_name."' method for " . $self->attribute->name . " because : ".$self->error;
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::EnumValuesMustBeString;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'value' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1
);

sub _build_message {
    my $self = shift;
    "Enum values must be strings, not ".( defined $self->value ? "'".$self->value."'" : "undef" );
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RolesDoNotSupportAugment;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    "Roles cannot support 'augment'";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::OverloadRequiresAMetaOverload;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    my $self = shift;
    'If you provide an original_overload parameter to the Moose::Meta::Overload constructor it must be a Moose::Meta::Overload object';
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::OverloadRequiresAMethodNameOrCoderef;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

sub _build_message {
    my $self = shift;
    'You must provide a method_name or coderef parameter when constructing a Moose::Meta::Overload object';
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::MetaclassNotLoaded;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Class';

sub _build_message {
    my $self = shift;
    "The Metaclass ".$self->class_name." must be loaded. (Perhaps you forgot to 'use ".$self->class_name."'?)";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::AttributeValueIsNotAnObject;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::Attribute';

has 'method' => (
    is       => 'ro',
    isa      => 'Moose::Meta::Method::Delegation',
    required => 1,
);

has 'given_value' => (
    is       => 'ro',
    isa      => 'Any',
    required => 1,
);

sub _build_message {
    my $self = shift;
    "Cannot delegate ".$self->method->name." to "
    .$self->method->delegate_to_method." because the value of "
    . $self->attribute->name . " is not an object (got '".$self->given_value."')";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::CouldNotEvalDestructor;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';

has 'method_destructor_object' => (
    is       => 'ro',
    isa      => 'Moose::Meta::Method::Destructor',
    required => 1
);

has 'source' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

has 'error' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    my $error = $self->error;
    my $source = $self->source;

    return "Could not eval the destructor :\n\n$source\n\nbecause :\n\n$error";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::RolesDoNotSupportRegexReferencesForMethodModifiers;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::Role';

has 'modifier_type' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    my $self = shift;
    "Roles do not currently support regex references for ".$self->modifier_type." method modifiers";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception::OperatorIsRequired;
our $VERSION = '2.2204';

use Moose;
extends 'Moose::Exception';
with 'Moose::Exception::Role::ParamsHash';

has 'class' => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

sub _build_message {
    "operator is required";
}

__PACKAGE__->meta->make_immutable;
1;
package Moose::Exception;
our $VERSION = '2.2204';

use Moose;
use Devel::StackTrace 2.03;

has 'trace' => (
    is            => 'ro',
    isa           => 'Devel::StackTrace',
    builder       => '_build_trace',
    lazy          => 1,
    documentation => "This attribute is read-only and isa L<Devel::StackTrace>. ".
                     'It is lazy & dependent on $exception->message.'
);

has 'message' => (
    is            => 'ro',
    isa           => 'Defined',
    builder       => '_build_message',
    lazy          => 1,
    documentation => "This attribute is read-only and isa Defined. ".
                     "It is lazy and has a default value 'Error'."
);

use overload(
    q{""}    => 'as_string',
    bool     => sub () { 1 },
    fallback => 1,
);

sub _build_trace {
    my $self = shift;

    # skip frames that are method calls on the exception object, which include
    # the object itself in the arguments (but Devel::LeakTrace really ought to
    # be weakening all references in its frames)
    my $skip = 0;
    while (my @c = caller(++$skip)) {
        last if ($c[3] =~ /^(.*)::new$/ || $c[3] =~ /^\S+ (.*)::new \(defined at /)
            && $self->isa($1);
    }
    $skip++;

    Devel::StackTrace->new(
        message => $self->message,
        indent  => 1,
        skip_frames => $skip,
        no_refs => 1,
    );
}

sub _build_message {
    "Error";
}

sub BUILD {
    my $self = shift;
    $self->trace;
}

sub as_string {
    my $self = shift;

    if ( $ENV{MOOSE_FULL_EXCEPTION} ) {
        return $self->trace->as_string;
    }

    my @frames;
    my $last_frame;
    my $in_moose = 1;
    for my $frame ( $self->trace->frames ) {
        if ( $in_moose && $frame->package =~ /^(?:Moose|Class::MOP)(?::|$)/ )
        {
            $last_frame = $frame;
            next;
        }
        elsif ($last_frame) {
            push @frames, $last_frame;
            undef $last_frame;
        }

        $in_moose = 0;
        push @frames, $frame;
    }

    # This would be a somewhat pathological case, but who knows
    return $self->trace->as_string unless @frames;

    my $message = ( shift @frames )->as_string( 1, {} ) . "\n";
    $message .= join q{}, map { $_->as_string( 0, {} ) . "\n" } @frames;

    return $message;
}

__PACKAGE__->meta->make_immutable;
1;

# ABSTRACT: Superclass for Moose internal exceptions

package Moose::Deprecated;
our $VERSION = '2.2204';

use strict;
use warnings;

use Package::DeprecationManager 0.07 -deprecations => {
    'non-arrayref form of enum'         => '2.1100',
    'non-arrayref form of duck_type'    => '2.1100',
    },
    -ignore => [qr/^(?:Class::MOP|Moose)(?:::)?/],
    ;

1;

# ABSTRACT: Manages deprecation warnings for Moose

package Test::Moose;
our $VERSION = '2.2204';

use strict;
use warnings;

use Sub::Exporter;
use Test::Builder;

use List::Util 1.33 'all';
use Moose::Util 'does_role', 'find_meta';

my @exports = qw[
    meta_ok
    does_ok
    has_attribute_ok
    with_immutable
];

Sub::Exporter::setup_exporter({
    exports => \@exports,
    groups  => { default => \@exports }
});

## the test builder instance ...

my $Test = Test::Builder->new;

## exported functions

sub meta_ok ($;$) {
    my ($class_or_obj, $message) = @_;

    $message ||= "The object has a meta";

    if (find_meta($class_or_obj)) {
        return $Test->ok(1, $message)
    }
    else {
        return $Test->ok(0, $message);
    }
}

sub does_ok ($$;$) {
    my ($class_or_obj, $does, $message) = @_;

    $message ||= "The object does $does";

    if (does_role($class_or_obj, $does)) {
        return $Test->ok(1, $message)
    }
    else {
        return $Test->ok(0, $message);
    }
}

sub has_attribute_ok ($$;$) {
    my ($class_or_obj, $attr_name, $message) = @_;

    $message ||= "The object does has an attribute named $attr_name";

    my $meta = find_meta($class_or_obj);

    if ($meta->find_attribute_by_name($attr_name)) {
        return $Test->ok(1, $message)
    }
    else {
        return $Test->ok(0, $message);
    }
}

sub with_immutable (&@) {
    my $block = shift;
    my $before = $Test->current_test;

    $block->(0);
    Class::MOP::class_of($_)->make_immutable for @_;
    $block->(1);

    my $num_tests = $Test->current_test - $before;
    my $all_passed = all { $_ } ($Test->summary)[-$num_tests..-1];
    return $all_passed;
}

1;

# ABSTRACT: Test functions for Moose specific features

package inc::GitUpToDate;
use Moose;

with 'Dist::Zilla::Role::BeforeBuild';

sub git {
    if (wantarray) {
        chomp(my @ret = qx{git $_[0]});
        return @ret;
    }
    else {
        chomp(my $ret = qx{git $_[0]});
        return $ret;
    }
}

sub before_build {
    my $self = shift;

    return unless $ENV{DZIL_RELEASING};

    my $branch = git "symbolic-ref HEAD";
    die "Could not get the current branch"
        unless $branch;

    $branch =~ s{refs/heads/}{};

    $self->log("Ensuring branch $branch is up to date");

    git "fetch origin";
    my $origin = git "rev-parse origin/$branch";
    my $head = git "rev-parse HEAD";

    die "Branch $branch is not up to date (origin: $origin, HEAD: $head)"
        if $origin ne $head;


    # now also check that HEAD is current with the release branch
    # that is, that the release branch is an ancestor commit of HEAD.
    my $release_branch = ($self->zilla->plugin_named('Git::CheckFor::CorrectBranch')->release_branch)[0];
    foreach my $remote ('origin/', '')
    {
        my $release_commit = git "rev-parse ${remote}$release_branch";
        my $common_ancestor = git "merge-base $head $release_commit";

        die "Branch $branch does not contain all commits from the current release branch ",
                "(common ancestor for ${remote}$release_branch: $common_ancestor)"
            if $common_ancestor ne $release_commit;
    }
}

1;
use strict;
use warnings;
package inc::Documentation;

# add x_documentation metadata
# see https://github.com/metacpan/metacpan-web/issues/1468#event-283925638

use Moose;
with 'Dist::Zilla::Role::MetaProvider';

sub mvp_multivalue_args { 'module' }

has module => (
    is => 'ro', isa => 'ArrayRef[Str]',
    required => 1,
);

sub metadata
{
    my $self = shift;
    return +{ x_documentation => $self->module };
}

1;
use strict;
use warnings;
package inc::CheckAuthorDeps;

# our goal is to verify that the declared authordeps already reflect
# everything in configure + runtime prerequisites -- otherwise, we won't be
# able to bootstrap our built Moose for the purposes of running
# author/docGenerator.pl

use Moose;
with 'Dist::Zilla::Role::AfterBuild';

sub after_build
{
    my $self = shift;

    # get our authordeps
    require Dist::Zilla::Util::AuthorDeps;
    Dist::Zilla::Util::AuthorDeps->VERSION(5.021);

    require CPAN::Meta::Requirements;
    my $authordeps = CPAN::Meta::Requirements->new;
    $authordeps->add_string_requirement(%$_)
        foreach @{ Dist::Zilla::Util::AuthorDeps::extract_author_deps('.') };

    # get our prereqs
    my $prereqs = $self->zilla->prereqs;

    # merge prereqs into authordeps
    my $merged_prereqs = CPAN::Meta::Requirements->new;
    $merged_prereqs->add_requirements($authordeps);
    $merged_prereqs->add_requirements($prereqs->requirements_for('configure', 'requires'));
    $merged_prereqs->add_requirements($prereqs->requirements_for('runtime', 'requires'));

    # remove some false positives we know we already have fulfilled
    $merged_prereqs->clear_requirement('ExtUtils::MakeMaker');
    $merged_prereqs->clear_requirement('Dist::CheckConflicts');

    # the merged set should not be different than the original authordeps.
    require Test::Deep;
    my ($ok, $stack) = Test::Deep::cmp_details(
        $authordeps->as_string_hash,
        Test::Deep::superhashof($merged_prereqs->as_string_hash),
    );

    return if $ok;

    $self->log_fatal('authordeps does not have all prereqs found in configure, runtime prereqs: '
        . Test::Deep::deep_diag($stack));
}

1;
use strict;
use warnings;
package inc::SimpleAuthority;

use Moose;
with 'Dist::Zilla::Role::MetaProvider';

sub metadata
{
    return +{ x_authority => 'cpan:STEVAN' };
}

1;
package inc::Clean;
use Moose;

with 'Dist::Zilla::Role::BeforeBuild',
    'Dist::Zilla::Role::AfterBuild';
use Path::Tiny;
use File::pushd 'pushd';
use File::Spec;
use Config;

sub before_build { shift->_clean('.') }

sub after_build {
    my ($self, $opts) = @_;

    $self->_clean($opts->{build_root});

    my $iter = path($opts->{build_root})->iterator({ recurse => 1 });
    my %found_files;
    while (my $found_file = $iter->()) {
        next if -d $found_file;
        ++$found_files{ $found_file->relative($opts->{build_root}) };
    }
    delete $found_files{$_->name} foreach @{ $self->zilla->files };

    $self->log(join("\n",
        "WARNING: Files were left behind in $opts->{build_root} that were not explicitly added:",
        sort keys %found_files,
    )) if keys %found_files;
}

sub _clean {
    my ($self, $build_dir) = @_;

    my $cwd = pushd $build_dir;
    if (-e 'Makefile') {

        my $make = $Config{make} || 'make';

        my $devnull = File::Spec->devnull;
        $self->log("Running $make distclean in $build_dir to clear out build cruft");
        my $pid = fork;
        unless ($pid) {
            open STDIN, '<', $devnull;
            open STDOUT, '>', $devnull;
            open STDERR, '>', $devnull;
            { exec("$^X Makefile.PL && $make distclean") }
            die "couldn't exec: $!";
        }
        waitpid($pid, 0) if $pid;
    }
}
package inc::CheckDelta;
use Moose;

with 'Dist::Zilla::Role::AfterBuild';

sub after_build {
    my $self = shift;

    return unless $ENV{DZIL_RELEASING};

    my ($delta) = grep { $_->name eq 'lib/Moose/Manual/Delta.pod' }
                       @{ $self->zilla->files };

    die "Moose::Manual::Delta still contains \$NEXT"
        if $delta->content =~ /\$NEXT/;
}

1;
package inc::TestRelease;

use Moose;

extends 'Dist::Zilla::Plugin::TestRelease';

around before_release => sub {
    my $orig = shift;
    my $self = shift;

    local $ENV{MOOSE_TEST_MD} = 1 if not $self->zilla->is_trial;
    local $ENV{AUTHOR_TESTING} = 1 if not $self->zilla->is_trial;

    $self->$orig(@_);
};

1;
package inc::MMHelper;

use strict;
use warnings;

use Config;

sub ccflags_dyn {
    my $is_dev = shift;

    my $ccflags = q<( $Config::Config{ccflags} || '' ) . ' -I.'>;
    if ($is_dev and ($Config{cc} !~ /^cl\b/i)) {
        $ccflags .= q< . ' -Wall -Wdeclaration-after-statement'>;
    }

    return $ccflags;
}

sub ccflags_static {
    my $is_dev = shift;

    return eval(ccflags_dyn($is_dev));
}

sub mm_args {
    my ( @object, %xs );

    for my $xs ( glob "xs/*.xs" ) {
        ( my $c = $xs ) =~ s/\.xs$/.c/i;
        ( my $o = $xs ) =~ s/\.xs$/\$(OBJ_EXT)/i;

        $xs{$xs} = $c;
        push @object, $o;
    }

    for my $c ( glob "*.c" ) {
        ( my $o = $c ) =~ s/\.c$/\$(OBJ_EXT)/i;
        push @object, $o;
    }

    return (
        clean   => { FILES => join( q{ }, @object ) },
        OBJECT => join( q{ }, @object ),
        XS     => \%xs,
    );
}

sub my_package_subs {
    return <<'EOP';
{
package MY;

use Config;

# These two are necessary to keep bmake happy
sub xs_c {
    my $self = shift;
    my $ret = $self->SUPER::xs_c(@_);
    $ret =~ s/\$\*\.xs/\$</g;
    $ret =~ s/\$\*\.c\b/\$@/g;
    return $ret;
}

sub c_o {
    my $self = shift;
    my $ret = $self->SUPER::c_o(@_);
    $ret =~ s/\$\*\.c\b/\$</g;
    $ret =~ s/\$\*\$\(OBJ_EXT\)/\$@/g;
    return $ret;
}

sub const_cccmd {
    my $ret = shift->SUPER::const_cccmd(@_);
    return q{} unless $ret;

    if ($Config{cc} =~ /^cl\b/i) {
        warn 'you are using MSVC... we may not have gotten some options quite right.';
        $ret .= ' /Fo$@';
    }
    else {
        $ret .= ' -o $@';
    }

    return $ret;
}

sub postamble {
    return <<'EOF';
$(OBJECT) : mop.h
EOF
}
}
EOP
}

1;
package inc::ExtractInlineTests;

use Moose;

with 'Dist::Zilla::Role::FileGatherer';

use File::Find::Rule;
use inc::MyInline;  # contains My::Extract
use Test::Inline;

sub gather_files {
    my $self = shift;
    my $arg  = shift;

    my $inline = Test::Inline->new(
        verbose        => 0,
        ExtractHandler => 'My::Extract',
        ContentHandler => 'My::Content',
        OutputHandler  => My::Output->new($self),
    );

    for my $pod ( File::Find::Rule->file->name(qr/\.pod$/)->in('lib/Moose/Cookbook') ) {
        $inline->add($pod);
    }

    $inline->save;
}

{
    package My::Output;

    sub new {
        my $class = shift;
        my $dzil  = shift;

        return bless { dzil => $dzil }, $class;
    }

    sub write {
        my $self    = shift;
        my $name    = shift;
        my $content = shift;

        $name =~ s/^moose_cookbook_//;

        $self->{dzil}->add_file(
            Dist::Zilla::File::InMemory->new(
                name    => "t/recipes/$name",
                content => $content,
            )
        );

        return 1;
    }
}

1;
package inc::CheckReleaseType;
use Moose;
with 'Dist::Zilla::Role::BeforeRelease';

# this is so I don't accidentally release 2.x<odd>xx without the --trial
# option, which has very nearly happened a few times.

sub before_release
{
    my $self = shift;
    my $version = $self->zilla->version;

    $version =~ m/^\d\.\d{4}$/
        or $self->log_fatal("version $version doesn't seem to conform to the normal specification!");

    my $digit = substr($version, 3, 1);
    if ($self->zilla->is_trial)
    {
        if ($digit % 2 != 1)
        {
            if ($ENV{MOOSE_EVEN_TRIAL_OK}) {
                $self->log('you\'re doing a -TRIAL release using an even number? okay, I\'ll assume you know what you\'re doing, since you set MOOSE_EVEN_TRIAL_OK...');
            } else {
                $self->log_fatal('-TRIAL releases must be numbered 2.x{ODD}xx! set MOOSE_EVEN_TRIAL_OK to release anyway (you better know what you\'re doing)');
            }
        }
    }
    else
    {
        $digit % 2 == 0
            or $self->log_fatal('stable releases must be numbered 2.x{EVEN}xx!');

        # Moose::Manual::Support says:
        # 2.x{EVEN}00 must be January, April, July, October only.
        if (substr($version, -2, 2) eq '00')
        {
            # month is 0..11
            my $month = (gmtime(time))[4];
            $month % 3 == 0
                or $self->log_fatal('2.x{EVEN}00 releases can only occur in January, April, July or October!');
        }
    }
}
package inc::MakeMaker;

use Moose;

use inc::MMHelper;

extends 'Dist::Zilla::Plugin::MakeMaker::Awesome';

override _build_MakeFile_PL_template => sub {
    my $self = shift;

    my $tmpl = super();
    my $assert_compiler = <<'ASSERT_COMPILER';
# Secondary compile testing via ExtUtils::HasCompiler
use lib 'inc';
use ExtUtils::HasCompiler 0.014 'can_compile_loadable_object';
die 'This distribution requires a working compiler'
    unless can_compile_loadable_object(quiet => 1);

ASSERT_COMPILER

    # splice in our stuff after the preamble bits
    # TODO - MMA ought to make this easier.
    $tmpl =~ m/use warnings;\n\n/g;
    $tmpl = substr($tmpl, 0, pos($tmpl)) . $assert_compiler . substr($tmpl, pos($tmpl));


    # TODO: splice this in using 'around _build_WriteMakefile_args'
    my $ccflags = inc::MMHelper::ccflags_dyn();
    $tmpl =~ s/^(WriteMakefile\()/\$WriteMakefileArgs{CCFLAGS} = $ccflags;\n\n$1/m;

    return $tmpl . "\n\n" . inc::MMHelper::my_package_subs();
};

override _build_WriteMakefile_args => sub {
    my $self = shift;

    my $args = super();

    return {
        %{$args},
        inc::MMHelper::mm_args(),
    };
};

override test => sub {
    my $self = shift;

    local $ENV{PERL5LIB} = join ':',
        grep {defined} @ENV{ 'PERL5LIB', 'DZIL_TEST_INC' };

    super();
};

1;
package inc::GenerateDocs;

use Moose;
with 'Dist::Zilla::Role::FileGatherer',
    'Dist::Zilla::Role::AfterBuild',
    'Dist::Zilla::Role::FileInjector';

use IPC::System::Simple qw(capturex);
use File::pushd;
use Path::Tiny;
use List::Util 'first';

my $filename = path(qw(lib Moose Manual Exceptions Manifest.pod));

sub gather_files {
    my ($self, $arg) = @_;

    $self->add_file(Dist::Zilla::File::InMemory->new(
        name    => $filename->stringify,
        # more to fill in later
        content => <<'END_POD',
# PODNAME: Moose::Manual::Exceptions::Manifest
# ABSTRACT: Moose's Exception Types

#__END__

=for comment insert generated content here
END_POD
        )
    );
}

sub after_build {
    my ($self, $opts) = @_;
    my $build_dir = $opts->{build_root};

    my $wd = pushd($build_dir);
    unless ( -d 'blib' ) {
        my @builders = @{ $self->zilla->plugins_with( -BuildRunner ) };
        die "no BuildRunner plugins specified" unless @builders;
        $self->log('building the distribution in order to generate documentation for exception classes...');
        $_->build for @builders;
        die "no blib; failed to build properly?" unless -d 'blib';
    }

    # This must be run as a separate process because we need to use the new
    # Moose we just generated in order to introspect all the exception
    # classes.
    $self->log('running author/doc-generator...');
    my $text = capturex($^X, 'author/doc-generator');

    my $file_obj = first { $_->name eq $filename } @{$self->zilla->files};

    my $content = $file_obj->content;
    my $pos = index($content, "\n\n=for comment insert generated content here");
    $file_obj->content(
              substr($content, 0, $pos) . "\n\n"
            . $text
            . substr($content, $pos, -1));

    $filename->spew_raw($file_obj->encoded_content);
}

1;
package inc::MyInline;

use strict;
use warnings;

{
    package My::Extract;

    use parent 'Test::Inline::Extract';

    use List::Util qw( first );

    # This extracts the SYNOPSIS in addition to code specifically
    # marked for testing
    my $search = qr/
        (?:^|\n)                           # After the beginning of the string, or a newline
        (                                  # ... start capturing
                                           # EITHER
            package\s+                            # A package
            [^\W\d]\w*(?:(?:\'|::)[^\W\d]\w*)*    # ... with a name
            \s*;                                  # And a statement terminator
        |                                  # OR
            \#\s*PODNAME:\s+                      # A PODNAME comment
            [^\W\d]\w*(?:(?:\'|::)[^\W\d]\w*)*    # ... with a name
            (?:\s+|$)                             # And a name terminator
        |
                        =head1[ \t]+SYNOPSIS\n
                        .*?
                        (?=\n=)
        |                                  # OR
            =for[ \t]+example[ \t]+begin\n        # ... when we find a =for example begin
            .*?                                   # ... and keep capturing
            \n=for[ \t]+example[ \t]+end\s*?      # ... until the =for example end
            (?:\n|$)                              # ... at the end of file or a newline
        |                                  # OR
            =begin[ \t]+(?:test|testing)(?:-SETUP)? # ... when we find a =begin test or testing
            .*?                                     # ... and keep capturing
            \n=end[ \t]+(?:test|testing)(?:-SETUP)? # ... until an =end tag
                        .*?
            (?:\n|$)                              # ... at the end of file or a newline
        )                                  # ... and stop capturing
        /isx;

    sub _elements {
        my $self     = shift;
        my @elements = ();
        while ( $self->{source} =~ m/$search/go ) {
            my $elt = $1;

            # A hack to turn the SYNOPSIS into something Test::Inline
            # doesn't barf on
            if ( $elt =~ s/=head1[ \t]+SYNOPSIS/=begin testing-SETUP\n\n{/ ) {
                $elt .= "}\n\n=end testing-SETUP";
            }

            # It seems like search.cpan doesn't like a name with
            # spaces after =begin. bleah, what a mess.
            $elt =~ s/testing-SETUP/testing SETUP/g;

            push @elements, $elt;
        }

        # If we have just one element it's a SYNOPSIS, so there's no
        # tests.
        return unless @elements > 2;

        if ( @elements && $self->{source} =~ /# PODNAME: (Moose::Cookbook\S+)(?:\s|$)/ ) {
            foreach my $element (@elements)
            {
                $element = "package $1;" if $element =~ /# PODNAME: (Moose::Cookbook\S+)(?:\s+|$)/;
            }
        }

        if ( @elements && $self->{source} =~ /=head1 NAME\n\n(Moose::Cookbook\S+)/ ) {
            unshift @elements, 'package ' . $1 . ';';
        }

        ( first {/^=/} @elements ) ? \@elements : '';
    }
}

{
    package My::Content;

    use parent 'Test::Inline::Content::Default';

    sub process {
        my $self = shift;

        my $base = $self->SUPER::process(@_);

        $base =~ s/(\$\| = 1;)/use Test::Fatal;\n$1/;

        return $base;
    }
}

1;
use strict;
use warnings;
package inc::SimpleProvides;

use Moose;
with 'Dist::Zilla::Role::MetaProvider',
    'Dist::Zilla::Role::FileFinderUser' => {
        default_finders => [ ':InstallModules' ],   # this is overridden in dist.ini!
    },
;

sub metadata
{
    my $self = shift;

    my $version = $self->zilla->version;

    return +{
        provides => {
            map {
                # this is an awful hack and assumes ascii package names:
                # please do not cargo-cult this code elsewhere. The proper
                # thing to do is to crack open the file and read the pod name.
                my $filename = $_->name;
                (my $package = $filename) =~ s{[/\\]}{::}g;
                $package =~ s/^lib:://;
                $package =~ s/\.pod$//;
                $package => { file => $filename, version => $version }
            } @{$self->found_files},
        }
    };
}

__PACKAGE__->meta->make_immutable;

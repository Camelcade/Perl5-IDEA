package LoginApp;
use Mojo::Base 'Mojolicious', -signatures;

use LoginApp::Model::Users;

sub startup ($self) {

  $self->secrets(['Mojolicious rocks']);
  $self->helper(users => sub { state $users = LoginApp::Model::Users->new });

  my $r = $self->routes;
  $r->any('/')->to('login#index')->name('index');

  my $logged_in = $r->under('/')->to('login#logged_in');
  $logged_in->get('/protected')->to('login#protected');

  $r->get('/logout')->to('login#logout');
}

1;
package LoginApp::Controller::Login;
use Mojo::Base 'Mojolicious::Controller', -signatures;

sub index ($self) {
  my $user = $self->param('user') || '';
  my $pass = $self->param('pass') || '';
  return $self->render unless $self->users->check($user, $pass);

  $self->session(user => $user);
  $self->flash(message => 'Thanks for logging in.');
  $self->redirect_to('protected');
}

sub logged_in ($self) {
  return 1 if $self->session('user');
  $self->redirect_to('index');
  return undef;
}

sub logout ($self) {
  $self->session(expires => 1);
  $self->redirect_to('index');
}

1;
package LoginApp::Model::Users;

use strict;
use warnings;
use experimental qw(signatures);

use Mojo::Util qw(secure_compare);

my $USERS = {joel => 'las3rs', marcus => 'lulz', sebastian => 'secr3t'};

sub new ($class) { bless {}, $class }

sub check ($self, $user, $pass) {

  # Success
  return 1 if $USERS->{$user} && secure_compare $USERS->{$user}, $pass;

  # Fail
  return undef;
}

1;
package Mojo::BaseTest::Base2;
use Mojo::Base 'Mojo::BaseTest::Base1';

has [qw(bar baz)] => sub {2};
has yada          => 0;

1;
package Mojo::BaseTest::Base1;
use Mojo::Base -base;

has 'foo';

1;
package Mojo::BaseTest::Base3;
use Mojo::BaseTest::Base1 -base;

has 'test';

1;
package Mojo::DeprecationTest;

use Mojo::Util qw(deprecated);

sub foo {
  deprecated 'foo is DEPRECATED';
  return 'bar';
}

1;
package Mojo::Server::Morbo::Backend::TestBackend;
use Mojo::Base 'Mojo::Server::Morbo::Backend';

sub modified_files { return ['always_changed'] }

1
package Mojo::LoaderException::A;
use Mojo::Base -base;

sub new { }

foo {

1;
package Mojo::LoaderTest::B;
use Mojo::Base -base;

1;
package Mojo::LoaderTest::A;
use Mojo::Base -base;

1;
package Mojo::LoaderTest::C;
use Mojo::Base -base;

1;
package Mojo::LoaderTest::E::F;
use Mojo::Base -base;

1;
package Mojo::LoaderException2;
use Mojo::Base -strict;

Mojo::LoaderException2_2::throw_error();

1;

package Mojo::LoaderException2_2;

use Carp qw(croak);

sub throw_error {
  eval { Mojo::LoaderException2_3::throw_error() };
  croak $@ if $@;
}

package Mojo::LoaderException2_3;

use Carp qw(croak);

sub throw_error {
  croak "Exception";
}

1;
package Mojo::TestConnectProxy;
use Mojo::Base -strict;

use Mojo::IOLoop;

# CONNECT proxy server for testing
sub proxy {
  my ($from, $to, $ok, $zero) = @_;

  $ok   ||= "HTTP/1.1 200 OK\x0d\x0aServer: Test 1.0\x0d\x0a\x0d\x0a";
  $zero ||= "HTTP/1.1 404 NOT FOUND\x0d\x0aContent-Length: 20\x0d\x0a"
    . "Connection: close\x0d\x0a\x0d\x0aSomething went wrong";

  my %buffer;
  return Mojo::IOLoop->server(
    $from => sub {
      my ($loop, $stream, $id) = @_;

      # Connection to client
      $stream->on(
        read => sub {
          my ($stream, $chunk) = @_;

          # Write chunk from client to server
          my $server = $buffer{$id}{connection};
          return Mojo::IOLoop->stream($server)->write($chunk) if $server;

          # Read connect request from client
          my $buffer = $buffer{$id}{client} .= $chunk;
          if ($buffer =~ /\x0d?\x0a\x0d?\x0a$/) {
            $buffer{$id}{client} = '';
            if ($buffer =~ /CONNECT \S+:(\d+)/) {

              return Mojo::IOLoop->stream($id)->write($zero) if $1 == 0;

              # Connection to server
              $buffer{$id}{connection} = Mojo::IOLoop->client(
                $to => sub {
                  my ($loop, $err, $stream) = @_;

                  # Connection to server failed
                  if ($err) {
                    Mojo::IOLoop->remove($id);
                    return delete $buffer{$id};
                  }

                  # Start forwarding data in both directions
                  Mojo::IOLoop->stream($id)->write($ok);
                  $stream->on(
                    read => sub {
                      my ($stream, $chunk) = @_;
                      Mojo::IOLoop->stream($id)->write($chunk);
                    }
                  );

                  # Server closed connection
                  $stream->on(
                    close => sub {
                      Mojo::IOLoop->remove($id);
                      delete $buffer{$id};
                    }
                  );
                }
              );
            }

            # Invalid request from client
            else { Mojo::IOLoop->remove($id) }
          }
        }
      );

      # Client closed connection
      $stream->on(
        close => sub {
          my $buffer = delete $buffer{$id};
          Mojo::IOLoop->remove($buffer->{connection}) if $buffer->{connection};
        }
      );
    }
  );
}

1;
package Mojo::LoaderException;

use Mojo::Base -base;

sub new { }

foo {

1;
package PluginWithEmbeddedApp;
use Mojo::Base 'Mojolicious::Plugin';

sub register {
  my ($self, $app) = @_;
  $app->routes->any('/plugin')->partial(1)->to(PluginWithEmbeddedApp::App::app());
}

package PluginWithEmbeddedApp::App;
use Mojolicious::Lite;

get '/foo';

1;
package MojoliciousConfigTest;
use Mojo::Base 'Mojolicious';

sub startup { shift->plugin('Config') }

1;
package SingleFileTestApp;
use Mojo::Base 'Mojolicious';

sub startup {
  my $self = shift;

  # Only log errors to STDERR
  $self->log->level('fatal');

  # Plugins
  $self->plugin('PluginWithEmbeddedApp');
  $self->plugin('MojoliciousTest::Plugin::Test::SomePlugin2');
  $self->plugin('Config');

  # DATA classes
  push @{$self->renderer->classes}, 'SingleFileTestApp::Foo';
  push @{$self->static->classes},   'SingleFileTestApp::Foo';

  # Helper route
  $self->routes->any('/helper')->to(
    cb => sub {
      my $c = shift;
      $c->render(text => $c->some_plugin);
    }
  );

  # The default route
  my $r = $self->routes;
  $r->any('/foo')->to('Foo#index');
  $r->any('/foo/conf')->to('Foo#conf');
  $r->any('/foo/data_static')->to('Foo#data_static');
  $r->any('/foo/data_template')->to('Foo#data_template');
  $r->any('/foo/data_template2')->to('Foo#data_template2');
  $r->any('/foo/routes')->to('Foo#routes');
  $r->any('/redispatch')->to('Redispatch#index');
  $r->any('/redispatch/render')->to('Redispatch#render');
  $r->any('/redispatch/secret')->to('Redispatch#secret');
}

package SingleFileTestApp::Redispatch;
use Mojo::Base 'Mojolicious';

sub handler {
  my ($self, $c) = @_;
  return secret($c) if $c->param('rly');
  return render($c) if $c->stash('action') eq 'render';
  $c->render(text => 'Redispatch!');
}

sub render {
  my $c = shift;
  $c->render(text => 'Render!');
}

sub secret {
  my $c = shift;
  $c->render(text => 'Secret!');
}

package SingleFileTestApp::Foo;
use Mojo::Base 'Mojolicious::Controller';

sub conf {
  my $self = shift;
  $self->render(text => $self->config->{single_file});
}

sub data_template { shift->render('index') }

sub data_template2 { shift->stash(template => 'too') }

sub data_static { shift->reply->static('singlefiletestapp/foo.txt') }

sub index {
  shift->stash(template => 'WithGreenLayout', msg => 'works great!');
}

sub routes {
  my $self = shift;
  $self->res->headers->header('X-Bender' => 'Bite my shiny metal ass!');
  $self->render(text => $self->url_for);
}

1;
package MojoliciousTest::Baz;
use Mojo::Base 'Mojolicious::Controller';

sub index { shift->render(text => 'Production namespace has low precedence!') }

1;
package MojoliciousTest::SideEffects::Test;
use Mojo::Base 'Mojolicious::Controller';

sub index { shift->render(text => 'pass') }

1;
package MojoliciousTest::Plugin::UPPERCASETestPlugin;
use Mojo::Base 'Mojolicious::Plugin';

sub register {
  my ($self, $app) = @_;

  # Add "upper_case_test_plugin" helper
  $app->helper(upper_case_test_plugin => sub {'WELCOME aboard!'});
}

1;
package MojoliciousTest::Plugin::DeploymentPlugin;
use Mojo::Base 'Mojolicious::Plugin';

sub register {
  my ($self, $app, $config) = @_;
  my $name = $config->{name}    // 'deployment_helper';
  my $msg  = $config->{message} // 'deployment plugins work!';
  $app->helper($name => sub {$msg});
}

1;
package MojoliciousTest::Plugin::Test::SomePlugin2;
use Mojo::Base 'Mojolicious::Plugin';

sub register {
  my ($self, $app) = @_;

  # Add "some_plugin" helper
  $app->helper(some_plugin => sub {'Welcome aboard!'});
}

1;
package MojoliciousTest::Controller::Foo::Bar;
use Mojolicious::Controller -base;

sub index {1}

sub test { shift->stash(msg => 'works') }

1;
package MojoliciousTest::Command::test_command;
use Mojo::Base 'Mojolicious::Command';

use Mojo::Util qw(getopt);

sub run {
  my ($self, @args) = @_;
  getopt \@args, ['default'], 'too' => \my $too;
  return $too ? 'works too!' : 'works!';
}

1;
package MojoliciousTest::Command::_test2_command;
use Mojo::Base 'Mojolicious::Command';

sub run {'works 2!'}

1;
package MojoliciousTest::Foo;
use Mojo::Base 'Mojolicious::Controller';

sub DESTROY { shift->stash->{destroyed} = 1 }

sub config {
  my $self = shift;
  $self->render(text => $self->stash('config')->{test});
}

sub fun { shift->render }

sub joy { shift->render }

sub index {
  my $self = shift;
  $self->layout('default');
  $self->stash(handler => 'xpl', msg => 'Hello World!');
}

sub longpoll {
  my $self = shift;
  $self->on(finish => sub { shift->stash->{finished} = 1 });
  $self->write_chunk(
    'P' => sub {
      shift->write_chunk('oll!' => sub { shift->write_chunk('') });
    }
  );
}

sub plugin_camel_case {
  my $self = shift;
  $self->render(text => $self->some_plugin);
}

sub plugin_upper_case {
  my $self = shift;
  $self->render(text => $self->upper_case_test_plugin);
}

sub session_domain {
  my $self = shift;
  $self->session(user => 'Bender');
  $self->render(text => 'Bender rockzzz!');
}

sub something {
  my $self = shift;
  $self->res->headers->header('X-Bender' => 'Bite my shiny metal ass!');
  $self->render(text => $self->url_for('something', something => '42'));
}

sub stage1 {
  my $self = shift;

  # Authenticated
  return 1 if $self->req->headers->header('X-Pass');

  # Fail
  $self->render(text => 'Go away!');
  return undef;
}

sub stage2 { return shift->some_plugin }

sub suspended {
  my $self = shift;

  $self->res->headers->append('X-Suspended' => $self->match->position);
  Mojo::IOLoop->next_tick(sub {
    $self->res->headers->append('X-Suspended' => $self->match->position);
    $self->continue;
  });

  return 0;
}

sub syntaxerror { shift->render('syntaxerror', format => 'html') }

sub templateless { shift->render(handler => 'test') }

sub test {
  my $self = shift;
  $self->res->headers->header('X-Bender' => 'Bite my shiny metal ass!');
  $self->render(text => $self->url_for(foo => 'bar'));
}

sub url_for_missing {
  my $self = shift;
  $self->render(text => $self->url_for('does_not_exist', something => '42'));
}

sub willdie { die 'for some reason' }

sub withBlock { shift->render(template => 'withblock') }

sub withlayout { shift->stash(template => 'WithGreenLayout') }

1;
package MojoliciousTest::SyntaxError;
use Mojo::Base 'Mojolicious::Controller';

sub foo {

1;
package MojoliciousTest::Exceptional;
use Mojo::Base 'Mojolicious::Controller';

sub this_one_dies { die "doh!\n" }

sub this_one_might_die {
  die "double doh!\n" unless shift->req->headers->header('X-DoNotDie');
  1;
}

1;
package MojoliciousTest::PODTest;

1;

=head1 One

PODTest

=head2 Two

  my $foo = 'bar';

=head3 Three

Hello

=head4 Four

World!

=cut
package MojoliciousTest;
use Mojo::Base 'Mojolicious';

use MojoliciousTest::Foo;

sub startup {
  my $self = shift;

  if ($self->mode eq 'development') {

    # Template and static file class with higher precedence for development
    unshift @{$self->static->classes},   'MojoliciousTest::Foo';
    unshift @{$self->renderer->classes}, 'MojoliciousTest::Foo';

    # Static root for development
    unshift @{$self->static->paths}, $self->home->child('public_dev');

    # Development namespace
    unshift @{$self->routes->namespaces}, 'MojoliciousTest3';
  }

  # Template and static file class with lower precedence for production
  push @{$self->static->classes},   'MojoliciousTest';
  push @{$self->renderer->classes}, 'MojoliciousTest';

  # Application specific commands
  push @{$self->commands->namespaces}, 'MojoliciousTest::Command';

  # Plugins in custom namespace
  unshift @{$self->plugins->namespaces}, $self->routes->namespaces->[-1] . '::Plugin';
  $self->plugin('test-some_plugin2');
  $self->plugin('UPPERCASETestPlugin');

  # Plugin for rendering return values
  $self->plugin('AroundPlugin');

  # Templateless renderer
  $self->renderer->add_handler(
    test => sub {
      my ($renderer, $c, $output) = @_;
      $$output = 'Hello Mojo from a templateless renderer!';
    }
  );

  # Renderer for a different file extension
  $self->renderer->add_handler(xpl => $self->renderer->handlers->{epl});

  # Shortcut for "/fun*" routes
  $self->routes->add_shortcut(
    fun => sub {
      my ($r, $append) = @_;
      $r->any("/fun$append");
    }
  );

  # Session
  $self->sessions->cookie_domain('.example.com');
  $self->sessions->cookie_path('/bar');

  # /plugin/upper_case
  # /plugin/camel_case (plugins loaded correctly)
  my $r = $self->routes;
  $r->any('/plugin/upper_case')->to('foo#plugin_upper_case');
  $r->any('/plugin/camel_case')->to('foo#plugin_camel_case');

  # /exceptional/*
  $r->any('/exceptional/this_one_dies')->to('exceptional#this_one_dies');

  # /exceptional_too/*
  $r->any('/exceptional_too')->inline(1)->to('exceptional#this_one_might_die')->any('/this_one_dies')
    ->to('#this_one_dies');

  # /fun/time
  $r->fun('/time')->to('foo#fun');

  # /happy/fun/time
  $r->any('/happy')->fun('/time')->to('foo#fun');

  # /fun/joy
  $r->fun('/joy')->to('foo#joy');

  # /stash_config
  $r->any('/stash_config')->to(controller => 'foo', action => 'config', config => {test => 123});

  # /test4 (named route for url_for)
  $r->any('/test4/:something')->to('foo#something', something => 23)->name('something');

  # /somethingtest (refer to another route with url_for)
  $r->put('/somethingtest')->to('foo#something');

  # /something_missing (refer to a non-existing route with url_for)
  $r->any('/something_missing')->to('foo#url_for_missing');

  # /test3 (no class, just a namespace)
  $r->any('/test3')->to(namespace => 'MojoliciousTest2::Foo', action => 'test');

  # /test4 (controller class without action)
  $r->any('/test1')->to(controller => 'Foo::Bar');

  # /test2 (different namespace test)
  $r->any('/test2')->to(namespace => 'MojoliciousTest2', controller => 'Foo', action => 'test');

  # /test6 (no namespace test)
  $r->any('/test6')->to(namespace => '', controller => 'mojolicious_test2-foo', action => 'test');

  # /test7 (controller class shortcut)
  $r->any('/test7')->to('Foo::Bar#test');

  # /test8 (controller class)
  $r->any('/test8')->to(controller => 'Foo::Bar', action => 'test');

  # /test9 (controller in development namespace)
  $r->any('/test9')->to('bar#index');

  # /test10 (controller in both namespaces)
  $r->any('/test10')->to('baz#index');

  # /withblock (template with blocks)
  $r->any('/withblock', [format => ['txt']])->to('foo#withBlock');

  # /staged (authentication with intermediate destination)
  my $b = $r->any('/staged')->inline(1)->to('foo#stage1', return => 1);
  $b->any->to(action => 'stage2');

  # /suspended (suspended intermediate destination)
  $r->any('/suspended')->inline(1)->to('foo#suspended')->any->inline(1)->to('foo#suspended')->any->to('foo#fun');

  # /longpoll (long polling)
  $r->any('/longpoll')->to('foo#longpoll');

  # /shortcut/act
  # /shortcut/ctrl
  # /shortcut/ctrl-act (shortcuts to controller#action)
  $r->any('/shortcut/ctrl-act')->to('foo#config', config => {test => 'ctrl-act'});
  $r->any('/shortcut/ctrl')->to('foo#', action => 'config', config => {test => 'ctrl'});
  $r->any('/shortcut/act')->to('#config', controller => 'foo', config => {test => 'act'});

  # /foo/session (session cookie with domain)
  $r->any('/foo/session')->to('foo#session_domain');

  # /rss.xml (mixed formats)
  $r->any('/rss.xml')->to('foo#bar', format => 'rss');

  $r->any('/foo/yada')->to('Foo#yada');
  $r->any('/foo')->to('foo#index');
  $r->any('/foo-bar')->to('foo-bar#index');
  $r->any('/foo/baz')->to('foo#baz');
  $r->any('/plugin-test-some_plugin2/register')->to('plugin-test-some_plugin2#register');
  $r->any('/foo/syntaxerror')->to('foo#syntaxerror');
  $r->any('/syntax_error/foo')->to('syntax_error#foo');
  $r->any('/:foo/test' => [foo => [qw(foo bar)]])->to('foo#test');
  $r->any('/another')->to('another#index');
  $r->any('/foo/willdie')->to('foo#willdie');
  $r->any('/foo/templateless')->to('foo#templateless');
  $r->any('/foo/withlayout')->to('foo#withlayout');
  $r->any('/side_effects-test/index')->to('side_effects-test#index');

  # /just/some/template (embedded template)
  $r->any('/just/some/template')->to(template => 'just/some/template');
}

1;
package MojoliciousTest2::Foo;
use Mojo::Base 'Mojolicious::Controller';

sub test {
  my $self = shift;
  $self->res->headers->header('X-Bender' => 'Bite my shiny metal ass!');
  $self->render(text => $self->url_for);
}

1;
package MojoliciousTest3::Baz;
use Mojo::Base 'MojoliciousTest::Baz';

sub index { shift->render(text => 'Development namespace has high precedence!') }

1;
package MojoliciousTest3::Bar;
use Mojo::Base 'Mojolicious::Controller';

sub index {
  my $self = shift;
  $self->render(text => 'Development namespace works!');
}

1;
package PluginWithTemplate;
use Mojo::Base 'Mojolicious::Plugin';

sub register {
  my ($self, $app) = @_;
  push @{$app->renderer->classes}, __PACKAGE__;
  $app->routes->any('/plugin_with_template')->to(cb => sub { shift->render('plugin_with_template') });
}

1;
package AroundPlugin;
use Mojo::Base 'Mojolicious::Plugin';

sub register {
  my ($self, $app) = @_;

  # Render return value
  $app->hook(
    around_action => sub {
      my ($next, $c, $action, $last) = @_;
      my $value = $next->();
      $c->render(text => $value) if $last && $c->stash->{return};
      return $value;
    }
  );
}

1;
package EmbeddedTestApp;
use Mojolicious::Lite;

plugin "JSONConfig";

get '/works';

get '/works/too' => 'too';

1;
package MyApp;
use Mojo::Base 'Mojolicious';

sub startup {
  my $self = shift;
  my $r    = $self->routes;

  $self->plugin('Config');

  $r->get(
    '/' => sub {
      my $self = shift;
      $self->render(text => $self->config->{works});
    }
  );

  $r->get(
    '/test' => sub {
      my $self = shift;
      $self->render(text => $self->config->{whatever});
    }
  );

  $r->get(
    '/secondary' => sub {
      my $self = shift;
      $self->render(text => ++$self->session->{secondary});
    }
  );

  $r->get(
    '/inline' => sub {
      my $self = shift;
      $self->render(inline => '<%= config->{whatever} =%>');
    }
  );
}

1;
package Mojo;
use Mojo::Base -strict;

# "Professor: These old Doomsday devices are dangerously unstable. I'll rest
#             easier not knowing where they are."
1;

=encoding utf8

=head1 NAME

Mojo - Web development toolkit

=head1 SYNOPSIS

  # HTTP/WebSocket user agent
  use Mojo::UserAgent;
  my $ua = Mojo::UserAgent->new;
  say $ua->get('www.mojolicious.org')->result->headers->server;

  # HTML/XML DOM parser with CSS selectors
  use Mojo::DOM;
  my $dom = Mojo::DOM->new('<div><b>Hello Mojo!</b></div>');
  say $dom->at('div > b')->text;

  # Perl-ish templates
  use Mojo::Template;
  my $mt = Mojo::Template->new(vars => 1);
  say $mt->render('Hello <%= $what %>!', {what => 'Mojo'});

  # HTTP/WebSocket server
  use Mojo::Server::Daemon;
  my $daemon = Mojo::Server::Daemon->new(listen => ['http://*:8080']);
  $daemon->unsubscribe('request')->on(request => sub ($daemon, $tx) {
    $tx->res->code(200);
    $tx->res->body('Hello Mojo!');
    $tx->resume;
  });
  $daemon->run;

  # Event loop
  use Mojo::IOLoop;
  for my $seconds (1 .. 5) {
    Mojo::IOLoop->timer($seconds => sub { say $seconds });
  }
  Mojo::IOLoop->start;

=head1 DESCRIPTION

A powerful web development toolkit, with all the basic tools and helpers needed to write simple web applications and
higher level web frameworks, such as L<Mojolicious>. Some of the most commonly used tools are L<Mojo::UserAgent>,
L<Mojo::DOM>, L<Mojo::JSON>, L<Mojo::Server::Daemon>, L<Mojo::Server::Prefork>, L<Mojo::IOLoop> and L<Mojo::Template>.

See L<Mojolicious::Guides> for more!

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Plugins;
use Mojo::Base 'Mojo::EventEmitter';

use Mojo::Loader qw(load_class);
use Mojo::Util   qw(camelize);

has namespaces => sub { ['Mojolicious::Plugin'] };

sub emit_chain {
  my ($self, $name, @args) = @_;

  my $wrapper;
  for my $cb (reverse @{$self->subscribers($name)}) {
    my $next = $wrapper;
    $wrapper = sub { $cb->($next, @args) };
  }

  !$wrapper ? return : return $wrapper->();
}

sub emit_hook {
  my $self = shift;
  for my $cb (@{$self->subscribers(shift)}) { $cb->(@_) }
  return $self;
}

sub emit_hook_reverse {
  my $self = shift;
  for my $cb (reverse @{$self->subscribers(shift)}) { $cb->(@_) }
  return $self;
}

sub load_plugin {
  my ($self, $name) = @_;

  # Try all namespaces and full module name
  my $suffix  = $name =~ /^[a-z]/ ? camelize $name : $name;
  my @classes = map {"${_}::$suffix"} @{$self->namespaces};
  for my $class (@classes, $name) { return $class->new if _load($class) }

  # Not found
  die qq{Plugin "$name" missing, maybe you need to install it?\n};
}

sub register_plugin { shift->load_plugin(shift)->register(shift, ref $_[0] ? $_[0] : {@_}) }

sub _load {
  my $module = shift;
  return $module->isa('Mojolicious::Plugin') unless my $e = load_class $module;
  ref $e ? die $e : return undef;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Plugins - Plugin manager

=head1 SYNOPSIS

  use Mojolicious::Plugins;

  my $plugins = Mojolicious::Plugins->new;
  push @{$plugins->namespaces}, 'MyApp::Plugin';

=head1 DESCRIPTION

L<Mojolicious::Plugins> is the plugin manager of L<Mojolicious>.

=head1 PLUGINS

The following plugins are included in the L<Mojolicious> distribution as examples.

=over 2

=item L<Mojolicious::Plugin::Config>

Perl-ish configuration files.

=item L<Mojolicious::Plugin::DefaultHelpers>

General purpose helper collection, loaded automatically.

=item L<Mojolicious::Plugin::EPLRenderer>

Renderer for plain embedded Perl templates, loaded automatically.

=item L<Mojolicious::Plugin::EPRenderer>

Renderer for more sophisticated embedded Perl templates, loaded automatically.

=item L<Mojolicious::Plugin::HeaderCondition>

Route condition for all kinds of headers, loaded automatically.

=item L<Mojolicious::Plugin::JSONConfig>

JSON configuration files.

=item L<Mojolicious::Plugin::Mount>

Mount whole L<Mojolicious> applications.

=item L<Mojolicious::Plugin::NotYAMLConfig>

YAML configuration files.

=item L<Mojolicious::Plugin::TagHelpers>

Template specific helper collection, loaded automatically.

=back

=head1 EVENTS

L<Mojolicious::Plugins> inherits all events from L<Mojo::EventEmitter>.

=head1 ATTRIBUTES

L<Mojolicious::Plugins> implements the following attributes.

=head2 namespaces

  my $namespaces = $plugins->namespaces;
  $plugins       = $plugins->namespaces(['Mojolicious::Plugin']);

Namespaces to load plugins from, defaults to L<Mojolicious::Plugin>.

  # Add another namespace to load plugins from
  push @{$plugins->namespaces}, 'MyApp::Plugin';

=head1 METHODS

L<Mojolicious::Plugins> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 emit_chain

  $plugins->emit_chain('foo');
  $plugins->emit_chain(foo => 123);

Emit events as chained hooks.

=head2 emit_hook

  $plugins = $plugins->emit_hook('foo');
  $plugins = $plugins->emit_hook(foo => 123);

Emit events as hooks.

=head2 emit_hook_reverse

  $plugins = $plugins->emit_hook_reverse('foo');
  $plugins = $plugins->emit_hook_reverse(foo => 123);

Emit events as hooks in reverse order.

=head2 load_plugin

  my $plugin = $plugins->load_plugin('some_thing');
  my $plugin = $plugins->load_plugin('SomeThing');
  my $plugin = $plugins->load_plugin('MyApp::Plugin::SomeThing');

Load a plugin from the configured namespaces or by full module name.

=head2 register_plugin

  $plugins->register_plugin('some_thing', Mojolicious->new);
  $plugins->register_plugin('some_thing', Mojolicious->new, foo => 23);
  $plugins->register_plugin('some_thing', Mojolicious->new, {foo => 23});
  $plugins->register_plugin('SomeThing', Mojolicious->new);
  $plugins->register_plugin('SomeThing', Mojolicious->new, foo => 23);
  $plugins->register_plugin('SomeThing', Mojolicious->new, {foo => 23});
  $plugins->register_plugin('MyApp::Plugin::SomeThing', Mojolicious->new);
  $plugins->register_plugin(
    'MyApp::Plugin::SomeThing', Mojolicious->new, foo => 23);
  $plugins->register_plugin(
    'MyApp::Plugin::SomeThing', Mojolicious->new, {foo => 23});

Load a plugin from the configured namespaces or by full module name and run C<register>, optional arguments are passed
through.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Plugin::DefaultHelpers;
use Mojo::Base 'Mojolicious::Plugin';

use Carp qw(croak);
use Mojo::Asset::File;
use Mojo::ByteStream;
use Mojo::Collection;
use Mojo::Exception;
use Mojo::IOLoop;
use Mojo::Promise;
use Mojo::Util   qw(dumper hmac_sha1_sum steady_time);
use Time::HiRes  qw(gettimeofday tv_interval);
use Scalar::Util qw(blessed weaken);

sub register {
  my ($self, $app) = @_;

  # Controller alias helpers
  for my $name (qw(app param stash session url_for)) {
    $app->helper($name => sub { shift->$name(@_) });
  }

  # Stash key shortcuts (should not generate log messages)
  for my $name (qw(extends layout title)) {
    $app->helper($name => sub { shift->stash($name, @_) });
  }

  $app->helper(accepts => sub { $_[0]->app->renderer->accepts(@_) });
  $app->helper(b       => sub { shift; Mojo::ByteStream->new(@_) });
  $app->helper(c       => sub { shift; Mojo::Collection->new(@_) });
  $app->helper(config  => sub { shift->app->config(@_) });

  $app->helper(content      => sub { _content(0, 0, @_) });
  $app->helper(content_for  => sub { _content(1, 0, @_) });
  $app->helper(content_with => sub { _content(0, 1, @_) });

  $app->helper($_ => $self->can("_$_"))
    for qw(csrf_token current_route exception_format flash inactivity_timeout is_fresh),
    qw(redirect_to respond_to url_with validation);

  $app->helper(dumper  => sub { shift; dumper @_ });
  $app->helper(include => sub { shift->render_to_string(@_) });

  $app->helper(log => \&_log);

  $app->helper('proxy.get_p'   => sub { _proxy_method_p('GET',  @_) });
  $app->helper('proxy.post_p'  => sub { _proxy_method_p('POST', @_) });
  $app->helper('proxy.start_p' => \&_proxy_start_p);

  $app->helper("reply.$_" => $self->can("_$_")) for qw(asset file static);

  $app->helper('reply.exception',      => sub { shift->helpers->reply->http_exception(@_) });
  $app->helper('reply.not_found',      => sub { shift->helpers->reply->http_not_found() });
  $app->helper('reply.http_exception', => \&_http_exception);
  $app->helper('reply.http_not_found', => \&_http_not_found);
  $app->helper('reply.html_exception'  => sub { _development('exception', @_) });
  $app->helper('reply.html_not_found'  => sub { _development('not_found', @_) });
  $app->helper('reply.json_exception', => \&_json_exception);
  $app->helper('reply.json_not_found', => \&_json_not_found);
  $app->helper('reply.txt_exception',  => \&_txt_exception);
  $app->helper('reply.txt_not_found',  => \&_txt_not_found);

  $app->helper('timing.begin'         => \&_timing_begin);
  $app->helper('timing.elapsed'       => \&_timing_elapsed);
  $app->helper('timing.rps'           => \&_timing_rps);
  $app->helper('timing.server_timing' => \&_timing_server_timing);

  $app->helper(ua => sub { shift->app->ua });
}

sub _asset {
  my $c = shift;
  $c->app->static->serve_asset($c, @_);
  $c->rendered;
}

sub _block { ref $_[0] eq 'CODE' ? $_[0]() : $_[0] }

sub _content {
  my ($append, $replace, $c, $name, $content) = @_;
  $name ||= 'content';

  my $hash = $c->stash->{'mojo.content'} //= {};
  if (defined $content) {
    if   ($append)  { $hash->{$name} .= _block($content) }
    if   ($replace) { $hash->{$name} = _block($content) }
    else            { $hash->{$name} //= _block($content) }
  }

  return Mojo::ByteStream->new($hash->{$name} // '');
}

sub _convert_to_exception {
  my $e = shift;
  return (blessed $e && $e->isa('Mojo::Exception')) ? $e : Mojo::Exception->new($e);
}

sub _csrf_token { $_[0]->session->{csrf_token} ||= hmac_sha1_sum($$ . steady_time . rand, $_[0]->app->secrets->[0]) }

sub _current_route {
  return '' unless my $route = shift->match->endpoint;
  return @_ ? $route->name eq shift : $route->name;
}

sub _development {
  my ($page, $c, $e) = @_;

  $c->helpers->log->error(($e = _convert_to_exception($e))->inspect) if $page eq 'exception';

  # Filtered stash snapshot
  my $stash = $c->stash;
  %{$stash->{snapshot} = {}}
    = map { $_ => $_ eq 'app' ? 'DUMMY' : $stash->{$_} } grep { !/^mojo\./ and defined $stash->{$_} } keys %$stash;
  $stash->{exception} = $page eq 'exception' ? $e : undef;

  # Render with fallbacks
  my $app     = $c->app;
  my $mode    = $app->mode;
  my $options = {
    format   => $stash->{format} || $app->renderer->default_format,
    handler  => undef,
    status   => $page eq 'exception' ? 500 : 404,
    template => "$page.$mode"
  };
  my $bundled = 'mojo/' . ($mode eq 'development' ? 'debug' : $page);
  return $c if _fallbacks($c, $options, $page, $bundled);
  _fallbacks($c, {%$options, format => 'html'}, $page, $bundled);
  return $c;
}

sub _exception_format {
  my $c     = shift;
  my $stash = $c->stash;
  $stash->{'mojo.exception_format'} ||= $c->app->exception_format;
  return $stash->{'mojo.exception_format'} unless @_;
  $stash->{'mojo.exception_format'} = shift;
  return $c;
}

sub _fallbacks {
  my ($c, $options, $template, $bundled) = @_;

  # Mode specific template
  return 1 if $c->render_maybe(%$options);

  # Normal template
  return 1 if $c->render_maybe(%$options, template => $template);

  # Inline template
  my $stash = $c->stash;
  return undef unless $options->{format} eq 'html';
  delete @$stash{qw(extends layout)};
  return $c->render_maybe($bundled, %$options, handler => 'ep');
}

sub _file { _asset(shift, Mojo::Asset::File->new(path => shift)) }

sub _flash {
  my $c = shift;

  # Check old flash
  my $session = $c->session;
  return $session->{flash} ? $session->{flash}{$_[0]} : undef if @_ == 1 && !ref $_[0];

  # Initialize new flash and merge values
  my $values = ref $_[0] ? $_[0] : {@_};
  @{$session->{new_flash} //= {}}{keys %$values} = values %$values;

  return $c;
}

sub _http_exception {
  my ($c, $e) = @_;
  my $format = $c->exception_format;
  return $c->helpers->reply->txt_exception($e)  if $format eq 'txt';
  return $c->helpers->reply->json_exception($e) if $format eq 'json';
  return $c->helpers->reply->html_exception($e);
}

sub _http_not_found {
  my $c      = shift;
  my $format = $c->exception_format;
  return $c->helpers->reply->txt_not_found  if $format eq 'txt';
  return $c->helpers->reply->json_not_found if $format eq 'json';
  return $c->helpers->reply->html_not_found;
}

sub _inactivity_timeout {
  my ($c, $timeout) = @_;
  my $stream = Mojo::IOLoop->stream($c->tx->connection // '');
  $stream->timeout($timeout) if $stream;
  return $c;
}

sub _is_fresh {
  my ($c, %options) = @_;
  return $c->app->static->is_fresh($c, \%options);
}

sub _json_exception {
  my ($c, $e) = @_;
  $c->stash->{exception} = _convert_to_exception($e);
  return $c->render(json => {error => $e},                      status => 500) if $c->app->mode eq 'development';
  return $c->render(json => {error => 'Internal Server Error'}, status => 500);
}

sub _json_not_found { shift->render(json => {error => 'Not Found'}, status => 404) }

sub _log { $_[0]->stash->{'mojo.log'} ||= $_[0]->app->log->context('[' . $_[0]->req->request_id . ']') }

sub _proxy_method_p {
  my ($method, $c) = (shift, shift);
  return _proxy_start_p($c, $c->ua->build_tx($method, @_));
}

sub _proxy_start_p {
  my ($c, $source_tx) = @_;
  my $tx = $c->render_later->tx;

  my $promise = Mojo::Promise->new;
  $source_tx->res->content->auto_upgrade(0)->auto_decompress(0)->once(
    body => sub {
      my $source_content = shift;

      my $source_res = $source_tx->res;
      my $res        = $tx->res;
      my $content    = $res->content;
      $res->code($source_res->code)->message($source_res->message);
      my $headers = $source_res->headers->clone->dehop;
      $content->headers($headers);
      $promise->resolve;

      my $source_stream = Mojo::IOLoop->stream($source_tx->connection);
      return unless my $stream = Mojo::IOLoop->stream($tx->connection);

      my $write = $source_content->is_chunked ? 'write_chunk' : 'write';
      $source_content->unsubscribe('read')->on(
        read => sub {
          my $data = pop;
          $content->$write(length $data ? $data : ()) and $tx->resume;

          # Throttle transparently when backpressure rises
          return if $stream->can_write;
          $source_stream->stop;
          $stream->once(drain => sub { $source_stream->start });
        }
      );

      $source_res->once(finish => sub { $content->$write('') and $tx->resume });
    }
  );
  weaken $source_tx;
  $source_tx->once(finish => sub { $promise->reject(_tx_error(@_)) });

  $c->ua->start_p($source_tx)->catch(sub { });

  return $promise;
}

sub _redirect_to {
  my $c = shift;

  # Don't override 3xx status
  my $res = $c->res;
  $res->headers->location($c->url_for(@_));
  return $c->rendered($res->is_redirect ? () : 302);
}

sub _respond_to {
  my ($c, $args) = (shift, ref $_[0] ? $_[0] : {@_});

  # Find target
  my $target;
  my $renderer = $c->app->renderer;
  my @formats  = @{$renderer->accepts($c)};
  for my $format (@formats ? @formats : ($renderer->default_format)) {
    next unless $target = $args->{$format};
    $c->stash->{format} = $format;
    last;
  }

  # Fallback
  unless ($target) {
    return $c->rendered(204) unless $target = $args->{any};
    delete $c->stash->{format};
  }

  # Dispatch
  ref $target eq 'CODE' ? $target->($c) : $c->render(%$target);

  return $c;
}

sub _static {
  my ($c, $file) = @_;
  croak qq{Static file "$file" not found} unless $c->app->static->serve($c, $file);
  return $c->rendered;
}

sub _timing_begin { shift->stash->{'mojo.timing'}{shift()} = [gettimeofday] }

sub _timing_elapsed {
  my ($c, $name) = @_;
  return undef unless my $started = $c->stash->{'mojo.timing'}{$name};
  return tv_interval($started, [gettimeofday()]);
}

sub _timing_rps { $_[1] == 0 ? undef : sprintf '%.3f', 1 / $_[1] }

sub _timing_server_timing {
  my ($c, $metric, $desc, $dur) = @_;
  my $value = $metric;
  $value .= qq{;desc="$desc"} if defined $desc;
  $value .= ";dur=$dur"       if defined $dur;
  $c->res->headers->append('Server-Timing' => $value);
}

sub _tx_error { (shift->error // {})->{message} // 'Unknown error' }

sub _txt_exception {
  my ($c, $e) = @_;
  $c->stash->{exception} = _convert_to_exception($e);
  return $c->render(text => $e,                      format => 'txt', status => 500) if $c->app->mode eq 'development';
  return $c->render(text => 'Internal Server Error', format => 'txt', status => 500);
}

sub _txt_not_found { shift->render(text => 'Not Found', format => 'txt', status => 404) }

sub _url_with {
  my $c = shift;
  return $c->url_for(@_)->query($c->req->url->query->clone);
}

sub _validation {
  my $c = shift;

  my $stash = $c->stash;
  return $stash->{'mojo.validation'} if $stash->{'mojo.validation'};

  my $req    = $c->req;
  my $token  = $c->session->{csrf_token};
  my $header = $req->headers->header('X-CSRF-Token');
  my $hash   = $req->params->to_hash;
  $hash->{csrf_token} //= $header if $token && $header;
  $hash->{$_} = $req->every_upload($_) for map { $_->name } @{$req->uploads};
  my $v = $c->app->validator->validation->input($hash);
  return $stash->{'mojo.validation'} = $v->csrf_token($token);
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Plugin::DefaultHelpers - Default helpers plugin

=head1 SYNOPSIS

  # Mojolicious
  $app->plugin('DefaultHelpers');

  # Mojolicious::Lite
  plugin 'DefaultHelpers';

=head1 DESCRIPTION

L<Mojolicious::Plugin::DefaultHelpers> is a collection of helpers for L<Mojolicious>.

This is a core plugin, that means it is always enabled and its code a good example for learning to build new plugins,
you're welcome to fork it.

See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available by default.

=head1 HELPERS

L<Mojolicious::Plugin::DefaultHelpers> implements the following helpers.

=head2 accepts

  my $formats = $c->accepts;
  my $format  = $c->accepts('html', 'json', 'txt');

Select best possible representation for resource from C<format> C<GET>/C<POST> parameter, C<format> stash value or
C<Accept> request header with L<Mojolicious::Renderer/"accepts">, defaults to returning the first extension if no
preference could be detected.

  # Check if JSON is acceptable
  $c->render(json => {hello => 'world'}) if $c->accepts('json');

  # Check if JSON was specifically requested
  $c->render(json => {hello => 'world'}) if $c->accepts('', 'json');

  # Unsupported representation
  $c->render(data => '', status => 204)
    unless my $format = $c->accepts('html', 'json');

  # Detected representations to select from
  my @formats = @{$c->accepts};

=head2 app

  %= app->secrets->[0]

Alias for L<Mojolicious::Controller/"app">.

=head2 b

  %= b('Joel is a slug')->slugify

Turn string into a L<Mojo::ByteStream> object.

=head2 c

  %= c('a', 'b', 'c')->shuffle->join

Turn list into a L<Mojo::Collection> object.

=head2 config

  %= config 'something'

Alias for L<Mojolicious/"config">.

=head2 content

  %= content foo => begin
    test
  % end
  %= content bar => 'Hello World!'
  %= content 'foo'
  %= content 'bar'
  %= content

Store partial rendered content in a named buffer and retrieve it later, defaults to retrieving the named buffer
C<content>, which is used by the renderer for the C<layout> and C<extends> features. New content will be ignored if the
named buffer is already in use.

=head2 content_for

  % content_for foo => begin
    test
  % end
  %= content_for 'foo'

Same as L</"content">, but appends content to named buffers if they are already in use.

  % content_for message => begin
    Hello
  % end
  % content_for message => begin
    world!
  % end
  %= content 'message'

=head2 content_with

  % content_with foo => begin
    test
  % end
  %= content_with 'foo'

Same as L</"content">, but replaces content of named buffers if they are already in use.

  % content message => begin
    world!
  % end
  % content_with message => begin
    Hello <%= content 'message' %>
  % end
  %= content 'message'

=head2 csrf_token

  %= csrf_token

Get CSRF token from L</"session">, and generate one if none exists.

=head2 current_route

  % if (current_route 'login') {
    Welcome to Mojolicious!
  % }
  %= current_route

Check or get name of current route.

=head2 dumper

  %= dumper {some => 'data'}

Dump a Perl data structure with L<Mojo::Util/"dumper">, very useful for debugging.

=head2 exception_format

  my $format = $c->exception_format;
  $c         = $c->exception_format('txt');

Format for HTTP exceptions (C<html>, C<json>, or C<txt>), defaults to the value of L<Mojolicious/"exception_format">.

=head2 extends

  % extends 'blue';
  % extends 'blue', title => 'Blue!';

Set C<extends> stash value, all additional key/value pairs get merged into the L</"stash">.

=head2 flash

  my $foo = $c->flash('foo');
  $c      = $c->flash({foo => 'bar'});
  $c      = $c->flash(foo => 'bar');
  %= flash 'foo'

Data storage persistent only for the next request, stored in the L</"session">.

  # Show message after redirect
  $c->flash(message => 'User created successfully!');
  $c->redirect_to('show_user', id => 23);

=head2 inactivity_timeout

  $c = $c->inactivity_timeout(3600);

Use L<Mojo::IOLoop/"stream"> to find the current connection and increase timeout if possible.

  # Longer version
  Mojo::IOLoop->stream($c->tx->connection)->timeout(3600);

=head2 include

  %= include 'menubar'
  %= include 'menubar', format => 'txt'

Alias for L<Mojolicious::Controller/"render_to_string">.

=head2 is_fresh

  my $bool = $c->is_fresh;
  my $bool = $c->is_fresh(etag => 'abc');
  my $bool = $c->is_fresh(etag => 'W/"def"');
  my $bool = $c->is_fresh(last_modified => $epoch);

Check freshness of request by comparing the C<If-None-Match> and C<If-Modified-Since> request headers to the C<ETag>
and C<Last-Modified> response headers with L<Mojolicious::Static/"is_fresh">.

  # Add ETag/Last-Modified headers and check freshness before rendering
  $c->is_fresh(etag => 'abc', last_modified => 1424985708)
    ? $c->rendered(304)
    : $c->render(text => 'I â™¥ Mojolicious!');

=head2 layout

  % layout 'green';
  % layout 'green', title => 'Green!';

Set C<layout> stash value, all additional key/value pairs get merged into the L</"stash">.

=head2 log

  my $log = $c->log;

Alternative to L<Mojolicious/"log"> that includes L<Mojo::Message::Request/"request_id"> with every log message.

  # Log message with context
  $c->log->debug('This is a log message with request id');

  # Pass logger with context to model
  my $log = $c->log;
  $c->some_model->create({foo => $foo}, $log);

=head2 param

  %= param 'foo'

Alias for L<Mojolicious::Controller/"param">.

=head2 proxy->get_p

  my $promise = $c->proxy->get_p('http://example.com' => {Accept => '*/*'});

Perform non-blocking C<GET> request and forward response as efficiently as possible, takes the same arguments as
L<Mojo::UserAgent/"get"> and returns a L<Mojo::Promise> object.

  # Forward with exception handling
  $c->proxy->get_p('http://mojolicious.org')->catch(sub ($err) {
    $c->log->debug("Proxy error: $err");
    $c->render(text => 'Something went wrong!', status => 400);
  });

=head2 proxy->post_p

  my $promise = $c->proxy->post_p('http://example.com' => {Accept => '*/*'});

Perform non-blocking C<POST> request and forward response as efficiently as possible, takes the same arguments as
L<Mojo::UserAgent/"post"> and returns a L<Mojo::Promise> object.

  # Forward with exception handling
  $c->proxy->post_p('example.com' => form => {test => 'pass'})->catch(sub ($err) {
    $c->log->debug("Proxy error: $err");
    $c->render(text => 'Something went wrong!', status => 400);
  });

=head2 proxy->start_p

  my $promise = $c->proxy->start_p(Mojo::Transaction::HTTP->new);

Perform non-blocking request for a custom L<Mojo::Transaction::HTTP> object and forward response as efficiently as
possible, returns a L<Mojo::Promise> object.

  # Forward with exception handling
  my $tx = $c->ua->build_tx(GET => 'http://mojolicious.org');
  $c->proxy->start_p($tx)->catch(sub ($err) {
    $c->log->debug("Proxy error: $err");
    $c->render(text => 'Something went wrong!', status => 400);
  });

  # Forward with custom request and response headers
  my $headers = $c->req->headers->clone->dehop;
  $headers->header('X-Proxy' => 'Mojo');
  my $tx = $c->ua->build_tx(GET => 'http://example.com' => $headers->to_hash);
  $c->proxy->start_p($tx);
  $tx->res->content->once(body => sub ($content) { $c->res->headers->header('X-Proxy' => 'Mojo') });

=head2 redirect_to

  $c = $c->redirect_to('named', foo => 'bar');
  $c = $c->redirect_to('named', {foo => 'bar'});
  $c = $c->redirect_to('/index.html');
  $c = $c->redirect_to('http://example.com/index.html');

Prepare a C<302> (if the status code is not already C<3xx>) redirect response with C<Location> header, takes the same
arguments as L</"url_for">.

  # Moved Permanently
  $c->res->code(301);
  $c->redirect_to('some_route');

  # Temporary Redirect
  $c->res->code(307);
  $c->redirect_to('some_route');

=head2 reply->asset

  $c->reply->asset(Mojo::Asset::File->new);

Reply with a L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object using L<Mojolicious::Static/"serve_asset">, and
perform content negotiation with C<Range>, C<If-Modified-Since> and C<If-None-Match> headers.

  # Serve asset with custom modification time
  my $asset = Mojo::Asset::Memory->new;
  $asset->add_chunk('Hello World!')->mtime(784111777);
  $c->res->headers->content_type('text/plain');
  $c->reply->asset($asset);

  # Serve static file if it exists
  if (my $asset = $c->app->static->file('images/logo.png')) {
    $c->res->headers->content_type('image/png');
    $c->reply->asset($asset);
  }

=head2 reply->exception

  $c = $c->reply->exception('Oops!');
  $c = $c->reply->exception(Mojo::Exception->new);

Render an exception response in the appropriate format by delegating to more specific exception helpers.

=head2 reply->file

  $c->reply->file('/etc/passwd');

Reply with a static file from an absolute path anywhere on the file system using L<Mojolicious/"static">.

  # Longer version
  $c->reply->asset(Mojo::Asset::File->new(path => '/etc/passwd'));

  # Serve file from an absolute path with a custom content type
  $c->res->headers->content_type('application/myapp');
  $c->reply->file('/home/sri/foo.txt');

  # Serve file from a secret application directory
  $c->reply->file($c->app->home->child('secret', 'file.txt'));

=head2 reply->html_exception

  $c = $c->reply->html_exception('Oops!');
  $c = $c->reply->html_exception(Mojo::Exception->new);

Render the exception template C<exception.$mode.$format.*> or C<exception.$format.*> and set the response status code
to C<500>. Also sets the stash values C<exception> to a L<Mojo::Exception> object and C<snapshot> to a copy of the
L</"stash"> for use in the templates.

=head2 reply->html_not_found

  $c = $c->reply->html_not_found;

Render the not found template C<not_found.$mode.$format.*> or C<not_found.$format.*> and set the response status code
to C<404>. Also sets the stash value C<snapshot> to a copy of the L</"stash"> for use in the templates.

=head2 reply->json_exception

  $c = $c->reply->json_exception('Oops!');
  $c = $c->reply->json_exception(Mojo::Exception->new);

Render a JSON response and set the response status to C<500>.

=head2 reply->json_not_found

  $c = $c->reply->json_not_found;

Render a JSON response and set the response status to C<404>.

=head2 reply->not_found

  $c = $c->reply->not_found;

Render a not found response in the appropriate format by delegating to more specific exception helpers.

=head2 reply->static

  $c->reply->static('images/logo.png');
  $c->reply->static('../lib/MyApp.pm');

Reply with a static file using L<Mojolicious/"static">, usually from the C<public> directories or C<DATA> sections of
your application. Note that this helper uses a relative path, but does not protect from traversing to parent
directories.

  # Serve file from a relative path with a custom content type
  $c->res->headers->content_type('application/myapp');
  $c->reply->static('foo.txt');

=head2 reply->txt_exception

  $c = $c->reply->txt_exception('Oops!');
  $c = $c->reply->txt_exception(Mojo::Exception->new);

Render a plain text response and set the response status to C<500>.

=head2 reply->txt_not_found

  $c = $c->reply->txt_not_found;

Render a plain text response and set the response status to C<404>.

=head2 respond_to

  $c = $c->respond_to(
    json => {json => {message => 'Welcome!'}},
    html => {template => 'welcome'},
    any  => sub {...}
  );

Automatically select best possible representation for resource from C<format> C<GET>/C<POST> parameter, C<format> stash
value or C<Accept> request header, defaults to L<Mojolicious::Renderer/"default_format"> or rendering an empty C<204>
response. Each representation can be handled with a callback or a hash reference containing arguments to be passed to
L<Mojolicious::Controller/"render">.

  # Everything else than "json" and "xml" gets a 204 response
  $c->respond_to(
    json => sub { $c->render(json => {just => 'works'}) },
    xml  => {text => '<just>works</just>'},
    any  => {data => '', status => 204}
  );

For more advanced negotiation logic you can also use L</"accepts">.

=head2 session

  %= session 'foo'

Alias for L<Mojolicious::Controller/"session">.

=head2 stash

  %= stash 'foo'
  % stash foo => 'bar';

Alias for L<Mojolicious::Controller/"stash">.

  %= stash('name') // 'Somebody'

=head2 timing->begin

  $c->timing->begin('foo');

Create named timestamp for L<"timing-E<gt>elapsed">.

=head2 timing->elapsed

  my $elapsed = $c->timing->elapsed('foo');

Return fractional amount of time in seconds since named timstamp has been created with L</"timing-E<gt>begin"> or
C<undef> if no such timestamp exists.

  # Log timing information
  $c->timing->begin('database_stuff');
  ...
  my $elapsed = $c->timing->elapsed('database_stuff');
  $c->app->log->debug("Database stuff took $elapsed seconds");

=head2 timing->rps

  my $rps = $c->timing->rps('0.001');

Return fractional number of requests that could be performed in one second if every singe one took the given amount of
time in seconds or C<undef> if the number is too low.

  # Log more timing information
  $c->timing->begin('web_stuff');
  ...
  my $elapsed = $c->timing->elapsed('web_stuff');
  my $rps     = $c->timing->rps($elapsed);
  $c->app->log->debug("Web stuff took $elapsed seconds ($rps per second)");

=head2 timing->server_timing

  $c->timing->server_timing('metric');
  $c->timing->server_timing('metric', 'Some Description');
  $c->timing->server_timing('metric', 'Some Description', '0.001');

Create C<Server-Timing> header with optional description and duration.

  # "Server-Timing: miss"
  $c->timing->server_timing('miss');

  # "Server-Timing: dc;desc=atl"
  $c->timing->server_timing('dc', 'atl');

  # "Server-Timing: db;desc=Database;dur=0.0001"
  $c->timing->begin('database_stuff');
  ...
  my $elapsed = $c->timing->elapsed('database_stuff');
  $c->timing->server_timing('db', 'Database', $elapsed);

  # "Server-Timing: miss, dc;desc=atl"
  $c->timing->server_timing('miss');
  $c->timing->server_timing('dc', 'atl');

=head2 title

  %= title
  % title 'Welcome!';
  % title 'Welcome!', foo => 'bar';

Get or set C<title> stash value, all additional key/value pairs get merged into the L</"stash">.

=head2 ua

  %= ua->get('mojolicious.org')->result->dom->at('title')->text

Alias for L<Mojolicious/"ua">.

=head2 url_for

  %= url_for 'named', foo => 'bar', baz => 'yada'

Alias for L<Mojolicious::Controller/"url_for">.

  %= url_for('/index.html')->query(foo => 'bar')

=head2 url_with

  %= url_with 'named', foo => 'bar', baz => 'yada'

Does the same as L</"url_for">, but inherits query parameters from the current request.

  %= url_with->query({page => 2})

=head2 validation

  my $v = $c->validation;

Get L<Mojolicious::Validator::Validation> object for current request to validate file uploads as well as C<GET> and
C<POST> parameters extracted from the query string and C<application/x-www-form-urlencoded> or C<multipart/form-data>
message body. Parts of the request body need to be loaded into memory to parse C<POST> parameters, so you have to make
sure it is not excessively large. There's a 16MiB limit for requests by default.

  # Validate GET/POST parameter
  my $v = $c->validation;
  $v->required('title', 'trim')->size(3, 50);
  my $title = $v->param('title');

  # Validate file upload
  my $v = $c->validation;
  $v->required('tarball')->upload->size(1, 1048576);
  my $tarball = $v->param('tarball');

=head1 METHODS

L<Mojolicious::Plugin::DefaultHelpers> inherits all methods from L<Mojolicious::Plugin> and implements the following
new ones.

=head2 register

  $plugin->register(Mojolicious->new);

Register helpers in L<Mojolicious> application.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Plugin::HeaderCondition;
use Mojo::Base 'Mojolicious::Plugin';

use re qw(is_regexp);

sub register {
  my ($self, $app) = @_;

  $app->routes->add_condition(headers => \&_headers);
  $app->routes->add_condition(agent   => sub { _headers(@_[0 .. 2], {'User-Agent' => $_[3]}) });
  $app->routes->add_condition(host    => sub { _check($_[1]->req->url->to_abs->host, $_[3]) });
}

sub _check {
  my ($value, $pattern) = @_;
  return 1 if $value && $pattern && is_regexp($pattern) && $value =~ $pattern;
  return $value && defined $pattern && $pattern eq $value;
}

sub _headers {
  my ($route, $c, $captures, $patterns) = @_;
  return undef unless $patterns && ref $patterns eq 'HASH' && keys %$patterns;

  # All headers need to match
  my $headers = $c->req->headers;
  _check($headers->header($_), $patterns->{$_}) || return undef for keys %$patterns;
  return 1;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Plugin::HeaderCondition - Header condition plugin

=head1 SYNOPSIS

  # Mojolicious
  $app->plugin('HeaderCondition');
  $app->routes->get('/foo')->requires(headers => {Referer => qr/example\.com/});

  # Mojolicious::Lite
  plugin 'HeaderCondition';
  get '/' => (headers => {Referer => qr/example\.com/}) => sub {...};

  # All headers need to match
  $app->routes->get('/foo')->requires(headers => {
    'X-Secret-Header' => 'Foo',
    Referer => qr/example\.com/
  });

  # The "agent" condition is a shortcut for the "User-Agent" header
  get '/' => (agent => qr/Firefox/) => sub {...};

  # The "host" condition is a shortcut for the detected host
  get '/' => (host => qr/mojolicious\.org/) => sub {...};

=head1 DESCRIPTION

L<Mojolicious::Plugin::HeaderCondition> is a route condition for header-based routes.

This is a core plugin, that means it is always enabled and its code a good example for learning to build new plugins,
you're welcome to fork it.

See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available by default.

=head1 METHODS

L<Mojolicious::Plugin::HeaderCondition> inherits all methods from L<Mojolicious::Plugin> and implements the following
new ones.

=head2 register

  $plugin->register(Mojolicious->new);

Register conditions in L<Mojolicious> application.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Plugin::TagHelpers;
use Mojo::Base 'Mojolicious::Plugin';

use Mojo::ByteStream;
use Mojo::DOM::HTML qw(tag_to_html);
use Scalar::Util    qw(blessed);

sub register {
  my ($self, $app) = @_;

  # Text field variations
  my @time = qw(date month time week);
  for my $name (@time, qw(color email number range search tel text url)) {
    $app->helper("${name}_field" => sub { _input(@_, type => $name) });
  }
  $app->helper(datetime_field => sub { _input(@_, type => 'datetime-local') });

  my @helpers = (
    qw(asset_tag csrf_field form_for hidden_field javascript label_for link_to select_field stylesheet submit_button),
    qw(tag_with_error text_area)
  );
  $app->helper($_ => __PACKAGE__->can("_$_")) for @helpers;

  $app->helper(button_to      => sub { _button_to(0, @_) });
  $app->helper(check_box      => sub { _input(@_, type => 'checkbox') });
  $app->helper(csrf_button_to => sub { _button_to(1, @_) });
  $app->helper(file_field     => sub { _empty_field('file', @_) });
  $app->helper(image          => sub { _tag('img', src => shift->url_for(shift), @_) });
  $app->helper(input_tag      => sub { _input(@_) });
  $app->helper(password_field => sub { _empty_field('password', @_) });
  $app->helper(radio_button   => sub { _input(@_, type => 'radio') });

  # "t" is just a shortcut for the "tag" helper
  $app->helper($_ => sub { shift; _tag(@_) }) for qw(t tag);
}

sub _asset_tag {
  my ($c, $target) = (shift, shift);

  my $url = $c->url_for_asset($target);

  return $c->helpers->javascript($url, @_) if $target =~ /\.js$/;
  return $c->helpers->stylesheet($url, @_) if $target =~ /\.css$/;
  return $c->helpers->image($url, @_);
}

sub _button_to {
  my ($csrf, $c, $text) = (shift, shift, shift);
  my $prefix = $csrf ? _csrf_field($c) : '';
  return _form_for($c, @_, sub { $prefix . _submit_button($c, $text) });
}

sub _csrf_field {
  my $c = shift;
  return _hidden_field($c, csrf_token => $c->helpers->csrf_token, @_);
}

sub _empty_field {
  my ($type, $c, $name) = (shift, shift, shift);
  return _validation($c, $name, 'input', name => $name, @_, type => $type);
}

sub _form_for {
  my ($c, @url) = (shift, shift);
  push @url, shift if ref $_[0] eq 'HASH';

  # Method detection
  my $r      = $c->app->routes->lookup($url[0]);
  my $method = $r               ? $r->suggested_method : 'GET';
  my @post   = $method ne 'GET' ? (method => 'POST')   : ();

  my $url = $c->url_for(@url);
  $url->query({_method => $method}) if @post && $method ne 'POST';
  return _tag('form', action => $url, @post, @_);
}

sub _hidden_field {
  my ($c, $name, $value) = (shift, shift, shift);
  return _tag('input', name => $name, value => $value, @_, type => 'hidden');
}

sub _input {
  my ($c, $name) = (shift, shift);
  my %attrs = @_ % 2 ? (value => shift, @_) : @_;

  if (my @values = @{$c->every_param($name)}) {

    # Checkbox or radiobutton
    my $type = $attrs{type} || '';
    if ($type eq 'checkbox' || $type eq 'radio') {
      my $value = $attrs{value} // 'on';
      delete $attrs{checked};
      $attrs{checked} = undef if grep { $_ eq $value } @values;
    }

    # Others
    else { $attrs{value} = $values[-1] }
  }

  return _validation($c, $name, 'input', name => $name, %attrs);
}

sub _javascript {
  my $c       = shift;
  my $content = ref $_[-1] eq 'CODE' ? "//<![CDATA[\n" . pop->() . "\n//]]>" : '';
  my @src     = @_ % 2               ? (src => $c->url_for(shift))           : ();
  return _tag('script', @src, @_, sub {$content});
}

sub _label_for {
  my ($c, $name) = (shift, shift);
  my $content = ref $_[-1] eq 'CODE' ? pop : shift;
  return _validation($c, $name, 'label', for => $name, @_, $content);
}

sub _link_to {
  my ($c, $content) = (shift, shift);
  my @url = ($content);

  # Content
  unless (ref $_[-1] eq 'CODE') {
    @url = (shift);
    push @_, $content;
  }

  # Captures
  push @url, shift if ref $_[0] eq 'HASH';

  return _tag('a', href => $c->url_for(@url), @_);
}

sub _option {
  my ($values, $pair) = @_;

  $pair = [$pair => $pair] unless ref $pair eq 'ARRAY';
  my %attrs = (value => $pair->[1], @$pair[2 .. $#$pair]);
  delete $attrs{selected}  if keys %$values;
  $attrs{selected} = undef if $values->{$pair->[1]};

  return _tag('option', %attrs, $pair->[0]);
}

sub _select_field {
  my ($c, $name, $options, %attrs) = (shift, shift, shift, @_);

  my %values = map { $_ => 1 } grep {defined} @{$c->every_param($name)};

  my $groups = '';
  for my $group (@$options) {

    # "optgroup" tag
    if (blessed $group && $group->isa('Mojo::Collection')) {
      my ($label, $values, %attrs) = @$group;
      my $content = join '', map { _option(\%values, $_) } @$values;
      $groups .= _tag('optgroup', label => $label, %attrs, sub {$content});
    }

    # "option" tag
    else { $groups .= _option(\%values, $group) }
  }

  return _validation($c, $name, 'select', name => $name, %attrs, sub {$groups});
}

sub _stylesheet {
  my $c       = shift;
  my $content = ref $_[-1] eq 'CODE' ? "/*<![CDATA[*/\n" . pop->() . "\n/*]]>*/" : '';
  return _tag('style', @_, sub {$content}) unless @_ % 2;
  return _tag('link', rel => 'stylesheet', href => $c->url_for(shift), @_);
}

sub _submit_button {
  my ($c, $value) = (shift, shift // 'Ok');
  return _tag('input', value => $value, @_, type => 'submit');
}

sub _tag { Mojo::ByteStream->new(tag_to_html(@_)) }

sub _tag_with_error {
  my ($c, $tag) = (shift, shift);
  my ($content, %attrs) = (@_ % 2 ? pop : undef, @_);
  $attrs{class} .= $attrs{class} ? ' field-with-error' : 'field-with-error';
  return _tag($tag, %attrs, defined $content ? $content : ());
}

sub _text_area {
  my ($c, $name) = (shift, shift);

  my $cb      = ref $_[-1] eq 'CODE' ? pop   : undef;
  my $content = @_ % 2               ? shift : undef;
  $content = $c->param($name) // $content // $cb // '';

  return _validation($c, $name, 'textarea', name => $name, @_, $content);
}

sub _validation {
  my ($c, $name) = (shift, shift);
  return _tag(@_) unless $c->helpers->validation->has_error($name);
  return $c->helpers->tag_with_error(@_);
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Plugin::TagHelpers - Tag helpers plugin

=head1 SYNOPSIS

  # Mojolicious
  $app->plugin('TagHelpers');

  # Mojolicious::Lite
  plugin 'TagHelpers';

=head1 DESCRIPTION

L<Mojolicious::Plugin::TagHelpers> is a collection of HTML tag helpers for L<Mojolicious>, based on the L<HTML Living
Standard|https://html.spec.whatwg.org>.

Most form helpers can automatically pick up previous input values and will show them as default. You can also use
L<Mojolicious::Plugin::DefaultHelpers/"param"> to set them manually and let necessary attributes always be generated
automatically.

  % param country => 'germany' unless param 'country';
  <%= radio_button country => 'germany' %> Germany
  <%= radio_button country => 'france'  %> France
  <%= radio_button country => 'uk'      %> UK

For fields that failed validation with L<Mojolicious::Plugin::DefaultHelpers/"validation"> the C<field-with-error>
class will be automatically added through L</"tag_with_error">, to make styling with CSS easier.

  <input class="field-with-error" name="age" type="text" value="250">

This is a core plugin, that means it is always enabled and its code a good example for learning how to build new
plugins, you're welcome to fork it.

See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available by default.

=head1 HELPERS

L<Mojolicious::Plugin::TagHelpers> implements the following helpers.

=head2 asset_tag

  %= asset_tag '/app.js'
  %= asset_tag '/app.js', async => 'async'

Generate C<script>, C<link> or C<img> tag for static asset.

=head2 button_to

  %= button_to Test => 'some_get_route'
  %= button_to Test => some_get_route => {id => 23} => (class => 'menu')
  %= button_to Test => 'http://example.com/test' => (class => 'menu')
  %= button_to Remove => 'some_delete_route'

Generate portable C<form> tag with L</"form_for">, containing a single button.

  <form action="/path/to/get/route">
    <input type="submit" value="Test">
  </form>
  <form action="/path/to/get/route/23" class="menu">
    <input type="submit" value="Test">
  </form>
  <form action="http://example.com/test" class="menu">
    <input type="submit" value="Test">
  </form>
  <form action="/path/to/delete/route?_method=DELETE" method="POST">
    <input type="submit" value="Remove">
  </form>

=head2 check_box

  %= check_box 'employed'
  %= check_box employed => 1
  %= check_box employed => 1, checked => undef, id => 'foo'

Generate C<input> tag of type C<checkbox>. Previous input values will automatically get picked up and shown as default.

  <input name="employed" type="checkbox">
  <input name="employed" type="checkbox" value="1">
  <input checked id="foo" name="employed" type="checkbox" value="1">

=head2 color_field

  %= color_field 'background'
  %= color_field background => '#ffffff'
  %= color_field background => '#ffffff', id => 'foo'

Generate C<input> tag of type C<color>. Previous input values will automatically get picked up and shown as default.

  <input name="background" type="color">
  <input name="background" type="color" value="#ffffff">
  <input id="foo" name="background" type="color" value="#ffffff">

=head2 csrf_button_to

  %= csrf_button_to Remove => 'some_delete_route'

Same as L</"button_to">, but also includes a L</"csrf_field">.

  <form action="/path/to/delete/route?_method=DELETE" method="POST">
    <input name="csrf_token" type="hidden" value="fa6a08...">
    <input type="submit" value="Remove">
  </form>

=head2 csrf_field

  %= csrf_field

Generate C<input> tag of type C<hidden> with L<Mojolicious::Plugin::DefaultHelpers/"csrf_token">.

  <input name="csrf_token" type="hidden" value="fa6a08...">

=head2 date_field

  %= date_field 'end'
  %= date_field end => '2012-12-21'
  %= date_field end => '2012-12-21', id => 'foo'

Generate C<input> tag of type C<date>. Previous input values will automatically get picked up and shown as default.

  <input name="end" type="date">
  <input name="end" type="date" value="2012-12-21">
  <input id="foo" name="end" type="date" value="2012-12-21">

=head2 datetime_field

  %= datetime_field 'end'
  %= datetime_field end => '2012-12-21T23:59:59'
  %= datetime_field end => '2012-12-21T23:59:59', id => 'foo'

Generate C<input> tag of type C<datetime-local>. Previous input values will automatically get picked up and shown as
default.

  <input name="end" type="datetime-local">
  <input name="end" type="datetime-local" value="2012-12-21T23:59:59">
  <input id="foo" name="end" type="datetime-local" value="2012-12-21T23:59:59">

=head2 email_field

  %= email_field 'notify'
  %= email_field notify => 'nospam@example.com'
  %= email_field notify => 'nospam@example.com', id => 'foo'

Generate C<input> tag of type C<email>. Previous input values will automatically get picked up and shown as default.

  <input name="notify" type="email">
  <input name="notify" type="email" value="nospam@example.com">
  <input id="foo" name="notify" type="email" value="nospam@example.com">

=head2 file_field

  %= file_field 'avatar'
  %= file_field 'avatar', id => 'foo'

Generate C<input> tag of type C<file>.

  <input name="avatar" type="file">
  <input id="foo" name="avatar" type="file">

=head2 form_for

  %= form_for login => begin
    %= text_field 'first_name'
    %= submit_button
  % end
  %= form_for login => {format => 'txt'} => (method => 'POST') => begin
    %= text_field 'first_name'
    %= submit_button
  % end
  %= form_for '/login' => (enctype => 'multipart/form-data') => begin
    %= text_field 'first_name', disabled => 'disabled'
    %= submit_button
  % end
  %= form_for 'http://example.com/login' => (method => 'POST') => begin
    %= text_field 'first_name'
    %= submit_button
  % end
  %= form_for some_delete_route => begin
    %= submit_button 'Remove'
  % end

Generate portable C<form> tag with L<Mojolicious::Controller/"url_for">. For routes that do not allow C<GET>, a
C<method> attribute with the value C<POST> will be automatically added. And for methods other than C<GET> or C<POST>,
an C<_method> query parameter will be added as well.

  <form action="/path/to/login">
    <input name="first_name" type="text">
    <input type="submit" value="Ok">
  </form>
  <form action="/path/to/login.txt" method="POST">
    <input name="first_name" type="text">
    <input type="submit" value="Ok">
  </form>
  <form action="/path/to/login" enctype="multipart/form-data">
    <input disabled="disabled" name="first_name" type="text">
    <input type="submit" value="Ok">
  </form>
  <form action="http://example.com/login" method="POST">
    <input name="first_name" type="text">
    <input type="submit" value="Ok">
  </form>
  <form action="/path/to/delete/route?_method=DELETE" method="POST">
    <input type="submit" value="Remove">
  </form>

=head2 hidden_field

  %= hidden_field foo => 'bar'
  %= hidden_field foo => 'bar', id => 'bar'

Generate C<input> tag of type C<hidden>.

  <input name="foo" type="hidden" value="bar">
  <input id="bar" name="foo" type="hidden" value="bar">

=head2 image

  %= image '/images/foo.png'
  %= image '/images/foo.png', alt => 'Foo'

Generate portable C<img> tag.

  <img src="/path/to/images/foo.png">
  <img alt="Foo" src="/path/to/images/foo.png">

=head2 input_tag

  %= input_tag 'first_name'
  %= input_tag first_name => 'Default'
  %= input_tag 'employed', type => 'checkbox'

Generate C<input> tag. Previous input values will automatically get picked up and shown as default.

  <input name="first_name">
  <input name="first_name" value="Default">
  <input name="employed" type="checkbox">

=head2 javascript

  %= javascript '/script.js'
  %= javascript '/script.js', defer => undef
  %= javascript begin
    const a = 'b';
  % end

Generate portable C<script> tag for JavaScript asset.

  <script src="/path/to/script.js"></script>
  <script defer src="/path/to/script.js"></script>
  <script><![CDATA[
    const a = 'b';
  ]]></script>

=head2 label_for

  %= label_for first_name => 'First name'
  %= label_for first_name => 'First name', class => 'user'
  %= label_for first_name => begin
    First name
  % end
  %= label_for first_name => (class => 'user') => begin
    First name
  % end

Generate C<label> tag.

  <label for="first_name">First name</label>
  <label class="user" for="first_name">First name</label>
  <label for="first_name">
    First name
  </label>
  <label class="user" for="first_name">
    First name
  </label>

=head2 link_to

  %= link_to Home => 'index'
  %= link_to Home => 'index' => {format => 'txt'} => (class => 'menu')
  %= link_to index => {format => 'txt'} => (class => 'menu') => begin
    Home
  % end
  %= link_to Contact => 'mailto:sri@example.com'
  <%= link_to index => begin %>Home<% end %>
  <%= link_to '/file.txt' => begin %>File<% end %>
  <%= link_to 'https://mojolicious.org' => begin %>Mojolicious<% end %>
  <%= link_to url_for->query(foo => 'bar')->to_abs => begin %>Retry<% end %>

Generate portable C<a> tag with L<Mojolicious::Controller/"url_for">, defaults to using the capitalized link target as
content.

  <a href="/path/to/index">Home</a>
  <a class="menu" href="/path/to/index.txt">Home</a>
  <a class="menu" href="/path/to/index.txt">
    Home
  </a>
  <a href="mailto:sri@example.com">Contact</a>
  <a href="/path/to/index">Home</a>
  <a href="/path/to/file.txt">File</a>
  <a href="https://mojolicious.org">Mojolicious</a>
  <a href="http://127.0.0.1:3000/current/path?foo=bar">Retry</a>

The first argument to C<link_to> is the link content, except when the
final argument is Perl code such as a template block (created with the
C<begin> and C<end> keywords); in that case, the link content is
omitted at the start of the argument list, and the block will become
the link content.

=head2 month_field

  %= month_field 'vacation'
  %= month_field vacation => '2012-12'
  %= month_field vacation => '2012-12', id => 'foo'

Generate C<input> tag of type C<month>. Previous input values will automatically get picked up and shown as default.

  <input name="vacation" type="month">
  <input name="vacation" type="month" value="2012-12">
  <input id="foo" name="vacation" type="month" value="2012-12">

=head2 number_field

  %= number_field 'age'
  %= number_field age => 25
  %= number_field age => 25, id => 'foo', min => 0, max => 200

Generate C<input> tag of type C<number>. Previous input values will automatically get picked up and shown as default.

  <input name="age" type="number">
  <input name="age" type="number" value="25">
  <input id="foo" max="200" min="0" name="age" type="number" value="25">

=head2 password_field

  %= password_field 'pass'
  %= password_field 'pass', id => 'foo'

Generate C<input> tag of type C<password>.

  <input name="pass" type="password">
  <input id="foo" name="pass" type="password">

=head2 radio_button

  %= radio_button 'test'
  %= radio_button country => 'germany'
  %= radio_button country => 'germany', checked => undef, id => 'foo'

Generate C<input> tag of type C<radio>. Previous input values will automatically get picked up and shown as default.

  <input name="test" type="radio">
  <input name="country" type="radio" value="germany">
  <input checked id="foo" name="country" type="radio" value="germany">

=head2 range_field

  %= range_field 'age'
  %= range_field age => 25
  %= range_field age => 25, id => 'foo', min => 0, max => 200

Generate C<input> tag of type C<range>. Previous input values will automatically get picked up and shown as default.

  <input name="age" type="range">
  <input name="age" type="range" value="25">
  <input id="foo" max="200" min="200" name="age" type="range" value="25">

=head2 search_field

  %= search_field 'q'
  %= search_field q => 'perl'
  %= search_field q => 'perl', id => 'foo'

Generate C<input> tag of type C<search>. Previous input values will automatically get picked up and shown as default.

  <input name="q" type="search">
  <input name="q" type="search" value="perl">
  <input id="foo" name="q" type="search" value="perl">

=head2 select_field

  %= select_field country => ['de', 'en']
  %= select_field country => [[Germany => 'de'], 'en'], id => 'eu'
  %= select_field country => [[Germany => 'de', selected => 'selected'], 'en']
  %= select_field country => [c(EU => [[Germany => 'de'], 'en'], id => 'eu')]
  %= select_field country => [c(EU => ['de', 'en']), c(Asia => ['cn', 'jp'])]

Generate C<select> and C<option> tags from array references and C<optgroup> tags from L<Mojo::Collection> objects.
Previous input values will automatically get picked up and shown as default.

  <select name="country">
    <option value="de">de</option>
    <option value="en">en</option>
  </select>
  <select id="eu" name="country">
    <option value="de">Germany</option>
    <option value="en">en</option>
  </select>
  <select name="country">
    <option selected="selected" value="de">Germany</option>
    <option value="en">en</option>
  </select>
  <select name="country">
    <optgroup id="eu" label="EU">
      <option value="de">Germany</option>
      <option value="en">en</option>
    </optgroup>
  </select>
  <select name="country">
    <optgroup label="EU">
      <option value="de">de</option>
      <option value="en">en</option>
    </optgroup>
    <optgroup label="Asia">
      <option value="cn">cn</option>
      <option value="jp">jp</option>
    </optgroup>
  </select>

=head2 stylesheet

  %= stylesheet '/foo.css'
  %= stylesheet '/foo.css', title => 'Foo style'
  %= stylesheet begin
    body {color: #000}
  % end

Generate portable C<style> or C<link> tag for CSS asset.

  <link href="/path/to/foo.css" rel="stylesheet">
  <link href="/path/to/foo.css" rel="stylesheet" title="Foo style">
  <style><![CDATA[
    body {color: #000}
  ]]></style>

=head2 submit_button

  %= submit_button
  %= submit_button 'Ok!', id => 'foo'

Generate C<input> tag of type C<submit>.

  <input type="submit" value="Ok">
  <input id="foo" type="submit" value="Ok!">

=head2 t

  %= t div => 'test & 123'

Alias for L</"tag">.

  <div>test &amp; 123</div>

=head2 tag

  %= tag 'br'
  %= tag 'div'
  %= tag 'div', id => 'foo', hidden => undef
  %= tag 'div', 'test & 123'
  %= tag 'div', id => 'foo', 'test & 123'
  %= tag 'div', data => {my_id => 1, Name => 'test'}, 'test & 123'
  %= tag div => begin
    test & 123
  % end
  <%= tag div => (id => 'foo') => begin %>test & 123<% end %>

Alias for L<Mojo::DOM/"new_tag">.

  <br>
  <div></div>
  <div id="foo" hidden></div>
  <div>test &amp; 123</div>
  <div id="foo">test &amp; 123</div>
  <div data-my-id="1" data-name="test">test &amp; 123</div>
  <div>
    test & 123
  </div>
  <div id="foo">test & 123</div>

Very useful for reuse in more specific tag helpers.

  my $output = $c->tag('meta');
  my $output = $c->tag('meta', charset => 'UTF-8');
  my $output = $c->tag('div', '<p>This will be escaped</p>');
  my $output = $c->tag('div', sub { '<p>This will not be escaped</p>' });

Results are automatically wrapped in L<Mojo::ByteStream> objects to prevent accidental double escaping in C<ep>
templates.

=head2 tag_with_error

  %= tag_with_error 'input', class => 'foo'

Same as L</"tag">, but adds the class C<field-with-error>.

  <input class="foo field-with-error">

=head2 tel_field

  %= tel_field 'work'
  %= tel_field work => '123456789'
  %= tel_field work => '123456789', id => 'foo'

Generate C<input> tag of type C<tel>. Previous input values will automatically get picked up and shown as default.

  <input name="work" type="tel">
  <input name="work" type="tel" value="123456789">
  <input id="foo" name="work" type="tel" value="123456789">

=head2 text_area

  %= text_area 'story'
  %= text_area 'story', cols => 40
  %= text_area story => 'Default', cols => 40
  %= text_area story => (cols => 40) => begin
    Default
  % end

Generate C<textarea> tag. Previous input values will automatically get picked up and shown as default.

  <textarea name="story"></textarea>
  <textarea cols="40" name="story"></textarea>
  <textarea cols="40" name="story">Default</textarea>
  <textarea cols="40" name="story">
    Default
  </textarea>

=head2 text_field

  %= text_field 'first_name'
  %= text_field first_name => 'Default'
  %= text_field first_name => 'Default', class => 'user'

Generate C<input> tag of type C<text>. Previous input values will automatically get picked up and shown as default.

  <input name="first_name" type="text">
  <input name="first_name" type="text" value="Default">
  <input class="user" name="first_name" type="text" value="Default">

=head2 time_field

  %= time_field 'start'
  %= time_field start => '23:59:59'
  %= time_field start => '23:59:59', id => 'foo'

Generate C<input> tag of type C<time>. Previous input values will automatically get picked up and shown as default.

  <input name="start" type="time">
  <input name="start" type="time" value="23:59:59">
  <input id="foo" name="start" type="time" value="23:59:59">

=head2 url_field

  %= url_field 'address'
  %= url_field address => 'https://mojolicious.org'
  %= url_field address => 'https://mojolicious.org', id => 'foo'

Generate C<input> tag of type C<url>. Previous input values will automatically get picked up and shown as default.

  <input name="address" type="url">
  <input name="address" type="url" value="https://mojolicious.org">
  <input id="foo" name="address" type="url" value="https://mojolicious.org">

=head2 week_field

  %= week_field 'vacation'
  %= week_field vacation => '2012-W17'
  %= week_field vacation => '2012-W17', id => 'foo'

Generate C<input> tag of type C<week>. Previous input values will automatically get picked up and shown as default.

  <input name="vacation" type="week">
  <input name="vacation" type="week" value="2012-W17">
  <input id="foo" name="vacation" type="week" value="2012-W17">

=head1 METHODS

L<Mojolicious::Plugin::TagHelpers> inherits all methods from L<Mojolicious::Plugin> and implements the following new
ones.

=head2 register

  $plugin->register(Mojolicious->new);

Register helpers in L<Mojolicious> application.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Plugin::EPLRenderer;
use Mojo::Base 'Mojolicious::Plugin';

use Mojo::Template;
use Mojo::Util qw(encode md5_sum);

sub register {
  my ($self, $app) = @_;
  $app->renderer->add_handler(epl => sub { _render(@_, Mojo::Template->new, $_[1]) });
}

sub _render {
  my ($renderer, $c, $output, $options, $mt, @args) = @_;

  # Cached
  if ($mt->compiled) {
    $c->helpers->log->trace("Rendering cached @{[$mt->name]}");
    $$output = $mt->process(@args);
  }

  # Not cached
  else {
    my $inline = $options->{inline};
    my $name   = defined $inline ? md5_sum encode('UTF-8', $inline) : undef;
    return unless defined($name //= $renderer->template_name($options));

    # Inline
    if (defined $inline) {
      $c->helpers->log->trace(qq{Rendering inline template "$name"});
      $$output = $mt->name(qq{inline template "$name"})->render($inline, @args);
    }

    # File
    else {
      if (my $encoding = $renderer->encoding) { $mt->encoding($encoding) }

      # Try template
      if (defined(my $path = $renderer->template_path($options))) {
        $c->helpers->log->trace(qq{Rendering template "$name"});
        $$output = $mt->name(qq{template "$name"})->render_file($path, @args);
      }

      # Try DATA section
      elsif (defined(my $d = $renderer->get_data_template($options))) {
        $c->helpers->log->trace(qq{Rendering template "$name" from DATA section});
        $$output = $mt->name(qq{template "$name" from DATA section})->render($d, @args);
      }

      # No template
      else { $c->helpers->log->trace(qq{Template "$name" not found}) }
    }
  }

  # Exception
  die $$output if ref $$output;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Plugin::EPLRenderer - Embedded Perl Lite renderer plugin

=head1 SYNOPSIS

  # Mojolicious
  $app->plugin('EPLRenderer');

  # Mojolicious::Lite
  plugin 'EPLRenderer';

=head1 DESCRIPTION

L<Mojolicious::Plugin::EPLRenderer> is a renderer for C<epl> templates, which are pretty much just raw
L<Mojo::Template>.

This is a core plugin, that means it is always enabled and its code a good example for learning to build new plugins,
you're welcome to fork it.

See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available by default.

=head1 METHODS

L<Mojolicious::Plugin::EPLRenderer> inherits all methods from L<Mojolicious::Plugin> and implements the following new
ones.

=head2 register

  $plugin->register(Mojolicious->new);

Register renderer in L<Mojolicious> application.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Plugin::Config;
use Mojo::Base 'Mojolicious::Plugin';

use Mojo::File qw(path);
use Mojo::Util qw(decode);

sub load { $_[0]->parse(decode('UTF-8', path($_[1])->slurp), @_[1, 2, 3]) }

sub parse {
  my ($self, $content, $file, $conf, $app) = @_;

  # Run Perl code in sandbox
  my $config = eval 'package Mojolicious::Plugin::Config::Sandbox; no warnings;'
    . "sub app; local *app = sub { \$app }; use Mojo::Base -strict; $content";
  die qq{Can't load configuration from file "$file": $@} if $@;
  die qq{Configuration file "$file" did not return a hash reference} unless ref $config eq 'HASH';

  return $config;
}

sub register {
  my ($self, $app, $conf) = @_;

  # Override
  return _plugins($app, $app->config) if $app->config->{config_override};

  # Config file
  my $file = $conf->{file} || $ENV{MOJO_CONFIG};
  $file ||= $app->moniker . '.' . ($conf->{ext} || 'conf');

  # Mode specific config file
  my $mode = $file =~ /^(.*)\.([^.]+)$/ ? join('.', $1, $app->mode, $2) : '';

  my $home = $app->home;
  $file = $home->child($file) unless path($file)->is_abs;
  $mode = $home->child($mode) if $mode && !path($mode)->is_abs;
  $mode = undef unless $mode           && -e $mode;

  # Read config file
  my $config = {};
  if (-e $file) { $config = $self->load($file, $conf, $app) }

  # Check for default and mode specific config file
  elsif (!$conf->{default} && !$mode) { die qq{Configuration file "$file" missing, maybe you need to create it?\n} }

  # Merge everything
  $config = {%$config, %{$self->load($mode, $conf, $app)}} if $mode;
  $config = {%{$conf->{default}}, %$config} if $conf->{default};
  return _plugins($app, $app->config($config)->config);
}

sub _plugins {
  my ($app, $config) = @_;

  if (my $plugins = $config->{plugins}) {
    die qq{Configuration value "plugins" is not an array reference} unless ref $plugins eq 'ARRAY';
    for my $plugin (@$plugins) {
      die qq{Configuration value "plugins" contains an entry that is not a hash reference} unless ref $plugin eq 'HASH';
      $app->plugin((keys %$plugin)[0], (values %$plugin)[0]);
    }
  }

  return $app->config;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Plugin::Config - Perl-ish configuration plugin

=head1 SYNOPSIS

  # myapp.conf (it's just Perl returning a hash)
  {
    # Just a value
    foo => "bar",

    # Nested data structures are fine too
    baz => ['â™¥'],

    # You have full access to the application
    music_dir => app->home->child('music')
  };

  # Mojolicious
  my $config = $app->plugin('Config');
  say $config->{foo};

  # Mojolicious::Lite
  my $config = plugin 'Config';
  say $config->{foo};

  # foo.html.ep
  %= config->{foo}

  # The configuration is available application-wide
  my $config = app->config;
  say $config->{foo};

  # Everything can be customized with options
  my $config = plugin Config => {file => '/etc/myapp.stuff'};

=head1 DESCRIPTION

L<Mojolicious::Plugin::Config> is a Perl-ish configuration plugin.

The application object can be accessed via C<$app> or the C<app> function, L<strict>, L<warnings>, L<utf8> and Perl
5.16 L<features|feature> are automatically enabled. A default configuration filename in the application home directory
will be generated from the value of L<Mojolicious/"moniker"> (C<$moniker.conf>). You can extend the normal
configuration file C<$moniker.conf> with C<mode> specific ones like C<$moniker.$mode.conf>, which will be detected
automatically.

These configuration values are currently reserved:

=over 2

=item C<config_override>

If this configuration value has been set in L<Mojolicious/"config"> when this plugin is loaded, it will not do anything
besides loading deployment specific plugins.

=item C<plugins>

  plugins => [{SetUserGroup => {user => 'sri', group => 'staff'}}]

One or more deployment specific plugins that should be loaded right after this plugin has been loaded.

=back

The code of this plugin is a good example for learning to build new plugins, you're welcome to fork it.

See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available by default.

=head1 OPTIONS

L<Mojolicious::Plugin::Config> supports the following options.

=head2 default

  # Mojolicious::Lite
  plugin Config => {default => {foo => 'bar'}};

Default configuration, making configuration files optional.

=head2 ext

  # Mojolicious::Lite
  plugin Config => {ext => 'stuff'};

File extension for generated configuration filenames, defaults to C<conf>.

=head2 file

  # Mojolicious::Lite
  plugin Config => {file => 'myapp.conf'};
  plugin Config => {file => '/etc/foo.stuff'};

Path to configuration file, absolute or relative to the application home directory, defaults to the value of the
C<MOJO_CONFIG> environment variable or C<$moniker.conf> in the application home directory.

=head1 METHODS

L<Mojolicious::Plugin::Config> inherits all methods from L<Mojolicious::Plugin> and implements the following new ones.

=head2 load

  $plugin->load($file, $conf, $app);

Loads configuration file and passes the content to L</"parse">.

  sub load ($self, $file, $conf, $app) {
    ...
    return $self->parse($content, $file, $conf, $app);
  }

=head2 parse

  $plugin->parse($content, $file, $conf, $app);

Parse configuration file.

  sub parse ($self, $content, $file, $conf, $app) {
    ...
    return $hash;
  }

=head2 register

  my $config = $plugin->register(Mojolicious->new);
  my $config = $plugin->register(Mojolicious->new, {file => '/etc/app.conf'});

Register plugin in L<Mojolicious> application and merge configuration.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Plugin::JSONConfig;
use Mojo::Base 'Mojolicious::Plugin::Config';

use Mojo::JSON qw(from_json);
use Mojo::Template;

sub parse {
  my ($self, $content, $file, $conf, $app) = @_;

  my $config = eval { from_json $self->render($content, $file, $conf, $app) };
  die qq{Can't load configuration from file "$file": $@} if $@;
  die qq{Configuration file "$file" did not return a JSON object} unless ref $config eq 'HASH';

  return $config;
}

sub register { shift->SUPER::register(shift, {ext => 'json', %{shift()}}) }

sub render {
  my ($self, $content, $file, $conf, $app) = @_;

  # Application instance and helper
  my $prepend = q[no strict 'refs'; no warnings 'redefine'; my $app = shift; sub app; local *app = sub { $app };]
    . q[use Mojo::Base -strict; no warnings 'ambiguous';];

  my $mt     = Mojo::Template->new($conf->{template} // {})->name($file);
  my $output = $mt->prepend($prepend . $mt->prepend)->render($content, $app);
  return ref $output ? die $output : $output;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Plugin::JSONConfig - JSON configuration plugin

=head1 SYNOPSIS

  # myapp.json (it's just JSON with embedded Perl)
  {
    %# Just a value
    "foo": "bar",

    %# Nested data structures are fine too
    "baz": ["â™¥"],

    %# You have full access to the application
    "music_dir": "<%= app->home->child('music') %>"
  }

  # Mojolicious
  my $config = $app->plugin('JSONConfig');
  say $config->{foo};

  # Mojolicious::Lite
  my $config = plugin 'JSONConfig';
  say $config->{foo};

  # foo.html.ep
  %= config->{foo}

  # The configuration is available application-wide
  my $config = app->config;
  say $config->{foo};

  # Everything can be customized with options
  my $config = plugin JSONConfig => {file => '/etc/myapp.conf'};

=head1 DESCRIPTION

L<Mojolicious::Plugin::JSONConfig> is a JSON configuration plugin that preprocesses its input with L<Mojo::Template>.

The application object can be accessed via C<$app> or the C<app> function. A default configuration filename in the
application home directory will be generated from the value of L<Mojolicious/"moniker"> (C<$moniker.json>). You can
extend the normal configuration file C<$moniker.json> with C<mode> specific ones like C<$moniker.$mode.json>, which
will be detected automatically.

These configuration values are currently reserved:

=over 2

=item C<config_override>

If this configuration value has been set in L<Mojolicious/"config"> when this plugin is loaded, it will not do anything
besides loading deployment specific plugins.

=item C<plugins>

  "plugins": [{"SetUserGroup": {"user": "sri", "group": "staff"}}]

One or more deployment specific plugins that should be loaded right after this plugin has been loaded.

=back

The code of this plugin is a good example for learning to build new plugins, you're welcome to fork it.

See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available by default.

=head1 OPTIONS

L<Mojolicious::Plugin::JSONConfig> inherits all options from L<Mojolicious::Plugin::Config> and supports the following
new ones.

=head2 template

  # Mojolicious::Lite
  plugin JSONConfig => {template => {line_start => '.'}};

Attribute values passed to L<Mojo::Template> object used to preprocess configuration files.

=head1 METHODS

L<Mojolicious::Plugin::JSONConfig> inherits all methods from L<Mojolicious::Plugin::Config> and implements the
following new ones.

=head2 parse

  $plugin->parse($content, $file, $conf, $app);

Process content with L</"render"> and parse it with L<Mojo::JSON>.

  sub parse ($self, $content, $file, $conf, $app) {
    ...
    $content = $self->render($content, $file, $conf, $app);
    ...
    return $hash;
  }

=head2 register

  my $config = $plugin->register(Mojolicious->new);
  my $config = $plugin->register(Mojolicious->new, {file => '/etc/foo.conf'});

Register plugin in L<Mojolicious> application and merge configuration.

=head2 render

  $plugin->render($content, $file, $conf, $app);

Process configuration file with L<Mojo::Template>.

  sub render ($self, $content, $file, $conf, $app) {
    ...
    return $content;
  }

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Plugin::NotYAMLConfig;
use Mojo::Base 'Mojolicious::Plugin::JSONConfig';

use CPAN::Meta::YAML;
use Mojo::Util qw(decode encode);

sub parse {
  my ($self, $content, $file, $conf, $app) = @_;
  my $config = eval { $self->{yaml}->(encode('UTF-8', $self->render($content, $file, $conf, $app))) };
  die qq{Can't load configuration from file "$file": $@} if $@;
  die qq{Configuration file "$file" did not return a YAML mapping} unless ref $config eq 'HASH';
  return $config;
}

sub register {
  my ($self, $app, $conf) = @_;

  $conf->{ext} //= 'yml';
  $self->{yaml} = sub { CPAN::Meta::YAML::Load(decode 'UTF-8', shift) };
  if (my $mod = $conf->{module}) {
    die qq{YAML module $mod has no Load function} unless $self->{yaml} = $mod->can('Load');
  }

  return $self->SUPER::register($app, $conf);
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Plugin::NotYAMLConfig - Not quite YAML configuration plugin

=head1 SYNOPSIS

  # myapp.yml (it's just YAML with embedded Perl)
  ---
  foo: bar
  baz:
    - â™¥
  music_dir: <%= app->home->child('music') %>

  # Mojolicious
  my $config = $app->plugin('NotYAMLConfig');
  say $config->{foo};

  # Mojolicious::Lite
  my $config = plugin 'NotYAMLConfig';
  say $config->{foo};

  # foo.html.ep
  %= config->{foo}

  # The configuration is available application-wide
  my $config = app->config;
  say $config->{foo};

  # Everything can be customized with options
  my $config = plugin NotYAMLConfig => {file => '/etc/myapp.conf'};

=head1 DESCRIPTION

L<Mojolicious::Plugin::NotYAMLConfig> is a YAML configuration plugin that preprocesses its input with L<Mojo::Template>.
By default it uses L<CPAN::Meta::YAML> for parsing, which is not the best YAML module available, but good enough for
most config files. If you need something more correct you can use a different module like L<YAML::XS> with the
L</"module"> option.

The application object can be accessed via C<$app> or the C<app> function. A default configuration filename in the
application home directory will be generated from the value of L<Mojolicious/"moniker"> (C<$moniker.yml>). You can
extend the normal configuration file C<$moniker.yml> with C<mode> specific ones like C<$moniker.$mode.yml>, which will
be detected automatically.

These configuration values are currently reserved:

=over 2

=item C<config_override>

If this configuration value has been set in L<Mojolicious/"config"> when this plugin is loaded, it will not do anything
besides loading deployment specific plugins.

=item C<plugins>

  plugins:
    - SetUserGroup:
        user: sri
        group: staff

One or more deployment specific plugins that should be loaded right after this plugin has been loaded.

=back

The code of this plugin is a good example for learning to build new plugins, you're welcome to fork it.

See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available by default.

=head1 OPTIONS

L<Mojolicious::Plugin::NotYAMLConfig> inherits all options from L<Mojolicious::Plugin::JSONConfig> and supports the
following new ones.

=head2 module

  # Mojolicious::Lite
  plugin NotYAMLConfig => {module => 'YAML::PP'};

Alternative YAML module to use for parsing.

=head1 METHODS

L<Mojolicious::Plugin::NotYAMLConfig> inherits all methods from L<Mojolicious::Plugin::JSONConfig> and implements the
following new ones.

=head2 parse

  $plugin->parse($content, $file, $conf, $app);

Process content with L<Mojolicious::Plugin::JSONConfig/"render"> and parse it with L<CPAN::Meta::YAML>.

  sub parse ($self, $content, $file, $conf, $app) {
    ...
    $content = $self->render($content, $file, $conf, $app);
    ...
    return $hash;
  }

=head2 register

  my $config = $plugin->register(Mojolicious->new);
  my $config = $plugin->register(Mojolicious->new, {file => '/etc/foo.conf'});

Register plugin in L<Mojolicious> application and merge configuration.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Plugin::EPRenderer;
use Mojo::Base 'Mojolicious::Plugin::EPLRenderer';

use Mojo::Template;
use Mojo::Util qw(encode md5_sum monkey_patch);

sub DESTROY { Mojo::Util::_teardown(shift->{namespace}) }

sub register {
  my ($self, $app, $conf) = @_;

  # Auto escape by default to prevent XSS attacks
  my $ep = {auto_escape => 1, %{$conf->{template} // {}}, vars => 1};
  my $ns = $self->{namespace} = $ep->{namespace} //= 'Mojo::Template::Sandbox::' . md5_sum "$self";

  # Make "$self" and "$c" available in templates
  $ep->{prepend} = 'my $self = my $c = _C;' . ($ep->{prepend} // '');

  # Add "ep" handler and make it the default
  $app->renderer->default_handler('ep')->add_handler(
    $conf->{name} || 'ep' => sub {
      my ($renderer, $c, $output, $options) = @_;

      my $name = $options->{inline} // $renderer->template_name($options);
      return unless defined $name;
      my $key = md5_sum encode 'UTF-8', $name;

      my $cache = $renderer->cache;
      my $mt    = $cache->get($key);
      $cache->set($key => $mt = Mojo::Template->new($ep)) unless $mt;

      # Export helpers only once
      ++$self->{helpers} and _helpers($ns, $renderer->helpers) unless $self->{helpers};

      # Make current controller available and render with "epl" handler
      no strict 'refs';
      no warnings 'redefine';
      local *{"${ns}::_C"} = sub {$c};
      Mojolicious::Plugin::EPLRenderer::_render($renderer, $c, $output, $options, $mt, $c->stash);
    }
  );
}

sub _helpers {
  my ($class, $helpers) = @_;
  for my $method (grep {/^\w+$/} keys %$helpers) {
    my $sub = $helpers->{$method};
    monkey_patch $class, $method, sub { $class->_C->$sub(@_) };
  }
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Plugin::EPRenderer - Embedded Perl renderer plugin

=head1 SYNOPSIS

  # Mojolicious
  $app->plugin('EPRenderer');
  $app->plugin(EPRenderer => {name => 'foo'});
  $app->plugin(EPRenderer => {name => 'bar', template => {line_start => '.'}});

  # Mojolicious::Lite
  plugin 'EPRenderer';
  plugin EPRenderer => {name => 'foo'};
  plugin EPRenderer => {name => 'bar', template => {line_start => '.'}};

=head1 DESCRIPTION

L<Mojolicious::Plugin::EPRenderer> is a renderer for Embedded Perl templates. For more information see
L<Mojolicious::Guides::Rendering/"Embedded Perl">.

This is a core plugin, that means it is always enabled and its code a good example for learning to build new plugins,
you're welcome to fork it.

See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available by default.

=head1 OPTIONS

L<Mojolicious::Plugin::EPRenderer> supports the following options.

=head2 name

  # Mojolicious::Lite
  plugin EPRenderer => {name => 'foo'};

Handler name, defaults to C<ep>.

=head2 template

  # Mojolicious::Lite
  plugin EPRenderer => {template => {line_start => '.'}};

Attribute values passed to L<Mojo::Template> objects used to render templates.

=head1 METHODS

L<Mojolicious::Plugin::EPRenderer> inherits all methods from L<Mojolicious::Plugin::EPLRenderer> and implements the
following new ones.

=head2 register

  $plugin->register(Mojolicious->new);
  $plugin->register(Mojolicious->new, {name => 'foo'});

Register renderer in L<Mojolicious> application.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Plugin::Mount;
use Mojo::Base 'Mojolicious::Plugin';

use Mojo::Server;

sub register {
  my ($self, $app, $conf) = @_;

  my $path  = (keys %$conf)[0];
  my $embed = Mojo::Server->new->load_app($conf->{$path})->secrets($app->secrets)->log($app->log);

  # Extract host
  my $host;
  ($host, $path) = ($1 ? qr/^(?:.*\.)?\Q$2\E$/i : qr/^\Q$2\E$/i, $3) if $path =~ m!^(\*\.)?([^/]+)(/.*)?$!;

  my $route = $app->routes->any($path)->partial(1)->to(app => $embed);
  return $host ? $route->requires(host => $host) : $route;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Plugin::Mount - Application mount plugin

=head1 SYNOPSIS

  # Mojolicious
  my $route = $app->plugin(Mount => {'/prefix' => '/home/sri/foo/script/foo'});

  # Mojolicious::Lite
  my $route = plugin Mount => {'/prefix' => '/home/sri/myapp.pl'};

  # Adjust the generated route and mounted application
  my $example = plugin Mount => {'/example' => '/home/sri/example.pl'};
  $example->to(message => 'It works great!');
  my $app = $example->pattern->defaults->{app};
  $app->config(foo => 'bar');
  $app->log(app->log);

  # Mount application with host
  plugin Mount => {'example.com' => '/home/sri/myapp.pl'};

  # Host and path
  plugin Mount => {'example.com/myapp' => '/home/sri/myapp.pl'};

  # Or even hosts with wildcard subdomains
  plugin Mount => {'*.example.com/myapp' => '/home/sri/myapp.pl'};

=head1 DESCRIPTION

L<Mojolicious::Plugin::Mount> is a plugin that allows you to mount whole L<Mojolicious> applications.

The code of this plugin is a good example for learning to build new plugins, you're welcome to fork it.

See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available by default.

=head1 METHODS

L<Mojolicious::Plugin::Mount> inherits all methods from L<Mojolicious::Plugin> and implements the following new ones.

=head2 register

  my $route = $plugin->register(Mojolicious->new, {'/foo' => '/some/app.pl'});

Mount L<Mojolicious> application and return the generated route, which is usually a L<Mojolicious::Routes::Route>
object.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Static;
use Mojo::Base -base;

use Mojo::Asset::File;
use Mojo::Asset::Memory;
use Mojo::Date;
use Mojo::File   qw(curfile path);
use Mojo::Loader qw(data_section file_is_binary);
use Mojo::Util   qw(encode md5_sum trim);

# Bundled files
my $PUBLIC = curfile->sibling('resources', 'public');
my %EXTRA  = $PUBLIC->list_tree->map(sub { join('/', @{$_->to_rel($PUBLIC)}), $_->realpath->to_string })->each;

has asset_dir => 'assets';
has classes   => sub { ['main'] };
has extra     => sub { +{%EXTRA} };
has paths     => sub { [] };

sub asset_path {
  my ($self, $asset) = @_;
  $asset = "/$asset" unless $asset =~ /^\//;
  my $assets = $self->{assets} //= {};
  return '/' . $self->asset_dir . ($assets->{$asset} // $asset);
}

sub dispatch {
  my ($self, $c) = @_;

  # Method (GET or HEAD)
  my $req    = $c->req;
  my $method = $req->method;
  return undef unless $method eq 'GET' || $method eq 'HEAD';

  # Canonical path
  my $stash = $c->stash;
  my $path  = $req->url->path;
  $path = $stash->{path} ? $path->new($stash->{path}) : $path->clone;
  return undef unless my @parts = @{$path->canonicalize->parts};

  # Serve static file and prevent path traversal
  my $canon_path = join '/', @parts;
  return undef if $canon_path =~ /^\.\.\/|\\/ || !$self->serve($c, $canon_path);
  $stash->{'mojo.static'} = 1;

  # Development assets will be rebuilt a lot, do not let browsers cache them
  $c->res->headers->cache_control('no-cache')
    if $c->app->mode eq 'development' && index($canon_path, $self->asset_dir) == 0;

  return !!$c->rendered;
}

sub file {
  my ($self, $rel) = @_;

  $self->warmup unless $self->{index};

  # Search all paths
  my @parts = split /\//, $rel;
  for my $path (@{$self->paths}) {
    next unless my $asset = _get_file(path($path, @parts)->to_string);
    return $asset;
  }

  # Search DATA
  if (my $asset = $self->_get_data_file($rel)) { return $asset }

  # Search extra files
  my $extra = $self->extra;
  return exists $extra->{$rel} ? _get_file($extra->{$rel}) : undef;
}

sub is_fresh {
  my ($self, $c, $options) = @_;

  my $res_headers = $c->res->headers;
  my ($last, $etag) = @$options{qw(last_modified etag)};
  $res_headers->last_modified(Mojo::Date->new($last)->to_string)       if $last;
  $res_headers->etag($etag = ($etag =~ m!^W/"! ? $etag : qq{"$etag"})) if $etag;

  # Unconditional
  my $req_headers = $c->req->headers;
  my $match       = $req_headers->if_none_match;
  return undef unless (my $since = $req_headers->if_modified_since) || $match;

  # If-None-Match
  $etag //= $res_headers->etag // '';
  return undef if $match && !grep { $_ eq $etag || "W/$_" eq $etag } map { trim($_) } split /,/, $match;

  # If-Modified-Since
  return !!$match unless ($last //= $res_headers->last_modified) && $since;
  return _epoch($last) <= (_epoch($since) // 0);
}

sub serve {
  my ($self, $c, $rel) = @_;
  return undef unless my $asset = $self->file($rel);
  $c->app->types->content_type($c, {file => $rel});
  return !!$self->serve_asset($c, $asset);
}

sub serve_asset {
  my ($self, $c, $asset) = @_;

  # Content-Type
  $c->app->types->content_type($c, {file => $asset->path}) if $asset->is_file;

  # Last-Modified and ETag
  my $res = $c->res;
  $res->code(200)->headers->accept_ranges('bytes');
  my $mtime   = $asset->mtime;
  my $options = {etag => md5_sum($mtime), last_modified => $mtime};
  return $res->code(304) if $self->is_fresh($c, $options);

  # Range
  return $res->content->asset($asset) unless my $range = $c->req->headers->range;

  # Not satisfiable
  return $res->code(416) unless my $size = $asset->size;
  return $res->code(416) unless $range =~ /^bytes=(\d+)?-(\d+)?/;
  my ($start, $end) = ($1 // 0, defined $2 && $2 < $size ? $2 : $size - 1);
  return $res->code(416) if $start > $end;

  # Satisfiable
  $res->code(206)->headers->content_length($end - $start + 1)->content_range("bytes $start-$end/$size");
  return $res->content->asset($asset->start_range($start)->end_range($end));
}

sub warmup {
  my $self = shift;

  # DATA sections
  my $index = $self->{index} = {};
  for my $class (reverse @{$self->classes}) { $index->{$_} = $class for keys %{data_section $class} }

  # Static assets
  my $assets    = $self->{assets} = {};
  my $asset_dir = $self->asset_dir;
  for my $path (@{$self->paths}) {
    my $asset_path = path($path, $asset_dir);
    next unless -d $asset_path;

    for my $asset_file ($asset_path->list_tree({recursive => 1})->each) {
      my $parts    = $asset_file->to_rel($asset_path)->to_array;
      my $filename = pop @$parts;
      my $prefix   = join '/', @$parts;

      next unless $filename =~ /^([^.]+)\.([^.]+)\.(.+)$/;
      my $checksum = $2;
      my $short    = $prefix eq '' ? "/$1.$3" : "/$prefix/$1.$3";
      my $long     = '/' . join('/', @$parts, $filename);

      $assets->{$short} = $long if !exists($assets->{$short}) || $checksum eq 'development';
    }
  }
}

sub _epoch { Mojo::Date->new(shift)->epoch }

sub _get_data_file {
  my ($self, $rel) = @_;

  # Protect files without extensions and templates with two extensions
  return undef if $rel !~ /\.\w+$/ || $rel =~ /\.\w+\.\w+$/;

  # Find file
  my @args = ($self->{index}{$rel}, $rel);
  return undef unless defined(my $data = data_section(@args));
  return Mojo::Asset::Memory->new->add_chunk(file_is_binary(@args) ? $data : encode 'UTF-8', $data);
}

sub _get_file {
  my $path = shift;
  no warnings 'newline';
  return -f $path && -r _ ? Mojo::Asset::File->new(path => $path) : undef;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Static - Serve static files

=head1 SYNOPSIS

  use Mojolicious::Static;

  my $static = Mojolicious::Static->new;
  push @{$static->classes}, 'MyApp::Controller::Foo';
  push @{$static->paths}, '/home/sri/public';

=head1 DESCRIPTION

L<Mojolicious::Static> is a static file server with C<Range>, C<If-Modified-Since> and C<If-None-Match> support, based
on L<RFC 7232|https://tools.ietf.org/html/rfc7232> and L<RFC 7233|https://tools.ietf.org/html/rfc7233>.

=head1 ATTRIBUTES

L<Mojolicious::Static> implements the following attributes.

=head2 asset_dir

  my $dir = $static->asset_dir;
  $static = $static->asset_dir('assets');

Subdirectory used for all static assets, defaults to C<assets>.

=head2 classes

  my $classes = $static->classes;
  $static     = $static->classes(['main']);

Classes to use for finding files in C<DATA> sections with L<Mojo::Loader>, first one has the highest precedence,
defaults to C<main>. Only files with exactly one extension will be used, like C<index.html>. Note that for files to be
detected, these classes need to have already been loaded and added before L</"warmup"> is called, which usually happens
automatically during application startup.

  # Add another class with static files in DATA section
  push @{$static->classes}, 'Mojolicious::Plugin::Fun';

  # Add another class with static files in DATA section and higher precedence
  unshift @{$static->classes}, 'Mojolicious::Plugin::MoreFun';

=head2 extra

  my $extra = $static->extra;
  $static   = $static->extra({'foo/bar.txt' => '/home/sri/myapp/bar.txt'});

Paths for extra files to be served from locations other than L</"paths">, such as the images used by the built-in
exception and not found pages. Note that extra files are only served if no better alternative could be found in
L</"paths"> and L</"classes">.

  # Remove built-in favicon
  delete $static->extra->{'favicon.ico'};

=head2 paths

  my $paths = $static->paths;
  $static   = $static->paths(['/home/sri/public']);

Directories to serve static files from, first one has the highest precedence.

  # Add another "public" directory
  push @{$static->paths}, '/home/sri/public';

  # Add another "public" directory with higher precedence
  unshift @{$static->paths}, '/home/sri/themes/blue/public';

=head1 METHODS

L<Mojolicious::Static> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 asset_path

  my $path = $static->asset_path('/app.js');

Get static asset path.

=head2 dispatch

  my $bool = $static->dispatch(Mojolicious::Controller->new);

Serve static file for L<Mojolicious::Controller> object.

=head2 file

  my $asset = $static->file('images/logo.png');
  my $asset = $static->file('../lib/MyApp.pm');

Build L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object for a file, relative to L</"paths"> or from L</"classes">,
or return C<undef> if it doesn't exist. Note that this method uses a relative path, but does not protect from
traversing to parent directories.

  my $content = $static->file('foo/bar.html')->slurp;

=head2 is_fresh

  my $bool = $static->is_fresh(Mojolicious::Controller->new, {etag => 'abc'});
  my $bool = $static->is_fresh(
    Mojolicious::Controller->new, {etag => 'W/"def"'});

Check freshness of request by comparing the C<If-None-Match> and C<If-Modified-Since> request headers to the C<ETag>
and C<Last-Modified> response headers.

These options are currently available:

=over 2

=item etag

  etag => 'abc'
  etag => 'W/"abc"'

Add C<ETag> header before comparing.

=item last_modified

  last_modified => $epoch

Add C<Last-Modified> header before comparing.

=back

=head2 serve

  my $bool = $static->serve(Mojolicious::Controller->new, 'images/logo.png');
  my $bool = $static->serve(Mojolicious::Controller->new, '../lib/MyApp.pm');

Serve a specific file, relative to L</"paths"> or from L</"classes">. Note that this method uses a relative path, but
does not protect from traversing to parent directories.

=head2 serve_asset

  $static->serve_asset(Mojolicious::Controller->new, Mojo::Asset::File->new);

Serve a L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object with C<Range>, C<If-Modified-Since> and C<If-None-Match>
support.

=head2 warmup

  $static->warmup();

Prepare static files from L</"classes"> and static assets for future use.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Command::get;
use Mojo::Base 'Mojolicious::Command';

use Mojo::Collection qw(c);
use Mojo::DOM;
use Mojo::IOLoop;
use Mojo::JSON qw(to_json j);
use Mojo::JSON::Pointer;
use Mojo::URL;
use Mojo::UserAgent;
use Mojo::Util   qw(decode encode getopt);
use Scalar::Util qw(weaken);

has description => 'Perform HTTP request';
has usage       => sub { shift->extract_usage };

sub run {
  my ($self, @args) = @_;

  # Data from STDIN
  vec(my $r = '', fileno(STDIN), 1) = 1;
  my $in = !-t STDIN && select($r, undef, undef, 0) ? join '', <STDIN> : undef;

  my $ua = Mojo::UserAgent->new(ioloop => Mojo::IOLoop->singleton);
  my %form;
  die $self->usage
    unless getopt \@args,
    'C|charset=s'            => \my $charset,
    'c|content=s'            => \$in,
    'f|form=s'               => sub { _form(\%form) if $_[1] =~ /^(.+)=(\@?)(.+)$/ },
    'H|header=s'             => \my @headers,
    'i|inactivity-timeout=i' => sub { $ua->inactivity_timeout($_[1]) },
    'k|insecure'             => sub { $ua->insecure(1) },
    'M|method=s'             => \(my $method = 'GET'),
    'o|connect-timeout=i'    => sub { $ua->connect_timeout($_[1]) },
    'r|redirect'             => \my $redirect,
    'S|response-size=i'      => sub { $ua->max_response_size($_[1]) },
    'u|user=s'               => \my $user,
    'v|verbose'              => \my $verbose;

  @args = map { decode 'UTF-8', $_ } @args;
  die $self->usage unless my $url = shift @args;
  my $selector = shift @args;

  # Parse header pairs
  my %headers = map { /^\s*([^:]+)\s*:\s*(.*+)$/ ? ($1, $2) : () } @headers;

  # Detect proxy for absolute URLs
  $url !~ m!^/! ? $ua->proxy->detect : $ua->server->app($self->app);
  $url = Mojo::URL->new($url)->userinfo($user) if $user;
  $ua->max_redirects(10)                       if $redirect;

  my $buffer = '';
  $ua->on(
    start => sub {
      my ($ua, $tx) = @_;

      # Verbose
      weaken $tx;
      $tx->res->content->on(body => sub { warn _header($tx->req), _header($tx->res) }) if $verbose;

      # Stream content (ignore redirects)
      $tx->res->content->unsubscribe('read')->on(
        read => sub {
          return if $redirect && $tx->res->is_redirect;
          defined $selector ? ($buffer .= pop) : print pop;
        }
      );
    }
  );

  # Switch to verbose for HEAD requests
  $verbose = 1 if $method eq 'HEAD';
  STDOUT->autoflush(1);
  my @content = %form ? (form => \%form) : defined $in ? ($in) : ();
  my $tx      = $ua->start($ua->build_tx($method, $url, \%headers, @content));
  my $res     = $tx->result;

  # JSON Pointer
  return undef unless defined $selector;
  return _json($buffer, $selector) if !length $selector || $selector =~ m!^/!;

  # Selector
  $charset //= $res->content->charset || $res->default_charset;
  _select($buffer, $selector, $charset, @args);
}

sub _form { push @{$_[0]{$1}}, $2 ? {file => $3} : $3 }

sub _header { $_[0]->build_start_line, $_[0]->headers->to_string, "\n\n" }

sub _json {
  return unless my $data = j(shift);
  return unless defined($data = Mojo::JSON::Pointer->new($data)->get(shift));
  _say(ref $data eq 'HASH' || ref $data eq 'ARRAY' ? to_json($data) : $data);
}

sub _say { length && say encode('UTF-8', $_) for @_ }

sub _select {
  my ($buffer, $selector, $charset, @args) = @_;

  # Keep a strong reference to the root
  $buffer = decode($charset, $buffer) // $buffer if $charset;
  my $dom     = Mojo::DOM->new($buffer);
  my $results = $dom->find($selector);

  while (defined(my $command = shift @args)) {

    # Number
    ($results = c($results->[$command])) and next if $command =~ /^\d+$/;

    # Text
    return _say($results->map('text')->each) if $command eq 'text';

    # All text
    return _say($results->map('all_text')->each) if $command eq 'all';

    # Attribute
    return _say($results->map(attr => $args[0] // '')->each) if $command eq 'attr';

    # Unknown
    die qq{Unknown command "$command".\n};
  }

  _say($results->each);
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::get - Get command

=head1 SYNOPSIS

  Usage: APPLICATION get [OPTIONS] URL [SELECTOR|JSON-POINTER] [COMMANDS]

    ./myapp.pl get /
    ./myapp.pl get -H 'Accept: text/html' /hello.html 'head > title' text
    ./myapp.pl get //sri:secr3t@/secrets.json /1/content
    mojo get mojolicious.org
    mojo get -v -r -o 25 -i 50 google.com
    mojo get -v -H 'Host: mojolicious.org' -H 'Accept: */*' mojolicious.org
    mojo get -u 'sri:s3cret' https://mojolicious.org
    mojo get mojolicious.org > example.html
    mojo get -M PUT mojolicious.org < example.html
    mojo get -f 'q=Mojolicious' -f 'size=5' https://metacpan.org/search
    mojo get -M POST -f 'upload=@example.html' mojolicious.org
    mojo get mojolicious.org 'head > title' text
    mojo get mojolicious.org .footer all
    mojo get mojolicious.org a attr href
    mojo get mojolicious.org '*' attr id
    mojo get mojolicious.org 'h1, h2, h3' 3 text
    mojo get https://fastapi.metacpan.org/v1/author/SRI /name
    mojo get -H 'Host: example.com' http+unix://%2Ftmp%2Fmyapp.sock/index.html

  Options:
    -C, --charset <charset>              Charset of HTML/XML content, defaults
                                         to auto-detection
    -c, --content <content>              Content to send with request
    -f, --form <name=value>              One or more form values and file
                                         uploads
    -H, --header <name:value>            One or more additional HTTP headers
    -h, --help                           Show this summary of available options
        --home <path>                    Path to home directory of your
                                         application, defaults to the value of
                                         MOJO_HOME or auto-detection
    -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                         value of MOJO_INACTIVITY_TIMEOUT or 40
    -k, --insecure                       Do not require a valid TLS certificate
                                         to access HTTPS sites
    -M, --method <method>                HTTP method to use, defaults to "GET"
    -m, --mode <name>                    Operating mode for your application,
                                         defaults to the value of
                                         MOJO_MODE/PLACK_ENV or "development"
    -o, --connect-timeout <seconds>      Connect timeout, defaults to the value
                                         of MOJO_CONNECT_TIMEOUT or 10
    -r, --redirect                       Follow up to 10 redirects
    -S, --response-size <size>           Maximum response size in bytes,
                                         defaults to 2147483648 (2GiB)
    -u, --user <userinfo>                Alternate mechanism for specifying
                                         colon-separated username and password
    -v, --verbose                        Print request and response headers to
                                         STDERR

=head1 DESCRIPTION

L<Mojolicious::Command::get> performs requests to remote hosts or local applications.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::get> inherits all attributes from L<Mojolicious::Command> and implements the following new
ones.

=head2 description

  my $description = $get->description;
  $get            = $get->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $get->usage;
  $get      = $get->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::get> inherits all methods from L<Mojolicious::Command> and implements the following new ones.

=head2 run

  $get->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Command::psgi;
use Mojo::Base 'Mojolicious::Command';

use Mojo::Server::PSGI;

has description => 'Start application with PSGI';
has usage       => sub { shift->extract_usage };

sub run { Mojo::Server::PSGI->new(app => shift->app)->to_psgi_app }

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::psgi - PSGI command

=head1 SYNOPSIS

  Usage: APPLICATION psgi [OPTIONS]

    ./myapp.pl psgi

  Options:
    -h, --help          Show this summary of available options
        --home <path>   Path to home directory of your application, defaults to
                        the value of MOJO_HOME or auto-detection
    -m, --mode <name>   Operating mode for your application, defaults to the
                        value of MOJO_MODE/PLACK_ENV or "development"

=head1 DESCRIPTION

L<Mojolicious::Command::psgi> starts applications with the L<Mojo::Server::PSGI> backend.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::psgi> inherits all attributes from L<Mojolicious::Command> and implements the following new
ones.

=head2 description

  my $description = $psgi->description;
  $psgi           = $psgi->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $psgi->usage;
  $psgi     = $psgi->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::psgi> inherits all methods from L<Mojolicious::Command> and implements the following new ones.

=head2 run

  my $app = $psgi->run;

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Command::eval;
use Mojo::Base 'Mojolicious::Command';

use Mojo::Promise;
use Mojo::Util qw(getopt);

has description => 'Run code against application';
has usage       => sub { shift->extract_usage };

sub run {
  my ($self, @args) = @_;

  die $self->usage unless getopt \@args, 'v|verbose' => \my $v1, 'V' => \my $v2;
  my $code = shift @args || '';

  # Run code against application
  my $app    = $self->app;
  my $result = eval "package main; no warnings 'redefine'; sub app; local *app = sub { \$app }; $code";
  die $@ if $@;

  # Handle promises
  my $err;
  Mojo::Promise->resolve($result)->then(sub { $result = shift }, sub { $err = shift })->wait;
  die $err if $err;

  return $result unless defined $result && ($v1 || $v2);
  $v2 ? print($app->dumper($result)) : say $result;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::eval - Eval command

=head1 SYNOPSIS

  Usage: APPLICATION eval [OPTIONS] CODE

    ./myapp.pl eval 'say app->ua->get("/")->result->body'
    ./myapp.pl eval 'say for sort keys %{app->renderer->helpers}'
    ./myapp.pl eval -v 'app->home'
    ./myapp.pl eval -V 'app->renderer->paths'

  Options:
    -h, --help          Show this summary of available options
        --home <path>   Path to home directory of your application, defaults to
                        the value of MOJO_HOME or auto-detection
    -m, --mode <name>   Operating mode for your application, defaults to the
                        value of MOJO_MODE/PLACK_ENV or "development"
    -v, --verbose       Print return value to STDOUT
    -V                  Print returned data structure to STDOUT

=head1 DESCRIPTION

L<Mojolicious::Command::eval> runs code against applications. If the result is a promise (then-able), it will wait
until the promise is fulfilled or rejected and the result is returned.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::eval> inherits all attributes from L<Mojolicious::Command> and implements the following new
ones.

=head2 description

  my $description = $eval->description;
  $eval           = $eval->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $eval->usage;
  $eval     = $eval->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::eval> inherits all methods from L<Mojolicious::Command> and implements the following new ones.

=head2 run

  $eval->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Command::cgi;
use Mojo::Base 'Mojolicious::Command';

use Mojo::Server::CGI;
use Mojo::Util qw(getopt);

has description => 'Start application with CGI';
has usage       => sub { shift->extract_usage };

sub run {
  my ($self, @args) = @_;
  die $self->usage unless getopt \@args, nph => \(my $nph = 0);
  Mojo::Server::CGI->new(app => $self->app, nph => $nph)->run;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::cgi - CGI command

=head1 SYNOPSIS

  Usage: APPLICATION cgi [OPTIONS]

    ./myapp.pl cgi

  Options:
    -h, --help          Show this summary of available options
        --home <path>   Path to home directory of your application, defaults to
                        the value of MOJO_HOME or auto-detection
    -m, --mode <name>   Operating mode for your application, defaults to the
                        value of MOJO_MODE/PLACK_ENV or "development"
        --nph           Enable non-parsed-header mode

=head1 DESCRIPTION

L<Mojolicious::Command::cgi> starts applications with the L<Mojo::Server::CGI> backend.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::cgi> inherits all attributes from L<Mojolicious::Command> and implements the following new
ones.

=head2 description

  my $description = $cgi->description;
  $cgi            = $cgi->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $cgi->usage;
  $cgi      = $cgi->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::cgi> inherits all methods from L<Mojolicious::Command> and implements the following new ones.

=head2 run

  $cgi->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Command::routes;
use Mojo::Base 'Mojolicious::Command';

use re         qw(regexp_pattern);
use Mojo::Util qw(encode getopt tablify);

has description => 'Show available routes';
has usage       => sub { shift->extract_usage };

sub run {
  my ($self, @args) = @_;

  die $self->usage unless getopt \@args, 'v|verbose' => \my $verbose;

  my $rows = [];
  _walk($_, 0, $rows, $verbose) for @{$self->app->routes->children};
  print encode('UTF-8', tablify($rows));
}

sub _walk {
  my ($route, $depth, $rows, $verbose) = @_;

  # Pattern
  my $prefix = '';
  if (my $i = $depth * 2) { $prefix .= ' ' x $i . '+' }
  push @$rows, my $row = [$prefix . ($route->pattern->unparsed || '/')];

  # Flags
  my @flags;
  push @flags, @{$route->requires // []} ? 'C' : '.';
  push @flags, (my $partial = $route->partial) ? 'P' : '.';
  push @flags, $route->inline       ? 'U' : '.';
  push @flags, $route->is_websocket ? 'W' : '.';
  push @$row,  join('', @flags) if $verbose;

  # Methods
  my $methods = $route->methods;
  push @$row, !$methods ? '*' : uc join ',', @$methods;

  # Name
  my $name = $route->name;
  push @$row, $route->has_custom_name ? qq{"$name"} : $name;

  # Regex (verbose)
  my $pattern = $route->pattern;
  $pattern->match('/', $route->is_endpoint && !$partial);
  push @$row, (regexp_pattern $pattern->regex)[0] if $verbose;

  $depth++;
  _walk($_, $depth, $rows, $verbose) for @{$route->children};
  $depth--;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::routes - Routes command

=head1 SYNOPSIS

  Usage: APPLICATION routes [OPTIONS]

    ./myapp.pl routes
    ./myapp.pl routes -v

  Options:
    -h, --help          Show this summary of available options
        --home <path>   Path to home directory of your application, defaults to
                        the value of MOJO_HOME or auto-detection
    -m, --mode <name>   Operating mode for your application, defaults to the
                        value of MOJO_MODE/PLACK_ENV or "development"
    -v, --verbose       Print additional details about routes, flags indicate
                        C=Conditions, P=Partial, U=Under and W=WebSocket

=head1 DESCRIPTION

L<Mojolicious::Command::routes> lists all your application routes.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::routes> inherits all attributes from L<Mojolicious::Command> and implements the following new
ones.

=head2 description

  my $description = $routes->description;
  $routes         = $routes->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $routes->usage;
  $routes   = $routes->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::routes> inherits all methods from L<Mojolicious::Command> and implements the following new
ones.

=head2 run

  $routes->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Command::daemon;
use Mojo::Base 'Mojolicious::Command';

use Mojo::Server::Daemon;
use Mojo::Util qw(getopt);

has description => 'Start application with HTTP and WebSocket server';
has usage       => sub { shift->extract_usage };

sub build_server {
  my ($self, @args) = @_;

  my $daemon = Mojo::Server::Daemon->new(app => $self->app);
  die $self->usage
    unless getopt \@args,
    'b|backlog=i'            => sub { $daemon->backlog($_[1]) },
    'c|clients=i'            => sub { $daemon->max_clients($_[1]) },
    'i|inactivity-timeout=i' => sub { $daemon->inactivity_timeout($_[1]) },
    'k|keep-alive-timeout=i' => sub { $daemon->keep_alive_timeout($_[1]) },
    'l|listen=s'             => \my @listen,
    'p|proxy:s'              => \my @proxy,
    'r|requests=i'           => sub { $daemon->max_requests($_[1]) };

  $daemon->listen(\@listen) if @listen;
  $daemon->reverse_proxy(1) if @proxy;
  my @trusted = grep {length} @proxy;
  $daemon->trusted_proxies(\@trusted) if @trusted;
  return $daemon;
}

sub run { shift->build_server(@_)->run }

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::daemon - Daemon command

=head1 SYNOPSIS

  Usage: APPLICATION daemon [OPTIONS]

    ./myapp.pl daemon
    ./myapp.pl daemon -m production -p -l http://*:8080
    ./myapp.pl daemon -l http://127.0.0.1:8080 -l https://[::]:8081
    ./myapp.pl daemon -l 'https://*:443?cert=./server.crt&key=./server.key'
    ./myapp.pl daemon -l http+unix://%2Ftmp%2Fmyapp.sock
    ./myapp.pl daemon -l http://127.0.0.1:8080 -p 127.0.0.0/8 -p fc00::/7

  Options:
    -b, --backlog <size>                 Listen backlog size, defaults to
                                         SOMAXCONN
    -c, --clients <number>               Maximum number of concurrent
                                         connections, defaults to 1000
    -h, --help                           Show this summary of available options
        --home <path>                    Path to home directory of your
                                         application, defaults to the value of
                                         MOJO_HOME or auto-detection
    -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                         value of MOJO_INACTIVITY_TIMEOUT or 30
    -k, --keep-alive-timeout <seconds>   Keep-alive timeout, defaults to the
                                         value of MOJO_KEEP_ALIVE_TIMEOUT or 5
    -l, --listen <location>              One or more locations you want to
                                         listen on, defaults to the value of
                                         MOJO_LISTEN or "http://*:3000"
    -m, --mode <name>                    Operating mode for your application,
                                         defaults to the value of
                                         MOJO_MODE/PLACK_ENV or "development"
    -p, --proxy [<network>]              Activate reverse proxy support,
                                         defaults to the value of
                                         MOJO_REVERSE_PROXY, optionally takes
                                         one or more trusted proxy addresses or
                                         networks
    -r, --requests <number>              Maximum number of requests per
                                         keep-alive connection, defaults to 100

=head1 DESCRIPTION

L<Mojolicious::Command::daemon> starts applications with the L<Mojo::Server::Daemon> backend.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::daemon> inherits all attributes from L<Mojolicious::Command> and implements the following new
ones.

=head2 description

  my $description = $daemon->description;
  $daemon         = $daemon->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $daemon->usage;
  $daemon   = $daemon->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::daemon> inherits all methods from L<Mojolicious::Command> and implements the following new
ones.

=head2 build_server

  my $server = $daemon->build_server(@ARGV);

Build L<Mojo::Server::Daemon> instance from command line arguments.

=head2 run

  $daemon->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Command::Author::generate;
use Mojo::Base 'Mojolicious::Commands';

has description => 'Generate files and directories from templates';
has hint        => <<EOF;

See 'APPLICATION generate help GENERATOR' for more information on a specific
generator.
EOF
has message    => sub { shift->extract_usage . "\nGenerators:\n" };
has namespaces => sub { ['Mojolicious::Command::Author::generate'] };

sub help { shift->run(@_) }

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::Author::generate - Generator command

=head1 SYNOPSIS

  Usage: APPLICATION generate GENERATOR [OPTIONS]

    mojo generate app
    mojo generate lite-app

=head1 DESCRIPTION

L<Mojolicious::Command::Author::generate> lists available generators.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::Author::generate> inherits all attributes from L<Mojolicious::Commands> and implements the
following new ones.

=head2 description

  my $description = $generator->description;
  $generator      = $generator->description('Foo');

Short description of this command, used for the command list.

=head2 hint

  my $hint   = $generator->hint;
  $generator = $generator->hint('Foo');

Short hint shown after listing available generator commands.

=head2 message

  my $msg    = $generator->message;
  $generator = $generator->message('Bar');

Short usage message shown before listing available generator commands.

=head2 namespaces

  my $namespaces = $generator->namespaces;
  $generator     = $generator->namespaces(['MyApp::Command::generate']);

Namespaces to search for available generator commands, defaults to L<Mojolicious::Command::Author::generate>.

=head1 METHODS

L<Mojolicious::Command::Author::generate> inherits all methods from L<Mojolicious::Commands> and implements the
following new ones.

=head2 help

  $generator->help('app');

Print usage information for generator command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Command::Author::inflate;
use Mojo::Base 'Mojolicious::Command';

use Mojo::Loader qw(data_section file_is_binary);
use Mojo::Util   qw(encode);

has description => 'Inflate embedded files to real files';
has usage       => sub { shift->extract_usage };

sub run {
  my $self = shift;

  # Find all embedded files
  my %all;
  my $app = $self->app;
  for my $class (@{$app->renderer->classes}, @{$app->static->classes}) {
    for my $name (keys %{data_section $class}) {
      my $data = data_section $class, $name;
      $data       = encode 'UTF-8', $data unless file_is_binary $class, $name;
      $all{$name} = $data;
    }
  }

  # Turn them into real files
  for my $name (grep {/\.\w+$/} keys %all) {
    my $prefix = $name =~ /\.\w+\.\w+$/ ? 'templates' : 'public';
    $self->write_file($self->rel_file("$prefix/$name"), $all{$name});
  }
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::Author::inflate - Inflate command

=head1 SYNOPSIS

  Usage: APPLICATION inflate [OPTIONS]

    ./myapp.pl inflate

  Options:
    -h, --help          Show this summary of available options
        --home <path>   Path to home directory of your application, defaults to
                        the value of MOJO_HOME or auto-detection
    -m, --mode <name>   Operating mode for your application, defaults to the
                        value of MOJO_MODE/PLACK_ENV or "development"

=head1 DESCRIPTION

L<Mojolicious::Command::Author::inflate> turns templates and static files embedded in the C<DATA> sections of your
application into real files.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::Author::inflate> inherits all attributes from L<Mojolicious::Command> and implements the
following new ones.

=head2 description

  my $description = $inflate->description;
  $inflate        = $inflate->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $inflate->usage;
  $inflate  = $inflate->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::Author::inflate> inherits all methods from L<Mojolicious::Command> and implements the following
new ones.

=head2 run

  $inflate->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Command::Author::generate::lite_app;
use Mojo::Base 'Mojolicious::Command';

has description => 'Generate Mojolicious::Lite application';
has usage       => sub { shift->extract_usage };

sub run {
  my ($self, $name) = (shift, shift || 'myapp.pl');
  $self->render_to_rel_file('liteapp', $name);
  $self->chmod_rel_file($name, 0744);
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::Author::generate::lite_app - Lite app generator command

=head1 SYNOPSIS

  Usage: APPLICATION generate lite-app [OPTIONS] [NAME]

    mojo generate lite-app
    mojo generate lite-app foo.pl

  Options:
    -h, --help   Show this summary of available options

=head1 DESCRIPTION

L<Mojolicious::Command::Author::generate::lite_app> generate fully functional L<Mojolicious::Lite> applications.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::Author::generate::lite_app> inherits all attributes from L<Mojolicious::Command> and implements
the following new ones.

=head2 description

  my $description = $app->description;
  $app            = $app->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $app->usage;
  $app      = $app->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::Author::generate::lite_app> inherits all methods from L<Mojolicious::Command> and implements
the following new ones.

=head2 run

  $app->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut

package Mojolicious::Command::Author::generate::plugin;
use Mojo::Base 'Mojolicious::Command';

use Mojo::Util qw(camelize class_to_path getopt);

has description => 'Generate Mojolicious plugin directory structure';
has usage       => sub { shift->extract_usage };

sub run {
  my ($self, @args) = @_;

  die $self->usage unless getopt \@args, 'f|full' => \(my $full);

  # Class
  my $name  = $args[0] // 'MyPlugin';
  my $class = $full ? $name : "Mojolicious::Plugin::$name";
  my $dir   = join '-', split(/::/, $class);
  my $app   = class_to_path $class;
  $self->render_to_rel_file('class', "$dir/lib/$app", {class => $class, name => $name});

  # Test
  $self->render_to_rel_file('test', "$dir/t/basic.t", {name => $name});

  # Makefile
  $self->render_to_rel_file('makefile', "$dir/Makefile.PL", {class => $class, path => $app});
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::Author::generate::plugin - Plugin generator command

=head1 SYNOPSIS

  Usage: APPLICATION generate plugin [OPTIONS] [NAME]

    mojo generate plugin
    mojo generate plugin TestPlugin
    mojo generate plugin -f MyApp::Plugin::AwesomeFeature

  Options:
    -f, --full   Do not prepend "Mojolicious::Plugin::" to the plugin name
    -h, --help   Show this summary of available options

=head1 DESCRIPTION

L<Mojolicious::Command::Author::generate::plugin> generates directory structures for fully functional L<Mojolicious>
plugins.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::Author::generate::plugin> inherits all attributes from L<Mojolicious::Command> and implements
the following new ones.

=head2 description

  my $description = $plugin->description;
  $plugin         = $plugin->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $plugin->usage;
  $plugin   = $plugin->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::Author::generate::plugin> inherits all methods from L<Mojolicious::Command> and implements the
following new ones.

=head2 run

  $plugin->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut

package Mojolicious::Command::Author::generate::makefile;
use Mojo::Base 'Mojolicious::Command';

has description => 'Generate "Makefile.PL"';
has usage       => sub { shift->extract_usage };

sub run { shift->render_to_rel_file('makefile', 'Makefile.PL') }

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::Author::generate::makefile - Makefile generator command

=head1 SYNOPSIS

  Usage: APPLICATION generate makefile [OPTIONS]

    ./myapp.pl generate makefile
    mojo generate makefile

  Options:
    -h, --help   Show this summary of available options

=head1 DESCRIPTION

L<Mojolicious::Command::Author::generate::makefile> generates C<Makefile.PL> files for applications.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::Author::generate::makefile> inherits all attributes from L<Mojolicious::Command> and implements
the following new ones.

=head2 description

  my $description = $makefile->description;
  $makefile       = $makefile->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $makefile->usage;
  $makefile = $makefile->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::Author::generate::makefile> inherits all methods from L<Mojolicious::Command> and implements
the following new ones.

=head2 run

  $makefile->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut

package Mojolicious::Command::Author::generate::app;
use Mojo::Base 'Mojolicious::Command';

use Mojo::Util qw(class_to_file class_to_path decamelize);

has description => 'Generate Mojolicious application directory structure';
has usage       => sub { shift->extract_usage };

sub run {
  my ($self, $class) = (shift, shift || 'MyApp');

  # Script
  my $name = class_to_file $class;
  $self->render_to_rel_file('mojo', "$name/script/$name", {class => $class});
  $self->chmod_rel_file("$name/script/$name", 0744);

  # Application class
  my $app = class_to_path $class;
  $self->render_to_rel_file('appclass', "$name/lib/$app", {class => $class});

  # Config file (using the default moniker)
  $self->render_to_rel_file('config', "$name/@{[decamelize $class]}.yml");

  # Controller
  my $controller = "${class}::Controller::Example";
  my $path       = class_to_path $controller;
  $self->render_to_rel_file('controller', "$name/lib/$path", {class => $controller});

  # Test
  $self->render_to_rel_file('test', "$name/t/basic.t", {class => $class});

  # Static file
  $self->render_to_rel_file('static', "$name/public/index.html");
  $self->create_dir("$name/public/assets");

  # Templates
  $self->render_to_rel_file('layout',  "$name/templates/layouts/default.html.ep");
  $self->render_to_rel_file('welcome', "$name/templates/example/welcome.html.ep");
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::Author::generate::app - App generator command

=head1 SYNOPSIS

  Usage: APPLICATION generate app [OPTIONS] [NAME]

    mojo generate app
    mojo generate app TestApp
    mojo generate app My::TestApp

  Options:
    -h, --help   Show this summary of available options

=head1 DESCRIPTION

L<Mojolicious::Command::Author::generate::app> generates application directory structures for fully functional
L<Mojolicious> applications.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::Author::generate::app> inherits all attributes from L<Mojolicious::Command> and implements the
following new ones.

=head2 description

  my $description = $app->description;
  $app            = $app->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $app->usage;
  $app      = $app->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::Author::generate::app> inherits all methods from L<Mojolicious::Command> and implements the
following new ones.

=head2 run

  $app->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut

package Mojolicious::Command::Author::generate::dockerfile;
use Mojo::Base 'Mojolicious::Command';

use Mojo::File qw(path);

has description => 'Generate "Dockerfile"';
has usage       => sub { shift->extract_usage };

sub run {
  my $self = shift;
  my $name = $self->app->moniker;
  my $exe  = $ENV{MOJO_EXE} ? path($ENV{MOJO_EXE})->to_rel($self->app->home)->to_string : "script/$name";
  $self->render_to_rel_file('dockerfile', 'Dockerfile', {name => $name, cmd => "./$exe prefork"});
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::Author::generate::dockerfile - Dockerfile generator command

=head1 SYNOPSIS

  Usage: APPLICATION generate dockerfile [OPTIONS]

    ./myapp.pl generate dockerfile
    ./script/my_app generate dockerfile

  Options:
    -h, --help   Show this summary of available options

=head1 DESCRIPTION

L<Mojolicious::Command::Author::generate::dockerfile> generates C<Dockerfile> for applications.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::Author::generate::dockerfile> inherits all attributes from L<Mojolicious::Command> and
implements the following new ones.

=head2 description

  my $description = $dockerfile->description;
  $dockerfile     = $dockerfile->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage   = $dockerfile->usage;
  $dockerfile = $dockerfile->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::Author::generate::dockerfile> inherits all methods from L<Mojolicious::Command> and implements
the following new ones.

=head2 run

  $dockerfile->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut

package Mojolicious::Command::Author::cpanify;
use Mojo::Base 'Mojolicious::Command';

use Mojo::File qw(path);
use Mojo::Util qw(getopt);

has description => 'Upload distribution to CPAN';
has usage       => sub { shift->extract_usage };

sub run {
  my ($self, @args) = @_;

  die $self->usage unless getopt \@args,
    'p|password=s' => \(my $password = ''),
    'u|user=s'     => \(my $user     = '');
  die $self->usage unless my $file = shift @args;

  my $tx = $self->app->ua->tap(sub { $_->proxy->detect })->post(
    "https://$user:$password\@pause.perl.org/pause/authenquery" => form => {
      HIDDENNAME                        => $user,
      CAN_MULTIPART                     => 1,
      pause99_add_uri_upload            => path($file)->basename,
      SUBMIT_pause99_add_uri_httpupload => ' Upload this file from my disk ',
      pause99_add_uri_uri               => '',
      pause99_add_uri_httpupload        => {file => $file},
    }
  );

  if (my $err = $tx->error) {
    my $code = $tx->res->code // 0;
    my $msg  = $err->{message};
    if    ($code == 401) { $msg = 'Wrong username or password.' }
    elsif ($code == 409) { $msg = 'File already exists on CPAN.' }
    die qq{Problem uploading file "$file": $msg\n};
  }

  say 'Upload successful!';
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::Author::cpanify - CPAN-ify command

=head1 SYNOPSIS

  Usage: APPLICATION cpanify [OPTIONS] [FILE]

    mojo cpanify -u sri -p secr3t Mojolicious-Plugin-MyPlugin-0.01.tar.gz

  Options:
    -h, --help                  Show this summary of available options
    -p, --password <password>   PAUSE password
    -u, --user <name>           PAUSE username

=head1 DESCRIPTION

L<Mojolicious::Command::Author::cpanify> uploads files to CPAN.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::Author::cpanify> inherits all attributes from L<Mojolicious::Command> and implements the
following new ones.

=head2 description

  my $description = $cpanify->description;
  $cpanify        = $cpanify->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $cpanify->usage;
  $cpanify  = $cpanify->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::Author::cpanify> inherits all methods from L<Mojolicious::Command> and implements the following
new ones.

=head2 run

  $cpanify->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Command::prefork;
use Mojo::Base 'Mojolicious::Command';

use Mojo::Server::Prefork;
use Mojo::Util qw(getopt);

has description => 'Start application with pre-forking HTTP and WebSocket server';
has usage       => sub { shift->extract_usage };

sub build_server {
  my ($self, @args) = @_;

  my $prefork = Mojo::Server::Prefork->new(app => $self->app);
  die $self->usage
    unless getopt \@args,
    'a|accepts=i'            => sub { $prefork->accepts($_[1]) },
    'b|backlog=i'            => sub { $prefork->backlog($_[1]) },
    'c|clients=i'            => sub { $prefork->max_clients($_[1]) },
    'G|graceful-timeout=i'   => sub { $prefork->graceful_timeout($_[1]) },
    'I|heartbeat-interval=i' => sub { $prefork->heartbeat_interval($_[1]) },
    'H|heartbeat-timeout=i'  => sub { $prefork->heartbeat_timeout($_[1]) },
    'i|inactivity-timeout=i' => sub { $prefork->inactivity_timeout($_[1]) },
    'k|keep-alive-timeout=i' => sub { $prefork->keep_alive_timeout($_[1]) },
    'l|listen=s'             => \my @listen,
    'P|pid-file=s'           => sub { $prefork->pid_file($_[1]) },
    'p|proxy:s'              => \my @proxy,
    'r|requests=i'           => sub { $prefork->max_requests($_[1]) },
    's|spare=i'              => sub { $prefork->spare($_[1]) },
    'w|workers=i'            => sub { $prefork->workers($_[1]) };

  $prefork->listen(\@listen) if @listen;
  $prefork->reverse_proxy(1) if @proxy;
  my @trusted = grep {length} @proxy;
  $prefork->trusted_proxies(\@trusted) if @trusted;
  return $prefork;
}

sub run { shift->build_server(@_)->run }

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::prefork - Pre-fork command

=head1 SYNOPSIS

  Usage: APPLICATION prefork [OPTIONS]

    ./myapp.pl prefork
    ./myapp.pl prefork -m production -p -l http://*:8080
    ./myapp.pl prefork -l http://127.0.0.1:8080 -l https://[::]:8081
    ./myapp.pl prefork -l 'https://*:443?cert=./server.crt&key=./server.key'
    ./myapp.pl prefork -l http+unix://%2Ftmp%2Fmyapp.sock -w 12
    ./myapp.pl prefork -l http://127.0.0.1:8080 -p 127.0.0.0/8 -p fc00::/7

  Options:
    -a, --accepts <number>               Number of connections for workers to
                                         accept, defaults to 10000
    -b, --backlog <size>                 Listen backlog size, defaults to
                                         SOMAXCONN
    -c, --clients <number>               Maximum number of concurrent
                                         connections, defaults to 1000
    -G, --graceful-timeout <seconds>     Graceful timeout, defaults to 120.
    -I, --heartbeat-interval <seconds>   Heartbeat interval, defaults to 5
    -H, --heartbeat-timeout <seconds>    Heartbeat timeout, defaults to 50
    -h, --help                           Show this summary of available options
        --home <path>                    Path to home directory of your
                                         application, defaults to the value of
                                         MOJO_HOME or auto-detection
    -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                         value of MOJO_INACTIVITY_TIMEOUT or 30
    -k, --keep-alive-timeout <seconds>   Keep-alive timeout, defaults to the
                                         value of MOJO_KEEP_ALIVE_TIMEOUT or 5
    -l, --listen <location>              One or more locations you want to
                                         listen on, defaults to the value of
                                         MOJO_LISTEN or "http://*:3000"
    -m, --mode <name>                    Operating mode for your application,
                                         defaults to the value of
                                         MOJO_MODE/PLACK_ENV or "development"
    -P, --pid-file <path>                Path to process id file, defaults to
                                         "prefork.pid" in a temporary directory
    -p, --proxy [<network>]              Activate reverse proxy support,
                                         defaults to the value of
                                         MOJO_REVERSE_PROXY, optionally takes
                                         one or more trusted proxy addresses or
                                         networks
    -r, --requests <number>              Maximum number of requests per
                                         keep-alive connection, defaults to 100
    -s, --spare <number>                 Temporarily spawn up to this number of
                                         additional workers, defaults to 2
    -w, --workers <number>               Number of workers, defaults to 4

=head1 DESCRIPTION

L<Mojolicious::Command::prefork> starts applications with the L<Mojo::Server::Prefork> backend.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::prefork> inherits all attributes from L<Mojolicious::Command> and implements the following new
ones.

=head2 description

  my $description = $prefork->description;
  $prefork        = $prefork->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $prefork->usage;
  $prefork  = $prefork->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::prefork> inherits all methods from L<Mojolicious::Command> and implements the following new
ones.

=head2 build_server

  my $server = $daemon->build_server(@ARGV);

Build L<Mojo::Server::Prefork> instance from command line arguments.

=head2 run

  $prefork->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Command::version;
use Mojo::Base 'Mojolicious::Command';

use Mojo::IOLoop::Client;
use Mojo::IOLoop::TLS;
use Mojo::JSON;
use Mojolicious;

has description => 'Show versions of available modules';
has usage       => sub { shift->extract_usage };

sub run {
  my $self = shift;

  my $json  = Mojo::JSON->JSON_XS                   ? $Cpanel::JSON::XS::VERSION   : 'n/a';
  my $ev    = eval { require Mojo::Reactor::EV; 1 } ? $EV::VERSION                 : 'n/a';
  my $socks = Mojo::IOLoop::Client->can_socks       ? $IO::Socket::Socks::VERSION  : 'n/a';
  my $tls   = Mojo::IOLoop::TLS->can_tls            ? $IO::Socket::SSL::VERSION    : 'n/a';
  my $nnr   = Mojo::IOLoop::Client->can_nnr         ? $Net::DNS::Native::VERSION   : 'n/a';
  my $roles = Mojo::Base->ROLES                     ? $Role::Tiny::VERSION         : 'n/a';
  my $async = Mojo::Base->ASYNC                     ? $Future::AsyncAwait::VERSION : 'n/a';

  print <<EOF;
CORE
  Perl        ($^V, $^O)
  Mojolicious ($Mojolicious::VERSION, $Mojolicious::CODENAME)

OPTIONAL
  Cpanel::JSON::XS 4.09+   ($json)
  EV 4.32+                 ($ev)
  IO::Socket::Socks 0.64+  ($socks)
  IO::Socket::SSL 2.009+   ($tls)
  Net::DNS::Native 0.15+   ($nnr)
  Role::Tiny 2.000001+     ($roles)
  Future::AsyncAwait 0.52+ ($async)

EOF

  # Check latest version on CPAN
  my $latest = eval {
    $self->app->ua->max_redirects(10)->tap(sub { $_->proxy->detect })
      ->get('fastapi.metacpan.org/v1/release/Mojolicious')->result->json->{version};
  } or return;

  my $msg = 'This version is up to date, have fun!';
  $msg = 'Thanks for testing a development release, you are awesome!' if $latest < $Mojolicious::VERSION;
  $msg = "You might want to update your Mojolicious to $latest!"      if $latest > $Mojolicious::VERSION;
  say $msg;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Command::version - Version command

=head1 SYNOPSIS

  Usage: APPLICATION version [OPTIONS]

    mojo version

  Options:
    -h, --help   Show this summary of available options

=head1 DESCRIPTION

L<Mojolicious::Command::version> shows version information for available core and optional modules.

This is a core command, that means it is always enabled and its code a good example for learning to build new commands,
you're welcome to fork it.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command::version> inherits all attributes from L<Mojolicious::Command> and implements the following new
ones.

=head2 description

  my $description = $v->description;
  $v              = $v->description('Foo');

Short description of this command, used for the command list.

=head2 usage

  my $usage = $v->usage;
  $v        = $v->usage('Foo');

Usage information for this command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command::version> inherits all methods from L<Mojolicious::Command> and implements the following new
ones.

=head2 run

  $v->run(@ARGV);

Run this command.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Renderer;
use Mojo::Base -base;

use Carp qw(croak);
use Mojo::Cache;
use Mojo::DynamicMethods;
use Mojo::File   qw(curfile path);
use Mojo::JSON   qw(encode_json);
use Mojo::Loader qw(data_section);
use Mojo::Util   qw(decamelize deprecated encode gzip md5_sum monkey_patch);

has cache          => sub { Mojo::Cache->new };
has classes        => sub { ['main'] };
has compress       => 1;
has default_format => 'html';
has 'default_handler';
has encoding               => 'UTF-8';
has [qw(handlers helpers)] => sub { {} };
has min_compress_size      => 860;
has paths                  => sub { [] };

# Bundled templates
my $TEMPLATES = curfile->sibling('resources', 'templates');

sub DESTROY { Mojo::Util::_teardown($_) for @{shift->{namespaces}} }

sub accepts {
  my ($self, $c) = (shift, shift);

  # DEPRECATED!
  my $req   = $c->req;
  my $param = $req->param('format');
  deprecated 'The ?format=* parameter is deprecated in favor of ?_format=* for content negotiation' if defined $param;

  # List representations
  my $fmt  = $param // $req->param('_format') || $c->stash->{format};
  my @exts = $fmt ? ($fmt) : ();
  push @exts, @{$c->app->types->detect($req->headers->accept)};
  return \@exts unless @_;

  # Find best representation
  for my $ext (@exts) { $ext eq $_ and return $ext for @_ }
  return @exts ? undef : shift;
}

sub add_handler { $_[0]->handlers->{$_[1]} = $_[2] and return $_[0] }

sub add_helper {
  my ($self, $name, $cb) = @_;

  $self->helpers->{$name} = $cb;
  delete $self->{proxy};
  $cb = $self->get_helper($name) if $name =~ s/\..*$//;
  Mojo::DynamicMethods::register $_, $self, $name, $cb for qw(Mojolicious Mojolicious::Controller);

  return $self;
}

sub get_data_template {
  my ($self, $options) = @_;
  return undef unless my $template = $self->template_name($options);
  return data_section $self->{index}{$template}, $template;
}

sub get_helper {
  my ($self, $name) = @_;

  if (my $h = $self->{proxy}{$name} || $self->helpers->{$name}) { return $h }

  my $found;
  my $class = 'Mojolicious::Renderer::Helpers::' . md5_sum "$name:$self";
  my $re    = length $name ? qr/^(\Q$name\E\.([^.]+))/ : qr/^(([^.]+))/;
  for my $key (keys %{$self->helpers}) {
    $key =~ $re ? ($found, my $method) = (1, $2) : next;
    my $sub = $self->get_helper($1);
    monkey_patch $class, $method => sub { ${shift()}->$sub(@_) };
  }

  $found ? push @{$self->{namespaces}}, $class : return undef;
  return $self->{proxy}{$name} = sub { bless \(my $dummy = shift), $class };
}

sub render {
  my ($self, $c) = @_;

  my $stash   = $c->stash;
  my $options = {
    encoding => $self->encoding,
    handler  => $stash->{handler},
    template => delete $stash->{template},
    variant  => $stash->{variant}
  };
  my $inline = $options->{inline} = delete $stash->{inline};
  $options->{handler} //= $self->default_handler if defined $inline;
  $options->{format} = $stash->{format} || $self->default_format;

  # Data
  return delete $stash->{data}, $options->{format} if defined $stash->{data};

  # Text
  return _maybe($options->{encoding}, delete $stash->{text}), $options->{format} if defined $stash->{text};

  # JSON
  return encode_json(delete $stash->{json}), 'json' if exists $stash->{json};

  # Template or templateless handler
  $options->{template} //= $self->template_for($c);
  return () unless $self->_render_template($c, \my $output, $options);

  # Inheritance
  my $content = $stash->{'mojo.content'} //= {};
  local $content->{content} = $output =~ /\S/ ? $output : undef if $stash->{extends} || $stash->{layout};
  while ((my $next = _next($stash)) && !defined $inline) {
    @$options{qw(handler template)} = ($stash->{handler}, $next);
    $options->{format} = $stash->{format} || $self->default_format;
    if ($self->_render_template($c, \my $tmp, $options)) { $output = $tmp }
    $content->{content} //= $output if $output =~ /\S/;
  }

  return $output if $stash->{'mojo.string'};
  return _maybe($options->{encoding}, $output), $options->{format};
}

sub respond {
  my ($self, $c, $output, $format, $status) = @_;

  croak 'A response has already been rendered' if $c->stash->{'mojo.respond'}++;

  # Gzip compression
  my $res = $c->res;
  if ($self->compress && length($output) >= $self->min_compress_size) {
    my $headers = $res->headers;
    $headers->append(Vary => 'Accept-Encoding');
    my $gzip = ($c->req->headers->accept_encoding // '') =~ /gzip/i;
    if ($gzip && !$headers->content_encoding) {
      $headers->content_encoding('gzip');
      $output = gzip $output;
    }
  }

  $res->body($output);
  $c->app->types->content_type($c, {ext => $format});
  return !!$c->rendered($status);
}

sub template_for {
  my ($self, $c) = @_;

  # Normal default template
  my $stash = $c->stash;
  my ($controller, $action) = @$stash{qw(controller action)};
  return join '/', split(/-/, decamelize $controller), $action if $controller && $action;

  # Try the route name if we don't have controller and action
  return undef unless my $route = $c->match->endpoint;
  return $route->name;
}

sub template_handler {
  my ($self, $options) = @_;
  return undef                  unless my $file     = $self->template_name($options);
  return $self->default_handler unless my $handlers = $self->{templates}{$file};
  return $handlers->[0];
}

sub template_name {
  my ($self, $options) = @_;

  return undef unless defined(my $template = $options->{template});
  return undef unless my $format = $options->{format};
  $template .= ".$format";

  $self->warmup unless $self->{templates};

  # Variants
  my $handler = $options->{handler};
  if (defined(my $variant = $options->{variant})) {
    $variant = "$template+$variant";
    my $handlers = $self->{templates}{$variant} // [];
    $template = $variant if @$handlers && !defined $handler || grep { $_ eq $handler } @$handlers;
  }

  return defined $handler ? "$template.$handler" : $template;
}

sub template_path {
  my ($self, $options) = @_;
  return undef unless my $name = $self->template_name($options);
  my @parts = split /\//, $name;
  -r and return $_ for map { path($_, @parts)->to_string } @{$self->paths}, $TEMPLATES;
  return undef;
}

sub warmup {
  my $self = shift;

  my ($index, $templates) = @$self{qw(index templates)} = ({}, {});

  # Handlers for templates
  for my $path (@{$self->paths}, $TEMPLATES) {
    s/\.(\w+)$// and push @{$templates->{$_}}, $1
      for path($path)->list_tree->map(sub { join '/', @{$_->to_rel($path)} })->each;
  }

  # Handlers and classes for DATA templates
  for my $class (reverse @{$self->classes}) {
    $index->{$_} = $class for my @keys = sort keys %{data_section $class};
    s/\.(\w+)$// and unshift @{$templates->{$_}}, $1 for reverse @keys;
  }
}

sub _maybe { $_[0] ? encode @_ : $_[1] }

sub _next {
  my $stash = shift;
  return delete $stash->{extends} if $stash->{extends};
  return undef unless my $layout = delete $stash->{layout};
  return join '/', 'layouts', $layout;
}

sub _render_template {
  my ($self, $c, $output, $options) = @_;

  my $handler = $options->{handler} ||= $self->template_handler($options);
  return undef unless $handler;
  $c->helpers->log->error(qq{No handler for "$handler" found}) and return undef
    unless my $renderer = $self->handlers->{$handler};

  $renderer->($self, $c, $output, $options);
  return 1 if defined $$output;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Renderer - Generate dynamic content

=head1 SYNOPSIS

  use Mojolicious::Renderer;

  my $renderer = Mojolicious::Renderer->new;
  push @{$renderer->classes}, 'MyApp::Controller::Foo';
  push @{$renderer->paths}, '/home/sri/templates';

=head1 DESCRIPTION

L<Mojolicious::Renderer> is the standard L<Mojolicious> renderer.

See L<Mojolicious::Guides::Rendering> for more.

=head1 ATTRIBUTES

L<Mojolicious::Renderer> implements the following attributes.

=head2 cache

  my $cache = $renderer->cache;
  $renderer = $renderer->cache(Mojo::Cache->new);

Renderer cache, defaults to a L<Mojo::Cache> object.

=head2 classes

  my $classes = $renderer->classes;
  $renderer   = $renderer->classes(['main']);

Classes to use for finding templates in C<DATA> sections with L<Mojo::Loader>, first one has the highest precedence,
defaults to C<main>. Only files with exactly two extensions will be used, like C<index.html.ep>. Note that for
templates to be detected, these classes need to have already been loaded and added before L</"warmup"> is called, which
usually happens automatically during application startup.

  # Add another class with templates in DATA section
  push @{$renderer->classes}, 'Mojolicious::Plugin::Fun';

  # Add another class with templates in DATA section and higher precedence
  unshift @{$renderer->classes}, 'Mojolicious::Plugin::MoreFun';

=head2 compress

  my $bool  = $renderer->compress;
  $renderer = $renderer->compress($bool);

Try to negotiate compression for dynamically generated response content and C<gzip> compress it automatically, defaults
to true.

=head2 default_format

  my $default = $renderer->default_format;
  $renderer   = $renderer->default_format('html');

The default format to render if C<format> is not set in the stash, defaults to C<html>. Note that changing the default
away from C<html> is not recommended, as it has the potential to break, for example, plugins with bundled templates.

=head2 default_handler

  my $default = $renderer->default_handler;
  $renderer   = $renderer->default_handler('ep');

The default template handler to use for rendering in cases where auto-detection doesn't work, like for C<inline>
templates.

=head2 encoding

  my $encoding = $renderer->encoding;
  $renderer    = $renderer->encoding('koi8-r');

Will encode generated content if set, defaults to C<UTF-8>. Note that many renderers such as
L<Mojolicious::Plugin::EPRenderer> also use this value to determine if template files should be decoded before
processing.

=head2 handlers

  my $handlers = $renderer->handlers;
  $renderer    = $renderer->handlers({epl => sub {...}});

Registered handlers.

=head2 helpers

  my $helpers = $renderer->helpers;
  $renderer   = $renderer->helpers({url_for => sub {...}});

Registered helpers.

=head2 min_compress_size

  my $size  = $renderer->min_compress_size;
  $renderer = $renderer->min_compress_size(1024);

Minimum output size in bytes required for compression to be used if enabled, defaults to C<860>.

=head2 paths

  my $paths = $renderer->paths;
  $renderer = $renderer->paths(['/home/sri/templates']);

Directories to look for templates in, first one has the highest precedence.

  # Add another "templates" directory
  push @{$renderer->paths}, '/home/sri/templates';

  # Add another "templates" directory with higher precedence
  unshift @{$renderer->paths}, '/home/sri/themes/blue/templates';

=head1 METHODS

L<Mojolicious::Renderer> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 accepts

  my $all  = $renderer->accepts(Mojolicious::Controller->new);
  my $best = $renderer->accepts(Mojolicious::Controller->new, 'html', 'json');

Select best possible representation for L<Mojolicious::Controller> object from C<format> C<GET>/C<POST> parameter,
C<format> stash value, or C<Accept> request header, defaults to returning the first extension if no preference could be
detected.

=head2 add_handler

  $renderer = $renderer->add_handler(epl => sub {...});

Register a handler.

  $renderer->add_handler(foo => sub ($renderer, $c, $output, $options) {
    ...
    $$output = 'Hello World!';
  });

=head2 add_helper

  $renderer = $renderer->add_helper(url_for => sub {...});

Register a helper.

  $renderer->add_helper(foo => sub ($c, @args) {
    ...
  });

=head2 get_data_template

  my $template = $renderer->get_data_template({
    template       => 'foo/bar',
    format         => 'html',
    handler        => 'epl'
  });

Return a C<DATA> section template from L</"classes"> for an options hash reference with C<template>, C<format>,
C<variant> and C<handler> values, or C<undef> if no template could be found, usually used by handlers.

=head2 get_helper

  my $helper = $renderer->get_helper('url_for');

Get a helper by full name, generate a helper dynamically for a prefix, or return C<undef> if no helper or prefix could
be found. Generated helpers return a proxy object containing the current controller object and on which nested helpers
can be called.

=head2 render

  my ($output, $format) = $renderer->render(Mojolicious::Controller->new);

Render output through one of the renderers. See L<Mojolicious::Controller/"render"> for a more user-friendly interface.

=head2 respond

  my $bool = $renderer->respond(Mojolicious::Controller->new, $output, $format);
  my $bool = $renderer->respond(
    Mojolicious::Controller->new, $output, $format, $status);

Finalize dynamically generated response content and L</"compress"> it if possible.

=head2 template_for

  my $name = $renderer->template_for(Mojolicious::Controller->new);

Return default template name for L<Mojolicious::Controller> object, or C<undef> if no name could be generated.

=head2 template_handler

  my $handler = $renderer->template_handler({
    template => 'foo/bar',
    format   => 'html'
  });

Return handler for an options hash reference with C<template>, C<format> and C<variant> values, or C<undef> if no
handler could be found.

=head2 template_name

  my $template = $renderer->template_name({
    template => 'foo/bar',
    format   => 'html',
    handler  => 'epl'
  });

Return a template name for an options hash reference with C<template>, C<format>, C<variant> and C<handler> values, or
C<undef> if no template could be found, usually used by handlers.

=head2 template_path

  my $path = $renderer->template_path({
    template => 'foo/bar',
    format   => 'html',
    handler  => 'epl'
  });

Return the full template path for an options hash reference with C<template>, C<format>, C<variant> and C<handler>
values, or C<undef> if the file does not exist in L</"paths">, usually used by handlers.

=head2 warmup

  $renderer->warmup;

Prepare templates from L</"classes"> for future use.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Validator::Validation;
use Mojo::Base -base;

use Carp ();
use Mojo::DynamicMethods -dispatch;
use Scalar::Util ();

has [qw(csrf_token topic validator)];
has [qw(input output)] => sub { {} };

sub BUILD_DYNAMIC {
  my ($class, $method, $dyn_methods) = @_;

  return sub {
    my $self    = shift;
    my $dynamic = $dyn_methods->{$self->validator}{$method};
    return $self->check($method => @_) if $dynamic;
    my $package = ref $self;
    Carp::croak qq{Can't locate object method "$method" via package "$package"};
  };
}

sub check {
  my ($self, $check) = (shift, shift);

  return $self unless $self->is_valid;

  my $cb     = $self->validator->checks->{$check};
  my $name   = $self->topic;
  my $values = $self->output->{$name};
  for my $value (ref $values eq 'ARRAY' ? @$values : $values) {
    next unless my $result = $self->$cb($name, $value, @_);
    return $self->error($name => [$check, $result, @_]);
  }

  return $self;
}

sub csrf_protect {
  my $self  = shift;
  my $token = $self->input->{csrf_token};
  $self->error(csrf_token => ['csrf_protect']) unless $token && $token eq ($self->csrf_token // '');
  return $self;
}

sub error {
  my ($self, $name) = (shift, shift);
  return $self->{error}{$name} unless @_;
  $self->{error}{$name} = shift;
  delete $self->output->{$name};
  return $self;
}

sub every_param {
  return [] unless defined(my $value = $_[0]->output->{$_[1] // $_[0]->topic});
  return [ref $value eq 'ARRAY' ? @$value : $value];
}

sub failed { [sort keys %{shift->{error}}] }

sub has_data { !!keys %{shift->input} }

sub has_error { $_[1] ? exists $_[0]{error}{$_[1]} : !!keys %{$_[0]{error}} }

sub is_valid { exists $_[0]->output->{$_[1] // $_[0]->topic} }

sub optional {
  my ($self, $name, @filters) = @_;

  return $self->topic($name) unless defined(my $input = $self->input->{$name});

  my @input = ref $input eq 'ARRAY' ? @$input : ($input);
  for my $cb (map { $self->validator->filters->{$_} } @filters) {
    @input = map { $self->$cb($name, $_) } @input;
  }
  $self->output->{$name} = @input > 1 ? \@input : $input[0] if @input && !grep { !defined } @input;

  return $self->topic($name);
}

sub param { shift->every_param(shift)->[-1] }

sub passed { [sort keys %{shift->output}] }

sub required {
  my ($self, $name) = (shift, shift);
  return $self if $self->optional($name, @_)->is_valid;
  return $self->error($name => ['required']);
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Validator::Validation - Perform validations

=head1 SYNOPSIS

  use Mojolicious::Validator;
  use Mojolicious::Validator::Validation;

  my $validator = Mojolicious::Validator->new;
  my $v = Mojolicious::Validator::Validation->new(validator => $validator);
  $v->input({foo => 'bar'});
  $v->required('foo')->in('bar', 'baz');
  say $v->param('foo');

=head1 DESCRIPTION

L<Mojolicious::Validator::Validation> performs L<Mojolicious::Validator> validation checks.

=head1 ATTRIBUTES

L<Mojolicious::Validator::Validation> implements the following attributes.

=head2 csrf_token

  my $token = $v->csrf_token;
  $v        = $v->csrf_token('fa6a08...');

CSRF token.

=head2 input

  my $input = $v->input;
  $v        = $v->input({foo => 'bar', baz => [123, 'yada']});

Data to be validated.

=head2 output

  my $output = $v->output;
  $v         = $v->output({foo => 'bar', baz => [123, 'yada']});

Validated data.

=head2 topic

  my $topic = $v->topic;
  $v        = $v->topic('foo');

Name of field currently being validated.

=head2 validator

  my $v = $v->validator;
  $v    = $v->validator(Mojolicious::Validator->new);

L<Mojolicious::Validator> object this validation belongs to.

=head1 METHODS

L<Mojolicious::Validator::Validation> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 check

  $v = $v->check('size', 2, 7);

Perform validation check on all values of the current L</"topic">, no more checks will be performed on them after the
first one failed. All checks from L<Mojolicious::Validator/"CHECKS"> are supported.

=head2 csrf_protect

  $v = $v->csrf_protect;

Validate C<csrf_token> and protect from cross-site request forgery.

=head2 error

  my $err = $v->error('foo');
  $v      = $v->error(foo => ['custom_check']);
  $v      = $v->error(foo => [$check, $result, @args]);

Get or set details for failed validation check, at any given time there can only be one per field.

  # Details about failed validation
  my ($check, $result, @args) = @{$v->error('foo')};

  # Force validation to fail for a field without performing a check
  $v->error(foo => ['some_made_up_check_name']);

=head2 every_param

  my $values = $v->every_param;
  my $values = $v->every_param('foo');

Similar to L</"param">, but returns all values sharing the same name as an array reference.

  # Get first value
  my $first = $v->every_param('foo')->[0];

=head2 failed

  my $names = $v->failed;

Return an array reference with all names for values that failed validation.

  # Names of all values that failed
  say for @{$v->failed};

=head2 has_data

  my $bool = $v->has_data;

Check if L</"input"> is available for validation.

=head2 has_error

  my $bool = $v->has_error;
  my $bool = $v->has_error('foo');

Check if validation resulted in errors, defaults to checking all fields.

=head2 is_valid

  my $bool = $v->is_valid;
  my $bool = $v->is_valid('foo');

Check if validation was successful and field has a value, defaults to checking the current L</"topic">.

=head2 optional

  $v = $v->optional('foo');
  $v = $v->optional('foo', @filters);

Change validation L</"topic"> and apply filters. All filters from L<Mojolicious::Validator/"FILTERS"> are supported.

  # Trim value and check size
  $v->optional('user', 'trim')->size(1, 15);

=head2 param

  my $value = $v->param;
  my $value = $v->param('foo');

Access validated values, defaults to the current L</"topic">. If there are multiple values sharing the same name, and
you want to access more than just the last one, you can use L</"every_param">.

  # Get value right away
  my $user = $v->optional('user')->size(1, 15)->param;

=head2 passed

  my $names = $v->passed;

Return an array reference with all names for values that passed validation.

  # Names of all values that passed
  say for @{$v->passed};

=head2 required

  $v = $v->required('foo');
  $v = $v->required('foo', @filters);

Change validation L</"topic">, apply filters, and make sure a value is present. All filters from
L<Mojolicious::Validator/"FILTERS"> are supported.

  # Trim value and check size
  $v->required('user', 'trim')->size(1, 15);

=head1 CHECKS

In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above, you can also call validation checks provided by
L</"validator"> on L<Mojolicious::Validator::Validation> objects, similar to L</"check">.

  # Call validation checks
  $v->required('foo')->size(2, 5)->like(qr/^[A-Z]/);
  $v->optional('bar')->equal_to('foo');
  $v->optional('baz')->in('test', '123');

  # Longer version
  $v->required('foo')->check('size', 2, 5)->check('like', qr/^[A-Z]/);

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Routes::Pattern;
use Mojo::Base -base;

use Carp qw(croak);

has [qw(constraints defaults types)]   => sub { {} };
has [qw(placeholder_start type_start)] => ':';
has [qw(placeholders tree)]            => sub { [] };
has quote_end                          => '>';
has quote_start                        => '<';
has [qw(regex unparsed)];
has relaxed_start  => '#';
has wildcard_start => '*';

sub match {
  my ($self, $path, $detect) = @_;
  my $captures = $self->match_partial(\$path, $detect);
  return !$path || $path eq '/' ? $captures : undef;
}

sub match_partial {
  my ($self, $pathref, $detect) = @_;

  # Compile on demand
  $self->_compile($detect) unless $self->{regex};

  return undef unless my @captures = $$pathref =~ $self->regex;
  $$pathref = ${^POSTMATCH};
  @captures = () if $#+ == 0;
  my $captures = {%{$self->defaults}};
  for my $placeholder (@{$self->placeholders}, 'format') {
    last unless @captures;
    my $capture = shift @captures;
    $captures->{$placeholder} = $capture if defined $capture;
  }

  return $captures;
}

sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }

sub parse {
  my $self = shift;

  my $pattern = @_ % 2 ? (shift // '/') : '/';
  $pattern =~ s!^/*|/+!/!g;
  return $self->constraints({@_}) if $pattern eq '/';

  $pattern =~ s!/$!!;
  return $self->constraints({@_})->_tokenize($pattern);
}

sub render {
  my ($self, $values, $endpoint) = @_;

  # Placeholders can only be optional without a format
  my $optional = !(my $format = $values->{format});

  my $str = '';
  for my $token (reverse @{$self->tree}) {
    my ($op, $value) = @$token;
    my $part = '';

    # Text
    if ($op eq 'text') { ($part, $optional) = ($value, 0) }

    # Slash
    elsif ($op eq 'slash') { $part = '/' unless $optional }

    # Placeholder
    else {
      my $name    = $value->[0];
      my $default = $self->defaults->{$name};
      $part = $values->{$name} // $default // '';
      if    (!defined $default || ($default ne $part)) { $optional = 0 }
      elsif ($optional)                                { $part     = '' }
    }

    $str = $part . $str;
  }

  # Format can be optional
  return $endpoint && $format ? "$str.$format" : $str;
}

sub _compile {
  my ($self, $detect) = @_;

  my $constraints = $self->constraints;
  my $defaults    = $self->defaults;
  my $types       = $self->types;

  my $block    = my $regex = '';
  my $optional = 1;
  for my $token (reverse @{$self->tree}) {
    my ($op, $value, $type) = @$token;
    my $part = '';

    # Text
    if ($op eq 'text') { ($part, $optional) = (quotemeta $value, 0) }

    # Slash
    elsif ($op eq 'slash') {
      $regex = ($optional ? "(?:/$block)?" : "/$block") . $regex;
      ($block, $optional) = ('', 1);
      next;
    }

    # Placeholder
    else {
      if ($value->[1]) { $part = _compile_req($types->{$value->[1]} // '?!') }
      else             { $part = $type ? $type eq 'relaxed' ? '([^/]+)' : '(.+)' : '([^/.]+)' }

      # Custom regex
      if (my $c = $constraints->{$value->[0]}) { $part = _compile_req($c) }

      # Optional placeholder
      exists $defaults->{$value->[0]} ? ($part .= '?') : ($optional = 0);
    }

    $block = $part . $block;
  }

  # Not rooted with a slash
  $regex = $block . $regex if $block;

  # Format
  $regex .= _compile_format($constraints->{format}, exists $defaults->{format}) if $detect;

  $self->regex(qr/^$regex/ps);
}

sub _compile_format {
  my ($format, $has_default) = @_;

  # No regex
  return '' unless $format;

  # Default regex
  return '/?(?:\.([^/]+))?$' if $format eq '1';

  # Compile custom regex
  my $regex = '\.' . _compile_req($format);
  return $has_default ? "/?(?:$regex)?\$" : "/?$regex\$";
}

sub _compile_req {
  my $req = shift;
  return "($req)" if ref $req ne 'ARRAY';
  return '(' . join('|', map {quotemeta} reverse sort @$req) . ')';
}

sub _tokenize {
  my ($self, $pattern) = @_;

  my $placeholders = $self->placeholders;
  my $type_start   = $self->type_start;
  my $quote_end    = $self->quote_end;
  my $quote_start  = $self->quote_start;
  my $start        = $self->placeholder_start;
  my $relaxed      = $self->relaxed_start;
  my $wildcard     = $self->wildcard_start;

  my (@tree, $spec, $more);
  for my $char (split //, $pattern) {

    # Quoted
    if    ($char eq $quote_start) { push @tree, ['placeholder', ''] if ++$spec }
    elsif ($char eq $quote_end)   { $spec = $more = 0 }

    # Placeholder
    elsif (!$more && $char eq $start) { push @tree, ['placeholder', ''] unless $spec++ }

    # Relaxed or wildcard (upgrade when quoted)
    elsif (!$more && ($char eq $relaxed || $char eq $wildcard)) {
      push @tree, ['placeholder', ''] unless $spec++;
      $tree[-1][2] = $char eq $relaxed ? 'relaxed' : 'wildcard';
    }

    # Slash
    elsif ($char eq '/') {
      push @tree, ['slash'];
      $spec = $more = 0;
    }

    # Placeholder
    elsif ($spec && ++$more) { $tree[-1][1] .= $char }

    # Text (optimize slash+text and *+text+slash+text)
    elsif ($tree[-1][0] eq 'text')                                         { $tree[-1][-1] .= $char }
    elsif (!$tree[-2] && $tree[-1][0] eq 'slash')                          { @tree = (['text', "/$char"]) }
    elsif ($tree[-2] && $tree[-2][0] eq 'text' && $tree[-1][0] eq 'slash') { pop @tree && ($tree[-1][-1] .= "/$char") }
    else                                                                   { push @tree, ['text', $char] }
  }

  # Placeholder types
  for my $token (reverse @tree) {
    next unless $token->[0] eq 'placeholder';
    $token->[1] = $token->[1] =~ /^(.+)\Q$type_start\E(.+)$/ ? [$1, $2] : [$token->[1]];
    unshift @$placeholders, $token->[1][0];
  }

  return $self->unparsed($pattern)->tree(\@tree);
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Routes::Pattern - Route pattern

=head1 SYNOPSIS

  use Mojolicious::Routes::Pattern;

  # Create pattern
  my $pattern = Mojolicious::Routes::Pattern->new('/test/:name');

  # Match routes
  my $captures = $pattern->match('/test/sebastian');
  say $captures->{name};

=head1 DESCRIPTION

L<Mojolicious::Routes::Pattern> is the core of L<Mojolicious::Routes>.

=head1 ATTRIBUTES

L<Mojolicious::Routes::Pattern> implements the following attributes.

=head2 constraints

  my $constraints = $pattern->constraints;
  $pattern        = $pattern->constraints({foo => qr/\w+/});

Regular expression constraints.

=head2 defaults

  my $defaults = $pattern->defaults;
  $pattern     = $pattern->defaults({foo => 'bar'});

Default parameters.

=head2 placeholder_start

  my $start = $pattern->placeholder_start;
  $pattern  = $pattern->placeholder_start(':');

Character indicating a placeholder, defaults to C<:>.

=head2 placeholders

  my $placeholders = $pattern->placeholders;
  $pattern         = $pattern->placeholders(['foo', 'bar']);

Placeholder names.

=head2 quote_end

  my $end  = $pattern->quote_end;
  $pattern = $pattern->quote_end('}');

Character indicating the end of a quoted placeholder, defaults to C<E<gt>>.

=head2 quote_start

  my $start = $pattern->quote_start;
  $pattern  = $pattern->quote_start('{');

Character indicating the start of a quoted placeholder, defaults to C<E<lt>>.

=head2 regex

  my $regex = $pattern->regex;
  $pattern  = $pattern->regex($regex);

Pattern in compiled regular expression form.

=head2 relaxed_start

  my $start = $pattern->relaxed_start;
  $pattern  = $pattern->relaxed_start('*');

Character indicating a relaxed placeholder, defaults to C<#>.

=head2 tree

  my $tree = $pattern->tree;
  $pattern = $pattern->tree([['text', '/foo']]);

Pattern in parsed form. Note that this structure should only be used very carefully since it is very dynamic.

=head2 type_start

  my $start = $pattern->type_start;
  $pattern  = $pattern->type_start('|');

Character indicating the start of a placeholder type, defaults to C<:>.

=head2 types

  my $types = $pattern->types;
  $pattern  = $pattern->types({int => qr/[0-9]+/});

Placeholder types.

=head2 unparsed

  my $unparsed = $pattern->unparsed;
  $pattern     = $pattern->unparsed('/:foo/:bar');

Raw unparsed pattern.

=head2 wildcard_start

  my $start = $pattern->wildcard_start;
  $pattern  = $pattern->wildcard_start('*');

Character indicating the start of a wildcard placeholder, defaults to C<*>.

=head1 METHODS

L<Mojolicious::Routes::Pattern> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 match

  my $captures = $pattern->match('/foo/bar');
  my $captures = $pattern->match('/foo/bar', 1);

Match pattern against entire path, format detection is disabled by default.

=head2 match_partial

  my $captures = $pattern->match_partial(\$path);
  my $captures = $pattern->match_partial(\$path, 1);

Match pattern against path and remove matching parts, format detection is disabled by default.

=head2 new

  my $pattern = Mojolicious::Routes::Pattern->new;
  my $pattern = Mojolicious::Routes::Pattern->new('/users/:id');
  my $pattern = Mojolicious::Routes::Pattern->new('/user/:id', id => qr/\d+/);
  my $pattern = Mojolicious::Routes::Pattern->new(format => ['json', 'yaml']);

Construct a new L<Mojolicious::Routes::Pattern> object and L</"parse"> pattern if necessary.

=head2 parse

  $pattern = $pattern->parse('/user/:id');
  $pattern = $pattern->parse('/user/:id', id=> qr/\d+/);
  $pattern = $pattern->parse(format => ['json', 'yaml']);

Parse pattern.

=head2 render

  my $path = $pattern->render({id => 24});
  my $path = $pattern->render({id => 24}, 1);

Render pattern into a path with parameters, format rendering is disabled by default.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Routes::Match;
use Mojo::Base -base;

use Mojo::Util;

has [qw(endpoint root)];
has position => 0;
has stack    => sub { [] };

sub find { $_[0]->_match($_[0]->root, $_[1], $_[2]) }

sub path_for {
  my ($self, $name, %values) = (shift, Mojo::Util::_options(@_));

  # Current route
  my ($route, $current) = (undef, !$name || $name eq 'current');
  if ($current) { return {} unless $route = $self->endpoint }

  # Find endpoint
  else { return {path => $name} unless $route = $self->root->lookup($name) }

  # Merge values (clear format)
  my $captures    = $self->stack->[-1] // {};
  my %merged      = (%$captures, format => undef, %values);
  my $pattern     = $route->pattern;
  my $constraints = $pattern->constraints;
  $merged{format} = ($current ? $captures->{format} : undef) // $pattern->defaults->{format}
    if !exists $values{format} && $constraints->{format} && $constraints->{format} ne '1';

  return {path => $route->render(\%merged), websocket => $route->has_websocket};
}

sub _match {
  my ($self, $r, $c, $options) = @_;

  # Pattern
  my $path    = $options->{path};
  my $partial = $r->partial;
  my $detect  = (my $endpoint = $r->is_endpoint) && !$partial;
  return undef unless my $captures = $r->pattern->match_partial(\$path, $detect);
  local $options->{path} = $path;
  local @{$self->{captures} //= {}}{keys %$captures} = values %$captures;
  $captures = $self->{captures};

  # Method
  my $methods = $r->methods;
  return undef if $methods && !grep { $_ eq $options->{method} } @$methods;

  # Conditions
  if (my $over = $r->requires) {
    my $conditions = $self->{conditions} ||= $self->root->conditions;
    for (my $i = 0; $i < @$over; $i += 2) {
      return undef unless my $condition = $conditions->{$over->[$i]};
      return undef if !$condition->($r, $c, $captures, $over->[$i + 1]);
    }
  }

  # WebSocket
  return undef if $r->is_websocket && !$options->{websocket};

  # Partial
  my $empty = !length $path || $path eq '/';
  if ($partial) {
    $captures->{path} = $path;
    $self->endpoint($r);
    $empty = 1;
  }

  # Endpoint (or intermediate destination)
  if (($endpoint && $empty) || $r->inline) {
    push @{$self->stack}, {%$captures};
    if ($endpoint && $empty) {
      my $format = $captures->{format};
      if ($format) { $_->{format} = $format for @{$self->stack} }
      return !!$self->endpoint($r);
    }
    delete @$captures{qw(app cb)};
  }

  # Match children
  my $snapshot = $r->parent ? [@{$self->stack}] : [];
  for my $child (@{$r->children}) {
    return 1 if $self->_match($child, $c, $options);
    $self->stack([@$snapshot]);
  }
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Routes::Match - Find routes

=head1 SYNOPSIS

  use Mojolicious::Controller;
  use Mojolicious::Routes;
  use Mojolicious::Routes::Match;

  # Routes
  my $r = Mojolicious::Routes->new;
  $r->get('/user/:id');
  $r->put('/user/:id');

  # Match
  my $c = Mojolicious::Controller->new;
  my $match = Mojolicious::Routes::Match->new(root => $r);
  $match->find($c => {method => 'PUT', path => '/user/23'});
  say $match->stack->[0]{id};

  # Render
  say $match->path_for->{path};
  say $match->path_for(id => 24)->{path};

=head1 DESCRIPTION

L<Mojolicious::Routes::Match> finds routes in L<Mojolicious::Routes> structures.

=head1 ATTRIBUTES

L<Mojolicious::Routes::Match> implements the following attributes.

=head2 endpoint

  my $route = $match->endpoint;
  $match    = $match->endpoint(Mojolicious::Routes::Route->new);

The route endpoint that matched, usually a L<Mojolicious::Routes::Route> object.

=head2 position

  my $position = $match->position;
  $match       = $match->position(2);

Current position on the L</"stack">, defaults to C<0>.

=head2 root

  my $root = $match->root;
  $match   = $match->root(Mojolicious::Routes->new);

The root of the route structure, usually a L<Mojolicious::Routes> object.

=head2 stack

  my $stack = $match->stack;
  $match    = $match->stack([{action => 'foo'}, {action => 'bar'}]);

Captured parameters with nesting history.

=head1 METHODS

L<Mojolicious::Routes::Match> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 find

  $match->find(Mojolicious::Controller->new, {method => 'GET', path => '/'});

Match controller and options against L</"root"> to find an appropriate L</"endpoint">.

=head2 path_for

  my $info = $match->path_for;
  my $info = $match->path_for(foo => 'bar');
  my $info = $match->path_for({foo => 'bar'});
  my $info = $match->path_for('named');
  my $info = $match->path_for('named', foo => 'bar');
  my $info = $match->path_for('named', {foo => 'bar'});

Render matching route with parameters into path.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Routes::Route;
use Mojo::Base -base;

use Carp qw(croak);
use Mojo::DynamicMethods -dispatch;
use Mojo::Util;
use Mojolicious::Routes::Pattern;

has [qw(inline partial)];
has 'children' => sub { [] };
has parent     => undef, weak => 1;
has pattern    => sub { Mojolicious::Routes::Pattern->new };

# Reserved stash values
my %RESERVED = map { $_ => 1 } (
  qw(action app cb controller data extends format handler inline json layout namespace path status template text),
  qw(variant)
);

sub BUILD_DYNAMIC {
  my ($class, $method, $dyn_methods) = @_;

  return sub {
    my $self    = shift;
    my $dynamic = $dyn_methods->{$self->root}{$method};
    return $self->$dynamic(@_) if $dynamic;
    my $package = ref($self);
    croak qq{Can't locate object method "$method" via package "$package"};
  };
}

sub add_child {
  my ($self, $route) = @_;
  push @{$self->children}, $route->remove->parent($self);
  $route->pattern->types($self->root->types);
  return $self;
}

sub any { shift->_generate_route(ref $_[0] eq 'ARRAY' ? shift : [], @_) }

sub delete { shift->_generate_route(DELETE => @_) }

sub find { shift->_index->{shift()} }

sub get { shift->_generate_route(GET => @_) }

sub has_custom_name { !!shift->{custom} }

sub has_websocket {
  my $self = shift;
  return $self->{has_websocket} if exists $self->{has_websocket};
  return $self->{has_websocket} = grep { $_->is_websocket } @{$self->_chain};
}

sub is_endpoint { $_[0]->inline ? undef : !@{$_[0]->children} }

sub is_reserved { !!$RESERVED{$_[1]} }

sub is_websocket { !!shift->{websocket} }

sub methods {
  my $self = shift;
  return $self->{methods} unless @_;
  my $methods = [map uc($_), @{ref $_[0] ? $_[0] : [@_]}];
  $self->{methods} = $methods if @$methods;
  return $self;
}

sub name {
  my $self = shift;
  return $self->{name} unless @_;
  @$self{qw(name custom)} = (shift, 1);
  return $self;
}

sub options { shift->_generate_route(OPTIONS => @_) }

sub parse {
  my $self = shift;
  $self->{name} = $self->pattern->parse(@_)->unparsed // '';
  $self->{name} =~ s/\W+//g;
  return $self;
}

sub patch { shift->_generate_route(PATCH => @_) }
sub post  { shift->_generate_route(POST  => @_) }
sub put   { shift->_generate_route(PUT   => @_) }

sub remove {
  my $self = shift;
  return $self unless my $parent = $self->parent;
  @{$parent->children} = grep { $_ ne $self } @{$parent->children};
  return $self->parent(undef);
}

sub render {
  my ($self, $values) = @_;
  my $path = join '', map { $_->pattern->render($values, !@{$_->children} && !$_->partial) } @{$self->_chain};
  return $path || '/';
}

sub root { shift->_chain->[0] }

sub requires {
  my $self = shift;

  # Routes with conditions can't be cached
  return $self->{requires} unless @_;
  my $conditions = ref $_[0] eq 'ARRAY' ? $_[0] : [@_];
  return $self unless @$conditions;
  $self->{requires} = $conditions;
  $self->root->cache->max_keys(0);

  return $self;
}

sub suggested_method {
  my $self = shift;

  my %via;
  for my $route (@{$self->_chain}) {
    next unless my @via = @{$route->methods // []};
    %via = map { $_ => 1 } keys %via ? grep { $via{$_} } @via : @via;
  }

  return 'POST' if $via{POST} && !$via{GET};
  return $via{GET} ? 'GET' : (sort keys %via)[0] || 'GET';
}

sub to {
  my $self = shift;

  my $pattern = $self->pattern;
  return $pattern->defaults unless @_;
  my ($shortcut, %defaults) = Mojo::Util::_options(@_);

  if ($shortcut) {

    # Application
    if (ref $shortcut || $shortcut =~ /^[\w:]+$/) { $defaults{app} = $shortcut }

    # Controller and action
    elsif ($shortcut =~ /^([\w\-:]+)?\#(\w+)?$/) {
      $defaults{controller} = $1 if defined $1;
      $defaults{action}     = $2 if defined $2;
    }
  }

  @{$pattern->defaults}{keys %defaults} = values %defaults;

  return $self;
}

sub to_string {
  join '', map { $_->pattern->unparsed // '' } @{shift->_chain};
}

sub under { shift->_generate_route(under => @_) }

sub websocket {
  my $route = shift->get(@_);
  $route->{websocket} = 1;
  return $route;
}

sub _chain {
  my @chain = (my $parent = shift);
  unshift @chain, $parent while $parent = $parent->parent;
  return \@chain;
}

sub _generate_route {
  my ($self, $methods, @args) = @_;

  my (@conditions, @constraints, %defaults, $name, $pattern);
  while (defined(my $arg = shift @args)) {

    # First scalar is the pattern
    if (!ref $arg && !$pattern) { $pattern = $arg }

    # Scalar
    elsif (!ref $arg && @args) { push @conditions, $arg, shift @args }

    # Last scalar is the route name
    elsif (!ref $arg) { $name = $arg }

    # Callback
    elsif (ref $arg eq 'CODE') { $defaults{cb} = $arg }

    # Constraints
    elsif (ref $arg eq 'ARRAY') { push @constraints, @$arg }

    # Defaults
    elsif (ref $arg eq 'HASH') { %defaults = (%defaults, %$arg) }
  }

  my $route = $self->_route($pattern, @constraints)->requires(\@conditions)->to(\%defaults);
  $methods eq 'under' ? $route->inline(1) : $route->methods($methods);

  return defined $name ? $route->name($name) : $route;
}

sub _index {
  my $self = shift;

  my (%auto, %custom);
  my @children = (@{$self->children});
  while (my $child = shift @children) {
    if   ($child->has_custom_name) { $custom{$child->name} ||= $child }
    else                           { $auto{$child->name}   ||= $child }
    push @children, @{$child->children};
  }

  return {%auto, %custom};
}

sub _route {
  my $self = shift;

  my $route       = $self->add_child(__PACKAGE__->new->parse(@_))->children->[-1];
  my $new_pattern = $route->pattern;
  croak qq{Route pattern "@{[$new_pattern->unparsed]}" contains a reserved stash value}
    if grep { $self->is_reserved($_) } @{$new_pattern->placeholders};

  my $old_pattern = $self->pattern;
  my $constraints = $old_pattern->constraints;
  $new_pattern->constraints->{format} //= $constraints->{format} if exists $constraints->{format};
  my $defaults = $old_pattern->defaults;
  $new_pattern->defaults->{format} //= $defaults->{format} if exists $defaults->{format};

  return $route;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Routes::Route - Route

=head1 SYNOPSIS

  use Mojolicious::Routes::Route;

  my $r = Mojolicious::Routes::Route->new;

=head1 DESCRIPTION

L<Mojolicious::Routes::Route> is the route container used by L<Mojolicious::Routes>.

=head1 ATTRIBUTES

L<Mojolicious::Routes::Route> implements the following attributes.

=head2 children

  my $children = $r->children;
  $r           = $r->children([Mojolicious::Routes::Route->new]);

The children of this route, used for nesting routes.

=head2 inline

  my $bool = $r->inline;
  $r       = $r->inline($bool);

Allow L</"under"> semantics for this route.

=head2 parent

  my $parent = $r->parent;
  $r         = $r->parent(Mojolicious::Routes::Route->new);

The parent of this route, usually a L<Mojolicious::Routes::Route> object. Note that this attribute is weakened.

=head2 partial

  my $bool = $r->partial;
  $r       = $r->partial($bool);

Route has no specific end, remaining characters will be captured in C<path>.

=head2 pattern

  my $pattern = $r->pattern;
  $r          = $r->pattern(Mojolicious::Routes::Pattern->new);

Pattern for this route, defaults to a L<Mojolicious::Routes::Pattern> object.

=head1 METHODS

L<Mojolicious::Routes::Route> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 add_child

  $r = $r->add_child(Mojolicious::Routes::Route->new);

Add a child to this route, it will be automatically removed from its current parent if necessary.

  # Reattach route
  $r->add_child($r->find('foo'));

=head2 any

  my $route = $r->any;
  my $route = $r->any('/:foo');
  my $route = $r->any('/:foo' => sub ($c) {...});
  my $route = $r->any('/:foo' => sub ($c) {...} => 'name');
  my $route = $r->any('/:foo' => {foo => 'bar'} => sub ($c) {...});
  my $route = $r->any('/:foo' => [foo => qr/\w+/] => sub ($c) {...});
  my $route = $r->any('/:foo' => (agent => qr/Firefox/) => sub ($c) {...});
  my $route = $r->any(['GET', 'POST'] => '/:foo' => sub ($c) {...});
  my $route = $r->any(['GET', 'POST'] => '/:foo' => [foo => qr/\w+/]);

Generate L<Mojolicious::Routes::Route> object matching any of the listed HTTP request methods or all.

  # Route with pattern and destination
  $r->any('/user')->to('user#whatever');

All arguments are optional, but some have to appear in a certain order, like the two supported array reference values,
which contain the HTTP methods to match and restrictive placeholders.

  # Route with HTTP methods, pattern, restrictive placeholders and destination
  $r->any(['DELETE', 'PUT'] => '/:foo' => [foo => qr/\w+/])->to('foo#bar');

There are also two supported string values, containing the route pattern and the route name, defaulting to the pattern
C</> and a name based on the pattern.

  # Route with pattern, name and destination
  $r->any('/:foo' => 'foo_route')->to('foo#bar');

An arbitrary number of key/value pairs in between the route pattern and name can be used to specify route conditions.

  # Route with pattern, condition and destination
  $r->any('/' => (agent => qr/Firefox/))->to('foo#bar');

A hash reference is used to specify optional placeholders and default values for the stash.

  # Route with pattern, optional placeholder and destination
  $r->any('/:foo' => {foo => 'bar'})->to('foo#bar');

And a code reference can be used to specify a C<cb> value to be merged into the default values for the stash.

  # Route with pattern and a closure as destination
  $r->any('/:foo' => sub ($c) {
    $c->render(text => 'Hello World!');
  });

See L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more information.

=head2 delete

  my $route = $r->delete;
  my $route = $r->delete('/:foo');
  my $route = $r->delete('/:foo' => sub ($c) {...});
  my $route = $r->delete('/:foo' => sub ($c) {...} => 'name');
  my $route = $r->delete('/:foo' => {foo => 'bar'} => sub ($c) {...});
  my $route = $r->delete('/:foo' => [foo => qr/\w+/] => sub ($c) {...});
  my $route = $r->delete('/:foo' => (agent => qr/Firefox/) => sub ($c) {...});

Generate L<Mojolicious::Routes::Route> object matching only C<DELETE> requests, takes the same arguments as L</"any">
(except for the HTTP methods to match, which are implied). See L<Mojolicious::Guides::Tutorial> and
L<Mojolicious::Guides::Routing> for more information.

  # Route with destination
  $r->delete('/user')->to('user#remove');

=head2 find

  my $route = $r->find('foo');

Find child route by name, custom names have precedence over automatically generated ones.

  # Change default parameters of a named route
  $r->find('show_user')->to(foo => 'bar');

=head2 get

  my $route = $r->get;
  my $route = $r->get('/:foo');
  my $route = $r->get('/:foo' => sub ($c) {...});
  my $route = $r->get('/:foo' => sub ($c) {...} => 'name');
  my $route = $r->get('/:foo' => {foo => 'bar'} => sub ($c) {...});
  my $route = $r->get('/:foo' => [foo => qr/\w+/] => sub ($c) {...});
  my $route = $r->get('/:foo' => (agent => qr/Firefox/) => sub ($c) {...});

Generate L<Mojolicious::Routes::Route> object matching only C<GET> requests, takes the same arguments as L</"any">
(except for the HTTP methods to match, which are implied). See L<Mojolicious::Guides::Tutorial> and
L<Mojolicious::Guides::Routing> for more information.

  # Route with destination
  $r->get('/user')->to('user#show');

=head2 has_custom_name

  my $bool = $r->has_custom_name;

Check if this route has a custom name.

=head2 has_websocket

  my $bool = $r->has_websocket;

Check if this route has a WebSocket ancestor and cache the result for future checks.

=head2 is_endpoint

  my $bool = $r->is_endpoint;

Check if this route qualifies as an endpoint.

=head2 is_reserved

  my $bool = $r->is_reserved('controller');

Check if string is a reserved stash value.

=head2 is_websocket

  my $bool = $r->is_websocket;

Check if this route is a WebSocket.

=head2 methods

  my $methods = $r->methods;
  $r          = $r->methods('GET');
  $r          = $r->methods('GET', 'POST');
  $r          = $r->methods(['GET', 'POST']);

Restrict HTTP methods this route is allowed to handle, defaults to no restrictions.

  # Route with two methods and destination
  $r->any('/foo')->methods('GET', 'POST')->to('foo#bar');

=head2 name

  my $name = $r->name;
  $r       = $r->name('foo');

The name of this route, defaults to an automatically generated name based on the route pattern. Note that the name
C<current> is reserved for referring to the current route.

  # Route with destination and custom name
  $r->get('/user')->to('user#show')->name('show_user');

=head2 options

  my $route = $r->options;
  my $route = $r->options('/:foo');
  my $route = $r->options('/:foo' => sub ($c) {...});
  my $route = $r->options('/:foo' => sub ($c) {...} => 'name');
  my $route = $r->options('/:foo' => {foo => 'bar'} => sub ($c) {...});
  my $route = $r->options('/:foo' => [foo => qr/\w+/] => sub ($c) {...});
  my $route = $r->options('/:foo' => (agent => qr/Firefox/) => sub ($c) {...});

Generate L<Mojolicious::Routes::Route> object matching only C<OPTIONS> requests, takes the same arguments as L</"any">
(except for the HTTP methods to match, which are implied). See L<Mojolicious::Guides::Tutorial> and
L<Mojolicious::Guides::Routing> for more information.

  # Route with destination
  $r->options('/user')->to('user#overview');

=head2 parse

  $r = $r->parse('/user/:id');
  $r = $r->parse('/user/:id', id => qr/\d+/);
  $r = $r->parse(format => ['json', 'yaml']);

Parse pattern.

=head2 patch

  my $route = $r->patch;
  my $route = $r->patch('/:foo');
  my $route = $r->patch('/:foo' => sub ($c) {...});
  my $route = $r->patch('/:foo' => sub ($c) {...} => 'name');
  my $route = $r->patch('/:foo' => {foo => 'bar'} => sub ($c) {...});
  my $route = $r->patch('/:foo' => [foo => qr/\w+/] => sub ($c) {...});
  my $route = $r->patch('/:foo' => (agent => qr/Firefox/) => sub ($c) {...});

Generate L<Mojolicious::Routes::Route> object matching only C<PATCH> requests, takes the same arguments as L</"any">
(except for the HTTP methods to match, which are implied). See L<Mojolicious::Guides::Tutorial> and
L<Mojolicious::Guides::Routing> for more information.

  # Route with destination
  $r->patch('/user')->to('user#update');

=head2 post

  my $route = $r->post;
  my $route = $r->post('/:foo');
  my $route = $r->post('/:foo' => sub ($c) {...});
  my $route = $r->post('/:foo' => sub ($c) {...} => 'name');
  my $route = $r->post('/:foo' => {foo => 'bar'} => sub ($c) {...});
  my $route = $r->post('/:foo' => [foo => qr/\w+/] => sub ($c) {...});
  my $route = $r->post('/:foo' => (agent => qr/Firefox/) => sub ($c) {...});

Generate L<Mojolicious::Routes::Route> object matching only C<POST> requests, takes the same arguments as L</"any">
(except for the HTTP methods to match, which are implied). See L<Mojolicious::Guides::Tutorial> and
L<Mojolicious::Guides::Routing> for more information.

  # Route with destination
  $r->post('/user')->to('user#create');

=head2 put

  my $route = $r->put;
  my $route = $r->put('/:foo');
  my $route = $r->put('/:foo' => sub ($c) {...});
  my $route = $r->put('/:foo' => sub ($c) {...} => 'name');
  my $route = $r->put('/:foo' => {foo => 'bar'} => sub ($c) {...});
  my $route = $r->put('/:foo' => [foo => qr/\w+/] => sub ($c) {...});
  my $route = $r->put('/:foo' => (agent => qr/Firefox/) => sub ($c) {...});

Generate L<Mojolicious::Routes::Route> object matching only C<PUT> requests, takes the same arguments as L</"any">
(except for the HTTP methods to match, which are implied). See L<Mojolicious::Guides::Tutorial> and
L<Mojolicious::Guides::Routing> for more information.

  # Route with destination
  $r->put('/user')->to('user#replace');

=head2 remove

  $r = $r->remove;

Remove route from parent.

  # Remove route completely
  $r->find('foo')->remove;

  # Reattach route to new parent
  $r->any('/foo')->add_child($r->find('bar')->remove);

=head2 render

  my $path = $r->render({foo => 'bar'});

Render route with parameters into a path.

=head2 root

  my $root = $r->root;

The L<Mojolicious::Routes> object this route is a descendant of.

=head2 requires

  my $requires = $r->requires;
  $r           = $r->requires(foo => 1);
  $r           = $r->requires(foo => 1, bar => {baz => 'yada'});
  $r           = $r->requires([foo => 1, bar => {baz => 'yada'}]);

Activate conditions for this route. Note that this automatically disables the routing cache, since conditions are too
complex for caching.

  # Route with condition and destination
  $r->get('/foo')->requires(host => qr/mojolicious\.org/)->to('foo#bar');

=head2 suggested_method

  my $method = $r->suggested_method;

Suggested HTTP method for reaching this route, C<GET> and C<POST> are preferred.

=head2 to

  my $defaults = $r->to;
  $r           = $r->to(action => 'foo');
  $r           = $r->to({action => 'foo'});
  $r           = $r->to('controller#action');
  $r           = $r->to('controller#action', foo => 'bar');
  $r           = $r->to('controller#action', {foo => 'bar'});
  $r           = $r->to(Mojolicious->new);
  $r           = $r->to(Mojolicious->new, foo => 'bar');
  $r           = $r->to(Mojolicious->new, {foo => 'bar'});
  $r           = $r->to('MyApp');
  $r           = $r->to('MyApp', foo => 'bar');
  $r           = $r->to('MyApp', {foo => 'bar'});

Set default parameters for this route.

=head2 to_string

  my $str = $r->to_string;

Stringify the whole route.

=head2 under

  my $route = $r->under(sub ($c) {...});
  my $route = $r->under('/:foo' => sub ($c) {...});
  my $route = $r->under('/:foo' => {foo => 'bar'});
  my $route = $r->under('/:foo' => [foo => qr/\w+/]);
  my $route = $r->under('/:foo' => (agent => qr/Firefox/));
  my $route = $r->under([format => ['json', 'yaml']]);

Generate L<Mojolicious::Routes::Route> object for a nested route with its own intermediate destination, takes the same
arguments as L</"any"> (except for the HTTP methods to match, which are not available). See
L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more information.

  # Longer version
  $r->any('/:foo' => sub ($c) {...})->inline(1);

  # Intermediate destination and prefix shared between two routes
  my $auth = $r->under('/user')->to('user#auth');
  $auth->get('/show')->to('#show');
  $auth->post('/create')->to('#create');

=head2 websocket

  my $route = $r->websocket;
  my $route = $r->websocket('/:foo');
  my $route = $r->websocket('/:foo' => sub ($c) {...});
  my $route = $r->websocket('/:foo' => sub ($c) {...} => 'name');
  my $route = $r->websocket('/:foo' => {foo => 'bar'} => sub ($c) {...});
  my $route = $r->websocket('/:foo' => [foo => qr/\w+/] => sub ($c) {...});
  my $route = $r->websocket('/:foo' => (agent => qr/Firefox/) => sub ($c) {...});

Generate L<Mojolicious::Routes::Route> object matching only WebSocket handshakes, takes the same arguments as L</"any">
(except for the HTTP methods to match, which are implied). See L<Mojolicious::Guides::Tutorial> and
L<Mojolicious::Guides::Routing> for more information.

  # Route with destination
  $r->websocket('/echo')->to('example#echo');

=head1 SHORTCUTS

In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call shortcuts provided by L</"root"> on
L<Mojolicious::Routes::Route> objects.

  # Add a "firefox" shortcut
  $r->root->add_shortcut(firefox => sub ($r, $path) {
    $r->get($path, agent => qr/Firefox/);
  });

  # Use "firefox" shortcut to generate routes
  $r->firefox('/welcome')->to('firefox#welcome');
  $r->firefox('/bye')->to('firefox#bye');

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Types;
use Mojo::Base -base;

use Mojo::File qw(path);

has mapping => sub {
  {
    appcache => ['text/cache-manifest'],
    atom     => ['application/atom+xml'],
    bin      => ['application/octet-stream'],
    css      => ['text/css'],
    gif      => ['image/gif'],
    gz       => ['application/x-gzip'],
    htm      => ['text/html'],
    html     => ['text/html;charset=UTF-8'],
    ico      => ['image/x-icon'],
    jpeg     => ['image/jpeg'],
    jpg      => ['image/jpeg'],
    js       => ['application/javascript'],
    json     => ['application/json;charset=UTF-8'],
    mp3      => ['audio/mpeg'],
    mp4      => ['video/mp4'],
    ogg      => ['audio/ogg'],
    ogv      => ['video/ogg'],
    pdf      => ['application/pdf'],
    png      => ['image/png'],
    rss      => ['application/rss+xml'],
    svg      => ['image/svg+xml'],
    ttf      => ['font/ttf'],
    txt      => ['text/plain;charset=UTF-8'],
    webm     => ['video/webm'],
    woff     => ['font/woff'],
    woff2    => ['font/woff2'],
    xml      => ['application/xml', 'text/xml'],
    zip      => ['application/zip']
  };
};

sub content_type {
  my ($self, $c, $o) = (shift, shift, shift // {});

  my $headers = $c->res->headers;
  return undef if $headers->content_type;

  my $type = $o->{file} ? $self->file_type($o->{file}) : $self->type($o->{ext});
  $headers->content_type($type // 'application/octet-stream');
}

sub detect {
  my ($self, $accept) = @_;

  # Extract and prioritize MIME types
  my %types;
  /^\s*([^,; ]+)(?:\s*\;\s*q\s*=\s*(\d+(?:\.\d+)?))?\s*$/i and $types{lc $1} = $2 // 1 for split /,/, $accept // '';
  my @detected = sort { $types{$b} <=> $types{$a} } sort keys %types;

  # Detect extensions from MIME types
  my %reverse;
  my $mapping = $self->mapping;
  for my $ext (sort keys %$mapping) {
    my @types = @{$mapping->{$ext}};
    push @{$reverse{$_}}, $ext for map { s/\;.*$//; lc $_ } @types;
  }

  return [map { @{$reverse{$_} // []} } @detected];
}

sub file_type { $_[0]->type(path($_[1])->extname) }

sub type {
  my ($self, $ext, $type) = @_;
  return $self->mapping->{lc $ext}[0] unless $type;
  $self->mapping->{lc $ext} = ref $type ? $type : [$type];
  return $self;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Types - MIME types

=head1 SYNOPSIS

  use Mojolicious::Types;

  my $types = Mojolicious::Types->new;
  $types->type(foo => 'text/foo');
  say $types->type('foo');

=head1 DESCRIPTION

L<Mojolicious::Types> manages MIME types for L<Mojolicious>.

  appcache -> text/cache-manifest
  atom     -> application/atom+xml
  bin      -> application/octet-stream
  css      -> text/css
  gif      -> image/gif
  gz       -> application/x-gzip
  htm      -> text/html
  html     -> text/html;charset=UTF-8
  ico      -> image/x-icon
  jpeg     -> image/jpeg
  jpg      -> image/jpeg
  js       -> application/javascript
  json     -> application/json;charset=UTF-8
  mp3      -> audio/mpeg
  mp4      -> video/mp4
  ogg      -> audio/ogg
  ogv      -> video/ogg
  pdf      -> application/pdf
  png      -> image/png
  rss      -> application/rss+xml
  svg      -> image/svg+xml
  ttf      -> font/ttf
  txt      -> text/plain;charset=UTF-8
  webm     -> video/webm
  woff     -> font/woff
  woff2    -> font/woff2
  xml      -> application/xml,text/xml
  zip      -> application/zip

The most common ones are already defined.

=head1 ATTRIBUTES

L<Mojolicious::Types> implements the following attributes.

=head2 mapping

  my $mapping = $types->mapping;
  $types      = $types->mapping({png => ['image/png']});

MIME type mapping.

=head1 METHODS

L<Mojolicious::Types> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 content_type

  $types->content_type(Mojolicious::Controller->new, {ext => 'json'});

Detect MIME type for L<Mojolicious::Controller> object unless a C<Content-Type> response header has already been set,
defaults to using C<application/octet-stream> if no better alternative could be found. These options are currently
available:

=over 2

=item ext

  ext => 'json'

File extension to get MIME type for.

=item file

  file => 'foo/bar.png'

File path to get MIME type for.

=back

=head2 detect

  my $exts = $types->detect('text/html, application/json;q=9');

Detect file extensions from C<Accept> header value.

  # List detected extensions prioritized
  say for @{$types->detect('application/json, text/xml;q=0.1', 1)};

=head2 file_type

  my $type = $types->file_type('foo/bar.png');

Get MIME type for file path.

=head2 type

  my $type = $types->type('png');
  $types   = $types->type(png => 'image/png');
  $types   = $types->type(json => ['application/json', 'text/x-json']);

Get or set MIME types for file extension, alternatives are only used for detection.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Validator;
use Mojo::Base -base;

use Mojo::DynamicMethods;
use Mojo::Util qw(trim);
use Mojolicious::Validator::Validation;

has checks  => sub { {} };
has filters => sub { {comma_separated => \&_comma_separated, not_empty => \&_not_empty, trim => \&_trim} };

sub add_check {
  my ($self, $name, $cb) = @_;
  $self->checks->{$name} = $cb;
  Mojo::DynamicMethods::register 'Mojolicious::Validator::Validation', $self, $name, $cb;
  return $self;
}

sub add_filter { $_[0]->filters->{$_[1]} = $_[2] and return $_[0] }

sub new {
  my $self = shift->SUPER::new(@_);

  $self->add_check(equal_to => \&_equal_to);
  $self->add_check(in       => \&_in);
  $self->add_check(like     => sub { $_[2] !~ $_[3] });
  $self->add_check(num      => \&_num);
  $self->add_check(size     => \&_size);
  $self->add_check(upload   => sub { !ref $_[2] || !$_[2]->isa('Mojo::Upload') });

  return $self;
}

sub validation { Mojolicious::Validator::Validation->new(validator => shift) }

sub _comma_separated { defined $_[2] ? split(/\s*,\s*/, $_[2], -1) : undef }

sub _equal_to {
  my ($v, $name, $value, $to) = @_;
  return 1 unless defined(my $other = $v->input->{$to});
  return $value ne $other;
}

sub _in {
  my ($v, $name, $value) = (shift, shift, shift);
  $value eq $_ && return undef for @_;
  return 1;
}

sub _not_empty { length $_[2] ? $_[2] : () }

sub _num {
  my ($v, $name, $value, $min, $max) = @_;
  return 1 if $value !~ /^-?[0-9]+$/;
  return defined $min && $min > $value || defined $max && $max < $value;
}

sub _size {
  my ($v, $name, $value, $min, $max) = @_;
  my $len = ref $value ? $value->size : length $value;
  return (defined $min && $len < $min) || (defined $max && $len > $max);
}

sub _trim { defined $_[2] ? trim $_[2] : undef }

1;

=encoding utf8

=head1 NAME

Mojolicious::Validator - Validate values

=head1 SYNOPSIS

  use Mojolicious::Validator;

  my $validator = Mojolicious::Validator->new;
  my $v = $validator->validation;
  $v->input({foo => 'bar'});
  $v->required('foo')->like(qr/ar$/);
  say $v->param('foo');

=head1 DESCRIPTION

L<Mojolicious::Validator> validates values for L<Mojolicious>.

=head1 CHECKS

These validation checks are available by default.

=head2 equal_to

  $v = $v->equal_to('foo');

String value needs to be equal to the value of another field.

=head2 in

  $v = $v->in('foo', 'bar', 'baz');

String value needs to match one of the values in the list.

=head2 like

  $v = $v->like(qr/^[A-Z]/);

String value needs to match the regular expression.

=head2 num

  $v = $v->num;
  $v = $v->num(2, 5);
  $v = $v->num(-3, 7);
  $v = $v->num(2, undef);
  $v = $v->num(undef, 5);

String value needs to be a non-fractional number (positive or negative) and if provided in the given range.

=head2 size

  $v = $v->size(2, 5);
  $v = $v->size(2, undef);
  $v = $v->size(undef, 5);

String value length or size of L<Mojo::Upload> object in bytes needs to be between these two values.

=head2 upload

  $v = $v->upload;

Value needs to be a L<Mojo::Upload> object, representing a file upload.

=head1 FILTERS

These filters are available by default.

=head2 comma_separated

  $v = $v->optional('foo', 'comma_separated');

Split string of comma separated values into separate values.

=head2 not_empty

  $v = $v->optional('foo', 'not_empty');

Remove empty string values and treat them as if they had not been submitted.

=head2 trim

  $v = $v->optional('foo', 'trim');

Trim whitespace characters from both ends of string value with L<Mojo::Util/"trim">.

=head1 ATTRIBUTES

L<Mojolicious::Validator> implements the following attributes.

=head2 checks

  my $checks = $validator->checks;
  $validator = $validator->checks({size => sub ($v, $name, $value, @args) {...}});

Registered validation checks, by default only L</"equal_to">, L</"in">, L</"like">, L</"num">, L</"size"> and
L</"upload"> are already defined.

=head2 filters

  my $filters = $validator->filters;
  $validator  = $validator->filters({trim => sub {...}});

Registered filters, by default only L</"comma_separated">, L</"not_empty"> and L</"trim"> are already defined.

=head1 METHODS

L<Mojolicious::Validator> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 add_check

  $validator = $validator->add_check(size => sub ($v, $name, $value, @args) {...});

Register a validation check.

  $validator->add_check(foo => sub ($v, $name, $value, @args) {
    ...
    return undef;
  });

=head2 add_filter

  $validator = $validator->add_filter(trim => sub ($v, $name, $value) {...});

Register a new filter.

  $validator->add_filter(foo => sub ($v, $name, $value) {
    ...
    return $value;
  });

=head2 new

  my $validator = Mojolicious::Validator->new;

Construct a new L<Mojolicious::Validator> object.

=head2 validation

  my $v = $validator->validation;

Build L<Mojolicious::Validator::Validation> object to perform validations.

  my $v = $validator->validation;
  $v->input({foo => 'bar'});
  $v->required('foo')->size(1, 5);
  say $v->param('foo');

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Plugin;
use Mojo::Base -base;

use Carp qw(croak);

sub register { croak 'Method "register" not implemented by subclass' }

1;

=encoding utf8

=head1 NAME

Mojolicious::Plugin - Plugin base class

=head1 SYNOPSIS

  # CamelCase plugin name
  package Mojolicious::Plugin::MyPlugin;
  use Mojo::Base 'Mojolicious::Plugin', -signatures;

  sub register ($self, $app, $conf) {

    # Magic here! :)
  }

=head1 DESCRIPTION

L<Mojolicious::Plugin> is an abstract base class for L<Mojolicious> plugins.

See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available by default.

=head1 METHODS

L<Mojolicious::Plugin> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 register

  $plugin->register(Mojolicious->new);
  $plugin->register(Mojolicious->new, {foo => 'bar'});

This method will be called by L<Mojolicious::Plugins> at startup time. Meant to be overloaded in a subclass.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Sessions;
use Mojo::Base -base;

use Mojo::JSON;
use Mojo::Util qw(b64_decode b64_encode);

has [qw(cookie_domain secure)];
has cookie_name        => 'mojolicious';
has cookie_path        => '/';
has default_expiration => 3600;
has deserialize        => sub { \&_deserialize };
has samesite           => 'Lax';
has serialize          => sub { \&_serialize };

sub load {
  my ($self, $c) = @_;

  return unless my $value = $c->signed_cookie($self->cookie_name);
  $value =~ y/-/=/;
  return unless my $session = $self->deserialize->(b64_decode $value);

  # "expiration" value is inherited
  my $expiration = $session->{expiration} // $self->default_expiration;
  return if !(my $expires = delete $session->{expires}) && $expiration;
  return if defined $expires                            && $expires <= time;

  my $stash = $c->stash;
  return unless $stash->{'mojo.active_session'} = keys %$session;
  $stash->{'mojo.session'} = $session;
  $session->{flash}        = delete $session->{new_flash} if $session->{new_flash};
}

sub store {
  my ($self, $c) = @_;

  # Make sure session was active
  my $stash = $c->stash;
  return unless my $session = $stash->{'mojo.session'};
  return unless keys %$session || $stash->{'mojo.active_session'};

  # Don't reset flash for static files
  my $old = delete $session->{flash};
  $session->{new_flash} = $old if $stash->{'mojo.static'};
  delete $session->{new_flash} unless keys %{$session->{new_flash}};

  # Generate "expires" value from "expiration" if necessary
  my $expiration = $session->{expiration} // $self->default_expiration;
  my $default    = delete $session->{expires};
  $session->{expires} = $default || time + $expiration if $expiration || $default;

  my $value = b64_encode $self->serialize->($session), '';
  $value =~ y/=/-/;
  my $options = {
    domain   => $self->cookie_domain,
    expires  => $session->{expires},
    httponly => 1,
    path     => $self->cookie_path,
    samesite => $self->samesite,
    secure   => $self->secure
  };
  $c->signed_cookie($self->cookie_name, $value, $options);
}

sub _deserialize { Mojo::JSON::decode_json($_[0] =~ s/\}\KZ*$//r) }

sub _serialize {
  no warnings 'numeric';
  my $out = Mojo::JSON::encode_json($_[0]);
  return $out . 'Z' x (1025 - length $out);
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Sessions - Session manager based on signed cookies

=head1 SYNOPSIS

  use Mojolicious::Sessions;

  my $sessions = Mojolicious::Sessions->new;
  $sessions->cookie_name('myapp');
  $sessions->default_expiration(86400);

=head1 DESCRIPTION

L<Mojolicious::Sessions> manages sessions based on signed cookies for L<Mojolicious>. All data gets serialized with
L<Mojo::JSON> and stored Base64 encoded on the client-side, but is protected from unwanted changes with a HMAC-SHA256
signature.

=head1 ATTRIBUTES

L<Mojolicious::Sessions> implements the following attributes.

=head2 cookie_domain

  my $domain = $sessions->cookie_domain;
  $sessions  = $sessions->cookie_domain('.example.com');

Domain for session cookies, not defined by default.

=head2 cookie_name

  my $name  = $sessions->cookie_name;
  $sessions = $sessions->cookie_name('session');

Name for session cookies, defaults to C<mojolicious>.

=head2 cookie_path

  my $path  = $sessions->cookie_path;
  $sessions = $sessions->cookie_path('/foo');

Path for session cookies, defaults to C</>.

=head2 default_expiration

  my $time  = $sessions->default_expiration;
  $sessions = $sessions->default_expiration(3600);

Default time for sessions to expire in seconds from now, defaults to C<3600>. The expiration timeout gets refreshed for
every request. Setting the value to C<0> will allow sessions to persist until the browser window is closed, this can
have security implications though. For more control you can also use the C<expiration> and C<expires> session values.

  # Expiration date in seconds from now (persists between requests)
  $c->session(expiration => 604800);

  # Expiration date as absolute epoch time (only valid for one request)
  $c->session(expires => time + 604800);

  # Delete whole session by setting an expiration date in the past
  $c->session(expires => 1);

=head2 deserialize

  my $cb    = $sessions->deserialize;
  $sessions = $sessions->deserialize(sub ($bytes) {...});

A callback used to deserialize sessions, defaults to L<Mojo::JSON/"j">.

  $sessions->deserialize(sub ($bytes) { return {} });

=head2 samesite

  my $samesite = $sessions->samesite;
  $sessions    = $sessions->samesite('Strict');

Set the SameSite value on all session cookies, defaults to C<Lax>. Note that this attribute is B<EXPERIMENTAL> because
even though most commonly used browsers support the feature, there is no specification yet besides L<this
draft|https://tools.ietf.org/html/draft-west-first-party-cookies-07>.

  # Disable SameSite feature
  $sessions->samesite(undef);

=head2 secure

  my $bool  = $sessions->secure;
  $sessions = $sessions->secure($bool);

Set the secure flag on all session cookies, so that browsers send them only over HTTPS connections.

=head2 serialize

  my $cb    = $sessions->serialize;
  $sessions = $sessions->serialize(sub ($hash) {...});

A callback used to serialize sessions, defaults to L<Mojo::JSON/"encode_json">.

  $sessions->serialize(sub ($hash) { return '' });

=head1 METHODS

L<Mojolicious::Sessions> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 load

  $sessions->load(Mojolicious::Controller->new);

Load session data from signed cookie.

=head2 store

  $sessions->store(Mojolicious::Controller->new);

Store session data in signed cookie.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Commands;
use Mojo::Base 'Mojolicious::Command';

use Mojo::Loader qw(find_modules find_packages load_class);
use Mojo::Server;
use Mojo::Util qw(getopt tablify);

has hint => <<EOF;

See 'APPLICATION help COMMAND' for more information on a specific command.
EOF
has message    => sub { shift->extract_usage . "\nCommands:\n" };
has namespaces => sub { ['Mojolicious::Command::Author', 'Mojolicious::Command'] };

sub detect {

  # PSGI (Plack only for now)
  return 'psgi' if defined $ENV{PLACK_ENV};

  # CGI
  return 'cgi' if defined $ENV{PATH_INFO} || defined $ENV{GATEWAY_INTERFACE};

  # Nothing
  return undef;
}

sub run {
  my ($self, $name, @args) = @_;

  # Application loader
  return $self->app if defined $ENV{MOJO_APP_LOADER};

  # Try to detect environment
  if (!$ENV{MOJO_NO_DETECT} && (my $env = $self->detect)) { $name = $env }

  # Run command
  if ($name && $name =~ /^\w[\w-]+$/ && ($name ne 'help' || $args[0])) {

    # Help
    $name = shift @args if my $help = $name eq 'help';
    local $ENV{MOJO_HELP} = $help = $ENV{MOJO_HELP} || $help;
    $name =~ s/-/_/g;

    # Remove options shared by all commands before loading the command
    _args(\@args);
    my $module;
    $module = _command("${_}::$name", 1) and last for @{$self->namespaces};

    # Unknown command
    die qq{Unknown command "$name", maybe you need to install it?\n} unless $module;

    # Run command
    my $app     = $self->app;
    my $command = $module->new(app => $app);
    return $command->help(@args) if $help;
    $app->plugins->emit_hook(before_command => $command, \@args);
    return $command->run(@args);
  }

  elsif ($name && $name ne 'help' && $name ne '--help' && $name ne '-h') { die qq{Invalid command "$name".\n} }

  # Hide list for tests
  return 1 if $ENV{HARNESS_ACTIVE};

  # Find all available commands
  my %all;
  for my $ns (@{$self->namespaces}) {
    $all{substr $_, length "${ns}::"} //= $_->new->description
      for grep { _command($_) } find_modules($ns), find_packages($ns);
  }

  my @rows;
  for my $class (sort keys %all) {
    my $command = $class;
    $command =~ s/(?<!^)_/-/g;
    push @rows, [" $command", $all{$class}];
  }

  return print $self->message, tablify(\@rows), $self->hint;
}

sub start_app { shift; Mojo::Server->new->build_app(shift)->start(@_) }

# Command line options for MOJO_HELP, MOJO_HOME and MOJO_MODE
sub _args {
  getopt shift, ['pass_through'],
    'h|help'   => \$ENV{MOJO_HELP},
    'home=s'   => \$ENV{MOJO_HOME},
    'm|mode=s' => \$ENV{MOJO_MODE}
    unless __PACKAGE__->detect;
}

# Do not remove options from @ARGV
BEGIN { _args([@ARGV]) }

sub _command {
  my ($module, $fatal) = @_;
  return $module->isa('Mojolicious::Command') ? $module : undef unless my $e = load_class $module;
  $fatal && ref $e ? die $e : return undef;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Commands - Command line interface

=head1 SYNOPSIS

  Usage: APPLICATION COMMAND [OPTIONS]

    mojo version
    mojo generate lite-app
    ./myapp.pl daemon -m production -l http://*:8080
    ./myapp.pl get /foo
    ./myapp.pl routes -v

  Tip: CGI and PSGI environments can be automatically detected very often and
       work without commands.

  Options (for all commands):
    -h, --help          Get more information on a specific command
        --home <path>   Path to home directory of your application, defaults to
                        the value of MOJO_HOME or auto-detection
    -m, --mode <name>   Operating mode for your application, defaults to the
                        value of MOJO_MODE/PLACK_ENV or "development"

=head1 DESCRIPTION

L<Mojolicious::Commands> is the interactive command line interface for the L<Mojolicious> framework. It will
automatically detect available commands in the C<Mojolicious::Command> and C<Mojolicious::Command::Author> namespaces.

=head1 COMMANDS

These commands are available by default.

=head2 cgi

  $ ./myapp.pl cgi

Use L<Mojolicious::Command::cgi> to start application with CGI backend, usually auto detected.

=head2 cpanify

  $ mojo cpanify -u sri -p secr3t Mojolicious-Plugin-Fun-0.1.tar.gz

Use L<Mojolicious::Command::Author::cpanify> for uploading files to CPAN.

=head2 daemon

  $ ./myapp.pl daemon

Use L<Mojolicious::Command::daemon> to start application with standalone HTTP and WebSocket server.

=head2 eval

  $ ./myapp.pl eval 'say app->home'

Use L<Mojolicious::Command::eval> to run code against application.

=head2 generate

  $ mojo generate
  $ mojo generate help
  $ ./myapp.pl generate help

List available generator commands with short descriptions.

  $ mojo generate help <generator>
  $ ./myapp.pl generate help <generator>

List available options for generator command with short descriptions.

=head2 generate app

  $ mojo generate app <AppName>

Use L<Mojolicious::Command::Author::generate::app> to generate application directory structure for a fully functional
L<Mojolicious> application.

=head2 generate dockerfile

  $ ./myapp.pl generate dockerfile
  $ ./script/my_app generate dockerfile

Use L<Mojolicious::Command::Author::generate::dockerfile> to generate C<Dockerfile> for application.

=head2 generate lite-app

  $ mojo generate lite-app

Use L<Mojolicious::Command::Author::generate::lite_app> to generate a fully functional L<Mojolicious::Lite>
application.

=head2 generate makefile

  $ mojo generate makefile
  $ ./myapp.pl generate makefile

Use L<Mojolicious::Command::Author::generate::makefile> to generate C<Makefile.PL> file for application.

=head2 generate plugin

  $ mojo generate plugin <PluginName>

Use L<Mojolicious::Command::Author::generate::plugin> to generate directory structure for a fully functional
L<Mojolicious> plugin.

=head2 get

  $ mojo get https://mojolicious.org
  $ ./myapp.pl get /foo

Use L<Mojolicious::Command::get> to perform requests to remote host or local application.

=head2 help

  $ mojo
  $ mojo help
  $ ./myapp.pl help

List available commands with short descriptions.

  $ mojo help <command>
  $ ./myapp.pl help <command>

List available options for the command with short descriptions.

=head2 inflate

  $ ./myapp.pl inflate

Use L<Mojolicious::Command::Author::inflate> to turn templates and static files embedded in the C<DATA> sections of
your application into real files.

=head2 prefork

  $ ./myapp.pl prefork

Use L<Mojolicious::Command::prefork> to start application with standalone pre-forking HTTP and WebSocket server.

=head2 psgi

  $ ./myapp.pl psgi

Use L<Mojolicious::Command::psgi> to start application with PSGI backend, usually auto detected.

=head2 routes

  $ ./myapp.pl routes

Use L<Mojolicious::Command::routes> to list application routes.

=head2 version

  $ mojo version
  $ ./myapp.pl version

Use L<Mojolicious::Command::version> to show version information for available core and optional modules, very useful
for debugging.

=head1 ATTRIBUTES

L<Mojolicious::Commands> inherits all attributes from L<Mojolicious::Command> and implements the following new ones.

=head2 hint

  my $hint  = $commands->hint;
  $commands = $commands->hint('Foo');

Short hint shown after listing available commands.

=head2 message

  my $msg   = $commands->message;
  $commands = $commands->message('Hello World!');

Short usage message shown before listing available commands.

=head2 namespaces

  my $namespaces = $commands->namespaces;
  $commands      = $commands->namespaces(['MyApp::Command']);

Namespaces to load commands from, defaults to C<Mojolicious::Command::Author> and C<Mojolicious::Command>.

  # Add another namespace to load commands from
  push @{$commands->namespaces}, 'MyApp::Command';

=head1 METHODS

L<Mojolicious::Commands> inherits all methods from L<Mojolicious::Command> and implements the following new ones.

=head2 detect

  my $env = $commands->detect;

Try to detect environment, or return C<undef> if none could be detected.

=head2 run

  $commands->run;
  $commands->run(@ARGV);

Load and run commands. Automatic deployment environment detection can be disabled with the C<MOJO_NO_DETECT>
environment variable.

=head2 start_app

  Mojolicious::Commands->start_app('MyApp');
  Mojolicious::Commands->start_app(MyApp => @ARGV);

Load application from class and start the command line interface for it. Note that the options C<-h>/C<--help>,
C<--home> and C<-m>/C<--mode>, which are shared by all commands, will be parsed from C<@ARGV> during compile time.

  # Always start daemon for application
  Mojolicious::Commands->start_app('MyApp', 'daemon', '-l', 'http://*:8080');

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Command;
use Mojo::Base -base;

use Carp         qw(croak);
use Mojo::File   qw(path);
use Mojo::Loader qw(data_section);
use Mojo::Server;
use Mojo::Template;

has app => sub { $_[0]{app_ref} = Mojo::Server->new->build_app('Mojo::HelloWorld') }, weak => 1;
has description => 'No description';
has 'quiet';
has template => sub { {vars => 1} };
has usage    => "Usage: APPLICATION\n";

sub chmod_file {
  my ($self, $path, $mode) = @_;
  path($path)->chmod($mode);
  return $self->_loud("  [chmod] $path " . sprintf('%lo', $mode));
}

sub chmod_rel_file { $_[0]->chmod_file($_[0]->rel_file($_[1]), $_[2]) }

sub create_dir {
  my ($self, $path) = @_;
  return $self->_loud("  [exist] $path") if -d $path;
  path($path)->make_path;
  return $self->_loud("  [mkdir] $path");
}

sub create_rel_dir { $_[0]->create_dir($_[0]->rel_file($_[1])) }

sub extract_usage { Mojo::Util::extract_usage((caller)[1]) }

sub help { print shift->usage }

sub rel_file { path->child(split(/\//, pop)) }

sub render_data {
  my ($self, $name) = (shift, shift);
  my $template = Mojo::Template->new($self->template)->name("template $name from DATA section");
  my $output   = $template->render(data_section(ref $self, $name), @_);
  return ref $output ? die $output : $output;
}

sub render_to_file {
  my ($self, $data, $path) = (shift, shift, shift);
  return $self->write_file($path, $self->render_data($data, @_));
}

sub render_to_rel_file {
  my $self = shift;
  $self->render_to_file(shift, $self->rel_file(shift), @_);
}

sub run { croak 'Method "run" not implemented by subclass' }

sub write_file {
  my ($self, $path, $data) = @_;
  return $self->_loud("  [exist] $path") if -f $path;
  $self->create_dir(path($path)->dirname);
  path($path)->spurt($data);
  return $self->_loud("  [write] $path");
}

sub write_rel_file { $_[0]->write_file($_[0]->rel_file($_[1]), $_[2]) }

sub _loud {
  my ($self, $msg) = @_;
  say $msg unless $self->quiet;
  return $self;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Command - Command base class

=head1 SYNOPSIS

  # Lowercase command name
  package Mojolicious::Command::mycommand;
  use Mojo::Base 'Mojolicious::Command', -signatures;

  # Short description
  has description => 'My first Mojo command';

  # Usage message from SYNOPSIS
  has usage => sub ($self) { $self->extract_usage };

  sub run ($self, @args) {

    # Magic here! :)
  }

  =head1 SYNOPSIS

    Usage: APPLICATION mycommand [OPTIONS]

    Options:
      -s, --something   Does something

  =cut

=head1 DESCRIPTION

L<Mojolicious::Command> is an abstract base class for L<Mojolicious> commands.

See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are available by default.

=head1 ATTRIBUTES

L<Mojolicious::Command> implements the following attributes.

=head2 app

  my $app  = $command->app;
  $command = $command->app(Mojolicious->new);

Application for command, defaults to a L<Mojo::HelloWorld> object. Note that this attribute is weakened.

  # Introspect
  say "Template path: $_" for @{$command->app->renderer->paths};

=head2 description

  my $description = $command->description;
  $command        = $command->description('Foo');

Short description of command, used for the command list.

=head2 quiet

  my $bool = $command->quiet;
  $command = $command->quiet($bool);

Limited command output.

=head2 template

  my $template = $command->template;
  $command     = $command->template({vars => 1});

Attribute values passed to L<Mojo::Template> objects used to render templates with L</"render_data">, defaults to
activating C<vars>.

=head2 usage

  my $usage = $command->usage;
  $command  = $command->usage('Foo');

Usage information for command, used for the help screen.

=head1 METHODS

L<Mojolicious::Command> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 chmod_file

  $command = $command->chmod_file('/home/sri/foo.txt', 0644);

Change mode of a file.

=head2 chmod_rel_file

  $command = $command->chmod_rel_file('foo/foo.txt', 0644);

Portably change mode of a file relative to the current working directory.

=head2 create_dir

  $command = $command->create_dir('/home/sri/foo/bar');

Create a directory if it does not exist already.

=head2 create_rel_dir

  $command = $command->create_rel_dir('foo/bar/baz');

Portably create a directory relative to the current working directory if it does not exist already.

=head2 extract_usage

  my $usage = $command->extract_usage;

Extract usage message from the SYNOPSIS section of the file this method was called from with
L<Mojo::Util/"extract_usage">.

=head2 help

  $command->help;

Print usage information for command.

=head2 rel_file

  my $path = $command->rel_file('foo/bar.txt');

Return a L<Mojo::File> object relative to the current working directory.

=head2 render_data

  my $data = $command->render_data('foo_bar');
  my $data = $command->render_data('foo_bar', @args);
  my $data = $command->render_data('foo_bar', {foo => 'bar'});

Render a template from the C<DATA> section of the command class with L<Mojo::Loader> and L<Mojo::Template>. The
template can be configured with L</"template">.

=head2 render_to_file

  $command = $command->render_to_file('foo_bar', '/home/sri/foo.txt');
  $command = $command->render_to_file('foo_bar', '/home/sri/foo.txt', @args);
  $command = $command->render_to_file(
    'foo_bar', '/home/sri/foo.txt', {foo => 'bar'});

Render a template with L</"render_data"> to a file if it does not exist already, and create the directory if necessary.

=head2 render_to_rel_file

  $command = $command->render_to_rel_file('foo_bar', 'foo/bar.txt');
  $command = $command->render_to_rel_file('foo_bar', 'foo/bar.txt', @args);
  $command = $command->render_to_rel_file(
    'foo_bar', 'foo/bar.txt', {foo => 'bar'});

Portably render a template with L</"render_data"> to a file relative to the current working directory if it does not
exist already, and create the directory if necessary.

=head2 run

  $command->run;
  $command->run(@ARGV);

Run command. Meant to be overloaded in a subclass.

=head2 write_file

  $command = $command->write_file('/home/sri/foo.txt', 'Hello World!');

Write text to a file if it does not exist already, and create the directory if necessary.

=head2 write_rel_file

  $command = $command->write_rel_file('foo/bar.txt', 'Hello World!');

Portably write text to a file relative to the current working directory if it does not exist already, and create the
directory if necessary.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Controller;
use Mojo::Base -base;

# No imports, for security reasons!
use Carp        ();
use Digest::SHA ();
use Mojo::ByteStream;
use Mojo::DynamicMethods -dispatch;
use Mojo::URL;
use Mojo::Util;
use Mojolicious::Routes::Match;
use Scalar::Util ();

has [qw(app tx)] => undef, weak => 1;
has match => sub { Mojolicious::Routes::Match->new(root => shift->app->routes) };

sub BUILD_DYNAMIC {
  my ($class, $method, $dyn_methods) = @_;

  return sub {
    my $self    = shift;
    my $dynamic = $dyn_methods->{$self->{app}{renderer}}{$method};
    return $self->$dynamic(@_) if $dynamic;
    my $package = ref $self;
    Carp::croak qq{Can't locate object method "$method" via package "$package"};
  };
}

sub continue { $_[0]->app->routes->continue($_[0]) }

sub cookie {
  my ($self, $name) = (shift, shift);

  # Response cookie
  if (@_) {

    # Cookie too big
    my $cookie = {name => $name, value => shift, %{shift // {}}};
    $self->helpers->log->error(qq{Cookie "$name" is bigger than 4KiB}) if length $cookie->{value} > 4096;

    $self->res->cookies($cookie);
    return $self;
  }

  # Request cookies
  return undef unless my $cookie = $self->req->cookie($name);
  return $cookie->value;
}

sub every_cookie { [map { $_->value } @{shift->req->every_cookie(shift)}] }

sub every_param {
  my ($self, $name) = @_;

  # Captured unreserved values
  my $captures = $self->stash->{'mojo.captures'} //= {};
  if (exists $captures->{$name} && !$self->app->routes->is_reserved($name)) {
    my $value = $captures->{$name};
    return ref $value eq 'ARRAY' ? $value : [$value];
  }

  # Uploads or param values
  my $req     = $self->req;
  my $uploads = $req->every_upload($name);
  return @$uploads ? $uploads : $req->every_param($name);
}

sub every_signed_cookie {
  my ($self, $name) = @_;

  my $secrets = $self->app->secrets;
  my @results;
  for my $value (@{$self->every_cookie($name)}) {

    # Check signature with rotating secrets
    if ($value =~ s/--([^\-]+)$//) {
      my $signature = $1;

      my $valid;
      for my $secret (@$secrets) {
        my $check = Digest::SHA::hmac_sha256_hex("$name=$value", $secret);
        ++$valid and last if Mojo::Util::secure_compare($signature, $check);
      }
      if ($valid) { push @results, $value }

      else { $self->helpers->log->trace(qq{Cookie "$name" has bad signature}) }
    }

    else { $self->helpers->log->trace(qq{Cookie "$name" is not signed}) }
  }

  return \@results;
}

sub finish {
  my $self = shift;

  # WebSocket
  my $tx = $self->tx || Carp::croak 'Transaction already destroyed';
  $tx->finish(@_) and return $tx->established ? $self : $self->rendered(101) if $tx->is_websocket;

  # Chunked stream
  return @_ ? $self->write_chunk(@_)->write_chunk('') : $self->write_chunk('') if $tx->res->content->is_chunked;

  # Normal stream
  return @_ ? $self->write(@_)->write('') : $self->write('');
}

sub helpers { $_[0]->app->renderer->get_helper('')->($_[0]) }

sub on {
  my ($self, $name, $cb) = @_;
  my $tx = $self->tx || Carp::croak 'Transaction already destroyed';
  $self->rendered(101) if $tx->is_websocket && !$tx->established;
  return $tx->on($name => sub { shift; $self->$cb(@_) });
}

sub param {
  my ($self, $name) = (shift, shift);
  return $self->every_param($name)->[-1] unless @_;
  $self->stash->{'mojo.captures'}{$name} = @_ > 1 ? [@_] : $_[0];
  return $self;
}

sub render {
  my $self = shift;

  # Template may be first argument
  my ($template, $args) = (@_ % 2 ? shift : undef, {@_});
  $args->{template} = $template if $template;
  my $app     = $self->app;
  my $plugins = $app->plugins->emit_hook(before_render => $self, $args);

  # Localize "extends" and "layout" to allow argument overrides
  my ($maybe, $ts) = @{$args}{'mojo.maybe', 'mojo.string'};
  my $stash = $self->stash;
  local $stash->{layout}  = $stash->{layout}  if exists $stash->{layout};
  local $stash->{extends} = $stash->{extends} if exists $stash->{extends};

  # Rendering to string
  local @{$stash}{keys %$args}         if $ts || $maybe;
  delete @{$stash}{qw(layout extends)} if $ts;

  # All other arguments just become part of the stash
  @$stash{keys %$args} = values %$args;
  my $renderer = $app->renderer;
  my ($output, $format) = $renderer->render($self);

  # Maybe no 404
  return defined $output ? Mojo::ByteStream->new($output) : undef if $ts;
  return $maybe          ? undef : Carp::croak("Could not render a response") unless defined $output;

  $plugins->emit_hook(after_render => $self, \$output, $format);
  return $renderer->respond($self, $output, $format, $stash->{status});
}

sub render_later { shift->stash('mojo.rendered' => 1) }

sub render_maybe { shift->render(@_, 'mojo.maybe' => 1) }

sub render_to_string { shift->render(@_, 'mojo.string' => 1) }

sub rendered {
  my ($self, $status) = @_;

  # Make sure we have a status
  $self->res->code($status) if $status;

  # Finish transaction
  my $stash = $self->stash;
  if (!$stash->{'mojo.finished'} && ++$stash->{'mojo.finished'}) {
    my $res = $self->res;
    $res->code(200) if !$status && !$res->code;

    # Disable auto rendering and stop timer
    my $app = $self->render_later->app;
    $self->helpers->log->trace(sub {
      my $timing  = $self->helpers->timing;
      my $elapsed = $timing->elapsed('mojo.timer') // 0;
      my $rps     = $timing->rps($elapsed)         // '??';
      my $code    = $res->code;
      my $msg     = $res->message || $res->default_message($code);
      return "$code $msg (${elapsed}s, $rps/s)";
    }) unless $stash->{'mojo.static'};

    $app->plugins->emit_hook_reverse(after_dispatch => $self);
    $app->sessions->store($self);
  }
  $self->tx->resume;
  return $self;
}

sub req { (shift->tx || Carp::croak 'Transaction already destroyed')->req }
sub res { (shift->tx || Carp::croak 'Transaction already destroyed')->res }

sub send {
  my ($self, $msg, $cb) = @_;
  my $tx = $self->tx || Carp::croak 'Transaction already destroyed';
  Carp::croak 'No WebSocket connection to send message to' unless $tx->is_websocket;
  $tx->send($msg, $cb ? sub { shift; $self->$cb(@_) } : ());
  return $tx->established ? $self : $self->rendered(101);
}

sub session {
  my $self = shift;

  my $stash = $self->stash;
  $self->app->sessions->load($self) unless exists $stash->{'mojo.active_session'};

  # Hash
  my $session = $stash->{'mojo.session'} //= {};
  return $session unless @_;

  # Get
  return $session->{$_[0]} unless @_ > 1 || ref $_[0];

  # Set
  my $values = ref $_[0] ? $_[0] : {@_};
  @$session{keys %$values} = values %$values;

  return $self;
}

sub signed_cookie {
  my ($self, $name, $value, $options) = @_;

  # Request cookie
  return $self->every_signed_cookie($name)->[-1] unless defined $value;

  # Response cookie
  my $sum = Digest::SHA::hmac_sha256_hex("$name=$value", $self->app->secrets->[0]);
  return $self->cookie($name, "$value--$sum", $options);
}

sub stash { Mojo::Util::_stash(stash => @_) }

sub url_for {
  my ($self, $target) = (shift, shift // '');

  # Absolute URL
  return $target                 if Scalar::Util::blessed $target && $target->isa('Mojo::URL');
  return Mojo::URL->new($target) if $target =~ m!^(?:[^:/?#]+:|//|#)!;

  # Base
  my $url  = Mojo::URL->new;
  my $req  = $self->req;
  my $base = $url->base($req->url->base->clone)->base->userinfo(undef);

  # Relative URL
  my $path = $url->path;
  if ($target =~ m!^/!) {
    if (defined(my $prefix = $self->stash->{path})) {
      my $real = $req->url->path->to_route;
      $real =~ s!/?\Q$prefix\E$!$target!;
      $target = $real;
    }
    $url->parse($target);
  }

  # Route
  else {
    my $generated = $self->match->path_for($target, @_);
    $path->parse($generated->{path})                         if $generated->{path};
    $base->scheme($base->protocol eq 'https' ? 'wss' : 'ws') if $generated->{websocket};
  }

  # Make path absolute
  my $base_path = $base->path;
  unshift @{$path->parts}, @{$base_path->parts};
  $base_path->parts([])->trailing_slash(0);

  return $url;
}

sub url_for_asset {
  my ($self, $asset) = @_;
  return $self->url_for($self->app->static->asset_path($asset));
}

sub write {
  my ($self, $chunk, $cb) = @_;
  $self->res->content->write($chunk, $cb ? sub { shift; $self->$cb(@_) } : ());
  return $self->rendered;
}

sub write_chunk {
  my ($self, $chunk, $cb) = @_;
  $self->res->content->write_chunk($chunk, $cb ? sub { shift; $self->$cb(@_) } : ());
  return $self->rendered;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Controller - Controller base class

=head1 SYNOPSIS

  # Controller
  package MyApp::Controller::Foo;
  use Mojo::Base 'Mojolicious::Controller', -signatures;

  # Action
  sub bar ($self) {
    my $name = $self->param('name');
    $self->res->headers->cache_control('max-age=1, no-cache');
    $self->render(json => {hello => $name});
  }

=head1 DESCRIPTION

L<Mojolicious::Controller> is the base class for your L<Mojolicious> controllers. It is also the default controller
class unless you set L<Mojolicious/"controller_class">.

=head1 ATTRIBUTES

L<Mojolicious::Controller> implements the following attributes.

=head2 app

  my $app = $c->app;
  $c      = $c->app(Mojolicious->new);

A reference back to the application that dispatched to this controller, usually a L<Mojolicious> object. Note that this
attribute is weakened.

  # Use application logger
  $c->app->log->debug('Hello Mojo');

  # Generate path
  my $path = $c->app->home->child('templates', 'foo', 'bar.html.ep');

=head2 match

  my $m = $c->match;
  $c    = $c->match(Mojolicious::Routes::Match->new);

Router results for the current request, defaults to a L<Mojolicious::Routes::Match> object.

  # Introspect
  my $name   = $c->match->endpoint->name;
  my $foo    = $c->match->endpoint->pattern->defaults->{foo};
  my $action = $c->match->stack->[-1]{action};

=head2 tx

  my $tx = $c->tx;
  $c     = $c->tx(Mojo::Transaction::HTTP->new);

The transaction that is currently being processed, usually a L<Mojo::Transaction::HTTP> or
L<Mojo::Transaction::WebSocket> object. Note that this attribute is weakened. So the object needs to be referenced
elsewhere as well when you're performing non-blocking operations and the underlying connection might get closed early.

  # Check peer information
  my $address = $c->tx->remote_address;
  my $port    = $c->tx->remote_port;

  # Increase size limit for WebSocket messages to 16MiB
  $c->tx->max_websocket_size(16777216) if $c->tx->is_websocket;

  # Perform non-blocking operation without knowing the connection status
  my $tx = $c->tx;
  Mojo::IOLoop->timer(2 => sub {
    $c->app->log->debug($tx->is_finished ? 'Finished' : 'In progress');
  });

=head1 METHODS

L<Mojolicious::Controller> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 continue

  $c->continue;

Continue dispatch chain from an intermediate destination with L<Mojolicious::Routes/"continue">.

=head2 cookie

  my $value = $c->cookie('foo');
  $c        = $c->cookie(foo => 'bar');
  $c        = $c->cookie(foo => 'bar', {path => '/'});

Access request cookie values and create new response cookies. If there are multiple values sharing the same name, and
you want to access more than just the last one, you can use L</"every_cookie">.

  # Create response cookie with domain and expiration date
  $c->cookie(user => 'sri', {domain => 'example.com', expires => time + 60});

  # Create secure response cookie
  $c->cookie(secret => 'I <3 Mojolicious', {secure => 1, httponly => 1});

=head2 every_cookie

  my $values = $c->every_cookie('foo');

Similar to L</"cookie">, but returns all request cookie values sharing the same name as an array reference.

  $ Get first cookie value
  my $first = $c->every_cookie('foo')->[0];

=head2 every_param

  my $values = $c->every_param('foo');

Similar to L</"param">, but returns all values sharing the same name as an array reference.

  # Get first value
  my $first = $c->every_param('foo')->[0];

=head2 every_signed_cookie

  my $values = $c->every_signed_cookie('foo');

Similar to L</"signed_cookie">, but returns all signed request cookie values sharing the same name as an array
reference.

  # Get first signed cookie value
  my $first = $c->every_signed_cookie('foo')->[0];

=head2 finish

  $c = $c->finish;
  $c = $c->finish(1000);
  $c = $c->finish(1003 => 'Cannot accept data!');
  $c = $c->finish('Bye!');

Close WebSocket connection or long poll stream gracefully. This method will automatically respond to WebSocket
handshake requests with a C<101> response status, to establish the WebSocket connection.

=head2 helpers

  my $helpers = $c->helpers;

Return a proxy object containing the current controller object and on which helpers provided by L</"app"> can be
called. This includes all helpers from L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.

  # Make sure to use the "title" helper and not the controller method
  $c->helpers->title('Welcome!');

  # Use a nested helper instead of the "reply" controller method
  $c->helpers->reply->not_found;

=head2 on

  my $cb = $c->on(finish => sub {...});

Subscribe to events of L</"tx">, which is usually a L<Mojo::Transaction::HTTP> or L<Mojo::Transaction::WebSocket>
object. This method will automatically respond to WebSocket handshake requests with a C<101> response status, to
establish the WebSocket connection.

  # Do something after the transaction has been finished
  $c->on(finish => sub ($c) {
    $c->app->log->debug('All data has been sent');
  });

  # Receive WebSocket message
  $c->on(message => sub ($c, $msg) {
    $c->app->log->debug("Message: $msg");
  });

  # Receive JSON object via WebSocket message
  $c->on(json => sub ($c, $hash) {
    $c->app->log->debug("Test: $hash->{test}");
  });

  # Receive WebSocket "Binary" message
  $c->on(binary => sub ($c, $bytes) {
    my $len = length $bytes;
    $c->app->log->debug("Received $len bytes");
  });

=head2 param

  my $value = $c->param('foo');
  $c        = $c->param(foo => 'ba;r');
  $c        = $c->param(foo => 'ba;r', 'baz');
  $c        = $c->param(foo => ['ba;r', 'baz']);

Access route placeholder values that are not reserved stash values, file uploads as well as C<GET> and C<POST>
parameters extracted from the query string and C<application/x-www-form-urlencoded> or C<multipart/form-data> message
body, in that order. If there are multiple values sharing the same name, and you want to access more than just the last
one, you can use L</"every_param">. Parts of the request body need to be loaded into memory to parse C<POST>
parameters, so you have to make sure it is not excessively large. There's a 16MiB limit for requests by default.

  # Get first value
  my $first = $c->every_param('foo')->[0];

For more control you can also access request information directly.

  # Only GET parameters
  my $foo = $c->req->query_params->param('foo');

  # Only POST parameters
  my $foo = $c->req->body_params->param('foo');

  # Only GET and POST parameters
  my $foo = $c->req->param('foo');

  # Only file uploads
  my $foo = $c->req->upload('foo');

=head2 render

  my $bool = $c->render;
  my $bool = $c->render(foo => 'bar', baz => 23);
  my $bool = $c->render(template => 'foo/index');
  my $bool = $c->render(template => 'index', format => 'html');
  my $bool = $c->render(data => $bytes);
  my $bool = $c->render(text => 'Hello!');
  my $bool = $c->render(json => {foo => 'bar'});
  my $bool = $c->render(handler => 'something');
  my $bool = $c->render('foo/index');

Render content with L<Mojolicious/"renderer"> and emit hooks L<Mojolicious/"before_render"> as well as
L<Mojolicious/"after_render">, or dies if no response could be generated. All additional key/value pairs get merged into
the L</"stash">.

  # Render characters
  $c->render(text => 'I â™¥ Mojolicious!');

  # Render characters (alternative)
  $c->stash(text => 'I â™¥ Mojolicious!')->render;

  # Render binary data
  use Mojo::JSON qw(encode_json);
  $c->render(data => encode_json({test => 'I â™¥ Mojolicious!'}));

  # Render JSON
  $c->render(json => {test => 'I â™¥ Mojolicious!'});

  # Render inline template
  $c->render(inline => '<%= 1 + 1 %>');

  # Render template "foo/bar.html.ep"
  $c->render(template => 'foo/bar', format => 'html', handler => 'ep');

  # Render template "test.*.*" with arbitrary values "foo" and "bar"
  $c->render(template => 'test', foo => 'test', bar => 23);

  # Render template "test.xml.*"
  $c->render(template => 'test', format => 'xml');

  # Render template "test.xml.*" (alternative)
  $c->render('test', format => 'xml');

=head2 render_later

  $c = $c->render_later;

Disable automatic rendering to delay response generation, only necessary if automatic rendering would result in a
response.

  # Delayed rendering
  $c->render_later;
  Mojo::IOLoop->timer(2 => sub { $c->render(text => 'Delayed by 2 seconds!') });

=head2 render_maybe

  my $bool = $c->render_maybe;
  my $bool = $c->render_maybe(foo => 'bar', baz => 23);
  my $bool = $c->render_maybe('foo/index', format => 'html');

Try to render content, but do not call L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>not_found"> if no response
could be generated, all arguments get localized automatically and are only available during this render operation,
takes the same arguments as L</"render">.

  # Render template "index_local" only if it exists
  $c->render_maybe('index_local') or $c->render('index');

=head2 render_to_string

  my $output = $c->render_to_string('foo/index', format => 'pdf');

Try to render content and return it wrapped in a L<Mojo::ByteStream> object or return C<undef>, all arguments get
localized automatically and are only available during this render operation, takes the same arguments as L</"render">.

  # Render inline template
  my $two = $c->render_to_string(inline => '<%= 1 + 1 %>');

=head2 rendered

  $c = $c->rendered;
  $c = $c->rendered(302);

Finalize response and emit hook L<Mojolicious/"after_dispatch">, defaults to using a C<200> response code.

  # Custom response
  $c->res->headers->content_type('text/plain');
  $c->res->body('Hello World!');
  $c->rendered(200);

=head2 req

  my $req = $c->req;

Get L<Mojo::Message::Request> object from L</"tx">.

  # Longer version
  my $req = $c->tx->req;

  # Extract request information
  my $id     = $c->req->request_id;
  my $method = $c->req->method;
  my $url    = $c->req->url->to_abs;
  my $info   = $c->req->url->to_abs->userinfo;
  my $host   = $c->req->url->to_abs->host;
  my $agent  = $c->req->headers->user_agent;
  my $custom = $c->req->headers->header('Custom-Header');
  my $bytes  = $c->req->body;
  my $str    = $c->req->text;
  my $hash   = $c->req->params->to_hash;
  my $all    = $c->req->uploads;
  my $value  = $c->req->json;
  my $foo    = $c->req->json('/23/foo');
  my $dom    = $c->req->dom;
  my $bar    = $c->req->dom('div.bar')->first->text;

=head2 res

  my $res = $c->res;

Get L<Mojo::Message::Response> object from L</"tx">.

  # Longer version
  my $res = $c->tx->res;

  # Force file download by setting a response header
  $c->res->headers->content_disposition('attachment; filename=foo.png;');

  # Use a custom response header
  $c->res->headers->header('Custom-Header' => 'whatever');

  # Make sure response is cached correctly
  $c->res->headers->cache_control('public, max-age=300');
  $c->res->headers->append(Vary => 'Accept-Encoding');

=head2 send

  $c = $c->send({binary => $bytes});
  $c = $c->send({text   => $bytes});
  $c = $c->send({json   => {test => [1, 2, 3]}});
  $c = $c->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
  $c = $c->send($chars);
  $c = $c->send($chars => sub ($c) {...});

Send message or frame non-blocking via WebSocket, the optional drain callback will be executed once all data has been
written. This method will automatically respond to WebSocket handshake requests with a C<101> response status, to
establish the WebSocket connection.

  # Send "Text" message
  $c->send('I â™¥ Mojolicious!');

  # Send JSON object as "Text" message
  $c->send({json => {test => 'I â™¥ Mojolicious!'}});

  # Send JSON object as "Binary" message
  use Mojo::JSON qw(encode_json);
  $c->send({binary => encode_json({test => 'I â™¥ Mojolicious!'})});

  # Send "Ping" frame
  use Mojo::WebSocket qw(WS_PING);
  $c->send([1, 0, 0, 0, WS_PING, 'Hello World!']);

  # Make sure the first message has been written before continuing
  $c->send('First message!' => sub ($c) { $c->send('Second message!') });

For mostly idle WebSockets you might also want to increase the inactivity timeout with
L<Mojolicious::Plugin::DefaultHelpers/"inactivity_timeout">, which usually defaults to C<30> seconds.

  # Increase inactivity timeout for connection to 300 seconds
  $c->inactivity_timeout(300);

=head2 session

  my $session = $c->session;
  my $foo     = $c->session('foo');
  $c          = $c->session({foo => 'bar'});
  $c          = $c->session(foo => 'bar');

Persistent data storage for the next few requests, all session data gets serialized with L<Mojo::JSON> and stored
Base64 encoded in HMAC-SHA256 signed cookies, to prevent tampering. Note that cookies usually have a C<4096> byte
(4KiB) limit, depending on browser.

  # Manipulate session
  $c->session->{foo} = 'bar';
  my $foo = $c->session->{foo};
  delete $c->session->{foo};

  # Expiration date in seconds from now (persists between requests)
  $c->session(expiration => 604800);

  # Expiration date as absolute epoch time (only valid for one request)
  $c->session(expires => time + 604800);

  # Delete whole session by setting an expiration date in the past
  $c->session(expires => 1);

=head2 signed_cookie

  my $value = $c->signed_cookie('foo');
  $c        = $c->signed_cookie(foo => 'bar');
  $c        = $c->signed_cookie(foo => 'bar', {path => '/'});

Access signed request cookie values and create new signed response cookies. If there are multiple values sharing the
same name, and you want to access more than just the last one, you can use L</"every_signed_cookie">. Cookies are
cryptographically signed with HMAC-SHA256, to prevent tampering, and the ones failing signature verification will be
automatically discarded.

=head2 stash

  my $hash = $c->stash;
  my $foo  = $c->stash('foo');
  $c       = $c->stash({foo => 'bar', baz => 23});
  $c       = $c->stash(foo => 'bar', baz => 23);

Non-persistent data storage and exchange for the current request, application wide default values can be set with
L<Mojolicious/"defaults">. Some stash values have a special meaning and are reserved, the full list is currently
C<action>, C<app>, C<cb>, C<controller>, C<data>, C<extends>, C<format>, C<handler>, C<inline>, C<json>, C<layout>,
C<namespace>, C<path>, C<status>, C<template>, C<text> and C<variant>. Note that all stash values with a C<mojo.*>
prefix are reserved for internal use.

  # Remove value
  my $foo = delete $c->stash->{foo};

  # Assign multiple values at once
  $c->stash(foo => 'test', bar => 23);

=head2 url_for

  my $url = $c->url_for;
  my $url = $c->url_for(name => 'sebastian');
  my $url = $c->url_for({name => 'sebastian'});
  my $url = $c->url_for('test', name => 'sebastian');
  my $url = $c->url_for('test', {name => 'sebastian'});
  my $url = $c->url_for('/index.html');
  my $url = $c->url_for('//example.com/index.html');
  my $url = $c->url_for('http://example.com/index.html');
  my $url = $c->url_for('mailto:sri@example.com');
  my $url = $c->url_for('#whatever');

Generate a portable L<Mojo::URL> object with base for a path, URL or route.

  # Rebuild URL for the current route
  $c->url_for;

  # Rebuild URL for the current route, but replace the "name" placeholder value
  $c->url_for(name => 'sebastian');

  # Absolute URL for the current route
  $c->url_for->to_abs;

  # Build URL for route "test" with two placeholder values
  $c->url_for('test', name => 'sebastian', foo => 'bar');

  # "http://127.0.0.1:3000/index.html" if application was started with Morbo
  $c->url_for('/index.html')->to_abs;

  # "https://127.0.0.1:443/index.html" if application was started with Morbo
  $c->url_for('/index.html')->to_abs->scheme('https')->port(443);

  # "/index.html?foo=bar" if application is deployed under "/"
  $c->url_for('/index.html')->query(foo => 'bar');

  # "/myapp/index.html?foo=bar" if application is deployed under "/myapp"
  $c->url_for('/index.html')->query(foo => 'bar');

You can also use the helper L<Mojolicious::Plugin::DefaultHelpers/"url_with"> to inherit query parameters from the
current request.

  # "/list?q=mojo&page=2" if current request was for "/list?q=mojo&page=1"
  $c->url_with->query({page => 2});


=head2 url_for_asset

  my $url = $c->url_for_asset('/app.js');

Generate a portable L<Mojo::URL> object with base for a static asset.

=head2 write

  $c = $c->write;
  $c = $c->write('');
  $c = $c->write($bytes);
  $c = $c->write($bytes => sub ($c) {...});

Write dynamic content non-blocking, the optional drain callback will be executed once all data has been written.
Calling this method without a chunk of data will finalize the response headers and allow for dynamic content to be
written later.

  # Keep connection alive (with Content-Length header)
  $c->res->headers->content_length(6);
  $c->write('Hel' => sub ($c) { $c->write('lo!') });

  # Close connection when finished (without Content-Length header)
  $c->write('Hel' => sub ($c) {
    $c->write('lo!' => sub ($c) { $c->finish });
  });

You can call L</"finish"> or write an empty chunk of data at any time to end the stream.

  HTTP/1.1 200 OK
  Date: Sat, 13 Sep 2014 16:48:29 GMT
  Content-Length: 6
  Server: Mojolicious (Perl)

  Hello!

  HTTP/1.1 200 OK
  Connection: close
  Date: Sat, 13 Sep 2014 16:48:29 GMT
  Server: Mojolicious (Perl)

  Hello!

For Comet (long polling) you might also want to increase the inactivity timeout with
L<Mojolicious::Plugin::DefaultHelpers/"inactivity_timeout">, which usually defaults to C<30> seconds.

  # Increase inactivity timeout for connection to 300 seconds
  $c->inactivity_timeout(300);

=head2 write_chunk

  $c = $c->write_chunk;
  $c = $c->write_chunk('');
  $c = $c->write_chunk($bytes);
  $c = $c->write_chunk($bytes => sub ($c) {...});

Write dynamic content non-blocking with chunked transfer encoding, the optional drain callback will be executed once
all data has been written. Calling this method without a chunk of data will finalize the response headers and allow for
dynamic content to be written later.

  # Make sure previous chunk has been written before continuing
  $c->write_chunk('H' => sub ($c) {
    $c->write_chunk('ell' => sub ($c) { $c->finish('o!') });
  });

You can call L</"finish"> or write an empty chunk of data at any time to end the stream.

  HTTP/1.1 200 OK
  Date: Sat, 13 Sep 2014 16:48:29 GMT
  Transfer-Encoding: chunked
  Server: Mojolicious (Perl)

  1
  H
  3
  ell
  2
  o!
  0

=head1 HELPERS

In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call helpers provided by L</"app"> on
L<Mojolicious::Controller> objects. This includes all helpers from L<Mojolicious::Plugin::DefaultHelpers> and
L<Mojolicious::Plugin::TagHelpers>.

  # Call helpers
  $c->layout('green');
  $c->title('Welcome!');

  # Longer version
  $c->helpers->layout('green');

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Routes;
use Mojo::Base 'Mojolicious::Routes::Route';

use Carp       qw(croak);
use List::Util qw(first);
use Mojo::Cache;
use Mojo::DynamicMethods;
use Mojo::Loader qw(load_class);
use Mojo::Util   qw(camelize);

has base_classes               => sub { [qw(Mojolicious::Controller Mojolicious)] };
has cache                      => sub { Mojo::Cache->new };
has [qw(conditions shortcuts)] => sub { {} };
has types                      => sub { {num => qr/[0-9]+/} };
has namespaces                 => sub { [] };

sub add_condition { $_[0]->conditions->{$_[1]} = $_[2] and return $_[0] }

sub add_shortcut {
  my ($self, $name, $cb) = @_;
  $self->shortcuts->{$name} = $cb;
  Mojo::DynamicMethods::register 'Mojolicious::Routes::Route', $self, $name, $cb;
  return $self;
}

sub add_type { $_[0]->types->{$_[1]} = $_[2] and return $_[0] }

sub continue {
  my ($self, $c) = @_;

  my $match    = $c->match;
  my $stack    = $match->stack;
  my $position = $match->position;
  return _render($c) unless my $field = $stack->[$position];

  # Merge captures into stash
  my $stash = $c->stash;
  @{$stash->{'mojo.captures'} //= {}}{keys %$field} = values %$field;
  @$stash{keys %$field} = values %$field;

  my $continue;
  my $last = !$stack->[++$position];
  if (my $cb = $field->{cb}) { $continue = $self->_callback($c, $cb, $last) }
  else                       { $continue = $self->_controller($c, $field, $last) }
  $match->position($position);
  $self->continue($c) if $last || $continue;
}

sub dispatch {
  my ($self, $c) = @_;
  $self->match($c);
  @{$c->match->stack} ? $self->continue($c) : return undef;
  return 1;
}

sub lookup { ($_[0]{reverse} //= $_[0]->_index)->{$_[1]} }

sub match {
  my ($self, $c) = @_;

  # Path (partial path gets priority)
  my $req  = $c->req;
  my $path = $c->stash->{path};
  if (defined $path) { $path = "/$path" if $path !~ m!^/! }
  else               { $path = $req->url->path->to_route }

  # Method (HEAD will be treated as GET)
  my $method   = uc $req->method;
  my $override = $req->url->query->clone->param('_method');
  $method = uc $override if $override && $method eq 'POST';
  $method = 'GET'        if $method eq 'HEAD';

  # Check cache
  my $ws    = $c->tx->is_websocket ? 1 : 0;
  my $match = $c->match;
  $match->root($self);
  my $cache = $self->cache;
  if (my $result = $cache->get("$method:$path:$ws")) {
    return $match->endpoint($result->{endpoint})->stack($result->{stack});
  }

  # Check routes
  $match->find($c => {method => $method, path => $path, websocket => $ws});
  return undef unless my $route = $match->endpoint;
  $cache->set("$method:$path:$ws" => {endpoint => $route, stack => $match->stack});
}

sub _action { shift->plugins->emit_chain(around_action => @_) }

sub _callback {
  my ($self, $c, $cb, $last) = @_;
  $c->stash->{'mojo.routed'} = 1 if $last;
  $c->helpers->log->trace('Routing to a callback');
  return _action($c->app, $c, $cb, $last);
}

sub _class {
  my ($self, $c, $field) = @_;

  # Application instance
  return $field->{app} if ref $field->{app};

  # Application class
  my @classes;
  my $class = $field->{controller} ? camelize $field->{controller} : '';
  if ($field->{app}) { push @classes, $field->{app} }

  # Specific namespace
  elsif (defined(my $ns = $field->{namespace})) {
    croak qq{Namespace "$ns" requires a controller} unless $class;
    push @classes, $ns ? "${ns}::$class" : $class;
  }

  # All namespaces
  elsif ($class) { push @classes, "${_}::$class" for @{$self->namespaces} }

  # Try to load all classes
  my $log = $c->helpers->log;
  for my $class (@classes) {

    # Failed
    next                                         unless defined(my $found = $self->_load($class));
    croak qq{Class "$class" is not a controller} unless $found;

    # Success
    return $class->new(%$c);
  }

  # Nothing found
  return @classes ? croak qq{Controller "$classes[-1]" does not exist} : 0;
}

sub _controller {
  my ($self, $old, $field, $last) = @_;

  # Load and instantiate controller/application
  my $new;
  unless ($new = $self->_class($old, $field)) { return defined $new }

  # Application
  my $class = ref $new;
  my $log   = $old->helpers->log;
  if ($new->isa('Mojolicious')) {
    $log->trace(qq{Routing to application "$class"});

    # Try to connect routes
    if (my $sub = $new->can('routes')) {
      my $r = $new->$sub;
      $r->parent($old->match->endpoint) unless $r->parent;
    }
    $new->handler($old);
    $old->stash->{'mojo.routed'} = 1;
  }

  # Action
  elsif (my $method = $field->{action}) {
    $log->trace(qq{Routing to controller "$class" and action "$method"});

    if (my $sub = $new->can($method)) {
      $old->stash->{'mojo.routed'} = 1 if $last;
      return 1                         if _action($old->app, $new, $sub, $last);
    }

    else { $log->trace('Action not found in controller') }
  }

  else { croak qq{Controller "$class" requires an action} }

  return undef;
}

sub _load {
  my ($self, $app) = @_;

  # Load unless already loaded
  return 1 if $self->{loaded}{$app};
  if (my $e = load_class $app) { ref $e ? die $e : return undef }

  # Check base classes
  return 0 unless first { $app->isa($_) } @{$self->base_classes};
  return $self->{loaded}{$app} = 1;
}

sub _render {
  my $c     = shift;
  my $stash = $c->stash;
  return if $stash->{'mojo.rendered'};
  $c->render_maybe or $stash->{'mojo.routed'} or croak 'Route without action and nothing to render';
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Routes - Always find your destination with routes

=head1 SYNOPSIS

  use Mojolicious::Routes;

  # Simple route
  my $r = Mojolicious::Routes->new;
  $r->any('/')->to(controller => 'blog', action => 'welcome');

  # More advanced routes
  my $blog = $r->under('/blog');
  $blog->get('/list')->to('blog#list');
  $blog->get('/:id' => [id => qr/\d+/])->to('blog#show', id => 23);
  $blog->patch(sub ($c) { $c->render(text => 'Go away!', status => 405) });

=head1 DESCRIPTION

L<Mojolicious::Routes> is the core of the L<Mojolicious> web framework.

See L<Mojolicious::Guides::Routing> for more.

=head1 TYPES

These placeholder types are available by default.

=head2 num

  $r->get('/article/<id:num>');

Placeholder value needs to be a non-fractional number, similar to the regular expression C<([0-9]+)>.

=head1 ATTRIBUTES

L<Mojolicious::Routes> inherits all attributes from L<Mojolicious::Routes::Route> and implements the following new
ones.

=head2 base_classes

  my $classes = $r->base_classes;
  $r          = $r->base_classes(['MyApp::Controller']);

Base classes used to identify controllers, defaults to L<Mojolicious::Controller> and L<Mojolicious>.

=head2 cache

  my $cache = $r->cache;
  $r        = $r->cache(Mojo::Cache->new);

Routing cache, defaults to a L<Mojo::Cache> object.

=head2 conditions

  my $conditions = $r->conditions;
  $r             = $r->conditions({foo => sub {...}});

Contains all available conditions.

=head2 namespaces

  my $namespaces = $r->namespaces;
  $r             = $r->namespaces(['MyApp::Controller', 'MyApp']);

Namespaces to load controllers from.

  # Add another namespace to load controllers from
  push @{$r->namespaces}, 'MyApp::MyController';

=head2 shortcuts

  my $shortcuts = $r->shortcuts;
  $r            = $r->shortcuts({foo => sub {...}});

Contains all available shortcuts.

=head2 types

  my $types = $r->types;
  $r        = $r->types({lower => qr/[a-z]+/});

Registered placeholder types, by default only L</"num"> is already defined.

=head1 METHODS

L<Mojolicious::Routes> inherits all methods from L<Mojolicious::Routes::Route> and implements the following new ones.

=head2 add_condition

  $r = $r->add_condition(foo => sub ($route, $c, $captures, $arg) {...});

Register a condition.

  $r->add_condition(foo => sub ($route, $c, $captures, $arg) {
    ...
    return 1;
  });

=head2 add_shortcut

  $r = $r->add_shortcut(foo => sub ($route, @args) {...});

Register a shortcut.

  $r->add_shortcut(foo => sub ($route, @args) {...});

=head2 add_type

  $r = $r->add_type(foo => qr/\w+/);
  $r = $r->add_type(foo => ['bar', 'baz']);

Register a placeholder type.

  $r->add_type(lower => qr/[a-z]+/);

=head2 continue

  $r->continue(Mojolicious::Controller->new);

Continue dispatch chain and emit the hook L<Mojolicious/"around_action"> for every action.

=head2 dispatch

  my $bool = $r->dispatch(Mojolicious::Controller->new);

Match routes with L</"match"> and dispatch with L</"continue">.

=head2 lookup

  my $route = $r->lookup('foo');

Find route by name with L<Mojolicious::Routes::Route/"find"> and cache all results for future lookups.

=head2 match

  $r->match(Mojolicious::Controller->new);

Match routes with L<Mojolicious::Routes::Match>.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious::Lite;
use Mojo::Base 'Mojolicious';

# "Bender: Bite my shiny metal ass!"
use Mojo::File qw(path);
use Mojo::UserAgent::Server;
use Mojo::Util qw(monkey_patch);

sub import {

  # Remember executable for later
  $ENV{MOJO_EXE} ||= (caller)[1];

  # Reuse home directory if possible
  local $ENV{MOJO_HOME} = path($ENV{MOJO_EXE})->dirname->to_string unless $ENV{MOJO_HOME};

  # Initialize application class
  my $caller = caller;
  no strict 'refs';
  push @{"${caller}::ISA"}, 'Mojolicious';

  # Generate moniker based on filename
  my $moniker = path($ENV{MOJO_EXE})->basename('.pl', '.pm', '.t');
  my $app     = shift->new(moniker => $moniker);

  # Initialize routes without namespaces
  my $routes = $app->routes->namespaces([]);
  $app->static->classes->[0] = $app->renderer->classes->[0] = $caller;

  # The Mojolicious::Lite DSL
  my $root = $routes;
  for my $name (qw(any get options patch post put websocket)) {
    monkey_patch $caller, $name, sub { $routes->$name(@_) }
  }
  monkey_patch($caller, $_, sub {$app}) for qw(new app);
  monkey_patch $caller, del   => sub { $routes->delete(@_) };
  monkey_patch $caller, group => sub (&) {
    (my $old, $root) = ($root, $routes);
    shift->();
    ($routes, $root) = ($root, $old);
  };
  monkey_patch $caller,
    helper => sub { $app->helper(@_) },
    hook   => sub { $app->hook(@_) },
    plugin => sub { $app->plugin(@_) },
    under  => sub { $routes = $root->under(@_) };

  # Make sure there's a default application for testing
  Mojo::UserAgent::Server->app($app) unless Mojo::UserAgent::Server->app;

  # Lite apps are strict!
  unshift @_, 'Mojo::Base', '-strict';
  goto &Mojo::Base::import;
}

1;

=encoding utf8

=head1 NAME

Mojolicious::Lite - Micro real-time web framework

=head1 SYNOPSIS

  # Automatically enables "strict", "warnings", "utf8" and Perl 5.16 features
  use Mojolicious::Lite -signatures;

  # Route with placeholder
  get '/:foo' => sub ($c) {
    my $foo = $c->param('foo');
    $c->render(text => "Hello from $foo.");
  };

  # Start the Mojolicious command system
  app->start;

=head1 DESCRIPTION

L<Mojolicious::Lite> is a tiny domain specific language built around L<Mojolicious>, made up of only about a dozen Perl
functions.

On Perl 5.20+ you can also use a C<-signatures> flag to enable support for L<subroutine
signatures|perlsub/"Signatures">.

  use Mojolicious::Lite -signatures;

  get '/:foo' => sub ($c) {
    my $foo = $c->param('foo');
    $c->render(text => "Hello from $foo.");
  };

  app->start;

See L<Mojolicious::Guides::Tutorial> for more!

=head1 GROWING

While L<Mojolicious::Guides::Growing> will give you a detailed introduction to growing a L<Mojolicious::Lite> prototype
into a well-structured L<Mojolicious> application, here we have collected a few snippets that illustrate very well just
how similar both of them are.

=head2 Routes

The functions L</"get">, L</"post"> and friends all have equivalent methods.

  # Mojolicious::Lite
  get '/foo' => sub ($c) {
    $c->render(text => 'Hello World!');
  };

  # Mojolicious
  sub startup ($self) {
  
    my $routes = $self->routes;
    $routes->get('/foo' => sub ($c) {
      $c->render(text => 'Hello World!');
    });
  }

=head2 Application

The application object you can access with the function L</"app"> is the first argument passed to the C<startup>
method.

  # Mojolicious::Lite
  app->max_request_size(16777216);

  # Mojolicious
  sub startup ($self) {
    $self->max_request_size(16777216);
  }

=head2 Plugins

Instead of the L</"plugin"> function you just use the method L<Mojolicious/"plugin">.

  # Mojolicious::Lite
  plugin 'Config';

  # Mojolicious
  sub startup ($self) {
    $self->plugin('Config');
  }

=head2 Helpers

Similar to plugins, instead of the L</"helper"> function you just use the method L<Mojolicious/"helper">.

  # Mojolicious::Lite
  helper two => sub ($c) {
    return 1 + 1;
  };

  # Mojolicious
  sub startup ($self) {
    $self->helper(two => sub ($c) {
      return 1 + 1;
    });
  }

=head2 Under

Instead of sequential function calls, we can use methods to build a tree with nested routes, that much better
illustrates how routes work internally.

  # Mojolicious::Lite
  under '/foo';
  get '/bar' => sub ($c) {...};

  # Mojolicious
  sub startup ($self) {

    my $routes = $self->routes;
    my $foo = $routes->under('/foo');
    $foo->get('/bar' => sub ($c) {...});
  }

=head1 FUNCTIONS

L<Mojolicious::Lite> implements the following functions, which are automatically exported.

=head2 any

  my $route = any '/:foo' => sub ($c) {...};
  my $route = any '/:foo' => sub ($c) {...} => 'name';
  my $route = any '/:foo' => {foo => 'bar'} => sub ($c) {...};
  my $route = any '/:foo' => [foo => qr/\w+/] => sub ($c) {...};
  my $route = any ['GET', 'POST'] => '/:foo' => sub ($c) {...};
  my $route = any ['GET', 'POST'] => '/:foo' => [foo => qr/\w+/] => sub ($c) {...};
  my $route = any ['GET', 'POST'] => '/:foo' => (agent => qr/Firefox/) => sub ($c) {...};

Generate route with L<Mojolicious::Routes::Route/"any">, matching any of the listed HTTP request methods or all. See
L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more information.

=head2 app

  my $app = app;

Returns the L<Mojolicious::Lite> application object, which is a subclass of L<Mojolicious>.

  # Use all the available attributes and methods
  app->log->level('error');
  app->defaults(foo => 'bar');

=head2 del

  my $route = del '/:foo' => sub ($c) {...};
  my $route = del '/:foo' => sub ($c) {...} => 'name';
  my $route = del '/:foo' => {foo => 'bar'} => sub ($c) {...};
  my $route = del '/:foo' => [foo => qr/\w+/] => sub ($c) {...};
  my $route = del '/:foo' => (agent => qr/Firefox/) => sub ($c) {...};

Generate route with L<Mojolicious::Routes::Route/"delete">, matching only C<DELETE> requests. See
L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more information.

=head2 get

  my $route = get '/:foo' => sub ($c) {...};
  my $route = get '/:foo' => sub ($c) {...} => 'name';
  my $route = get '/:foo' => {foo => 'bar'} => sub ($c) {...};
  my $route = get '/:foo' => [foo => qr/\w+/] => sub ($c) {...};
  my $route = get '/:foo' => (agent => qr/Firefox/) => sub ($c) {...};

Generate route with L<Mojolicious::Routes::Route/"get">, matching only C<GET> requests. See
L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more information.

=head2 group

  group {...};

Start a new route group.

=head2 helper

  helper foo => sub ($c, @args) {...};

Add a new helper with L<Mojolicious/"helper">.

=head2 hook

  hook after_dispatch => sub ($c) {...};

Share code with L<Mojolicious/"hook">.

=head2 options

  my $route = options '/:foo' => sub ($c) {...};
  my $route = options '/:foo' => sub ($c) {...} => 'name';
  my $route = options '/:foo' => {foo => 'bar'} => sub ($c) {...};
  my $route = options '/:foo' => [foo => qr/\w+/] => sub ($c) {...};
  my $route = options '/:foo' => (agent => qr/Firefox/) => sub ($c) {...};

Generate route with L<Mojolicious::Routes::Route/"options">, matching only C<OPTIONS> requests. See
L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more information.

=head2 patch

  my $route = patch '/:foo' => sub ($c) {...};
  my $route = patch '/:foo' => sub ($c) {...} => 'name';
  my $route = patch '/:foo' => {foo => 'bar'} => sub ($c) {...};
  my $route = patch '/:foo' => [foo => qr/\w+/] => sub ($c) {...};
  my $route = patch '/:foo' => (agent => qr/Firefox/) => sub ($c) {...};

Generate route with L<Mojolicious::Routes::Route/"patch">, matching only C<PATCH> requests. See
L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more information.

=head2 plugin

  plugin SomePlugin => {foo => 23};

Load a plugin with L<Mojolicious/"plugin">.

=head2 post

  my $route = post '/:foo' => sub ($c) {...};
  my $route = post '/:foo' => sub ($c) {...} => 'name';
  my $route = post '/:foo' => {foo => 'bar'} => sub ($c) {...};
  my $route = post '/:foo' => [foo => qr/\w+/] => sub ($c) {...};
  my $route = post '/:foo' => (agent => qr/Firefox/) => sub ($c) {...};

Generate route with L<Mojolicious::Routes::Route/"post">, matching only C<POST> requests. See
L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more information.

=head2 put

  my $route = put '/:foo' => sub ($c) {...};
  my $route = put '/:foo' => sub ($c) {...} => 'name';
  my $route = put '/:foo' => {foo => 'bar'} => sub ($c) {...};
  my $route = put '/:foo' => [foo => qr/\w+/] => sub ($c) {...};
  my $route = put '/:foo' => (agent => qr/Firefox/) => sub ($c) {...};

Generate route with L<Mojolicious::Routes::Route/"put">, matching only C<PUT> requests. See
L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more information.

=head2 under

  my $route = under sub ($c) {...};
  my $route = under '/:foo' => sub ($c) {...};
  my $route = under '/:foo' => {foo => 'bar'};
  my $route = under '/:foo' => [foo => qr/\w+/];
  my $route = under '/:foo' => (agent => qr/Firefox/);
  my $route = under [format => ['json', 'yaml']];

Generate nested route with L<Mojolicious::Routes::Route/"under">, to which all following routes are automatically
appended. See L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more information.

=head2 websocket

  my $route = websocket '/:foo' => sub ($c) {...};
  my $route = websocket '/:foo' => sub ($c) {...} => 'name';
  my $route = websocket '/:foo' => {foo => 'bar'} => sub ($c) {...};
  my $route = websocket '/:foo' => [foo => qr/\w+/] => sub ($c) {...};
  my $route = websocket '/:foo' => (agent => qr/Firefox/) => sub ($c) {...};

Generate route with L<Mojolicious::Routes::Route/"websocket">, matching only WebSocket handshakes. See
L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more information.

=head1 ATTRIBUTES

L<Mojolicious::Lite> inherits all attributes from L<Mojolicious>.

=head1 METHODS

L<Mojolicious::Lite> inherits all methods from L<Mojolicious>.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package ojo;
use Mojo::Base -strict;

use Benchmark        qw(timeit timestr :hireswallclock);
use Mojo::ByteStream qw(b);
use Mojo::Collection qw(c);
use Mojo::DOM;
use Mojo::File qw(path);
use Mojo::JSON qw(j);
use Mojo::URL;
use Mojo::Util qw(dumper monkey_patch);

# Silent one-liners
$ENV{MOJO_LOG_LEVEL} ||= 'fatal';

sub import {

  # Mojolicious::Lite
  my $caller = caller;
  eval "package $caller; use Mojolicious::Lite; 1" or die $@;
  Mojo::Base->import(-strict, $] < 5.020 ? () : (-signatures));
  my $ua = $caller->app->ua;
  $ua->server->app->hook(around_action => sub { local $_ = $_[1]; $_[0]() });

  $ua->max_redirects(10) unless defined $ENV{MOJO_MAX_REDIRECTS};
  $ua->proxy->detect     unless defined $ENV{MOJO_PROXY};

  # The ojo DSL
  monkey_patch $caller,
    a => sub { $caller->can('any')->(@_) and return $ua->server->app },
    b => \&b,
    c => \&c,
    d => sub { $ua->delete(@_)->result },
    f => \&path,
    g => sub { $ua->get(@_)->result },
    h => sub { $ua->head(@_)->result },
    j => \&j,
    l => sub { Mojo::URL->new(@_) },
    n => sub (&@) { say STDERR timestr timeit($_[1] // 1, $_[0]) },
    o => sub { $ua->options(@_)->result },
    p => sub { $ua->post(@_)->result },
    r => \&dumper,
    t => sub { $ua->patch(@_)->result },
    u => sub { $ua->put(@_)->result },
    x => sub { Mojo::DOM->new(@_) };
}

1;

=encoding utf8

=head1 NAME

ojo - Fun one-liners with Mojo

=head1 SYNOPSIS

  $ perl -Mojo -E 'say g("mojolicious.org")->dom->at("title")->text'

=head1 DESCRIPTION

A collection of automatically exported functions for fun Perl one-liners. Ten redirects will be followed by default,
you can change this behavior with the C<MOJO_MAX_REDIRECTS> environment variable.

  $ MOJO_MAX_REDIRECTS=0 perl -Mojo -E 'say g("example.com")->code'

Proxy detection is enabled by default, but you can disable it with the C<MOJO_PROXY> environment variable.

  $ MOJO_PROXY=0 perl -Mojo -E 'say g("example.com")->body'

TLS certificate verification can be disabled with the C<MOJO_INSECURE> environment variable.

  $ MOJO_INSECURE=1 perl -Mojo -E 'say g("https://127.0.0.1:3000")->body'

Every L<ojo> one-liner is also a L<Mojolicious::Lite> application.

  $ perl -Mojo -E 'get "/" => {inline => "%= time"}; app->start' get /

On Perl 5.20+ L<subroutine signatures|perlsub/"Signatures"> will be enabled automatically.

  $ perl -Mojo -E 'a(sub ($c) { $c->render(text => "Hello!") })->start' get /

If it is not already defined, the C<MOJO_LOG_LEVEL> environment variable will be set to C<fatal>.

=head1 FUNCTIONS

L<ojo> implements the following functions, which are automatically exported.

=head2 a

  my $app = a('/hello' => sub { $_->render(json => {hello => 'world'}) });

Create a route with L<Mojolicious::Lite/"any"> and return the current L<Mojolicious::Lite> object. The current
controller object is also available to actions as C<$_>. See also L<Mojolicious::Guides::Tutorial> for more argument
variations.

  $ perl -Mojo -E 'a("/hello" => {text => "Hello Mojo!"})->start' daemon

=head2 b

  my $stream = b('lalala');

Turn string into a L<Mojo::ByteStream> object.

  $ perl -Mojo -E 'b(g("mojolicious.org")->body)->html_unescape->say'

=head2 c

  my $collection = c(1, 2, 3);

Turn list into a L<Mojo::Collection> object.

=head2 d

  my $res = d('example.com');
  my $res = d('http://example.com' => {Accept => '*/*'} => 'Hi!');
  my $res = d('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $res = d('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform C<DELETE> request with L<Mojo::UserAgent/"delete"> and return resulting L<Mojo::Message::Response> object.

=head2 f

  my $path = f('/home/sri/foo.txt');

Turn string into a L<Mojo::File> object.

  $ perl -Mojo -E 'say r j f("hello.json")->slurp'

=head2 g

  my $res = g('example.com');
  my $res = g('http://example.com' => {Accept => '*/*'} => 'Hi!');
  my $res = g('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $res = g('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform C<GET> request with L<Mojo::UserAgent/"get"> and return resulting L<Mojo::Message::Response> object.

  $ perl -Mojo -E 'say g("mojolicious.org")->dom("h1")->map("text")->join("\n")'

=head2 h

  my $res = h('example.com');
  my $res = h('http://example.com' => {Accept => '*/*'} => 'Hi!');
  my $res = h('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $res = h('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform C<HEAD> request with L<Mojo::UserAgent/"head"> and return resulting L<Mojo::Message::Response> object.

=head2 j

  my $bytes = j([1, 2, 3]);
  my $bytes = j({foo => 'bar'});
  my $value = j($bytes);

Encode Perl data structure or decode JSON with L<Mojo::JSON/"j">.

  $ perl -Mojo -E 'f("hello.json")->spurt(j {hello => "world!"})'

=head2 l

  my $url = l('https://mojolicious.org');

Turn a string into a L<Mojo::URL> object.

  $ perl -Mojo -E 'say l("/perldoc")->to_abs(l("https://mojolicious.org"))'

=head2 n

  n {...};
  n {...} 100;

Benchmark block and print the results to C<STDERR>, with an optional number of iterations, which defaults to C<1>.

  $ perl -Mojo -E 'n { say g("mojolicious.org")->code }'

=head2 o

  my $res = o('example.com');
  my $res = o('http://example.com' => {Accept => '*/*'} => 'Hi!');
  my $res = o('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $res = o('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform C<OPTIONS> request with L<Mojo::UserAgent/"options"> and return resulting L<Mojo::Message::Response> object.

=head2 p

  my $res = p('example.com');
  my $res = p('http://example.com' => {Accept => '*/*'} => 'Hi!');
  my $res = p('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $res = p('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform C<POST> request with L<Mojo::UserAgent/"post"> and return resulting L<Mojo::Message::Response> object.

=head2 r

  my $perl = r({data => 'structure'});

Dump a Perl data structure with L<Mojo::Util/"dumper">.

  perl -Mojo -E 'say r g("example.com")->headers->to_hash'

=head2 t

  my $res = t('example.com');
  my $res = t('http://example.com' => {Accept => '*/*'} => 'Hi!');
  my $res = t('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $res = t('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform C<PATCH> request with L<Mojo::UserAgent/"patch"> and return resulting L<Mojo::Message::Response> object.

=head2 u

  my $res = u('example.com');
  my $res = u('http://example.com' => {Accept => '*/*'} => 'Hi!');
  my $res = u('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $res = u('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform C<PUT> request with L<Mojo::UserAgent/"put"> and return resulting L<Mojo::Message::Response> object.

=head2 x

  my $dom = x('<div>Hello!</div>');

Turn HTML/XML input into L<Mojo::DOM> object.

  $ perl -Mojo -E 'say x(f("test.html")->slurp)->at("title")->text'

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Test::Mojo;
use Mojo::Base -base;

# "Amy: He knows when you are sleeping.
#  Professor: He knows when you're on the can.
#  Leela: He'll hunt you down and blast your ass from here to Pakistan.
#  Zoidberg: Oh.
#  Hermes: You'd better not breathe, you'd better not move.
#  Bender: You're better off dead, I'm telling you, dude.
#  Fry: Santa Claus is gunning you down!"
use Mojo::IOLoop;
use Mojo::JSON qw(j);
use Mojo::JSON::Pointer;
use Mojo::Server;
use Mojo::UserAgent;
use Mojo::Util qw(decode encode);
use Test::More ();

has handler => sub { \&_handler };
has [qw(message success tx)];
has ua => sub { Mojo::UserAgent->new(insecure => 1)->ioloop(Mojo::IOLoop->singleton) };

# Silent or loud tests
$ENV{MOJO_LOG_LEVEL} ||= $ENV{HARNESS_IS_VERBOSE} ? 'trace' : 'fatal';

sub app {
  my ($self, $app) = @_;
  return $self->ua->server->app unless $app;
  $self->ua->server->app($app);
  return $self;
}

sub attr_is {
  my ($self, $selector, $attr, $value, $desc) = @_;
  $desc = _desc($desc, qq{exact match for attribute "$attr" at selector "$selector"});
  return $self->test('is', $self->_attr($selector, $attr), $value, $desc);
}

sub attr_isnt {
  my ($self, $selector, $attr, $value, $desc) = @_;
  $desc = _desc($desc, qq{no match for attribute "$attr" at selector "$selector"});
  return $self->test('isnt', $self->_attr($selector, $attr), $value, $desc);
}

sub attr_like {
  my ($self, $selector, $attr, $regex, $desc) = @_;
  $desc = _desc($desc, qq{similar match for attribute "$attr" at selector "$selector"});
  return $self->test('like', $self->_attr($selector, $attr), $regex, $desc);
}

sub attr_unlike {
  my ($self, $selector, $attr, $regex, $desc) = @_;
  $desc = _desc($desc, qq{no similar match for attribute "$attr" at selector "$selector"});
  return $self->test('unlike', $self->_attr($selector, $attr), $regex, $desc);
}

sub content_is {
  my ($self, $value, $desc) = @_;
  return $self->test('is', $self->tx->res->text, $value, _desc($desc, 'exact match for content'));
}

sub content_isnt {
  my ($self, $value, $desc) = @_;
  return $self->test('isnt', $self->tx->res->text, $value, _desc($desc, 'no match for content'));
}

sub content_like {
  my ($self, $regex, $desc) = @_;
  return $self->test('like', $self->tx->res->text, $regex, _desc($desc, 'content is similar'));
}

sub content_type_is {
  my ($self, $type, $desc) = @_;
  return $self->test('is', $self->tx->res->headers->content_type, $type, _desc($desc, "Content-Type: $type"));
}

sub content_type_isnt {
  my ($self, $type, $desc) = @_;
  return $self->test('isnt', $self->tx->res->headers->content_type, $type, _desc($desc, "not Content-Type: $type"));
}

sub content_type_like {
  my ($self, $regex, $desc) = @_;
  return $self->test('like', $self->tx->res->headers->content_type, $regex, _desc($desc, 'Content-Type is similar'));
}

sub content_type_unlike {
  my ($self, $regex, $desc) = @_;
  $desc = _desc($desc, 'Content-Type is not similar');
  return $self->test('unlike', $self->tx->res->headers->content_type, $regex, $desc);
}

sub content_unlike {
  my ($self, $regex, $desc) = @_;
  return $self->test('unlike', $self->tx->res->text, $regex, _desc($desc, 'content is not similar'));
}

sub delete_ok { shift->_build_ok(DELETE => @_) }

sub element_count_is {
  my ($self, $selector, $count, $desc) = @_;
  my $size = $self->tx->res->dom->find($selector)->size;
  return $self->test('is', $size, $count, _desc($desc, qq{element count for selector "$selector"}));
}

sub element_exists {
  my ($self, $selector, $desc) = @_;
  $desc = _desc($desc, qq{element for selector "$selector" exists});
  return $self->test('ok', $self->tx->res->dom->at($selector), $desc);
}

sub element_exists_not {
  my ($self, $selector, $desc) = @_;
  return $self->test('ok', !$self->tx->res->dom->at($selector), _desc($desc, qq{no element for selector "$selector"}));
}

sub finish_ok {
  my $self = shift;
  $self->tx->finish(@_) if $self->tx->is_websocket;
  Mojo::IOLoop->one_tick while !$self->{finished};
  return $self->test('ok', 1, 'closed WebSocket');
}

sub finished_ok {
  my ($self, $code) = @_;
  Mojo::IOLoop->one_tick while !$self->{finished};
  Test::More::diag "WebSocket closed with status $self->{finished}[0]" unless my $ok = $self->{finished}[0] == $code;
  return $self->test('ok', $ok, "WebSocket closed with status $code");
}

sub get_ok  { shift->_build_ok(GET  => @_) }
sub head_ok { shift->_build_ok(HEAD => @_) }

sub header_exists {
  my ($self, $name, $desc) = @_;
  return $self->test('ok', !!@{$self->tx->res->headers->every_header($name)}, _desc($desc, qq{header "$name" exists}));
}

sub header_exists_not {
  my ($self, $name, $desc) = @_;
  return $self->test('ok', !@{$self->tx->res->headers->every_header($name)}, _desc($desc, qq{no "$name" header}));
}

sub header_is {
  my ($self, $name, $value, $desc) = @_;
  return $self->test('is', $self->tx->res->headers->header($name), $value, _desc($desc, "$name: " . ($value // '')));
}

sub header_isnt {
  my ($self, $name, $value, $desc) = @_;
  $desc = _desc($desc, "not $name: " . ($value // ''));
  return $self->test('isnt', $self->tx->res->headers->header($name), $value, $desc);
}

sub header_like {
  my ($self, $name, $regex, $desc) = @_;
  $desc = _desc($desc, "$name is similar");
  return $self->test('like', $self->tx->res->headers->header($name), $regex, $desc);
}

sub header_unlike {
  my ($self, $name, $regex, $desc) = @_;
  return $self->test('unlike', $self->tx->res->headers->header($name), $regex, _desc($desc, "$name is not similar"));
}

sub json_has {
  my ($self, $p, $desc) = @_;
  $desc = _desc($desc, qq{has value for JSON Pointer "$p"});
  return $self->test('ok', !!Mojo::JSON::Pointer->new($self->tx->res->json)->contains($p), $desc);
}

sub json_hasnt {
  my ($self, $p, $desc) = @_;
  $desc = _desc($desc, qq{has no value for JSON Pointer "$p"});
  return $self->test('ok', !Mojo::JSON::Pointer->new($self->tx->res->json)->contains($p), $desc);
}

sub json_is {
  my $self = shift;
  my ($p, $data) = @_ > 1 ? (shift, shift) : ('', shift);
  my $desc = _desc(shift, qq{exact match for JSON Pointer "$p"});
  return $self->test('is_deeply', $self->tx->res->json($p), $data, $desc);
}

sub json_like {
  my ($self, $p, $regex, $desc) = @_;
  return $self->test('like', $self->tx->res->json($p), $regex, _desc($desc, qq{similar match for JSON Pointer "$p"}));
}

sub json_message_has {
  my ($self, $p, $desc) = @_;
  return $self->test('ok', $self->_json(contains => $p), _desc($desc, qq{has value for JSON Pointer "$p"}));
}

sub json_message_hasnt {
  my ($self, $p, $desc) = @_;
  return $self->test('ok', !$self->_json(contains => $p), _desc($desc, qq{has no value for JSON Pointer "$p"}));
}

sub json_message_is {
  my $self = shift;
  my ($p, $data) = @_ > 1 ? (shift, shift) : ('', shift);
  return $self->test('is_deeply', $self->_json(get => $p), $data, _desc(shift, qq{exact match for JSON Pointer "$p"}));
}

sub json_message_like {
  my ($self, $p, $regex, $desc) = @_;
  return $self->test('like', $self->_json(get => $p), $regex, _desc($desc, qq{similar match for JSON Pointer "$p"}));
}

sub json_message_unlike {
  my ($self, $p, $regex, $desc) = @_;
  $desc = _desc($desc, qq{no similar match for JSON Pointer "$p"});
  return $self->test('unlike', $self->_json(get => $p), $regex, $desc);
}

sub json_unlike {
  my ($self, $p, $regex, $desc) = @_;
  $desc = _desc($desc, qq{no similar match for JSON Pointer "$p"});
  return $self->test('unlike', $self->tx->res->json($p), $regex, $desc);
}

sub message_is {
  my ($self, $value, $desc) = @_;
  return $self->_message('is', $value, _desc($desc, 'exact match for message'));
}

sub message_isnt {
  my ($self, $value, $desc) = @_;
  return $self->_message('isnt', $value, _desc($desc, 'no match for message'));
}

sub message_like {
  my ($self, $regex, $desc) = @_;
  return $self->_message('like', $regex, _desc($desc, 'message is similar'));
}

sub message_ok {
  my ($self, $desc) = @_;
  return $self->test('ok', !!$self->_wait, _desc($desc, 'message received'));
}

sub message_unlike {
  my ($self, $regex, $desc) = @_;
  return $self->_message('unlike', $regex, _desc($desc, 'message is not similar'));
}

sub new {
  my $self = shift->SUPER::new;

  return $self unless my $app = shift;

  my @cfg = @_ ? {config => {config_override => 1, %{shift()}}} : ();
  return $self->app(Mojo::Server->new->build_app($app, @cfg)) unless ref $app;
  return $self->app(
    $app->isa('Mojolicious') ? @cfg ? $app->config($cfg[0]{config}) : $app : Mojo::Server->new->load_app($app, @cfg));
}

sub options_ok { shift->_build_ok(OPTIONS => @_) }

sub or {
  my ($self, $cb) = @_;
  $self->$cb unless $self->success;
  return $self;
}

sub patch_ok { shift->_build_ok(PATCH => @_) }
sub post_ok  { shift->_build_ok(POST  => @_) }
sub put_ok   { shift->_build_ok(PUT   => @_) }

sub request_ok { shift->_request_ok($_[0], $_[0]->req->url->to_string) }

sub reset_session {
  my $self = shift;
  $self->ua->cookie_jar->empty;
  return $self->tx(undef);
}

sub send_ok {
  my ($self, $msg, $desc) = @_;

  $desc = _desc($desc, 'send message');
  return $self->test('ok', 0, $desc) unless $self->tx->is_websocket;

  $self->tx->send($msg => sub { Mojo::IOLoop->stop });
  Mojo::IOLoop->start;
  return $self->test('ok', 1, $desc);
}

sub status_is {
  my ($self, $status, $desc) = @_;
  $desc = _desc($desc, "$status " . $self->tx->res->default_message($status));
  return $self->test('is', $self->tx->res->code, $status, $desc);
}

sub status_isnt {
  my ($self, $status, $desc) = @_;
  $desc = _desc($desc, "not $status " . $self->tx->res->default_message($status));
  return $self->test('isnt', $self->tx->res->code, $status, $desc);
}

sub test {
  my ($self, $name, @args) = @_;
  local $Test::Builder::Level = $Test::Builder::Level + 3;
  return $self->success(!!$self->handler->($name, @args));
}

sub text_is {
  my ($self, $selector, $value, $desc) = @_;
  return $self->test('is', $self->_text($selector), $value, _desc($desc, qq{exact match for selector "$selector"}));
}

sub text_isnt {
  my ($self, $selector, $value, $desc) = @_;
  return $self->test('isnt', $self->_text($selector), $value, _desc($desc, qq{no match for selector "$selector"}));
}

sub text_like {
  my ($self, $selector, $regex, $desc) = @_;
  return $self->test('like', $self->_text($selector), $regex, _desc($desc, qq{similar match for selector "$selector"}));
}

sub text_unlike {
  my ($self, $selector, $regex, $desc) = @_;
  $desc = _desc($desc, qq{no similar match for selector "$selector"});
  return $self->test('unlike', $self->_text($selector), $regex, $desc);
}

sub websocket_ok {
  my $self = shift;
  return $self->_request_ok($self->ua->build_websocket_tx(@_), $_[0]);
}

sub _attr {
  my ($self, $selector, $attr) = @_;
  return undef unless my $e = $self->tx->res->dom->at($selector);
  return $e->attr($attr) // '';
}

sub _build_ok {
  my ($self, $method, $url) = (shift, shift, shift);
  local $Test::Builder::Level = $Test::Builder::Level + 1;
  return $self->_request_ok($self->ua->build_tx($method, $url, @_), $url);
}

sub _desc { encode 'UTF-8', shift || shift }

sub _handler {
  my ($name, @args) = @_;
  return Test::More->can($name)->(@args);
}

sub _json {
  my ($self, $method, $p) = @_;
  return Mojo::JSON::Pointer->new(j(@{$self->message // []}[1]))->$method($p);
}

sub _message {
  my ($self, $name, $value, $desc) = @_;
  local $Test::Builder::Level = $Test::Builder::Level + 1;
  my ($type, $msg) = @{$self->message // []};

  # Type check
  if (ref $value eq 'HASH') {
    my $expect = exists $value->{text} ? 'text' : 'binary';
    $value = $value->{$expect};
    $msg   = '' unless ($type // '') eq $expect;
  }

  # Decode text frame if there is no type check
  else { $msg = decode 'UTF-8', $msg if ($type // '') eq 'text' }

  return $self->test($name, $msg // '', $value, $desc);
}

sub _request_ok {
  my ($self, $tx, $url) = @_;

  local $Test::Builder::Level = $Test::Builder::Level + 1;

  # Establish WebSocket connection
  if ($tx->req->is_handshake) {
    @$self{qw(finished messages)} = (undef, []);
    $self->ua->start(
      $tx => sub {
        my ($ua, $tx) = @_;
        $self->{finished} = [] unless $self->tx($tx)->tx->is_websocket;
        $tx->on(finish => sub { shift; $self->{finished} = [@_] });
        $tx->on(binary => sub { push @{$self->{messages}}, [binary => pop] });
        $tx->on(text   => sub { push @{$self->{messages}}, [text   => pop] });
        Mojo::IOLoop->stop;
      }
    );
    Mojo::IOLoop->start;

    return $self->test('ok', $self->tx->is_websocket, _desc("WebSocket handshake with $url"));
  }

  # Perform request
  $self->tx($self->ua->start($tx));
  my $err = $self->tx->error;
  Test::More::diag $err->{message} if !(my $ok = !$err->{message} || $err->{code}) && $err;
  return $self->test('ok', $ok, _desc("@{[uc $tx->req->method]} $url"));
}

sub _text {
  return undef unless my $e = shift->tx->res->dom->at(shift);
  return $e->text;
}

sub _wait {
  my $self = shift;
  Mojo::IOLoop->one_tick while !$self->{finished} && !@{$self->{messages}};
  return $self->message(shift @{$self->{messages}})->message;
}

1;

=encoding utf8

=head1 NAME

Test::Mojo - Testing Mojo

=head1 SYNOPSIS

  use Test::More;
  use Test::Mojo;

  my $t = Test::Mojo->new('MyApp');

  # HTML/XML
  $t->get_ok('/welcome')->status_is(200)->text_is('div#message' => 'Hello!');

  # JSON
  $t->post_ok('/search.json' => form => {q => 'Perl'})
    ->status_is(200)
    ->header_is('Server' => 'Mojolicious (Perl)')
    ->header_isnt('X-Bender' => 'Bite my shiny metal ass!')
    ->json_is('/results/4/title' => 'Perl rocks!')
    ->json_like('/results/7/title' => qr/Perl/);

  # WebSocket
  $t->websocket_ok('/echo')
    ->send_ok('hello')
    ->message_ok
    ->message_is('echo: hello')
    ->finish_ok;

  done_testing();

=head1 DESCRIPTION

L<Test::Mojo> is a test user agent based on L<Mojo::UserAgent>, it is usually used together with L<Test::More> to test
L<Mojolicious> applications. Just run your tests with L<prove>.

  $ prove -l -v
  $ prove -l -v t/foo.t

If it is not already defined, the C<MOJO_LOG_LEVEL> environment variable will be set to C<trace> or C<fatal>, depending
on the value of the C<HARNESS_IS_VERBOSE> environment variable. And to make it esier to test HTTPS/WSS web services
L<Mojo::UserAgent/"insecure"> will be activated by default for L</"ua">.

See L<Mojolicious::Guides::Testing> for more.

=head1 ATTRIBUTES

L<Test::Mojo> implements the following attributes.

=head2 handler

  my $cb = $t->handler;
  $t     = $t->handler(sub {...});

A callback to connect L<Test::Mojo> with L<Test::More>.

  $t->handler(sub ($name, @args) {
    return Test::More->can($name)->(@args);
  });

=head2 message

  my $msg = $t->message;
  $t      = $t->message([text => $bytes]);

Current WebSocket message represented as an array reference containing the frame type and payload.

  # More specific tests
  use Mojo::JSON qw(decode_json);
  my $hash = decode_json $t->message->[1];
  is ref $hash, 'HASH', 'right reference';
  is $hash->{foo}, 'bar', 'right value';

  # Test custom message
  $t->message([binary => $bytes])
    ->json_message_has('/foo/bar')
    ->json_message_hasnt('/bar')
    ->json_message_is('/foo/baz' => {yada => [1, 2, 3]});

=head2 success

  my $bool = $t->success;
  $t       = $t->success($bool);

True if the last test was successful.

  # Build custom tests
  my $location_is = sub ($t, $value, $desc = '') {
    $desc ||= "Location: $value";
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    return $t->success(is($t->tx->res->headers->location, $value, $desc));
  };
  $t->get_ok('/')
    ->status_is(302)
    ->$location_is('https://mojolicious.org')
    ->or(sub { diag 'Must have been Joel!' });

=head2 tx

  my $tx = $t->tx;
  $t     = $t->tx(Mojo::Transaction::HTTP->new);

Current transaction, usually a L<Mojo::Transaction::HTTP> or L<Mojo::Transaction::WebSocket> object.

  # More specific tests
  is $t->tx->res->json->{foo}, 'bar', 'right value';
  ok $t->tx->res->content->is_multipart, 'multipart content';
  is $t->tx->previous->res->code, 302, 'right status';

=head2 ua

  my $ua = $t->ua;
  $t     = $t->ua(Mojo::UserAgent->new);

User agent used for testing, defaults to a L<Mojo::UserAgent> object.

  # Allow redirects
  $t->ua->max_redirects(10);
  $t->get_ok('/redirect')->status_is(200)->content_like(qr/redirected/);

  # Switch protocol from HTTP to HTTPS
  $t->ua->server->url('https');
  $t->get_ok('/secure')->status_is(200)->content_like(qr/secure/);

  # Use absolute URL for request with Basic authentication
  my $url = $t->ua->server->url->userinfo('sri:secr3t')->path('/secrets.json');
  $t->post_ok($url => json => {limit => 10})
    ->status_is(200)
    ->json_is('/1/content', 'Mojo rocks!');

  # Customize all transactions (including followed redirects)
  $t->ua->on(start => sub ($ua, $tx) { $tx->req->headers->accept_language('en-US') });
  $t->get_ok('/hello')->status_is(200)->content_like(qr/Howdy/);

=head1 METHODS

L<Test::Mojo> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 app

  my $app = $t->app;
  $t      = $t->app(Mojolicious->new);

Access application with L<Mojo::UserAgent::Server/"app">.

  # Change log level
  $t->app->log->level('fatal');

  # Test application directly
  is $t->app->defaults->{foo}, 'bar', 'right value';
  ok $t->app->routes->find('echo')->is_websocket, 'WebSocket route';
  my $c = $t->app->build_controller;
  ok $c->render(template => 'foo'), 'rendering was successful';
  is $c->res->status, 200, 'right status';
  is $c->res->body, 'Foo!', 'right content';

  # Change application behavior
  $t->app->hook(before_dispatch => sub ($c) {
    $c->render(text => 'This request did not reach the router.') if $c->req->url->path->contains('/user');
  });
  $t->get_ok('/user')->status_is(200)->content_like(qr/not reach the router/);

  # Extract additional information
  my $stash;
  $t->app->hook(after_dispatch => sub ($c) { $stash = $c->stash });
  $t->get_ok('/hello')->status_is(200);
  is $stash->{foo}, 'bar', 'right value';

=head2 attr_is

  $t = $t->attr_is('img.cat', 'alt', 'Grumpy cat');
  $t = $t->attr_is('img.cat', 'alt', 'Grumpy cat', 'right alt text');

Checks text content of attribute with L<Mojo::DOM/"attr"> at the CSS selectors first matching HTML/XML element for
exact match with L<Mojo::DOM/"at">.

=head2 attr_isnt

  $t = $t->attr_isnt('img.cat', 'alt', 'Calm cat');
  $t = $t->attr_isnt('img.cat', 'alt', 'Calm cat', 'different alt text');

Opposite of L</"attr_is">.

=head2 attr_like

  $t = $t->attr_like('img.cat', 'alt', qr/Grumpy/);
  $t = $t->attr_like('img.cat', 'alt', qr/Grumpy/, 'right alt text');

Checks text content of attribute with L<Mojo::DOM/"attr"> at the CSS selectors first matching HTML/XML element for
similar match with L<Mojo::DOM/"at">.

=head2 attr_unlike

  $t = $t->attr_unlike('img.cat', 'alt', qr/Calm/);
  $t = $t->attr_unlike('img.cat', 'alt', qr/Calm/, 'different alt text');

Opposite of L</"attr_like">.

=head2 content_is

  $t = $t->content_is('working!');
  $t = $t->content_is('working!', 'right content');

Check response content for exact match after retrieving it from L<Mojo::Message/"text">.

=head2 content_isnt

  $t = $t->content_isnt('working!');
  $t = $t->content_isnt('working!', 'different content');

Opposite of L</"content_is">.

=head2 content_like

  $t = $t->content_like(qr/working!/);
  $t = $t->content_like(qr/working!/, 'right content');

Check response content for similar match after retrieving it from L<Mojo::Message/"text">.

=head2 content_type_is

  $t = $t->content_type_is('text/html');
  $t = $t->content_type_is('text/html', 'right content type');

Check response C<Content-Type> header for exact match.

=head2 content_type_isnt

  $t = $t->content_type_isnt('text/html');
  $t = $t->content_type_isnt('text/html', 'different content type');

Opposite of L</"content_type_is">.

=head2 content_type_like

  $t = $t->content_type_like(qr/text/);
  $t = $t->content_type_like(qr/text/, 'right content type');

Check response C<Content-Type> header for similar match.

=head2 content_type_unlike

  $t = $t->content_type_unlike(qr/text/);
  $t = $t->content_type_unlike(qr/text/, 'different content type');

Opposite of L</"content_type_like">.

=head2 content_unlike

  $t = $t->content_unlike(qr/working!/);
  $t = $t->content_unlike(qr/working!/, 'different content');

Opposite of L</"content_like">.

=head2 delete_ok

  $t = $t->delete_ok('http://example.com/foo');
  $t = $t->delete_ok('/foo');
  $t = $t->delete_ok('/foo' => {Accept => '*/*'} => 'Content!');
  $t = $t->delete_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
  $t = $t->delete_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});

Perform a C<DELETE> request and check for transport errors, takes the same arguments as L<Mojo::UserAgent/"delete">,
except for the callback.

=head2 element_count_is

  $t = $t->element_count_is('div.foo[x=y]', 5);
  $t = $t->element_count_is('html body div', 30, 'thirty elements');

Checks the number of HTML/XML elements matched by the CSS selector with L<Mojo::DOM/"find">.

=head2 element_exists

  $t = $t->element_exists('div.foo[x=y]');
  $t = $t->element_exists('html head title', 'has a title');

Checks for existence of the CSS selectors first matching HTML/XML element with L<Mojo::DOM/"at">.

  # Check attribute values
  $t->get_ok('/login')
    ->element_exists('label[for=email]')
    ->element_exists('input[name=email][type=text][value*="example.com"]')
    ->element_exists('label[for=pass]')
    ->element_exists('input[name=pass][type=password]')
    ->element_exists('input[type=submit][value]');

=head2 element_exists_not

  $t = $t->element_exists_not('div.foo[x=y]');
  $t = $t->element_exists_not('html head title', 'has no title');

Opposite of L</"element_exists">.

=head2 finish_ok

  $t = $t->finish_ok;
  $t = $t->finish_ok(1000);
  $t = $t->finish_ok(1003 => 'Cannot accept data!');

Close WebSocket connection gracefully.

=head2 finished_ok

  $t = $t->finished_ok(1000);

Wait for WebSocket connection to be closed gracefully and check status.

=head2 get_ok

  $t = $t->get_ok('http://example.com/foo');
  $t = $t->get_ok('/foo');
  $t = $t->get_ok('/foo' => {Accept => '*/*'} => 'Content!');
  $t = $t->get_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
  $t = $t->get_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});

Perform a C<GET> request and check for transport errors, takes the same arguments as L<Mojo::UserAgent/"get">, except
for the callback.

  # Run tests against remote host
  $t->get_ok('https://docs.mojolicious.org')->status_is(200);

  # Use relative URL for request with Basic authentication
  $t->get_ok('//sri:secr3t@/secrets.json')
    ->status_is(200)
    ->json_is('/1/content', 'Mojo rocks!');

  # Run additional tests on the transaction
  $t->get_ok('/foo')->status_is(200);
  is $t->tx->res->dom->at('input')->val, 'whatever', 'right value';

=head2 head_ok

  $t = $t->head_ok('http://example.com/foo');
  $t = $t->head_ok('/foo');
  $t = $t->head_ok('/foo' => {Accept => '*/*'} => 'Content!');
  $t = $t->head_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
  $t = $t->head_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});

Perform a C<HEAD> request and check for transport errors, takes the same arguments as L<Mojo::UserAgent/"head">, except
for the callback.

=head2 header_exists

  $t = $t->header_exists('ETag');
  $t = $t->header_exists('ETag', 'header exists');

Check if response header exists.

=head2 header_exists_not

  $t = $t->header_exists_not('ETag');
  $t = $t->header_exists_not('ETag', 'header is missing');

Opposite of L</"header_exists">.

=head2 header_is

  $t = $t->header_is(ETag => '"abc321"');
  $t = $t->header_is(ETag => '"abc321"', 'right header');

Check response header for exact match.

=head2 header_isnt

  $t = $t->header_isnt(Etag => '"abc321"');
  $t = $t->header_isnt(ETag => '"abc321"', 'different header');

Opposite of L</"header_is">.

=head2 header_like

  $t = $t->header_like(ETag => qr/abc/);
  $t = $t->header_like(ETag => qr/abc/, 'right header');

Check response header for similar match.

=head2 header_unlike

  $t = $t->header_unlike(ETag => qr/abc/);
  $t = $t->header_unlike(ETag => qr/abc/, 'different header');

Opposite of L</"header_like">.

=head2 json_has

  $t = $t->json_has('/foo');
  $t = $t->json_has('/minibar', 'has a minibar');

Check if JSON response contains a value that can be identified using the given JSON Pointer with
L<Mojo::JSON::Pointer>.

=head2 json_hasnt

  $t = $t->json_hasnt('/foo');
  $t = $t->json_hasnt('/minibar', 'no minibar');

Opposite of L</"json_has">.

=head2 json_is

  $t = $t->json_is({foo => [1, 2, 3]});
  $t = $t->json_is('/foo' => [1, 2, 3]);
  $t = $t->json_is('/foo/1' => 2, 'right value');

Check the value extracted from JSON response using the given JSON Pointer with L<Mojo::JSON::Pointer>, which defaults
to the root value if it is omitted.

  # Use an empty JSON Pointer to test the whole JSON response with a test description
  $t->json_is('' => {foo => [1, 2, 3]}, 'right object');

=head2 json_like

  $t = $t->json_like('/foo/1' => qr/^\d+$/);
  $t = $t->json_like('/foo/1' => qr/^\d+$/, 'right value');

Check the value extracted from JSON response using the given JSON Pointer with L<Mojo::JSON::Pointer> for similar
match.

=head2 json_message_has

  $t = $t->json_message_has('/foo');
  $t = $t->json_message_has('/minibar', 'has a minibar');

Check if JSON WebSocket message contains a value that can be identified using the given JSON Pointer with
L<Mojo::JSON::Pointer>.

=head2 json_message_hasnt

  $t = $t->json_message_hasnt('/foo');
  $t = $t->json_message_hasnt('/minibar', 'no minibar');

Opposite of L</"json_message_has">.

=head2 json_message_is

  $t = $t->json_message_is({foo => [1, 2, 3]});
  $t = $t->json_message_is('/foo' => [1, 2, 3]);
  $t = $t->json_message_is('/foo/1' => 2, 'right value');

Check the value extracted from JSON WebSocket message using the given JSON Pointer with L<Mojo::JSON::Pointer>, which
defaults to the root value if it is omitted.

=head2 json_message_like

  $t = $t->json_message_like('/foo/1' => qr/^\d+$/);
  $t = $t->json_message_like('/foo/1' => qr/^\d+$/, 'right value');

Check the value extracted from JSON WebSocket message using the given JSON Pointer with L<Mojo::JSON::Pointer> for
similar match.

=head2 json_message_unlike

  $t = $t->json_message_unlike('/foo/1' => qr/^\d+$/);
  $t = $t->json_message_unlike('/foo/1' => qr/^\d+$/, 'different value');

Opposite of L</"json_message_like">.

=head2 json_unlike

  $t = $t->json_unlike('/foo/1' => qr/^\d+$/);
  $t = $t->json_unlike('/foo/1' => qr/^\d+$/, 'different value');

Opposite of L</"json_like">.

=head2 message_is

  $t = $t->message_is({binary => $bytes});
  $t = $t->message_is({text   => $bytes});
  $t = $t->message_is('working!');
  $t = $t->message_is('working!', 'right message');

Check WebSocket message for exact match.

=head2 message_isnt

  $t = $t->message_isnt({binary => $bytes});
  $t = $t->message_isnt({text   => $bytes});
  $t = $t->message_isnt('working!');
  $t = $t->message_isnt('working!', 'different message');

Opposite of L</"message_is">.

=head2 message_like

  $t = $t->message_like({binary => qr/$bytes/});
  $t = $t->message_like({text   => qr/$bytes/});
  $t = $t->message_like(qr/working!/);
  $t = $t->message_like(qr/working!/, 'right message');

Check WebSocket message for similar match.

=head2 message_ok

  $t = $t->message_ok;
  $t = $t->message_ok('got a message');

Wait for next WebSocket message to arrive.

  # Wait for message and perform multiple tests on it
  $t->websocket_ok('/time')
    ->message_ok
    ->message_like(qr/\d+/)
    ->message_unlike(qr/\w+/)
    ->finish_ok;

=head2 message_unlike

  $t = $t->message_unlike({binary => qr/$bytes/});
  $t = $t->message_unlike({text   => qr/$bytes/});
  $t = $t->message_unlike(qr/working!/);
  $t = $t->message_unlike(qr/working!/, 'different message');

Opposite of L</"message_like">.

=head2 new

  my $t = Test::Mojo->new;
  my $t = Test::Mojo->new('MyApp');
  my $t = Test::Mojo->new('MyApp', {foo => 'bar'});
  my $t = Test::Mojo->new(Mojo::File->new('/path/to/myapp.pl'));
  my $t = Test::Mojo->new(Mojo::File->new('/path/to/myapp.pl'), {foo => 'bar'});
  my $t = Test::Mojo->new(MyApp->new);
  my $t = Test::Mojo->new(MyApp->new, {foo => 'bar'});

Construct a new L<Test::Mojo> object. In addition to a class name or L<Mojo::File> object pointing to the application
script, you can pass along a hash reference with configuration values that will be used to override the application
configuration. The special configuration value C<config_override> will be set in L<Mojolicious/"config"> as well, which
is used to disable configuration plugins like L<Mojolicious::Plugin::Config>, L<Mojolicious::Plugin::JSONConfig> and
L<Mojolicious::Plugin::NotYAMLConfig> for tests.

  # Load application script relative to the "t" directory
  use Mojo::File qw(curfile);
  my $t = Test::Mojo->new(curfile->dirname->sibling('myapp.pl'));

=head2 options_ok

  $t = $t->options_ok('http://example.com/foo');
  $t = $t->options_ok('/foo');
  $t = $t->options_ok('/foo' => {Accept => '*/*'} => 'Content!');
  $t = $t->options_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
  $t = $t->options_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});

Perform a C<OPTIONS> request and check for transport errors, takes the same arguments as L<Mojo::UserAgent/"options">,
except for the callback.

=head2 or

  $t = $t->or(sub {...});

Execute callback if the value of L</"success"> is false.

  # Diagnostics
  $t->get_ok('/bad')->or(sub { diag 'Must have been Glen!' })
    ->status_is(200)->or(sub { diag $t->tx->res->dom->at('title')->text });

=head2 patch_ok

  $t = $t->patch_ok('http://example.com/foo');
  $t = $t->patch_ok('/foo');
  $t = $t->patch_ok('/foo' => {Accept => '*/*'} => 'Content!');
  $t = $t->patch_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
  $t = $t->patch_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});

Perform a C<PATCH> request and check for transport errors, takes the same arguments as L<Mojo::UserAgent/"patch">,
except for the callback.

=head2 post_ok

  $t = $t->post_ok('http://example.com/foo');
  $t = $t->post_ok('/foo');
  $t = $t->post_ok('/foo' => {Accept => '*/*'} => 'Content!');
  $t = $t->post_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
  $t = $t->post_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});

Perform a C<POST> request and check for transport errors, takes the same arguments as L<Mojo::UserAgent/"post">, except
for the callback.

  # Test file upload
  my $upload = {foo => {content => 'bar', filename => 'baz.txt'}};
  $t->post_ok('/upload' => form => $upload)->status_is(200);

  # Test JSON API
  $t->post_ok('/hello.json' => json => {hello => 'world'})
    ->status_is(200)
    ->json_is({bye => 'world'});

=head2 put_ok

  $t = $t->put_ok('http://example.com/foo');
  $t = $t->put_ok('/foo');
  $t = $t->put_ok('/foo' => {Accept => '*/*'} => 'Content!');
  $t = $t->put_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
  $t = $t->put_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});

Perform a C<PUT> request and check for transport errors, takes the same arguments as L<Mojo::UserAgent/"put">, except
for the callback.

=head2 request_ok

  $t = $t->request_ok(Mojo::Transaction::HTTP->new);

Perform request and check for transport errors.

  # Request with custom method
  my $tx = $t->ua->build_tx(FOO => '/test.json' => json => {foo => 1});
  $t->request_ok($tx)->status_is(200)->json_is({success => 1});

  # Request with custom cookie
  my $tx = $t->ua->build_tx(GET => '/account');
  $tx->req->cookies({name => 'user', value => 'sri'});
  $t->request_ok($tx)->status_is(200)->text_is('head > title' => 'Hello sri');

  # Custom WebSocket handshake
  my $tx = $t->ua->build_websocket_tx('/foo');
  $tx->req->headers->remove('User-Agent');
  $t->request_ok($tx)->message_ok->message_is('bar')->finish_ok;

=head2 reset_session

  $t = $t->reset_session;

Reset user agent session.

=head2 send_ok

  $t = $t->send_ok({binary => $bytes});
  $t = $t->send_ok({text   => $bytes});
  $t = $t->send_ok({json   => {test => [1, 2, 3]}});
  $t = $t->send_ok([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
  $t = $t->send_ok($chars);
  $t = $t->send_ok($chars, 'sent successfully');

Send message or frame via WebSocket.

  # Send JSON object as "Text" message
  $t->websocket_ok('/echo.json')
    ->send_ok({json => {test => 'I â™¥ Mojolicious!'}})
    ->message_ok
    ->json_message_is('/test' => 'I â™¥ Mojolicious!')
    ->finish_ok;

=head2 status_is

  $t = $t->status_is(200);
  $t = $t->status_is(200, 'right status');

Check response status for exact match.

=head2 status_isnt

  $t = $t->status_isnt(200);
  $t = $t->status_isnt(200, 'different status');

Opposite of L</"status_is">.

=head2 test

  $t = $t->test('is', 'first value', 'second value', 'right value');

Call L<Test::More> functions through L</"handler">, used to implement L<Test::Mojo> roles. The result will be stored in
L</"success">.

=head2 text_is

  $t = $t->text_is('div.foo[x=y]' => 'Hello!');
  $t = $t->text_is('html head title' => 'Hello!', 'right title');

Checks text content of the CSS selectors first matching HTML/XML element for exact match with L<Mojo::DOM/"at">.

=head2 text_isnt

  $t = $t->text_isnt('div.foo[x=y]' => 'Hello!');
  $t = $t->text_isnt('html head title' => 'Hello!', 'different title');

Opposite of L</"text_is">.

=head2 text_like

  $t = $t->text_like('div.foo[x=y]' => qr/Hello/);
  $t = $t->text_like('html head title' => qr/Hello/, 'right title');

Checks text content of the CSS selectors first matching HTML/XML element for similar match with L<Mojo::DOM/"at">.

=head2 text_unlike

  $t = $t->text_unlike('div.foo[x=y]' => qr/Hello/);
  $t = $t->text_unlike('html head title' => qr/Hello/, 'different title');

Opposite of L</"text_like">.

=head2 websocket_ok

  $t = $t->websocket_ok('http://example.com/echo');
  $t = $t->websocket_ok('/echo');
  $t = $t->websocket_ok('/echo' => {DNT => 1} => ['v1.proto']);

Open a WebSocket connection with transparent handshake, takes the same arguments as L<Mojo::UserAgent/"websocket">,
except for the callback.

  # WebSocket with permessage-deflate compression
  $t->websocket_ok('/' => {'Sec-WebSocket-Extensions' => 'permessage-deflate'})
    ->send_ok('y' x 50000)
    ->message_ok
    ->message_is('z' x 50000)
    ->finish_ok;

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojolicious;
use Mojo::Base -base;

# "Fry: Shut up and take my money!"
use Carp ();
use Mojo::DynamicMethods -dispatch;
use Mojo::Exception;
use Mojo::Home;
use Mojo::Loader;
use Mojo::Log;
use Mojo::Server;
use Mojo::Util;
use Mojo::UserAgent;
use Mojolicious::Commands;
use Mojolicious::Controller;
use Mojolicious::Plugins;
use Mojolicious::Renderer;
use Mojolicious::Routes;
use Mojolicious::Sessions;
use Mojolicious::Static;
use Mojolicious::Types;
use Mojolicious::Validator;
use Scalar::Util ();

has commands         => sub { Mojolicious::Commands->new(app => shift) };
has controller_class => 'Mojolicious::Controller';
has exception_format => 'html';
has home             => sub { Mojo::Home->new->detect(ref shift) };
has log              => sub {
  my $self = shift;

  # Reduced log output outside of development mode
  my $log = Mojo::Log->new;
  return $log->level($ENV{MOJO_LOG_LEVEL}) if $ENV{MOJO_LOG_LEVEL};
  return $self->mode eq 'development' ? $log : $log->level('info');
};
has 'max_request_size';
has mode               => sub { $ENV{MOJO_MODE} || $ENV{PLACK_ENV} || 'development' };
has moniker            => sub { Mojo::Util::decamelize ref shift };
has plugins            => sub { Mojolicious::Plugins->new };
has preload_namespaces => sub { [] };
has renderer           => sub { Mojolicious::Renderer->new };
has routes             => sub { Mojolicious::Routes->new };
has secrets            => sub {
  my $self = shift;

  # Warn developers about insecure default
  $self->log->trace('Your secret passphrase needs to be changed (see FAQ for more)');

  # Default to moniker
  return [$self->moniker];
};
has sessions  => sub { Mojolicious::Sessions->new };
has static    => sub { Mojolicious::Static->new };
has types     => sub { Mojolicious::Types->new };
has ua        => sub { Mojo::UserAgent->new };
has validator => sub { Mojolicious::Validator->new };

our $CODENAME = 'Waffle';
our $VERSION  = '9.34';

sub BUILD_DYNAMIC {
  my ($class, $method, $dyn_methods) = @_;

  return sub {
    my $self    = shift;
    my $dynamic = $dyn_methods->{$self->renderer}{$method};
    return $self->build_controller->$dynamic(@_) if $dynamic;
    my $package = ref $self;
    Carp::croak qq{Can't locate object method "$method" via package "$package"};
  };
}

sub build_controller {
  my ($self, $tx) = @_;

  # Embedded application
  my $stash = {};
  if ($tx && (my $sub = $tx->can('stash'))) { ($stash, $tx) = ($tx->$sub, $tx->tx) }

  # Build default controller
  my $defaults = $self->defaults;
  @$stash{keys %$defaults} = values %$defaults;
  my $c = $self->controller_class->new(app => $self, stash => $stash, tx => $tx);
  $c->{tx} ||= $self->build_tx;

  return $c;
}

sub build_tx {
  my $self = shift;

  my $tx  = Mojo::Transaction::HTTP->new;
  my $max = $self->max_request_size;
  $tx->req->max_message_size($max) if defined $max;
  $self->plugins->emit_hook(after_build_tx => $tx, $self);

  return $tx;
}

sub config   { Mojo::Util::_stash(config   => @_) }
sub defaults { Mojo::Util::_stash(defaults => @_) }

sub dispatch {
  my ($self, $c) = @_;

  my $plugins = $self->plugins->emit_hook(before_dispatch => $c);

  my $stash = $c->stash;
  return if $stash->{'mojo.rendered'};

  # Try to find a static file
  my $tx = $c->tx;
  $self->static->dispatch($c) and $plugins->emit_hook(after_static => $c) unless $tx->res->code;

  # Start timer (ignore static files)
  $c->helpers->log->trace(sub {
    my $req    = $c->req;
    my $method = $req->method;
    my $path   = $req->url->path->to_abs_string;
    $c->helpers->timing->begin('mojo.timer');
    return qq{$method "$path"};
  }) unless $stash->{'mojo.static'};

  # Routes
  $plugins->emit_hook(before_routes => $c);
  $c->helpers->reply->not_found unless $tx->res->code || $self->routes->dispatch($c) || $tx->res->code;
}

sub handler {
  my $self = shift;

  # Dispatcher has to be last in the chain
  ++$self->{dispatch}
    and $self->hook(around_action   => \&_action)
    and $self->hook(around_dispatch => sub { $_[1]->app->dispatch($_[1]) })
    unless $self->{dispatch};

  # Process with chain
  my $c = $self->build_controller(@_);
  $self->plugins->emit_chain(around_dispatch => $c);

  # Delayed response
  $c->helpers->log->trace('Nothing has been rendered, expecting delayed response (see FAQ for more)')
    unless $c->stash->{'mojo.rendered'};
}

sub helper { shift->renderer->add_helper(@_) }

sub hook { shift->plugins->on(@_) }

sub new {
  my $self = shift->SUPER::new((ref $_[0] ? %{shift()} : @_), @Mojo::Server::ARGS_OVERRIDE);

  my $home = $self->home;
  push @{$self->renderer->paths}, $home->child('templates')->to_string;
  push @{$self->static->paths},   $home->child('public')->to_string;

  # Default to controller and application namespace
  my $controller = "@{[ref $self]}::Controller";
  my $r          = $self->preload_namespaces([$controller])->routes->namespaces([$controller, ref $self]);

  $self->plugin($_) for qw(HeaderCondition DefaultHelpers TagHelpers EPLRenderer EPRenderer);

  # Exception handling should be first in chain
  $self->hook(around_dispatch => \&_exception);

  $self->startup;
  $self->warmup;

  return $self;
}

sub plugin {
  my $self = shift;
  $self->plugins->register_plugin(shift, $self, @_);
}

sub server { $_[0]->plugins->emit_hook(before_server_start => @_[1, 0]) }

sub start {
  my $self = shift;
  $_->warmup for $self->static, $self->renderer;
  return $self->commands->run(@_ ? @_ : @ARGV);
}

sub startup { }

sub warmup { Mojo::Loader::load_classes $_ for @{shift->preload_namespaces} }

sub _action {
  my ($next, $c, $action, $last) = @_;
  my $val = $action->($c);
  $val->catch(sub { $c->helpers->reply->exception(shift) }) if Scalar::Util::blessed $val && $val->isa('Mojo::Promise');
  return $val;
}

sub _die { CORE::die ref $_[0] ? $_[0] : Mojo::Exception->new(shift)->trace }

sub _exception {
  my ($next, $c) = @_;
  local $SIG{__DIE__} = \&_die;
  $c->helpers->reply->exception($@) unless eval { $next->(); 1 };
}

1;

=encoding utf8

=head1 NAME

Mojolicious - Real-time web framework

=head1 SYNOPSIS

  # Application
  package MyApp;
  use Mojo::Base 'Mojolicious', -signatures;

  # Route
  sub startup ($self) {
    $self->routes->get('/hello')->to('foo#hello');
  }

  # Controller
  package MyApp::Controller::Foo;
  use Mojo::Base 'Mojolicious::Controller', -signatures;

  # Action
  sub hello ($self) {
    $self->render(text => 'Hello World!');
  }

=head1 DESCRIPTION

An amazing real-time web framework built on top of the powerful L<Mojo> web development toolkit. With support for
RESTful routes, plugins, commands, Perl-ish templates, content negotiation, session management, form validation,
testing framework, static file server, C<CGI>/C<PSGI> detection, first class Unicode support and much more for you to
discover.

Take a look at our excellent documentation in L<Mojolicious::Guides>!

=head1 HOOKS

L<Mojolicious> will emit the following hooks in the listed order.

=head2 before_command

Emitted right before the application runs a command through the command line interface.

  $app->hook(before_command => sub ($command, $args) {...});

Useful for reconfiguring the application before running a command or to modify the behavior of a command. (Passed the
command object and the command arguments)

=head2 before_server_start

Emitted right before the application server is started, for web servers that support it, which includes all the
built-in ones.

  $app->hook(before_server_start => sub ($server, $app) {...});

Useful for reconfiguring application servers dynamically or collecting server diagnostics information. (Passed the
server and application objects)

=head2 after_build_tx

Emitted right after the transaction is built and before the HTTP request gets parsed.

  $app->hook(after_build_tx => sub ($tx, $app) {...});

This is a very powerful hook and should not be used lightly, it makes some rather advanced features such as upload
progress bars possible. Note that this hook will not work for embedded applications, because only the host application
gets to build transactions. (Passed the transaction and application objects)

=head2 around_dispatch

Emitted right after a new request has been received and wraps around the whole dispatch process, so you have to
manually forward to the next hook if you want to continue the chain. Default exception handling with
L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>exception"> is the first hook in the chain and a call to
L</"dispatch"> the last, yours will be in between.

  $app->hook(around_dispatch => sub ($next, $c) {
    ...
    $next->();
    ...
  });

This is a very powerful hook and should not be used lightly, it allows you to, for example, customize application-wide
exception handling, consider it the sledgehammer in your toolbox. (Passed a callback leading to the next hook and the
default controller object)

=head2 before_dispatch

Emitted right before the static file server and router start their work.

  $app->hook(before_dispatch => sub ($c) {...});

Very useful for rewriting incoming requests and other preprocessing tasks. (Passed the default controller object)

=head2 after_static

Emitted after a static file response has been generated by the static file server.

  $app->hook(after_static => sub ($c) {...});

Mostly used for post-processing static file responses. (Passed the default controller object)

=head2 before_routes

Emitted after the static file server determined if a static file should be served and before the router starts its
work.

  $app->hook(before_routes => sub ($c) {...});

Mostly used for custom dispatchers and collecting metrics. (Passed the default controller object)

=head2 around_action

Emitted right before an action gets executed and wraps around it, so you have to manually forward to the next hook if
you want to continue the chain. Default action dispatching is the last hook in the chain, yours will run before it.

  $app->hook(around_action => sub ($next, $c, $action, $last) {
    ...
    return $next->();
  });

This is a very powerful hook and should not be used lightly, it allows you for example to pass additional arguments to
actions or handle return values differently. Note that this hook can trigger more than once for the same request if
there are nested routes. (Passed a callback leading to the next hook, the current controller object, the action
callback and a flag indicating if this action is an endpoint)

=head2 before_render

Emitted before content is generated by the renderer. Note that this hook can trigger out of order due to its dynamic
nature, and with embedded applications will only work for the application that is rendering.

  $app->hook(before_render => sub ($c, $args) {...});

Mostly used for pre-processing arguments passed to the renderer. (Passed the current controller object and the render
arguments)

=head2 after_render

Emitted after content has been generated by the renderer that will be assigned to the response. Note that this hook can
trigger out of order due to its dynamic nature, and with embedded applications will only work for the application that
is rendering.

  $app->hook(after_render => sub ($c, $output, $format) {...});

Mostly used for post-processing dynamically generated content. (Passed the current controller object, a reference to
the content and the format)

=head2 after_dispatch

Emitted in reverse order after a response has been generated. Note that this hook can trigger out of order due to its
dynamic nature, and with embedded applications will only work for the application that is generating the response.

  $app->hook(after_dispatch => sub ($c) {...});

Useful for rewriting outgoing responses and other post-processing tasks. (Passed the current controller object)

=head1 ATTRIBUTES

L<Mojolicious> implements the following attributes.

=head2 commands

  my $commands = $app->commands;
  $app         = $app->commands(Mojolicious::Commands->new);

Command line interface for your application, defaults to a L<Mojolicious::Commands> object.

  # Add another namespace to load commands from
  push @{$app->commands->namespaces}, 'MyApp::Command';

=head2 controller_class

  my $class = $app->controller_class;
  $app      = $app->controller_class('Mojolicious::Controller');

Class to be used for the default controller, defaults to L<Mojolicious::Controller>. Note that this class needs to have
already been loaded before the first request arrives.

=head2 exception_format

  my $format = $app->exception_format;
  $app       = $app->exception_format('txt');

Format for HTTP exceptions (C<html>, C<json>, or C<txt>), defaults to C<html>.

=head2 home

  my $home = $app->home;
  $app     = $app->home(Mojo::Home->new);

The home directory of your application, defaults to a L<Mojo::Home> object which stringifies to the actual path.

  # Portably generate path relative to home directory
  my $path = $app->home->child('data', 'important.txt');

=head2 log

  my $log = $app->log;
  $app    = $app->log(Mojo::Log->new);

The logging layer of your application, defaults to a L<Mojo::Log> object. The level will default to either the
C<MOJO_LOG_LEVEL> environment variable, C<trace> if the L</mode> is C<development>, or C<info> otherwise. All messages
will be written to C<STDERR> by default.

  # Log debug message
  $app->log->debug('It works');

=head2 max_request_size

  my $max = $app->max_request_size;
  $app    = $app->max_request_size(16777216);

Maximum request size in bytes, defaults to the value of L<Mojo::Message/"max_message_size">. Setting the value to C<0>
will allow requests of indefinite size. Note that increasing this value can also drastically increase memory usage,
should you for example attempt to parse an excessively large request body with the methods L<Mojo::Message/"dom"> or
L<Mojo::Message/"json">.

=head2 mode

  my $mode = $app->mode;
  $app     = $app->mode('production');

The operating mode for your application, defaults to a value from the C<MOJO_MODE> and C<PLACK_ENV> environment
variables or C<development>.

=head2 moniker

  my $moniker = $app->moniker;
  $app        = $app->moniker('foo_bar');

Moniker of this application, often used as default filename for configuration files and the like, defaults to
decamelizing the application class with L<Mojo::Util/"decamelize">.

=head2 plugins

  my $plugins = $app->plugins;
  $app        = $app->plugins(Mojolicious::Plugins->new);

The plugin manager, defaults to a L<Mojolicious::Plugins> object. See the L</"plugin"> method below if you want to load
a plugin.

  # Add another namespace to load plugins from
  push @{$app->plugins->namespaces}, 'MyApp::Plugin';

=head2 preload_namespaces

  my $namespaces = $app->preload_namespaces;
  $app           = $app->preload_namespaces(['MyApp::Controller']);

Namespaces to preload classes from during application startup.

=head2 renderer

  my $renderer = $app->renderer;
  $app         = $app->renderer(Mojolicious::Renderer->new);

Used to render content, defaults to a L<Mojolicious::Renderer> object. For more information about how to generate
content see L<Mojolicious::Guides::Rendering>.

  # Enable compression
  $app->renderer->compress(1);

  # Add another "templates" directory
  push @{$app->renderer->paths}, '/home/sri/templates';

  # Add another "templates" directory with higher precedence
  unshift @{$app->renderer->paths}, '/home/sri/themes/blue/templates';

  # Add another class with templates in DATA section
  push @{$app->renderer->classes}, 'Mojolicious::Plugin::Fun';

=head2 routes

  my $routes = $app->routes;
  $app       = $app->routes(Mojolicious::Routes->new);

The router, defaults to a L<Mojolicious::Routes> object. You use this in your startup method to define the url
endpoints for your application.

  # Add routes
  my $r = $app->routes;
  $r->get('/foo/bar')->to('test#foo', title => 'Hello Mojo!');
  $r->post('/baz')->to('test#baz');

  # Add another namespace to load controllers from
  push @{$app->routes->namespaces}, 'MyApp::MyController';

=head2 secrets

  my $secrets = $app->secrets;
  $app        = $app->secrets([$bytes]);

Secret passphrases used for signed cookies and the like, defaults to the L</"moniker"> of this application, which is
not very secure, so you should change it!!! As long as you are using the insecure default there will be debug messages
in the log file reminding you to change your passphrase. Only the first passphrase is used to create new signatures,
but all of them for verification. So you can increase security without invalidating all your existing signed cookies by
rotating passphrases, just add new ones to the front and remove old ones from the back.

  # Rotate passphrases
  $app->secrets(['new_passw0rd', 'old_passw0rd', 'very_old_passw0rd']);

=head2 sessions

  my $sessions = $app->sessions;
  $app         = $app->sessions(Mojolicious::Sessions->new);

Signed cookie based session manager, defaults to a L<Mojolicious::Sessions> object. You can usually leave this alone,
see L<Mojolicious::Controller/"session"> for more information about working with session data.

  # Change name of cookie used for all sessions
  $app->sessions->cookie_name('mysession');

  # Disable SameSite feature
  $app->sessions->samesite(undef);

=head2 static

  my $static = $app->static;
  $app       = $app->static(Mojolicious::Static->new);

For serving static files from your C<public> directories, defaults to a L<Mojolicious::Static> object.

  # Add another "public" directory
  push @{$app->static->paths}, '/home/sri/public';

  # Add another "public" directory with higher precedence
  unshift @{$app->static->paths}, '/home/sri/themes/blue/public';

  # Add another class with static files in DATA section
  push @{$app->static->classes}, 'Mojolicious::Plugin::Fun';

  # Remove built-in favicon
  delete $app->static->extra->{'favicon.ico'};

=head2 types

  my $types = $app->types;
  $app      = $app->types(Mojolicious::Types->new);

Responsible for connecting file extensions with MIME types, defaults to a L<Mojolicious::Types> object.

  # Add custom MIME type
  $app->types->type(twt => 'text/tweet');

=head2 ua

  my $ua = $app->ua;
  $app   = $app->ua(Mojo::UserAgent->new);

A full featured HTTP user agent for use in your applications, defaults to a L<Mojo::UserAgent> object.

  # Perform blocking request
  say $app->ua->get('example.com')->result->body;

=head2 validator

  my $validator = $app->validator;
  $app          = $app->validator(Mojolicious::Validator->new);

Validate values, defaults to a L<Mojolicious::Validator> object.

  # Add validation check
  $app->validator->add_check(foo => sub ($v, $name, $value) {
    return $value ne 'foo';
  });

  # Add validation filter
  $app->validator->add_filter(quotemeta => sub ($v, $name, $value) {
    return quotemeta $value;
  });

=head1 METHODS

L<Mojolicious> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 build_controller

  my $c = $app->build_controller;
  my $c = $app->build_controller(Mojo::Transaction::HTTP->new);
  my $c = $app->build_controller(Mojolicious::Controller->new);

Build default controller object with L</"controller_class">.

  # Render template from application
  my $foo = $app->build_controller->render_to_string(template => 'foo');

=head2 build_tx

  my $tx = $app->build_tx;

Build L<Mojo::Transaction::HTTP> object and emit L</"after_build_tx"> hook.

=head2 config

  my $hash = $app->config;
  my $foo  = $app->config('foo');
  $app     = $app->config({foo => 'bar', baz => 23});
  $app     = $app->config(foo => 'bar', baz => 23);

Application configuration.

  # Remove value
  my $foo = delete $app->config->{foo};

  # Assign multiple values at once
  $app->config(foo => 'test', bar => 23);

=head2 defaults

  my $hash = $app->defaults;
  my $foo  = $app->defaults('foo');
  $app     = $app->defaults({foo => 'bar', baz => 23});
  $app     = $app->defaults(foo => 'bar', baz => 23);

Default values for L<Mojolicious::Controller/"stash">, assigned for every new request.

  # Remove value
  my $foo = delete $app->defaults->{foo};

  # Assign multiple values at once
  $app->defaults(foo => 'test', bar => 23);

=head2 dispatch

  $app->dispatch(Mojolicious::Controller->new);

The heart of every L<Mojolicious> application, calls the L</"static"> and L</"routes"> dispatchers for every request
and passes them a L<Mojolicious::Controller> object.

=head2 handler

  $app->handler(Mojo::Transaction::HTTP->new);
  $app->handler(Mojolicious::Controller->new);

Sets up the default controller and emits the L</"around_dispatch"> hook for every request.

=head2 helper

  $app->helper(foo => sub {...});

Add or replace a helper that will be available as a method of the controller object and the application object, as well
as a function in C<ep> templates. For a full list of helpers that are available by default see
L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.

  # Helper
  $app->helper(cache => sub { state $cache = {} });

  # Application
  $app->cache->{foo} = 'bar';
  my $result = $app->cache->{foo};

  # Controller
  $c->cache->{foo} = 'bar';
  my $result = $c->cache->{foo};

  # Template
  % cache->{foo} = 'bar';
  %= cache->{foo}

=head2 hook

  $app->hook(after_dispatch => sub {...});

Extend L<Mojolicious> with hooks, which allow code to be shared with all requests indiscriminately, for a full list of
available hooks see L</"HOOKS">.

  # Dispatchers will not run if there's already a response code defined
  $app->hook(before_dispatch => sub ($c) {
    $c->render(text => 'Skipped static file server and router!')
      if $c->req->url->path->to_route =~ /do_not_dispatch/;
  });

=head2 new

  my $app = Mojolicious->new;
  my $app = Mojolicious->new(moniker => 'foo_bar');
  my $app = Mojolicious->new({moniker => 'foo_bar'});

Construct a new L<Mojolicious> application and call L</"startup">. Will automatically detect your home directory. Also
sets up the renderer, static file server, a default set of plugins and an L</"around_dispatch"> hook with the default
exception handling.

=head2 plugin

  $app->plugin('some_thing');
  $app->plugin('some_thing', foo => 23);
  $app->plugin('some_thing', {foo => 23});
  $app->plugin('SomeThing');
  $app->plugin('SomeThing', foo => 23);
  $app->plugin('SomeThing', {foo => 23});
  $app->plugin('MyApp::Plugin::SomeThing');
  $app->plugin('MyApp::Plugin::SomeThing', foo => 23);
  $app->plugin('MyApp::Plugin::SomeThing', {foo => 23});

Load a plugin, for a full list of example plugins included in the L<Mojolicious> distribution see
L<Mojolicious::Plugins/"PLUGINS">.

=head2 server

  $app->server(Mojo::Server->new);

Emits the L</"before_server_start"> hook.

=head2 start

  $app->start;
  $app->start(@ARGV);

Start the command line interface for your application. For a full list of commands that are available by default see
L<Mojolicious::Commands/"COMMANDS">. Note that the options C<-h>/C<--help>, C<--home> and C<-m>/C<--mode>, which are
shared by all commands, will be parsed from C<@ARGV> during compile time.

  # Always start daemon
  $app->start('daemon', '-l', 'http://*:8080');

=head2 startup

  $app->startup;

This is your main hook into the application, it will be called at application startup. Meant to be overloaded in a
subclass.

  sub startup ($self) {...}

=head2 warmup

  $app->warmup;

Preload classes from L</"preload_namespaces"> for future use.

=head1 HELPERS

In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call helpers on L<Mojolicious> objects. This
includes all helpers from L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>. Note that
application helpers are always called with a new default controller object, so they can't depend on or change
controller state, which includes request, response and stash.

  # Call helper
  say $app->dumper({foo => 'bar'});

  # Longer version
  say $app->build_controller->helpers->dumper({foo => 'bar'});

=head1 BUNDLED FILES

The L<Mojolicious> distribution includes a few files with different licenses that have been bundled for internal use.

=head2 Mojolicious Artwork

  Copyright (C) 2010-2023, Sebastian Riedel.

Licensed under the CC-SA License, Version 4.0 L<http://creativecommons.org/licenses/by-sa/4.0>.

=head2 jQuery

  Copyright (C) jQuery Foundation.

Licensed under the MIT License, L<http://creativecommons.org/licenses/MIT>.

=head2 highlight.js

  Copyright (C) 2006, Ivan Sagalaev.

Licensed under the BSD License, L<https://github.com/highlightjs/highlight.js/blob/master/LICENSE>.

=head2 Bootstrap

  Copyright 2011-2020 The Bootstrap Authors.
  Copyright 2011-2020 Twitter, Inc.

Licensed under the MIT License, L<http://creativecommons.org/licenses/MIT>.

=head2 Font Awesome

Licensed under the CC-BY License, Version 4.0 L<https://creativecommons.org/licenses/by/4.0/> and SIL OFL, Version 1.1
L<https://opensource.org/licenses/OFL-1.1>.

=head1 CODE NAMES

Every major release of L<Mojolicious> has a code name, these are the ones that have been used in the past.

9.0, C<Waffle> (U+1F9C7)

8.0, C<Supervillain> (U+1F9B9)

7.0, C<Doughnut> (U+1F369)

6.0, C<Clinking Beer Mugs> (U+1F37B)

5.0, C<Tiger Face> (U+1F42F)

4.0, C<Top Hat> (U+1F3A9)

3.0, C<Rainbow> (U+1F308)

2.0, C<Leaf Fluttering In Wind> (U+1F343)

1.0, C<Snowflake> (U+2744)

=head1 SPONSORS

=over 2

=item

L<Stix|https://stix.no> sponsored the creation of the Mojolicious logo (designed by Nicolai Graesdal) and transferred
its copyright to Sebastian Riedel.

=item

Some of the work on this distribution has been sponsored by L<The Perl Foundation|https://www.perlfoundation.org>.

=back

=head1 AUTHORS

L<Mojolicious> is an open source project that relies on the tireless support of its contributors.

=head2 Project Founder

Sebastian Riedel, C<kraih@mojolicious.org>

=head2 Core Developers

Current voting members of the core team in alphabetical order:

=over 2

CandyAngel, C<candyangel@mojolicious.org>

Christopher Rasch-Olsen Raa, C<christopher@mojolicious.org>

Dan Book, C<grinnz@mojolicious.org>

Jan Henning Thorsen, C<batman@mojolicious.org>

Joel Berger, C<jberger@mojolicious.org>

Marcus Ramberg, C<marcus@mojolicious.org>

=back

The following members of the core team are currently on hiatus:

=over 2

Abhijit Menon-Sen, C<ams@cpan.org>

Glen Hinkle, C<tempire@cpan.org>

=back

=head2 Contributors

In alphabetical order:

=over 2

Adam Kennedy

Adriano Ferreira

Al Newkirk

Alex Efros

Alex Salimon

Alexander Karelas

Alexey Likhatskiy

Anatoly Sharifulin

Andre Parker

Andre Vieth

Andreas Guldstrand

Andreas Jaekel

Andreas Koenig

Andrew Fresh

Andrew Nugged

Andrey Khozov

Andrey Kuzmin

Andy Grundman

Andy Lester

Aristotle Pagaltzis

Ashley Dev

Ask Bjoern Hansen

Audrey Tang

Ben Tyler

Ben van Staveren

Benjamin Erhart

Bernhard Graf

Breno G. de Oliveira

Brian Duggan

Brian Medley

Burak Gursoy

Ch Lamprecht

Charlie Brady

Chas. J. Owens IV

Chase Whitener

Chris Scheller

Christian Hansen

chromatic

Curt Tilmes

Daniel Kimsey

Daniel Mantovani

Danijel Tasov

Dagfinn Ilmari Mannsï¿½ker

Danny Thomas

David Davis

David Webb

Diego Kuperman

Dmitriy Shalashov

Dmitry Konstantinov

Dominik Jarmulowicz

Dominique Dumont

Dotan Dimet

Douglas Christopher Wilson

Elmar S. Heeb

Ettore Di Giacinto

Eugen Konkov

Eugene Toropov

Flavio Poletti

Gisle Aas

Graham Barr

Graham Knop

Heiko Jansen

Henry Tang

Hideki Yamamura

Hiroki Toyokawa

Ian Goodacre

Ilya Chesnokov

Ilya Rassadin

James Duncan

Jan Jona Javorsek

Jan Schmidt

Jaroslav Muhin

Jesse Vincent

Johannes Plunien

John Kingsley

Jonathan Yu

Josh Leder

Kamen Naydenov

Karen Etheridge

Kazuhiro Shibuya

Kevin Old

Kitamura Akatsuki

Klaus S. Madsen

Knut Arne Bjorndal

Lars Balker Rasmussen

Lee Johnson

Leon Brocard

Lukas Mai

Magnus Holm

Maik Fischer

Mark Fowler

Mark Grimes

Mark Stosberg

Martin McGrath

Marty Tennison

Matt S Trout

Matthew Lineen

Maksym Komar

Maxim Vuets

Michael Gregorowicz

Michael Harris

Michael Jemmeson

Mike Magowan

Mirko Westermeier

Mons Anderson

Moritz Lenz

Neil Watkiss

Nic Sandfield

Nils Diewald

Oleg Zhelo

Olivier Mengue

Pascal Gaudette

Paul Evans

Paul Robins

Paul Tomlin

Pavel Shaydo

Pedro Melo

Peter Edwards

Pierre-Yves Ritschard

Piotr Roszatycki

Quentin Carbonneaux

Rafal Pocztarski

Randal Schwartz

Rawley Fowler

Richard Elberger

Rick Delaney

Robert Hicks

Robert Rothenberg

Robin Lee

Roland Lammel

Roy Storey

Ryan Jendoubi

Salvador Fandino

Santiago Zarate

Sascha Kiefer

Scott Wiersdorf

Sebastian Paaske Torholm

Sergey Zasenko

Simon Bertrang

Simone Tampieri

Shoichi Kaji

Shu Cho

Skye Shaw

Stanis Trendelenburg

Stefan Adams

Steffen Ullrich

Stephan Kulow

Stephane Este-Gracias

Stevan Little

Steve Atkins

Tatsuhiko Miyagawa

Terrence Brannon

Tianon Gravi

Tomas Znamenacek

Tudor Constantin

Ulrich Habel

Ulrich Kautz

Uwe Voelker

Veesh Goldman

Viacheslav Tykhanovskyi

Victor Engmark

Viliam Pucik

Wes Cravens

William Lindley

Yaroslav Korshak

Yuki Kimoto

Zak B. Elep

Zoffix Znet

=back

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2008-2023, Sebastian Riedel and others.

This program is free software, you can redistribute it and/or modify it under the terms of the Artistic License version
2.0.

=head1 SEE ALSO

L<https://github.com/mojolicious/mojo>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Home;
use Mojo::Base 'Mojo::File';

use Mojo::Util qw(class_to_path);

sub detect {
  my ($self, $class) = @_;

  # Environment variable
  my $home;
  if ($ENV{MOJO_HOME}) { $home = Mojo::File->new($ENV{MOJO_HOME})->to_array }

  # Location of the application class (Windows mixes backslash and slash)
  elsif ($class && (my $path = $INC{my $file = class_to_path $class})) {
    $home = Mojo::File->new($path)->to_array;
    splice @$home, (my @dummy = split(/\//, $file)) * -1;
    @$home && $home->[-1] eq $_ && pop @$home for qw(lib blib);
  }

  $$self = Mojo::File->new(@$home)->to_abs->to_string if $home;
  return $self;
}

sub rel_file { shift->child(split(/\//, shift)) }

1;

=encoding utf8

=head1 NAME

Mojo::Home - Home sweet home

=head1 SYNOPSIS

  use Mojo::Home;

  # Find and manage the project root directory
  my $home = Mojo::Home->new;
  $home->detect;
  say $home->child('templates', 'layouts', 'default.html.ep');
  say "$home";

=head1 DESCRIPTION

L<Mojo::Home> is a container for home directories based on L<Mojo::File>.

=head1 METHODS

L<Mojo::Home> inherits all methods from L<Mojo::File> and implements the following new ones.

=head2 detect

  $home = $home->detect;
  $home = $home->detect('My::App');

Detect home directory from the value of the C<MOJO_HOME> environment variable or the location of the application class.

=head2 rel_file

  my $path = $home->rel_file('foo/bar.html');

Return a new L<Mojo::Home> object relative to the home directory.

=head1 OPERATORS

L<Mojo::Home> inherits all overloaded operators from L<Mojo::File>.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::DOM::HTML;
use Mojo::Base -base;

use Exporter     qw(import);
use Mojo::Util   qw(html_attr_unescape html_unescape xml_escape);
use Scalar::Util qw(weaken);

our @EXPORT_OK = ('tag_to_html');

has tree => sub { ['root'] };
has 'xml';

my $ATTR_RE = qr/
  ([^<>=\s\/0-9.\-][^<>=\s\/]*|\/)     # Key
  (?:
    \s*=\s*
    (?s:(["'])(.*?)\g{-2}|([^>\s]*))   # Value
  )?
  \s*
/x;
my $TOKEN_RE = qr/
  ([^<]+)?                                                                     # Text
  (?:
    <(?:
      !(?:
        DOCTYPE(
        \s+\w+                                                                 # Doctype
        (?:(?:\s+\w+)?(?:\s+(?:"[^"]*"|'[^']*'))+)?                            # External ID
        (?:\s+\[.+?\])?                                                        # Int Subset
        \s*)
      |
        --(.*?)--\s*                                                           # Comment
      |
        \[CDATA\[(.*?)\]\]                                                     # CDATA
      )
    |
      \?(.*?)\?                                                                # Processing Instruction
    |
      \s*((?:\/\s*)?[^<>\s\/0-9.\-][^<>\s\/]*\s*(?:(?:$ATTR_RE){0,32766})*+)   # Tag
    )>
  |
    (<)                                                                        # Runaway "<"
  )??
/xis;

# HTML elements that only contain raw text
my %RAW = map { $_ => 1 } qw(script style);

# HTML elements that only contain raw text and entities
my %RCDATA = map { $_ => 1 } qw(title textarea);

# HTML elements with optional end tags
my %END = (body => 'head', optgroup => 'optgroup', option => 'option');

# HTML elements that break paragraphs
map { $END{$_} = 'p' } (
  qw(address article aside blockquote details dialog div dl fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6),
  qw(header hgroup hr main menu nav ol p pre section table ul)
);

# Container HTML elements that create their own scope
my %SCOPE = map { $_ => 1 } qw(math svg);

# HTML table elements with optional end tags
my %TABLE = map { $_ => 1 } qw(colgroup tbody td tfoot th thead tr);

# HTML elements with optional end tags and scoping rules
my %CLOSE = (li => [{li => 1}, {ul => 1, ol => 1}], tr => [{tr => 1}, {table => 1}]);
$CLOSE{$_} = [\%TABLE, {table => 1}] for qw(colgroup tbody tfoot thead);
$CLOSE{$_} = [{dd => 1, dt => 1}, {dl    => 1}] for qw(dd dt);
$CLOSE{$_} = [{rp => 1, rt => 1}, {ruby  => 1}] for qw(rp rt);
$CLOSE{$_} = [{th => 1, td => 1}, {table => 1}] for qw(td th);

# HTML parent elements that signal no more content when closed, but that are also phrasing content
my %NO_MORE_CONTENT = (ruby => [qw(rt rp)], select => [qw(option optgroup)]);

# HTML elements without end tags
my %EMPTY = map { $_ => 1 } qw(area base br col embed hr img input keygen link menuitem meta param source track wbr);

# HTML elements categorized as phrasing content (and obsolete inline elements)
my @PHRASING = (
  qw(a abbr area audio b bdi bdo br button canvas cite code data datalist del dfn em embed i iframe img input ins kbd),
  qw(keygen label link map mark math meta meter noscript object output picture progress q ruby s samp script select),
  qw(slot small span strong sub sup svg template textarea time u var video wbr)
);
my @OBSOLETE = qw(acronym applet basefont big font strike tt);
my %PHRASING = map { $_ => 1 } @OBSOLETE, @PHRASING;

# HTML elements that don't get their self-closing flag acknowledged
my %BLOCK = map { $_ => 1 } (
  qw(a address applet article aside b big blockquote body button caption center code col colgroup dd details dialog),
  qw(dir div dl dt em fieldset figcaption figure font footer form frameset h1 h2 h3 h4 h5 h6 head header hgroup html),
  qw(i iframe li listing main marquee menu nav nobr noembed noframes noscript object ol optgroup option p plaintext),
  qw(pre rp rt s script section select small strike strong style summary table tbody td template textarea tfoot th),
  qw(thead title tr tt u ul xmp)
);

sub parse {
  my ($self, $html) = (shift, "$_[0]");

  my $xml     = $self->xml;
  my $current = my $tree = ['root'];
  while ($html =~ /\G$TOKEN_RE/gcso) {
    my ($text, $doctype, $comment, $cdata, $pi, $tag, $runaway) = ($1, $2, $3, $4, $5, $6, $11);

    # Text (and runaway "<")
    $text .= '<'                                 if defined $runaway;
    _node($current, 'text', html_unescape $text) if defined $text;

    # Tag
    if (defined $tag) {

      # End
      if ($tag =~ /^\/\s*(\S+)/) {
        my $end = $xml ? $1 : lc $1;

        # No more content
        if (!$xml && (my $tags = $NO_MORE_CONTENT{$end})) { _end($_, $xml, \$current) for @$tags }

        _end($end, $xml, \$current);
      }

      # Start
      elsif ($tag =~ m!^([^\s/]+)([\s\S]*)!) {
        my ($start, $attr) = ($xml ? $1 : lc $1, $2);

        # Attributes
        my (%attrs, $closing);
        while ($attr =~ /$ATTR_RE/go) {
          my ($key, $value) = ($xml ? $1 : lc $1, $3 // $4);

          # Empty tag
          ++$closing and next if $key eq '/';

          $attrs{$key} = defined $value ? html_attr_unescape $value : $value;
        }

        # "image" is an alias for "img"
        $start = 'img' if !$xml && $start eq 'image';
        _start($start, \%attrs, $xml, \$current);

        # Element without end tag (self-closing)
        _end($start, $xml, \$current) if !$xml && $EMPTY{$start} || ($xml || !$BLOCK{$start}) && $closing;

        # Raw text elements
        next if $xml || !$RAW{$start} && !$RCDATA{$start};
        next unless $html =~ m!\G(.*?)</\Q$start\E(?:\s+|\s*>)!gcsi;
        _node($current, 'raw', $RCDATA{$start} ? html_unescape $1 : $1);
        _end($start, 0, \$current);
      }
    }

    # DOCTYPE
    elsif (defined $doctype) { _node($current, 'doctype', $doctype) }

    # Comment
    elsif (defined $comment) { _node($current, 'comment', $comment) }

    # CDATA
    elsif (defined $cdata) { _node($current, 'cdata', $cdata) }

    # Processing instruction (try to detect XML)
    elsif (defined $pi) {
      $self->xml($xml = 1) if !exists $self->{xml} && $pi =~ /xml/i;
      _node($current, 'pi', $pi);
    }
  }

  return $self->tree($tree);
}

sub render { _render($_[0]->tree, $_[0]->xml) }

sub tag { shift->tree(['root', _tag(@_)]) }

sub tag_to_html { _render(_tag(@_), undef) }

sub _end {
  my ($end, $xml, $current) = @_;

  # Search stack for start tag
  my $next = $$current;
  do {

    # Ignore useless end tag
    return if $next->[0] eq 'root';

    # Donâ€™t traverse a container tag
    return if $SCOPE{$next->[1]} && $next->[1] ne $end;

    # Right tag
    return $$current = $next->[3] if $next->[1] eq $end;

    # Phrasing content can only cross phrasing content
    return if !$xml && $PHRASING{$end} && !$PHRASING{$next->[1]};

  } while $next = $next->[3];
}

sub _node {
  my ($current, $type, $content) = @_;
  push @$current, my $new = [$type, $content, $current];
  weaken $new->[2];
}

sub _render {
  my ($tree, $xml) = @_;

  # Tag
  my $type = $tree->[0];
  if ($type eq 'tag') {

    # Start tag
    my $tag    = $tree->[1];
    my $result = "<$tag";

    # Attributes
    for my $key (sort keys %{$tree->[2]}) {
      my $value = $tree->[2]{$key};
      $result .= $xml ? qq{ $key="$key"} : " $key" and next unless defined $value;
      $result .= qq{ $key="} . xml_escape($value) . '"';
    }

    # No children
    return $xml ? "$result />" : $EMPTY{$tag} ? "$result>" : "$result></$tag>" unless $tree->[4];

    # Children
    no warnings 'recursion';
    $result .= '>' . join '', map { _render($_, $xml) } @$tree[4 .. $#$tree];

    # End tag
    return "$result</$tag>";
  }

  # Text (escaped)
  return xml_escape $tree->[1] if $type eq 'text';

  # Raw text
  return $tree->[1] if $type eq 'raw';

  # Root
  return join '', map { _render($_, $xml) } @$tree[1 .. $#$tree] if $type eq 'root';

  # DOCTYPE
  return '<!DOCTYPE' . $tree->[1] . '>' if $type eq 'doctype';

  # Comment
  return '<!--' . $tree->[1] . '-->' if $type eq 'comment';

  # CDATA
  return '<![CDATA[' . $tree->[1] . ']]>' if $type eq 'cdata';

  # Processing instruction
  return '<?' . $tree->[1] . '?>' if $type eq 'pi';

  # Everything else
  return '';
}

sub _start {
  my ($start, $attrs, $xml, $current) = @_;

  # Autoclose optional HTML elements
  if (!$xml && $$current->[0] ne 'root') {
    if (my $end = $END{$start}) { _end($end, 0, $current) }

    elsif (my $close = $CLOSE{$start}) {
      my ($allowed, $scope) = @$close;

      # Close allowed parent elements in scope
      my $parent = $$current;
      while ($parent->[0] ne 'root' && !$scope->{$parent->[1]}) {
        _end($parent->[1], 0, $current) if $allowed->{$parent->[1]};
        $parent = $parent->[3];
      }
    }
  }

  # New tag
  push @$$current, my $new = ['tag', $start, $attrs, $$current];
  weaken $new->[3];
  $$current = $new;
}

sub _tag {
  my $tree = ['tag', shift, undef, undef];

  # Content
  push @$tree, ref $_[-1] eq 'CODE' ? ['raw', pop->()] : ['text', pop] if @_ % 2;

  # Attributes
  my $attrs = $tree->[2] = {@_};
  return $tree unless exists $attrs->{data} && ref $attrs->{data} eq 'HASH';
  my $data = delete $attrs->{data};
  @$attrs{map { y/_/-/; lc "data-$_" } keys %$data} = values %$data;
  return $tree;
}

1;

=encoding utf8

=head1 NAME

Mojo::DOM::HTML - HTML/XML engine

=head1 SYNOPSIS

  use Mojo::DOM::HTML;

  # Turn HTML into DOM tree
  my $html = Mojo::DOM::HTML->new;
  $html->parse('<div><p id="a">Test</p><p id="b">123</p></div>');
  my $tree = $html->tree;

=head1 DESCRIPTION

L<Mojo::DOM::HTML> is the HTML/XML engine used by L<Mojo::DOM>, based on the L<HTML Living
Standard|https://html.spec.whatwg.org> and the L<Extensible Markup Language (XML) 1.0|https://www.w3.org/TR/xml/>.

=head1 FUNCTIONS

L<Mojo::DOM::HTML> implements the following functions, which can be imported individually.

=head2 tag_to_html

  my $str = tag_to_html 'div', id => 'foo', 'safe content';

Generate HTML/XML tag and render it right away. This is a significantly faster alternative to L</"tag"> for template
systems that have to generate a lot of tags.

=head1 ATTRIBUTES

L<Mojo::DOM::HTML> implements the following attributes.

=head2 tree

  my $tree = $html->tree;
  $html    = $html->tree(['root']);

Document Object Model. Note that this structure should only be used very carefully since it is very dynamic.

=head2 xml

  my $bool = $html->xml;
  $html    = $html->xml($bool);

Disable HTML semantics in parser and activate case-sensitivity, defaults to auto-detection based on XML declarations.

=head1 METHODS

L<Mojo::DOM::HTML> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 parse

  $html = $html->parse('<foo bar="baz">I â™¥ Mojolicious!</foo>');

Parse HTML/XML fragment.

=head2 render

  my $str = $html->render;

Render DOM to HTML/XML.

=head2 tag

  $html = $html->tag('div', id => 'foo', 'safe content');

Generate HTML/XML tag.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::DOM::CSS;
use Mojo::Base -base;

use Carp       qw(croak);
use Mojo::Util qw(dumper trim);

use constant DEBUG => $ENV{MOJO_DOM_CSS_DEBUG} || 0;

has 'tree';

my $ESCAPE_RE = qr/\\[^0-9a-fA-F]|\\[0-9a-fA-F]{1,6}/;
my $ATTR_RE   = qr/
  \[
  ((?:$ESCAPE_RE|[\w\-])+)                              # Key
  (?:
    (\W)?=                                              # Operator
    (?:"((?:\\"|[^"])*)"|'((?:\\'|[^'])*)'|([^\]]+?))   # Value
    (?:\s+(?:(i|I)|s|S))?                               # Case-sensitivity
  )?
  \]
/x;

sub matches {
  my $tree = shift->tree;
  return $tree->[0] ne 'tag' ? undef : _match(_compile(@_), $tree, $tree, _root($tree));
}

sub select     { _select(0, shift->tree, _compile(@_)) }
sub select_one { _select(1, shift->tree, _compile(@_)) }

sub _absolutize { [map { _is_scoped($_) ? $_ : [[['pc', 'scope']], ' ', @$_] } @{shift()}] }

sub _ancestor {
  my ($selectors, $current, $tree, $scope, $one, $pos) = @_;

  while ($current ne $scope && $current->[0] ne 'root' && ($current = $current->[3])) {
    return 1     if _combinator($selectors, $current, $tree, $scope, $pos);
    return undef if $current eq $scope;
    last         if $one;
  }

  return undef;
}

sub _attr {
  my ($name_re, $value_re, $current) = @_;

  my $attrs = $current->[2];
  for my $name (keys %$attrs) {
    my $value = $attrs->{$name};
    next if $name !~ $name_re || (!defined $value && defined $value_re);
    return 1 if !(defined $value && defined $value_re) || $value =~ $value_re;
  }

  return undef;
}

sub _combinator {
  my ($selectors, $current, $tree, $scope, $pos) = @_;

  # Selector
  return undef unless my $c = $selectors->[$pos];
  if (ref $c) {
    return undef unless _selector($c, $current, $tree, $scope);
    return 1 unless $c = $selectors->[++$pos];
  }

  # ">" (parent only)
  return _ancestor($selectors, $current, $tree, $scope, 1, ++$pos) if $c eq '>';

  # "~" (preceding siblings)
  return _sibling($selectors, $current, $tree, $scope, 0, ++$pos) if $c eq '~';

  # "+" (immediately preceding siblings)
  return _sibling($selectors, $current, $tree, $scope, 1, ++$pos) if $c eq '+';

  # " " (ancestor)
  return _ancestor($selectors, $current, $tree, $scope, 0, ++$pos);
}

sub _compile {
  my ($css, %ns) = (trim('' . shift), @_);

  my $group = [[]];
  while (my $selectors = $group->[-1]) {
    push @$selectors, [] unless @$selectors && ref $selectors->[-1];
    my $last = $selectors->[-1];

    # Separator
    if ($css =~ /\G\s*,\s*/gc) { push @$group, [] }

    # Combinator
    elsif ($css =~ /\G\s*([ >+~])\s*/gc) {
      push @$last,      ['pc', 'scope'] unless @$last;
      push @$selectors, $1;
    }

    # Class or ID
    elsif ($css =~ /\G([.#])((?:$ESCAPE_RE\s|\\.|[^,.#:[ >~+])+)/gco) {
      my ($name, $op) = $1 eq '.' ? ('class', '~') : ('id', '');
      push @$last, ['attr', _name($name), _value($op, $2)];
    }

    # Attributes
    elsif ($css =~ /\G$ATTR_RE/gco) { push @$last, ['attr', _name($1), _value($2 // '', $3 // $4 // $5, $6)] }

    # Pseudo-class
    elsif ($css =~ /\G:([\w\-]+)(?:\(((?:\([^)]+\)|[^)])+)\))?/gcs) {
      my ($name, $args) = (lc $1, $2);

      # ":text" (raw text)
      $args = [$args =~ m!^/(.+)/$! ? qr/$1/ : qr/\Q$args\E/i] if $name eq 'text';

      # ":is" and ":not" (contains more selectors)
      $args = _compile($args, %ns) if $name eq 'has' || $name eq 'is' || $name eq 'not';

      # ":nth-*" (with An+B notation)
      $args = _equation($args) if $name =~ /^nth-/;

      # ":first-*", ":last-*" (rewrite to ":nth-(last-)*")
      ($name, $args) = ("nth-$+", [0, 1]) if $name =~ /^(?:first-(.+)|(last-.+))$/;

      push @$last, ['pc', $name, $args];
    }

    # Tag
    elsif ($css =~ /\G((?:$ESCAPE_RE\s|\\.|[^,.#:[ >~+])+)/gco) {
      my $alias = (my $name = $1) =~ s/^([^|]*)\|// && $1 ne '*' ? $1                                  : undef;
      my $ns    = length $alias                                  ? $ns{$alias} // return [['invalid']] : $alias;
      push @$last, ['tag', $name eq '*' ? undef : _name($name), _unescape($ns)];
    }

    else { pos $css < length $css ? croak "Unknown CSS selector: $css" : last }
  }

  warn qq{-- CSS Selector ($css)\n@{[dumper $group]}} if DEBUG;
  return $group;
}

sub _equation {
  return [0, 0] unless my $equation = shift;

  # "even"
  return [2, 0] if $equation =~ /^\s*even\s*$/i;

  # "odd"
  return [2, 1] if $equation =~ /^\s*odd\s*$/i;

  # "4", "+4" or "-4"
  return [0, $1] if $equation =~ /^\s*((?:\+|-)?\d+)\s*$/;

  # "n", "4n", "+4n", "-4n", "n+1", "4n-1", "+4n-1" (and other variations)
  return [0, 0] unless $equation =~ /^\s*((?:\+|-)?(?:\d+)?)?n\s*((?:\+|-)\s*\d+)?\s*$/i;
  return [$1 eq '-' ? -1 : !length $1 ? 1 : $1, join('', split(' ', $2 // 0))];
}

sub _is_scoped {
  my $selector = shift;

  for my $pc (grep { $_->[0] eq 'pc' } map { ref $_ ? @$_ : () } @$selector) {

    # Selector with ":scope"
    return 1 if $pc->[1] eq 'scope';

    # Argument of functional pseudo-class with ":scope"
    return 1 if ($pc->[1] eq 'has' || $pc->[1] eq 'is' || $pc->[1] eq 'not') && grep { _is_scoped($_) } @{$pc->[2]};
  }

  return undef;
}

sub _match {
  my ($group, $current, $tree, $scope) = @_;
  _combinator([reverse @$_], $current, $tree, $scope, 0) and return 1 for @$group;
  return undef;
}

sub _name {qr/(?:^|:)\Q@{[_unescape(shift)]}\E$/}

sub _namespace {
  my ($ns, $current) = @_;

  my $attr = $current->[1] =~ /^([^:]+):/ ? "xmlns:$1" : 'xmlns';
  while ($current) {
    last                               if $current->[0] eq 'root';
    return $current->[2]{$attr} eq $ns if exists $current->[2]{$attr};

    $current = $current->[3];
  }

  # Failing to match yields true if searching for no namespace, false otherwise
  return !length $ns;
}

sub _pc {
  my ($class, $args, $current, $tree, $scope) = @_;

  # ":scope" (root can only be a :scope)
  return $current eq $scope if $class eq 'scope';
  return undef              if $current->[0] eq 'root';

  # ":checked"
  return exists $current->[2]{checked} || exists $current->[2]{selected} if $class eq 'checked';

  # ":not"
  return !_match($args, $current, $current, $scope) if $class eq 'not';

  # ":is"
  return !!_match($args, $current, $current, $scope) if $class eq 'is';

  # ":has"
  return !!_select(1, $current, $args) if $class eq 'has';

  # ":empty"
  return !grep { !($_->[0] eq 'comment' || $_->[0] eq 'pi') } @$current[4 .. $#$current] if $class eq 'empty';

  # ":root"
  return $current->[3] && $current->[3][0] eq 'root' if $class eq 'root';

  # ":text"
  return grep { ($_->[0] eq 'text' || $_->[0] eq 'raw') && $_->[1] =~ $args->[0] } @$current[4 .. $#$current]
    if $class eq 'text';

  # ":any-link", ":link" and ":visited"
  if ($class eq 'any-link' || $class eq 'link' || $class eq 'visited') {
    return undef unless $current->[0] eq 'tag' && exists $current->[2]{href};
    return !!grep { $current->[1] eq $_ } qw(a area link);
  }

  # ":only-child" or ":only-of-type"
  if ($class eq 'only-child' || $class eq 'only-of-type') {
    my $type = $class eq 'only-of-type' ? $current->[1] : undef;
    $_ ne $current and return undef for @{_siblings($current, $type)};
    return 1;
  }

  # ":nth-child", ":nth-last-child", ":nth-of-type" or ":nth-last-of-type"
  if (ref $args) {
    my $type     = $class eq 'nth-of-type' || $class eq 'nth-last-of-type' ? $current->[1] : undef;
    my @siblings = @{_siblings($current, $type)};
    my $index;
    for my $i (0 .. $#siblings) {
      $index = $i, last if $siblings[$i] eq $current;
    }
    $index = $#siblings - $index if $class eq 'nth-last-child' || $class eq 'nth-last-of-type';
    $index++;

    my $delta = $index - $args->[1];
    return 1 if $delta == 0;
    return $args->[0] != 0 && ($delta < 0) == ($args->[0] < 0) && $delta % $args->[0] == 0;
  }

  # Everything else
  return undef;
}

sub _root {
  my $tree = shift;
  $tree = $tree->[3] while $tree->[0] ne 'root';
  return $tree;
}

sub _select {
  my ($one, $scope, $group) = @_;

  # Scoped selectors require the whole tree to be searched
  my $tree = $scope;
  ($group, $tree) = (_absolutize($group), _root($scope)) if grep { _is_scoped($_) } @$group;

  my @results;
  my @queue = @$tree[($tree->[0] eq 'root' ? 1 : 4) .. $#$tree];
  while (my $current = shift @queue) {
    next unless $current->[0] eq 'tag';

    unshift @queue, @$current[4 .. $#$current];
    next unless _match($group, $current, $tree, $scope);
    $one ? return $current : push @results, $current;
  }

  return $one ? undef : \@results;
}

sub _selector {
  my ($selector, $current, $tree, $scope) = @_;

  # The root might be the scope
  my $is_tag = $current->[0] eq 'tag';
  for my $s (@$selector) {
    my $type = $s->[0];

    # Tag
    if ($is_tag && $type eq 'tag') {
      return undef if defined $s->[1] && $current->[1] !~ $s->[1];
      return undef if defined $s->[2] && !_namespace($s->[2], $current);
    }

    # Attribute
    elsif ($is_tag && $type eq 'attr') { return undef unless _attr(@$s[1, 2], $current) }

    # Pseudo-class
    elsif ($type eq 'pc') { return undef unless _pc(@$s[1, 2], $current, $tree, $scope) }

    # No match
    else { return undef }
  }

  return 1;
}

sub _sibling {
  my ($selectors, $current, $tree, $scope, $immediate, $pos) = @_;

  my $found;
  for my $sibling (@{_siblings($current)}) {
    return $found if $sibling eq $current;

    # "+" (immediately preceding sibling)
    if ($immediate) { $found = _combinator($selectors, $sibling, $tree, $scope, $pos) }

    # "~" (preceding sibling)
    else { return 1 if _combinator($selectors, $sibling, $tree, $scope, $pos) }
  }

  return undef;
}

sub _siblings {
  my ($current, $type) = @_;

  my $parent   = $current->[3];
  my @siblings = grep { $_->[0] eq 'tag' } @$parent[($parent->[0] eq 'root' ? 1 : 4) .. $#$parent];
  @siblings = grep { $type eq $_->[1] } @siblings if defined $type;

  return \@siblings;
}

sub _unescape {
  return undef unless defined(my $value = shift);

  # Remove escaped newlines
  $value =~ s/\\\n//g;

  # Unescape Unicode characters
  $value =~ s/\\([0-9a-fA-F]{1,6})\s?/pack 'U', hex $1/ge;

  # Remove backslash
  $value =~ s/\\//g;

  return $value;
}

sub _value {
  my ($op, $value, $insensitive) = @_;
  return undef unless defined $value;
  $value = ($insensitive ? '(?i)' : '') . quotemeta _unescape($value);

  # "~=" (word)
  return qr/(?:^|\s+)$value(?:\s+|$)/ if $op eq '~';

  # "|=" (hyphen-separated)
  return qr/^$value(?:-|$)/ if $op eq '|';

  # "*=" (contains)
  return qr/$value/ if $op eq '*';

  # "^=" (begins with)
  return qr/^$value/ if $op eq '^';

  # "$=" (ends with)
  return qr/$value$/ if $op eq '$';

  # Everything else
  return qr/^$value$/;
}

1;

=encoding utf8

=head1 NAME

Mojo::DOM::CSS - CSS selector engine

=head1 SYNOPSIS

  use Mojo::DOM::CSS;

  # Select elements from DOM tree
  my $css = Mojo::DOM::CSS->new(tree => $tree);
  my $elements = $css->select('h1, h2, h3');

=head1 DESCRIPTION

L<Mojo::DOM::CSS> is the CSS selector engine used by L<Mojo::DOM>, based on the L<HTML Living
Standard|https://html.spec.whatwg.org> and L<Selectors Level 3|https://www.w3.org/TR/css3-selectors/>.

=head1 SELECTORS

All CSS selectors that make sense for a standalone parser are supported.

=head2 *

Any element.

  my $all = $css->select('*');

=head2 E

An element of type C<E>.

  my $title = $css->select('title');

=head2 E[foo]

An C<E> element with a C<foo> attribute.

  my $links = $css->select('a[href]');

=head2 E[foo="bar"]

An C<E> element whose C<foo> attribute value is exactly equal to C<bar>.

  my $case_sensitive = $css->select('input[type="hidden"]');
  my $case_sensitive = $css->select('input[type=hidden]');

=head2 E[foo="bar" i]

An C<E> element whose C<foo> attribute value is exactly equal to any (ASCII-range) case-permutation of C<bar>. Note
that this selector is B<EXPERIMENTAL> and might change without warning!

  my $case_insensitive = $css->select('input[type="hidden" i]');
  my $case_insensitive = $css->select('input[type=hidden i]');
  my $case_insensitive = $css->select('input[class~="foo" i]');

This selector is part of L<Selectors Level 4|https://dev.w3.org/csswg/selectors-4>, which is still a work in progress.

=head2 E[foo="bar" s]

An C<E> element whose C<foo> attribute value is exactly and case-sensitively equal to C<bar>. Note that this selector
is B<EXPERIMENTAL> and might change without warning!

  my $case_sensitive = $css->select('input[type="hidden" s]');

This selector is part of L<Selectors Level 4|https://dev.w3.org/csswg/selectors-4>, which is still a work in progress.

=head2 E[foo~="bar"]

An C<E> element whose C<foo> attribute value is a list of whitespace-separated values, one of which is exactly equal to
C<bar>.

  my $foo = $css->select('input[class~="foo"]');
  my $foo = $css->select('input[class~=foo]');

=head2 E[foo^="bar"]

An C<E> element whose C<foo> attribute value begins exactly with the string C<bar>.

  my $begins_with = $css->select('input[name^="f"]');
  my $begins_with = $css->select('input[name^=f]');

=head2 E[foo$="bar"]

An C<E> element whose C<foo> attribute value ends exactly with the string C<bar>.

  my $ends_with = $css->select('input[name$="o"]');
  my $ends_with = $css->select('input[name$=o]');

=head2 E[foo*="bar"]

An C<E> element whose C<foo> attribute value contains the substring C<bar>.

  my $contains = $css->select('input[name*="fo"]');
  my $contains = $css->select('input[name*=fo]');

=head2 E[foo|="en"]

An C<E> element whose C<foo> attribute has a hyphen-separated list of values beginning (from the left) with C<en>.

  my $english = $css->select('link[hreflang|=en]');

=head2 E:root

An C<E> element, root of the document.

  my $root = $css->select(':root');

=head2 E:nth-child(n)

An C<E> element, the C<n-th> child of its parent.

  my $third = $css->select('div:nth-child(3)');
  my $odd   = $css->select('div:nth-child(odd)');
  my $even  = $css->select('div:nth-child(even)');
  my $top3  = $css->select('div:nth-child(-n+3)');

=head2 E:nth-last-child(n)

An C<E> element, the C<n-th> child of its parent, counting from the last one.

  my $third    = $css->select('div:nth-last-child(3)');
  my $odd      = $css->select('div:nth-last-child(odd)');
  my $even     = $css->select('div:nth-last-child(even)');
  my $bottom3  = $css->select('div:nth-last-child(-n+3)');

=head2 E:nth-of-type(n)

An C<E> element, the C<n-th> sibling of its type.

  my $third = $css->select('div:nth-of-type(3)');
  my $odd   = $css->select('div:nth-of-type(odd)');
  my $even  = $css->select('div:nth-of-type(even)');
  my $top3  = $css->select('div:nth-of-type(-n+3)');

=head2 E:nth-last-of-type(n)

An C<E> element, the C<n-th> sibling of its type, counting from the last one.

  my $third    = $css->select('div:nth-last-of-type(3)');
  my $odd      = $css->select('div:nth-last-of-type(odd)');
  my $even     = $css->select('div:nth-last-of-type(even)');
  my $bottom3  = $css->select('div:nth-last-of-type(-n+3)');

=head2 E:first-child

An C<E> element, first child of its parent.

  my $first = $css->select('div p:first-child');

=head2 E:last-child

An C<E> element, last child of its parent.

  my $last = $css->select('div p:last-child');

=head2 E:first-of-type

An C<E> element, first sibling of its type.

  my $first = $css->select('div p:first-of-type');

=head2 E:last-of-type

An C<E> element, last sibling of its type.

  my $last = $css->select('div p:last-of-type');

=head2 E:only-child

An C<E> element, only child of its parent.

  my $lonely = $css->select('div p:only-child');

=head2 E:only-of-type

An C<E> element, only sibling of its type.

  my $lonely = $css->select('div p:only-of-type');

=head2 E:empty

An C<E> element that has no children (including text nodes).

  my $empty = $css->select(':empty');

=head2 E:any-link

Alias for L</"E:link">. Note that this selector is B<EXPERIMENTAL> and might change without warning! This selector is
part of L<Selectors Level 4|https://dev.w3.org/csswg/selectors-4>, which is still a work in progress.

=head2 E:link

An C<E> element being the source anchor of a hyperlink of which the target is not yet visited (C<:link>) or already
visited (C<:visited>). Note that L<Mojo::DOM::CSS> is not stateful, therefore C<:any-link>, C<:link> and C<:visited>
yield exactly the same results.

  my $links = $css->select(':any-link');
  my $links = $css->select(':link');
  my $links = $css->select(':visited');

=head2 E:visited

Alias for L</"E:link">.

=head2 E:scope

An C<E> element being a designated reference element. Note that this selector is B<EXPERIMENTAL> and might change
without warning!

  my $scoped = $css->select('a:not(:scope > a)');
  my $scoped = $css->select('div :scope p');
  my $scoped = $css->select('~ p');

This selector is part of L<Selectors Level 4|https://dev.w3.org/csswg/selectors-4>, which is still a work in progress.

=head2 E:checked

A user interface element C<E> which is checked (for instance a radio-button or checkbox).

  my $input = $css->select(':checked');

=head2 E.warning

An C<E> element whose class is "warning".

  my $warning = $css->select('div.warning');

=head2 E#myid

An C<E> element with C<ID> equal to "myid".

  my $foo = $css->select('div#foo');

=head2 E:not(s1, s2)

An C<E> element that does not match either compound selector C<s1> or compound selector C<s2>. Note that support for
compound selectors is B<EXPERIMENTAL> and might change without warning!

  my $others = $css->select('div p:not(:first-child, :last-child)');

Support for compound selectors was added as part of L<Selectors Level 4|https://dev.w3.org/csswg/selectors-4>, which is
still a work in progress.

=head2 E:is(s1, s2)

An C<E> element that matches compound selector C<s1> and/or compound selector C<s2>. Note that this selector is
B<EXPERIMENTAL> and might change without warning!

  my $headers = $css->select(':is(section, article, aside, nav) h1');

This selector is part of L<Selectors Level 4|https://dev.w3.org/csswg/selectors-4>, which is still a work in progress.

=head2 E:has(rs1, rs2)

An C<E> element, if either of the relative selectors C<rs1> or C<rs2>, when evaluated with C<E> as the :scope elements,
match an element. Note that this selector is B<EXPERIMENTAL> and might change without warning!

  my $link = $css->select('a:has(> img)');

This selector is part of L<Selectors Level 4|https://dev.w3.org/csswg/selectors-4>, which is still a work in progress.
Also be aware that this feature is currently marked C<at-risk>, so there is a high chance that it will get removed
completely.

=head2 E:text(string_or_regex)

An C<E> element containing text content that substring matches C<string_or_regex> case-insensitively or that regex
matches C<string_or_regex>. For regular expressions use the format C<:text(/.../)>. Note that this selector is
B<EXPERIMENTAL> and might change without warning!

  # Substring match
  my $login = $css->select(':text(Log in)');

  # Regex match
  my $login = $css->select(':text(/Log ?in/)');

  # Regex match (case-insensitive)
  my $login = $css->select(':text(/(?i:Log ?in)/)');

This is a custom selector for L<Mojo::DOM> and not part of any spec.

=head2 A|E

An C<E> element that belongs to the namespace alias C<A> from L<CSS Namespaces Module Level
3|https://www.w3.org/TR/css-namespaces-3/>. Key/value pairs passed to selector methods are used to declare namespace
aliases.

  my $elem = $css->select('lq|elem', lq => 'http://example.com/q-markup');

Using an empty alias searches for an element that belongs to no namespace.

  my $div = $c->select('|div');

=head2 E F

An C<F> element descendant of an C<E> element.

  my $headlines = $css->select('div h1');

=head2 E E<gt> F

An C<F> element child of an C<E> element.

  my $headlines = $css->select('html > body > div > h1');

=head2 E + F

An C<F> element immediately preceded by an C<E> element.

  my $second = $css->select('h1 + h2');

=head2 E ~ F

An C<F> element preceded by an C<E> element.

  my $second = $css->select('h1 ~ h2');

=head2 E, F, G

Elements of type C<E>, C<F> and C<G>.

  my $headlines = $css->select('h1, h2, h3');

=head2 E[foo=bar][bar=baz]

An C<E> element whose attributes match all following attribute selectors.

  my $links = $css->select('a[foo^=b][foo$=ar]');

=head1 ATTRIBUTES

L<Mojo::DOM::CSS> implements the following attributes.

=head2 tree

  my $tree = $css->tree;
  $css     = $css->tree(['root']);

Document Object Model. Note that this structure should only be used very carefully since it is very dynamic.

=head1 METHODS

L<Mojo::DOM::CSS> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 matches

  my $bool = $css->matches('head > title');
  my $bool = $css->matches('svg|line', svg => 'http://www.w3.org/2000/svg');

Check if first node in L</"tree"> matches the CSS selector. Trailing key/value pairs can be used to declare xml
namespace aliases.

=head2 select

  my $results = $css->select('head > title');
  my $results = $css->select('svg|line', svg => 'http://www.w3.org/2000/svg');

Run CSS selector against L</"tree">. Trailing key/value pairs can be used to declare xml namespace aliases.

=head2 select_one

  my $result = $css->select_one('head > title');
  my $result =
    $css->select_one('svg|line', svg => 'http://www.w3.org/2000/svg');

Run CSS selector against L</"tree"> and stop as soon as the first node matched. Trailing key/value pairs can be used to
declare xml namespace aliases.

=head1 DEBUGGING

You can set the C<MOJO_DOM_CSS_DEBUG> environment variable to get some advanced diagnostics information printed to
C<STDERR>.

  MOJO_DOM_CSS_DEBUG=1

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::File;
use Mojo::Base -strict;
use overload '@{}' => sub { shift->to_array }, bool => sub {1}, '""' => sub { ${$_[0]} }, fallback => 1;

use Carp                  qw(croak);
use Cwd                   qw(getcwd);
use Exporter              qw(import);
use File::Basename        ();
use File::Copy            qw(copy move);
use File::Find            qw(find);
use File::Path            ();
use File::Spec::Functions qw(abs2rel canonpath catfile file_name_is_absolute rel2abs splitdir);
use File::stat            ();
use File::Temp            ();
use IO::File              ();
use Mojo::Collection;

our @EXPORT_OK = ('curfile', 'path', 'tempdir', 'tempfile');

sub basename { File::Basename::basename ${shift()}, @_ }

sub child { $_[0]->new(${shift()}, @_) }

sub chmod {
  my ($self, $mode) = @_;
  chmod $mode, $$self or croak qq{Can't chmod file "$$self": $!};
  return $self;
}

sub copy_to {
  my ($self, $to) = @_;
  copy($$self, $to) or croak qq{Can't copy file "$$self" to "$to": $!};
  return $self->new(-d $to ? ($to, File::Basename::basename $self) : $to);
}

sub curfile { __PACKAGE__->new(Cwd::realpath((caller)[1])) }

sub dirname { $_[0]->new(scalar File::Basename::dirname ${$_[0]}) }

sub extname { shift->basename =~ /.+\.([^.]+)$/ ? $1 : '' }

sub is_abs { file_name_is_absolute ${shift()} }

sub list {
  my ($self, $options) = (shift, shift // {});

  return Mojo::Collection->new unless -d $$self;
  opendir(my $dir, $$self) or croak qq{Can't open directory "$$self": $!};
  my @files = grep { $_ ne '.' && $_ ne '..' } readdir $dir;
  @files = grep { !/^\./ } @files unless $options->{hidden};
  @files = map  { catfile $$self, $_ } @files;
  @files = grep { !-d } @files unless $options->{dir};

  return Mojo::Collection->new(map { $self->new($_) } sort @files);
}

sub list_tree {
  my ($self, $options) = (shift, shift // {});

  # This may break in the future, but is worth it for performance
  local $File::Find::skip_pattern = qr/^\./ unless $options->{hidden};

  # The File::Find documentation lies, this is needed for CIFS
  local $File::Find::dont_use_nlink = 1 if $options->{dont_use_nlink};

  my %all;
  my $wanted = sub {
    if ($options->{max_depth}) {
      (my $rel = $File::Find::name) =~ s!^\Q$$self\E/?!!;
      $File::Find::prune = 1 if splitdir($rel) >= $options->{max_depth};
    }
    $all{$File::Find::name}++ if $options->{dir} || !-d $File::Find::name;
  };
  find {wanted => $wanted, no_chdir => 1}, $$self if -d $$self;
  delete $all{$$self};

  return Mojo::Collection->new(map { $self->new(canonpath $_) } sort keys %all);
}

sub lstat { File::stat::lstat(${shift()}) }

sub make_path {
  my $self = shift;
  File::Path::make_path $$self, @_;
  return $self;
}

sub move_to {
  my ($self, $to) = @_;
  move($$self, $to) or croak qq{Can't move file "$$self" to "$to": $!};
  return $self->new(-d $to ? ($to, File::Basename::basename $self) : $to);
}

sub new {
  my $class = shift;
  croak 'Invalid path' if grep { !defined } @_;
  my $value = @_ == 1 ? $_[0] : @_ > 1 ? catfile @_ : canonpath getcwd;
  return bless \$value, ref $class || $class;
}

sub open {
  my $self   = shift;
  my $handle = IO::File->new;
  $handle->open($$self, @_) or croak qq{Can't open file "$$self": $!};
  return $handle;
}

sub path { __PACKAGE__->new(@_) }

sub realpath { $_[0]->new(Cwd::realpath ${$_[0]}) }

sub remove {
  my ($self, $mode) = @_;
  unlink $$self or croak qq{Can't remove file "$$self": $!} if -e $$self;
  return $self;
}

sub remove_tree {
  my $self = shift;
  File::Path::remove_tree $$self, @_;
  return $self;
}

sub sibling {
  my $self = shift;
  return $self->new(scalar File::Basename::dirname($self), @_);
}

sub slurp {
  my $self = shift;

  CORE::open my $file, '<', $$self or croak qq{Can't open file "$$self": $!};
  my $ret = my $content = '';
  while ($ret = $file->sysread(my $buffer, 131072, 0)) { $content .= $buffer }
  croak qq{Can't read from file "$$self": $!} unless defined $ret;

  return $content;
}

sub spurt {
  my ($self, $content) = (shift, join '', @_);
  CORE::open my $file, '>', $$self or croak qq{Can't open file "$$self": $!};
  ($file->syswrite($content) // -1) == length $content or croak qq{Can't write to file "$$self": $!};
  return $self;
}

sub stat { File::stat::stat(${shift()}) }

sub tap { shift->Mojo::Base::tap(@_) }

sub tempdir { __PACKAGE__->new(File::Temp->newdir(@_)) }

sub tempfile { __PACKAGE__->new(File::Temp->new(@_)) }

sub to_abs { $_[0]->new(rel2abs ${$_[0]}) }

sub to_array { [splitdir ${shift()}] }

sub to_rel { $_[0]->new(abs2rel(${$_[0]}, $_[1])) }

sub to_string {"${$_[0]}"}

sub touch {
  my $self = shift;
  $self->open('>') unless -e $$self;
  utime undef, undef, $$self or croak qq{Can't touch file "$$self": $!};
  return $self;
}

sub with_roles { shift->Mojo::Base::with_roles(@_) }

1;

=encoding utf8

=head1 NAME

Mojo::File - File system paths

=head1 SYNOPSIS

  use Mojo::File;

  # Portably deal with file system paths
  my $path = Mojo::File->new('/home/sri/.vimrc');
  say $path->slurp;
  say $path->dirname;
  say $path->basename;
  say $path->extname;
  say $path->sibling('.bashrc');

  # Use the alternative constructor
  use Mojo::File qw(path);
  my $path = path('/tmp/foo/bar')->make_path;
  $path->child('test.txt')->spurt('Hello Mojo!');

=head1 DESCRIPTION

L<Mojo::File> is a scalar-based container for file system paths that provides a friendly API for dealing with different
operating systems.

  # Access scalar directly to manipulate path
  my $path = Mojo::File->new('/home/sri/test');
  $$path .= '.txt';

=head1 FUNCTIONS

L<Mojo::File> implements the following functions, which can be imported individually.

=head2 curfile

  my $path = curfile;

Construct a new scalar-based L<Mojo::File> object for the absolute path to the current source file.

=head2 path

  my $path = path;
  my $path = path('/home/sri/.vimrc');
  my $path = path('/home', 'sri', '.vimrc');
  my $path = path(File::Temp->newdir);

Construct a new scalar-based L<Mojo::File> object, defaults to using the current working directory.

  # "foo/bar/baz.txt" (on UNIX)
  path('foo', 'bar', 'baz.txt');

=head2 tempdir

  my $path = tempdir;
  my $path = tempdir('tempXXXXX');

Construct a new scalar-based L<Mojo::File> object for a temporary directory with L<File::Temp>.

  # Longer version
  my $path = path(File::Temp->newdir('tempXXXXX'));

=head2 tempfile

  my $path = tempfile;
  my $path = tempfile(DIR => '/tmp');

Construct a new scalar-based L<Mojo::File> object for a temporary file with L<File::Temp>.

  # Longer version
  my $path = path(File::Temp->new(DIR => '/tmp'));

=head1 METHODS

L<Mojo::File> implements the following methods.

=head2 basename

  my $name = $path->basename;
  my $name = $path->basename('.txt');

Return the last level of the path with L<File::Basename>.

  # ".vimrc" (on UNIX)
  path('/home/sri/.vimrc')->basename;

  # "test" (on UNIX)
  path('/home/sri/test.txt')->basename('.txt');

=head2 child

  my $child = $path->child('.vimrc');

Return a new L<Mojo::File> object relative to the path.

  # "/home/sri/.vimrc" (on UNIX)
  path('/home')->child('sri', '.vimrc');

=head2 chmod

  $path = $path->chmod(0644);

Change file permissions.

=head2 copy_to

  my $destination = $path->copy_to('/home/sri');
  my $destination = $path->copy_to('/home/sri/.vimrc.backup');

Copy file with L<File::Copy> and return the destination as a L<Mojo::File> object.

=head2 dirname

  my $name = $path->dirname;

Return all but the last level of the path with L<File::Basename> as a L<Mojo::File> object.

  # "/home/sri" (on UNIX)
  path('/home/sri/.vimrc')->dirname;

=head2 extname

  my $ext = $path->extname;

Return file extension of the path.

  # "js"
  path('/home/sri/test.js')->extname;

=head2 is_abs

  my $bool = $path->is_abs;

Check if the path is absolute.

  # True (on UNIX)
  path('/home/sri/.vimrc')->is_abs;

  # False (on UNIX)
  path('.vimrc')->is_abs;

=head2 list

  my $collection = $path->list;
  my $collection = $path->list({hidden => 1});

List all files in the directory and return a L<Mojo::Collection> object containing the results as L<Mojo::File>
objects. The list does not include C<.> and C<..>.

  # List files
  say for path('/home/sri/myapp')->list->each;

These options are currently available:

=over 2

=item dir

  dir => 1

Include directories.

=item hidden

  hidden => 1

Include hidden files.

=back

=head2 list_tree

  my $collection = $path->list_tree;
  my $collection = $path->list_tree({hidden => 1});

List all files recursively in the directory and return a L<Mojo::Collection> object containing the results as
L<Mojo::File> objects. The list does not include C<.> and C<..>.

  # List all templates
  say for path('/home/sri/myapp/templates')->list_tree->each;

These options are currently available:

=over 2

=item dir

  dir => 1

Include directories.

=item dont_use_nlink

  dont_use_nlink => 1

Force L<File::Find> to always stat directories.

=item hidden

  hidden => 1

Include hidden files and directories.

=item max_depth

  max_depth => 3

Maximum number of levels to descend when searching for files.

=back

=head2 lstat

  my $stat = $path->lstat;

Return a L<File::stat> object for the symlink.

  # Get symlink size
  say path('/usr/sbin/sendmail')->lstat->size;

  # Get symlink modification time
  say path('/usr/sbin/sendmail')->lstat->mtime;

=head2 make_path

  $path = $path->make_path;
  $path = $path->make_path({mode => 0711});

Create the directories if they don't already exist, any additional arguments are passed through to L<File::Path>.

=head2 move_to

  my $destination = $path->move_to('/home/sri');
  my $destination = $path->move_to('/home/sri/.vimrc.backup');

Move file with L<File::Copy> and return the destination as a L<Mojo::File> object.

=head2 new

  my $path = Mojo::File->new;
  my $path = Mojo::File->new('/home/sri/.vimrc');
  my $path = Mojo::File->new('/home', 'sri', '.vimrc');
  my $path = Mojo::File->new(File::Temp->new);
  my $path = Mojo::File->new(File::Temp->newdir);

Construct a new L<Mojo::File> object, defaults to using the current working directory.

  # "foo/bar/baz.txt" (on UNIX)
  Mojo::File->new('foo', 'bar', 'baz.txt');

=head2 open

  my $handle = $path->open('+<');
  my $handle = $path->open('r+');
  my $handle = $path->open(O_RDWR);
  my $handle = $path->open('<:encoding(UTF-8)');

Open file with L<IO::File>.

  # Combine "fcntl.h" constants
  use Fcntl qw(O_CREAT O_EXCL O_RDWR);
  my $handle = path('/home/sri/test.pl')->open(O_RDWR | O_CREAT | O_EXCL);

=head2 realpath

  my $realpath = $path->realpath;

Resolve the path with L<Cwd> and return the result as a L<Mojo::File> object.

=head2 remove

  $path = $path->remove;

Delete file.

=head2 remove_tree

  $path = $path->remove_tree;
  $path = $path->remove_tree({keep_root => 1});

Delete this directory and any files and subdirectories it may contain, any additional arguments are passed through to
L<File::Path>.

=head2 sibling

  my $sibling = $path->sibling('.vimrc');

Return a new L<Mojo::File> object relative to the directory part of the path.

  # "/home/sri/.vimrc" (on UNIX)
  path('/home/sri/.bashrc')->sibling('.vimrc');

  # "/home/sri/.ssh/known_hosts" (on UNIX)
  path('/home/sri/.bashrc')->sibling('.ssh', 'known_hosts');

=head2 slurp

  my $bytes = $path->slurp;

Read all data at once from the file.

=head2 spurt

  $path = $path->spurt($bytes);
  $path = $path->spurt(@chunks_of_bytes);

Write all data at once to the file.

=head2 stat

  my $stat = $path->stat;

Return a L<File::stat> object for the path.

  # Get file size
  say path('/home/sri/.bashrc')->stat->size;

  # Get file modification time
  say path('/home/sri/.bashrc')->stat->mtime;

=head2 tap

  $path = $path->tap(sub {...});

Alias for L<Mojo::Base/"tap">.

=head2 to_abs

  my $absolute = $path->to_abs;

Return absolute path as a L<Mojo::File> object, the path does not need to exist on the file system.

=head2 to_array

  my $parts = $path->to_array;

Split the path on directory separators.

  # "home:sri:.vimrc" (on UNIX)
  join ':', @{path('/home/sri/.vimrc')->to_array};

=head2 to_rel

  my $relative = $path->to_rel('/some/base/path');

Return a relative path from the original path to the destination path as a L<Mojo::File> object.

  # "sri/.vimrc" (on UNIX)
  path('/home/sri/.vimrc')->to_rel('/home');

=head2 to_string

  my $str = $path->to_string;

Stringify the path.

=head2 touch

  $path = $path->touch;

Create file if it does not exist or change the modification and access time to the current time.

  # Safely read file
  say path('.bashrc')->touch->slurp;

=head2 with_roles

  my $new_class = Mojo::File->with_roles('Mojo::File::Role::One');
  my $new_class = Mojo::File->with_roles('+One', '+Two');
  $path         = $path->with_roles('+One', '+Two');

Alias for L<Mojo::Base/"with_roles">.

=head1 OPERATORS

L<Mojo::File> overloads the following operators.

=head2 array

  my @parts = @$path;

Alias for L</"to_array">.

=head2 bool

  my $bool = !!$path;

Always true.

=head2 stringify

  my $str = "$path";

Alias for L</"to_string">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Message::Response;
use Mojo::Base 'Mojo::Message';

use Mojo::Cookie::Response;
use Mojo::Date;

has [qw(code message)];
has max_message_size => sub { $ENV{MOJO_MAX_MESSAGE_SIZE} // 2147483648 };

# Unmarked codes are from RFC 7231
my %MESSAGES = (
  100 => 'Continue',
  101 => 'Switching Protocols',
  102 => 'Processing',                         # RFC 2518 (WebDAV)
  103 => 'Early Hints',                        # RFC 8297
  200 => 'OK',
  201 => 'Created',
  202 => 'Accepted',
  203 => 'Non-Authoritative Information',
  204 => 'No Content',
  205 => 'Reset Content',
  206 => 'Partial Content',
  207 => 'Multi-Status',                       # RFC 2518 (WebDAV)
  208 => 'Already Reported',                   # RFC 5842
  226 => 'IM Used',                            # RFC 3229
  300 => 'Multiple Choices',
  301 => 'Moved Permanently',
  302 => 'Found',
  303 => 'See Other',
  304 => 'Not Modified',
  305 => 'Use Proxy',
  307 => 'Temporary Redirect',
  308 => 'Permanent Redirect',                 # RFC 7538
  400 => 'Bad Request',
  401 => 'Unauthorized',
  402 => 'Payment Required',
  403 => 'Forbidden',
  404 => 'Not Found',
  405 => 'Method Not Allowed',
  406 => 'Not Acceptable',
  407 => 'Proxy Authentication Required',
  408 => 'Request Timeout',
  409 => 'Conflict',
  410 => 'Gone',
  411 => 'Length Required',
  412 => 'Precondition Failed',
  413 => 'Request Entity Too Large',
  414 => 'Request-URI Too Long',
  415 => 'Unsupported Media Type',
  416 => 'Request Range Not Satisfiable',
  417 => 'Expectation Failed',
  418 => "I'm a teapot",                       # RFC 2324 :)
  421 => 'Misdirected Request',                # RFC 7540
  422 => 'Unprocessable Entity',               # RFC 2518 (WebDAV)
  423 => 'Locked',                             # RFC 2518 (WebDAV)
  424 => 'Failed Dependency',                  # RFC 2518 (WebDAV)
  425 => 'Too Early',                          # RFC 8470
  426 => 'Upgrade Required',                   # RFC 2817
  428 => 'Precondition Required',              # RFC 6585
  429 => 'Too Many Requests',                  # RFC 6585
  431 => 'Request Header Fields Too Large',    # RFC 6585
  451 => 'Unavailable For Legal Reasons',      # RFC 7725
  500 => 'Internal Server Error',
  501 => 'Not Implemented',
  502 => 'Bad Gateway',
  503 => 'Service Unavailable',
  504 => 'Gateway Timeout',
  505 => 'HTTP Version Not Supported',
  506 => 'Variant Also Negotiates',            # RFC 2295
  507 => 'Insufficient Storage',               # RFC 2518 (WebDAV)
  508 => 'Loop Detected',                      # RFC 5842
  509 => 'Bandwidth Limit Exceeded',           # Unofficial
  510 => 'Not Extended',                       # RFC 2774
  511 => 'Network Authentication Required'     # RFC 6585
);

sub cookies {
  my $self = shift;

  # Parse cookies
  my $headers = $self->headers;
  return [@{Mojo::Cookie::Response->parse($headers->set_cookie)}] unless @_;

  # Add cookies
  $headers->add('Set-Cookie' => "$_") for map { ref $_ eq 'HASH' ? Mojo::Cookie::Response->new($_) : $_ } @_;

  return $self;
}

sub default_message { $MESSAGES{$_[1] || $_[0]->code // 404} || '' }

sub extract_start_line {
  my ($self, $bufref) = @_;

  # We have a full response line
  return undef                                                 unless $$bufref =~ s/^(.*?)\x0d?\x0a//;
  return !$self->error({message => 'Bad response start-line'}) unless $1 =~ m!^\s*HTTP/(\d\.\d)\s+(\d\d\d)\s*(.+)?$!;

  my $content = $self->content;
  $content->skip_body(1) if $self->code($2)->is_empty;
  defined $content->$_ or $content->$_(1) for qw(auto_decompress auto_relax);
  return !!$self->version($1)->message($3);
}

sub fix_headers {
  my $self = shift;
  $self->{fix} ? return $self : $self->SUPER::fix_headers(@_);

  # Date
  my $headers = $self->headers;
  $headers->date(Mojo::Date->new->to_string) unless $headers->date;

  # RFC 7230 3.3.2
  $headers->remove('Content-Length') if $self->is_empty;

  return $self;
}

sub get_start_line_chunk {
  my ($self, $offset) = @_;
  $self->_start_line->emit(progress => 'start_line', $offset);
  return substr $self->{start_buffer}, $offset, 131072;
}

sub is_client_error { shift->_status_class(400) }

sub is_empty {
  my $self = shift;
  return undef unless my $code = $self->code;
  return $self->is_info || $code == 204 || $code == 304;
}

sub is_error        { shift->_status_class(400, 500) }
sub is_info         { shift->_status_class(100) }
sub is_redirect     { shift->_status_class(300) }
sub is_server_error { shift->_status_class(500) }

sub is_success { shift->_status_class(200) }

sub start_line_size { length shift->_start_line->{start_buffer} }

sub _start_line {
  my $self = shift;

  return $self if defined $self->{start_buffer};
  my $code = $self->code    || 404;
  my $msg  = $self->message || $self->default_message;
  $self->{start_buffer} = "HTTP/@{[$self->version]} $code $msg\x0d\x0a";

  return $self;
}

sub _status_class {
  my ($self, @classes) = @_;
  return undef unless my $code = $self->code;
  return !!grep { $code >= $_ && $code < ($_ + 100) } @classes;
}

1;

=encoding utf8

=head1 NAME

Mojo::Message::Response - HTTP response

=head1 SYNOPSIS

  use Mojo::Message::Response;

  # Parse
  my $res = Mojo::Message::Response->new;
  $res->parse("HTTP/1.0 200 OK\x0d\x0a");
  $res->parse("Content-Length: 12\x0d\x0a");
  $res->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
  $res->parse('Hello World!');
  say $res->code;
  say $res->headers->content_type;
  say $res->body;

  # Build
  my $res = Mojo::Message::Response->new;
  $res->code(200);
  $res->headers->content_type('text/plain');
  $res->body('Hello World!');
  say $res->to_string;

=head1 DESCRIPTION

L<Mojo::Message::Response> is a container for HTTP responses, based on L<RFC 7230|https://tools.ietf.org/html/rfc7230>
and L<RFC 7231|https://tools.ietf.org/html/rfc7231>.

=head1 EVENTS

L<Mojo::Message::Response> inherits all events from L<Mojo::Message>.

=head1 ATTRIBUTES

L<Mojo::Message::Response> inherits all attributes from L<Mojo::Message> and implements the following new ones.

=head2 code

  my $code = $res->code;
  $res     = $res->code(200);

HTTP response status code.

=head2 max_message_size

  my $size = $res->max_message_size;
  $res     = $res->max_message_size(1024);

Maximum message size in bytes, defaults to the value of the C<MOJO_MAX_MESSAGE_SIZE> environment variable or
C<2147483648> (2GiB). Setting the value to C<0> will allow messages of indefinite size.

=head2 message

  my $msg = $res->message;
  $res    = $res->message('OK');

HTTP response status message.

=head1 METHODS

L<Mojo::Message::Response> inherits all methods from L<Mojo::Message> and implements the following new ones.

=head2 cookies

  my $cookies = $res->cookies;
  $res        = $res->cookies(Mojo::Cookie::Response->new);
  $res        = $res->cookies({name => 'foo', value => 'bar'});

Access response cookies, usually L<Mojo::Cookie::Response> objects.

  # Names of all cookies
  say $_->name for @{$res->cookies};

=head2 default_message

  my $msg = $res->default_message;
  my $msg = $res->default_message(418);

Generate default response message for status code, defaults to using L</"code">.

=head2 extract_start_line

  my $bool = $res->extract_start_line(\$str);

Extract status-line from string.

=head2 fix_headers

  $res = $res->fix_headers;

Make sure response has all required headers.

=head2 get_start_line_chunk

  my $bytes = $res->get_start_line_chunk($offset);

Get a chunk of status-line data starting from a specific position. Note that this method finalizes the response.

=head2 is_client_error

  my $bool = $res->is_client_error;

Check if this response has a C<4xx> status L</"code">.

=head2 is_empty

  my $bool = $res->is_empty;

Check if this response has a C<1xx>, C<204> or C<304> status L</"code">.

=head2 is_error

  my $bool = $res->is_error;

Check if this response has a C<4xx> or C<5xx> status L</"code">.

=head2 is_info

  my $bool = $res->is_info;

Check if this response has a C<1xx> status L</"code">.

=head2 is_redirect

  my $bool = $res->is_redirect;

Check if this response has a C<3xx> status L</"code">.

=head2 is_server_error

  my $bool = $res->is_server_error;

Check if this response has a C<5xx> status L</"code">.

=head2 is_success

  my $bool = $res->is_success;

Check if this response has a C<2xx> status L</"code">.

=head2 start_line_size

  my $size = $req->start_line_size;

Size of the status-line in bytes. Note that this method finalizes the response.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Message::Request;
use Mojo::Base 'Mojo::Message';

use Digest::SHA qw(sha1_base64);
use Mojo::Cookie::Request;
use Mojo::Util qw(b64_encode b64_decode sha1_sum);
use Mojo::URL;

has env    => sub { {} };
has method => 'GET';
has [qw(proxy reverse_proxy)];
has request_id => sub {
  state $seed    = $$ . time . rand;
  state $counter = int rand 0xffffff;
  my $b64 = substr(sha1_base64($seed . ($counter = ($counter + 1) % 0xffffff)), 0, 12);
  $b64 =~ tr!+/!-_!;
  return $b64;
};
has trusted_proxies => sub { [] };
has url             => sub { Mojo::URL->new };
has via_proxy       => 1;

sub clone {
  my $self = shift;

  # Dynamic requests cannot be cloned
  return undef unless my $content = $self->content->clone;
  my $clone
    = $self->new(content => $content, method => $self->method, url => $self->url->clone, version => $self->version);
  $clone->{proxy} = $self->{proxy}->clone if $self->{proxy};

  return $clone;
}

sub cookies {
  my $self = shift;

  # Parse cookies
  my $headers = $self->headers;
  return [map { @{Mojo::Cookie::Request->parse($_)} } $headers->cookie] unless @_;

  # Add cookies
  my @cookies = map { ref $_ eq 'HASH' ? Mojo::Cookie::Request->new($_) : $_ } $headers->cookie || (), @_;
  $headers->cookie(join '; ', @cookies);

  return $self;
}

sub every_param { shift->params->every_param(@_) }

sub extract_start_line {
  my ($self, $bufref) = @_;

  # Ignore any leading empty lines
  return undef unless $$bufref =~ s/^\s*(.*?)\x0d?\x0a//;

  # We have a (hopefully) full request-line
  return !$self->error({message => 'Bad request start-line'}) unless $1 =~ /^(\S+)\s+(\S+)\s+HTTP\/(\d\.\d)$/;
  my $url    = $self->method($1)->version($3)->url;
  my $target = $2;
  return !!$url->host_port($target)              if $1 eq 'CONNECT';
  return !!$url->parse($target)->fragment(undef) if $target =~ /^[^:\/?#]+:/;
  return !!$url->path_query($target);
}

sub fix_headers {
  my $self = shift;
  $self->{fix} ? return $self : $self->SUPER::fix_headers(@_);

  # Empty
  my $headers = $self->headers;
  $headers->remove('Content-Length') if ($headers->content_length // '') eq '0' && $self->method eq 'GET';

  # Host
  my $url = $self->url;
  $headers->host($url->host_port) unless $headers->host;

  # Basic authentication
  if ((my $info = $url->userinfo) && !$headers->authorization) {
    $headers->authorization('Basic ' . b64_encode($info, ''));
  }

  # Basic proxy authentication
  return $self                                                    unless (my $proxy = $self->proxy) && $self->via_proxy;
  return $self                                                    unless my $info = $proxy->userinfo;
  $headers->proxy_authorization('Basic ' . b64_encode($info, '')) unless $headers->proxy_authorization;
  return $self;
}

sub get_start_line_chunk {
  my ($self, $offset) = @_;
  $self->_start_line->emit(progress => 'start_line', $offset);
  return substr $self->{start_buffer}, $offset, 131072;
}

sub is_handshake { lc($_[0]->headers->upgrade // '') eq 'websocket' }

sub is_secure {
  my $url = shift->url;
  return ($url->protocol || $url->base->protocol) eq 'https';
}

sub is_xhr { (shift->headers->header('X-Requested-With') // '') =~ /XMLHttpRequest/i }

sub param { shift->params->param(@_) }

sub params { $_[0]->{params} ||= $_[0]->body_params->clone->append($_[0]->query_params) }

sub parse {
  my ($self, $env, $chunk) = (shift, ref $_[0] ? (shift, '') : (undef, shift));

  # Parse CGI environment
  $self->env($env)->_parse_env($env) if $env;

  # Parse normal message
  if (($self->{state} // '') ne 'cgi') { $self->SUPER::parse($chunk) }

  # Parse CGI content
  else { $self->content($self->content->parse_body($chunk))->SUPER::parse('') }

  # Check if we can fix things that require all headers
  return $self unless $self->is_finished;

  # Base URL
  my $base = $self->url->base;
  $base->scheme('http') unless $base->scheme;
  my $headers = $self->headers;
  if (!$base->host && (my $host = $headers->host)) { $base->host_port($host) }

  # Basic authentication
  if (my $basic = _basic($headers->authorization)) { $base->userinfo($basic) }

  # Basic proxy authentication
  my $basic = _basic($headers->proxy_authorization);
  $self->proxy(Mojo::URL->new->userinfo($basic)) if $basic;

  # "X-Forwarded-Proto"
  $base->scheme('https') if $self->reverse_proxy && ($headers->header('X-Forwarded-Proto') // '') eq 'https';

  return $self;
}

sub query_params { shift->url->query }

sub start_line_size { length shift->_start_line->{start_buffer} }

sub _basic { $_[0] && $_[0] =~ /Basic (.+)$/ ? b64_decode $1 : undef }

sub _parse_env {
  my ($self, $env) = @_;

  # Bypass normal message parser
  $self->{state} = 'cgi';

  # Extract headers
  my $headers = $self->headers;
  my $url     = $self->url;
  my $base    = $url->base;
  for my $name (keys %$env) {
    my $value = $env->{$name};
    next unless $name =~ s/^HTTP_//i;
    $name =~ y/_/-/;
    $headers->header($name => $value);

    # Host/Port
    $value =~ s/:(\d+)$// ? $base->host($value)->port($1) : $base->host($value) if $name eq 'HOST';
  }

  # Content-Type is a special case on some servers
  $headers->content_type($env->{CONTENT_TYPE}) if $env->{CONTENT_TYPE};

  # Content-Length is a special case on some servers
  $headers->content_length($env->{CONTENT_LENGTH}) if $env->{CONTENT_LENGTH};

  # Query
  $url->query->parse($env->{QUERY_STRING}) if $env->{QUERY_STRING};

  # Method
  $self->method($env->{REQUEST_METHOD}) if $env->{REQUEST_METHOD};

  # Scheme/Version
  $base->scheme($1) and $self->version($2) if ($env->{SERVER_PROTOCOL} // '') =~ m!^([^/]+)/([^/]+)$!;

  # HTTPS
  $base->scheme('https') if uc($env->{HTTPS} // '') eq 'ON';

  # Path
  my $path = $url->path->parse($env->{PATH_INFO} ? $env->{PATH_INFO} : '');

  # Base path
  if (my $value = $env->{SCRIPT_NAME}) {

    # Make sure there is a trailing slash (important for merging)
    $base->path->parse($value =~ m!/$! ? $value : "$value/");

    # Remove SCRIPT_NAME prefix if necessary
    my $buffer = $path->to_string;
    $value  =~ s!^/|/$!!g;
    $buffer =~ s!^/?\Q$value\E/?!!;
    $buffer =~ s!^/!!;
    $path->parse($buffer);
  }
}

sub _start_line {
  my $self = shift;

  return $self if defined $self->{start_buffer};

  # Path
  my $url  = $self->url;
  my $path = $url->path_query;
  $path = "/$path" unless $path =~ m!^/!;

  # CONNECT
  my $method = uc $self->method;
  if ($method eq 'CONNECT') {
    my $port = $url->port // ($url->protocol eq 'https' ? '443' : '80');
    $path = $url->ihost . ":$port";
  }

  # Proxy
  elsif ($self->proxy && $self->via_proxy && $url->protocol ne 'https') {
    $path = $url->clone->userinfo(undef) unless $self->is_handshake;
  }

  $self->{start_buffer} = "$method $path HTTP/@{[$self->version]}\x0d\x0a";

  return $self;
}

1;

=encoding utf8

=head1 NAME

Mojo::Message::Request - HTTP request

=head1 SYNOPSIS

  use Mojo::Message::Request;

  # Parse
  my $req = Mojo::Message::Request->new;
  $req->parse("GET /foo HTTP/1.0\x0d\x0a");
  $req->parse("Content-Length: 12\x0d\x0a");
  $req->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
  $req->parse('Hello World!');
  say $req->method;
  say $req->headers->content_type;
  say $req->body;

  # Build
  my $req = Mojo::Message::Request->new;
  $req->url->parse('http://127.0.0.1/foo/bar');
  $req->method('GET');
  say $req->to_string;

=head1 DESCRIPTION

L<Mojo::Message::Request> is a container for HTTP requests, based on L<RFC 7230|https://tools.ietf.org/html/rfc7230>,
L<RFC 7231|https://tools.ietf.org/html/rfc7231>, L<RFC 7235|https://tools.ietf.org/html/rfc7235> and L<RFC
2817|https://tools.ietf.org/html/rfc2817>.

=head1 EVENTS

L<Mojo::Message::Request> inherits all events from L<Mojo::Message>.

=head1 ATTRIBUTES

L<Mojo::Message::Request> inherits all attributes from L<Mojo::Message> and implements the following new ones.

=head2 env

  my $env = $req->env;
  $req    = $req->env({PATH_INFO => '/'});

Direct access to the C<CGI> or C<PSGI> environment hash if available.

  # Check CGI version
  my $version = $req->env->{GATEWAY_INTERFACE};

  # Check PSGI version
  my $version = $req->env->{'psgi.version'};

=head2 method

  my $method = $req->method;
  $req       = $req->method('POST');

HTTP request method, defaults to C<GET>.

=head2 proxy

  my $url = $req->proxy;
  $req    = $req->proxy(Mojo::URL->new('http://127.0.0.1:3000'));

Proxy URL for request.

=head2 reverse_proxy

  my $bool = $req->reverse_proxy;
  $req     = $req->reverse_proxy($bool);

Request has been performed through a reverse proxy.

=head2 trusted_proxies

  my $proxies = $req->trusted_proxies;
  $req        = $req->trusted_proxies(['10.0.0.0/8', '127.0.0.1', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']);

Trusted reverse proxies, addresses or networks in CIDR form.

=head2 request_id

  my $id = $req->request_id;
  $req   = $req->request_id('aee7d5d8');

Request ID, defaults to a reasonably unique value.

=head2 url

  my $url = $req->url;
  $req    = $req->url(Mojo::URL->new);

HTTP request URL, defaults to a L<Mojo::URL> object.

  # Get request information
  my $info = $req->url->to_abs->userinfo;
  my $host = $req->url->to_abs->host;
  my $path = $req->url->to_abs->path;

=head2 via_proxy

  my $bool = $req->via_proxy;
  $req     = $req->via_proxy($bool);

Request can be performed through a proxy server.

=head1 METHODS

L<Mojo::Message::Request> inherits all methods from L<Mojo::Message> and implements the following new ones.

=head2 clone

  my $clone = $req->clone;

Return a new L<Mojo::Message::Request> object cloned from this request if possible, otherwise return C<undef>.

=head2 cookies

  my $cookies = $req->cookies;
  $req        = $req->cookies(Mojo::Cookie::Request->new);
  $req        = $req->cookies({name => 'foo', value => 'bar'});

Access request cookies, usually L<Mojo::Cookie::Request> objects.

  # Names of all cookies
  say $_->name for @{$req->cookies};

=head2 every_param

  my $values = $req->every_param('foo');

Similar to L</"param">, but returns all values sharing the same name as an array reference.

  # Get first value
  say $req->every_param('foo')->[0];

=head2 extract_start_line

  my $bool = $req->extract_start_line(\$str);

Extract request-line from string.

=head2 fix_headers

  $req = $req->fix_headers;

Make sure request has all required headers.

=head2 get_start_line_chunk

  my $bytes = $req->get_start_line_chunk($offset);

Get a chunk of request-line data starting from a specific position. Note that this method finalizes the request.

=head2 is_handshake

  my $bool = $req->is_handshake;

Check C<Upgrade> header for C<websocket> value.

=head2 is_secure

  my $bool = $req->is_secure;

Check if connection is secure.

=head2 is_xhr

  my $bool = $req->is_xhr;

Check C<X-Requested-With> header for C<XMLHttpRequest> value.

=head2 param

  my $value = $req->param('foo');

Access C<GET> and C<POST> parameters extracted from the query string and C<application/x-www-form-urlencoded> or
C<multipart/form-data> message body. If there are multiple values sharing the same name, and you want to access more
than just the last one, you can use L</"every_param">. Note that this method caches all data, so it should not be
called before the entire request body has been received. Parts of the request body need to be loaded into memory to
parse C<POST> parameters, so you have to make sure it is not excessively large. There's a 16MiB limit for requests by
default.

=head2 params

  my $params = $req->params;

All C<GET> and C<POST> parameters extracted from the query string and C<application/x-www-form-urlencoded> or
C<multipart/form-data> message body, usually a L<Mojo::Parameters> object. Note that this method caches all data, so it
should not be called before the entire request body has been received. Parts of the request body need to be loaded into
memory to parse C<POST> parameters, so you have to make sure it is not excessively large. There's a 16MiB limit for
requests by default.

  # Get parameter names and values
  my $hash = $req->params->to_hash;

=head2 parse

  $req = $req->parse('GET /foo/bar HTTP/1.1');
  $req = $req->parse({PATH_INFO => '/'});

Parse HTTP request chunks or environment hash.

=head2 query_params

  my $params = $req->query_params;

All C<GET> parameters, usually a L<Mojo::Parameters> object.

  # Turn GET parameters to hash and extract value
  say $req->query_params->to_hash->{foo};

=head2 start_line_size

  my $size = $req->start_line_size;

Size of the request-line in bytes. Note that this method finalizes the request.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::UserAgent::Server;
use Mojo::Base -base;

use Mojo::IOLoop;
use Mojo::Server::Daemon;
use Scalar::Util qw(weaken);

has ioloop => sub { Mojo::IOLoop->singleton };

sub app {
  my ($self, $app) = @_;

  # Singleton application
  state $singleton;
  return $singleton = $app ? $app : $singleton unless ref $self;

  # Default to singleton application
  return $self->{app} || $singleton unless $app;
  $self->{app} = $app;
  return $self;
}

sub nb_url { shift->_url(1, @_) }

sub restart { delete @{$_[0]}{qw(nb_port nb_server port server)} }

sub url { shift->_url(0, @_) }

sub _url {
  my ($self, $nb, $proto) = @_;

  if (!$self->{server} || $proto) {
    $proto = $self->{proto} = $proto || 'http';

    # Blocking
    my $server = $self->{server} = Mojo::Server::Daemon->new(ioloop => $self->ioloop, silent => 1);
    weaken $server->app($self->app)->{app};
    my $port = $self->{port} ? ":$self->{port}" : '';
    $self->{port} = $server->listen(["$proto://127.0.0.1$port"])->start->ports->[0];

    # Non-blocking
    $server = $self->{nb_server} = Mojo::Server::Daemon->new(silent => 1);
    weaken $server->app($self->app)->{app};
    $port = $self->{nb_port} ? ":$self->{nb_port}" : '';
    $self->{nb_port} = $server->listen(["$proto://127.0.0.1$port"])->start->ports->[0];
  }

  my $port = $nb ? $self->{nb_port} : $self->{port};
  return Mojo::URL->new("$self->{proto}://127.0.0.1:$port/");
}

1;

=encoding utf8

=head1 NAME

Mojo::UserAgent::Server - Application server

=head1 SYNOPSIS

  use Mojo::UserAgent::Server;

  my $server = Mojo::UserAgent::Server->new;
  say $server->url;

=head1 DESCRIPTION

L<Mojo::UserAgent::Server> is an embedded web server based on L<Mojo::Server::Daemon> that processes requests for
L<Mojo::UserAgent>.

=head1 ATTRIBUTES

L<Mojo::UserAgent::Server> implements the following attributes.

=head2 ioloop

  my $loop = $server->ioloop;
  $server  = $server->ioloop(Mojo::IOLoop->new);

Event loop object to use for I/O operations, defaults to the global L<Mojo::IOLoop> singleton.

=head1 METHODS

L<Mojo::UserAgent::Server> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 app

  my $app = Mojo::UserAgent::Server->app;
            Mojo::UserAgent::Server->app(Mojolicious->new);
  my $app = $server->app;
  $server = $server->app(Mojolicious->new);

Application this server handles, instance specific applications override the global default.

  # Change application behavior
  $server->app->defaults(testing => 'oh yea!');

=head2 nb_url

  my $url = $server->nb_url;
  my $url = $server->nb_url('http');
  my $url = $server->nb_url('https');

Get absolute L<Mojo::URL> object for server processing non-blocking requests with L</"app"> and switch protocol if
necessary.

=head2 restart

  $server->restart;

Restart server with new port.

=head2 url

  my $url = $server->url;
  my $url = $server->url('http');
  my $url = $server->url('https');

Get absolute L<Mojo::URL> object for server processing blocking requests with L</"app"> and switch protocol if
necessary.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::UserAgent::CookieJar;
use Mojo::Base -base;

use Mojo::Cookie::Request;
use Mojo::Path;
use Scalar::Util qw(looks_like_number);

has 'ignore';
has max_cookie_size => 4096;

sub add {
  my ($self, @cookies) = @_;

  my $size = $self->max_cookie_size;
  for my $cookie (@cookies) {

    # Convert max age to expires
    my $age = $cookie->max_age;
    $cookie->expires($age <= 0 ? 0 : $age + time) if looks_like_number $age;

    # Check cookie size
    next if length($cookie->value // '') > $size;

    # Replace cookie
    next unless my $domain = lc($cookie->domain // '');
    next unless my $path   = $cookie->path;
    next unless length(my $name = $cookie->name // '');
    my $jar = $self->{jar}{$domain} //= [];
    @$jar = (grep({ _compare($_, $path, $name, $domain) } @$jar), $cookie);
  }

  return $self;
}

sub all {
  my $jar = shift->{jar};
  return [map { @{$jar->{$_}} } sort keys %$jar];
}

sub collect {
  my ($self, $tx) = @_;

  my $url = $tx->req->url;
  for my $cookie (@{$tx->res->cookies}) {

    # Validate domain
    my $host = lc $url->ihost;
    $cookie->domain($host)->host_only(1) unless $cookie->domain;
    my $domain = lc $cookie->domain;
    if (my $cb = $self->ignore) { next if $cb->($cookie) }
    next if $host ne $domain && ($host !~ /\Q.$domain\E$/ || $host =~ /\.\d+$/);

    # Validate path
    my $path = $cookie->path // $url->path->to_dir->to_abs_string;
    $path = Mojo::Path->new($path)->trailing_slash(0)->to_abs_string;
    next unless _path($path, $url->path->to_abs_string);
    $self->add($cookie->path($path));
  }
}

sub empty { delete shift->{jar} }

sub find {
  my ($self, $url) = @_;

  my @found;
  my $domain = my $host = lc $url->ihost;
  my $path   = $url->path->to_abs_string;
  while ($domain) {
    next unless my $old = $self->{jar}{$domain};

    # Grab cookies
    my $new = $self->{jar}{$domain} = [];
    for my $cookie (@$old) {
      next if $cookie->host_only && $host ne $cookie->domain;

      # Check if cookie has expired
      if (defined(my $expires = $cookie->expires)) { next if time > $expires }
      push @$new, $cookie;

      # Taste cookie
      next if $cookie->secure && $url->protocol ne 'https';
      next unless _path($cookie->path, $path);
      my $name  = $cookie->name;
      my $value = $cookie->value;
      push @found, Mojo::Cookie::Request->new(name => $name, value => $value);
    }
  }

  # Remove another part
  continue { $domain =~ s/^[^.]*\.*// }

  return \@found;
}

sub prepare {
  my ($self, $tx) = @_;
  return unless keys %{$self->{jar}};
  my $req = $tx->req;
  $req->cookies(@{$self->find($req->url)});
}

sub _compare {
  my ($cookie, $path, $name, $domain) = @_;
  return $cookie->path ne $path || $cookie->name ne $name || $cookie->domain ne $domain;
}

sub _path { $_[0] eq '/' || $_[0] eq $_[1] || index($_[1], "$_[0]/") == 0 }

1;

=encoding utf8

=head1 NAME

Mojo::UserAgent::CookieJar - Cookie jar for HTTP user agents

=head1 SYNOPSIS

  use Mojo::UserAgent::CookieJar;

  # Add response cookies
  my $jar = Mojo::UserAgent::CookieJar->new;
  $jar->add(
    Mojo::Cookie::Response->new(
      name   => 'foo',
      value  => 'bar',
      domain => 'localhost',
      path   => '/test'
    )
  );

  # Find request cookies
  for my $cookie (@{$jar->find(Mojo::URL->new('http://localhost/test'))}) {
    say $cookie->name;
    say $cookie->value;
  }

=head1 DESCRIPTION

L<Mojo::UserAgent::CookieJar> is a minimalistic and relaxed cookie jar used by L<Mojo::UserAgent>, based on L<RFC
6265|https://tools.ietf.org/html/rfc6265>.

=head1 ATTRIBUTES

L<Mojo::UserAgent::CookieJar> implements the following attributes.

=head2 ignore

  my $ignore = $jar->ignore;
  $jar       = $jar->ignore(sub {...});

A callback used to decide if a cookie should be ignored by L</"collect">.

  # Ignore all cookies
  $jar->ignore(sub { 1 });

  # Ignore cookies for domains "com", "net" and "org"
  $jar->ignore(sub ($cookie) {
    return undef unless my $domain = $cookie->domain;
    return $domain eq 'com' || $domain eq 'net' || $domain eq 'org';
  });

=head2 max_cookie_size

  my $size = $jar->max_cookie_size;
  $jar     = $jar->max_cookie_size(4096);

Maximum cookie size in bytes, defaults to C<4096> (4KiB).

=head1 METHODS

L<Mojo::UserAgent::CookieJar> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 add

  $jar = $jar->add(@cookies);

Add multiple L<Mojo::Cookie::Response> objects to the jar.

=head2 all

  my $cookies = $jar->all;

Return all L<Mojo::Cookie::Response> objects that are currently stored in the jar.

  # Names of all cookies
  say $_->name for @{$jar->all};

=head2 collect

  $jar->collect(Mojo::Transaction::HTTP->new);

Collect response cookies from transaction.

=head2 empty

  $jar->empty;

Empty the jar.

=head2 find

  my $cookies = $jar->find(Mojo::URL->new);

Find L<Mojo::Cookie::Request> objects in the jar for L<Mojo::URL> object.

  # Names of all cookies found
  say $_->name for @{$jar->find(Mojo::URL->new('http://example.com/foo'))};

=head2 prepare

  $jar->prepare(Mojo::Transaction::HTTP->new);

Prepare request cookies for transaction.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::UserAgent::Transactor;
use Mojo::Base -base;

use Mojo::Asset::File;
use Mojo::Asset::Memory;
use Mojo::Content::MultiPart;
use Mojo::Content::Single;
use Mojo::File qw(path);
use Mojo::JSON qw(encode_json);
use Mojo::Parameters;
use Mojo::Transaction::HTTP;
use Mojo::Transaction::WebSocket;
use Mojo::URL;
use Mojo::Util      qw(encode url_escape);
use Mojo::WebSocket qw(challenge client_handshake);

has compressed => sub { $ENV{MOJO_GZIP} // 1 };
has generators => sub { {form => \&_form, json => \&_json, multipart => \&_multipart} };
has name       => 'Mojolicious (Perl)';

sub add_generator { $_[0]->generators->{$_[1]} = $_[2] and return $_[0] }

sub endpoint {
  my ($self, $tx) = @_;

  # Basic endpoint
  my $req   = $tx->req;
  my $url   = $req->url;
  my $proto = $url->protocol || 'http';
  my $host  = $url->ihost;
  my $port  = $url->port // ($proto eq 'https' ? 443 : 80);

  # Proxy for normal HTTP requests
  my $socks;
  if (my $proxy = $req->proxy) { $socks = $proxy->protocol eq 'socks' }
  return _proxy($tx, $proto, $host, $port) if $proto eq 'http' && !$req->is_handshake && !$socks;

  return $proto, $host, $port;
}

sub peer { _proxy($_[1], $_[0]->endpoint($_[1])) }

sub promisify {
  my ($self, $promise, $tx) = @_;
  my $err = $tx->error;
  return $promise->reject($err->{message})              if $err                   && !$err->{code};
  return $promise->reject('WebSocket handshake failed') if $tx->req->is_handshake && !$tx->is_websocket;
  $promise->resolve($tx);
}

sub proxy_connect {
  my ($self, $old) = @_;

  # Already a CONNECT request
  my $req = $old->req;
  return undef if uc $req->method eq 'CONNECT';

  # No proxy
  return undef unless (my $proxy = $req->proxy) && $req->via_proxy;
  return undef if $proxy->protocol eq 'socks';

  # WebSocket and/or HTTPS
  my $url = $req->url;
  return undef unless $req->is_handshake || $url->protocol eq 'https';

  # CONNECT request (expect a bad response)
  my $new = $self->tx(CONNECT => $url->clone->userinfo(undef));
  $new->req->proxy($proxy);
  $new->res->content->auto_relax(0)->headers->connection('keep-alive');

  return $new;
}

sub redirect {
  my ($self, $old) = @_;

  # Commonly used codes
  my $res  = $old->res;
  my $code = $res->code // 0;
  return undef unless grep { $_ == $code } 301, 302, 303, 307, 308;

  # CONNECT requests cannot be redirected
  my $req = $old->req;
  return undef if uc $req->method eq 'CONNECT';

  # Fix location without authority and/or scheme
  return undef unless my $location = $res->headers->every_header('Location')->[0];
  $location = Mojo::URL->new($location);
  $location = $location->base($req->url)->to_abs unless $location->is_abs;
  my $proto = $location->protocol;
  return undef if ($proto ne 'http' && $proto ne 'https') || !$location->host;

  # Clone request if necessary
  my $new = Mojo::Transaction::HTTP->new;
  if ($code == 307 || $code == 308) {
    return undef unless my $clone = $req->clone;
    $new->req($clone);
  }
  else {
    my $method = uc $req->method;
    $method = $code == 303 || $method eq 'POST' ? 'GET' : $method;
    $new->req->method($method)->content->headers(my $headers = $req->headers->clone);
    $headers->remove($_) for grep {/^content-/i} @{$headers->names};
  }

  $new->res->content->auto_decompress(0) unless $self->compressed;
  my $headers = $new->req->url($location)->headers;
  $headers->remove($_) for qw(Authorization Cookie Host Referer);

  return $new->previous($old);
}

sub tx {
  my ($self, $method, $url) = (shift, shift, shift);

  # Method and URL
  my $tx  = Mojo::Transaction::HTTP->new;
  my $req = $tx->req->method($method);
  ref $url ? $req->url($url) : $req->url->parse($url =~ m!^/|://! ? $url : "http://$url");

  # Headers (we identify ourselves and accept gzip compression)
  my $headers = $req->headers;
  $headers->from_hash(shift) if ref $_[0] eq 'HASH';
  $headers->user_agent($self->name) unless $headers->user_agent;
  if    (!$self->compressed)         { $tx->res->content->auto_decompress(0) }
  elsif (!$headers->accept_encoding) { $headers->accept_encoding('gzip') }

  # Generator
  if (@_ > 1) {
    my $cb = $self->generators->{shift()};
    $self->$cb($tx, @_);
  }

  # Body
  elsif (@_) { $req->body(shift) }

  return $tx;
}

sub upgrade {
  my ($self, $tx) = @_;
  my $code = $tx->res->code // 0;
  return undef unless $tx->req->is_handshake && $code == 101;
  my $ws = Mojo::Transaction::WebSocket->new(handshake => $tx, masked => 1);
  return challenge($ws) ? $ws->established(1) : undef;
}

sub websocket {
  my $self = shift;

  # New WebSocket transaction
  my $sub = ref $_[-1] eq 'ARRAY' ? pop : [];
  my $tx  = $self->tx(GET => @_);
  my $req = $tx->req;
  $req->headers->sec_websocket_protocol(join ', ', @$sub) if @$sub;

  # Handshake protocol
  my $url   = $req->url;
  my $proto = $url->protocol // '';
  if    ($proto eq 'ws')      { $url->scheme('http') }
  elsif ($proto eq 'wss')     { $url->scheme('https') }
  elsif ($proto eq 'ws+unix') { $url->scheme('http+unix') }

  return client_handshake $tx;
}

sub _content { Mojo::Content::MultiPart->new(headers => $_[0], parts => $_[1]) }

sub _form {
  my ($self, $tx, $form, %options) = @_;
  $options{charset} = 'UTF-8' unless exists $options{charset};

  # Check for uploads and force multipart if necessary
  my $req       = $tx->req;
  my $headers   = $req->headers;
  my $multipart = ($headers->content_type // '') =~ m!multipart/form-data!i;
  for my $value (map { ref $_ eq 'ARRAY' ? @$_ : $_ } values %$form) {
    ++$multipart and last if ref $value eq 'HASH';
  }

  # Multipart
  if ($multipart) {
    $req->content(_content($headers, _form_parts($options{charset}, $form)));
    _type($headers, 'multipart/form-data');
    return $tx;
  }

  # Query parameters or urlencoded
  my $method = uc $req->method;
  my @form   = map { $_ => $form->{$_} } sort keys %$form;
  if ($method eq 'GET' || $method eq 'HEAD') { $req->url->query->merge(@form) }
  else {
    $req->body(Mojo::Parameters->new(@form)->charset($options{charset})->to_string);
    _type($headers, 'application/x-www-form-urlencoded');
  }

  return $tx;
}

sub _form_parts {
  my ($charset, $form) = @_;

  my @parts;
  for my $name (sort keys %$form) {
    next                unless defined(my $values = $form->{$name});
    $values = [$values] unless ref $values eq 'ARRAY';
    push @parts, @{_parts($charset, $name, $values)};
  }

  return \@parts;
}

sub _json {
  my ($self, $tx, $data) = @_;
  _type($tx->req->body(encode_json $data)->headers, 'application/json');
  return $tx;
}

sub _multipart {
  my ($self, $tx, $parts) = @_;
  my $req = $tx->req;
  $req->content(_content($req->headers, _parts(undef, undef, $parts)));
  return $tx;
}

sub _parts {
  my ($charset, $name, $values) = @_;

  my @parts;
  for my $value (@$values) {
    push @parts, my $part = Mojo::Content::Single->new;

    my $filename;
    my $headers = $part->headers;
    if (ref $value eq 'HASH') {

      # File
      if (my $file = delete $value->{file}) {
        $file = Mojo::Asset::File->new(path => $file) unless ref $file;
        $part->asset($file);
        $value->{filename} //= path($file->path)->basename if $file->isa('Mojo::Asset::File');
      }

      # Memory
      elsif (defined(my $content = delete $value->{content})) {
        $part->asset(Mojo::Asset::Memory->new->add_chunk($content));
      }

      # Filename and headers
      $filename = delete $value->{filename};
      $headers->from_hash($value);
      next unless defined $name;
      $filename = url_escape $filename // $name, '"';
      $filename = encode $charset, $filename if $charset;
    }

    # Field
    else {
      $value = encode $charset, $value if $charset;
      $part->asset(Mojo::Asset::Memory->new->add_chunk($value));
    }

    # Content-Disposition
    next if !defined $name || defined $headers->content_disposition;
    $name = url_escape $name, '"';
    $name = encode $charset,  $name if $charset;
    my $disposition = qq{form-data; name="$name"};
    $disposition .= qq{; filename="$filename"} if defined $filename;
    $headers->content_disposition($disposition);
  }

  return \@parts;
}

sub _proxy {
  my ($tx, $proto, $host, $port) = @_;

  my $req = $tx->req;
  if ($req->via_proxy && (my $proxy = $req->proxy)) {
    return $proxy->protocol, $proxy->ihost, $proxy->port // ($proto eq 'https' ? 443 : 80);
  }

  return $proto, $host, $port;
}

sub _type { $_[0]->content_type($_[1]) unless $_[0]->content_type }

1;

=encoding utf8

=head1 NAME

Mojo::UserAgent::Transactor - User agent transactor

=head1 SYNOPSIS

  use Mojo::UserAgent::Transactor;

  # GET request with Accept header
  my $t = Mojo::UserAgent::Transactor->new;
  say $t->tx(GET => 'http://example.com' => {Accept => '*/*'})->req->to_string;

  # POST request with form-data
  say $t->tx(POST => 'example.com' => form => {a => 'b'})->req->to_string;

  # PUT request with JSON data
  say $t->tx(PUT => 'example.com' => json => {a => 'b'})->req->to_string;

=head1 DESCRIPTION

L<Mojo::UserAgent::Transactor> is the transaction building and manipulation framework used by L<Mojo::UserAgent>.

=head1 GENERATORS

These content generators are available by default.

=head2 form

  $t->tx(POST => 'http://example.com' => form => {a => 'b'});

Generate query string, C<application/x-www-form-urlencoded> or C<multipart/form-data> content. See L</"tx"> for more.

=head2 json

  $t->tx(PATCH => 'http://example.com' => json => {a => 'b'});

Generate JSON content with L<Mojo::JSON>. See L</"tx"> for more.

=head2 multipart

  $t->tx(PUT => 'http://example.com' => multipart => ['Hello', 'World!']);

Generate multipart content. See L</"tx"> for more.

=head1 ATTRIBUTES

L<Mojo::UserAgent::Transactor> implements the following attributes.

=head2 compressed

  my $bool = $t->compressed;
  $t       = $t->compressed($bool);

Try to negotiate compression for the response content and decompress it automatically, defaults to the value of the
C<MOJO_GZIP> environment variable or true.

=head2 generators

  my $generators = $t->generators;
  $t             = $t->generators({foo => sub {...}});

Registered content generators, by default only C<form>, C<json> and C<multipart> are already defined.

=head2 name

  my $name = $t->name;
  $t       = $t->name('Mojolicious');

Value for C<User-Agent> request header of generated transactions, defaults to C<Mojolicious (Perl)>.

=head1 METHODS

L<Mojo::UserAgent::Transactor> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 add_generator

  $t = $t->add_generator(foo => sub {...});

Register a content generator.

  $t->add_generator(foo => sub ($t, $tx, @args) {...});

=head2 endpoint

  my ($proto, $host, $port) = $t->endpoint(Mojo::Transaction::HTTP->new);

Actual endpoint for transaction.

=head2 peer

  my ($proto, $host, $port) = $t->peer(Mojo::Transaction::HTTP->new);

Actual peer for transaction.

=head2 promisify

  $t->promisify(Mojo::Promise->new, Mojo::Transaction::HTTP->new);

Resolve or reject L<Mojo::Promise> object with L<Mojo::Transaction::HTTP> object.

=head2 proxy_connect

  my $tx = $t->proxy_connect(Mojo::Transaction::HTTP->new);

Build L<Mojo::Transaction::HTTP> proxy C<CONNECT> request for transaction if possible.

=head2 redirect

  my $tx = $t->redirect(Mojo::Transaction::HTTP->new);

Build L<Mojo::Transaction::HTTP> follow-up request for C<301>, C<302>, C<303>, C<307> or C<308> redirect response if
possible.

=head2 tx

  my $tx = $t->tx(GET  => 'example.com');
  my $tx = $t->tx(POST => 'http://example.com');
  my $tx = $t->tx(GET  => 'http://example.com' => {Accept => '*/*'});
  my $tx = $t->tx(PUT  => 'http://example.com' => 'Content!');
  my $tx = $t->tx(PUT  => 'http://example.com' => form => {a => 'b'});
  my $tx = $t->tx(PUT  => 'http://example.com' => json => {a => 'b'});
  my $tx = $t->tx(PUT  => 'https://example.com' => multipart => ['a', 'b']);
  my $tx = $t->tx(POST => 'example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $t->tx(PUT => 'example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $t->tx(PUT => 'example.com' => {Accept => '*/*'} => json => {a => 'b'});
  my $tx = $t->tx(PUT => 'example.com' => {Accept => '*/*'} => multipart => ['a', 'b']);

Versatile general purpose L<Mojo::Transaction::HTTP> transaction builder for requests, with support for
L</"GENERATORS">.

  # Generate and inspect custom GET request with DNT header and content
  say $t->tx(GET => 'example.com' => {DNT => 1} => 'Bye!')->req->to_string;

  # Stream response content to STDOUT
  my $tx = $t->tx(GET => 'http://example.com');
  $tx->res->content->unsubscribe('read')->on(read => sub { say $_[1] });

  # PUT request with content streamed from file
  my $tx = $t->tx(PUT => 'http://example.com');
  $tx->req->content->asset(Mojo::Asset::File->new(path => '/foo.txt'));

The C<json> content generator uses L<Mojo::JSON> for encoding and sets the content type to C<application/json>.

  # POST request with "application/json" content
  my $tx = $t->tx(POST => 'http://example.com' => json => {a => 'b', c => [1, 2, 3]});

The C<form> content generator will automatically use query parameters for C<GET> and C<HEAD> requests.

  # GET request with query parameters
  my $tx = $t->tx(GET => 'http://example.com' => form => {a => 'b'});

For all other request methods the C<application/x-www-form-urlencoded> content type is used.

  # POST request with "application/x-www-form-urlencoded" content
  my $tx = $t->tx(POST => 'http://example.com' => form => {a => 'b', c => 'd'});

Parameters may be encoded with the C<charset> option.

  # PUT request with Shift_JIS encoded form values
  my $tx = $t->tx(PUT => 'example.com' => form => {a => 'b'} => charset => 'Shift_JIS');

An array reference can be used for multiple form values sharing the same name.

  # POST request with form values sharing the same name
  my $tx = $t->tx(POST => 'http://example.com' => form => {a => ['b', 'c', 'd']});

A hash reference with a C<content> or C<file> value can be used to switch to the C<multipart/form-data> content type
for file uploads.

  # POST request with "multipart/form-data" content
  my $tx = $t->tx(POST => 'http://example.com' => form => {mytext => {content => 'lala'}});

  # POST request with multiple files sharing the same name
  my $tx = $t->tx(POST => 'http://example.com' => form => {mytext => [{content => 'first'}, {content => 'second'}]});

The C<file> value should contain the path to the file you want to upload or an asset object, like L<Mojo::Asset::File>
or L<Mojo::Asset::Memory>.

  # POST request with upload streamed from file
  my $tx = $t->tx(POST => 'http://example.com' => form => {mytext => {file => '/foo.txt'}});

  # POST request with upload streamed from asset
  my $asset = Mojo::Asset::Memory->new->add_chunk('lalala');
  my $tx    = $t->tx(POST => 'http://example.com' => form => {mytext => {file => $asset}});

A C<filename> value will be generated automatically, but can also be set manually if necessary. All remaining values in
the hash reference get merged into the C<multipart/form-data> content as headers.

  # POST request with form values and customized upload (filename and header)
  my $tx = $t->tx(POST => 'http://example.com' => form => {
    a      => 'b',
    c      => 'd',
    mytext => {
      content        => 'lalala',
      filename       => 'foo.txt',
      'Content-Type' => 'text/plain'
    }
  });

The C<multipart/form-data> content type can also be enforced by setting the C<Content-Type> header manually.

  # Force "multipart/form-data"
  my $headers = {'Content-Type' => 'multipart/form-data'};
  my $tx = $t->tx(POST => 'example.com' => $headers => form => {a => 'b'});

The C<multipart> content generator can be used to build custom multipart requests and does not set a content type.

  # POST request with multipart content ("foo" and "bar")
  my $tx = $t->tx(POST => 'http://example.com' => multipart => ['foo', 'bar']);

Similar to the C<form> content generator you can also pass hash references with C<content> or C<file> values, as well
as headers.

  # POST request with multipart content streamed from file
  my $tx = $t->tx(POST => 'http://example.com' => multipart => [{file => '/foo.txt'}]);

  # PUT request with multipart content streamed from asset
  my $headers = {'Content-Type' => 'multipart/custom'};
  my $asset   = Mojo::Asset::Memory->new->add_chunk('lalala');
  my $tx      = $t->tx(PUT => 'http://example.com' => $headers => multipart => [{file => $asset}]);

  # POST request with multipart content and custom headers
  my $tx = $t->tx(POST => 'http://example.com' => multipart => [
    {
      content            => 'Hello',
      'Content-Type'     => 'text/plain',
      'Content-Language' => 'en-US'
    },
    {
      content            => 'World!',
      'Content-Type'     => 'text/plain',
      'Content-Language' => 'en-US'
    }
  ]);

=head2 upgrade

  my $tx = $t->upgrade(Mojo::Transaction::HTTP->new);

Build L<Mojo::Transaction::WebSocket> follow-up transaction for WebSocket handshake if possible.

=head2 websocket

  my $tx = $t->websocket('ws://example.com');
  my $tx = $t->websocket('ws://example.com' => {DNT => 1} => ['v1.proto']);

Versatile L<Mojo::Transaction::HTTP> transaction builder for WebSocket handshake requests.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::UserAgent::Proxy;
use Mojo::Base -base;

use Mojo::URL;

has [qw(http https not)];

sub detect {
  my $self = shift;
  $self->http($ENV{HTTP_PROXY}   || $ENV{http_proxy});
  $self->https($ENV{HTTPS_PROXY} || $ENV{https_proxy});
  return $self->not([split /,/, $ENV{NO_PROXY} || $ENV{no_proxy} || '']);
}

sub is_needed {
  !grep { $_[1] =~ /\Q$_\E$/ } @{$_[0]->not // []};
}

sub prepare {
  my ($self, $tx) = @_;

  $self->detect if $ENV{MOJO_PROXY};
  my $req = $tx->req;
  my $url = $req->url;
  return unless $self->is_needed($url->host);

  # HTTP proxy
  my $proto = $url->protocol;
  my $http  = $self->http;
  $req->proxy(Mojo::URL->new($http)) if $http && $proto eq 'http';

  # HTTPS proxy
  my $https = $self->https;
  $req->proxy(Mojo::URL->new($https)) if $https && $proto eq 'https';
}

1;

=encoding utf8

=head1 NAME

Mojo::UserAgent::Proxy - User agent proxy manager

=head1 SYNOPSIS

  use Mojo::UserAgent::Proxy;

  my $proxy = Mojo::UserAgent::Proxy->new;
  $proxy->detect;
  say $proxy->http;

=head1 DESCRIPTION

L<Mojo::UserAgent::Proxy> manages proxy servers for L<Mojo::UserAgent>.

=head1 ATTRIBUTES

L<Mojo::UserAgent::Proxy> implements the following attributes.

=head2 http

  my $http = $proxy->http;
  $proxy   = $proxy->http('socks://sri:secret@127.0.0.1:8080');

Proxy server to use for HTTP and WebSocket requests.

=head2 https

  my $https = $proxy->https;
  $proxy    = $proxy->https('http://sri:secret@127.0.0.1:8080');

Proxy server to use for HTTPS and WebSocket requests.

=head2 not

  my $not = $proxy->not;
  $proxy  = $proxy->not(['localhost', 'intranet.mojolicious.org']);

Domains that don't require a proxy server to be used.

=head1 METHODS

L<Mojo::UserAgent::Proxy> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 detect

  $proxy = $proxy->detect;

Check environment variables C<HTTP_PROXY>, C<http_proxy>, C<HTTPS_PROXY>, C<https_proxy>, C<NO_PROXY> and C<no_proxy>
for proxy information. Automatic proxy detection can be enabled with the C<MOJO_PROXY> environment variable.

=head2 is_needed

  my $bool = $proxy->is_needed('intranet.example.com');

Check if request for domain would use a proxy server.

=head2 prepare

  $proxy->prepare(Mojo::Transaction::HTTP->new);

Prepare proxy server information for transaction.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::HelloWorld;
use Mojo::Base 'Mojolicious';

sub startup {
  my $self = shift;
  $self->preload_namespaces([])->log->level('error')->path(undef);
  $self->routes->any('/*whatever' => {whatever => '', text => 'Your Mojo is working!'});
}

1;

=encoding utf8

=head1 NAME

Mojo::HelloWorld - Hello World!

=head1 SYNOPSIS

  use Mojo::HelloWorld;

  my $hello = Mojo::HelloWorld->new;
  $hello->start;

=head1 DESCRIPTION

L<Mojo::HelloWorld> is the default L<Mojolicious> application, used mostly for testing.

=head1 ATTRIBUTES

L<Mojo::HelloWorld> inherits all attributes from L<Mojolicious>.

=head1 METHODS

L<Mojo::HelloWorld> inherits all methods from L<Mojolicious> and implements the following new ones.

=head2 startup

  $hello->startup;

Creates a catch-all route that renders a text message.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Content::Single;
use Mojo::Base 'Mojo::Content';

use Mojo::Asset::Memory;
use Mojo::Content::MultiPart;

has asset        => sub { Mojo::Asset::Memory->new(auto_upgrade => 1) };
has auto_upgrade => 1;

sub body_contains { shift->asset->contains(shift) >= 0 }

sub body_size {
  my $self = shift;
  return ($self->headers->content_length || 0) if $self->is_dynamic;
  return $self->{body_size} //= $self->asset->size;
}

sub clone {
  my $self = shift;
  return undef unless my $clone = $self->SUPER::clone();
  return $clone->asset($self->asset);
}

sub get_body_chunk {
  my ($self, $offset) = @_;
  return $self->generate_body_chunk($offset) if $self->is_dynamic;
  return $self->asset->get_chunk($offset);
}

sub new {
  my $self = shift->SUPER::new(@_);
  $self->{read} = $self->on(read => sub { $_[0]->asset($_[0]->asset->add_chunk($_[1])) });
  return $self;
}

sub parse {
  my $self = shift;

  # Parse headers
  $self->_parse_until_body(@_);

  # Parse body
  return $self->SUPER::parse unless $self->auto_upgrade && defined $self->boundary;

  # Content needs to be upgraded to multipart
  $self->unsubscribe(read => $self->{read});
  my $multi = Mojo::Content::MultiPart->new(%$self);
  $self->emit(upgrade => $multi);
  return $multi->parse;
}

1;

=encoding utf8

=head1 NAME

Mojo::Content::Single - HTTP content

=head1 SYNOPSIS

  use Mojo::Content::Single;

  my $single = Mojo::Content::Single->new;
  $single->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
  say $single->headers->content_length;

=head1 DESCRIPTION

L<Mojo::Content::Single> is a container for HTTP content, based on L<RFC 7230|https://tools.ietf.org/html/rfc7230> and
L<RFC 7231|https://tools.ietf.org/html/rfc7231>.

=head1 EVENTS

L<Mojo::Content::Single> inherits all events from L<Mojo::Content> and can emit the following new ones.

=head2 upgrade

  $single->on(upgrade => sub ($single, $multi) {...});

Emitted when content gets upgraded to a L<Mojo::Content::MultiPart> object.

  $single->on(upgrade => sub ($single, $multi) {
    return unless $multi->headers->content_type =~ /multipart\/([^;]+)/i;
    say "Multipart: $1";
  });

=head1 ATTRIBUTES

L<Mojo::Content::Single> inherits all attributes from L<Mojo::Content> and implements the following new ones.

=head2 asset

  my $asset = $single->asset;
  $single   = $single->asset(Mojo::Asset::Memory->new);

The actual content, defaults to a L<Mojo::Asset::Memory> object with L<Mojo::Asset::Memory/"auto_upgrade"> enabled.

=head2 auto_upgrade

  my $bool = $single->auto_upgrade;
  $single  = $single->auto_upgrade($bool);

Try to detect multipart content and automatically upgrade to a L<Mojo::Content::MultiPart> object, defaults to a true
value.

=head1 METHODS

L<Mojo::Content::Single> inherits all methods from L<Mojo::Content> and implements the following new ones.

=head2 body_contains

  my $bool = $single->body_contains('1234567');

Check if content contains a specific string.

=head2 body_size

  my $size = $single->body_size;

Content size in bytes.

=head2 clone

  my $clone = $single->clone;

Return a new L<Mojo::Content::Single> object cloned from this content if possible, otherwise return C<undef>.

=head2 get_body_chunk

  my $bytes = $single->get_body_chunk(0);

Get a chunk of content starting from a specific position. Note that it might not be possible to get the same chunk
twice if content was generated dynamically.

=head2 new

  my $single = Mojo::Content::Single->new;
  my $single = Mojo::Content::Single->new(asset => Mojo::Asset::File->new);
  my $single = Mojo::Content::Single->new({asset => Mojo::Asset::File->new});

Construct a new L<Mojo::Content::Single> object and subscribe to event L<Mojo::Content/"read"> with default content
parser.

=head2 parse

  $single = $single->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
  my $multi = $single->parse("Content-Type: multipart/form-data\x0d\x0a\x0d\x0a");

Parse content chunk and upgrade to L<Mojo::Content::MultiPart> object if necessary.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Content::MultiPart;
use Mojo::Base 'Mojo::Content';

use Mojo::Util qw(b64_encode);

has parts => sub { [] };

sub body_contains {
  my ($self, $chunk) = @_;
  ($_->headers_contain($chunk) or $_->body_contains($chunk)) and return 1 for @{$self->parts};
  return undef;
}

sub body_size {
  my $self = shift;

  # Check for existing Content-Length header
  if (my $len = $self->headers->content_length) { return $len }

  # Calculate length of whole body
  my $len = my $boundary_len = length($self->build_boundary) + 6;
  $len += $_->header_size + $_->body_size + $boundary_len for @{$self->parts};

  return $len;
}

sub build_boundary {
  my $self = shift;

  # Check for existing boundary
  my $boundary;
  return $boundary if defined($boundary = $self->boundary);

  # Generate and check boundary
  my $size = 1;
  do {
    $boundary = b64_encode join('', map chr(rand 256), 1 .. $size++ * 3);
    $boundary =~ s/\W/X/g;
  } while $self->body_contains($boundary);

  # Add boundary to Content-Type header
  my $headers = $self->headers;
  my ($before, $after) = ('multipart/mixed', '');
  ($before, $after) = ($1, $2) if ($headers->content_type // '') =~ m!^(.*multipart/[^;]+)(.*)$!;
  $headers->content_type("$before; boundary=$boundary$after");

  return $boundary;
}

sub clone {
  my $self = shift;
  return undef unless my $clone = $self->SUPER::clone();
  return $clone->parts($self->parts);
}

sub get_body_chunk {
  my ($self, $offset) = @_;

  # Body generator
  return $self->generate_body_chunk($offset) if $self->is_dynamic;

  # First boundary
  my $boundary     = $self->{boundary} //= $self->build_boundary;
  my $boundary_len = length($boundary) + 6;
  my $len          = $boundary_len - 2;
  return substr "--$boundary\x0d\x0a", $offset if $len > $offset;

  # Skip parts that have already been processed
  my $start = 0;
  ($len, $start) = ($self->{last_len}, $self->{last_part} + 1) if $self->{offset} && $offset > $self->{offset};

  # Prepare content part by part
  my $parts = $self->parts;
  for (my $i = $start; $i < @$parts; $i++) {
    my $part = $parts->[$i];

    # Headers
    my $header_len = $part->header_size;
    return $part->get_header_chunk($offset - $len) if ($len + $header_len) > $offset;
    $len += $header_len;

    # Content
    my $content_len = $part->body_size;
    return $part->get_body_chunk($offset - $len) if ($len + $content_len) > $offset;
    $len += $content_len;

    # Boundary
    if ($#$parts == $i) {
      $boundary .= '--';
      $boundary_len += 2;
    }
    return substr "\x0d\x0a--$boundary\x0d\x0a", $offset - $len if ($len + $boundary_len) > $offset;
    $len += $boundary_len;

    @{$self}{qw(last_len last_part offset)} = ($len, $i, $offset);
  }
}

sub is_multipart {1}

sub new {
  my $self = shift->SUPER::new(@_);
  $self->on(read => \&_read);
  return $self;
}

sub _parse_multipart_body {
  my ($self, $boundary) = @_;

  # Whole part in buffer
  my $pos = index $self->{multipart}, "\x0d\x0a--$boundary";
  if ($pos < 0) {
    my $len = length($self->{multipart}) - (length($boundary) + 8);
    return undef unless $len > 0;

    # Store chunk
    my $chunk = substr $self->{multipart}, 0, $len, '';
    $self->parts->[-1] = $self->parts->[-1]->parse($chunk);
    return undef;
  }

  # Store chunk
  my $chunk = substr $self->{multipart}, 0, $pos, '';
  $self->parts->[-1] = $self->parts->[-1]->parse($chunk);
  return !!($self->{multi_state} = 'multipart_boundary');
}

sub _parse_multipart_boundary {
  my ($self, $boundary) = @_;

  # Boundary begins
  if ((index $self->{multipart}, "\x0d\x0a--$boundary\x0d\x0a") == 0) {
    substr $self->{multipart}, 0, length($boundary) + 6, '';

    # New part
    my $part = Mojo::Content::Single->new(relaxed => 1);
    $self->emit(part => $part);
    push @{$self->parts}, $part;
    return !!($self->{multi_state} = 'multipart_body');
  }

  # Boundary ends
  my $end = "\x0d\x0a--$boundary--";
  if ((index $self->{multipart}, $end) == 0) {
    substr $self->{multipart}, 0, length $end, '';
    $self->{multi_state} = 'finished';
  }

  return undef;
}

sub _parse_multipart_preamble {
  my ($self, $boundary) = @_;

  # No boundary yet
  return undef if (my $pos = index $self->{multipart}, "--$boundary") < 0;

  # Replace preamble with carriage return and line feed
  substr $self->{multipart}, 0, $pos, "\x0d\x0a";

  # Parse boundary
  return !!($self->{multi_state} = 'multipart_boundary');
}

sub _read {
  my ($self, $chunk) = @_;

  $self->{multipart} .= $chunk;
  my $boundary = $self->boundary;
  until (($self->{multi_state} //= 'multipart_preamble') eq 'finished') {

    # Preamble
    if ($self->{multi_state} eq 'multipart_preamble') { last unless $self->_parse_multipart_preamble($boundary) }

    # Boundary
    elsif ($self->{multi_state} eq 'multipart_boundary') { last unless $self->_parse_multipart_boundary($boundary) }

    # Body
    elsif ($self->{multi_state} eq 'multipart_body') { last unless $self->_parse_multipart_body($boundary) }
  }

  # Check buffer size
  @$self{qw(state limit)} = ('finished', 1) if length($self->{multipart} // '') > $self->max_buffer_size;
}

1;

=encoding utf8

=head1 NAME

Mojo::Content::MultiPart - HTTP multipart content

=head1 SYNOPSIS

  use Mojo::Content::MultiPart;

  my $multi = Mojo::Content::MultiPart->new;
  $multi->parse('Content-Type: multipart/mixed; boundary=---foobar');
  my $single = $multi->parts->[4];

=head1 DESCRIPTION

L<Mojo::Content::MultiPart> is a container for HTTP multipart content, based on L<RFC
7230|https://tools.ietf.org/html/rfc7230>, L<RFC 7231|https://tools.ietf.org/html/rfc7231> and L<RFC
2388|https://tools.ietf.org/html/rfc2388>.

=head1 EVENTS

L<Mojo::Content::MultiPart> inherits all events from L<Mojo::Content> and can emit the following new ones.

=head2 part

  $multi->on(part => sub ($multi, $single) {...});

Emitted when a new L<Mojo::Content::Single> part starts.

  $multi->on(part => sub ($multi, $single) {
    return unless $single->headers->content_disposition =~ /name="([^"]+)"/;
    say "Field: $1";
  });

=head1 ATTRIBUTES

L<Mojo::Content::MultiPart> inherits all attributes from L<Mojo::Content> and implements the following new ones.

=head2 parts

  my $parts = $multi->parts;
  $multi    = $multi->parts([Mojo::Content::Single->new]);

Content parts embedded in this multipart content, usually L<Mojo::Content::Single> objects.

=head1 METHODS

L<Mojo::Content::MultiPart> inherits all methods from L<Mojo::Content> and implements the following new ones.

=head2 body_contains

  my $bool = $multi->body_contains('foobarbaz');

Check if content parts contain a specific string.

=head2 body_size

  my $size = $multi->body_size;

Content size in bytes.

=head2 build_boundary

  my $boundary = $multi->build_boundary;

Generate a suitable boundary for content and add it to C<Content-Type> header.

=head2 clone

  my $clone = $multi->clone;

Return a new L<Mojo::Content::MultiPart> object cloned from this content if possible, otherwise return C<undef>.

=head2 get_body_chunk

  my $bytes = $multi->get_body_chunk(0);

Get a chunk of content starting from a specific position. Note that it might not be possible to get the same chunk
twice if content was generated dynamically.

=head2 is_multipart

  my $bool = $multi->is_multipart;

True, this is a L<Mojo::Content::MultiPart> object.

=head2 new

  my $multi = Mojo::Content::MultiPart->new;
  my $multi
    = Mojo::Content::MultiPart->new(parts => [Mojo::Content::Single->new]);
  my $multi
    = Mojo::Content::MultiPart->new({parts => [Mojo::Content::Single->new]});

Construct a new L<Mojo::Content::MultiPart> object and subscribe to event L<Mojo::Content/"read"> with default content
parser.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Upload;
use Mojo::Base -base;

has [qw(asset filename headers name)];

sub move_to { $_[0]->asset->move_to($_[1]) and return $_[0] }

sub size  { shift->asset->size }
sub slurp { shift->asset->slurp }

1;

=encoding utf8

=head1 NAME

Mojo::Upload - Upload

=head1 SYNOPSIS

  use Mojo::Upload;

  my $upload = Mojo::Upload->new;
  say $upload->filename;
  $upload->move_to('/home/sri/foo.txt');

=head1 DESCRIPTION

L<Mojo::Upload> is a container for uploaded files.

=head1 ATTRIBUTES

L<Mojo::Upload> implements the following attributes.

=head2 asset

  my $asset = $upload->asset;
  $upload   = $upload->asset(Mojo::Asset::File->new);

Asset containing the uploaded data, usually a L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object.

=head2 filename

  my $filename = $upload->filename;
  $upload      = $upload->filename('foo.txt');

Name of the uploaded file.

=head2 headers

  my $headers = $upload->headers;
  $upload     = $upload->headers(Mojo::Headers->new);

Headers for upload, usually a L<Mojo::Headers> object.

=head2 name

  my $name = $upload->name;
  $upload  = $upload->name('foo');

Name of the upload.

=head1 METHODS

L<Mojo::Upload> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 move_to

  $upload = $upload->move_to('/home/sri/foo.txt');

Move uploaded data into a specific file.

=head2 size

  my $size = $upload->size;

Size of uploaded data in bytes.

=head2 slurp

  my $bytes = $upload->slurp;

Read all uploaded data at once.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Loader;
use Mojo::Base -strict;

use Exporter qw(import);
use Mojo::Exception;
use Mojo::File qw(path);
use Mojo::Util qw(b64_decode class_to_path);

our @EXPORT_OK = qw(data_section file_is_binary find_modules find_packages load_class load_classes);

my (%BIN, %CACHE);

sub data_section { $_[0] ? $_[1] ? _all($_[0])->{$_[1]} : _all($_[0]) : undef }

sub file_is_binary { keys %{_all($_[0])} ? !!$BIN{$_[0]}{$_[1]} : undef }

sub find_modules {
  my ($ns, $options) = (shift, shift // {});

  my @ns  = split /::/, $ns;
  my @inc = grep { -d $$_ } map { path($_, @ns) } @INC;

  my %modules;
  for my $dir (@inc) {
    for my $file ($options->{recursive} ? $dir->list_tree->each : $dir->list->each) {
      next unless $$file =~ s/\.pm$//;
      $modules{join('::', $ns, @{$file->to_rel($$dir)})}++;
    }
  }

  return sort keys %modules;
}

sub find_packages {
  my $ns = shift;
  no strict 'refs';
  return sort map { /^(.+)::$/ ? "${ns}::$1" : () } keys %{"${ns}::"};
}

sub load_class {
  my $class = shift;

  # Invalid class name
  return 1 if ($class || '') !~ /^\w(?:[\w:']*\w)?$/;

  # Load if not already loaded
  return undef if $class->can('new') || eval "require $class; 1";

  # Does not exist
  return 1 if $@ =~ /^Can't locate \Q@{[class_to_path $class]}\E in \@INC/;

  # Real error
  return Mojo::Exception->new($@)->inspect;
}

sub load_classes {
  my $ns = shift;

  my @classes;
  for my $module (find_modules($ns, {recursive => 1})) {
    push @classes, $module unless my $e = load_class($module);
    die $e if ref $e;
  }

  return @classes;
}

sub _all {
  my $class = shift;

  return $CACHE{$class} if $CACHE{$class};
  local $.;
  my $handle = do { no strict 'refs'; \*{"${class}::DATA"} };
  return {} unless fileno $handle;
  seek $handle, 0, 0;
  my $data = join '', <$handle>;

  # Ignore everything before __DATA__ (some versions seek to start of file)
  $data =~ s/^.*\n__DATA__\r?\n/\n/s;

  # Ignore everything after __END__
  $data =~ s/\n__END__\r?\n.*$/\n/s;

  # Split files
  (undef, my @files) = split /^@@\s*(.+?)\s*\r?\n/m, $data;

  # Find data
  my $all = $CACHE{$class} = {};
  while (@files) {
    my ($name, $data) = splice @files, 0, 2;
    $all->{$name} = $name =~ s/\s*\(\s*base64\s*\)$// && ++$BIN{$class}{$name} ? b64_decode $data : $data;
  }

  return $all;
}

1;

=encoding utf8

=head1 NAME

Mojo::Loader - Load all kinds of things

=head1 SYNOPSIS

  use Mojo::Loader qw(data_section find_modules load_class);

  # Find modules in a namespace
  for my $module (find_modules 'Some::Namespace') {

    # Load them safely
    my $e = load_class $module;
    warn qq{Loading "$module" failed: $e} and next if ref $e;

    # And extract files from the DATA section
    say data_section($module, 'some_file.txt');
  }

=head1 DESCRIPTION

L<Mojo::Loader> is a class loader and plugin framework. Aside from finding modules and loading classes, it allows
multiple files to be stored in the C<DATA> section of a class, which can then be accessed individually.

  package Foo;

  1;
  __DATA__

  @@ test.txt
  This is the first file.

  @@ test2.html (base64)
  VGhpcyBpcyB0aGUgc2Vjb25kIGZpbGUu

  @@ test
  This is the
  third file.

Each file has a header starting with C<@@>, followed by the file name and optional instructions for decoding its
content. Currently only the Base64 encoding is supported, which can be quite convenient for the storage of binary data.

=head1 FUNCTIONS

L<Mojo::Loader> implements the following functions, which can be imported individually.

=head2 data_section

  my $all   = data_section 'Foo::Bar';
  my $index = data_section 'Foo::Bar', 'index.html';

Extract embedded file from the C<DATA> section of a class, all files will be cached once they have been accessed for
the first time.

  # List embedded files
  say for keys %{data_section 'Foo::Bar'};

=head2 file_is_binary

  my $bool = file_is_binary 'Foo::Bar', 'test.png';

Check if embedded file from the C<DATA> section of a class was Base64 encoded.

=head2 find_packages

  my @pkgs = find_packages 'MyApp::Namespace';

Search for packages in a namespace non-recursively.

=head2 find_modules

  my @modules = find_modules 'MyApp::Namespace';
  my @modules = find_modules 'MyApp::Namespace', {recursive => 1};

Search for modules in a namespace.

These options are currently available:

=over 2

=item recursive

  recursive => 1

Search namespace recursively.

=back

=head2 load_class

  my $e = load_class 'Foo::Bar';

Load a class and catch exceptions, returns a false value if loading was successful, a true value if the class was not
found, or a L<Mojo::Exception> object if loading failed. Note that classes are checked for a C<new> method to see if
they are already loaded, so trying to load the same class multiple times may yield different results.

  # Handle exceptions
  if (my $e = load_class 'Foo::Bar') {
    die ref $e ? "Exception: $e" : 'Not found!';
  }

=head2 load_classes

  my @classes = load_classes 'Foo::Bar';

Load all classes in a namespace recursively.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Path;
use Mojo::Base -base;
use overload '@{}' => sub { shift->parts }, bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;

use Mojo::Util qw(decode encode url_escape url_unescape);

has charset => 'UTF-8';

sub canonicalize {
  my $self = shift;

  my $parts = $self->parts;
  for (my $i = 0; $i <= $#$parts;) {
    if    (!length $parts->[$i] || $parts->[$i] eq '.' || $parts->[$i] eq '...') { splice @$parts, $i, 1 }
    elsif ($i < 1 || $parts->[$i] ne '..' || $parts->[$i - 1] eq '..')           { $i++ }
    else                                                                         { splice @$parts, --$i, 2 }
  }

  return @$parts ? $self : $self->trailing_slash(undef);
}

sub clone {
  my $self = shift;

  my $clone = $self->new;
  if (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
  if (my $parts = $self->{parts}) {
    $clone->{$_} = $self->{$_} for qw(leading_slash trailing_slash);
    $clone->{parts} = [@$parts];
  }
  else { $clone->{path} = $self->{path} }

  return $clone;
}

sub contains { $_[1] eq '/' || $_[0]->to_route =~ m!^\Q$_[1]\E(?:/|$)! }

sub leading_slash { shift->_parse(leading_slash => @_) }

sub merge {
  my ($self, $path) = @_;

  # Replace
  return $self->parse($path) if $path =~ m!^/!;

  # Merge
  pop @{$self->parts} unless $self->trailing_slash;
  $path = $self->new($path);
  push @{$self->parts}, @{$path->parts};
  return $self->trailing_slash($path->trailing_slash);
}

sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }

sub parse {
  my $self = shift;
  $self->{path} = shift;
  delete @$self{qw(leading_slash parts trailing_slash)};
  return $self;
}

sub parts { shift->_parse(parts => @_) }

sub to_abs_string {
  my $path = shift->to_string;
  return $path =~ m!^/! ? $path : "/$path";
}

sub to_dir {
  my $clone = shift->clone;
  pop @{$clone->parts} unless $clone->trailing_slash;
  return $clone->trailing_slash(!!@{$clone->parts});
}

sub to_route {
  my $clone = shift->clone;
  return '/' . join '/', @{$clone->parts}, $clone->trailing_slash ? '' : ();
}

sub to_string {
  my $self = shift;

  # Path
  my $charset = $self->charset;
  if (defined(my $path = $self->{path})) {
    $path = encode $charset, $path if $charset;
    return url_escape $path, '^A-Za-z0-9\-._~!$&\'()*+,;=%:@/';
  }

  # Build path
  my @parts = @{$self->parts};
  @parts = map { encode $charset, $_ } @parts if $charset;
  my $path = join '/', map { url_escape $_, '^A-Za-z0-9\-._~!$&\'()*+,;=:@' } @parts;
  $path = "/$path" if $self->leading_slash;
  $path = "$path/" if $self->trailing_slash;
  return $path;
}

sub trailing_slash { shift->_parse(trailing_slash => @_) }

sub _parse {
  my ($self, $name) = (shift, shift);

  unless ($self->{parts}) {
    my $path    = url_unescape delete($self->{path}) // '';
    my $charset = $self->charset;
    $path                   = decode($charset, $path) // $path if $charset;
    $self->{leading_slash}  = $path =~ s!^/!!;
    $self->{trailing_slash} = $path =~ s!/$!!;
    $self->{parts}          = [split /\//, $path, -1];
  }

  return $self->{$name} unless @_;
  $self->{$name} = shift;
  return $self;
}

1;

=encoding utf8

=head1 NAME

Mojo::Path - Path

=head1 SYNOPSIS

  use Mojo::Path;

  # Parse
  my $path = Mojo::Path->new('/foo%2Fbar%3B/baz.html');
  say $path->[0];

  # Build
  my $path = Mojo::Path->new('/i/â™¥');
  push @$path, 'mojolicious';
  say "$path";

=head1 DESCRIPTION

L<Mojo::Path> is a container for paths used by L<Mojo::URL>, based on L<RFC 3986|https://tools.ietf.org/html/rfc3986>.

=head1 ATTRIBUTES

L<Mojo::Path> implements the following attributes.

=head2 charset

  my $charset = $path->charset;
  $path       = $path->charset('UTF-8');

Charset used for encoding and decoding, defaults to C<UTF-8>.

  # Disable encoding and decoding
  $path->charset(undef);

=head1 METHODS

L<Mojo::Path> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 canonicalize

  $path = $path->canonicalize;

Canonicalize path by resolving C<.> and C<..>, in addition C<...> will be treated as C<.> to protect from path
traversal attacks.

  # "/foo/baz"
  Mojo::Path->new('/foo/./bar/../baz')->canonicalize;

  # "/../baz"
  Mojo::Path->new('/foo/../bar/../../baz')->canonicalize;

  # "/foo/bar"
  Mojo::Path->new('/foo/.../bar')->canonicalize;

=head2 clone

  my $clone = $path->clone;

Return a new L<Mojo::Path> object cloned from this path.

=head2 contains

  my $bool = $path->contains('/i/â™¥/mojolicious');

Check if path contains given prefix.

  # True
  Mojo::Path->new('/foo/bar')->contains('/');
  Mojo::Path->new('/foo/bar')->contains('/foo');
  Mojo::Path->new('/foo/bar')->contains('/foo/bar');

  # False
  Mojo::Path->new('/foo/bar')->contains('/f');
  Mojo::Path->new('/foo/bar')->contains('/bar');
  Mojo::Path->new('/foo/bar')->contains('/whatever');

=head2 leading_slash

  my $bool = $path->leading_slash;
  $path    = $path->leading_slash($bool);

Path has a leading slash. Note that this method will normalize the path and that C<%2F> will be treated as C</> for
security reasons.

  # "/foo/bar"
  Mojo::Path->new('foo/bar')->leading_slash(1);

  # "foo/bar"
  Mojo::Path->new('/foo/bar')->leading_slash(0);

=head2 merge

  $path = $path->merge('/foo/bar');
  $path = $path->merge('foo/bar');
  $path = $path->merge(Mojo::Path->new);

Merge paths. Note that this method will normalize both paths if necessary and that C<%2F> will be treated as C</> for
security reasons.

  # "/baz/yada"
  Mojo::Path->new('/foo/bar')->merge('/baz/yada');

  # "/foo/baz/yada"
  Mojo::Path->new('/foo/bar')->merge('baz/yada');

  # "/foo/bar/baz/yada"
  Mojo::Path->new('/foo/bar/')->merge('baz/yada');

=head2 new

  my $path = Mojo::Path->new;
  my $path = Mojo::Path->new('/foo%2Fbar%3B/baz.html');

Construct a new L<Mojo::Path> object and L</"parse"> path if necessary.

=head2 parse

  $path = $path->parse('/foo%2Fbar%3B/baz.html');

Parse path.

=head2 to_abs_string

  my $str = $path->to_abs_string;

Turn path into an absolute string.

  # "/i/%E2%99%A5/mojolicious"
  Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_abs_string;
  Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_abs_string;

=head2 parts

  my $parts = $path->parts;
  $path     = $path->parts([qw(foo bar baz)]);

The path parts. Note that this method will normalize the path and that C<%2F> will be treated as C</> for security
reasons.

  # Part with slash
  push @{$path->parts}, 'foo/bar';

=head2 to_dir

  my $dir = $route->to_dir;

Clone path and remove everything after the right-most slash.

  # "/i/%E2%99%A5/"
  Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_dir->to_abs_string;

  # "i/%E2%99%A5/"
  Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_dir->to_abs_string;

=head2 to_route

  my $route = $path->to_route;

Turn path into a route.

  # "/i/â™¥/mojolicious"
  Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_route;
  Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_route;

=head2 to_string

  my $str = $path->to_string;

Turn path into a string.

  # "/i/%E2%99%A5/mojolicious"
  Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_string;

  # "i/%E2%99%A5/mojolicious"
  Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_string;

=head2 trailing_slash

  my $bool = $path->trailing_slash;
  $path    = $path->trailing_slash($bool);

Path has a trailing slash. Note that this method will normalize the path and that C<%2F> will be treated as C</> for
security reasons.

  # "/foo/bar/"
  Mojo::Path->new('/foo/bar')->trailing_slash(1);

  # "/foo/bar"
  Mojo::Path->new('/foo/bar/')->trailing_slash(0);

=head1 OPERATORS

L<Mojo::Path> overloads the following operators.

=head2 array

  my @parts = @$path;

Alias for L</"parts">. Note that this will normalize the path and that C<%2F> will be treated as C</> for security
reasons.

  say $path->[0];
  say for @$path;

=head2 bool

  my $bool = !!$path;

Always true.

=head2 stringify

  my $str = "$path";

Alias for L</"to_string">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Message;
use Mojo::Base 'Mojo::EventEmitter';

use Carp qw(croak);
use Mojo::Asset::Memory;
use Mojo::Content::Single;
use Mojo::DOM;
use Mojo::JSON qw(j);
use Mojo::JSON::Pointer;
use Mojo::Parameters;
use Mojo::Upload;
use Mojo::Util qw(decode);

has content          => sub { Mojo::Content::Single->new };
has default_charset  => 'UTF-8';
has max_line_size    => sub { $ENV{MOJO_MAX_LINE_SIZE} || 8192 };
has max_message_size => sub { $ENV{MOJO_MAX_MESSAGE_SIZE} // 16777216 };
has version          => '1.1';

sub body {
  my $self = shift;

  # Get
  my $content = $self->content;
  return $content->is_multipart ? '' : $content->asset->slurp unless @_;

  # Set (multipart content needs to be downgraded)
  $content = $self->content(Mojo::Content::Single->new)->content if $content->is_multipart;
  $content->asset(Mojo::Asset::Memory->new->add_chunk(@_));

  return $self;
}

sub body_params {
  my $self = shift;

  return $self->{body_params} if $self->{body_params};
  my $params = $self->{body_params} = Mojo::Parameters->new;
  $params->charset($self->content->charset || $self->default_charset);

  # "application/x-www-form-urlencoded"
  my $type = $self->headers->content_type // '';
  if ($type =~ m!application/x-www-form-urlencoded!i) {
    $params->parse($self->content->asset->slurp);
  }

  # "multipart/form-data"
  elsif ($type =~ m!multipart/form-data!i) {
    $params->append(@$_[0, 1]) for @{$self->_parse_formdata};
  }

  return $params;
}

sub body_size { shift->content->body_size }

sub build_body       { shift->_build('get_body_chunk') }
sub build_headers    { shift->_build('get_header_chunk') }
sub build_start_line { shift->_build('get_start_line_chunk') }

sub cookie { shift->_cache('cookies', 0, @_) }

sub cookies { croak 'Method "cookies" not implemented by subclass' }

sub dom {
  my $self = shift;
  return undef if $self->content->is_multipart;
  my $dom = $self->{dom} ||= Mojo::DOM->new($self->text);
  return @_ ? $dom->find(@_) : $dom;
}

sub error {
  my $self = shift;
  return $self->{error} unless @_;
  $self->{error} = shift;
  return $self->finish;
}

sub every_cookie { shift->_cache('cookies', 1, @_) }
sub every_upload { shift->_cache('uploads', 1, @_) }

sub extract_start_line { croak 'Method "extract_start_line" not implemented by subclass' }

sub finish {
  my $self = shift;
  $self->{state} = 'finished';
  return $self->{finished}++ ? $self : $self->emit('finish');
}

sub fix_headers {
  my $self = shift;
  return $self if $self->{fix}++;

  # Content-Length or Connection (unless chunked transfer encoding is used)
  my $content = $self->content;
  my $headers = $content->headers;
  if    ($content->is_multipart)                           { $headers->remove('Content-Length') }
  elsif ($content->is_chunked || $headers->content_length) { return $self }
  if    ($content->is_dynamic)                             { $headers->connection('close') }
  else                                                     { $headers->content_length($self->body_size) }

  return $self;
}

sub get_body_chunk {
  my ($self, $offset) = @_;

  $self->emit('progress', 'body', $offset);
  my $chunk = $self->content->get_body_chunk($offset);
  return $chunk if !defined $chunk || length $chunk;
  $self->finish;

  return $chunk;
}

sub get_header_chunk {
  my ($self, $offset) = @_;
  $self->emit('progress', 'headers', $offset);
  return $self->fix_headers->content->get_header_chunk($offset);
}

sub get_start_line_chunk { croak 'Method "get_start_line_chunk" not implemented by subclass' }

sub header_size { shift->fix_headers->content->header_size }

sub headers { shift->content->headers }

sub is_finished { (shift->{state} // '') eq 'finished' }

sub is_limit_exceeded { !!shift->{limit} }

sub json {
  my ($self, $pointer) = @_;
  return undef if $self->content->is_multipart;
  my $data = $self->{json} //= j($self->body);
  return $pointer ? Mojo::JSON::Pointer->new($data)->get($pointer) : $data;
}

sub parse {
  my ($self, $chunk) = @_;

  return $self if $self->{error};
  $self->{raw_size} += length $chunk;
  $self->{buffer} .= $chunk;

  # Start-line
  unless ($self->{state}) {

    # Check start-line size
    my $len = index $self->{buffer}, "\x0a";
    $len = length $self->{buffer} if $len < 0;
    return $self->_limit('Maximum start-line size exceeded') if $len > $self->max_line_size;

    $self->{state} = 'content' if $self->extract_start_line(\$self->{buffer});
  }

  # Content
  my $state = $self->{state} // '';
  $self->content($self->content->parse(delete $self->{buffer})) if $state eq 'content' || $state eq 'finished';

  # Check message size
  my $max = $self->max_message_size;
  return $self->_limit('Maximum message size exceeded') if $max && $max < $self->{raw_size};

  # Check header size
  return $self->_limit('Maximum header size exceeded') if $self->headers->is_limit_exceeded;

  # Check buffer size
  return $self->_limit('Maximum buffer size exceeded') if $self->content->is_limit_exceeded;

  return $self->emit('progress')->content->is_finished ? $self->finish : $self;
}

sub save_to {
  my ($self, $path) = @_;
  my $content = $self->content;
  croak 'Multipart content cannot be saved to files' if $content->is_multipart;
  $content->asset->move_to($path);
  return $self;
}

sub start_line_size { croak 'Method "start_line_size" not implemented by subclass' }

sub text {
  my $self    = shift;
  my $body    = $self->body;
  my $charset = $self->content->charset || $self->default_charset;
  return $charset ? decode($charset, $body) // $body : $body;
}

sub to_string {
  my $self = shift;
  return $self->build_start_line . $self->build_headers . $self->build_body;
}

sub upload { shift->_cache('uploads', 0, @_) }

sub uploads {
  my $self = shift;

  my @uploads;
  for my $data (@{$self->_parse_formdata(1)}) {
    my $upload = Mojo::Upload->new(
      name     => $data->[0],
      filename => $data->[2],
      asset    => $data->[1]->asset,
      headers  => $data->[1]->headers
    );
    push @uploads, $upload;
  }

  return \@uploads;
}

sub _build {
  my ($self, $method) = @_;

  my ($buffer, $offset) = ('', 0);
  while (1) {

    # No chunk yet, try again
    next unless defined(my $chunk = $self->$method($offset));

    # End of part
    last unless my $len = length $chunk;

    $offset += $len;
    $buffer .= $chunk;
  }

  return $buffer;
}

sub _cache {
  my ($self, $method, $all, $name) = @_;

  # Cache objects by name
  unless ($self->{$method}) {
    $self->{$method} = {};
    push @{$self->{$method}{$_->name}}, $_ for @{$self->$method};
  }

  my $objects = $self->{$method}{$name} // [];
  return $all ? $objects : $objects->[-1];
}

sub _limit { ++$_[0]{limit} and return $_[0]->error({message => $_[1]}) }

sub _parse_formdata {
  my ($self, $upload) = @_;

  my @formdata;
  my $content = $self->content;
  return \@formdata unless $content->is_multipart;
  my $charset = $content->charset || $self->default_charset;

  # Check all parts recursively
  my @parts = ($content);
  while (my $part = shift @parts) {

    if ($part->is_multipart) {
      unshift @parts, @{$part->parts};
      next;
    }

    next unless my $disposition = $part->headers->content_disposition;
    my ($filename) = $disposition =~ /[; ]filename="((?:\\"|[^"])*)"/;
    next if $upload && !defined $filename || !$upload && defined $filename;
    my ($name) = $disposition =~ /[; ]name="((?:\\"|[^;"])*)"/;
    next if !defined $name;
    $part = $part->asset->slurp unless $upload;

    if ($charset) {
      $name     = decode($charset, $name)     // $name     if $name;
      $filename = decode($charset, $filename) // $filename if $filename;
      $part     = decode($charset, $part)     // $part unless $upload;
    }

    push @formdata, [$name, $part, $filename];
  }

  return \@formdata;
}

1;

=encoding utf8

=head1 NAME

Mojo::Message - HTTP message base class

=head1 SYNOPSIS

  package Mojo::Message::MyMessage;
  use Mojo::Base 'Mojo::Message';

  sub cookies              {...}
  sub extract_start_line   {...}
  sub get_start_line_chunk {...}
  sub start_line_size      {...}

=head1 DESCRIPTION

L<Mojo::Message> is an abstract base class for HTTP message containers, based on L<RFC
7230|https://tools.ietf.org/html/rfc7230>, L<RFC 7231|https://tools.ietf.org/html/rfc7231> and L<RFC
2388|https://tools.ietf.org/html/rfc2388>, like L<Mojo::Message::Request> and L<Mojo::Message::Response>.

=head1 EVENTS

L<Mojo::Message> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 finish

  $msg->on(finish => sub ($msg) {...});

Emitted after message building or parsing is finished.

  my $before = time;
  $msg->on(finish => sub ($msg) { $msg->headers->header('X-Parser-Time' => time - $before) });

=head2 progress

  $msg->on(progress => sub ($msg) {...});

Emitted when message building or parsing makes progress.

  # Building
  $msg->on(progress => sub ($msg, $state, $offset) { say qq{Building "$state" at offset $offset} });

  # Parsing
  $msg->on(progress => sub ($msg) {
    return unless my $len = $msg->headers->content_length;
    my $size = $msg->content->progress;
    say 'Progress: ', $size == $len ? 100 : int($size / ($len / 100)), '%';
  });

=head1 ATTRIBUTES

L<Mojo::Message> implements the following attributes.

=head2 content

  my $msg = $msg->content;
  $msg    = $msg->content(Mojo::Content::Single->new);

Message content, defaults to a L<Mojo::Content::Single> object.

=head2 default_charset

  my $charset = $msg->default_charset;
  $msg        = $msg->default_charset('UTF-8');

Default charset used by L</"text"> and to extract data from C<application/x-www-form-urlencoded> or
C<multipart/form-data> message body, defaults to C<UTF-8>.

=head2 max_line_size

  my $size = $msg->max_line_size;
  $msg     = $msg->max_line_size(1024);

Maximum start-line size in bytes, defaults to the value of the C<MOJO_MAX_LINE_SIZE> environment variable or C<8192>
(8KiB).

=head2 max_message_size

  my $size = $msg->max_message_size;
  $msg     = $msg->max_message_size(1024);

Maximum message size in bytes, defaults to the value of the C<MOJO_MAX_MESSAGE_SIZE> environment variable or
C<16777216> (16MiB). Setting the value to C<0> will allow messages of indefinite size.

=head2 version

  my $version = $msg->version;
  $msg        = $msg->version('1.1');

HTTP version of message, defaults to C<1.1>.

=head1 METHODS

L<Mojo::Message> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 body

  my $bytes = $msg->body;
  $msg      = $msg->body('Hello!');

Slurp or replace L</"content">.

=head2 body_params

  my $params = $msg->body_params;

C<POST> parameters extracted from C<application/x-www-form-urlencoded> or C<multipart/form-data> message body, usually
a L<Mojo::Parameters> object. Note that this method caches all data, so it should not be called before the entire
message body has been received. Parts of the message body need to be loaded into memory to parse C<POST> parameters, so
you have to make sure it is not excessively large. There's a 16MiB limit for requests and a 2GiB limit for responses by
default.

  # Get POST parameter names and values
  my $hash = $msg->body_params->to_hash;

=head2 body_size

  my $size = $msg->body_size;

Content size in bytes.

=head2 build_body

  my $bytes = $msg->build_body;

Render whole body with L</"get_body_chunk">.

=head2 build_headers

  my $bytes = $msg->build_headers;

Render all headers with L</"get_header_chunk">.

=head2 build_start_line

  my $bytes = $msg->build_start_line;

Render start-line with L</"get_start_line_chunk">.

=head2 cookie

  my $cookie = $msg->cookie('foo');

Access message cookies, usually L<Mojo::Cookie::Request> or L<Mojo::Cookie::Response> objects. If there are multiple
cookies sharing the same name, and you want to access more than just the last one, you can use L</"every_cookie">. Note
that this method caches all data, so it should not be called before all headers have been received.

  # Get cookie value
  say $msg->cookie('foo')->value;

=head2 cookies

  my $cookies = $msg->cookies;

Access message cookies. Meant to be overloaded in a subclass.

=head2 dom

  my $dom        = $msg->dom;
  my $collection = $msg->dom('a[href]');

Retrieve message body from L</"text"> and turn it into a L<Mojo::DOM> object, an optional selector can be used to call
the method L<Mojo::DOM/"find"> on it right away, which then returns a L<Mojo::Collection> object. Note that this method
caches all data, so it should not be called before the entire message body has been received. The whole message body
needs to be loaded into memory to parse it, so you have to make sure it is not excessively large. There's a 16MiB limit
for requests and a 2GiB limit for responses by default.

  # Perform "find" right away
  say $msg->dom('h1, h2, h3')->map('text')->join("\n");

  # Use everything else Mojo::DOM has to offer
  say $msg->dom->at('title')->text;
  say $msg->dom->at('body')->children->map('tag')->uniq->join("\n");

=head2 error

  my $err = $msg->error;
  $msg    = $msg->error({message => 'Parser error'});

Get or set message error, an C<undef> return value indicates that there is no error.

  # Connection or parser error
  $msg->error({message => 'Connection refused'});

  # 4xx/5xx response
  $msg->error({message => 'Internal Server Error', code => 500});

=head2 every_cookie

  my $cookies = $msg->every_cookie('foo');

Similar to L</"cookie">, but returns all message cookies sharing the same name as an array reference.

  # Get first cookie value
  say $msg->every_cookie('foo')->[0]->value;

=head2 every_upload

  my $uploads = $msg->every_upload('foo');

Similar to L</"upload">, but returns all file uploads sharing the same name as an array reference.

  # Get content of first uploaded file
  say $msg->every_upload('foo')->[0]->asset->slurp;

=head2 extract_start_line

  my $bool = $msg->extract_start_line(\$str);

Extract start-line from string. Meant to be overloaded in a subclass.

=head2 finish

  $msg = $msg->finish;

Finish message parser/generator.

=head2 fix_headers

  $msg = $msg->fix_headers;

Make sure message has all required headers.

=head2 get_body_chunk

  my $bytes = $msg->get_body_chunk($offset);

Get a chunk of body data starting from a specific position. Note that it might not be possible to get the same chunk
twice if content was generated dynamically.

=head2 get_header_chunk

  my $bytes = $msg->get_header_chunk($offset);

Get a chunk of header data, starting from a specific position. Note that this method finalizes the message.

=head2 get_start_line_chunk

  my $bytes = $msg->get_start_line_chunk($offset);

Get a chunk of start-line data starting from a specific position. Meant to be overloaded in a subclass.

=head2 header_size

  my $size = $msg->header_size;

Size of headers in bytes. Note that this method finalizes the message.

=head2 headers

  my $headers = $msg->headers;

Message headers, usually a L<Mojo::Headers> object.

  # Longer version
  my $headers = $msg->content->headers;

=head2 is_finished

  my $bool = $msg->is_finished;

Check if message parser/generator is finished.

=head2 is_limit_exceeded

  my $bool = $msg->is_limit_exceeded;

Check if message has exceeded L</"max_line_size">, L</"max_message_size">, L<Mojo::Content/"max_buffer_size"> or
L<Mojo::Headers/"max_line_size">.

=head2 json

  my $value = $msg->json;
  my $value = $msg->json('/foo/bar');

Decode JSON message body directly using L<Mojo::JSON> if possible, an C<undef> return value indicates a bare C<null> or
that decoding failed. An optional JSON Pointer can be used to extract a specific value with L<Mojo::JSON::Pointer>.
Note that this method caches all data, so it should not be called before the entire message body has been received. The
whole message body needs to be loaded into memory to parse it, so you have to make sure it is not excessively large.
There's a 16MiB limit for requests and a 2GiB limit for responses by default.

  # Extract JSON values
  say $msg->json->{foo}{bar}[23];
  say $msg->json('/foo/bar/23');

=head2 parse

  $msg = $msg->parse('HTTP/1.1 200 OK...');

Parse message chunk.

=head2 save_to

  $msg = $msg->save_to('/some/path/index.html');

Save message body to a file.

=head2 start_line_size

  my $size = $msg->start_line_size;

Size of the start-line in bytes. Meant to be overloaded in a subclass.

=head2 text

  my $str = $msg->text;

Retrieve L</"body"> and try to decode it with L<Mojo::Content/"charset"> or L</"default_charset">.

=head2 to_string

  my $str = $msg->to_string;

Render whole message. Note that this method finalizes the message, and that it might not be possible to render the same
message twice if content was generated dynamically.

=head2 upload

  my $upload = $msg->upload('foo');

Access C<multipart/form-data> file uploads, usually L<Mojo::Upload> objects. If there are multiple uploads sharing the
same name, and you want to access more than just the last one, you can use L</"every_upload">. Note that this method
caches all data, so it should not be called before the entire message body has been received.

  # Get content of uploaded file
  say $msg->upload('foo')->asset->slurp;

=head2 uploads

  my $uploads = $msg->uploads;

All C<multipart/form-data> file uploads, usually L<Mojo::Upload> objects.

  # Names of all uploads
  say $_->name for @{$msg->uploads};

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Util;
use Mojo::Base -strict;

use Carp           qw(carp croak);
use Data::Dumper   ();
use Digest::MD5    qw(md5 md5_hex);
use Digest::SHA    qw(hmac_sha1_hex sha1 sha1_hex);
use Encode         qw(find_encoding);
use Exporter       qw(import);
use File::Basename qw(dirname);
use Getopt::Long   qw(GetOptionsFromArray);
use IO::Compress::Gzip;
use IO::Poll qw(POLLIN POLLPRI);
use IO::Uncompress::Gunzip;
use List::Util         qw(min);
use MIME::Base64       qw(decode_base64 encode_base64);
use Pod::Usage         qw(pod2usage);
use Socket             qw(inet_pton AF_INET6 AF_INET);
use Sub::Util          qw(set_subname);
use Symbol             qw(delete_package);
use Time::HiRes        ();
use Unicode::Normalize ();

# Check for monotonic clock support
use constant MONOTONIC => !!eval { Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()) };

# Punycode bootstring parameters
use constant {
  PC_BASE         => 36,
  PC_TMIN         => 1,
  PC_TMAX         => 26,
  PC_SKEW         => 38,
  PC_DAMP         => 700,
  PC_INITIAL_BIAS => 72,
  PC_INITIAL_N    => 128
};

# To generate a new HTML entity table run this command
# perl examples/entities.pl > lib/Mojo/resources/html_entities.txt
my %ENTITIES;
{
  # Don't use Mojo::File here due to circular dependencies
  my $path = File::Spec->catfile(dirname(__FILE__), 'resources', 'html_entities.txt');

  open my $file, '<', $path or croak "Unable to open html entities file ($path): $!";
  my $lines = do { local $/; <$file> };

  for my $line (split /\n/, $lines) {
    next unless $line =~ /^(\S+)\s+U\+(\S+)(?:\s+U\+(\S+))?/;
    $ENTITIES{$1} = defined $3 ? (chr(hex $2) . chr(hex $3)) : chr(hex $2);
  }
}

# Characters that should be escaped in XML
my %XML = ('&' => '&amp;', '<' => '&lt;', '>' => '&gt;', '"' => '&quot;', '\'' => '&#39;');

# "Sun, 06 Nov 1994 08:49:37 GMT" and "Sunday, 06-Nov-94 08:49:37 GMT"
my $EXPIRES_RE = qr/(\w+\W+\d+\W+\w+\W+\d+\W+\d+:\d+:\d+\W*\w+)/;

# Header key/value pairs
my $QUOTED_VALUE_RE   = qr/\G=\s*("(?:\\\\|\\"|[^"])*")/;
my $UNQUOTED_VALUE_RE = qr/\G=\s*([^;, ]*)/;

# HTML entities
my $ENTITY_RE = qr/&(?:\#((?:[0-9]{1,7}|x[0-9a-fA-F]{1,6}));|(\w+[;=]?))/;

# Encoding and pattern cache
my (%ENCODING, %PATTERN);

our @EXPORT_OK = (
  qw(b64_decode b64_encode camelize class_to_file class_to_path decamelize decode deprecated dumper encode),
  qw(extract_usage getopt gunzip gzip header_params hmac_sha1_sum html_attr_unescape html_unescape humanize_bytes),
  qw(md5_bytes md5_sum monkey_patch network_contains punycode_decode punycode_encode quote scope_guard secure_compare),
  qw(sha1_bytes sha1_sum slugify split_cookie_header split_header steady_time tablify term_escape trim unindent),
  qw(unquote url_escape url_unescape xml_escape xor_encode)
);

# Aliases
monkey_patch(__PACKAGE__, 'b64_decode',    \&decode_base64);
monkey_patch(__PACKAGE__, 'b64_encode',    \&encode_base64);
monkey_patch(__PACKAGE__, 'hmac_sha1_sum', \&hmac_sha1_hex);
monkey_patch(__PACKAGE__, 'md5_bytes',     \&md5);
monkey_patch(__PACKAGE__, 'md5_sum',       \&md5_hex);
monkey_patch(__PACKAGE__, 'sha1_bytes',    \&sha1);
monkey_patch(__PACKAGE__, 'sha1_sum',      \&sha1_hex);

# Use a monotonic clock if possible
monkey_patch(__PACKAGE__, 'steady_time',
  MONOTONIC ? sub () { Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()) } : \&Time::HiRes::time);

sub camelize {
  my $str = shift;
  return $str if $str =~ /^[A-Z]/;

  # CamelCase words
  return join '::', map {
    join('', map { ucfirst lc } split /_/)
  } split /-/, $str;
}

sub class_to_file {
  my $class = shift;
  $class =~ s/::|'//g;
  $class =~ s/([A-Z])([A-Z]*)/$1 . lc $2/ge;
  return decamelize($class);
}

sub class_to_path { join '.', join('/', split(/::|'/, shift)), 'pm' }

sub decamelize {
  my $str = shift;
  return $str if $str !~ /^[A-Z]/;

  # snake_case words
  return join '-', map {
    join('_', map {lc} grep {length} split /([A-Z]{1}[^A-Z]*)/)
  } split /::/, $str;
}

sub decode {
  my ($encoding, $bytes) = @_;
  return undef unless eval { $bytes = _encoding($encoding)->decode("$bytes", 1); 1 };
  return $bytes;
}

sub deprecated {
  local $Carp::CarpLevel = 1;
  $ENV{MOJO_FATAL_DEPRECATIONS} ? croak @_ : carp @_;
}

sub dumper { Data::Dumper->new([@_])->Indent(1)->Sortkeys(1)->Terse(1)->Useqq(1)->Dump }

sub encode { _encoding($_[0])->encode("$_[1]", 0) }

sub extract_usage {
  my $file = @_ ? "$_[0]" : (caller)[1];

  open my $handle, '>', \my $output;
  pod2usage -exitval => 'noexit', -input => $file, -output => $handle;
  $output =~ s/^.*\n|\n$//;
  $output =~ s/\n$//;

  return unindent($output);
}

sub getopt {
  my ($array, $opts) = map { ref $_[0] eq 'ARRAY' ? shift : $_ } \@ARGV, [];

  my $save   = Getopt::Long::Configure(qw(default no_auto_abbrev no_ignore_case), @$opts);
  my $result = GetOptionsFromArray $array, @_;
  Getopt::Long::Configure($save);

  return $result;
}

sub gunzip {
  my $compressed = shift;
  IO::Uncompress::Gunzip::gunzip \$compressed, \my $uncompressed
    or croak "Couldn't gunzip: $IO::Uncompress::Gunzip::GzipError";
  return $uncompressed;
}

sub gzip {
  my $uncompressed = shift;
  IO::Compress::Gzip::gzip \$uncompressed, \my $compressed or croak "Couldn't gzip: $IO::Compress::Gzip::GzipError";
  return $compressed;
}

sub header_params {
  my $value = shift;

  my $params = {};
  while ($value =~ /\G[;\s]*([^=;, ]+)\s*/gc) {
    my $name = $1;

    # Quoted value
    if ($value =~ /$QUOTED_VALUE_RE/gco) { $params->{$name} //= unquote($1) }

    # Unquoted value
    elsif ($value =~ /$UNQUOTED_VALUE_RE/gco) { $params->{$name} //= $1 }
  }

  return ($params, substr($value, pos($value) // 0));
}

sub html_attr_unescape { _html(shift, 1) }
sub html_unescape      { _html(shift, 0) }

sub humanize_bytes {
  my $size = shift;

  my $prefix = $size < 0 ? '-' : '';

  return "$prefix${size}B"               if ($size = abs $size) < 1024;
  return $prefix . _round($size) . 'KiB' if ($size /= 1024) < 1024;
  return $prefix . _round($size) . 'MiB' if ($size /= 1024) < 1024;
  return $prefix . _round($size) . 'GiB' if ($size /= 1024) < 1024;
  return $prefix . _round($size /= 1024) . 'TiB';
}

sub monkey_patch {
  my ($class, %patch) = @_;
  no strict 'refs';
  no warnings 'redefine';
  *{"${class}::$_"} = set_subname("${class}::$_", $patch{$_}) for keys %patch;
}

sub network_contains {
  my ($cidr, $addr) = @_;
  return undef unless length $cidr && length $addr;

  # Parse inputs
  my ($net, $mask) = split m!/!, $cidr, 2;
  my $v6 = $net =~ /:/;
  return undef if $v6 xor $addr =~ /:/;

  # Convert addresses to binary
  return undef unless $net  = inet_pton($v6 ? AF_INET6 : AF_INET, $net);
  return undef unless $addr = inet_pton($v6 ? AF_INET6 : AF_INET, $addr);
  my $length = $v6 ? 128 : 32;

  # Apply mask if given
  $addr &= pack "B$length", '1' x $mask if defined $mask;

  # Compare
  return 0 == unpack "B$length", ($net ^ $addr);
}

# Direct translation of RFC 3492
sub punycode_decode {
  my $input = shift;
  use integer;

  my ($n, $i, $bias, @output) = (PC_INITIAL_N, 0, PC_INITIAL_BIAS);

  # Consume all code points before the last delimiter
  push @output, split(//, $1) if $input =~ s/(.*)\x2d//s;

  while (length $input) {
    my ($oldi, $w) = ($i, 1);

    # Base to infinity in steps of base
    for (my $k = PC_BASE; 1; $k += PC_BASE) {
      my $digit = ord substr $input, 0, 1, '';
      $digit = $digit < 0x40 ? $digit + (26 - 0x30) : ($digit & 0x1f) - 1;
      $i += $digit * $w;
      my $t = $k - $bias;
      $t = $t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;
      last if $digit < $t;
      $w *= PC_BASE - $t;
    }

    $bias = _adapt($i - $oldi, @output + 1, $oldi == 0);
    $n += $i / (@output + 1);
    $i = $i % (@output + 1);
    splice @output, $i++, 0, chr $n;
  }

  return join '', @output;
}

# Direct translation of RFC 3492
sub punycode_encode {
  my $output = shift;
  use integer;

  my ($n, $delta, $bias) = (PC_INITIAL_N, 0, PC_INITIAL_BIAS);

  # Extract basic code points
  my @input = map {ord} split //, $output;
  $output =~ s/[^\x00-\x7f]+//gs;
  my $h = my $basic = length $output;
  $output .= "\x2d" if $basic > 0;

  for my $m (sort grep { $_ >= PC_INITIAL_N } @input) {
    next if $m < $n;
    $delta += ($m - $n) * ($h + 1);
    $n = $m;

    for my $c (@input) {

      if    ($c < $n) { $delta++ }
      elsif ($c == $n) {
        my $q = $delta;

        # Base to infinity in steps of base
        for (my $k = PC_BASE; 1; $k += PC_BASE) {
          my $t = $k - $bias;
          $t = $t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;
          last if $q < $t;
          my $o = $t + (($q - $t) % (PC_BASE - $t));
          $output .= chr $o + ($o < 26 ? 0x61 : 0x30 - 26);
          $q = ($q - $t) / (PC_BASE - $t);
        }

        $output .= chr $q + ($q < 26 ? 0x61 : 0x30 - 26);
        $bias  = _adapt($delta, $h + 1, $h == $basic);
        $delta = 0;
        $h++;
      }
    }

    $delta++;
    $n++;
  }

  return $output;
}

sub quote {
  my $str = shift;
  $str =~ s/(["\\])/\\$1/g;
  return qq{"$str"};
}

sub scope_guard { Mojo::Util::_Guard->new(cb => shift) }

sub secure_compare {
  my ($one, $two) = @_;
  my $r = length $one != length $two;
  $two = $one if $r;
  $r |= ord(substr $one, $_) ^ ord(substr $two, $_) for 0 .. length($one) - 1;
  return $r == 0;
}

sub slugify {
  my ($value, $allow_unicode) = @_;

  if ($allow_unicode) {

    # Force unicode semantics by upgrading string
    utf8::upgrade($value = Unicode::Normalize::NFKC($value));
    $value =~ s/[^\w\s-]+//g;
  }
  else {
    $value = Unicode::Normalize::NFKD($value);
    $value =~ s/[^a-zA-Z0-9_\p{PosixSpace}-]+//g;
  }
  (my $new = lc trim($value)) =~ s/[-\s]+/-/g;

  return $new;
}

sub split_cookie_header { _header(shift, 1) }
sub split_header        { _header(shift, 0) }

sub tablify {
  my $rows = shift;

  my @spec;
  for my $row (@$rows) {
    for my $i (0 .. $#$row) {
      ($row->[$i] //= '') =~ y/\r\n//d;
      my $len = length $row->[$i];
      $spec[$i] = $len if $len >= ($spec[$i] // 0);
    }
  }

  my @fm = (map({"\%-${_}s"} @spec[0 .. $#spec - 1]), '%s');
  return join '', map { sprintf join('  ', @fm[0 .. $#$_]) . "\n", @$_ } @$rows;
}

sub term_escape {
  my $str = shift;
  $str =~ s/([\x00-\x09\x0b-\x1f\x7f\x80-\x9f])/sprintf '\\x%02x', ord $1/ge;
  return $str;
}

sub trim {
  my $str = shift;
  $str =~ s/^\s+//;
  $str =~ s/\s+$//;
  return $str;
}

sub unindent {
  my $str = shift;
  my $min = min map { m/^([ \t]*)/; length $1 || () } split /\n/, $str;
  $str =~ s/^[ \t]{0,$min}//gm if $min;
  return $str;
}

sub unquote {
  my $str = shift;
  return $str unless $str =~ s/^"(.*)"$/$1/g;
  $str                    =~ s/\\\\/\\/g;
  $str                    =~ s/\\"/"/g;
  return $str;
}

sub url_escape {
  my ($str, $pattern) = @_;

  if ($pattern) {
    unless (exists $PATTERN{$pattern}) {
      (my $quoted = $pattern) =~ s!([/\$\[])!\\$1!g;
      $PATTERN{$pattern} = eval "sub { \$_[0] =~ s/([$quoted])/sprintf '%%%02X', ord \$1/ge }" or croak $@;
    }
    $PATTERN{$pattern}->($str);
  }
  else { $str =~ s/([^A-Za-z0-9\-._~])/sprintf '%%%02X', ord $1/ge }

  return $str;
}

sub url_unescape {
  my $str = shift;
  $str =~ s/%([0-9a-fA-F]{2})/chr hex $1/ge;
  return $str;
}

sub xml_escape {
  return $_[0] if ref $_[0] && ref $_[0] eq 'Mojo::ByteStream';
  my $str = shift // '';
  $str =~ s/([&<>"'])/$XML{$1}/ge;
  return $str;
}

sub xor_encode {
  my ($input, $key) = @_;

  # Encode with variable key length
  my $len    = length $key;
  my $buffer = my $output = '';
  $output .= $buffer ^ $key while length($buffer = substr($input, 0, $len, '')) == $len;
  return $output .= $buffer ^ substr($key, 0, length $buffer, '');
}

sub _adapt {
  my ($delta, $numpoints, $firsttime) = @_;
  use integer;

  $delta = $firsttime ? $delta / PC_DAMP : $delta / 2;
  $delta += $delta / $numpoints;
  my $k = 0;
  while ($delta > ((PC_BASE - PC_TMIN) * PC_TMAX) / 2) {
    $delta /= PC_BASE - PC_TMIN;
    $k     += PC_BASE;
  }

  return $k + (((PC_BASE - PC_TMIN + 1) * $delta) / ($delta + PC_SKEW));
}

sub _encoding { $ENCODING{$_[0]} //= find_encoding($_[0]) // croak "Unknown encoding '$_[0]'" }

sub _entity {
  my ($point, $name, $attr) = @_;

  # Code point
  return chr($point !~ /^x/ ? $point : hex $point) unless defined $name;

  # Named character reference
  my $rest = my $last = '';
  while (length $name) {
    return $ENTITIES{$name} . reverse $rest
      if exists $ENTITIES{$name} && (!$attr || $name =~ /;$/ || $last !~ /[A-Za-z0-9=]/);
    $rest .= $last = chop $name;
  }
  return '&' . reverse $rest;
}

sub _header {
  my ($str, $cookie) = @_;

  my (@tree, @part);
  while ($str =~ /\G[,;\s]*([^=;, ]+)\s*/gc) {
    push @part, $1, undef;
    my $expires = $cookie && @part > 2 && lc $1 eq 'expires';

    # Special "expires" value
    if ($expires && $str =~ /\G=\s*$EXPIRES_RE/gco) { $part[-1] = $1 }

    # Quoted value
    elsif ($str =~ /$QUOTED_VALUE_RE/gco) { $part[-1] = unquote $1 }

    # Unquoted value
    elsif ($str =~ /$UNQUOTED_VALUE_RE/gco) { $part[-1] = $1 }

    # Separator
    next unless $str =~ /\G[;\s]*,\s*/gc;
    push @tree, [@part];
    @part = ();
  }

  # Take care of final part
  return [@part ? (@tree, \@part) : @tree];
}

sub _html {
  my ($str, $attr) = @_;
  $str =~ s/$ENTITY_RE/_entity($1, $2, $attr)/geo;
  return $str;
}

sub _options {

  # Hash or name (one)
  return ref $_[0] eq 'HASH' ? (undef, %{shift()}) : @_ if @_ == 1;

  # Name and values (odd)
  return shift, @_ if @_ % 2;

  # Name and hash or just values (even)
  return ref $_[1] eq 'HASH' ? (shift, %{shift()}) : (undef, @_);
}

# This may break in the future, but is worth it for performance
sub _readable { !!(IO::Poll::_poll(@_[0, 1], my $m = POLLIN | POLLPRI) > 0) }

sub _round { $_[0] < 10 ? int($_[0] * 10 + 0.5) / 10 : int($_[0] + 0.5) }

sub _stash {
  my ($name, $object) = (shift, shift);

  # Hash
  return $object->{$name} //= {} unless @_;

  # Get
  return $object->{$name}{$_[0]} unless @_ > 1 || ref $_[0];

  # Set
  my $values = ref $_[0] ? $_[0] : {@_};
  @{$object->{$name}}{keys %$values} = values %$values;

  return $object;
}

sub _teardown {
  return unless my $class = shift;

  # @ISA has to be cleared first because of circular references
  no strict 'refs';
  @{"${class}::ISA"} = ();
  delete_package $class;
}

package Mojo::Util::_Guard;
use Mojo::Base -base;

sub DESTROY { shift->{cb}() }

1;

=encoding utf8

=head1 NAME

Mojo::Util - Portable utility functions

=head1 SYNOPSIS

  use Mojo::Util qw(b64_encode url_escape url_unescape);

  my $str = 'test=23';
  my $escaped = url_escape $str;
  say url_unescape $escaped;
  say b64_encode $escaped, '';

=head1 DESCRIPTION

L<Mojo::Util> provides portable utility functions for L<Mojo>.

=head1 FUNCTIONS

L<Mojo::Util> implements the following functions, which can be imported individually.

=head2 b64_decode

  my $bytes = b64_decode $b64;

Base64 decode bytes with L<MIME::Base64>.

=head2 b64_encode

  my $b64 = b64_encode $bytes;
  my $b64 = b64_encode $bytes, "\n";

Base64 encode bytes with L<MIME::Base64>, the line ending defaults to a newline.

=head2 camelize

  my $camelcase = camelize $snakecase;

Convert C<snake_case> string to C<CamelCase> and replace C<-> with C<::>.

  # "FooBar"
  camelize 'foo_bar';

  # "FooBar::Baz"
  camelize 'foo_bar-baz';

  # "FooBar::Baz"
  camelize 'FooBar::Baz';

=head2 class_to_file

  my $file = class_to_file 'Foo::Bar';

Convert a class name to a file.

  # "foo_bar"
  class_to_file 'Foo::Bar';

  # "foobar"
  class_to_file 'FOO::Bar';

  # "foo_bar"
  class_to_file 'FooBar';

  # "foobar"
  class_to_file 'FOOBar';

=head2 class_to_path

  my $path = class_to_path 'Foo::Bar';

Convert class name to path, as used by C<%INC>.

  # "Foo/Bar.pm"
  class_to_path 'Foo::Bar';

  # "FooBar.pm"
  class_to_path 'FooBar';

=head2 decamelize

  my $snakecase = decamelize $camelcase;

Convert C<CamelCase> string to C<snake_case> and replace C<::> with C<->.

  # "foo_bar"
  decamelize 'FooBar';

  # "foo_bar-baz"
  decamelize 'FooBar::Baz';

  # "foo_bar-baz"
  decamelize 'foo_bar-baz';

=head2 decode

  my $chars = decode 'UTF-8', $bytes;

Decode bytes to characters with L<Encode>, or return C<undef> if decoding failed.

=head2 deprecated

  deprecated 'foo is DEPRECATED in favor of bar';

Warn about deprecated feature from perspective of caller. You can also set the C<MOJO_FATAL_DEPRECATIONS> environment
variable to make them die instead with L<Carp>.

=head2 dumper

  my $perl = dumper {some => 'data'};

Dump a Perl data structure with L<Data::Dumper>.

=head2 encode

  my $bytes = encode 'UTF-8', $chars;

Encode characters to bytes with L<Encode>.

=head2 extract_usage

  my $usage = extract_usage;
  my $usage = extract_usage '/home/sri/foo.pod';

Extract usage message from the SYNOPSIS section of a file containing POD documentation, defaults to using the file this
function was called from.

  # "Usage: APPLICATION test [OPTIONS]\n"
  extract_usage;

  =head1 SYNOPSIS

    Usage: APPLICATION test [OPTIONS]

  =cut

=head2 getopt

  getopt
    'H|headers=s' => \my @headers,
    't|timeout=i' => \my $timeout,
    'v|verbose'   => \my $verbose;
  getopt $array,
    'H|headers=s' => \my @headers,
    't|timeout=i' => \my $timeout,
    'v|verbose'   => \my $verbose;
  getopt $array, ['pass_through'],
    'H|headers=s' => \my @headers,
    't|timeout=i' => \my $timeout,
    'v|verbose'   => \my $verbose;

Extract options from an array reference with L<Getopt::Long>, but without changing its global configuration, defaults
to using C<@ARGV>. The configuration options C<no_auto_abbrev> and C<no_ignore_case> are enabled by default.

  # Extract "charset" option
  getopt ['--charset', 'UTF-8'], 'charset=s' => \my $charset;
  say $charset;

=head2 gunzip

  my $uncompressed = gunzip $compressed;

Uncompress bytes with L<IO::Compress::Gunzip>.

=head2 gzip

  my $compressed = gzip $uncompressed;

Compress bytes with L<IO::Compress::Gzip>.

=head2 header_params

  my ($params, $remainder) = header_params 'one=foo; two="bar", three=baz';

Extract HTTP header field parameters until the first comma according to L<RFC 5987|http://tools.ietf.org/html/rfc5987>.
Note that this function is B<EXPERIMENTAL> and might change without warning!

=head2 hmac_sha1_sum

  my $checksum = hmac_sha1_sum $bytes, 'passw0rd';

Generate HMAC-SHA1 checksum for bytes with L<Digest::SHA>.

  # "11cedfd5ec11adc0ec234466d8a0f2a83736aa68"
  hmac_sha1_sum 'foo', 'passw0rd';

=head2 html_attr_unescape

  my $str = html_attr_unescape $escaped;

Same as L</"html_unescape">, but handles special rules from the L<HTML Living Standard|https://html.spec.whatwg.org>
for HTML attributes.

  # "foo=bar&ltest=baz"
  html_attr_unescape 'foo=bar&ltest=baz';

  # "foo=bar<est=baz"
  html_attr_unescape 'foo=bar&lt;est=baz';

=head2 html_unescape

  my $str = html_unescape $escaped;

Unescape all HTML entities in string.

  # "<div>"
  html_unescape '&lt;div&gt;';

=head2 humanize_bytes

  my $str = humanize_bytes 1234;

Turn number of bytes into a simplified human readable format.

  # "1B"
  humanize_bytes 1;

  # "7.5GiB"
  humanize_bytes 8007188480;

  # "13GiB"
  humanize_bytes 13443399680;

  # "-685MiB"
  humanize_bytes -717946880;

=head2 md5_bytes

  my $checksum = md5_bytes $bytes;

Generate binary MD5 checksum for bytes with L<Digest::MD5>.

=head2 md5_sum

  my $checksum = md5_sum $bytes;

Generate MD5 checksum for bytes with L<Digest::MD5>.

  # "acbd18db4cc2f85cedef654fccc4a4d8"
  md5_sum 'foo';

=head2 monkey_patch

  monkey_patch $package, foo => sub {...};
  monkey_patch $package, foo => sub {...}, bar => sub {...};

Monkey patch functions into package.

  monkey_patch 'MyApp',
    one   => sub { say 'One!' },
    two   => sub { say 'Two!' },
    three => sub { say 'Three!' };

=head2 punycode_decode

  my $str = punycode_decode $punycode;

Punycode decode string as described in L<RFC 3492|https://tools.ietf.org/html/rfc3492>.

  # "bÃ¼cher"
  punycode_decode 'bcher-kva';

=head2 network_contains

  my $bool = network_contains $network, $address;

Check that a given address is contained within a network in CIDR form. If the network is a single address, the
addresses must be equivalent.

  # True
  network_contains('10.0.0.0/8', '10.10.10.10');
  network_contains('10.10.10.10', '10.10.10.10');
  network_contains('fc00::/7', 'fc::c0:ff:ee');

  # False
  network_contains('10.0.0.0/29', '10.10.10.10');
  network_contains('10.10.10.12', '10.10.10.10');
  network_contains('fc00::/7', '::1');

=head2 punycode_encode

  my $punycode = punycode_encode $str;

Punycode encode string as described in L<RFC 3492|https://tools.ietf.org/html/rfc3492>.

  # "bcher-kva"
  punycode_encode 'bÃ¼cher';

=head2 quote

  my $quoted = quote $str;

Quote string.

=head2 scope_guard

  my $guard = scope_guard sub {...};

Create anonymous scope guard object that will execute the passed callback when the object is destroyed.

  # Execute closure at end of scope
  {
    my $guard = scope_guard sub { say "Mojo!" };
    say "Hello";
  }

=head2 secure_compare

  my $bool = secure_compare $str1, $str2;

Constant time comparison algorithm to prevent timing attacks. The secret string should be the second argument, to avoid
leaking information about the length of the string.

=head2 sha1_bytes

  my $checksum = sha1_bytes $bytes;

Generate binary SHA1 checksum for bytes with L<Digest::SHA>.

=head2 sha1_sum

  my $checksum = sha1_sum $bytes;

Generate SHA1 checksum for bytes with L<Digest::SHA>.

  # "0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33"
  sha1_sum 'foo';

=head2 slugify

  my $slug = slugify $string;
  my $slug = slugify $string, $bool;

Returns a URL slug generated from the input string. Non-word characters are removed, the string is trimmed and
lowercased, and whitespace characters are replaced by a dash. By default, non-ASCII characters are normalized to ASCII
word characters or removed, but if a true value is passed as the second parameter, all word characters will be allowed
in the result according to unicode semantics.

  # "joel-is-a-slug"
  slugify 'Joel is a slug';

  # "this-is-my-resume"
  slugify 'This is: my - rÃ©sumÃ©! â˜ƒ ';

  # "this-is-my-rÃ©sumÃ©"
  slugify 'This is: my - rÃ©sumÃ©! â˜ƒ ', 1;

=head2 split_cookie_header

  my $tree = split_cookie_header 'a=b; expires=Thu, 07 Aug 2008 07:07:59 GMT';

Same as L</"split_header">, but handles C<expires> values from L<RFC 6265|https://tools.ietf.org/html/rfc6265>.

=head2 split_header

   my $tree = split_header 'foo="bar baz"; test=123, yada';

Split HTTP header value into key/value pairs, each comma separated part gets its own array reference, and keys without
a value get C<undef> assigned.

  # "one"
  split_header('one; two="three four", five=six')->[0][0];

  # "two"
  split_header('one; two="three four", five=six')->[0][2];

  # "three four"
  split_header('one; two="three four", five=six')->[0][3];

  # "five"
  split_header('one; two="three four", five=six')->[1][0];

  # "six"
  split_header('one; two="three four", five=six')->[1][1];

=head2 steady_time

  my $time = steady_time;

High resolution time elapsed from an arbitrary fixed point in the past, resilient to time jumps if a monotonic clock is
available through L<Time::HiRes>.

=head2 tablify

  my $table = tablify [['foo', 'bar'], ['baz', 'yada']];

Row-oriented generator for text tables.

  # "foo   bar\nyada  yada\nbaz   yada\n"
  tablify [['foo', 'bar'], ['yada', 'yada'], ['baz', 'yada']];

=head2 term_escape

  my $escaped = term_escape $str;

Escape all POSIX control characters except for C<\n>.

  # "foo\\x09bar\\x0d\n"
  term_escape "foo\tbar\r\n";

=head2 trim

  my $trimmed = trim $str;

Trim whitespace characters from both ends of string.

  # "foo bar"
  trim '  foo bar  ';

=head2 unindent

  my $unindented = unindent $str;

Unindent multi-line string.

  # "foo\nbar\nbaz\n"
  unindent "  foo\n  bar\n  baz\n";

=head2 unquote

  my $str = unquote $quoted;

Unquote string.

=head2 url_escape

  my $escaped = url_escape $str;
  my $escaped = url_escape $str, '^A-Za-z0-9\-._~';

Percent encode unsafe characters in string as described in L<RFC 3986|https://tools.ietf.org/html/rfc3986>, the pattern
used defaults to C<^A-Za-z0-9\-._~>.

  # "foo%3Bbar"
  url_escape 'foo;bar';

=head2 url_unescape

  my $str = url_unescape $escaped;

Decode percent encoded characters in string as described in L<RFC 3986|https://tools.ietf.org/html/rfc3986>.

  # "foo;bar"
  url_unescape 'foo%3Bbar';

=head2 xml_escape

  my $escaped = xml_escape $str;

Escape unsafe characters C<&>, C<E<lt>>, C<E<gt>>, C<"> and C<'> in string, but do not escape L<Mojo::ByteStream>
objects.

  # "&lt;div&gt;"
  xml_escape '<div>';

  # "<div>"
  use Mojo::ByteStream qw(b);
  xml_escape b('<div>');

=head2 xor_encode

  my $encoded = xor_encode $str, $key;

XOR encode string with variable length key.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::IOLoop::Subprocess;
use Mojo::Base 'Mojo::EventEmitter';

use Config;
use Mojo::IOLoop;
use Mojo::IOLoop::Stream;
use Mojo::JSON;
use Mojo::Promise;
use POSIX ();

has deserialize => sub { \&Mojo::JSON::decode_json };
has ioloop      => sub { Mojo::IOLoop->singleton }, weak => 1;
has serialize   => sub { \&Mojo::JSON::encode_json };

sub exit_code { shift->{exit_code} }

sub pid { shift->{pid} }

sub run {
  my ($self, @args) = @_;
  $self->ioloop->next_tick(sub { $self->_start(@args) });
  return $self;
}

sub run_p {
  my ($self, $child) = @_;

  my $p      = Mojo::Promise->new;
  my $parent = sub {
    my ($self, $err) = (shift, shift);
    $err ? $p->reject($err) : $p->resolve(@_);
  };
  $self->ioloop->next_tick(sub { $self->_start($child, $parent) });

  return $p;
}

sub _start {
  my ($self, $child, $parent) = @_;

  # No fork emulation support
  return $self->$parent('Subprocesses do not support fork emulation') if $Config{d_pseudofork};

  # Pipe for subprocess communication
  return $self->$parent("Can't create pipe: $!") unless pipe(my $reader, $self->{writer});
  $self->{writer}->autoflush(1);

  # Child
  return $self->$parent("Can't fork: $!") unless defined(my $pid = $self->{pid} = fork);
  unless ($pid) {
    eval {
      $self->ioloop->reset({freeze => 1});
      my $results = eval { [$self->$child] } // [];
      print {$self->{writer}} '0-', $self->serialize->([$@, @$results]);
      $self->emit('cleanup');
    } or warn $@;
    POSIX::_exit(0);
  }

  # Parent
  my $me = $$;
  close $self->{writer};
  my $stream = Mojo::IOLoop::Stream->new($reader)->timeout(0);
  $self->emit('spawn')->ioloop->stream($stream);
  my $buffer = '';
  $stream->on(
    read => sub {
      $buffer .= pop;
      while (1) {
        my ($len) = $buffer =~ /^([0-9]+)\-/;
        last unless $len and length $buffer >= $len + $+[0];
        my $snippet = substr $buffer, 0, $len + $+[0], '';
        my $args    = $self->deserialize->(substr $snippet, $+[0]);
        $self->emit(progress => @$args);
      }
    }
  );
  $stream->on(
    close => sub {
      return unless $$ == $me;
      waitpid $pid, 0;
      $self->{exit_code} = $? >> 8;
      substr $buffer, 0, 2, '';
      my $results = eval { $self->deserialize->($buffer) } // [];
      $self->$parent(shift(@$results) // $@, @$results);
    }
  );
}

sub progress {
  my ($self, @args) = @_;
  my $serialized = $self->serialize->(\@args);
  print {$self->{writer}} length($serialized), '-', $serialized;
}

1;

=encoding utf8

=head1 NAME

Mojo::IOLoop::Subprocess - Subprocesses

=head1 SYNOPSIS

  use Mojo::IOLoop::Subprocess;

  # Operation that would block the event loop for 5 seconds
  my $subprocess = Mojo::IOLoop::Subprocess->new;
  $subprocess->run(
    sub ($subprocess) {
      sleep 5;
      return 'â™¥', 'Mojolicious';
    },
    sub ($subprocess, $err, @results) {
      say "Subprocess error: $err" and return if $err;
      say "I $results[0] $results[1]!";
    }
  );

  # Operation that would block the event loop for 5 seconds (with promise)
  $subprocess->run_p(sub {
    sleep 5;
    return 'â™¥', 'Mojolicious';
  })->then(sub (@results) {
    say "I $results[0] $results[1]!";
  })->catch(sub  {
    my $err = shift;
    say "Subprocess error: $err";
  });

  # Start event loop if necessary
  $subprocess->ioloop->start unless $subprocess->ioloop->is_running;

=head1 DESCRIPTION

L<Mojo::IOLoop::Subprocess> allows L<Mojo::IOLoop> to perform computationally expensive operations in subprocesses,
without blocking the event loop.

=head1 EVENTS

L<Mojo::IOLoop::Subprocess> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 cleanup

  $subprocess->on(cleanup => sub ($subprocess) {...});

Emitted in the subprocess right before the process will exit.

  $subprocess->on(cleanup => sub ($subprocess) { say "Process $$ is about to exit" });

=head2 progress

  $subprocess->on(progress => sub ($subprocess, @data) {...});

Emitted in the parent process when the subprocess calls the L<progress|/"progress1"> method.

=head2 spawn

  $subprocess->on(spawn => sub ($subprocess) {...});

Emitted in the parent process when the subprocess has been spawned.

  $subprocess->on(spawn => sub ($subprocess) {
    my $pid = $subprocess->pid;
    say "Performing work in process $pid";
  });

=head1 ATTRIBUTES

L<Mojo::IOLoop::Subprocess> implements the following attributes.

=head2 deserialize

  my $cb      = $subprocess->deserialize;
  $subprocess = $subprocess->deserialize(sub {...});

A callback used to deserialize subprocess return values, defaults to using L<Mojo::JSON>.

  $subprocess->deserialize(sub ($bytes) { return [] });

=head2 ioloop

  my $loop    = $subprocess->ioloop;
  $subprocess = $subprocess->ioloop(Mojo::IOLoop->new);

Event loop object to control, defaults to the global L<Mojo::IOLoop> singleton. Note that this attribute is weakened.

=head2 serialize

  my $cb      = $subprocess->serialize;
  $subprocess = $subprocess->serialize(sub {...});

A callback used to serialize subprocess return values, defaults to using L<Mojo::JSON>.

  $subprocess->serialize(sub ($array) { return '' });

=head1 METHODS

L<Mojo::IOLoop::Subprocess> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 exit_code

  my $code = $subprocess->exit_code;

Returns the subprocess exit code, or C<undef> if the subprocess is still running.

=head2 pid

  my $pid = $subprocess->pid;

Process id of the spawned subprocess if available.

=head2 progress

  $subprocess->progress(@data);

Send data serialized with L<Mojo::JSON> to the parent process at any time during the subprocess's execution. Must be
called by the subprocess and emits the L</"progress"> event in the parent process with the data.

  # Send progress information to the parent process
  $subprocess->run(
    sub ($subprocess) {
      $subprocess->progress('0%');
      sleep 5;
      $subprocess->progress('50%');
      sleep 5;
      return 'Hello Mojo!';
    },
    sub ($subprocess, $err, @results) {
      say 'Progress is 100%';
      say $results[0];
    }
  );
  $subprocess->on(progress => sub ($subprocess, @data) { say "Progress is $data[0]" });

=head2 run

  $subprocess = $subprocess->run(sub {...}, sub {...});

Execute the first callback in a child process and wait for it to return one or more values, without blocking
L</"ioloop"> in the parent process. Then execute the second callback in the parent process with the results. The return
values of the first callback and exceptions thrown by it, will be serialized with L<Mojo::JSON>, so they can be shared
between processes.

=head2 run_p

  my $promise = $subprocess->run_p(sub {...});

Same as L</"run">, but returns a L<Mojo::Promise> object instead of accepting a second callback.

  $subprocess->run_p(sub {
    sleep 5;
    return 'â™¥', 'Mojolicious';
  })->then(sub (@results) {
    say "I $results[0] $results[1]!";
  })->catch(sub ($err) {
    say "Subprocess error: $err";
  })->wait;

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::IOLoop::Stream;
use Mojo::Base 'Mojo::EventEmitter';

use Errno qw(EAGAIN ECONNRESET EINTR EWOULDBLOCK);
use Mojo::IOLoop;
use Mojo::Util;
use Scalar::Util qw(weaken);

has high_water_mark => 1048576;
has reactor => sub { Mojo::IOLoop->singleton->reactor }, weak => 1;

sub DESTROY { shift->close unless ${^GLOBAL_PHASE} eq 'DESTRUCT' }

sub bytes_read { shift->{read} || 0 }

sub bytes_waiting { length(shift->{buffer} // '') }

sub bytes_written { shift->{written} || 0 }

sub can_write { $_[0]{handle} && $_[0]->bytes_waiting < $_[0]->high_water_mark }

sub close {
  my $self = shift;
  return unless my $reactor = $self->reactor;
  return unless my $handle  = delete $self->timeout(0)->{handle};
  $reactor->remove($handle);
  $self->emit('close');
}

sub close_gracefully { $_[0]->is_writing ? $_[0]{graceful}++ : $_[0]->close }

sub handle { shift->{handle} }

sub is_readable {
  my $self = shift;
  $self->_again;
  return $self->{handle} && Mojo::Util::_readable(0, fileno $self->{handle});
}

sub is_writing {
  my $self = shift;
  return undef unless $self->{handle};
  return !!length($self->{buffer}) || $self->has_subscribers('drain');
}

sub new { shift->SUPER::new(handle => shift, timeout => 15) }

sub start {
  my $self = shift;

  # Resume
  return unless $self->{handle};
  my $reactor = $self->reactor;
  return $reactor->watch($self->{handle}, 1, $self->is_writing) if delete $self->{paused};

  weaken $self;
  my $cb = sub { pop() ? $self->_write : $self->_read };
  $reactor->io($self->timeout($self->{timeout})->{handle} => $cb);
}

sub steal_handle {
  my $self = shift;
  $self->reactor->remove($self->{handle});
  return delete $self->{handle};
}

sub stop { $_[0]->reactor->watch($_[0]{handle}, 0, $_[0]->is_writing) if $_[0]{handle} && !$_[0]{paused}++ }

sub timeout {
  my ($self, $timeout) = @_;

  return $self->{timeout} unless defined $timeout;
  $self->{timeout} = $timeout;

  my $reactor = $self->reactor;
  if ($self->{timer}) {
    if   (!$self->{timeout}) { $reactor->remove(delete $self->{timer}) }
    else                     { $reactor->again($self->{timer}, $self->{timeout}) }
  }
  elsif ($self->{timeout}) {
    weaken $self;
    $self->{timer}
      = $reactor->timer($timeout => sub { $self and delete($self->{timer}) and $self->emit('timeout')->close });
  }

  return $self;
}

sub write {
  my ($self, $chunk, $cb) = @_;

  # IO::Socket::SSL will corrupt data with the wrong internal representation
  utf8::downgrade $chunk;
  $self->{buffer} .= $chunk;
  if    ($cb)                     { $self->once(drain => $cb) }
  elsif (!length $self->{buffer}) { return $self }
  $self->reactor->watch($self->{handle}, !$self->{paused}, 1) if $self->{handle};

  return $self;
}

sub _again { $_[0]->reactor->again($_[0]{timer}) if $_[0]{timer} }

sub _read {
  my $self = shift;

  if (defined(my $read = $self->{handle}->sysread(my $buffer, 131072, 0))) {
    $self->{read} += $read;
    return $read == 0 ? $self->close : $self->emit(read => $buffer)->_again;
  }

  # Retry
  return undef if $! == EAGAIN || $! == EINTR || $! == EWOULDBLOCK;

  # Closed (maybe real error)
  $! == ECONNRESET ? $self->close : $self->emit(error => $!)->close;
}

sub _write {
  my $self = shift;

  # Handle errors only when reading (to avoid timing problems)
  my $handle = $self->{handle};
  if (length $self->{buffer}) {
    return undef unless defined(my $written = $handle->syswrite($self->{buffer}));
    $self->{written} += $written;
    $self->emit(write => substr($self->{buffer}, 0, $written, ''))->_again;
  }

  # Clear the buffer to free the underlying SV* memory
  undef $self->{buffer}, $self->emit('drain') unless length $self->{buffer};
  return undef                                        if $self->is_writing;
  return $self->close                                 if $self->{graceful};
  $self->reactor->watch($handle, !$self->{paused}, 0) if $self->{handle};
}

1;

=encoding utf8

=head1 NAME

Mojo::IOLoop::Stream - Non-blocking I/O stream

=head1 SYNOPSIS

  use Mojo::IOLoop::Stream;

  # Create stream
  my $stream = Mojo::IOLoop::Stream->new($handle);
  $stream->on(read => sub ($stream, $bytes) {...});
  $stream->on(close => sub ($stream) {...});
  $stream->on(error => sub ($stream, $err) {...});

  # Start and stop watching for new data
  $stream->start;
  $stream->stop;

  # Start reactor if necessary
  $stream->reactor->start unless $stream->reactor->is_running;

=head1 DESCRIPTION

L<Mojo::IOLoop::Stream> is a container for I/O streams used by L<Mojo::IOLoop>.

=head1 EVENTS

L<Mojo::IOLoop::Stream> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 close

  $stream->on(close => sub ($stream) {...});

Emitted if the stream gets closed.

=head2 drain

  $stream->on(drain => sub ($stream) {...});

Emitted once all data has been written.

=head2 error

  $stream->on(error => sub ($stream, $err) {...});

Emitted if an error occurs on the stream, fatal if unhandled.

=head2 read

  $stream->on(read => sub ($stream, $bytes) {...});

Emitted if new data arrives on the stream.

=head2 timeout

  $stream->on(timeout => sub ($stream) {...});

Emitted if the stream has been inactive for too long and will get closed automatically.

=head2 write

  $stream->on(write => sub ($stream, $bytes) {...});

Emitted if new data has been written to the stream.

=head1 ATTRIBUTES

L<Mojo::IOLoop::Stream> implements the following attributes.

=head2 high_water_mark

  my $size = $msg->high_water_mark;
  $msg     = $msg->high_water_mark(1024);

Maximum size of L</"write"> buffer in bytes before L</"can_write"> returns false, defaults to C<1048576> (1MiB).

=head2 reactor

  my $reactor = $stream->reactor;
  $stream     = $stream->reactor(Mojo::Reactor::Poll->new);

Low-level event reactor, defaults to the C<reactor> attribute value of the global L<Mojo::IOLoop> singleton. Note that
this attribute is weakened.

=head1 METHODS

L<Mojo::IOLoop::Stream> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 bytes_read

  my $num = $stream->bytes_read;

Number of bytes received.

=head2 bytes_waiting

  my $num = $stream->bytes_waiting;

Number of bytes that have been enqueued with L</"write"> and are waiting to be written.

=head2 bytes_written

  my $num = $stream->bytes_written;

Number of bytes written.

=head2 can_write

  my $bool = $stream->can_write;

Returns true if calling L</"write"> is safe.

=head2 close

  $stream->close;

Close stream immediately.

=head2 close_gracefully

  $stream->close_gracefully;

Close stream gracefully.

=head2 handle

  my $handle = $stream->handle;

Get handle for stream, usually an L<IO::Socket::IP> or L<IO::Socket::SSL> object.

=head2 is_readable

  my $bool = $stream->is_readable;

Quick non-blocking check if stream is readable, useful for identifying tainted sockets.

=head2 is_writing

  my $bool = $stream->is_writing;

Check if stream is writing.

=head2 new

  my $stream = Mojo::IOLoop::Stream->new($handle);

Construct a new L<Mojo::IOLoop::Stream> object.

=head2 start

  $stream->start;

Start or resume watching for new data on the stream.

=head2 steal_handle

  my $handle = $stream->steal_handle;

Steal L</"handle"> and prevent it from getting closed automatically.

=head2 stop

  $stream->stop;

Stop watching for new data on the stream.

=head2 timeout

  my $timeout = $stream->timeout;
  $stream     = $stream->timeout(45);

Maximum amount of time in seconds stream can be inactive before getting closed automatically, defaults to C<15>.
Setting the value to C<0> will allow this stream to be inactive indefinitely.

=head2 write

  $stream = $stream->write($bytes);
  $stream = $stream->write($bytes => sub {...});

Enqueue data to be written to the stream as soon as possible, the optional drain callback will be executed once all
data has been written.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::IOLoop::Server;
use Mojo::Base 'Mojo::EventEmitter';

use Carp qw(croak);
use IO::Socket::IP;
use IO::Socket::UNIX;
use Mojo::File qw(path);
use Mojo::IOLoop;
use Mojo::IOLoop::TLS;
use Scalar::Util qw(weaken);
use Socket       qw(IPPROTO_TCP TCP_NODELAY);

has reactor => sub { Mojo::IOLoop->singleton->reactor }, weak => 1;

sub DESTROY {
  my $self = shift;
  $ENV{MOJO_REUSE} =~ s/(?:^|\,)\Q$self->{reuse}\E// if $self->{reuse};
  $self->stop                                        if $self->{handle} && $self->reactor;
}

sub generate_port { IO::Socket::IP->new(Listen => 5, LocalAddr => '127.0.0.1')->sockport }

sub handle { shift->{handle} }

sub is_accepting { !!shift->{active} }

sub listen {
  my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});

  # Look for reusable file descriptor
  my $path    = $args->{path};
  my $address = $args->{address} || '0.0.0.0';
  my $port    = $args->{port};
  $ENV{MOJO_REUSE} ||= '';
  my $fd = ($path && $ENV{MOJO_REUSE} =~ /(?:^|\,)unix:\Q$path\E:(\d+)/)
    || ($port && $ENV{MOJO_REUSE} =~ /(?:^|\,)\Q$address:$port\E:(\d+)/) ? $1 : undef;

  # Allow file descriptor inheritance
  local $^F = 1023;

  # Reuse file descriptor
  my $handle;
  my $class = $path ? 'IO::Socket::UNIX' : 'IO::Socket::IP';
  if (defined($fd //= $args->{fd})) {
    $handle = $class->new_from_fd($fd, 'r') or croak "Can't open file descriptor $fd: $!";
  }

  else {
    my %options = (Listen => $args->{backlog} // SOMAXCONN, Type => SOCK_STREAM);

    # UNIX domain socket
    my $reuse;
    if ($path) {
      path($path)->remove if -S $path;
      $options{Local} = $path;
      $handle         = $class->new(%options) or croak "Can't create listen socket: $!";
      $reuse          = $self->{reuse} = join ':', 'unix', $path, fileno $handle;
    }

    # IP socket
    else {
      $options{LocalAddr} = $address;
      $options{LocalAddr} =~ y/[]//d;
      $options{LocalPort} = $port if $port;
      $options{ReuseAddr} = 1;
      $options{ReusePort} = $args->{reuse};
      $handle             = $class->new(%options) or croak "Can't create listen socket: $@";
      $fd                 = fileno $handle;
      $reuse              = $self->{reuse} = join ':', $address, $handle->sockport, $fd;
    }

    $ENV{MOJO_REUSE} .= length $ENV{MOJO_REUSE} ? ",$reuse" : "$reuse";
  }
  $handle->blocking(0);
  @$self{qw(args handle)} = ($args, $handle);

  croak 'IO::Socket::SSL 2.009+ required for TLS support' if !Mojo::IOLoop::TLS->can_tls && $args->{tls};
}

sub port { shift->{handle}->sockport }

sub start {
  my $self = shift;
  weaken $self;
  ++$self->{active} and $self->reactor->io($self->{handle} => sub { $self->_accept })->watch($self->{handle}, 1, 0);
}

sub stop { delete($_[0]{active}) and $_[0]->reactor->remove($_[0]{handle}) }

sub _accept {
  my $self = shift;

  # Greedy accept
  my $args     = $self->{args};
  my $accepted = 0;
  while ($self->{active} && !($args->{single_accept} && $accepted++)) {
    return unless my $handle = $self->{handle}->accept;
    $handle->blocking(0);

    # Disable Nagle's algorithm
    setsockopt $handle, IPPROTO_TCP, TCP_NODELAY, 1;

    $self->emit(accept => $handle) and next unless $args->{tls};

    # Start TLS handshake
    my $tls = Mojo::IOLoop::TLS->new($handle)->reactor($self->reactor);
    $tls->on(upgrade => sub { $self->emit(accept => pop) });
    $tls->on(error   => sub { });
    $tls->negotiate(%$args, server => 1);
  }
}

1;

=encoding utf8

=head1 NAME

Mojo::IOLoop::Server - Non-blocking TCP and UNIX domain socket server

=head1 SYNOPSIS

  use Mojo::IOLoop::Server;

  # Create listen socket
  my $server = Mojo::IOLoop::Server->new;
  $server->on(accept => sub ($server, $handle) {...});
  $server->listen(port => 3000);

  # Start and stop accepting connections
  $server->start;
  $server->stop;

  # Start reactor if necessary
  $server->reactor->start unless $server->reactor->is_running;

=head1 DESCRIPTION

L<Mojo::IOLoop::Server> accepts TCP/IP and UNIX domain socket connections for L<Mojo::IOLoop>.

=head1 EVENTS

L<Mojo::IOLoop::Server> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 accept

  $server->on(accept => sub ($server, $handle) {...});

Emitted for each accepted connection.

=head1 ATTRIBUTES

L<Mojo::IOLoop::Server> implements the following attributes.

=head2 reactor

  my $reactor = $server->reactor;
  $server     = $server->reactor(Mojo::Reactor::Poll->new);

Low-level event reactor, defaults to the C<reactor> attribute value of the global L<Mojo::IOLoop> singleton. Note that
this attribute is weakened.

=head1 METHODS

L<Mojo::IOLoop::Server> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 generate_port

  my $port = Mojo::IOLoop::Server->generate_port;

Find a free TCP port, primarily used for tests.

=head2 handle

  my $handle = $server->handle;

Get handle for server, usually an L<IO::Socket::IP> object.

=head2 is_accepting

  my $bool = $server->is_accepting;

Check if connections are currently being accepted.

=head2 listen

  $server->listen(port => 3000);
  $server->listen({port => 3000});

Create a new listen socket. Note that TLS support depends on L<IO::Socket::SSL> (2.009+).

These options are currently available:

=over 2

=item address

  address => '127.0.0.1'

Local address to listen on, defaults to C<0.0.0.0>.

=item backlog

  backlog => 128

Maximum backlog size, defaults to C<SOMAXCONN>.

=item fd

  fd => 3

File descriptor with an already prepared listen socket.

=item path

  path => '/tmp/myapp.sock'

Path for UNIX domain socket to listen on.

=item port

  port => 80

Port to listen on, defaults to a random port.

=item reuse

  reuse => 1

Allow multiple servers to use the same port with the C<SO_REUSEPORT> socket option.

=item single_accept

  single_accept => 1

Only accept one connection at a time.

=item tls

  tls => 1

Enable TLS.

=item tls_ca

  tls_ca => '/etc/tls/ca.crt'

Path to TLS certificate authority file.

=item tls_cert

  tls_cert => '/etc/tls/server.crt'
  tls_cert => {'mojolicious.org' => '/etc/tls/mojo.crt'}

Path to the TLS cert file, defaults to a built-in test certificate.

=item tls_key

  tls_key => '/etc/tls/server.key'
  tls_key => {'mojolicious.org' => '/etc/tls/mojo.key'}

Path to the TLS key file, defaults to a built-in test key.

=item tls_options

  tls_options => {SSL_alpn_protocols => ['foo', 'bar'], SSL_verify_mode => 0x00}

Additional options for L<IO::Socket::SSL>.

=back

=head2 port

  my $port = $server->port;

Get port this server is listening on.

=head2 start

  $server->start;

Start or resume accepting connections.

=head2 stop

  $server->stop;

Stop accepting connections.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::IOLoop::Client;
use Mojo::Base 'Mojo::EventEmitter';

use Errno qw(EINPROGRESS);
use IO::Socket::IP;
use IO::Socket::UNIX;
use Mojo::IOLoop;
use Mojo::IOLoop::TLS;
use Scalar::Util qw(weaken);
use Socket       qw(IPPROTO_TCP SOCK_STREAM TCP_NODELAY);

# Non-blocking name resolution requires Net::DNS::Native
use constant NNR => $ENV{MOJO_NO_NNR} ? 0 : !!eval { require Net::DNS::Native; Net::DNS::Native->VERSION('0.15'); 1 };
my $NDN;

# SOCKS support requires IO::Socket::Socks
use constant SOCKS => $ENV{MOJO_NO_SOCKS}
  ? 0
  : !!eval { require IO::Socket::Socks; IO::Socket::Socks->VERSION('0.64'); 1 };
use constant READ  => SOCKS ? IO::Socket::Socks::SOCKS_WANT_READ()  : 0;
use constant WRITE => SOCKS ? IO::Socket::Socks::SOCKS_WANT_WRITE() : 0;

has reactor => sub { Mojo::IOLoop->singleton->reactor }, weak => 1;

sub DESTROY { shift->_cleanup }

sub can_nnr   {NNR}
sub can_socks {SOCKS}

sub connect {
  my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});

  # Timeout
  weaken $self;
  my $reactor = $self->reactor;
  $self->{timer} = $reactor->timer($args->{timeout} || 10, sub { $self->emit(error => 'Connect timeout') });

  # Blocking name resolution
  $_ && s/[[\]]//g for @$args{qw(address socks_address)};
  my $address = $args->{socks_address} || ($args->{address} ||= '127.0.0.1');
  return $reactor->next_tick(sub { $self && $self->_connect($args) }) if !NNR || $args->{handle} || $args->{path};

  # Non-blocking name resolution
  $NDN //= Net::DNS::Native->new(pool => 5, extra_thread => 1);
  my $handle = $self->{dns}
    = $NDN->getaddrinfo($address, _port($args), {protocol => IPPROTO_TCP, socktype => SOCK_STREAM});
  $reactor->io(
    $handle => sub {
      my $reactor = shift;

      $reactor->remove($self->{dns});
      my ($err, @res) = $NDN->get_result(delete $self->{dns});
      return $self->emit(error => "Can't resolve: $err") if $err;

      $args->{addr_info} = \@res;
      $self->_connect($args);
    }
  )->watch($handle, 1, 0);
}

sub _cleanup {
  my $self = shift;
  $NDN->timedout($self->{dns}) if $NDN && $self->{dns};
  return $self unless my $reactor = $self->reactor;
  $self->{$_} && $reactor->remove(delete $self->{$_}) for qw(dns timer handle);
  return $self;
}

sub _connect {
  my ($self, $args) = @_;

  my $path   = $args->{path};
  my $handle = $self->{handle} = $args->{handle};

  unless ($handle) {
    my $class   = $path ? 'IO::Socket::UNIX' : 'IO::Socket::IP';
    my %options = (Blocking => 0);

    # UNIX domain socket
    if ($path) { $options{Peer} = $path }

    # IP socket
    else {
      if (my $info = $args->{addr_info}) { $options{PeerAddrInfo} = $info }
      else {
        $options{PeerAddr} = $args->{socks_address} || $args->{address};
        $options{PeerPort} = _port($args);
      }
      @options{keys %{$args->{socket_options}}} = values %{$args->{socket_options}} if $args->{socket_options};
    }

    return $self->emit(error => "Can't connect: $@") unless $self->{handle} = $handle = $class->new(%options);
  }
  $handle->blocking(0);

  $path ? $self->_try_socks($args) : $self->_wait('_ready', $handle, $args);
}

sub _port { $_[0]{socks_port} || $_[0]{port} || ($_[0]{tls} ? 443 : 80) }

sub _ready {
  my ($self, $args) = @_;

  # Socket changes in between attempts and needs to be re-added for epoll/kqueue
  my $handle = $self->{handle};
  unless ($handle->connect) {
    return $self->emit(error => $!) unless $! == EINPROGRESS;
    $self->reactor->remove($handle);
    return $self->_wait('_ready', $handle, $args);
  }

  return $self->emit(error => $! || 'Not connected') unless $handle->connected;

  # Disable Nagle's algorithm
  setsockopt $handle, IPPROTO_TCP, TCP_NODELAY, 1;

  $self->_try_socks($args);
}

sub _socks {
  my ($self, $args) = @_;

  # Connected
  my $handle = $self->{handle};
  return $self->_try_tls($args) if $handle->ready;

  # Switch between reading and writing
  my $err = $IO::Socket::Socks::SOCKS_ERROR;
  if    ($err == READ)  { $self->reactor->watch($handle, 1, 0) }
  elsif ($err == WRITE) { $self->reactor->watch($handle, 1, 1) }
  else                  { $self->emit(error => $err) }
}

sub _try_socks {
  my ($self, $args) = @_;

  my $handle = $self->{handle};
  return $self->_try_tls($args)                                                     unless $args->{socks_address};
  return $self->emit(error => 'IO::Socket::Socks 0.64+ required for SOCKS support') unless SOCKS;

  my %options = (ConnectAddr => $args->{address}, ConnectPort => $args->{port});
  @options{qw(AuthType Username Password)} = ('userpass', @$args{qw(socks_user socks_pass)}) if $args->{socks_user};
  my $reactor = $self->reactor;
  $reactor->remove($handle);
  return $self->emit(error => 'SOCKS upgrade failed') unless IO::Socket::Socks->start_SOCKS($handle, %options);

  $self->_wait('_socks', $handle, $args);
}

sub _try_tls {
  my ($self, $args) = @_;

  my $handle = $self->{handle};
  return $self->_cleanup->emit(connect => $handle) unless $args->{tls};
  my $reactor = $self->reactor;
  $reactor->remove($handle);

  # Start TLS handshake
  weaken $self;
  my $tls = Mojo::IOLoop::TLS->new($handle)->reactor($self->reactor);
  $tls->on(upgrade => sub { $self->_cleanup->emit(connect => pop) });
  $tls->on(error   => sub { $self->emit(error => pop) });
  $tls->negotiate(%$args);
}

sub _wait {
  my ($self, $next, $handle, $args) = @_;
  weaken $self;
  $self->reactor->io($handle => sub { $self->$next($args) })->watch($handle, 0, 1);
}

1;

=encoding utf8

=head1 NAME

Mojo::IOLoop::Client - Non-blocking TCP/IP and UNIX domain socket client

=head1 SYNOPSIS

  use Mojo::IOLoop::Client;

  # Create socket connection
  my $client = Mojo::IOLoop::Client->new;
  $client->on(connect => sub ($client, $handle) {...});
  $client->on(error => sub ($client, $err) {...});
  $client->connect(address => 'example.com', port => 80);

  # Start reactor if necessary
  $client->reactor->start unless $client->reactor->is_running;

=head1 DESCRIPTION

L<Mojo::IOLoop::Client> opens TCP/IP and UNIX domain socket connections for L<Mojo::IOLoop>.

=head1 EVENTS

L<Mojo::IOLoop::Client> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 connect

  $client->on(connect => sub ($client, $handle) {...});

Emitted once the connection is established.

=head2 error

  $client->on(error => sub ($client, $err) {...});

Emitted if an error occurs on the connection, fatal if unhandled.

=head1 ATTRIBUTES

L<Mojo::IOLoop::Client> implements the following attributes.

=head2 reactor

  my $reactor = $client->reactor;
  $client     = $client->reactor(Mojo::Reactor::Poll->new);

Low-level event reactor, defaults to the C<reactor> attribute value of the global L<Mojo::IOLoop> singleton. Note that
this attribute is weakened.

=head1 METHODS

L<Mojo::IOLoop::Client> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 can_nnr

  my $bool = Mojo::IOLoop::Client->can_nnr;

True if L<Net::DNS::Native> 0.15+ is installed and non-blocking name resolution support enabled.

=head2 can_socks

  my $bool = Mojo::IOLoop::Client->can_socks;

True if L<IO::Socket::SOCKS> 0.64+ is installed and SOCKS5 support enabled.

=head2 connect

  $client->connect(address => '127.0.0.1', port => 3000);
  $client->connect({address => '127.0.0.1', port => 3000});

Open a socket connection to a remote host. Note that non-blocking name resolution depends on L<Net::DNS::Native>
(0.15+), SOCKS5 support on L<IO::Socket::Socks> (0.64), and TLS support on L<IO::Socket::SSL> (2.009+).

These options are currently available:

=over 2

=item address

  address => 'mojolicious.org'

Address or host name of the peer to connect to, defaults to C<127.0.0.1>.

=item handle

  handle => $handle

Use an already prepared L<IO::Socket::IP> object.

=item path

  path => '/tmp/myapp.sock'

Path of UNIX domain socket to connect to.

=item port

  port => 80

Port to connect to, defaults to C<80> or C<443> with C<tls> option.

=item socket_options

  socket_options => {LocalAddr => '127.0.0.1'}

Additional options for L<IO::Socket::IP> when opening new connections.

=item socks_address

  socks_address => '127.0.0.1'

Address or host name of SOCKS5 proxy server to use for connection.

=item socks_pass

  socks_pass => 'secr3t'

Password to use for SOCKS5 authentication.

=item socks_port

  socks_port => 9050

Port of SOCKS5 proxy server to use for connection.

=item socks_user

  socks_user => 'sri'

Username to use for SOCKS5 authentication.

=item timeout

  timeout => 15

Maximum amount of time in seconds establishing connection may take before getting canceled, defaults to C<10>.

=item tls

  tls => 1

Enable TLS.

=item tls_ca

  tls_ca => '/etc/tls/ca.crt'

Path to TLS certificate authority file.

=item tls_cert

  tls_cert => '/etc/tls/client.crt'

Path to the TLS certificate file.

=item tls_key

  tls_key => '/etc/tls/client.key'

Path to the TLS key file.

=item tls_options

  tls_options => {SSL_alpn_protocols => ['foo', 'bar'], SSL_verify_mode => 0x00}

Additional options for L<IO::Socket::SSL>.

=back

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::IOLoop::TLS;
use Mojo::Base 'Mojo::EventEmitter';

use Mojo::File qw(curfile);
use Mojo::IOLoop;
use Scalar::Util qw(weaken);

# TLS support requires IO::Socket::SSL
use constant TLS   => $ENV{MOJO_NO_TLS} ? 0 : !!eval { require IO::Socket::SSL; IO::Socket::SSL->VERSION('2.009'); 1 };
use constant READ  => TLS               ? IO::Socket::SSL::SSL_WANT_READ()  : 0;
use constant WRITE => TLS               ? IO::Socket::SSL::SSL_WANT_WRITE() : 0;

has reactor => sub { Mojo::IOLoop->singleton->reactor }, weak => 1;

# To regenerate the certificate run this command (28.06.2019)
# openssl req -x509 -newkey rsa:4096 -nodes -sha256 -out server.crt \
#   -keyout server.key -days 7300 -subj '/CN=localhost'
my $CERT = curfile->sibling('resources', 'server.crt')->to_string;
my $KEY  = curfile->sibling('resources', 'server.key')->to_string;

sub DESTROY { shift->_cleanup }

sub can_tls {TLS}

sub negotiate {
  my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});

  return $self->emit(error => 'IO::Socket::SSL 2.009+ required for TLS support') unless TLS;

  my $handle = $self->{handle};
  return $self->emit(error => $IO::Socket::SSL::SSL_ERROR)
    unless IO::Socket::SSL->start_SSL($handle, %{$self->_expand($args)});
  $self->reactor->io($handle => sub { $self->_tls($handle, $args->{server}) });
}

sub new { shift->SUPER::new(handle => shift) }

sub _cleanup {
  my $self = shift;
  return undef unless my $reactor = $self->reactor;
  $reactor->remove($self->{handle}) if $self->{handle};
  return $self;
}

sub _expand {
  my ($self, $args) = @_;

  weaken $self;
  my $tls = {SSL_error_trap => sub { $self->_cleanup->emit(error => $_[1]) }, SSL_startHandshake => 0};
  $tls->{SSL_ca_file}   = $args->{tls_ca}   if $args->{tls_ca} && -T $args->{tls_ca};
  $tls->{SSL_cert_file} = $args->{tls_cert} if $args->{tls_cert};
  $tls->{SSL_key_file}  = $args->{tls_key}  if $args->{tls_key};
  $tls->{SSL_server}    = $args->{server}   if $args->{server};
  @{$tls}{keys %{$args->{tls_options}}} = values %{$args->{tls_options}} if $args->{tls_options};

  if ($args->{server}) {
    $tls->{SSL_cert_file} ||= $CERT;
    $tls->{SSL_key_file}  ||= $KEY;
  }
  else {
    $tls->{SSL_hostname}      = IO::Socket::SSL->can_client_sni ? $args->{address} : '';
    $tls->{SSL_verifycn_name} = $args->{address};
  }

  return $tls;
}

sub _tls {
  my ($self, $handle, $server) = @_;

  # Switch between reading and writing
  if (!($server ? $handle->accept_SSL : $handle->connect_SSL)) {
    my $err = $IO::Socket::SSL::SSL_ERROR;
    if    ($err == READ)  { $self->reactor->watch($handle, 1, 0) }
    elsif ($err == WRITE) { $self->reactor->watch($handle, 1, 1) }
  }

  else { $self->_cleanup->emit(upgrade => delete $self->{handle}) }
}

1;

=encoding utf8

=head1 NAME

Mojo::IOLoop::TLS - Non-blocking TLS handshake

=head1 SYNOPSIS

  use Mojo::IOLoop::TLS;

  # Negotiate TLS
  my $tls = Mojo::IOLoop::TLS->new($old_handle);
  $tls->on(upgrade => sub ($tls, $new_handle) {...});
  $tls->on(error => sub ($tls, $err) {...});
  $tls->negotiate(server => 1, tls_version => 'TLSv1_2');

  # Start reactor if necessary
  $tls->reactor->start unless $tls->reactor->is_running;

=head1 DESCRIPTION

L<Mojo::IOLoop::TLS> negotiates TLS for L<Mojo::IOLoop>.

=head1 EVENTS

L<Mojo::IOLoop::TLS> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 upgrade

  $tls->on(upgrade => sub ($tls, $handle) {...});

Emitted once TLS has been negotiated.

=head2 error

  $tls->on(error => sub ($tls, $err) {...});

Emitted if an error occurs during negotiation, fatal if unhandled.

=head1 ATTRIBUTES

L<Mojo::IOLoop::TLS> implements the following attributes.

=head2 reactor

  my $reactor = $tls->reactor;
  $tls        = $tls->reactor(Mojo::Reactor::Poll->new);

Low-level event reactor, defaults to the C<reactor> attribute value of the global L<Mojo::IOLoop> singleton. Note that
this attribute is weakened.

=head1 METHODS

L<Mojo::IOLoop::TLS> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 can_tls

  my $bool = Mojo::IOLoop::TLS->can_tls;

True if L<IO::Socket::SSL> 2.009+ is installed and TLS support enabled.

=head2 negotiate

  $tls->negotiate(server => 1, tls_version => 'TLSv1_2');
  $tls->negotiate({server => 1, tls_version => 'TLSv1_2'});

Negotiate TLS.

These options are currently available:

=over 2

=item server

  server => 1

Negotiate TLS from the server-side, defaults to the client-side.

=item tls_ca

  tls_ca => '/etc/tls/ca.crt'

Path to TLS certificate authority file.

=item tls_cert

  tls_cert => '/etc/tls/server.crt'
  tls_cert => {'mojolicious.org' => '/etc/tls/mojo.crt'}

Path to the TLS cert file, defaults to a built-in test certificate on the server-side.

=item tls_key

  tls_key => '/etc/tls/server.key'
  tls_key => {'mojolicious.org' => '/etc/tls/mojo.key'}

Path to the TLS key file, defaults to a built-in test key on the server-side.

=item tls_options

  tls_options => {SSL_alpn_protocols => ['foo', 'bar'], SSL_verify_mode => 0x00, SSL_version => 'TLSv1_2'}

Additional options for L<IO::Socket::SSL>.

=back

=head2 new

  my $tls = Mojo::IOLoop::TLS->new($handle);

Construct a new L<Mojo::IOLoop::Stream> object.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Parameters;
use Mojo::Base -base;
use overload '@{}' => sub { shift->pairs }, bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;

use Mojo::Util qw(decode encode url_escape url_unescape);

has charset => 'UTF-8';

sub append {
  my $self = shift;

  my $old = $self->pairs;
  my @new = @_ == 1 ? @{shift->pairs} : @_;
  while (my ($name, $value) = splice @new, 0, 2) {

    # Multiple values
    if (ref $value eq 'ARRAY') { push @$old, $name => $_ // '' for @$value }

    # Single value
    elsif (defined $value) { push @$old, $name => $value }
  }

  return $self;
}

sub clone {
  my $self = shift;

  my $clone = $self->new;
  if   (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
  if   (defined $self->{string}) { $clone->{string}  = $self->{string} }
  else                           { $clone->{pairs}   = [@{$self->pairs}] }

  return $clone;
}

sub every_param {
  my ($self, $name) = @_;

  my @values;
  my $pairs = $self->pairs;
  for (my $i = 0; $i < @$pairs; $i += 2) {
    push @values, $pairs->[$i + 1] if $pairs->[$i] eq $name;
  }

  return \@values;
}

sub merge {
  my $self = shift;

  my $merge = @_ == 1 ? shift->to_hash : {@_};
  for my $name (sort keys %$merge) {
    my $value = $merge->{$name};
    defined $value ? $self->param($name => $value) : $self->remove($name);
  }

  return $self;
}

sub names { [sort keys %{shift->to_hash}] }

sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }

sub pairs {
  my $self = shift;

  # Replace parameters
  if (@_) {
    $self->{pairs} = shift;
    delete $self->{string};
    return $self;
  }

  # Parse string
  if (defined(my $str = delete $self->{string})) {
    my $pairs = $self->{pairs} = [];
    return $pairs unless length $str;

    my $charset = $self->charset;
    for my $pair (split /&/, $str) {
      next unless $pair =~ /^([^=]+)(?:=(.*))?$/;
      my ($name, $value) = ($1, $2 // '');

      # Replace "+" with whitespace, unescape and decode
      s/\+/ /g for $name, $value;
      $name  = url_unescape $name;
      $name  = decode($charset, $name) // $name if $charset;
      $value = url_unescape $value;
      $value = decode($charset, $value) // $value if $charset;

      push @$pairs, $name, $value;
    }
  }

  return $self->{pairs} //= [];
}

sub param {
  my ($self, $name) = (shift, shift);
  return $self->every_param($name)->[-1] unless @_;
  $self->remove($name);
  return $self->append($name => ref $_[0] eq 'ARRAY' ? $_[0] : [@_]);
}

sub parse {
  my $self = shift;

  # Pairs
  return $self->append(@_) if @_ > 1;

  # String
  $self->{string} = shift;
  return $self;
}

sub remove {
  my ($self, $name) = @_;
  my $pairs = $self->pairs;
  my $i     = 0;
  $pairs->[$i] eq $name ? splice @$pairs, $i, 2 : ($i += 2) while $i < @$pairs;
  return $self;
}

sub to_hash {
  my $self = shift;

  my %hash;
  my $pairs = $self->pairs;
  for (my $i = 0; $i < @$pairs; $i += 2) {
    my ($name, $value) = @{$pairs}[$i, $i + 1];

    # Array
    if (exists $hash{$name}) {
      $hash{$name} = [$hash{$name}] if ref $hash{$name} ne 'ARRAY';
      push @{$hash{$name}}, $value;
    }

    # String
    else { $hash{$name} = $value }
  }

  return \%hash;
}

sub to_string {
  my $self = shift;

  # String (RFC 3986)
  my $charset = $self->charset;
  if (defined(my $str = $self->{string})) {
    $str = encode $charset, $str if $charset;
    return url_escape $str, '^A-Za-z0-9\-._~%!$&\'()*+,;=:@/?';
  }

  # Build pairs (HTML Living Standard)
  my $pairs = $self->pairs;
  return '' unless @$pairs;
  my @pairs;
  for (my $i = 0; $i < @$pairs; $i += 2) {
    my ($name, $value) = @{$pairs}[$i, $i + 1];

    # Escape and replace whitespace with "+"
    $name  = encode $charset,   $name if $charset;
    $name  = url_escape $name,  '^*\-.0-9A-Z_a-z';
    $value = encode $charset,   $value if $charset;
    $value = url_escape $value, '^*\-.0-9A-Z_a-z';
    s/\%20/\+/g for $name, $value;

    push @pairs, "$name=$value";
  }

  return join '&', @pairs;
}

1;

=encoding utf8

=head1 NAME

Mojo::Parameters - Parameters

=head1 SYNOPSIS

  use Mojo::Parameters;

  # Parse
  my $params = Mojo::Parameters->new('foo=bar&baz=23');
  say $params->param('baz');

  # Build
  my $params = Mojo::Parameters->new(foo => 'bar', baz => 23);
  push @$params, i => 'â™¥ mojolicious';
  say "$params";

=head1 DESCRIPTION

L<Mojo::Parameters> is a container for form parameters used by L<Mojo::URL>, based on L<RFC
3986|https://tools.ietf.org/html/rfc3986> and the L<HTML Living Standard|https://html.spec.whatwg.org>.

=head1 ATTRIBUTES

L<Mojo::Parameters> implements the following attributes.

=head2 charset

  my $charset = $params->charset;
  $params     = $params->charset('UTF-8');

Charset used for encoding and decoding parameters, defaults to C<UTF-8>.

  # Disable encoding and decoding
  $params->charset(undef);

=head1 METHODS

L<Mojo::Parameters> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 append

  $params = $params->append(foo => 'ba&r');
  $params = $params->append(foo => ['ba&r', 'baz']);
  $params = $params->append(foo => ['bar', 'baz'], bar => 23);
  $params = $params->append(Mojo::Parameters->new);

Append parameters. Note that this method will normalize the parameters.

  # "foo=bar&foo=baz"
  Mojo::Parameters->new('foo=bar')->append(Mojo::Parameters->new('foo=baz'));

  # "foo=bar&foo=baz"
  Mojo::Parameters->new('foo=bar')->append(foo => 'baz');

  # "foo=bar&foo=baz&foo=yada"
  Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada']);

  # "foo=bar&foo=baz&foo=yada&bar=23"
  Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada'], bar => 23);

=head2 clone

  my $params2 = $params->clone;

Return a new L<Mojo::Parameters> object cloned from these parameters.

=head2 every_param

  my $values = $params->every_param('foo');

Similar to L</"param">, but returns all values sharing the same name as an array reference. Note that this method will
normalize the parameters.

  # Get first value
  say $params->every_param('foo')->[0];

=head2 merge

  $params = $params->merge(foo => 'ba&r');
  $params = $params->merge(foo => ['ba&r', 'baz']);
  $params = $params->merge(foo => ['bar', 'baz'], bar => 23);
  $params = $params->merge(Mojo::Parameters->new);

Merge parameters. Note that this method will normalize the parameters.

  # "foo=baz"
  Mojo::Parameters->new('foo=bar')->merge(Mojo::Parameters->new('foo=baz'));

  # "yada=yada&foo=baz"
  Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => 'baz');

  # "yada=yada"
  Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => undef);

=head2 names

  my $names = $params->names;

Return an array reference with all parameter names.

  # Names of all parameters
  say for @{$params->names};

=head2 new

  my $params = Mojo::Parameters->new;
  my $params = Mojo::Parameters->new('foo=b%3Bar&baz=23');
  my $params = Mojo::Parameters->new(foo => 'b&ar');
  my $params = Mojo::Parameters->new(foo => ['ba&r', 'baz']);
  my $params = Mojo::Parameters->new(foo => ['bar', 'baz'], bar => 23);

Construct a new L<Mojo::Parameters> object and L</"parse"> parameters if necessary.

=head2 pairs

  my $array = $params->pairs;
  $params   = $params->pairs([foo => 'b&ar', baz => 23]);

Parsed parameter pairs. Note that this method will normalize the parameters.

  # Remove all parameters
  $params->pairs([]);

=head2 param

  my $value = $params->param('foo');
  $params   = $params->param(foo => 'ba&r');
  $params   = $params->param(foo => qw(ba&r baz));
  $params   = $params->param(foo => ['ba;r', 'baz']);

Access parameter values. If there are multiple values sharing the same name, and you want to access more than just the
last one, you can use L</"every_param">. Note that this method will normalize the parameters.

=head2 parse

  $params = $params->parse('foo=b%3Bar&baz=23');

Parse parameters.

=head2 remove

  $params = $params->remove('foo');

Remove parameters. Note that this method will normalize the parameters.

  # "bar=yada"
  Mojo::Parameters->new('foo=bar&foo=baz&bar=yada')->remove('foo');

=head2 to_hash

  my $hash = $params->to_hash;

Turn parameters into a hash reference. Note that this method will normalize the parameters.

  # "baz"
  Mojo::Parameters->new('foo=bar&foo=baz')->to_hash->{foo}[1];

=head2 to_string

  my $str = $params->to_string;

Turn parameters into a string.

  # "foo=bar&baz=23"
  Mojo::Parameters->new->pairs([foo => 'bar', baz => 23])->to_string;

=head1 OPERATORS

L<Mojo::Parameters> overloads the following operators.

=head2 array

  my @pairs = @$params;

Alias for L</"pairs">. Note that this will normalize the parameters.

  say $params->[0];
  say for @$params;

=head2 bool

  my $bool = !!$params;

Always true.

=head2 stringify

  my $str = "$params";

Alias for L</"to_string">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::JSON::Pointer;
use Mojo::Base -base;

has 'data';

sub contains { shift->_pointer(0, @_) }
sub get      { shift->_pointer(1, @_) }

sub new { @_ > 1 ? shift->SUPER::new(data => shift) : shift->SUPER::new }

sub _pointer {
  my ($self, $get, $pointer) = @_;

  my $data = $self->data;
  return length $pointer ? undef : $get ? $data : 1 unless $pointer =~ s!^/!!;
  for my $p (length $pointer ? (split /\//, $pointer, -1) : ($pointer)) {
    $p =~ s!~1!/!g;
    $p =~ s/~0/~/g;

    # Hash
    if (ref $data eq 'HASH' && exists $data->{$p}) { $data = $data->{$p} }

    # Array
    elsif (ref $data eq 'ARRAY' && $p =~ /^\d+$/ && @$data > $p) { $data = $data->[$p] }

    # Nothing
    else { return undef }
  }

  return $get ? $data : 1;
}

1;

=encoding utf8

=head1 NAME

Mojo::JSON::Pointer - JSON Pointers

=head1 SYNOPSIS

  use Mojo::JSON::Pointer;

  my $pointer = Mojo::JSON::Pointer->new({foo => [23, 'bar']});
  say $pointer->get('/foo/1');
  say 'Contains "/foo".' if $pointer->contains('/foo');

=head1 DESCRIPTION

L<Mojo::JSON::Pointer> is an implementation of L<RFC 6901|https://tools.ietf.org/html/rfc6901>.

=head1 ATTRIBUTES

L<Mojo::JSON::Pointer> implements the following attributes.

=head2 data

  my $data = $pointer->data;
  $pointer = $pointer->data({foo => 'bar'});

Data structure to be processed.

=head1 METHODS

L<Mojo::JSON::Pointer> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 contains

  my $bool = $pointer->contains('/foo/1');

Check if L</"data"> contains a value that can be identified with the given JSON Pointer.

  # True
  Mojo::JSON::Pointer->new('just a string')->contains('');
  Mojo::JSON::Pointer->new({'â™¥' => 'mojolicious'})->contains('/â™¥');
  Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/foo');
  Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/baz/1');

  # False
  Mojo::JSON::Pointer->new({'â™¥' => 'mojolicious'})->contains('/â˜ƒ');
  Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/bar');
  Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/baz/9');

=head2 get

  my $value = $pointer->get('/foo/bar');

Extract value from L</"data"> identified by the given JSON Pointer.

  # "just a string"
  Mojo::JSON::Pointer->new('just a string')->get('');

  # "mojolicious"
  Mojo::JSON::Pointer->new({'â™¥' => 'mojolicious'})->get('/â™¥');

  # "bar"
  Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/foo');

  # "4"
  Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/baz/0');

  # "6"
  Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/baz/2');

=head2 new

  my $pointer = Mojo::JSON::Pointer->new;
  my $pointer = Mojo::JSON::Pointer->new({foo => 'bar'});

Build new L<Mojo::JSON::Pointer> object.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Server;
use Mojo::Base 'Mojo::EventEmitter';

use Carp         qw(croak);
use Mojo::File   qw(path);
use Mojo::Loader qw(load_class);
use Mojo::Util   qw(md5_sum);
use POSIX        ();
use Scalar::Util qw(blessed);

has app             => sub { shift->build_app('Mojo::HelloWorld') };
has reverse_proxy   => sub { $ENV{MOJO_REVERSE_PROXY} || !!@{shift->trusted_proxies} };
has trusted_proxies => sub { [split /\s*,\s*/, ($ENV{MOJO_TRUSTED_PROXIES} // '')] };

our @ARGS_OVERRIDE;

sub build_app {
  my ($self, $app) = (shift, shift);
  local $ENV{MOJO_EXE};
  return $self->app($app->new(@_))->app unless my $e = load_class $app;
  die ref $e ? $e : qq{Can't find application class "$app" in \@INC. (@INC)\n};
}

sub build_tx {
  my $self = shift;
  my $tx   = $self->app->build_tx;
  push @{$tx->req->trusted_proxies}, @{$self->trusted_proxies};
  $tx->req->reverse_proxy(1) if $self->reverse_proxy;
  return $tx;
}

sub daemonize {

  # Fork and kill parent
  die "Can't fork: $!" unless defined(my $pid = fork);
  exit 0 if $pid;
  POSIX::setsid == -1 and die "Can't start a new session: $!";

  # Close filehandles
  open STDIN,  '<',  '/dev/null';
  open STDOUT, '>',  '/dev/null';
  open STDERR, '>&', STDOUT;
}

sub load_app {
  my ($self, $path, @args) = (shift, shift, ref $_[0] ? %{shift()} : @_);

  # Clean environment (reset FindBin defensively)
  {
    local $0 = $path = path($path)->to_abs->to_string;
    require FindBin;
    FindBin->again;
    local @ENV{qw(MOJO_APP_LOADER MOJO_EXE)} = (1, undef);
    local @ARGS_OVERRIDE = @args;

    # Try to load application from script into sandbox
    delete $INC{$path};
    my $app = eval "package Mojo::Server::Sandbox::@{[md5_sum $path]}; require \$path";
    die qq{Can't load application from file "$path": $@} if $@;
    die qq{File "$path" did not return an application object.\n} unless blessed $app && $app->can('handler');
    $self->app($app);
  };
  FindBin->again;

  return $self->app;
}

sub new {
  my $self = shift->SUPER::new(@_);
  $self->on(request => sub { shift->app->handler(shift) });
  return $self;
}

sub run { croak 'Method "run" not implemented by subclass' }

1;

=encoding utf8

=head1 NAME

Mojo::Server - HTTP/WebSocket server base class

=head1 SYNOPSIS

  package Mojo::Server::MyServer;
  use Mojo::Base 'Mojo::Server', -signatures;

  sub run ($self) {

    # Get a transaction
    my $tx = $self->build_tx;

    # Emit "request" event
    $self->emit(request => $tx);
  }

=head1 DESCRIPTION

L<Mojo::Server> is an abstract base class for HTTP/WebSocket servers and server interfaces, like L<Mojo::Server::CGI>,
L<Mojo::Server::Daemon>, L<Mojo::Server::Hypnotoad>, L<Mojo::Server::Morbo>, L<Mojo::Server::Prefork> and
L<Mojo::Server::PSGI>.

=head1 EVENTS

L<Mojo::Server> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 request

  $server->on(request => sub ($server, $tx) {...});

Emitted when a request is ready and needs to be handled.

  $server->on(request => sub ($server, $tx) {
    $tx->res->code(200);
    $tx->res->headers->content_type('text/plain');
    $tx->res->body('Hello World!');
    $tx->resume;
  });

=head1 ATTRIBUTES

L<Mojo::Server> implements the following attributes.

=head2 app

  my $app = $server->app;
  $server = $server->app(MojoSubclass->new);

Application this server handles, defaults to a L<Mojo::HelloWorld> object.

=head2 reverse_proxy

  my $bool = $server->reverse_proxy;
  $server  = $server->reverse_proxy($bool);

This server operates behind a reverse proxy, defaults to the value of the C<MOJO_REVERSE_PROXY> environment variable
or true if L</trusted_proxies> is not empty.

=head2 trusted_proxies

  my $proxies = $server->trusted_proxies;
  $server     = $server->trusted_proxies(['10.0.0.0/8', '127.0.0.1', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']);

This server expects requests from trusted reverse proxies, defaults to the value of the C<MOJO_TRUSTED_PROXIES>
environment variable split on commas with optional whitespace. These proxies should be addresses or networks in CIDR
form.

=head1 METHODS

L<Mojo::Server> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 build_app

  my $app = $server->build_app('MyApp');
  my $app = $server->build_app('MyApp', log => Mojo::Log->new);
  my $app = $server->build_app('MyApp', {log => Mojo::Log->new});

Build application from class and assign it to L</"app">.

=head2 build_tx

  my $tx = $server->build_tx;

Let application build a transaction.

=head2 daemonize

  $server->daemonize;

Daemonize server process.

=head2 load_app

  my $app = $server->load_app('/home/sri/myapp.pl');
  my $app = $server->load_app('/home/sri/myapp.pl', log => Mojo::Log->new);
  my $app = $server->load_app('/home/sri/myapp.pl', {log => Mojo::Log->new});

Load application from script and assign it to L</"app">.

  say Mojo::Server->new->load_app('./myapp.pl')->home;

=head2 new

  my $server = Mojo::Server->new;
  my $server = Mojo::Server->new(reverse_proxy => 1);
  my $server = Mojo::Server->new({reverse_proxy => 1});

Construct a new L<Mojo::Server> object and subscribe to L</"request"> event with default request handling.

=head2 run

  $server->run;

Run server. Meant to be overloaded in a subclass.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::EventEmitter;
use Mojo::Base -base;

use Scalar::Util qw(blessed weaken);

use constant DEBUG => $ENV{MOJO_EVENTEMITTER_DEBUG} || 0;

sub catch { $_[0]->on(error => $_[1]) and return $_[0] }

sub emit {
  my ($self, $name) = (shift, shift);

  if (my $s = $self->{events}{$name}) {
    warn "-- Emit $name in @{[blessed $self]} (@{[scalar @$s]})\n" if DEBUG;
    for my $cb (@$s) { $self->$cb(@_) }
  }
  else {
    warn "-- Emit $name in @{[blessed $self]} (0)\n" if DEBUG;
    die "@{[blessed $self]}: $_[0]"                  if $name eq 'error';
  }

  return $self;
}

sub has_subscribers { !!shift->{events}{shift()} }

sub on { push @{$_[0]{events}{$_[1]}}, $_[2] and return $_[2] }

sub once {
  my ($self, $name, $cb) = @_;

  weaken $self;
  my $wrapper = sub {
    $self->unsubscribe($name => __SUB__);
    $cb->(@_);
  };
  $self->on($name => $wrapper);

  return $wrapper;
}

sub subscribers { shift->{events}{shift()} //= [] }

sub unsubscribe {
  my ($self, $name, $cb) = @_;

  # One
  if ($cb) {
    $self->{events}{$name} = [grep { $cb ne $_ } @{$self->{events}{$name}}];
    delete $self->{events}{$name} unless @{$self->{events}{$name}};
  }

  # All
  else { delete $self->{events}{$name} }

  return $self;
}

1;

=encoding utf8

=head1 NAME

Mojo::EventEmitter - Event emitter base class

=head1 SYNOPSIS

  package Cat;
  use Mojo::Base 'Mojo::EventEmitter', -signatures;

  # Emit events
  sub poke ($self) { $self->emit(roar => 3) }

  package main;

  # Subscribe to events
  my $tiger = Cat->new;
  $tiger->on(roar => sub ($tiger, $times) { say 'RAWR!' for 1 .. $times });
  $tiger->poke;

=head1 DESCRIPTION

L<Mojo::EventEmitter> is a simple base class for event emitting objects.

=head1 EVENTS

L<Mojo::EventEmitter> can emit the following events.

=head2 error

  $e->on(error => sub ($e, $err) {...});

This is a special event for errors, it will not be emitted directly by this class, but is fatal if unhandled.
Subclasses may choose to emit it, but are not required to do so.

  $e->on(error => sub ($e, $err) { say "This looks bad: $err" });

=head1 METHODS

L<Mojo::EventEmitter> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 catch

  $e = $e->catch(sub {...});

Subscribe to L</"error"> event.

  # Longer version
  $e->on(error => sub {...});

=head2 emit

  $e = $e->emit('foo');
  $e = $e->emit('foo', 123);

Emit event.

=head2 has_subscribers

  my $bool = $e->has_subscribers('foo');

Check if event has subscribers.

=head2 on

  my $cb = $e->on(foo => sub {...});

Subscribe to event.

  $e->on(foo => sub ($e, @args) {...});

=head2 once

  my $cb = $e->once(foo => sub {...});

Subscribe to event and unsubscribe again after it has been emitted once.

  $e->once(foo => sub ($e, @args) {...});

=head2 subscribers

  my $subscribers = $e->subscribers('foo');

All subscribers for event.

  # Unsubscribe last subscriber
  $e->unsubscribe(foo => $e->subscribers('foo')->[-1]);

  # Change order of subscribers
  @{$e->subscribers('foo')} = reverse @{$e->subscribers('foo')};

=head2 unsubscribe

  $e = $e->unsubscribe('foo');
  $e = $e->unsubscribe(foo => $cb);

Unsubscribe from event.

=head1 DEBUGGING

You can set the C<MOJO_EVENTEMITTER_DEBUG> environment variable to get some advanced diagnostics information printed to
C<STDERR>.

  MOJO_EVENTEMITTER_DEBUG=1

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Asset;
use Mojo::Base 'Mojo::EventEmitter';

use Carp qw(croak);

has 'end_range';
has start_range => 0;

sub add_chunk { croak 'Method "add_chunk" not implemented by subclass' }
sub contains  { croak 'Method "contains" not implemented by subclass' }
sub get_chunk { croak 'Method "get_chunk" not implemented by subclass' }

sub is_file {undef}

sub is_range { !!($_[0]->end_range || $_[0]->start_range) }

sub move_to { croak 'Method "move_to" not implemented by subclass' }
sub mtime   { croak 'Method "mtime" not implemented by subclass' }
sub size    { croak 'Method "size" not implemented by subclass' }
sub slurp   { croak 'Method "slurp" not implemented by subclass' }
sub to_file { croak 'Method "to_file" not implemented by subclass' }

1;

=encoding utf8

=head1 NAME

Mojo::Asset - HTTP content storage base class

=head1 SYNOPSIS

  package Mojo::Asset::MyAsset;
  use Mojo::Base 'Mojo::Asset';

  sub add_chunk {...}
  sub contains  {...}
  sub get_chunk {...}
  sub move_to   {...}
  sub mtime     {...}
  sub size      {...}
  sub slurp     {...}
  sub to_file   {...}

=head1 DESCRIPTION

L<Mojo::Asset> is an abstract base class for HTTP content storage backends, like L<Mojo::Asset::File> and
L<Mojo::Asset::Memory>.

=head1 EVENTS

L<Mojo::Asset> inherits all events from L<Mojo::EventEmitter>.

=head1 ATTRIBUTES

L<Mojo::Asset> implements the following attributes.

=head2 end_range

  my $end = $asset->end_range;
  $asset  = $asset->end_range(8);

Pretend file ends earlier.

=head2 start_range

  my $start = $asset->start_range;
  $asset    = $asset->start_range(3);

Pretend file starts later.

=head1 METHODS

L<Mojo::Asset> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 add_chunk

  $asset = $asset->add_chunk('foo bar baz');

Add chunk of data to asset. Meant to be overloaded in a subclass.

=head2 contains

  my $position = $asset->contains('bar');

Check if asset contains a specific string. Meant to be overloaded in a subclass.

=head2 get_chunk

  my $bytes = $asset->get_chunk($offset);
  my $bytes = $asset->get_chunk($offset, $max);

Get chunk of data starting from a specific position, defaults to a maximum chunk size of C<131072> bytes (128KiB).
Meant to be overloaded in a subclass.

=head2 is_file

  my $bool = $asset->is_file;

False, this is not a L<Mojo::Asset::File> object.

=head2 is_range

  my $bool = $asset->is_range;

Check if asset has a L</"start_range"> or L</"end_range">.

=head2 move_to

  $asset = $asset->move_to('/home/sri/foo.txt');

Move asset data into a specific file. Meant to be overloaded in a subclass.

=head2 mtime

  my $mtime = $asset->mtime;

Modification time of asset. Meant to be overloaded in a subclass.

=head2 size

  my $size = $asset->size;

Size of asset data in bytes. Meant to be overloaded in a subclass.

=head2 slurp

  my $bytes = $asset->slurp;

Read all asset data at once. Meant to be overloaded in a subclass.

=head2 to_file

  my $file = $asset->to_file;

Convert asset to L<Mojo::Asset::File> object. Meant to be overloaded in a subclass.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Template;
use Mojo::Base -base;

use Carp qw(croak);
use Mojo::ByteStream;
use Mojo::Exception;
use Mojo::File qw(path);
use Mojo::Util qw(decode encode monkey_patch);

use constant DEBUG => $ENV{MOJO_TEMPLATE_DEBUG} || 0;

has [qw(append code prepend unparsed)] => '';
has [qw(auto_escape compiled vars)];
has capture_end                                 => 'end';
has capture_start                               => 'begin';
has comment_mark                                => '#';
has encoding                                    => 'UTF-8';
has escape                                      => sub { \&Mojo::Util::xml_escape };
has [qw(escape_mark expression_mark trim_mark)] => '=';
has [qw(line_start replace_mark)]               => '%';
has name                                        => 'template';
has namespace                                   => 'Mojo::Template::Sandbox';
has tag_start                                   => '<%';
has tag_end                                     => '%>';
has tree                                        => sub { [] };

sub parse {
  my ($self, $template) = @_;

  # Clean start
  $self->unparsed($template)->tree(\my @tree)->compiled(undef);

  my $tag     = $self->tag_start;
  my $replace = $self->replace_mark;
  my $expr    = $self->expression_mark;
  my $escp    = $self->escape_mark;
  my $cpen    = $self->capture_end;
  my $cmnt    = $self->comment_mark;
  my $cpst    = $self->capture_start;
  my $trim    = $self->trim_mark;
  my $end     = $self->tag_end;
  my $start   = $self->line_start;

  my $line_re  = qr/^(\s*)\Q$start\E(?:(\Q$replace\E)|(\Q$cmnt\E)|(\Q$expr\E))?(.*)$/;
  my $token_re = qr/
    (
      \Q$tag\E(?:\Q$replace\E|\Q$cmnt\E)                   # Replace
    |
      \Q$tag$expr\E(?:\Q$escp\E)?(?:\s*\Q$cpen\E(?!\w))?   # Expression
    |
      \Q$tag\E(?:\s*\Q$cpen\E(?!\w))?                      # Code
    |
      (?:(?<!\w)\Q$cpst\E\s*)?(?:\Q$trim\E)?\Q$end\E       # End
    )
  /x;
  my $cpen_re = qr/^\Q$tag\E(?:\Q$expr\E)?(?:\Q$escp\E)?\s*\Q$cpen\E(.*)$/;
  my $end_re  = qr/^(?:(\Q$cpst\E)\s*)?(\Q$trim\E)?\Q$end\E$/;

  # Split lines
  my $op = 'text';
  my ($trimming, $capture);
  for my $line (split /\n/, $template) {

    # Turn Perl line into mixed line
    if ($op eq 'text' && $line =~ $line_re) {

      # Escaped start
      if ($2) { $line = "$1$start$5" }

      # Comment
      elsif ($3) { $line = "$tag$3 $trim$end" }

      # Expression or code
      else { $line = $4 ? "$1$tag$4$5 $end" : "$tag$5 $trim$end" }
    }

    # Escaped line ending
    $line .= "\n" if $line !~ s/\\\\$/\\\n/ && $line !~ s/\\$//;

    # Mixed line
    for my $token (split $token_re, $line) {

      # Capture end
      ($token, $capture) = ("$tag$1", 1) if $token =~ $cpen_re;

      # End
      if ($op ne 'text' && $token =~ $end_re) {

        # Capture start
        splice @tree, -1, 0, ['cpst'] if $1;

        # Trim left side
        _trim(\@tree) if ($trimming = $2) && @tree > 1;

        # Hint at end
        push @tree, [$op = 'text', ''];
      }

      # Code
      elsif ($token eq $tag) { $op = 'code' }

      # Expression
      elsif ($token eq "$tag$expr") { $op = 'expr' }

      # Expression that needs to be escaped
      elsif ($token eq "$tag$expr$escp") { $op = 'escp' }

      # Comment
      elsif ($token eq "$tag$cmnt") { $op = 'cmnt' }

      # Text (comments are just ignored)
      elsif ($op ne 'cmnt') {

        # Replace
        $token = $tag if $token eq "$tag$replace";

        # Trim right side (convert whitespace to line noise)
        if ($trimming && $token =~ s/^(\s+)//) {
          push @tree, ['code', $1];
          $trimming = 0;
        }

        # Token (with optional capture end)
        push @tree, $capture ? ['cpen'] : (), [$op, $token];
        $capture = 0;
      }
    }

    # Optimize successive text lines separated by a newline
    push @tree, ['line'] and next
      if $tree[-4] && $tree[-4][0] ne 'line'
      || (!$tree[-3] || $tree[-3][0] ne 'text' || $tree[-3][1] !~ /\n$/)
      || ($tree[-2][0] ne 'line' || $tree[-1][0] ne 'text');
    $tree[-3][1] .= pop(@tree)->[1];
  }

  return $self;
}

sub process {
  my $self = shift;

  # Use a local stack trace for compile exceptions
  my $compiled = $self->compiled;
  unless ($compiled) {
    my $code = $self->_compile->code;
    monkey_patch $self->namespace, '_escape', $self->escape;
    return Mojo::Exception->new($@)->inspect($self->unparsed, $code)->trace->verbose(1)
      unless $compiled = eval $self->_wrap($code, @_);
    $self->compiled($compiled);
  }

  # Use a real stack trace for normal exceptions
  local $SIG{__DIE__} = sub {
    CORE::die $_[0] if ref $_[0];
    CORE::die Mojo::Exception->new(shift)->trace->inspect($self->unparsed, $self->code)->verbose(1);
  };

  my $output;
  return eval { $output = $compiled->(@_); 1 } ? $output : $@;
}

sub render { shift->parse(shift)->process(@_) }

sub render_file {
  my ($self, $path) = (shift, shift);

  $self->name($path) unless defined $self->{name};
  my $template = path($path)->slurp;
  my $encoding = $self->encoding;
  croak qq{Template "$path" has invalid encoding} if $encoding && !defined($template = decode $encoding, $template);

  return $self->render($template, @_);
}

sub _compile {
  my $self = shift;

  my $tree   = $self->tree;
  my $escape = $self->auto_escape;

  my @blocks = ('');
  my ($i, $capture, $multi);
  while (++$i <= @$tree && (my $next = $tree->[$i])) {
    my ($op, $value) = @{$tree->[$i - 1]};
    push @blocks, '' and next if $op eq 'line';
    my $newline = chomp($value //= '');

    # Text (quote and fix line ending)
    if ($op eq 'text') {
      $value = join "\n", map { quotemeta $_ } split(/\n/, $value, -1);
      $value      .= '\n'                          if $newline;
      $blocks[-1] .= "\$_O .= \"" . $value . "\";" if length $value;
    }

    # Code or multi-line expression
    elsif ($op eq 'code' || $multi) { $blocks[-1] .= $value }

    # Capture end
    elsif ($op eq 'cpen') {
      $blocks[-1] .= 'return Mojo::ByteStream->new($_O) }';

      # No following code
      $blocks[-1] .= ';' if $next->[0] ne 'cpst' && ($next->[1] // '') =~ /^\s*$/;
    }

    # Expression
    if ($op eq 'expr' || $op eq 'escp') {

      # Escaped
      if (!$multi && ($op eq 'escp' && !$escape || $op eq 'expr' && $escape)) {
        $blocks[-1] .= "\$_O .= _escape scalar + $value";
      }

      # Raw
      elsif (!$multi) { $blocks[-1] .= "\$_O .= scalar + $value" }

      # Multi-line
      $multi = !$next || $next->[0] ne 'text';

      # Append semicolon
      $blocks[-1] .= ';' unless $multi || $capture;
    }

    # Capture start
    if    ($op eq 'cpst') { $capture = 1 }
    elsif ($capture) {
      $blocks[-1] .= "sub { my \$_O = ''; ";
      $capture = 0;
    }
  }

  return $self->code(join "\n", @blocks)->tree([]);
}

sub _line {
  my $name = shift->name;
  $name =~ y/"//d;
  return qq{#line @{[shift]} "$name"};
}

sub _trim {
  my $tree = shift;

  # Skip captures
  my $i = $tree->[-2][0] eq 'cpst' || $tree->[-2][0] eq 'cpen' ? -3 : -2;

  # Only trim text
  return unless $tree->[$i][0] eq 'text';

  # Convert whitespace text to line noise
  splice @$tree, $i, 0, ['code', $1] if $tree->[$i][1] =~ s/(\s+)$//;
}

sub _wrap {
  my ($self, $body, $vars) = @_;

  # Variables
  my $args = '';
  if ($self->vars && (my @vars = grep {/^\w+$/} keys %$vars)) {
    $args = 'my (' . join(',', map {"\$$_"} @vars) . ')';
    $args .= '= @{shift()}{qw(' . join(' ', @vars) . ')};';
  }

  # Wrap lines
  my $num  = () = $body =~ /\n/g;
  my $code = $self->_line(1) . "\npackage @{[$self->namespace]};";
  $code .= "use Mojo::Base -strict; no warnings 'ambiguous';";
  $code .= "sub { my \$_O = ''; @{[$self->prepend]};{ $args { $body\n";
  $code .= $self->_line($num + 1) . "\n;}@{[$self->append]}; } \$_O };";

  warn "-- Code for @{[$self->name]}\n@{[encode 'UTF-8', $code]}\n\n" if DEBUG;
  return $code;
}

1;

=encoding utf8

=head1 NAME

Mojo::Template - Perl-ish templates

=head1 SYNOPSIS

  use Mojo::Template;

  # Use Perl modules
  my $mt = Mojo::Template->new;
  say $mt->render(<<'EOF');
  % use Time::Piece;
  <div>
    % my $now = localtime;
    Time: <%= $now->hms %>
  </div>
  EOF

  # Render with arguments
  say $mt->render(<<'EOF', [1 .. 13], 'Hello World!');
  % my ($numbers, $title) = @_;
  <div>
    <h1><%= $title %></h1>
    % for my $i (@$numbers) {
      Test <%= $i %>
    % }
  </div>
  EOF

  # Render with named variables
  say $mt->vars(1)->render(<<'EOF', {title => 'Hello World!'});
  <div>
    <h1><%= $title %></h1>
    %= 5 + 5
  </div>
  EOF

=head1 DESCRIPTION

L<Mojo::Template> is a minimalistic, fast, and very Perl-ish template engine, designed specifically for all those small
tasks that come up during big projects. Like preprocessing a configuration file, generating text from heredocs and
stuff like that.

See L<Mojolicious::Guides::Rendering> for information on how to generate content with the L<Mojolicious> renderer.

=head1 SYNTAX

For all templates L<strict>, L<warnings>, L<utf8> and Perl 5.16 L<features|feature> are automatically enabled.

  <% Perl code %>
  <%= Perl expression, replaced with result %>
  <%== Perl expression, replaced with XML escaped result %>
  <%# Comment, useful for debugging %>
  <%% Replaced with "<%", useful for generating templates %>
  % Perl code line, treated as "<% line =%>" (explained later)
  %= Perl expression line, treated as "<%= line %>"
  %== Perl expression line, treated as "<%== line %>"
  %# Comment line, useful for debugging
  %% Replaced with "%", useful for generating templates

Escaping behavior can be reversed with the L</"auto_escape"> attribute, this is the default in L<Mojolicious> C<.ep>
templates, for example.

  <%= Perl expression, replaced with XML escaped result %>
  <%== Perl expression, replaced with result %>

L<Mojo::ByteStream> objects are always excluded from automatic escaping.

  % use Mojo::ByteStream qw(b);
  <%= b('<div>excluded!</div>') %>

Whitespace characters around tags can be trimmed by adding an additional equal sign to the end of a tag.

  <% for (1 .. 3) { %>
    <%= 'Trim all whitespace characters around this expression' =%>
  <% } %>

Newline characters can be escaped with a backslash.

  This is <%= 1 + 1 %> a\
  single line

And a backslash in front of a newline character can be escaped with another backslash.

  This will <%= 1 + 1 %> result\\
  in multiple\\
  lines

A newline character gets appended automatically to every template, unless the last character is a backslash. And empty
lines at the end of a template are ignored.

  There is <%= 1 + 1 %> no newline at the end here\

You can capture whole template blocks for reuse later with the C<begin> and C<end> keywords. Just be aware that both
keywords are part of the surrounding tag and not actual Perl code, so there can only be whitespace after C<begin> and
before C<end>.

  <% my $block = begin %>
    <% my $name = shift; =%>
    Hello <%= $name %>.
  <% end %>
  <%= $block->('Baerbel') %>
  <%= $block->('Wolfgang') %>

Perl lines can also be indented freely.

  % my $block = begin
    % my $name = shift;
    Hello <%= $name %>.
  % end
  %= $block->('Baerbel')
  %= $block->('Wolfgang')

L<Mojo::Template> templates get compiled to a Perl subroutine, that means you can access arguments simply via C<@_>.

  % my ($foo, $bar) = @_;
  % my $x = shift;
  test 123 <%= $foo %>

The compilation of templates to Perl code can make debugging a bit tricky, but L<Mojo::Template> will return
L<Mojo::Exception> objects that stringify to error messages with context.

  Bareword "xx" not allowed while "strict subs" in use at template line 4.
  Context:
    2: </head>
    3: <body>
    4: % my $i = 2; xx
    5: %= $i * 2
    6: </body>
  Traceback (most recent call first):
    File "template", line 4, in "Mojo::Template::Sandbox"
    File "path/to/Mojo/Template.pm", line 123, in "Mojo::Template"
    File "path/to/myapp.pl", line 123, in "main"

=head1 ATTRIBUTES

L<Mojo::Template> implements the following attributes.

=head2 auto_escape

  my $bool = $mt->auto_escape;
  $mt      = $mt->auto_escape($bool);

Activate automatic escaping.

  # "&lt;html&gt;"
  Mojo::Template->new(auto_escape => 1)->render("<%= '<html>' %>");

=head2 append

  my $code = $mt->append;
  $mt      = $mt->append('warn "Processed template"');

Append Perl code to compiled template. Note that this code should not contain newline characters, or line numbers in
error messages might end up being wrong.

=head2 capture_end

  my $end = $mt->capture_end;
  $mt     = $mt->capture_end('end');

Keyword indicating the end of a capture block, defaults to C<end>.

  <% my $block = begin %>
    Some data!
  <% end %>

=head2 capture_start

  my $start = $mt->capture_start;
  $mt       = $mt->capture_start('begin');

Keyword indicating the start of a capture block, defaults to C<begin>.

  <% my $block = begin %>
    Some data!
  <% end %>

=head2 code

  my $code = $mt->code;
  $mt      = $mt->code($code);

Perl code for template if available.

=head2 comment_mark

  my $mark = $mt->comment_mark;
  $mt      = $mt->comment_mark('#');

Character indicating the start of a comment, defaults to C<#>.

  <%# This is a comment %>

=head2 compiled

  my $compiled = $mt->compiled;
  $mt          = $mt->compiled($compiled);

Compiled template code if available.

=head2 encoding

  my $encoding = $mt->encoding;
  $mt          = $mt->encoding('UTF-8');

Encoding used for template files, defaults to C<UTF-8>.

=head2 escape

  my $cb = $mt->escape;
  $mt    = $mt->escape(sub {...});

A callback used to escape the results of escaped expressions, defaults to L<Mojo::Util/"xml_escape">.

  $mt->escape(sub ($str) { return reverse $str });

=head2 escape_mark

  my $mark = $mt->escape_mark;
  $mt      = $mt->escape_mark('=');

Character indicating the start of an escaped expression, defaults to C<=>.

  <%== $foo %>

=head2 expression_mark

  my $mark = $mt->expression_mark;
  $mt      = $mt->expression_mark('=');

Character indicating the start of an expression, defaults to C<=>.

  <%= $foo %>

=head2 line_start

  my $start = $mt->line_start;
  $mt       = $mt->line_start('%');

Character indicating the start of a code line, defaults to C<%>.

  % $foo = 23;

=head2 name

  my $name = $mt->name;
  $mt      = $mt->name('foo.mt');

Name of template currently being processed, defaults to C<template>. Note that this value should not contain quotes or
newline characters, or error messages might end up being wrong.

=head2 namespace

  my $namespace = $mt->namespace;
  $mt           = $mt->namespace('main');

Namespace used to compile templates, defaults to C<Mojo::Template::Sandbox>. Note that namespaces should only be shared
very carefully between templates, since functions and global variables will not be cleared automatically.

=head2 prepend

  my $code = $mt->prepend;
  $mt      = $mt->prepend('my $self = shift;');

Prepend Perl code to compiled template. Note that this code should not contain newline characters, or line numbers in
error messages might end up being wrong.

=head2 replace_mark

  my $mark = $mt->replace_mark;
  $mt      = $mt->replace_mark('%');

Character used for escaping the start of a tag or line, defaults to C<%>.

  <%% my $foo = 23; %>

=head2 tag_start

  my $start = $mt->tag_start;
  $mt       = $mt->tag_start('<%');

Characters indicating the start of a tag, defaults to C<E<lt>%>.

  <% $foo = 23; %>

=head2 tag_end

  my $end = $mt->tag_end;
  $mt     = $mt->tag_end('%>');

Characters indicating the end of a tag, defaults to C<%E<gt>>.

  <%= $foo %>

=head2 tree

  my $tree = $mt->tree;
  $mt      = $mt->tree([['text', 'foo'], ['line']]);

Template in parsed form if available. Note that this structure should only be used very carefully since it is very
dynamic.

=head2 trim_mark

  my $mark = $mt->trim_mark;
  $mt      = $mt->trim_mark('-');

Character activating automatic whitespace trimming, defaults to C<=>.

  <%= $foo =%>

=head2 unparsed

  my $unparsed = $mt->unparsed;
  $mt          = $mt->unparsed('<%= 1 + 1 %>');

Raw unparsed template if available.

=head2 vars

  my $bool = $mt->vars;
  $mt      = $mt->vars($bool);

Instead of a list of values, use a hash reference with named variables to pass data to templates.

  # "works!"
  Mojo::Template->new(vars => 1)->render('<%= $test %>!', {test => 'works'});

=head1 METHODS

L<Mojo::Template> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 parse

  $mt = $mt->parse('<%= 1 + 1 %>');

Parse template into L</"tree">.

=head2 process

  my $output = $mt->process;
  my $output = $mt->process(@args);
  my $output = $mt->process({foo => 'bar'});

Process previously parsed template and return the result, or a L<Mojo::Exception> object if rendering failed.

  # Parse and process
  say Mojo::Template->new->parse('Hello <%= $_[0] %>')->process('Bender');

  # Reuse template (for much better performance)
  my $mt = Mojo::Template->new;
  say $mt->render('Hello <%= $_[0] %>!', 'Bender');
  say $mt->process('Fry');
  say $mt->process('Leela');

=head2 render

  my $output = $mt->render('<%= 1 + 1 %>');
  my $output = $mt->render('<%= shift() + shift() %>', @args);
  my $output = $mt->render('<%= $foo %>', {foo => 'bar'});

Render template and return the result, or a L<Mojo::Exception> object if rendering failed.

  # Longer version
  my $output = $mt->parse('<%= 1 + 1 %>')->process;

  # Render with arguments
  say Mojo::Template->new->render('<%= $_[0] %>', 'bar');

  # Render with named variables
  say Mojo::Template->new(vars => 1)->render('<%= $foo %>', {foo => 'bar'});

=head2 render_file

  my $output = $mt->render_file('/tmp/foo.mt');
  my $output = $mt->render_file('/tmp/foo.mt', @args);
  my $output = $mt->render_file('/tmp/bar.mt', {foo => 'bar'});

Same as L</"render">, but renders a template file.

=head1 DEBUGGING

You can set the C<MOJO_TEMPLATE_DEBUG> environment variable to get some advanced diagnostics information printed to
C<STDERR>.

  MOJO_TEMPLATE_DEBUG=1

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::WebSocket;
use Mojo::Base -strict;

use Config;
use Exporter   qw(import);
use Mojo::Util qw(b64_encode dumper sha1_bytes xor_encode);

use constant DEBUG => $ENV{MOJO_WEBSOCKET_DEBUG} || 0;

# Unique value from RFC 6455
use constant GUID => '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';

# Perl with support for quads
use constant MODERN => (($Config{use64bitint} // '') eq 'define' || $Config{longsize} >= 8);

# Opcodes
use constant {WS_CONTINUATION => 0x0, WS_TEXT => 0x1, WS_BINARY => 0x2, WS_CLOSE => 0x8, WS_PING => 0x9,
  WS_PONG => 0xa};

our @EXPORT_OK = (
  qw(WS_BINARY WS_CLOSE WS_CONTINUATION WS_PING WS_PONG WS_TEXT build_frame challenge client_handshake parse_frame),
  qw(server_handshake)
);

sub build_frame {
  my ($masked, $fin, $rsv1, $rsv2, $rsv3, $op, $payload) = @_;
  warn "-- Building frame ($fin, $rsv1, $rsv2, $rsv3, $op)\n" if DEBUG;

  # Head
  my $head = $op + ($fin ? 128 : 0);
  $head |= 0b01000000 if $rsv1;
  $head |= 0b00100000 if $rsv2;
  $head |= 0b00010000 if $rsv3;
  my $frame = pack 'C', $head;

  # Small payload
  my $len = length $payload;
  if ($len < 126) {
    warn "-- Small payload ($len)\n@{[dumper $payload]}" if DEBUG;
    $frame .= pack 'C', $masked ? ($len | 128) : $len;
  }

  # Extended payload (16-bit)
  elsif ($len < 65536) {
    warn "-- Extended 16-bit payload ($len)\n@{[dumper $payload]}" if DEBUG;
    $frame .= pack 'Cn', $masked ? (126 | 128) : 126, $len;
  }

  # Extended payload (64-bit with 32-bit fallback)
  else {
    warn "-- Extended 64-bit payload ($len)\n@{[dumper $payload]}" if DEBUG;
    $frame .= pack 'C', $masked ? (127 | 128) : 127;
    $frame .= MODERN ? pack('Q>', $len) : pack('NN', 0, $len & 0xffffffff);
  }

  # Mask payload
  if ($masked) {
    my $mask = pack 'N', int(rand 9 x 7);
    $payload = $mask . xor_encode($payload, $mask x 128);
  }

  return $frame . $payload;
}

sub challenge {
  my $tx = shift;

  # "permessage-deflate" extension
  my $headers = $tx->res->headers;
  $tx->compressed(1) if ($headers->sec_websocket_extensions // '') =~ /permessage-deflate/;

  return _challenge($tx->req->headers->sec_websocket_key) eq $headers->sec_websocket_accept;
}

sub client_handshake {
  my $tx = shift;

  my $headers = $tx->req->headers;
  $headers->upgrade('websocket')      unless $headers->upgrade;
  $headers->connection('Upgrade')     unless $headers->connection;
  $headers->sec_websocket_version(13) unless $headers->sec_websocket_version;

  # Generate 16 byte WebSocket challenge
  my $challenge = b64_encode sprintf('%16u', int(rand 9 x 16)), '';
  $headers->sec_websocket_key($challenge) unless $headers->sec_websocket_key;

  return $tx;
}

sub parse_frame {
  my ($buffer, $max) = @_;

  # Head
  return undef unless length $$buffer >= 2;
  my ($first, $second) = unpack 'C2', $$buffer;

  # FIN
  my $fin = ($first & 0b10000000) == 0b10000000 ? 1 : 0;

  # RSV1-3
  my $rsv1 = ($first & 0b01000000) == 0b01000000 ? 1 : 0;
  my $rsv2 = ($first & 0b00100000) == 0b00100000 ? 1 : 0;
  my $rsv3 = ($first & 0b00010000) == 0b00010000 ? 1 : 0;

  # Opcode
  my $op = $first & 0b00001111;
  warn "-- Parsing frame ($fin, $rsv1, $rsv2, $rsv3, $op)\n" if DEBUG;

  # Small payload
  my ($hlen, $len) = (2, $second & 0b01111111);
  if ($len < 126) { warn "-- Small payload ($len)\n" if DEBUG }

  # Extended payload (16-bit)
  elsif ($len == 126) {
    return undef unless length $$buffer > 4;
    $hlen = 4;
    $len  = unpack 'x2n', $$buffer;
    warn "-- Extended 16-bit payload ($len)\n" if DEBUG;
  }

  # Extended payload (64-bit with 32-bit fallback)
  elsif ($len == 127) {
    return undef unless length $$buffer > 10;
    $hlen = 10;
    $len  = MODERN ? unpack('x2Q>', $$buffer) : unpack('x2x4N', $$buffer);
    warn "-- Extended 64-bit payload ($len)\n" if DEBUG;
  }

  # Check message size
  return 1 if $len > $max;

  # Check if whole packet has arrived
  $len += 4 if my $masked = $second & 0b10000000;
  return undef if length $$buffer < ($hlen + $len);
  substr $$buffer, 0, $hlen, '';

  # Payload
  my $payload = $len ? substr($$buffer, 0, $len, '') : '';
  $payload = xor_encode($payload, substr($payload, 0, 4, '') x 128) if $masked;
  warn dumper $payload if DEBUG;

  return [$fin, $rsv1, $rsv2, $rsv3, $op, $payload];
}

sub server_handshake {
  my $tx = shift;

  my $headers = $tx->res->headers;
  $headers->upgrade('websocket')->connection('Upgrade');
  $headers->sec_websocket_accept(_challenge($tx->req->headers->sec_websocket_key));

  return $tx;
}

sub _challenge { b64_encode(sha1_bytes(($_[0] || '') . GUID), '') }

1;

=encoding utf8

=head1 NAME

Mojo::WebSocket - The WebSocket protocol

=head1 SYNOPSIS

  use Mojo::WebSocket qw(WS_TEXT build_frame parse_frame);

  my $bytes = build_frame 0, 1, 0, 0, 0, WS_TEXT, 'Hello World!';
  my $frame = parse_frame \$bytes, 262144;

=head1 DESCRIPTION

L<Mojo::WebSocket> implements the WebSocket protocol as described in L<RFC 6455|https://tools.ietf.org/html/rfc6455>.
Note that 64-bit frames require a Perl with support for quads or they are limited to 32-bit.

=head1 FUNCTIONS

L<Mojo::WebSocket> implements the following functions, which can be imported individually.

=head2 build_frame

  my $bytes = build_frame $masked, $fin, $rsv1, $rsv2, $rsv3, $op, $payload;

Build WebSocket frame.

  # Masked binary frame with FIN bit and payload
  say build_frame 1, 1, 0, 0, 0, WS_BINARY, 'Hello World!';

  # Text frame with payload but without FIN bit
  say build_frame 0, 0, 0, 0, 0, WS_TEXT, 'Hello ';

  # Continuation frame with FIN bit and payload
  say build_frame 0, 1, 0, 0, 0, WS_CONTINUATION, 'World!';

  # Close frame with FIN bit and without payload
  say build_frame 0, 1, 0, 0, 0, WS_CLOSE, '';

  # Ping frame with FIN bit and payload
  say build_frame 0, 1, 0, 0, 0, WS_PING, 'Test 123';

  # Pong frame with FIN bit and payload
  say build_frame 0, 1, 0, 0, 0, WS_PONG, 'Test 123';

=head2 challenge

  my $bool = challenge Mojo::Transaction::WebSocket->new;

Check WebSocket handshake challenge.

=head2 client_handshake

  my $tx = client_handshake Mojo::Transaction::HTTP->new;

Perform WebSocket handshake client-side.

=head2 parse_frame

  my $frame = parse_frame \$bytes, $limit;

Parse WebSocket frame.

  # Parse single frame and remove it from buffer
  my $frame = parse_frame \$buffer, 262144;
  say "FIN: $frame->[0]";
  say "RSV1: $frame->[1]";
  say "RSV2: $frame->[2]";
  say "RSV3: $frame->[3]";
  say "Opcode: $frame->[4]";
  say "Payload: $frame->[5]";

=head2 server_handshake

  my $tx = server_handshake Mojo::Transaction::HTTP->new;

Perform WebSocket handshake server-side.

=head1 CONSTANTS

L<Mojo::WebSocket> implements the following constants, which can be imported individually.

=head2 WS_BINARY

Opcode for C<Binary> frames.

=head2 WS_CLOSE

Opcode for C<Close> frames.

=head2 WS_CONTINUATION

Opcode for C<Continuation> frames.

=head2 WS_PING

Opcode for C<Ping> frames.

=head2 WS_PONG

Opcode for C<Pong> frames.

=head2 WS_TEXT

Opcode for C<Text> frames.

=head1 DEBUGGING

You can set the C<MOJO_WEBSOCKET_DEBUG> environment variable to get some advanced diagnostics information printed to
C<STDERR>.

  MOJO_WEBSOCKET_DEBUG=1

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Server::Hypnotoad;
use Mojo::Base -base;

# "Bender: I was God once.
#  God: Yes, I saw. You were doing well, until everyone died."
use Config;
use Mojo::File qw(path);
use Mojo::Server::Prefork;
use Mojo::Util   qw(steady_time);
use Scalar::Util qw(weaken);

has prefork         => sub { Mojo::Server::Prefork->new(listen => ['http://*:8080']) };
has upgrade_timeout => 180;

sub configure {
  my ($self, $name) = @_;

  # Hypnotoad settings
  my $prefork = $self->prefork;
  my $c       = $prefork->app->config($name) // {};
  $self->upgrade_timeout($c->{upgrade_timeout}) if $c->{upgrade_timeout};

  # Pre-fork settings
  $prefork->reverse_proxy($c->{proxy})             if defined $c->{proxy};
  $prefork->trusted_proxies($c->{trusted_proxies}) if defined $c->{trusted_proxies};
  $prefork->max_clients($c->{clients})             if $c->{clients};
  $prefork->max_requests($c->{requests})           if $c->{requests};
  defined $c->{$_} and $prefork->$_($c->{$_})
    for qw(accepts backlog graceful_timeout heartbeat_interval heartbeat_timeout inactivity_timeout keep_alive_timeout),
    qw(listen pid_file spare workers);
}

sub run {
  my ($self, $app) = @_;

  # No fork emulation support
  _exit('Hypnotoad does not support fork emulation.') if $Config{d_pseudofork};

  # Remember executable and application for later
  $ENV{HYPNOTOAD_EXE} ||= $0;
  $0 = $ENV{HYPNOTOAD_APP} ||= path($app)->to_abs->to_string;

  # This is a production server
  $ENV{MOJO_MODE} ||= 'production';

  # Clean start (to make sure everything works)
  die "Can't exec: $!" if !$ENV{HYPNOTOAD_REV}++ && !exec $^X, $ENV{HYPNOTOAD_EXE};

  # Preload application and configure server
  my $prefork = $self->prefork->cleanup(0);
  $app = $prefork->load_app($app);
  $app->config->{hypnotoad}{pid_file} //= path($ENV{HYPNOTOAD_APP})->sibling('hypnotoad.pid')->to_string;
  $self->configure('hypnotoad');
  weaken $self;
  $prefork->on(wait   => sub { $self->_manage });
  $prefork->on(reap   => sub { $self->_cleanup(pop) });
  $prefork->on(finish => sub { $self->_finish });

  # Testing
  _exit('Everything looks good!') if $ENV{HYPNOTOAD_TEST};

  # Stop running server
  $self->_stop if $ENV{HYPNOTOAD_STOP};

  # Initiate hot deployment
  $self->_hot_deploy unless $ENV{HYPNOTOAD_PID};

  # Daemonize as early as possible (but not for restarts)
  local $SIG{USR2} = sub { $self->{upgrade} ||= steady_time };
  $prefork->start;
  $prefork->daemonize if !$ENV{HYPNOTOAD_FOREGROUND} && $ENV{HYPNOTOAD_REV} < 3;

  # Start accepting connections
  $prefork->cleanup(1)->run;
}

sub _cleanup {
  my ($self, $pid) = @_;

  # Clean up failed upgrade
  return unless ($self->{new} || '') eq $pid;
  $self->prefork->app->log->error('Zero downtime software upgrade failed');
  delete @$self{qw(new upgrade)};
}

sub _exit { say shift and exit 0 }

sub _finish {
  my $self = shift;

  $self->{finish} = 1;
  return unless my $new = $self->{new};

  my $prefork = $self->prefork->cleanup(0);
  path($prefork->pid_file)->remove;
  $prefork->ensure_pid_file($new);
}

sub _hot_deploy {

  # Make sure server is running
  return unless my $pid = shift->prefork->check_pid;

  # Start hot deployment
  kill 'USR2', $pid;
  _exit("Starting hot deployment for Hypnotoad server $pid.");
}

sub _manage {
  my $self = shift;

  # Upgraded (wait for all workers to send a heartbeat)
  my $prefork = $self->prefork;
  my $log     = $prefork->app->log;
  if ($ENV{HYPNOTOAD_PID} && $ENV{HYPNOTOAD_PID} ne $$) {
    return unless $prefork->healthy == $prefork->workers;
    $log->info("Upgrade successful, stopping $ENV{HYPNOTOAD_PID}");
    kill 'QUIT', $ENV{HYPNOTOAD_PID};
  }
  $ENV{HYPNOTOAD_PID} = $$ unless ($ENV{HYPNOTOAD_PID} // '') eq $$;

  # Upgrade
  if ($self->{upgrade} && !$self->{finished}) {

    # Fresh start
    my $ut = $self->upgrade_timeout;
    unless ($self->{new}) {
      $log->info("Starting zero downtime software upgrade ($ut seconds)");
      die "Can't fork: $!" unless defined(my $pid = $self->{new} = fork);
      exec $^X, $ENV{HYPNOTOAD_EXE} or die "Can't exec: $!" unless $pid;
    }

    # Timeout
    kill 'KILL', $self->{new} if $self->{upgrade} + $ut <= steady_time;
  }
}

sub _stop {
  _exit('Hypnotoad server not running.') unless my $pid = shift->prefork->check_pid;
  kill 'QUIT', $pid;
  _exit("Stopping Hypnotoad server $pid gracefully.");
}

1;

=encoding utf8

=head1 NAME

Mojo::Server::Hypnotoad - A production web serv...ALL GLORY TO THE HYPNOTOAD!

=head1 SYNOPSIS

  use Mojo::Server::Hypnotoad;

  my $hypnotoad = Mojo::Server::Hypnotoad->new;
  $hypnotoad->run('/home/sri/myapp.pl');

=head1 DESCRIPTION

L<Mojo::Server::Hypnotoad> is a full featured, UNIX optimized, pre-forking non-blocking I/O HTTP and WebSocket server,
built around the very well tested and reliable L<Mojo::Server::Prefork>, with IPv6, TLS, SNI, UNIX domain socket, Comet
(long polling), keep-alive, multiple event loop and hot deployment support that just works. Note that the server uses
signals for process management, so you should avoid modifying signal handlers in your applications.

To start applications with it you can use the L<hypnotoad> script, which listens on port C<8080>, automatically
daemonizes the server process and defaults to C<production> mode for L<Mojolicious> and L<Mojolicious::Lite>
applications.

  $ hypnotoad ./myapp.pl

You can run the same command again for automatic hot deployment.

  $ hypnotoad ./myapp.pl
  Starting hot deployment for Hypnotoad server 31841.

This second invocation will load the application again, detect the process id file with it, and send a L</"USR2">
signal to the already running server.

For better scalability (epoll, kqueue) and to provide non-blocking name resolution, SOCKS5 as well as TLS support, the
optional modules L<EV> (4.32+), L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and L<IO::Socket::SSL>
(2.009+) will be used automatically if possible. Individual features can also be disabled with the C<MOJO_NO_NNR>,
C<MOJO_NO_SOCKS> and C<MOJO_NO_TLS> environment variables.

See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.

=head1 MANAGER SIGNALS

The L<Mojo::Server::Hypnotoad> manager process can be controlled at runtime with the following signals.

=head2 INT, TERM

Shut down server immediately.

=head2 QUIT

Shut down server gracefully.

=head2 TTIN

Increase worker pool by one.

=head2 TTOU

Decrease worker pool by one.

=head2 USR2

Attempt zero downtime software upgrade (hot deployment) without losing any incoming connections.

  Manager (old)
  |- Worker [1]
  |- Worker [2]
  |- Worker [3]
  |- Worker [4]
  +- Manager (new)
     |- Worker [1]
     |- Worker [2]
     |- Worker [3]
     +- Worker [4]

The new manager will automatically send a L</"QUIT"> signal to the old manager and take over serving requests after
starting up successfully.

=head1 WORKER SIGNALS

L<Mojo::Server::Hypnotoad> worker processes can be controlled at runtime with the following signals.

=head2 QUIT

Stop worker gracefully.

=head1 SETTINGS

L<Mojo::Server::Hypnotoad> can be configured with the following settings, see
L<Mojolicious::Guides::Cookbook/"Hypnotoad"> for examples.

=head2 accepts

  accepts => 100

Maximum number of connections a worker is allowed to accept, before stopping gracefully and then getting replaced with
a newly started worker, defaults to the value of L<Mojo::Server::Prefork/"accepts">. Setting the value to C<0> will
allow workers to accept new connections indefinitely. Note that up to half of this value can be subtracted randomly to
improve load balancing, and to make sure that not all workers restart at the same time.

=head2 backlog

  backlog => 128

Listen backlog size, defaults to the value of L<Mojo::Server::Daemon/"backlog">.

=head2 clients

  clients => 100

Maximum number of accepted connections each worker process is allowed to handle concurrently, before stopping to accept
new incoming connections, defaults to the value of L<Mojo::IOLoop/"max_connections">. Note that high concurrency works
best with applications that perform mostly non-blocking operations, to optimize for blocking operations you can
decrease this value and increase L</"workers"> instead for better performance.

=head2 graceful_timeout

  graceful_timeout => 15

Maximum amount of time in seconds stopping a worker gracefully may take before being forced, defaults to the value of
L<Mojo::Server::Prefork/"graceful_timeout">. Note that this value should usually be a little larger than the maximum
amount of time you expect any one request to take.

=head2 heartbeat_interval

  heartbeat_interval => 3

Heartbeat interval in seconds, defaults to the value of L<Mojo::Server::Prefork/"heartbeat_interval">.

=head2 heartbeat_timeout

  heartbeat_timeout => 2

Maximum amount of time in seconds before a worker without a heartbeat will be stopped gracefully, defaults to the value
of L<Mojo::Server::Prefork/"heartbeat_timeout">. Note that this value should usually be a little larger than the
maximum amount of time you expect any one operation to block the event loop.

=head2 inactivity_timeout

  inactivity_timeout => 10

Maximum amount of time in seconds a connection with an active request can be inactive before getting closed, defaults
to the value of L<Mojo::Server::Daemon/"inactivity_timeout">. Setting the value to C<0> will allow connections to be
inactive indefinitely.

=head2 keep_alive_timeout

  keep_alive_timeout => 10

Maximum amount of time in seconds a connection without an active request can be inactive before getting closed,
defaults to the value of L<Mojo::Server::Daemon/"keep_alive_timeout">. Setting the value to C<0> will allow connections
to be inactive indefinitely.

=head2 listen

  listen => ['http://*:80']

Array reference with one or more locations to listen on, defaults to C<http://*:8080>. See also
L<Mojo::Server::Daemon/"listen"> for more examples.

=head2 pid_file

  pid_file => '/var/run/hypnotoad.pid'

Full path to process id file, defaults to C<hypnotoad.pid> in the same directory as the application. Note that this
value can only be changed after the server has been stopped.

=head2 proxy

  proxy => 1

Activate reverse proxy support, which allows for the C<X-Forwarded-For> and C<X-Forwarded-Proto> headers to be picked
up automatically, defaults to the value of L<Mojo::Server/"reverse_proxy">.

=head2 requests

  requests => 50

Number of keep-alive requests per connection, defaults to the value of L<Mojo::Server::Daemon/"max_requests">.

=head2 spare

  spare => 4

Temporarily spawn up to this number of additional workers if there is a need, defaults to the value of
L<Mojo::Server::Prefork/"spare">. This allows for new workers to be started while old ones are still shutting down
gracefully, drastically reducing the performance cost of worker restarts.

=head2 trusted_proxies

  trusted_proxies => ['10.0.0.0/8', '127.0.0.1', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']

Trusted reverse proxies, addresses or networks in CIDR form.

=head2 upgrade_timeout

  upgrade_timeout => 45

Maximum amount of time in seconds a zero downtime software upgrade may take before getting canceled, defaults to
C<180>.

=head2 workers

  workers => 10

Number of worker processes, defaults to the value of L<Mojo::Server::Prefork/"workers">. A good rule of thumb is two
worker processes per CPU core for applications that perform mostly non-blocking operations, blocking operations often
require more and benefit from decreasing concurrency with L</"clients"> (often as low as C<1>). Note that during zero
downtime software upgrades there will be twice as many workers active for a short amount of time.

=head1 ATTRIBUTES

L<Mojo::Server::Hypnotoad> implements the following attributes.

=head2 prefork

  my $prefork = $hypnotoad->prefork;
  $hypnotoad  = $hypnotoad->prefork(Mojo::Server::Prefork->new);

L<Mojo::Server::Prefork> object this server manages.

=head2 upgrade_timeout

  my $timeout = $hypnotoad->upgrade_timeout;
  $hypnotoad  = $hypnotoad->upgrade_timeout(15);

Maximum amount of time in seconds a zero downtime software upgrade may take before getting canceled, defaults to
C<180>.

=head1 METHODS

L<Mojo::Server::Hypnotoad> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 configure

  $hypnotoad->configure('hypnotoad');

Configure server from application settings.

=head2 run

  $hypnotoad->run('script/my_app');

Run server for application and wait for L</"MANAGER SIGNALS">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Server::PSGI;
use Mojo::Base 'Mojo::Server';

sub run {
  my ($self, $env) = @_;

  my $tx  = $self->build_tx;
  my $req = $tx->req->parse($env);
  $tx->local_port($env->{SERVER_PORT})->remote_address($env->{REMOTE_ADDR});

  # Request body (may block if we try to read too much)
  my $len = $env->{CONTENT_LENGTH};
  until ($req->is_finished) {
    my $chunk = ($len && $len < 131072) ? $len : 131072;
    last unless my $read = $env->{'psgi.input'}->read(my $buffer, $chunk, 0);
    $req->parse($buffer);
    last if ($len -= $read) <= 0;
  }

  $self->emit(request => $tx);

  # Response headers
  my $res  = $tx->res->fix_headers;
  my $hash = $res->headers->to_hash(1);
  my @headers;
  for my $name (keys %$hash) { push @headers, $name, $_ for @{$hash->{$name}} }

  # PSGI response
  my $io = Mojo::Server::PSGI::_IO->new(tx => $tx, empty => $tx->is_empty);
  return [$res->code // 404, \@headers, $io];
}

sub to_psgi_app {
  my $self = shift;

  # Preload application and wrap it
  $self->app->server($self);
  return sub { $self->run(@_) }
}

package Mojo::Server::PSGI::_IO;
use Mojo::Base -base;

# Finish transaction
sub close { shift->{tx}->closed }

sub getline {
  my $self = shift;

  # Empty
  return undef if $self->{empty};

  # No content yet, try again later
  my $chunk = $self->{tx}->res->get_body_chunk($self->{offset} //= 0);
  return '' unless defined $chunk;

  # End of content
  return undef unless length $chunk;

  $self->{offset} += length $chunk;
  return $chunk;
}

1;

=encoding utf8

=head1 NAME

Mojo::Server::PSGI - PSGI server

=head1 SYNOPSIS

  use Mojo::Server::PSGI;

  my $psgi = Mojo::Server::PSGI->new;
  $psgi->unsubscribe('request')->on(request => sub ($psgi, $tx) {

    # Request
    my $method = $tx->req->method;
    my $path   = $tx->req->url->path;

    # Response
    $tx->res->code(200);
    $tx->res->headers->content_type('text/plain');
    $tx->res->body("$method request for $path!");

    # Resume transaction
    $tx->resume;
  });
  my $app = $psgi->to_psgi_app;

=head1 DESCRIPTION

L<Mojo::Server::PSGI> allows L<Mojolicious> applications to run on all L<PSGI> compatible servers.

See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.

=head1 EVENTS

L<Mojo::Server::PSGI> inherits all events from L<Mojo::Server>.

=head1 ATTRIBUTES

L<Mojo::Server::PSGI> inherits all attributes from L<Mojo::Server>.

=head1 METHODS

L<Mojo::Server::PSGI> inherits all methods from L<Mojo::Server> and implements the following new ones.

=head2 run

  my $res = $psgi->run($env);

Run L<PSGI>.

=head2 to_psgi_app

  my $app = $psgi->to_psgi_app;

Turn L<Mojolicious> application into L<PSGI> application.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Server::Morbo::Backend::Poll;
use Mojo::Base 'Mojo::Server::Morbo::Backend';

use Mojo::File qw(path);

sub modified_files {
  my $self = shift;

  my $cache = $self->{cache} //= {};
  my @files;
  for my $file (map { -f $_ && -r _ ? $_ : _list($_) } @{$self->watch}) {
    my ($size, $mtime) = (stat $file)[7, 9];
    next unless defined $size and defined $mtime;
    my $stats = $cache->{$file} ||= [$^T, $size];
    next if $mtime <= $stats->[0] && $size == $stats->[1];
    @$stats = ($mtime, $size);
    push @files, $file;
  }
  sleep $self->watch_timeout unless @files;

  return \@files;
}

sub _list { path(shift)->list_tree->map('to_string')->each }

1;

=encoding utf8

=head1 NAME

Mojo::Server::Morbo::Backend::Poll - Morbo default backend

=head1 SYNOPSIS

  use Mojo::Server::Morbo::Backend::Poll;

  my $backend = Mojo::Server::Morbo::Backend::Poll->new;
  if (my $files = $backend->modified_files) {
    ...
  }

=head1 DESCRIPTION

L<Mojo::Server::Morbo::Backend::Poll> is the default backend for L<Mojo::Server::Morbo>.

=head1 ATTRIBUTES

L<Mojo::Server::Morbo::Backend::Poll> inherits all attributes from L<Mojo::Server::Morbo::Backend>.

=head1 METHODS

L<Mojo::Server::Morbo::Backend::Poll> inherits all methods from L<Mojo::Server::Morbo::Backend> and implements the
following new ones.

=head2 modified_files

  my $files = $backend->modified_files;

Check file size and mtime to determine which files have changed, this is not particularly efficient, but very portable.

  # All files that have been modified
  say for @{$backend->modified_files};

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Server::Morbo::Backend;
use Mojo::Base -base;

use Carp qw(croak);

has watch         => sub { [qw(lib templates)] };
has watch_timeout => sub { $ENV{MOJO_MORBO_TIMEOUT} || 1 };

sub modified_files { croak 'Method "modified_files" not implemented by subclass' }

1;

=encoding utf8

=head1 NAME

Mojo::Server::Morbo::Backend - Morbo backend base class

=head1 SYNOPSIS

  package Mojo::Server::Morbo::Backend::Inotify:
  use Mojo::Base 'Mojo::Server::Morbo::Backend';

  sub modified_files {...}

=head1 DESCRIPTION

L<Mojo::Server::Morbo::Backend> is an abstract base class for Morbo backends, like
L<Mojo::Server::Morbo::Backend::Poll>.

=head1 ATTRIBUTES

L<Mojo::Server::Morbo::Backend> implements the following attributes.

=head2 watch

  my $watch = $backend->watch;
  $backend  = $backend->watch(['/home/sri/my_app']);

Files and directories to watch for changes, defaults to the application script as well as the C<lib> and C<templates>
directories in the current working directory.

=head2 watch_timeout

  my $timeout = $backend->watch_timeout;
  $backend    = $backend->watch_timeout(10);

Maximum amount of time in seconds a backend may block when waiting for files to change, defaults to the value of the
C<MOJO_MORBO_TIMEOUT> environment variable or C<1>.

=head1 METHODS

L<Mojo::Server::Morbo::Backend> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 modified_files

  my $files = $backend->modified_files;

Check if files from L</"watch"> have been modified since the last check and return an array reference with the results.
Meant to be overloaded in a subclass.

  # All files that have been modified
  say for @{$backend->modified_files};

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Server::Daemon;
use Mojo::Base 'Mojo::Server';

use Carp qw(croak);
use Mojo::IOLoop;
use Mojo::Transaction::WebSocket;
use Mojo::URL;
use Mojo::Util      qw(term_escape);
use Mojo::WebSocket qw(server_handshake);
use Scalar::Util    qw(weaken);

use constant DEBUG => $ENV{MOJO_SERVER_DEBUG} || 0;

has acceptors => sub { [] };
has [qw(backlog max_clients silent)];
has inactivity_timeout => sub { $ENV{MOJO_INACTIVITY_TIMEOUT} // 30 };
has ioloop             => sub { Mojo::IOLoop->singleton };
has keep_alive_timeout => sub { $ENV{MOJO_KEEP_ALIVE_TIMEOUT} // 5 };
has listen             => sub { [split /,/, $ENV{MOJO_LISTEN} || 'http://*:3000'] };
has max_requests       => 100;

sub DESTROY {
  my $self = shift;
  return if ${^GLOBAL_PHASE} eq 'DESTRUCT';
  my $loop = $self->ioloop;
  $loop->remove($_) for keys %{$self->{connections} // {}}, @{$self->acceptors};
}

sub ports { [map { $_[0]->ioloop->acceptor($_)->port } @{$_[0]->acceptors}] }

sub run {
  my $self = shift;

  # Make sure the event loop can be stopped in regular intervals
  my $loop = $self->ioloop;
  my $int  = $loop->recurring(1 => sub { });
  local $SIG{INT} = local $SIG{TERM} = sub { $loop->stop };
  $self->start->ioloop->start;
  $loop->remove($int);
}

sub start {
  my $self = shift;

  my $loop = $self->ioloop;
  if (my $max = $self->max_clients) { $loop->max_connections($max) }

  # Resume accepting connections
  if (my $servers = $self->{servers}) {
    push @{$self->acceptors}, $loop->acceptor(delete $servers->{$_}) for keys %$servers;
  }

  # Start listening
  elsif (!@{$self->acceptors}) {
    $self->app->server($self);
    $self->_listen($_) for @{$self->listen};
  }

  return $self;
}

sub stop {
  my $self = shift;

  # Suspend accepting connections but keep listen sockets open
  my $loop = $self->ioloop;
  while (my $id = shift @{$self->acceptors}) {
    my $server = $self->{servers}{$id} = $loop->acceptor($id);
    $loop->remove($id);
    $server->stop;
  }

  return $self;
}

sub _build_tx {
  my ($self, $id, $c) = @_;

  my $tx = $self->build_tx->connection($id);
  $tx->res->headers->server('Mojolicious (Perl)');
  my $handle = $self->ioloop->stream($id)->timeout($self->inactivity_timeout)->handle;
  unless ($handle->isa('IO::Socket::UNIX')) {
    $tx->local_address($handle->sockhost)->local_port($handle->sockport);
    $tx->remote_address($handle->peerhost)->remote_port($handle->peerport);
  }
  $tx->req->url->base->scheme('https') if $c->{tls};

  weaken $self;
  $tx->on(
    request => sub {
      my $tx = shift;

      my $req = $tx->req;
      if (my $error = $req->error) { $self->_trace($id, $error->{message}) }

      # WebSocket
      if ($req->is_handshake) {
        my $ws = $self->{connections}{$id}{next} = Mojo::Transaction::WebSocket->new(handshake => $tx);
        $self->emit(request => server_handshake $ws);
      }

      # HTTP
      else { $self->emit(request => $tx) }

      # Last keep-alive request or corrupted connection
      my $c = $self->{connections}{$id};
      $tx->res->headers->connection('close') if ($c->{requests} || 1) >= $self->max_requests || $req->error;

      $tx->on(resume => sub { $self->_write($id) });
      $self->_write($id);
    }
  );

  # Kept alive if we have more than one request on the connection
  return ++$c->{requests} > 1 ? $tx->kept_alive(1) : $tx;
}

sub _close {
  my ($self, $id) = @_;
  if (my $tx = $self->{connections}{$id}{tx}) { $tx->closed }
  delete $self->{connections}{$id};
}

sub _trace { $_[0]->app->log->trace($_[2]) if $_[0]{connections}{$_[1]}{tx} }

sub _finish {
  my ($self, $id) = @_;

  # Always remove connection for WebSockets
  my $c = $self->{connections}{$id};
  return unless my $tx = $c->{tx};
  return $self->_remove($id) if $tx->is_websocket;

  # Finish transaction
  delete($c->{tx})->closed;

  # Upgrade connection to WebSocket
  if (my $ws = delete $c->{next}) {

    # Successful upgrade
    if ($ws->handshake->res->code == 101) {
      $c->{tx} = $ws->established(1);
      weaken $self;
      $ws->on(resume => sub { $self->_write($id) });
      $self->_write($id);
    }

    # Failed upgrade
    else { $ws->closed }
  }

  # Close connection if necessary
  return $self->_remove($id) if $tx->error || !$tx->keep_alive;

  # Build new transaction for leftovers
  if (length(my $leftovers = $tx->req->content->leftovers)) {
    $tx = $c->{tx} = $self->_build_tx($id, $c);
    $tx->server_read($leftovers);
  }

  # Keep-alive connection
  $self->ioloop->stream($id)->timeout($self->keep_alive_timeout) unless $c->{tx};
}

sub _listen {
  my ($self, $listen) = @_;

  my $url   = Mojo::URL->new($listen);
  my $proto = $url->protocol;
  croak qq{Invalid listen location "$listen"} unless $proto eq 'http' || $proto eq 'https' || $proto eq 'http+unix';

  my $query   = $url->query;
  my $options = {backlog => $self->backlog};
  $options->{$_} = $query->param($_) for qw(fd single_accept reuse);
  if ($proto eq 'http+unix') { $options->{path} = $url->host }
  else {
    if ((my $host = $url->host) ne '*') { $options->{address} = $host }
    if (my $port = $url->port) { $options->{port} = $port }
  }

  $options->{tls_ca} = $query->param('ca');
  /^(.*)_(cert|key)$/ and $options->{"tls_$2"}{$1} = $query->param($_) for @{$query->names};
  if (my $cert = $query->param('cert')) { $options->{tls_cert}{''} = $cert }
  if (my $key  = $query->param('key'))  { $options->{tls_key}{''}  = $key }
  my ($ciphers, $verify, $version) = ($query->param('ciphers'), $query->param('verify'), $query->param('version'));
  $options->{tls_options}{SSL_cipher_list} = $ciphers    if defined $ciphers;
  $options->{tls_options}{SSL_verify_mode} = hex $verify if defined $verify;
  $options->{tls_options}{SSL_version}     = $version    if defined $version;
  my $tls = $options->{tls} = $proto eq 'https';

  weaken $self;
  push @{$self->acceptors}, $self->ioloop->server(
    $options => sub {
      my ($loop, $stream, $id) = @_;

      $self->{connections}{$id} = {tls => $tls};
      warn "-- Accept $id (@{[_peer($stream->handle)]})\n" if DEBUG;
      $stream->timeout($self->inactivity_timeout);

      $stream->on(close   => sub { $self && $self->_close($id) });
      $stream->on(error   => sub { $self && $self->app->log->error(pop) && $self->_close($id) });
      $stream->on(read    => sub { $self->_read($id => pop) });
      $stream->on(timeout => sub { $self->_trace($id, 'Inactivity timeout (see FAQ for more)') });
    }
  );

  return if $self->silent;
  $self->app->log->info(qq{Listening at "$url"});
  $query->pairs([]);
  $url->host('127.0.0.1')        if $url->host eq '*';
  $url->port($self->ports->[-1]) if !$options->{path} && !$url->port;
  say 'Web application available at ', $options->{path} // $url;
}

sub _peer { $_[0]->isa('IO::Socket::UNIX') ? $_[0]->peerpath : $_[0]->peerhost }

sub _read {
  my ($self, $id, $chunk) = @_;

  # Make sure we have a transaction
  my $c  = $self->{connections}{$id};
  my $tx = $c->{tx} ||= $self->_build_tx($id, $c);
  warn term_escape "-- Server <<< Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
  $tx->server_read($chunk);
}

sub _remove {
  my ($self, $id) = @_;
  $self->ioloop->remove($id);
  $self->_close($id);
}

sub _url { shift->req->url->to_abs }

sub _write {
  my ($self, $id) = @_;

  # Protect from resume event recursion
  my $c = $self->{connections}{$id};
  return if !(my $tx = $c->{tx}) || $c->{writing};
  local $c->{writing} = 1;
  my $chunk = $tx->server_write;
  warn term_escape "-- Server >>> Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
  my $next = $tx->is_finished ? '_finish' : length $chunk ? '_write' : undef;
  return $self->ioloop->stream($id)->write($chunk) unless $next;
  weaken $self;
  $self->ioloop->stream($id)->write($chunk => sub { $self->$next($id) });
}

1;

=encoding utf8

=head1 NAME

Mojo::Server::Daemon - Non-blocking I/O HTTP and WebSocket server

=head1 SYNOPSIS

  use Mojo::Server::Daemon;

  my $daemon = Mojo::Server::Daemon->new(listen => ['http://*:8080']);
  $daemon->unsubscribe('request')->on(request => sub ($daemon, $tx) {

    # Request
    my $method = $tx->req->method;
    my $path   = $tx->req->url->path;

    # Response
    $tx->res->code(200);
    $tx->res->headers->content_type('text/plain');
    $tx->res->body("$method request for $path!");

    # Resume transaction
    $tx->resume;
  });
  $daemon->run;

=head1 DESCRIPTION

L<Mojo::Server::Daemon> is a full featured, highly portable non-blocking I/O HTTP and WebSocket server, with IPv6, TLS,
SNI, Comet (long polling), keep-alive and multiple event loop support.

For better scalability (epoll, kqueue) and to provide non-blocking name resolution, SOCKS5 as well as TLS support, the
optional modules L<EV> (4.32+), L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and L<IO::Socket::SSL>
(2.009+) will be used automatically if possible. Individual features can also be disabled with the C<MOJO_NO_NNR>,
C<MOJO_NO_SOCKS> and C<MOJO_NO_TLS> environment variables.

See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.

=head1 SIGNALS

The L<Mojo::Server::Daemon> process can be controlled at runtime with the following signals.

=head2 INT, TERM

Shut down server immediately.

=head1 EVENTS

L<Mojo::Server::Daemon> inherits all events from L<Mojo::Server>.

=head1 ATTRIBUTES

L<Mojo::Server::Daemon> inherits all attributes from L<Mojo::Server> and implements the following new ones.

=head2 acceptors

  my $acceptors = $daemon->acceptors;
  $daemon       = $daemon->acceptors(['6be0c140ef00a389c5d039536b56d139']);

Active acceptor ids.

  # Check port
  mu $port = $daemon->ioloop->acceptor($daemon->acceptors->[0])->port;

=head2 backlog

  my $backlog = $daemon->backlog;
  $daemon     = $daemon->backlog(128);

Listen backlog size, defaults to C<SOMAXCONN>.

=head2 inactivity_timeout

  my $timeout = $daemon->inactivity_timeout;
  $daemon     = $daemon->inactivity_timeout(5);

Maximum amount of time in seconds a connection with an active request can be inactive before getting closed, defaults
to the value of the C<MOJO_INACTIVITY_TIMEOUT> environment variable or C<30>. Setting the value to C<0> will allow
connections to be inactive indefinitely.

=head2 ioloop

  my $loop = $daemon->ioloop;
  $daemon  = $daemon->ioloop(Mojo::IOLoop->new);

Event loop object to use for I/O operations, defaults to the global L<Mojo::IOLoop> singleton.

=head2 keep_alive_timeout

  my $timeout = $daemon->keep_alive_timeout;
  $daemon     = $daemon->keep_alive_timeout(10);

Maximum amount of time in seconds a connection without an active request can be inactive before getting closed,
defaults to the value of the C<MOJO_KEEP_ALIVE_TIMEOUT> environment variable or C<5>. Setting the value to C<0> will
allow connections to be inactive indefinitely.

=head2 listen

  my $listen = $daemon->listen;
  $daemon    = $daemon->listen(['https://127.0.0.1:8080']);

Array reference with one or more locations to listen on, defaults to the value of the C<MOJO_LISTEN> environment
variable or C<http://*:3000> (shortcut for C<http://0.0.0.0:3000>).

  # Listen on all IPv4 interfaces
  $daemon->listen(['http://*:3000']);

  # Listen on all IPv4 and IPv6 interfaces
  $daemon->listen(['http://[::]:3000']);

  # Listen on IPv6 interface
  $daemon->listen(['http://[::1]:4000']);

  # Listen on IPv4 and IPv6 interfaces
  $daemon->listen(['http://127.0.0.1:3000', 'http://[::1]:3000']);

  # Listen on UNIX domain socket "/tmp/myapp.sock" (percent encoded slash)
  $daemon->listen(['http+unix://%2Ftmp%2Fmyapp.sock']);

  # File descriptor, as used by systemd
  $daemon->listen(['http://127.0.0.1?fd=3']);

  # Allow multiple servers to use the same port (SO_REUSEPORT)
  $daemon->listen(['http://*:8080?reuse=1']);

  # Listen on two ports with HTTP and HTTPS at the same time
  $daemon->listen(['http://*:3000', 'https://*:4000']);

  # Use a custom certificate and key
  $daemon->listen(['https://*:3000?cert=/x/server.crt&key=/y/server.key']);

  # Domain specific certificates and keys (SNI)
  $daemon->listen(
    ['https://*:3000?example.com_cert=/x/my.crt&example.com_key=/y/my.key']);

  # Or even a custom certificate authority
  $daemon->listen(
    ['https://*:3000?cert=/x/server.crt&key=/y/server.key&ca=/z/ca.crt']);

These parameters are currently available:

=over 2

=item ca

  ca=/etc/tls/ca.crt

Path to TLS certificate authority file used to verify the peer certificate.

=item cert

  cert=/etc/tls/server.crt
  mojolicious.org_cert=/etc/tls/mojo.crt

Path to the TLS cert file, defaults to a built-in test certificate.

=item ciphers

  ciphers=AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH

TLS cipher specification string. For more information about the format see
L<https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-STRINGS>.

=item fd

  fd=3

File descriptor with an already prepared listen socket.

=item key

  key=/etc/tls/server.key
  mojolicious.org_key=/etc/tls/mojo.key

Path to the TLS key file, defaults to a built-in test key.

=item reuse

  reuse=1

Allow multiple servers to use the same port with the C<SO_REUSEPORT> socket option.

=item single_accept

  single_accept=1

Only accept one connection at a time.

=item verify

  verify=0x00

TLS verification mode.

=item version

  version=TLSv1_2

TLS protocol version.

=back

=head2 max_clients

  my $max = $daemon->max_clients;
  $daemon = $daemon->max_clients(100);

Maximum number of accepted connections this server is allowed to handle concurrently, before stopping to accept new
incoming connections, passed along to L<Mojo::IOLoop/"max_connections">.

=head2 max_requests

  my $max = $daemon->max_requests;
  $daemon = $daemon->max_requests(250);

Maximum number of keep-alive requests per connection, defaults to C<100>.

=head2 silent

  my $bool = $daemon->silent;
  $daemon  = $daemon->silent($bool);

Disable console messages.

=head1 METHODS

L<Mojo::Server::Daemon> inherits all methods from L<Mojo::Server> and implements the following new ones.

=head2 ports

  my $ports = $daemon->ports;

Get all ports this server is currently listening on.

  # All ports
  say for @{$daemon->ports};

=head2 run

  $daemon->run;

Run server and wait for L</"SIGNALS">.

=head2 start

  $daemon = $daemon->start;

Start or resume accepting connections through L</"ioloop">.

  # Listen on random port
  my $port = $daemon->listen(['http://127.0.0.1'])->start->ports->[0];

  # Run multiple web servers concurrently
  my $daemon1 = Mojo::Server::Daemon->new(listen => ['http://*:3000'])->start;
  my $daemon2 = Mojo::Server::Daemon->new(listen => ['http://*:4000'])->start;
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 stop

  $daemon = $daemon->stop;

Stop accepting connections through L</"ioloop">.

=head1 DEBUGGING

You can set the C<MOJO_SERVER_DEBUG> environment variable to get some advanced diagnostics information printed to
C<STDERR>.

  MOJO_SERVER_DEBUG=1

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Server::CGI;
use Mojo::Base 'Mojo::Server';

has 'nph';

sub run {
  my $self = shift;

  $self->app->server($self);
  my $tx  = $self->build_tx;
  my $req = $tx->req->parse(\%ENV);
  $tx->local_port($ENV{SERVER_PORT})->remote_address($ENV{REMOTE_ADDR});

  # Request body (may block if we try to read too much)
  binmode STDIN;
  my $len = $req->headers->content_length;
  until ($req->is_finished) {
    my $chunk = ($len && $len < 131072) ? $len : 131072;
    last unless my $read = STDIN->read(my $buffer, $chunk, 0);
    $req->parse($buffer);
    last if ($len -= $read) <= 0;
  }

  $self->emit(request => $tx);

  # Response start-line
  STDOUT->autoflush(1);
  binmode STDOUT;
  my $res = $tx->res->fix_headers;
  return undef if $self->nph && !_write($res, 'get_start_line_chunk');

  # Response headers
  my $code = $res->code    || 404;
  my $msg  = $res->message || $res->default_message;
  $res->headers->status("$code $msg") unless $self->nph;
  return undef                        unless _write($res, 'get_header_chunk');

  # Response body
  return undef unless $tx->is_empty || _write($res, 'get_body_chunk');

  # Finish transaction
  $tx->closed;

  return $res->code;
}

sub _write {
  my ($res, $method) = @_;

  my $offset = 0;
  while (1) {

    # No chunk yet, try again
    sleep 1 and next unless defined(my $chunk = $res->$method($offset));

    # End of part
    last unless my $len = length $chunk;

    # Make sure we can still write
    $offset += $len;
    return undef unless STDOUT->opened;
    print STDOUT $chunk;
  }

  return 1;
}

1;

=encoding utf8

=head1 NAME

Mojo::Server::CGI - CGI server

=head1 SYNOPSIS

  use Mojo::Server::CGI;

  my $cgi = Mojo::Server::CGI->new;
  $cgi->unsubscribe('request')->on(request => sub ($cgi, $tx) {

    # Request
    my $method = $tx->req->method;
    my $path   = $tx->req->url->path;

    # Response
    $tx->res->code(200);
    $tx->res->headers->content_type('text/plain');
    $tx->res->body("$method request for $path!");

    # Resume transaction
    $tx->resume;
  });
  $cgi->run;

=head1 DESCRIPTION

L<Mojo::Server::CGI> is a simple and portable implementation of L<RFC 3875|https://tools.ietf.org/html/rfc3875>.

See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.

=head1 EVENTS

L<Mojo::Server::CGI> inherits all events from L<Mojo::Server>.

=head1 ATTRIBUTES

L<Mojo::Server::CGI> inherits all attributes from L<Mojo::Server> and implements the following new ones.

=head2 nph

  my $bool = $cgi->nph;
  $cgi     = $cgi->nph($bool);

Activate non-parsed header mode.

=head1 METHODS

L<Mojo::Server::CGI> inherits all methods from L<Mojo::Server> and implements the following new ones.

=head2 run

  my $status = $cgi->run;

Run CGI.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Server::Morbo;
use Mojo::Base -base;

# "Linda: With Haley's Comet out of ice, Earth is experiencing the devastating
#         effects of sudden, intense global warming.
#  Morbo: Morbo is pleased but sticky."
use Mojo::Loader qw(load_class);
use Mojo::Server::Daemon;
use POSIX qw(WNOHANG);

has backend => sub {
  my $backend = $ENV{MOJO_MORBO_BACKEND} || 'Poll';
  $backend = "Mojo::Server::Morbo::Backend::$backend";
  return $backend->new unless my $e = load_class $backend;
  die $e if ref $e;
  die qq{Can't find Morbo backend class "$backend" in \@INC. (@INC)\n};
};
has daemon => sub { Mojo::Server::Daemon->new };
has silent => 1;

sub run {
  my ($self, $app) = @_;

  # Clean manager environment
  local $SIG{INT} = local $SIG{TERM} = sub {
    $self->{finished} = 1;
    kill 'TERM', $self->{worker} if $self->{worker};
  };
  unshift @{$self->backend->watch}, $0 = $app;
  $self->{modified} = 1;

  # Prepare and cache listen sockets for smooth restarting
  $self->daemon->start->stop;

  $self->_manage until $self->{finished} && !$self->{worker};
  exit 0;
}

sub _manage {
  my $self = shift;

  if (my @files = @{$self->backend->modified_files}) {
    say @files == 1
      ? qq{File "@{[$files[0]]}" changed, restarting.}
      : qq{@{[scalar @files]} files changed, restarting.}
      unless $self->silent;
    kill 'TERM', $self->{worker} if $self->{worker};
    $self->{modified} = 1;
  }

  if (my $pid = $self->{worker}) {
    delete $self->{worker} if waitpid($pid, WNOHANG) == $pid;
  }

  $self->_spawn if !$self->{worker} && delete $self->{modified};
}

sub _spawn {
  my $self = shift;

  # Manager
  my $manager = $$;
  die "Can't fork: $!" unless defined(my $pid = $self->{worker} = fork);
  return if $pid;

  # Worker
  my $daemon = $self->daemon;
  $daemon->load_app($self->backend->watch->[0])->server($daemon);
  $daemon->ioloop->recurring(1 => sub { shift->stop unless kill 0, $manager });
  $daemon->run;
  exit 0;
}

1;

=encoding utf8

=head1 NAME

Mojo::Server::Morbo - Tonight at 11...DOOOOOOOOOOOOOOOM!

=head1 SYNOPSIS

  use Mojo::Server::Morbo;

  my $morbo = Mojo::Server::Morbo->new;
  $morbo->run('/home/sri/myapp.pl');

=head1 DESCRIPTION

L<Mojo::Server::Morbo> is a full featured, self-restart capable non-blocking I/O HTTP and WebSocket server, built
around the very well tested and reliable L<Mojo::Server::Daemon>, with IPv6, TLS, SNI, UNIX domain socket, Comet (long
polling), keep-alive and multiple event loop support. Note that the server uses signals for process management, so you
should avoid modifying signal handlers in your applications.

To start applications with it you can use the L<morbo> script.

  $ morbo ./myapp.pl
  Web application available at http://127.0.0.1:3000

For better scalability (epoll, kqueue) and to provide non-blocking name resolution, SOCKS5 as well as TLS support, the
optional modules L<EV> (4.32+), L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and L<IO::Socket::SSL>
(2.009+) will be used automatically if possible. Individual features can also be disabled with the C<MOJO_NO_NNR>,
C<MOJO_NO_SOCKS> and C<MOJO_NO_TLS> environment variables.

See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.

=head1 SIGNALS

The L<Mojo::Server::Morbo> process can be controlled at runtime with the following signals.

=head2 INT, TERM

Shut down server immediately.

=head1 ATTRIBUTES

L<Mojo::Server::Morbo> implements the following attributes.

=head2 backend

  my $backend = $morbo->backend;
  $morbo      = $morbo->backend(Mojo::Server::Morbo::Backend::Poll->new);

Backend, usually a L<Mojo::Server::Morbo::Backend::Poll> object.

=head2 daemon

  my $daemon = $morbo->daemon;
  $morbo     = $morbo->daemon(Mojo::Server::Daemon->new);

L<Mojo::Server::Daemon> object this server manages.

=head2 silent

  my $bool = $morbo->silent;
  $morbo   = $morbo->silent($bool);

Disable console messages, defaults to a true value.

=head1 METHODS

L<Mojo::Server::Morbo> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 run

  $morbo->run('script/my_app');

Run server for application and wait for L</"SIGNALS">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Server::Prefork;
use Mojo::Base 'Mojo::Server::Daemon';

use Config;
use File::Spec::Functions qw(tmpdir);
use Mojo::File            qw(path);
use Mojo::Util            qw(steady_time);
use POSIX                 qw(WNOHANG);
use Scalar::Util          qw(weaken);

has accepts            => 10000;
has cleanup            => 1;
has graceful_timeout   => 120;
has heartbeat_timeout  => 50;
has heartbeat_interval => 5;
has pid_file           => sub { path(tmpdir, 'prefork.pid')->to_string };
has spare              => 2;
has workers            => 4;

sub DESTROY { path($_[0]->pid_file)->remove if $_[0]->cleanup }

sub check_pid {
  return undef unless -r (my $file = path(shift->pid_file));
  my $pid = $file->slurp;
  chomp $pid;

  # Running
  return $pid if $pid && kill 0, $pid;

  # Not running
  $file->remove;
  return undef;
}

sub ensure_pid_file {
  my ($self, $pid) = @_;

  # Check if PID file already exists
  return if -e (my $file = path($self->pid_file));

  # Create PID file
  if (my $err = eval { $file->spurt("$pid\n")->chmod(0644) } ? undef : $@) {
    $self->app->log->error(qq{Can't create process id file "$file": $err})
      and die qq{Can't create process id file "$file": $err};
  }
  $self->app->log->info(qq{Creating process id file "$file"});
}

sub healthy {
  scalar grep { $_->{healthy} } values %{shift->{pool}};
}

sub run {
  my $self = shift;

  # No fork emulation support
  say 'Pre-forking does not support fork emulation.' and exit 0 if $Config{d_pseudofork};

  # Pipe for worker communication
  pipe($self->{reader}, $self->{writer}) or die "Can't create pipe: $!";

  # Clean manager environment
  local $SIG{CHLD} = sub {
    while ((my $pid = waitpid -1, WNOHANG) > 0) { $self->emit(reap => $pid)->_stopped($pid) }
  };
  local $SIG{INT}  = local $SIG{TERM} = sub { $self->_term };
  local $SIG{QUIT} = sub { $self->_term(1) };
  local $SIG{TTIN} = sub { $self->workers($self->workers + 1) };
  local $SIG{TTOU} = sub {
    $self->workers > 0 ? $self->workers($self->workers - 1) : return;
    for my $w (values %{$self->{pool}}) { ($w->{graceful} = steady_time) and last unless $w->{graceful} }
  };

  # Preload application before starting workers
  $self->start->app->log->info("Manager $$ started");
  $self->ioloop->max_accepts($self->accepts);
  $self->{running} = 1;
  $self->_manage while $self->{running};
  $self->app->log->info("Manager $$ stopped");
}

sub _heartbeat { shift->{writer}->syswrite("$$:$_[0]\n") or exit 0 }

sub _manage {
  my $self = shift;

  # Spawn more workers if necessary and check PID file
  if (!$self->{finished}) {
    my $graceful = grep { $_->{graceful} } values %{$self->{pool}};
    my $spare    = $self->spare;
    $spare = $graceful ? $graceful > $spare ? $spare : $graceful : 0;
    my $need = ($self->workers - keys %{$self->{pool}}) + $spare;
    $self->_spawn while $need-- > 0;
    $self->ensure_pid_file($$);
  }

  # Shutdown
  elsif (!keys %{$self->{pool}}) { return delete $self->{running} }

  # Wait for heartbeats
  $self->_wait;

  my $interval = $self->heartbeat_interval;
  my $ht       = $self->heartbeat_timeout;
  my $gt       = $self->graceful_timeout;
  my $log      = $self->app->log;
  my $time     = steady_time;

  for my $pid (keys %{$self->{pool}}) {
    next unless my $w = $self->{pool}{$pid};

    # No heartbeat (graceful stop)
    $log->error("Worker $pid has no heartbeat ($ht seconds), restarting (see FAQ for more)") and $w->{graceful} = $time
      if !$w->{graceful} && ($w->{time} + $interval + $ht <= $time);

    # Graceful stop with timeout
    my $graceful = $w->{graceful} ||= $self->{graceful} ? $time : undef;
    $log->info("Stopping worker $pid gracefully ($gt seconds)") and (kill 'QUIT', $pid or $self->_stopped($pid))
      if $graceful && !$w->{quit}++;
    $w->{force} = 1 if $graceful && $graceful + $gt <= $time;

    # Normal stop
    $log->warn("Stopping worker $pid immediately") and (kill 'KILL', $pid or $self->_stopped($pid))
      if $w->{force} || ($self->{finished} && !$graceful);
  }
}

sub _spawn {
  my $self = shift;

  # Manager
  die "Can't fork: $!" unless defined(my $pid = fork);
  return $self->emit(spawn => $pid)->{pool}{$pid} = {time => steady_time} if $pid;

  # Heartbeat messages
  my $loop     = $self->cleanup(0)->ioloop;
  my $finished = 0;
  $loop->on(finish => sub { $finished = 1 });
  weaken $self;
  my $cb = sub { $self->_heartbeat($finished) };
  $loop->next_tick($cb);
  $loop->recurring($self->heartbeat_interval => $cb);

  # Clean worker environment
  $SIG{$_} = 'DEFAULT' for qw(CHLD INT TERM TTIN TTOU);
  $SIG{QUIT} = sub { $loop->stop_gracefully };
  $loop->on(finish => sub { $self->max_requests(1) });
  delete $self->{reader};
  srand;

  $self->app->log->info("Worker $$ started");
  $loop->start;
  exit 0;
}

sub _stopped {
  my ($self, $pid) = @_;

  return unless my $w = delete $self->{pool}{$pid};

  my $log = $self->app->log;
  $log->info("Worker $pid stopped");
  $log->error("Worker $pid stopped too early, shutting down") and $self->_term unless $w->{healthy};
}

sub _term {
  my ($self, $graceful) = @_;
  @{$self->emit(finish => $graceful)}{qw(finished graceful)} = (1, $graceful);
}

sub _wait {
  my $self = shift;

  # Poll for heartbeats
  my $reader = $self->emit('wait')->{reader};
  return unless Mojo::Util::_readable(1000, fileno($reader));
  return unless $reader->sysread(my $chunk, 4194304);

  # Update heartbeats (and stop gracefully if necessary)
  my $time = steady_time;
  while ($chunk =~ /(\d+):(\d)\n/g) {
    next unless my $w = $self->{pool}{$1};
    @$w{qw(healthy time)} = (1, $time) and $self->emit(heartbeat => $1);
    if ($2) {
      $w->{graceful} ||= $time;
      $w->{quit}++;
    }
  }
}

1;

=encoding utf8

=head1 NAME

Mojo::Server::Prefork - Pre-forking non-blocking I/O HTTP and WebSocket server

=head1 SYNOPSIS

  use Mojo::Server::Prefork;

  my $prefork = Mojo::Server::Prefork->new(listen => ['http://*:8080']);
  $prefork->unsubscribe('request')->on(request => sub ($prefork, $tx) {

    # Request
    my $method = $tx->req->method;
    my $path   = $tx->req->url->path;

    # Response
    $tx->res->code(200);
    $tx->res->headers->content_type('text/plain');
    $tx->res->body("$method request for $path!");

    # Resume transaction
    $tx->resume;
  });
  $prefork->run;

=head1 DESCRIPTION

L<Mojo::Server::Prefork> is a full featured, UNIX optimized, pre-forking non-blocking I/O HTTP and WebSocket server,
built around the very well tested and reliable L<Mojo::Server::Daemon>, with IPv6, TLS, SNI, UNIX domain socket, Comet
(long polling), keep-alive and multiple event loop support. Note that the server uses signals for process management,
so you should avoid modifying signal handlers in your applications.

For better scalability (epoll, kqueue) and to provide non-blocking name resolution, SOCKS5 as well as TLS support, the
optional modules L<EV> (4.32+), L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and L<IO::Socket::SSL>
(1.84+) will be used automatically if possible. Individual features can also be disabled with the C<MOJO_NO_NNR>,
C<MOJO_NO_SOCKS> and C<MOJO_NO_TLS> environment variables.

See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.

=head1 MANAGER SIGNALS

The L<Mojo::Server::Prefork> manager process can be controlled at runtime with the following signals.

=head2 INT, TERM

Shut down server immediately.

=head2 QUIT

Shut down server gracefully.

=head2 TTIN

Increase worker pool by one.

=head2 TTOU

Decrease worker pool by one.

=head1 WORKER SIGNALS

L<Mojo::Server::Prefork> worker processes can be controlled at runtime with the following signals.

=head2 QUIT

Stop worker gracefully.

=head1 EVENTS

L<Mojo::Server::Prefork> inherits all events from L<Mojo::Server::Daemon> and can emit the following new ones.

=head2 finish

  $prefork->on(finish => sub ($prefork, $graceful) {...});

Emitted when the server shuts down.

  $prefork->on(finish => sub ($prefork, $graceful) {
    say $graceful ? 'Graceful server shutdown' : 'Server shutdown';
  });

=head2 heartbeat

  $prefork->on(heartbeat => sub ($prefork, $pid) {...});

Emitted when a heartbeat message has been received from a worker.

  $prefork->on(heartbeat => sub ($prefork, $pid) { say "Worker $pid has a heartbeat" });

=head2 reap

  $prefork->on(reap => sub ($prefork, $pid) {...});

Emitted when a child process exited.

  $prefork->on(reap => sub ($prefork, $pid) { say "Worker $pid stopped" });

=head2 spawn

  $prefork->on(spawn => sub ($prefork, $pid) {...});

Emitted when a worker process is spawned.

  $prefork->on(spawn => sub ($prefork, $pid) { say "Worker $pid started" });

=head2 wait

  $prefork->on(wait => sub ($prefork) {...});

Emitted when the manager starts waiting for new heartbeat messages.

  $prefork->on(wait => sub ($prefork) {
    my $workers = $prefork->workers;
    say "Waiting for heartbeat messages from $workers workers";
  });

=head1 ATTRIBUTES

L<Mojo::Server::Prefork> inherits all attributes from L<Mojo::Server::Daemon> and implements the following new ones.

=head2 accepts

  my $accepts = $prefork->accepts;
  $prefork    = $prefork->accepts(100);

Maximum number of connections a worker is allowed to accept, before stopping gracefully and then getting replaced with
a newly started worker, passed along to L<Mojo::IOLoop/"max_accepts">, defaults to C<10000>. Setting the value to C<0>
will allow workers to accept new connections indefinitely. Note that up to half of this value can be subtracted
randomly to improve load balancing, and to make sure that not all workers restart at the same time.

=head2 cleanup

  my $bool = $prefork->cleanup;
  $prefork = $prefork->cleanup($bool);

Delete L</"pid_file"> automatically once it is not needed anymore, defaults to a true value.

=head2 graceful_timeout

  my $timeout = $prefork->graceful_timeout;
  $prefork    = $prefork->graceful_timeout(15);

Maximum amount of time in seconds stopping a worker gracefully may take before being forced, defaults to C<120>. Note
that this value should usually be a little larger than the maximum amount of time you expect any one request to take.

=head2 heartbeat_interval

  my $interval = $prefork->heartbeat_interval;
  $prefork     = $prefork->heartbeat_interval(3);

Heartbeat interval in seconds, defaults to C<5>.

=head2 heartbeat_timeout

  my $timeout = $prefork->heartbeat_timeout;
  $prefork    = $prefork->heartbeat_timeout(2);

Maximum amount of time in seconds before a worker without a heartbeat will be stopped gracefully, defaults to C<50>.
Note that this value should usually be a little larger than the maximum amount of time you expect any one operation to
block the event loop.

=head2 pid_file

  my $file = $prefork->pid_file;
  $prefork = $prefork->pid_file('/tmp/prefork.pid');

Full path of process id file, defaults to C<prefork.pid> in a temporary directory.

=head2 spare

  my $spare = $prefork->spare;
  $prefork  = $prefork->spare(4);

Temporarily spawn up to this number of additional workers if there is a need, defaults to C<2>. This allows for new
workers to be started while old ones are still shutting down gracefully, drastically reducing the performance cost of
worker restarts.

=head2 workers

  my $workers = $prefork->workers;
  $prefork    = $prefork->workers(10);

Number of worker processes, defaults to C<4>. A good rule of thumb is two worker processes per CPU core for
applications that perform mostly non-blocking operations, blocking operations often require more and benefit from
decreasing concurrency with L<Mojo::Server::Daemon/"max_clients"> (often as low as C<1>).

=head1 METHODS

L<Mojo::Server::Prefork> inherits all methods from L<Mojo::Server::Daemon> and implements the following new ones.

=head2 check_pid

  my $pid = $prefork->check_pid;

Get process id for running server from L</"pid_file"> or delete it if server is not running.

  say 'Server is not running' unless $prefork->check_pid;

=head2 ensure_pid_file

  $prefork->ensure_pid_file($pid);

Ensure L</"pid_file"> exists.

=head2 healthy

  my $healthy = $prefork->healthy;

Number of currently active worker processes with a heartbeat.

=head2 run

  $prefork->run;

Run server and wait for L</"MANAGER SIGNALS">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Asset::File;
use Mojo::Base 'Mojo::Asset';

use Carp                  qw(croak);
use Fcntl                 qw(SEEK_SET);
use File::Spec::Functions ();
use Mojo::File            qw(tempfile);

has [qw(cleanup path)];
has handle => sub {
  my $self = shift;

  # Open existing file
  my $path = $self->path;
  return Mojo::File->new($path)->open('<') if defined $path && -e $path;

  $self->cleanup(1) unless defined $self->cleanup;

  # Create a specific file
  return Mojo::File->new($path)->open('+>>') if defined $path;

  # Create a temporary file
  my $file = tempfile DIR => $self->tmpdir, TEMPLATE => 'mojo.tmp.XXXXXXXXXXXXXXXX', UNLINK => 0;
  $self->path($file->to_string);
  return $file->open('+>>');
};
has tmpdir => sub { $ENV{MOJO_TMPDIR} || File::Spec::Functions::tmpdir };

sub DESTROY {
  my $self = shift;

  return unless $self->cleanup && defined(my $path = $self->path);
  if (my $handle = $self->handle) { close $handle }

  # Only the process that created the file is allowed to remove it
  Mojo::File->new($path)->remove if -w $path && ($self->{pid} // $$) == $$;
}

sub add_chunk {
  my ($self, $chunk) = @_;
  ($self->handle->syswrite($chunk) // -1) == length $chunk or croak "Can't write to asset: $!";
  return $self;
}

sub contains {
  my ($self, $str) = @_;

  my $handle = $self->handle;
  $handle->sysseek($self->start_range, SEEK_SET);

  # Calculate window size
  my $end  = $self->end_range // $self->size;
  my $len  = length $str;
  my $size = $len > 131072 ? $len : 131072;
  $size = $end - $self->start_range if $size > $end - $self->start_range;

  # Sliding window search
  my $offset = 0;
  my $start  = $handle->sysread(my $window, $len);
  while ($offset < $end) {

    # Read as much as possible
    my $diff = $end - ($start + $offset);
    my $read = $handle->sysread(my $buffer, $diff < $size ? $diff : $size);
    $window .= $buffer;

    # Search window
    my $pos = index $window, $str;
    return $offset + $pos if $pos >= 0;
    return -1             if $read == 0 || ($offset += $read) == $end;

    # Resize window
    substr $window, 0, $read, '';
  }

  return -1;
}

sub get_chunk {
  my ($self, $offset, $max) = @_;
  $max //= 131072;

  $offset += $self->start_range;
  my $handle = $self->handle;
  $handle->sysseek($offset, SEEK_SET);

  my $buffer;
  if (defined(my $end = $self->end_range)) {
    return '' if (my $chunk = $end + 1 - $offset) <= 0;
    $handle->sysread($buffer, $chunk > $max ? $max : $chunk);
  }
  else { $handle->sysread($buffer, $max) }

  return $buffer;
}

sub is_file {1}

sub move_to {
  my ($self, $to) = @_;

  # Windows requires that the handle is closed
  close $self->handle;
  delete $self->{handle};

  # Move file and prevent clean up
  Mojo::File->new($self->path)->move_to($to);
  return $self->path($to)->cleanup(0);
}

sub mtime { (stat shift->handle)[9] }

sub new {
  my $file = shift->SUPER::new(@_);
  $file->{pid} = $$;
  return $file;
}

sub size { -s shift->handle }

sub slurp {
  my $handle = shift->handle;
  $handle->sysseek(0, SEEK_SET);
  my $ret = my $content = '';
  while ($ret = $handle->sysread(my $buffer, 131072, 0)) { $content .= $buffer }
  return defined $ret ? $content : croak "Can't read from asset: $!";
}

sub to_file {shift}

1;

=encoding utf8

=head1 NAME

Mojo::Asset::File - File storage for HTTP content

=head1 SYNOPSIS

  use Mojo::Asset::File;

  # Temporary file
  my $file = Mojo::Asset::File->new;
  $file->add_chunk('foo bar baz');
  say 'File contains "bar"' if $file->contains('bar') >= 0;
  say $file->slurp;

  # Existing file
  my $file = Mojo::Asset::File->new(path => '/home/sri/foo.txt');
  $file->move_to('/yada.txt');
  say $file->slurp;

=head1 DESCRIPTION

L<Mojo::Asset::File> is a file storage backend for HTTP content.

=head1 EVENTS

L<Mojo::Asset::File> inherits all events from L<Mojo::Asset>.

=head1 ATTRIBUTES

L<Mojo::Asset::File> inherits all attributes from L<Mojo::Asset> and implements the following new ones.

=head2 cleanup

  my $bool = $file->cleanup;
  $file    = $file->cleanup($bool);

Delete L</"path"> automatically once the file is not used anymore.

=head2 handle

  my $handle = $file->handle;
  $file      = $file->handle(IO::File->new);

Filehandle, created on demand for L</"path">, which can be generated automatically and safely based on L</"tmpdir">.

=head2 path

  my $path = $file->path;
  $file    = $file->path('/home/sri/foo.txt');

File path used to create L</"handle">.

=head2 tmpdir

  my $tmpdir = $file->tmpdir;
  $file      = $file->tmpdir('/tmp');

Temporary directory used to generate L</"path">, defaults to the value of the C<MOJO_TMPDIR> environment variable or
auto-detection.

=head1 METHODS

L<Mojo::Asset::File> inherits all methods from L<Mojo::Asset> and implements the following new ones.

=head2 add_chunk

  $file = $file->add_chunk('foo bar baz');

Add chunk of data.

=head2 contains

  my $position = $file->contains('bar');

Check if asset contains a specific string.

=head2 get_chunk

  my $bytes = $file->get_chunk($offset);
  my $bytes = $file->get_chunk($offset, $max);

Get chunk of data starting from a specific position, defaults to a maximum chunk size of C<131072> bytes (128KiB).

=head2 is_file

  my $bool = $file->is_file;

True, this is a L<Mojo::Asset::File> object.

=head2 move_to

  $file = $file->move_to('/home/sri/bar.txt');

Move asset data into a specific file and disable L</"cleanup">.

=head2 mtime

  my $mtime = $file->mtime;

Modification time of asset.

=head2 new

  my $file = Mojo::Asset::File->new;
  my $file = Mojo::Asset::File->new(path => '/home/sri/test.txt');
  my $file = Mojo::Asset::File->new({path => '/home/sri/test.txt'});

Construct a new L<Mojo::Asset::File> object.

=head2 size

  my $size = $file->size;

Size of asset data in bytes.

=head2 slurp

  my $bytes = $file->slurp;

Read all asset data at once.

=head2 to_file

  $file = $file->to_file;

Does nothing but return the invocant, since we already have a L<Mojo::Asset::File> object.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Asset::Memory;
use Mojo::Base 'Mojo::Asset';

use Carp 'croak';
use Mojo::Asset::File;
use Mojo::File qw(path);

has 'auto_upgrade';
has max_memory_size => sub { $ENV{MOJO_MAX_MEMORY_SIZE} || 262144 };
has mtime           => sub {$^T};

sub add_chunk {
  my ($self, $chunk) = @_;

  croak 'Asset has been upgraded and is now frozen' if $self->{frozen};
  if ($self->auto_upgrade && ($self->size + length $chunk) > $self->max_memory_size) {
    $self->emit(upgrade => my $file = Mojo::Asset::File->new)->{frozen} = 1;
    return $file->add_chunk($self->slurp . $chunk);
  }

  $self->{content} .= $chunk;
  return $self;
}

sub contains {
  my ($self, $str) = @_;

  my $start = $self->start_range;
  my $pos   = index $self->{content} // '', $str, $start;
  $pos -= $start if $start && $pos >= 0;
  my $end = $self->end_range;

  return $end && ($pos + length $str) >= $end ? -1 : $pos;
}

sub get_chunk {
  my ($self, $offset, $max) = @_;
  $max //= 131072;

  $offset += $self->start_range;
  if (my $end = $self->end_range) { $max = $end + 1 - $offset if ($offset + $max) > $end }

  return substr shift->{content} // '', $offset, $max;
}

sub move_to { path($_[1])->spurt($_[0]{content} // '') and return $_[0] }

sub size { length(shift->{content} // '') }

sub slurp { shift->{content} // '' }

sub to_file { Mojo::Asset::File->new->add_chunk(shift->slurp) }

1;

=encoding utf8

=head1 NAME

Mojo::Asset::Memory - In-memory storage for HTTP content

=head1 SYNOPSIS

  use Mojo::Asset::Memory;

  my $mem = Mojo::Asset::Memory->new;
  $mem->add_chunk('foo bar baz');
  say $mem->slurp;

=head1 DESCRIPTION

L<Mojo::Asset::Memory> is an in-memory storage backend for HTTP content.

=head1 EVENTS

L<Mojo::Asset::Memory> inherits all events from L<Mojo::Asset> and can emit the following new ones.

=head2 upgrade

  $mem->on(upgrade => sub ($mem, $file) {...});

Emitted when asset gets upgraded to a L<Mojo::Asset::File> object.

  $mem->on(upgrade => sub ($mem, $file) { $file->tmpdir('/tmp') });

=head1 ATTRIBUTES

L<Mojo::Asset::Memory> inherits all attributes from L<Mojo::Asset> and implements the following new ones.

=head2 auto_upgrade

  my $bool = $mem->auto_upgrade;
  $mem     = $mem->auto_upgrade($bool);

Try to detect if content size exceeds L</"max_memory_size"> limit and automatically upgrade to a L<Mojo::Asset::File>
object.

=head2 max_memory_size

  my $size = $mem->max_memory_size;
  $mem     = $mem->max_memory_size(1024);

Maximum size in bytes of data to keep in memory before automatically upgrading to a L<Mojo::Asset::File> object,
defaults to the value of the C<MOJO_MAX_MEMORY_SIZE> environment variable or C<262144> (256KiB).

=head2 mtime

  my $mtime = $mem->mtime;
  $mem      = $mem->mtime(1408567500);

Modification time of asset, defaults to the value of C<$^T>.

=head1 METHODS

L<Mojo::Asset::Memory> inherits all methods from L<Mojo::Asset> and implements the following new ones.

=head2 add_chunk

  $mem     = $mem->add_chunk('foo bar baz');
  my $file = $mem->add_chunk('abc' x 262144);

Add chunk of data and upgrade to L<Mojo::Asset::File> object if necessary.

=head2 contains

  my $position = $mem->contains('bar');

Check if asset contains a specific string.

=head2 get_chunk

  my $bytes = $mem->get_chunk($offset);
  my $bytes = $mem->get_chunk($offset, $max);

Get chunk of data starting from a specific position, defaults to a maximum chunk size of C<131072> bytes (128KiB).

=head2 move_to

  $mem = $mem->move_to('/home/sri/foo.txt');

Move asset data into a specific file.

=head2 size

  my $size = $mem->size;

Size of asset data in bytes.

=head2 slurp

  my $bytes = $mem->slurp;

Read all asset data at once.

=head2 to_file

  my $file = $mem->to_file;

Convert asset to L<Mojo::Asset::File> object.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Content;
use Mojo::Base 'Mojo::EventEmitter';

use Carp                qw(croak);
use Compress::Raw::Zlib qw(WANT_GZIP Z_STREAM_END);
use Mojo::Headers;
use Scalar::Util qw(looks_like_number);

has [qw(auto_decompress auto_relax relaxed skip_body)];
has headers           => sub { Mojo::Headers->new };
has max_buffer_size   => sub { $ENV{MOJO_MAX_BUFFER_SIZE}   || 262144 };
has max_leftover_size => sub { $ENV{MOJO_MAX_LEFTOVER_SIZE} || 262144 };

my $BOUNDARY_RE = qr!multipart.*boundary\s*=\s*(?:"([^"]+)"|([\w'(),.:?\-+/]+))!i;

sub body_contains { croak 'Method "body_contains" not implemented by subclass' }
sub body_size     { croak 'Method "body_size" not implemented by subclass' }

sub boundary { (shift->headers->content_type // '') =~ $BOUNDARY_RE ? $1 // $2 : undef }

sub charset {
  my $type = shift->headers->content_type // '';
  return $type =~ /charset\s*=\s*"?([^"\s;]+)"?/i ? $1 : undef;
}

sub clone {
  my $self = shift;
  return undef if $self->is_dynamic;
  return $self->new(headers => $self->headers->clone);
}

sub generate_body_chunk {
  my ($self, $offset) = @_;

  $self->emit(drain => $offset) unless length($self->{body_buffer} //= '');
  return delete $self->{body_buffer} if length $self->{body_buffer};
  return ''                          if $self->{eof};

  my $len = $self->headers->content_length;
  return looks_like_number $len && $len == $offset ? '' : undef;
}

sub get_body_chunk { croak 'Method "get_body_chunk" not implemented by subclass' }

sub get_header_chunk { substr shift->_headers->{header_buffer}, shift, 131072 }

sub header_size { length shift->_headers->{header_buffer} }

sub headers_contain { index(shift->_headers->{header_buffer}, shift) >= 0 }

sub is_chunked { !!shift->headers->transfer_encoding }

sub is_compressed { lc(shift->headers->content_encoding // '') eq 'gzip' }

sub is_dynamic { !!$_[0]{dynamic} }

sub is_finished { (shift->{state} // '') eq 'finished' }

sub is_limit_exceeded { !!shift->{limit} }

sub is_multipart {undef}

sub is_parsing_body { (shift->{state} // '') eq 'body' }

sub leftovers { shift->{buffer} }

sub parse {
  my $self = shift;

  # Headers
  $self->_parse_until_body(@_);
  return $self if $self->{state} eq 'headers';

  # Chunked content
  $self->{real_size} //= 0;
  if ($self->is_chunked && $self->{state} ne 'headers') {
    $self->_parse_chunked;
    $self->{state} = 'finished' if ($self->{chunk_state} // '') eq 'finished';
  }

  # Not chunked, pass through to second buffer
  else {
    $self->{real_size} += length $self->{pre_buffer};
    my $limit = $self->is_finished && length($self->{buffer}) > $self->max_leftover_size;
    $self->{buffer} .= $self->{pre_buffer} unless $limit;
    $self->{pre_buffer} = '';
  }

  # No content
  if ($self->skip_body) {
    $self->{state} = 'finished';
    return $self;
  }

  # Relaxed parsing
  my $headers = $self->headers;
  my $len     = $headers->content_length // '';
  if ($self->auto_relax && !length $len) {
    my $connection = lc($headers->connection // '');
    $self->relaxed(1) if $connection eq 'close' || !$connection;
  }

  # Chunked or relaxed content
  if ($self->is_chunked || $self->relaxed) {
    $self->_decompress($self->{buffer} //= '');
    $self->{size} += length $self->{buffer};
    $self->{buffer} = '';
    return $self;
  }

  # Normal content
  $len = 0 unless looks_like_number $len;
  if ((my $need = $len - ($self->{size} ||= 0)) > 0) {
    my $len   = length $self->{buffer};
    my $chunk = substr $self->{buffer}, 0, $need > $len ? $len : $need, '';
    $self->_decompress($chunk);
    $self->{size} += length $chunk;
  }
  $self->{state} = 'finished' if $len <= $self->progress;

  return $self;
}

sub parse_body {
  my $self = shift;
  $self->{state} = 'body';
  return $self->parse(@_);
}

sub progress {
  my $self = shift;
  return 0 unless my $state = $self->{state};
  return 0 unless $state eq 'body' || $state eq 'finished';
  return $self->{raw_size} - ($self->{header_size} || 0);
}

sub write {
  my ($self, $chunk, $cb) = @_;

  $self->{dynamic} = 1;
  $self->{body_buffer} .= $chunk if defined $chunk;
  $self->once(drain => $cb)      if $cb;
  $self->{eof} = 1               if defined $chunk && !length $chunk;

  return $self;
}

sub write_chunk {
  my ($self, $chunk, $cb) = @_;

  $self->headers->transfer_encoding('chunked') unless $self->{chunked};
  @{$self}{qw(chunked dynamic)} = (1, 1);

  $self->{body_buffer} .= $self->_build_chunk($chunk) if defined $chunk;
  $self->once(drain => $cb)                           if $cb;
  $self->{eof} = 1                                    if defined $chunk && !length $chunk;

  return $self;
}

sub _build_chunk {
  my ($self, $chunk) = @_;

  # End
  return "\x0d\x0a0\x0d\x0a\x0d\x0a" unless length $chunk;

  # First chunk has no leading CRLF
  my $crlf = $self->{chunks}++ ? "\x0d\x0a" : '';
  return $crlf . sprintf('%x', length $chunk) . "\x0d\x0a$chunk";
}

sub _decompress {
  my ($self, $chunk) = @_;

  # No compression
  return $self->emit(read => $chunk) unless $self->auto_decompress && $self->is_compressed;

  # Decompress
  $self->{post_buffer} .= $chunk;
  my $gz     = $self->{gz} //= Compress::Raw::Zlib::Inflate->new(WindowBits => WANT_GZIP);
  my $status = $gz->inflate(\$self->{post_buffer}, my $out);
  $self->emit(read => $out) if defined $out;

  # Replace Content-Encoding with Content-Length
  $self->headers->content_length($gz->total_out)->remove('Content-Encoding') if $status == Z_STREAM_END;

  # Check buffer size
  @$self{qw(state limit)} = ('finished', 1) if length($self->{post_buffer} // '') > $self->max_buffer_size;
}

sub _headers {
  my $self = shift;
  return $self if defined $self->{header_buffer};
  my $headers = $self->headers->to_string;
  $self->{header_buffer} = $headers ? "$headers\x0d\x0a\x0d\x0a" : "\x0d\x0a";
  return $self;
}

sub _parse_chunked {
  my $self = shift;

  # Trailing headers
  return $self->_parse_chunked_trailing_headers if ($self->{chunk_state} // '') eq 'trailing_headers';

  while (my $len = length $self->{pre_buffer}) {

    # Start new chunk (ignore the chunk extension)
    unless ($self->{chunk_len}) {
      last unless $self->{pre_buffer} =~ s/^(?:\x0d?\x0a)?([0-9a-fA-F]+).*\x0a//;
      next if $self->{chunk_len} = hex $1;

      # Last chunk
      $self->{chunk_state} = 'trailing_headers';
      last;
    }

    # Remove as much as possible from payload
    $len = $self->{chunk_len} if $self->{chunk_len} < $len;
    $self->{buffer} .= substr $self->{pre_buffer}, 0, $len, '';
    $self->{real_size} += $len;
    $self->{chunk_len} -= $len;
  }

  # Trailing headers
  $self->_parse_chunked_trailing_headers if ($self->{chunk_state} // '') eq 'trailing_headers';

  # Check buffer size
  @$self{qw(state limit)} = ('finished', 1) if length($self->{pre_buffer} // '') > $self->max_buffer_size;
}

sub _parse_chunked_trailing_headers {
  my $self = shift;

  my $headers = $self->headers->parse(delete $self->{pre_buffer});
  return unless $headers->is_finished;
  $self->{chunk_state} = 'finished';

  # Take care of leftover and replace Transfer-Encoding with Content-Length
  $self->{buffer} .= $headers->leftovers;
  $headers->remove('Transfer-Encoding');
  $headers->content_length($self->{real_size}) unless $headers->content_length;
}

sub _parse_headers {
  my $self = shift;

  my $headers = $self->headers->parse(delete $self->{pre_buffer});
  return unless $headers->is_finished;
  $self->{state} = 'body';

  # Take care of leftovers
  my $leftovers = $self->{pre_buffer} = $headers->leftovers;
  $self->{header_size} = $self->{raw_size} - length $leftovers;
}

sub _parse_until_body {
  my ($self, $chunk) = @_;

  $self->{raw_size} += length($chunk //= '');
  $self->{pre_buffer} .= $chunk;
  $self->_parse_headers if ($self->{state} ||= 'headers') eq 'headers';
  $self->emit('body')   if $self->{state} ne 'headers' && !$self->{body}++;
}

1;

=encoding utf8

=head1 NAME

Mojo::Content - HTTP content base class

=head1 SYNOPSIS

  package Mojo::Content::MyContent;
  use Mojo::Base 'Mojo::Content';

  sub body_contains  {...}
  sub body_size      {...}
  sub get_body_chunk {...}

=head1 DESCRIPTION

L<Mojo::Content> is an abstract base class for HTTP content containers, based on L<RFC
7230|https://tools.ietf.org/html/rfc7230> and L<RFC 7231|https://tools.ietf.org/html/rfc7231>, like
L<Mojo::Content::MultiPart> and L<Mojo::Content::Single>.

=head1 EVENTS

L<Mojo::Content> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 body

  $content->on(body => sub ($content) {...});

Emitted once all headers have been parsed and the body starts.

  $content->on(body => sub ($content) {
    $content->auto_upgrade(0) if $content->headers->header('X-No-MultiPart');
  });

=head2 drain

  $content->on(drain => sub ($content, $offset) {...});

Emitted once all data has been written.

  $content->on(drain => sub ($content) {
    $content->write_chunk(time);
  });

=head2 read

  $content->on(read => sub ($content, $bytes) {...});

Emitted when a new chunk of content arrives.

  $content->on(read => sub ($content, $bytes) {
    say "Streaming: $bytes";
  });

=head1 ATTRIBUTES

L<Mojo::Content> implements the following attributes.

=head2 auto_decompress

  my $bool = $content->auto_decompress;
  $content = $content->auto_decompress($bool);

Decompress content automatically if L</"is_compressed"> is true.

=head2 auto_relax

  my $bool = $content->auto_relax;
  $content = $content->auto_relax($bool);

Try to detect when relaxed parsing is necessary.

=head2 headers

  my $headers = $content->headers;
  $content    = $content->headers(Mojo::Headers->new);

Content headers, defaults to a L<Mojo::Headers> object.

=head2 max_buffer_size

  my $size = $content->max_buffer_size;
  $content = $content->max_buffer_size(1024);

Maximum size in bytes of buffer for content parser, defaults to the value of the C<MOJO_MAX_BUFFER_SIZE> environment
variable or C<262144> (256KiB).

=head2 max_leftover_size

  my $size = $content->max_leftover_size;
  $content = $content->max_leftover_size(1024);

Maximum size in bytes of buffer for pipelined HTTP requests, defaults to the value of the C<MOJO_MAX_LEFTOVER_SIZE>
environment variable or C<262144> (256KiB).

=head2 relaxed

  my $bool = $content->relaxed;
  $content = $content->relaxed($bool);

Activate relaxed parsing for responses that are terminated with a connection close.

=head2 skip_body

  my $bool = $content->skip_body;
  $content = $content->skip_body($bool);

Skip body parsing and finish after headers.

=head1 METHODS

L<Mojo::Content> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 body_contains

  my $bool = $content->body_contains('foo bar baz');

Check if content contains a specific string. Meant to be overloaded in a subclass.

=head2 body_size

  my $size = $content->body_size;

Content size in bytes. Meant to be overloaded in a subclass.

=head2 boundary

  my $boundary = $content->boundary;

Extract multipart boundary from C<Content-Type> header.

=head2 charset

  my $charset = $content->charset;

Extract charset from C<Content-Type> header.

=head2 clone

  my $clone = $content->clone;

Return a new L<Mojo::Content> object cloned from this content if possible, otherwise return C<undef>.

=head2 generate_body_chunk

  my $bytes = $content->generate_body_chunk(0);

Generate dynamic content.

=head2 get_body_chunk

  my $bytes = $content->get_body_chunk(0);

Get a chunk of content starting from a specific position. Meant to be overloaded in a subclass.

=head2 get_header_chunk

  my $bytes = $content->get_header_chunk(13);

Get a chunk of the headers starting from a specific position. Note that this method finalizes the content.

=head2 header_size

  my $size = $content->header_size;

Size of headers in bytes. Note that this method finalizes the content.

=head2 headers_contain

  my $bool = $content->headers_contain('foo bar baz');

Check if headers contain a specific string. Note that this method finalizes the content.

=head2 is_chunked

  my $bool = $content->is_chunked;

Check if C<Transfer-Encoding> header indicates chunked transfer encoding.

=head2 is_compressed

  my $bool = $content->is_compressed;

Check C<Content-Encoding> header for C<gzip> value.

=head2 is_dynamic

  my $bool = $content->is_dynamic;

Check if content will be dynamically generated, which prevents L</"clone"> from working.

=head2 is_finished

  my $bool = $content->is_finished;

Check if parser is finished.

=head2 is_limit_exceeded

  my $bool = $content->is_limit_exceeded;

Check if buffer has exceeded L</"max_buffer_size">.

=head2 is_multipart

  my $bool = $content->is_multipart;

False, this is not a L<Mojo::Content::MultiPart> object.

=head2 is_parsing_body

  my $bool = $content->is_parsing_body;

Check if body parsing started yet.

=head2 leftovers

  my $bytes = $content->leftovers;

Get leftover data from content parser.

=head2 parse

  $content
    = $content->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");

Parse content chunk.

=head2 parse_body

  $content = $content->parse_body('Hi!');

Parse body chunk and skip headers.

=head2 progress

  my $size = $content->progress;

Size of content already received from message in bytes.

=head2 write

  $content = $content->write;
  $content = $content->write('');
  $content = $content->write($bytes);
  $content = $content->write($bytes => sub {...});

Write dynamic content non-blocking, the optional drain callback will be executed once all data has been written.
Calling this method without a chunk of data will finalize the L</"headers"> and allow for dynamic content to be written
later. You can write an empty chunk of data at any time to end the stream.

  # Make sure previous chunk of data has been written before continuing
  $content->write('He' => sub ($content) {
    $content->write('llo!' => sub ($content) {
      $content->write('');
    });
  });

=head2 write_chunk

  $content = $content->write_chunk;
  $content = $content->write_chunk('');
  $content = $content->write_chunk($bytes);
  $content = $content->write_chunk($bytes => sub {...});

Write dynamic content non-blocking with chunked transfer encoding, the optional drain callback will be executed once
all data has been written. Calling this method without a chunk of data will finalize the L</"headers"> and allow for
dynamic content to be written later. You can write an empty chunk of data at any time to end the stream.

  # Make sure previous chunk of data has been written before continuing
  $content->write_chunk('He' => sub ($content) {
    $content->write_chunk('llo!' => sub ($content) {
      $content->write_chunk('');
    });
  });

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::DynamicMethods;
use Mojo::Base -strict;

use Hash::Util::FieldHash qw(fieldhash);
use Mojo::Util            qw(monkey_patch);

sub import {
  my ($flag, $caller) = ($_[1] // '', caller);
  return unless $flag eq '-dispatch';

  my $dyn_pkg    = "${caller}::_Dynamic";
  my $caller_can = $caller->can('SUPER::can');
  monkey_patch $dyn_pkg, 'can', sub {
    my ($self, $method, @rest) = @_;

    # Delegate to our parent's "can" if there is one, without breaking if not
    my $can = $self->$caller_can($method, @rest);
    return undef unless $can;
    no warnings 'once';
    my $h = do { no strict 'refs'; *{"${dyn_pkg}::${method}"}{CODE} };
    return $h && $h eq $can ? undef : $can;
  };

  {
    no strict 'refs';
    unshift @{"${caller}::ISA"}, $dyn_pkg;
  }
}

sub register {
  my ($target, $object, $name, $code) = @_;

  state %dyn_methods;
  state $setup = do { fieldhash %dyn_methods; 1 };

  my $dyn_pkg = "${target}::_Dynamic";
  monkey_patch($dyn_pkg, $name, $target->BUILD_DYNAMIC($name, \%dyn_methods))
    unless do { no strict 'refs'; *{"${dyn_pkg}::${name}"}{CODE} };
  $dyn_methods{$object}{$name} = $code;
}

"Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn";

=encoding utf8

=head1 NAME

Mojo::DynamicMethods - Fast dynamic method dispatch

=head1 SYNOPSIS

  package MyClass;
  use Mojo::Base -base, -signatures;

  use Mojo::DynamicMethods -dispatch;

  sub BUILD_DYNAMIC ($class, $method, $dyn_methods) {
    return sub {...};
  }

  sub add_helper ($self, $name, $cb) {
    Mojo::DynamicMethods::register 'MyClass', $self, $name, $cb;
  }

  package main;

  # Generate methods dynamically (and hide them from "$obj->can(...)")
  my $obj = MyClass->new;
  $obj->add_helper(foo => sub { warn 'Hello Helper!' });
  $obj->foo;

=head1 DESCRIPTION

L<Mojo::DynamicMethods> provides dynamic method dispatch for per-object helper methods without requiring use of
C<AUTOLOAD>.

To opt your class into dynamic dispatch simply pass the C<-dispatch> flag.

  use Mojo::DynamicMethods -dispatch;

And then implement a C<BUILD_DYNAMIC> method in your class, making sure that the key you use to lookup methods in
C<$dyn_methods> is the same thing you pass as C<$ref> to L</"register">.

  sub BUILD_DYNAMIC ($class, $method, $dyn_methods) {
    return sub ($self, @args) {
      my $dynamic = $dyn_methods->{$self}{$method};
      return $self->$dynamic(@args) if $dynamic;
      my $package = ref $self;
      croak qq{Can't locate object method "$method" via package "$package"};
    };
  }

Note that this module will summon B<Cthulhu>, use it at your own risk!

=head1 FUNCTIONS

L<Mojo::DynamicMethods> implements the following functions.

=head2 register

  Mojo::DynamicMethods::register $class, $ref, $name, $cb;

Registers the method C<$name> as eligible for dynamic dispatch for C<$class>, and sets C<$cb> to be looked up for
C<$name> by reference C<$ref> in a dynamic method constructed by C<BUILD_DYNAMIC>.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::JSON;
use Mojo::Base -strict;

use Carp         qw(croak);
use Exporter     qw(import);
use JSON::PP     ();
use Mojo::Util   qw(decode encode monkey_patch);
use Scalar::Util qw(blessed);

# For better performance Cpanel::JSON::XS is required
use constant JSON_XS => $ENV{MOJO_NO_JSON_XS}
  ? 0
  : !!eval { require Cpanel::JSON::XS; Cpanel::JSON::XS->VERSION('4.09'); 1 };

our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);

# Escaped special character map
my %ESCAPE
  = ('"' => '"', '\\' => '\\', '/' => '/', 'b' => "\x08", 'f' => "\x0c", 'n' => "\x0a", 'r' => "\x0d", 't' => "\x09");
my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;
for (0x00 .. 0x1f) { $REVERSE{pack 'C', $_} //= sprintf '\u%.4X', $_ }

# Replace pure-Perl fallbacks if Cpanel::JSON::XS is available
if (JSON_XS) {
  my $BINARY = Cpanel::JSON::XS->new->utf8;
  my $TEXT   = Cpanel::JSON::XS->new;
  $_->canonical->allow_nonref->allow_unknown->allow_blessed->convert_blessed->stringify_infnan->escape_slash
    ->allow_dupkeys
    for $BINARY, $TEXT;
  monkey_patch __PACKAGE__, 'encode_json', sub { $BINARY->encode($_[0]) };
  monkey_patch __PACKAGE__, 'decode_json', sub { $BINARY->decode($_[0]) };
  monkey_patch __PACKAGE__, 'to_json',     sub { $TEXT->encode($_[0]) };
  monkey_patch __PACKAGE__, 'from_json',   sub { $TEXT->decode($_[0]) };
}

sub decode_json {
  my $err = _decode(\my $value, shift);
  return defined $err ? croak $err : $value;
}

sub encode_json { encode('UTF-8', _encode_value(shift)) }

sub false () {JSON::PP::false}

sub from_json {
  my $err = _decode(\my $value, shift, 1);
  return defined $err ? croak $err : $value;
}

sub j {
  return encode_json($_[0]) if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
  return scalar eval { decode_json($_[0]) };
}

sub to_json { _encode_value(shift) }

sub true () {JSON::PP::true}

sub _decode {
  my $valueref = shift;

  eval {

    # Missing input
    die "Missing or empty input at offset 0\n" unless length(local $_ = shift);

    # UTF-8
    $_ = decode('UTF-8', $_)           unless shift;
    die "Input is not UTF-8 encoded\n" unless defined;

    # Value
    $$valueref = _decode_value();

    # Leftover data
    /\G[\x20\x09\x0a\x0d]*\z/gc or _throw('Unexpected data');
  } ? return undef : chomp $@;

  return $@;
}

sub _decode_array {
  my @array;
  until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {

    # Value
    push @array, _decode_value();

    # Separator
    redo if /\G[\x20\x09\x0a\x0d]*,/gc;

    # End
    last if /\G[\x20\x09\x0a\x0d]*\]/gc;

    # Invalid character
    _throw('Expected comma or right square bracket while parsing array');
  }

  return \@array;
}

sub _decode_object {
  my %hash;
  until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {

    # Quote
    /\G[\x20\x09\x0a\x0d]*"/gc or _throw('Expected string while parsing object');

    # Key
    my $key = _decode_string();

    # Colon
    /\G[\x20\x09\x0a\x0d]*:/gc or _throw('Expected colon while parsing object');

    # Value
    $hash{$key} = _decode_value();

    # Separator
    redo if /\G[\x20\x09\x0a\x0d]*,/gc;

    # End
    last if /\G[\x20\x09\x0a\x0d]*\}/gc;

    # Invalid character
    _throw('Expected comma or right curly bracket while parsing object');
  }

  return \%hash;
}

sub _decode_string {
  my $pos = pos;

  # Extract string with escaped characters
  m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc;
  my $str = $1;

  # Invalid character
  unless (m/\G"/gc) {
    _throw('Unexpected character or invalid escape while parsing string') if /\G[\x00-\x1f\\]/;
    _throw('Unterminated string');
  }

  # Unescape popular characters
  if (index($str, '\\u') < 0) {
    $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
    return $str;
  }

  # Unescape everything else
  my $buffer = '';
  while ($str =~ /\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
    $buffer .= $1;

    # Popular character
    if ($2) { $buffer .= $ESCAPE{$2} }

    # Escaped
    else {
      my $ord = hex $3;

      # Surrogate pair
      if (($ord & 0xf800) == 0xd800) {

        # High surrogate
        ($ord & 0xfc00) == 0xd800 or pos = $pos + pos($str), _throw('Missing high-surrogate');

        # Low surrogate
        $str =~ /\G\\u([Dd][C-Fc-f]..)/gc or pos = $pos + pos($str), _throw('Missing low-surrogate');

        $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
      }

      # Character
      $buffer .= pack 'U', $ord;
    }
  }

  # The rest
  return $buffer . substr $str, pos($str), length($str);
}

sub _decode_value {

  # Leading whitespace
  /\G[\x20\x09\x0a\x0d]*/gc;

  # String
  return _decode_string() if /\G"/gc;

  # Object
  return _decode_object() if /\G\{/gc;

  # Array
  return _decode_array() if /\G\[/gc;

  # Number
  return 0 + $1 if /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;

  # True
  return true() if /\Gtrue/gc;

  # False
  return false() if /\Gfalse/gc;

  # Null
  return undef if /\Gnull/gc;

  # Invalid character
  _throw('Expected string, array, object, number, boolean or null');
}

sub _encode_array {
  '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
}

sub _encode_object {
  my $object = shift;
  my @pairs  = map { _encode_string($_) . ':' . _encode_value($object->{$_}) } sort keys %$object;
  return '{' . join(',', @pairs) . '}';
}

sub _encode_string {
  my $str = shift;
  $str =~ s!([\x00-\x1f\\"/])!$REVERSE{$1}!gs;
  return "\"$str\"";
}

sub _encode_value {
  my $value = shift;

  # Reference
  if (my $ref = ref $value) {

    # Object
    return _encode_object($value) if $ref eq 'HASH';

    # Array
    return _encode_array($value) if $ref eq 'ARRAY';

    # True or false
    return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
    return $value  ? 'true' : 'false' if $ref eq 'JSON::PP::Boolean';

    # Everything else
    return 'null' unless blessed $value;
    return _encode_string($value) unless my $sub = $value->can('TO_JSON');
    return _encode_value($value->$sub);
  }

  # Null
  return 'null' unless defined $value;

  # Number
  no warnings 'numeric';
  return $value
    if !utf8::is_utf8($value) && length((my $dummy = '') & $value) && 0 + $value eq $value && $value * 0 == 0;

  # String
  return _encode_string($value);
}

sub _throw {

  # Leading whitespace
  /\G[\x20\x09\x0a\x0d]*/gc;

  # Context
  my $context = 'Malformed JSON: ' . shift;
  if (m/\G\z/gc) { $context .= ' before end of data' }
  else {
    my @lines = split /\n/, substr($_, 0, pos);
    $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
  }

  die "$context\n";
}

1;

=encoding utf8

=head1 NAME

Mojo::JSON - Minimalistic JSON

=head1 SYNOPSIS

  use Mojo::JSON qw(decode_json encode_json);

  my $bytes = encode_json {foo => [1, 2], bar => 'hello!', baz => \1};
  my $hash  = decode_json $bytes;

=head1 DESCRIPTION

L<Mojo::JSON> is a minimalistic and possibly the fastest pure-Perl implementation of L<RFC
8259|https://tools.ietf.org/html/rfc8259>.

It supports normal Perl data types like scalar, array reference, hash reference and will try to call the C<TO_JSON>
method on blessed references, or stringify them if it doesn't exist. Differentiating between strings and numbers in
Perl is hard, depending on how it has been used, a scalar can be both at the same time. The string value has a higher
precedence unless both representations are equivalent.

  [1, -2, 3]     -> [1, -2, 3]
  {"foo": "bar"} -> {foo => 'bar'}

Literal names will be translated to and from L<Mojo::JSON> constants or a similar native Perl value.

  true  -> Mojo::JSON->true
  false -> Mojo::JSON->false
  null  -> undef

In addition scalar references will be used to generate booleans, based on if their values are true or false.

  \1 -> true
  \0 -> false

The character C</> will always be escaped to prevent XSS attacks.

  "</script>" -> "<\/script>"

For better performance the optional module L<Cpanel::JSON::XS> (4.09+) will be used automatically if possible. This can
also be disabled with the C<MOJO_NO_JSON_XS> environment variable.

=head1 FUNCTIONS

L<Mojo::JSON> implements the following functions, which can be imported individually.

=head2 decode_json

  my $value = decode_json $bytes;

Decode JSON to Perl value and die if decoding fails.

=head2 encode_json

  my $bytes = encode_json {i => 'â™¥ mojolicious'};

Encode Perl value to JSON.

=head2 false

  my $false = false;

False value, used because Perl has no native equivalent.

=head2 from_json

  my $value = from_json $chars;

Decode JSON text that is not C<UTF-8> encoded to Perl value and die if decoding fails.

=head2 j

  my $bytes = j [1, 2, 3];
  my $bytes = j {i => 'â™¥ mojolicious'};
  my $value = j $bytes;

Encode Perl data structure (which may only be an array reference or hash reference) or decode JSON, an C<undef> return
value indicates a bare C<null> or that decoding failed.

=head2 to_json

  my $chars = to_json {i => 'â™¥ mojolicious'};

Encode Perl value to JSON text without C<UTF-8> encoding it.

=head2 true

  my $true = true;

True value, used because Perl has no native equivalent.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Log;
use Mojo::Base 'Mojo::EventEmitter';

use Carp  qw(croak);
use Fcntl qw(:flock);
use Mojo::File;
use Mojo::Util      qw(encode);
use Term::ANSIColor qw(colored);
use Time::HiRes     qw(time);

has color  => sub { $ENV{MOJO_LOG_COLOR} };
has format => sub { $_[0]->short ? \&_short : $_[0]->color ? \&_color : \&_default };
has handle => sub {

  # STDERR
  return \*STDERR unless my $path = shift->path;

  # File
  return Mojo::File->new($path)->open('>>');
};
has history          => sub { [] };
has level            => 'trace';
has max_history_size => 10;
has 'path';
has short => sub { $ENV{MOJO_LOG_SHORT} };

# Supported log levels
my %LEVEL = (trace => 1, debug => 2, info => 3, warn => 4, error => 5, fatal => 6);

# Systemd magic numbers
my %MAGIC = (trace => 7, debug => 6, info => 5, warn => 4, error => 3, fatal => 2);

# Colors
my %COLORS = (warn => ['yellow'], error => ['red'], fatal => ['white on_red']);

sub append {
  my ($self, $msg) = @_;

  return unless my $handle = $self->handle;
  flock $handle, LOCK_EX;
  $handle->print(encode('UTF-8', $msg)) or croak "Can't write to log: $!";
  flock $handle, LOCK_UN;
}

sub capture {
  my ($self, $level) = @_;

  croak 'Log messages are already being captured' if $self->{capturing}++;

  my $original = $self->level;
  $self->level($level || $original);
  my $subscribers = $self->subscribers('message');
  $self->unsubscribe('message');

  my $capture = Mojo::Log::_Capture->new(sub {
    delete $self->level($original)->unsubscribe('message')->{capturing};
    $self->on(message => $_) for @$subscribers;
  });
  my $messages = $capture->{messages};
  $self->on(
    message => sub {
      my $self = shift;
      push @$messages, $self->format->(time, @_);
    }
  );

  return $capture;
}

sub context {
  my ($self, @context) = @_;
  return $self->new(parent => $self, context => \@context, level => $self->level);
}

sub debug { 2 >= $LEVEL{$_[0]->level} ? _log(@_, 'debug') : $_[0] }

sub error { 5 >= $LEVEL{$_[0]->level} ? _log(@_, 'error') : $_[0] }
sub fatal { 6 >= $LEVEL{$_[0]->level} ? _log(@_, 'fatal') : $_[0] }
sub info  { 3 >= $LEVEL{$_[0]->level} ? _log(@_, 'info')  : $_[0] }

sub is_level { $LEVEL{pop()} >= $LEVEL{shift->level} }

sub new {
  my $self = shift->SUPER::new(@_);
  $self->on(message => \&_message);
  return $self;
}

sub trace { 1 >= $LEVEL{$_[0]->level} ? _log(@_, 'trace') : $_[0] }
sub warn  { 4 >= $LEVEL{$_[0]->level} ? _log(@_, 'warn')  : $_[0] }

sub _color {
  my $msg = _default(shift, my $level = shift, @_);
  return $COLORS{$level} ? colored($COLORS{$level}, $msg) : $msg;
}

sub _default {
  my ($time, $level) = (shift, shift);
  my ($s, $m, $h, $day, $month, $year) = localtime $time;
  $time = sprintf '%04d-%02d-%02d %02d:%02d:%08.5f', $year + 1900, $month + 1, $day, $h, $m,
    "$s." . ((split /\./, $time)[1] // 0);
  return "[$time] [$$] [$level] " . join(' ', @_) . "\n";
}

sub _log {
  my ($self, $level) = (shift, pop);
  my @msgs = ref $_[0] eq 'CODE' ? $_[0]() : @_;
  unshift @msgs, @{$self->{context}} if $self->{context};
  ($self->{parent} || $self)->emit('message', $level, @msgs);
}

sub _message {
  my ($self, $level) = (shift, shift);

  my $max     = $self->max_history_size;
  my $history = $self->history;
  push @$history, my $msg = [time, $level, @_];
  shift @$history while @$history > $max;

  $self->append($self->format->(@$msg));
}

sub _short {
  my ($time, $level) = (shift, shift);
  my ($magic, $short) = ("<$MAGIC{$level}>", substr($level, 0, 1));
  return "${magic}[$$] [$short] " . join(' ', @_) . "\n";
}

package Mojo::Log::_Capture;
use Mojo::Base -base;
use overload
  bool     => sub {1},
  '@{}'    => sub { shift->{messages} },
  '""'     => sub { join '', @{shift->{messages}} },
  fallback => 1;

use Mojo::Util qw(scope_guard);

sub new {
  my ($class, $cb) = @_;
  return $class->SUPER::new(guard => scope_guard($cb), messages => []);
}

1;

=encoding utf8

=head1 NAME

Mojo::Log - Simple logger

=head1 SYNOPSIS

  use Mojo::Log;

  # Log to STDERR
  my $log = Mojo::Log->new;

  # Customize log file location and minimum log level
  my $log = Mojo::Log->new(path => '/var/log/mojo.log', level => 'warn');

  # Log messages
  $log->trace('Doing stuff');
  $log->debug('Not sure what is happening here');
  $log->info('FYI: it happened again');
  $log->warn('This might be a problem');
  $log->error('Garden variety error');
  $log->fatal('Boom');

=head1 DESCRIPTION

L<Mojo::Log> is a simple logger for L<Mojo> projects.

=head1 EVENTS

L<Mojo::Log> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 message

  $log->on(message => sub ($log, $level, @lines) {...});

Emitted when a new message gets logged.

  $log->on(message => sub ($log, $level, @lines) { say "$level: ", @lines });

=head1 ATTRIBUTES

L<Mojo::Log> implements the following attributes.

=head2 color

  my $bool = $log->color;
  $log     = $log->color($bool);

Colorize log messages with the levels C<warn>, C<error> and C<fatal> using L<Term::ANSIColor>, defaults to the value of
the C<MOJO_LOG_COLOR> environment variables. Note that this attribute is B<EXPERIMENTAL> and might change without
warning!

=head2 format

  my $cb = $log->format;
  $log   = $log->format(sub {...});

A callback for formatting log messages.

  $log->format(sub ($time, $level, @lines) { "[2018-11-08 14:20:13.77168] [28320] [info] I â™¥ Mojolicious\n" });

=head2 handle

  my $handle = $log->handle;
  $log       = $log->handle(IO::Handle->new);

Log filehandle used by default L</"message"> event, defaults to opening L</"path"> or C<STDERR>.

=head2 history

  my $history = $log->history;
  $log        = $log->history([[time, 'debug', 'That went wrong']]);

The last few logged messages.

=head2 level

  my $level = $log->level;
  $log      = $log->level('debug');

Active log level, defaults to C<trace>. Available log levels are C<trace>, C<debug>, C<info>, C<warn>, C<error> and
C<fatal>, in that order.

=head2 max_history_size

  my $size = $log->max_history_size;
  $log     = $log->max_history_size(5);

Maximum number of logged messages to store in L</"history">, defaults to C<10>.

=head2 path

  my $path = $log->path
  $log     = $log->path('/var/log/mojo.log');

Log file path used by L</"handle">.

=head2 short

  my $bool = $log->short;
  $log     = $log->short($bool);

Generate short log messages without a timestamp but with journald log level prefix, suitable for systemd environments,
defaults to the value of the C<MOJO_LOG_SHORT> environment variables.

=head1 METHODS

L<Mojo::Log> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 append

  $log->append("[2018-11-08 14:20:13.77168] [28320] [info] I â™¥ Mojolicious\n");

Append message to L</"handle">.

=head2 capture

  my $messages = $log->capture;
  my $messages = $log->capture('debug');

Capture log messages for as long as the returned object exists, useful for testing log messages.

  # Test your log messages
  my $messages = $log->capture('trace');
  $log->fatal('Something very bad happened');
  $log->trace('Just some debug information');
  like $messages, qr/Something very bad happened/, 'logs contain fatal message';
  like $messages->[-1], qr/Just some debug information/, 'trace message was last';
  undef $messages;

=head2 context

  my $new = $log->context('[extra]', '[information]');

Construct a new child L<Mojo::Log> object that will include context information with every log message.

  # Log with context
  my $log = Mojo::Log->new;
  my $context = $log->context('[17a60115]');
  $context->debug('This is a log message with context information');
  $context->info('And another');

=head2 debug

  $log = $log->debug('You screwed up, but that is ok');
  $log = $log->debug('All', 'cool');
  $log = $log->debug(sub {...});

Emit L</"message"> event and log C<debug> message.

=head2 error

  $log = $log->error('You really screwed up this time');
  $log = $log->error('Wow', 'seriously');
  $log = $log->error(sub {...});

Emit L</"message"> event and log C<error> message.

=head2 fatal

  $log = $log->fatal('Its over...');
  $log = $log->fatal('Bye', 'bye');
  $log = $log->fatal(sub {...});

Emit L</"message"> event and log C<fatal> message.

=head2 info

  $log = $log->info('You are bad, but you prolly know already');
  $log = $log->info('Ok', 'then');
  $log = $log->info(sub {...});

Emit L</"message"> event and log C<info> message.

=head2 is_level

  my $bool = $log->is_level('debug');

Check active log L</"level">.

  # True
  $log->level('debug')->is_level('debug');
  $log->level('debug')->is_level('info');

  # False
  $log->level('info')->is_level('debug');
  $log->level('fatal')->is_level('warn');

=head2 new

  my $log = Mojo::Log->new;
  my $log = Mojo::Log->new(level => 'warn');
  my $log = Mojo::Log->new({level => 'warn'});

Construct a new L<Mojo::Log> object and subscribe to L</"message"> event with default logger.

=head2 trace

  $log = $log->trace('Whatever');
  $log = $log->trace('Who', 'cares');
  $log = $log->trace(sub {...});

Emit L</"message"> event and log C<trace> message.

=head2 warn

  $log = $log->warn('Dont do that Dave...');
  $log = $log->warn('No', 'really');
  $log = $log->warn(sub {...});

Emit L</"message"> event and log C<warn> message.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Reactor;
use Mojo::Base 'Mojo::EventEmitter';

use Carp qw(croak);
use Config;
use Mojo::Loader qw(load_class);

my %DETECTED;

sub again { croak 'Method "again" not implemented by subclass' }

sub detect {
  my $default = 'Mojo::Reactor::' . ($Config{d_pseudofork} ? 'Poll' : 'EV');
  my $try     = $ENV{MOJO_REACTOR} || $default;
  return $DETECTED{$try} ||= load_class($try) ? 'Mojo::Reactor::Poll' : $try;
}

sub io         { croak 'Method "io" not implemented by subclass' }
sub is_running { croak 'Method "is_running" not implemented by subclass' }
sub next_tick  { croak 'Method "next_tick" not implemented by subclass' }
sub one_tick   { croak 'Method "one_tick" not implemented by subclass' }
sub recurring  { croak 'Method "recurring" not implemented by subclass' }
sub remove     { croak 'Method "remove" not implemented by subclass' }
sub reset      { croak 'Method "reset" not implemented by subclass' }
sub start      { croak 'Method "start" not implemented by subclass' }
sub stop       { croak 'Method "stop" not implemented by subclass' }
sub timer      { croak 'Method "timer" not implemented by subclass' }
sub watch      { croak 'Method "watch" not implemented by subclass' }

1;

=encoding utf8

=head1 NAME

Mojo::Reactor - Low-level event reactor base class

=head1 SYNOPSIS

  package Mojo::Reactor::MyEventLoop;
  use Mojo::Base 'Mojo::Reactor';

  sub again      {...}
  sub io         {...}
  sub is_running {...}
  sub next_tick  {...}
  sub one_tick   {...}
  sub recurring  {...}
  sub remove     {...}
  sub reset      {...}
  sub start      {...}
  sub stop       {...}
  sub timer      {...}
  sub watch      {...}

=head1 DESCRIPTION

L<Mojo::Reactor> is an abstract base class for low-level event reactors, like L<Mojo::Reactor::EV> and
L<Mojo::Reactor::Poll>.

=head1 EVENTS

L<Mojo::Reactor> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 error

  $reactor->on(error => sub ($reactor, $err) {...});

Emitted for exceptions caught in callbacks, fatal if unhandled. Note that if this event is unhandled or fails it might
kill your program, so you need to be careful.

  $reactor->on(error => sub ($reactor, $err) { say "Something very bad happened: $err" });

=head1 METHODS

L<Mojo::Reactor> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 again

  $reactor->again($id);
  $reactor->again($id, 0.5);

Restart timer and optionally change the invocation time. Meant to be overloaded in a subclass. Note that this method
requires an active timer.

=head2 detect

  my $class = Mojo::Reactor->detect;

Detect and load the best reactor implementation available, will try the value of the C<MOJO_REACTOR> environment
variable, L<Mojo::Reactor::EV> or L<Mojo::Reactor::Poll>.

  # Instantiate best reactor implementation available
  my $reactor = Mojo::Reactor->detect->new;

=head2 io

  $reactor = $reactor->io($handle => sub {...});

Watch handle for I/O events, invoking the callback whenever handle becomes readable or writable. Meant to be overloaded
in a subclass.

  # Callback will be executed twice if handle becomes readable and writable
  $reactor->io($handle => sub ($reactor, $writable) {
    say $writable ? 'Handle is writable' : 'Handle is readable';
  });

=head2 is_running

  my $bool = $reactor->is_running;

Check if reactor is running. Meant to be overloaded in a subclass.

=head2 next_tick

  my $undef = $reactor->next_tick(sub {...});

Execute callback as soon as possible, but not before returning or other callbacks that have been registered with this
method, always returns C<undef>. Meant to be overloaded in a subclass.

=head2 one_tick

  $reactor->one_tick;

Run reactor until an event occurs. Note that this method can recurse back into the reactor, so you need to be careful.
Meant to be overloaded in a subclass.

  # Don't block longer than 0.5 seconds
  my $id = $reactor->timer(0.5 => sub {});
  $reactor->one_tick;
  $reactor->remove($id);

=head2 recurring

  my $id = $reactor->recurring(0.25 => sub {...});

Create a new recurring timer, invoking the callback repeatedly after a given amount of time in seconds. Meant to be
overloaded in a subclass.

=head2 remove

  my $bool = $reactor->remove($handle);
  my $bool = $reactor->remove($id);

Remove handle or timer. Meant to be overloaded in a subclass.

=head2 reset

  $reactor->reset;

Remove all handles and timers. Meant to be overloaded in a subclass.

=head2 start

  $reactor->start;

Start watching for I/O and timer events, this will block until L</"stop"> is called. Note that some reactors stop
automatically if there are no events being watched anymore. Meant to be overloaded in a subclass.

  # Start reactor only if it is not running already
  $reactor->start unless $reactor->is_running;

=head2 stop

  $reactor->stop;

Stop watching for I/O and timer events. Meant to be overloaded in a subclass.

=head2 timer

  my $id = $reactor->timer(0.5 => sub {...});

Create a new timer, invoking the callback after a given amount of time in seconds. Meant to be overloaded in a
subclass.

=head2 watch

  $reactor = $reactor->watch($handle, $readable, $writable);

Change I/O events to watch handle for with true and false values. Meant to be overloaded in a subclass. Note that this
method requires an active I/O watcher.

  # Watch only for readable events
  $reactor->watch($handle, 1, 0);

  # Watch only for writable events
  $reactor->watch($handle, 0, 1);

  # Watch for readable and writable events
  $reactor->watch($handle, 1, 1);

  # Pause watching for events
  $reactor->watch($handle, 0, 0);

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Collection;
use Mojo::Base -strict;

use re       qw(is_regexp);
use Carp     qw(croak);
use Exporter qw(import);
use List::Util;
use Mojo::ByteStream;
use Scalar::Util qw(blessed);

our @EXPORT_OK = ('c');

sub TO_JSON { [@{shift()}] }

sub c { __PACKAGE__->new(@_) }

sub compact {
  my $self = shift;
  return $self->new(grep { defined && (ref || length) } @$self);
}

sub each {
  my ($self, $cb) = @_;
  return @$self unless $cb;
  my $i = 1;
  $_->$cb($i++) for @$self;
  return $self;
}

sub first {
  my ($self, $cb) = (shift, shift);
  return $self->[0] unless $cb;
  return List::Util::first { $_ =~ $cb } @$self if is_regexp $cb;
  return List::Util::first { $_->$cb(@_) } @$self;
}

sub flatten { $_[0]->new(_flatten(@{$_[0]})) }

sub grep {
  my ($self, $cb) = (shift, shift);
  return $self->new(grep { $_ =~ $cb } @$self) if is_regexp $cb;
  return $self->new(grep { $_->$cb(@_) } @$self);
}

sub head {
  my ($self, $size) = @_;
  return $self->new(@$self)                   if $size > @$self;
  return $self->new(@$self[0 .. ($size - 1)]) if $size >= 0;
  return $self->new(@$self[0 .. ($#$self + $size)]);
}

sub join {
  Mojo::ByteStream->new(join $_[1] // '', map {"$_"} @{$_[0]});
}

sub last { shift->[-1] }

sub map {
  my ($self, $cb) = (shift, shift);
  return $self->new(map { $_->$cb(@_) } @$self);
}

sub new {
  my $class = shift;
  return bless [@_], ref $class || $class;
}

sub reduce {
  my $self = shift;
  @_ = (@_, @$self);
  goto &List::Util::reduce;
}

sub reverse { $_[0]->new(reverse @{$_[0]}) }

sub shuffle { $_[0]->new(List::Util::shuffle @{$_[0]}) }

sub size { scalar @{$_[0]} }

sub sort {
  my ($self, $cb) = @_;

  return $self->new(sort @$self) unless $cb;

  my $caller = caller;
  no strict 'refs';
  my @sorted = sort {
    local (*{"${caller}::a"}, *{"${caller}::b"}) = (\$a, \$b);
    $a->$cb($b);
  } @$self;
  return $self->new(@sorted);
}

sub tail {
  my ($self, $size) = @_;
  return $self->new(@$self)                                     if $size > @$self;
  return $self->new(@$self[($#$self - ($size - 1)) .. $#$self]) if $size >= 0;
  return $self->new(@$self[(0 - $size) .. $#$self]);
}

sub tap { shift->Mojo::Base::tap(@_) }

sub to_array { [@{shift()}] }

sub uniq {
  my ($self, $cb) = (shift, shift);
  my %seen;
  return $self->new(grep { !$seen{$_->$cb(@_) // ''}++ } @$self) if $cb;
  return $self->new(grep { !$seen{$_ // ''}++ } @$self);
}

sub with_roles { shift->Mojo::Base::with_roles(@_) }

sub _flatten {
  map { _ref($_) ? _flatten(@$_) : $_ } @_;
}

sub _ref { ref $_[0] eq 'ARRAY' || blessed $_[0] && $_[0]->isa(__PACKAGE__) }

1;

=encoding utf8

=head1 NAME

Mojo::Collection - Collection

=head1 SYNOPSIS

  use Mojo::Collection;

  # Manipulate collection
  my $collection = Mojo::Collection->new(qw(just works));
  unshift @$collection, 'it';
  say $collection->join("\n");

  # Chain methods
  $collection->map(sub { ucfirst })->shuffle->each(sub ($word, $num) {
    say "$num: $word";
  });

  # Use the alternative constructor
  use Mojo::Collection qw(c);
  c(qw(a b c))->join('/')->url_escape->say;

=head1 DESCRIPTION

L<Mojo::Collection> is an array-based container for collections.

  # Access array directly to manipulate collection
  my $collection = Mojo::Collection->new(1 .. 25);
  $collection->[23] += 100;
  say for @$collection;

=head1 FUNCTIONS

L<Mojo::Collection> implements the following functions, which can be imported individually.

=head2 c

  my $collection = c(1, 2, 3);

Construct a new array-based L<Mojo::Collection> object.

=head1 METHODS

L<Mojo::Collection> implements the following methods.

=head2 TO_JSON

  my $array = $collection->TO_JSON;

Alias for L</"to_array">.

=head2 compact

  my $new = $collection->compact;

Create a new collection with all elements that are defined and not an empty string.

  # "0, 1, 2, 3"
  c(0, 1, undef, 2, '', 3)->compact->join(', ');

=head2 each

  my @elements = $collection->each;
  $collection  = $collection->each(sub {...});

Evaluate callback for each element in collection, or return all elements as a list if none has been provided. The
element will be the first argument passed to the callback, and is also available as C<$_>.

  # Make a numbered list
  $collection->each(sub ($e, $num) {
    say "$num: $e";
  });

=head2 first

  my $first = $collection->first;
  my $first = $collection->first(qr/foo/);
  my $first = $collection->first(sub {...});
  my $first = $collection->first('some_method');
  my $first = $collection->first('some_method', @args);

Evaluate regular expression/callback for, or call method on, each element in collection and return the first one that
matched the regular expression, or for which the callback/method returned true. The element will be the first argument
passed to the callback, and is also available as C<$_>.

  # Longer version
  my $first = $collection->first(sub { $_->some_method(@args) });

  # Find first value that contains the word "mojo"
  my $interesting = $collection->first(qr/mojo/i);

  # Find first value that is greater than 5
  my $greater = $collection->first(sub { $_ > 5 });

=head2 flatten

  my $new = $collection->flatten;

Flatten nested collections/arrays recursively and create a new collection with all elements.

  # "1, 2, 3, 4, 5, 6, 7"
  c(1, [2, [3, 4], 5, [6]], 7)->flatten->join(', ');

=head2 grep

  my $new = $collection->grep(qr/foo/);
  my $new = $collection->grep(sub {...});
  my $new = $collection->grep('some_method');
  my $new = $collection->grep('some_method', @args);

Evaluate regular expression/callback for, or call method on, each element in collection and create a new collection
with all elements that matched the regular expression, or for which the callback/method returned true. The element will
be the first argument passed to the callback, and is also available as C<$_>.

  # Longer version
  my $new = $collection->grep(sub { $_->some_method(@args) });

  # Find all values that contain the word "mojo"
  my $interesting = $collection->grep(qr/mojo/i);

  # Find all values that are greater than 5
  my $greater = $collection->grep(sub { $_ > 5 });

=head2 head

  my $new = $collection->head(4);
  my $new = $collection->head(-2);

Create a new collection with up to the specified number of elements from the beginning of the collection. A negative
number will count from the end.

  # "A B C"
  c('A', 'B', 'C', 'D', 'E')->head(3)->join(' ');

  # "A B"
  c('A', 'B', 'C', 'D', 'E')->head(-3)->join(' ');

=head2 join

  my $stream = $collection->join;
  my $stream = $collection->join("\n");

Turn collection into L<Mojo::ByteStream>.

  # Join all values with commas
  $collection->join(', ')->say;

=head2 last

  my $last = $collection->last;

Return the last element in collection.

=head2 map

  my $new = $collection->map(sub {...});
  my $new = $collection->map('some_method');
  my $new = $collection->map('some_method', @args);

Evaluate callback for, or call method on, each element in collection and create a new collection from the results. The
element will be the first argument passed to the callback, and is also available as C<$_>.

  # Longer version
  my $new = $collection->map(sub { $_->some_method(@args) });

  # Append the word "mojo" to all values
  my $mojoified = $collection->map(sub { $_ . 'mojo' });

=head2 new

  my $collection = Mojo::Collection->new(1, 2, 3);

Construct a new array-based L<Mojo::Collection> object.

=head2 reduce

  my $result = $collection->reduce(sub {...});
  my $result = $collection->reduce(sub {...}, $initial);

Reduce elements in collection with a callback and return its final result, setting C<$a> and C<$b> each time the
callback is executed. The first time C<$a> will be set to an optional initial value or the first element in the
collection. And from then on C<$a> will be set to the return value of the callback, while C<$b> will always be set to
the next element in the collection.

  # Calculate the sum of all values
  my $sum = $collection->reduce(sub { $a + $b });

  # Count how often each value occurs in collection
  my $hash = $collection->reduce(sub { $a->{$b}++; $a }, {});

=head2 reverse

  my $new = $collection->reverse;

Create a new collection with all elements in reverse order.

=head2 shuffle

  my $new = $collection->shuffle;

Create a new collection with all elements in random order.

=head2 size

  my $size = $collection->size;

Number of elements in collection.

=head2 sort

  my $new = $collection->sort;
  my $new = $collection->sort(sub {...});

Sort elements based on return value of a callback and create a new collection from the results, setting C<$a> and C<$b>
to the elements being compared, each time the callback is executed.

  # Sort values case-insensitive
  my $case_insensitive = $collection->sort(sub { uc($a) cmp uc($b) });

=head2 tail

  my $new = $collection->tail(4);
  my $new = $collection->tail(-2);

Create a new collection with up to the specified number of elements from the end of the collection. A negative number
will count from the beginning.

  # "C D E"
  c('A', 'B', 'C', 'D', 'E')->tail(3)->join(' ');

  # "D E"
  c('A', 'B', 'C', 'D', 'E')->tail(-3)->join(' ');

=head2 tap

  $collection = $collection->tap(sub {...});

Alias for L<Mojo::Base/"tap">.

=head2 to_array

  my $array = $collection->to_array;

Turn collection into array reference.

=head2 uniq

  my $new = $collection->uniq;
  my $new = $collection->uniq(sub {...});
  my $new = $collection->uniq('some_method');
  my $new = $collection->uniq('some_method', @args);

Create a new collection without duplicate elements, using the string representation of either the elements or the
return value of the callback/method to decide uniqueness. Note that C<undef> and empty string are treated the same.

  # Longer version
  my $new = $collection->uniq(sub { $_->some_method(@args) });

  # "foo bar baz"
  c('foo', 'bar', 'bar', 'baz')->uniq->join(' ');

  # "[[1, 2], [2, 1]]"
  c([1, 2], [2, 1], [3, 2])->uniq(sub{ $_->[1] })->to_array;

=head2 with_roles

  my $new_class = Mojo::Collection->with_roles('Mojo::Collection::Role::One');
  my $new_class = Mojo::Collection->with_roles('+One', '+Two');
  $collection   = $collection->with_roles('+One', '+Two');

Alias for L<Mojo::Base/"with_roles">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::DOM;
use Mojo::Base -strict;
use overload
  '@{}'    => sub { shift->child_nodes },
  '%{}'    => sub { shift->attr },
  bool     => sub {1},
  '""'     => sub { shift->to_string },
  fallback => 1;

# "Fry: This snow is beautiful. I'm glad global warming never happened.
#  Leela: Actually, it did. But thank God nuclear winter canceled it out."
use Mojo::Collection;
use Mojo::DOM::CSS;
use Mojo::DOM::HTML;
use Scalar::Util qw(blessed weaken);
use Storable     qw(dclone);

sub all_text { _text(_nodes($_[0]->tree), $_[0]->xml, 1) }

sub ancestors { _select($_[0]->_collect([_ancestors($_[0]->tree)]), $_[1]) }

sub append         { shift->_add(1, @_) }
sub append_content { shift->_content(1, 0, @_) }

sub at {
  my $self = shift;
  return undef unless my $result = $self->_css->select_one(@_);
  return $self->_build($result, $self->xml);
}

sub attr {
  my $self = shift;

  # Hash
  my $tree  = $self->tree;
  my $attrs = $tree->[0] ne 'tag' ? {} : $tree->[2];
  return $attrs unless @_;

  # Get
  return $attrs->{$_[0]} unless @_ > 1 || ref $_[0];

  # Set
  my $values = ref $_[0] ? $_[0] : {@_};
  @$attrs{keys %$values} = values %$values;

  return $self;
}

sub child_nodes { $_[0]->_collect(_nodes($_[0]->tree)) }

sub children { _select($_[0]->_collect(_nodes($_[0]->tree, 1)), $_[1]) }

sub content {
  my $self = shift;

  my $type = $self->type;
  if ($type eq 'root' || $type eq 'tag') {
    return $self->_content(0, 1, @_) if @_;
    my $html = Mojo::DOM::HTML->new(xml => $self->xml);
    return join '', map { $html->tree($_)->render } @{_nodes($self->tree)};
  }

  return $self->tree->[1] unless @_;
  $self->tree->[1] = shift;
  return $self;
}

sub descendant_nodes { $_[0]->_collect(_all(_nodes($_[0]->tree))) }

sub find {
  my $self = shift;
  return $self->_collect($self->_css->select(@_));
}

sub following       { _select($_[0]->_collect(_siblings($_[0]->tree, 1, 1)), $_[1]) }
sub following_nodes { $_[0]->_collect(_siblings($_[0]->tree, 0, 1)) }

sub matches { shift->_css->matches(@_) }

sub namespace {
  my $self = shift;

  return undef if (my $tree = $self->tree)->[0] ne 'tag';

  # Extract namespace prefix and search parents
  my $ns = $tree->[1] =~ /^(.*?):/ ? "xmlns:$1" : undef;
  for my $node ($tree, _ancestors($tree)) {

    # Namespace for prefix
    my $attrs = $node->[2];
    if ($ns) { $_ eq $ns and return $attrs->{$_} for keys %$attrs }

    # Namespace attribute
    elsif (defined $attrs->{xmlns}) { return $attrs->{xmlns} }
  }

  return undef;
}

sub new {
  my $class = shift;
  my $self  = bless \Mojo::DOM::HTML->new, ref $class || $class;
  return @_ ? $self->parse(@_) : $self;
}

sub new_tag {
  my $self = shift;
  my $new  = $self->new;
  $$new->tag(@_);
  $$new->xml($$self->xml) if ref $self;
  return $new;
}

sub next      { $_[0]->_maybe(_siblings($_[0]->tree, 1, 1, 0)) }
sub next_node { $_[0]->_maybe(_siblings($_[0]->tree, 0, 1, 0)) }

sub parent {
  my $self = shift;
  return undef if (my $tree = $self->tree)->[0] eq 'root';
  return $self->_build(_parent($tree), $self->xml);
}

sub parse { ${$_[0]}->parse($_[1]) and return $_[0] }

sub preceding       { _select($_[0]->_collect(_siblings($_[0]->tree, 1, 0)), $_[1]) }
sub preceding_nodes { $_[0]->_collect(_siblings($_[0]->tree, 0)) }

sub prepend         { shift->_add(0, @_) }
sub prepend_content { shift->_content(0, 0, @_) }

sub previous      { $_[0]->_maybe(_siblings($_[0]->tree, 1, 0, -1)) }
sub previous_node { $_[0]->_maybe(_siblings($_[0]->tree, 0, 0, -1)) }

sub remove { shift->replace('') }

sub replace {
  my ($self, $new) = @_;
  return $self->parse($new) if (my $tree = $self->tree)->[0] eq 'root';
  return $self->_replace(_parent($tree), $tree, _nodes($self->_parse($new)));
}

sub root {
  my $self = shift;
  return $self unless my $tree = _ancestors($self->tree, 1);
  return $self->_build($tree, $self->xml);
}

sub selector {
  return undef unless (my $tree = shift->tree)->[0] eq 'tag';
  return join ' > ', reverse map { $_->[1] . ':nth-child(' . (@{_siblings($_, 1)} + 1) . ')' } $tree, _ancestors($tree);
}

sub strip {
  my $self = shift;
  return $self if (my $tree = $self->tree)->[0] ne 'tag';
  return $self->_replace($tree->[3], $tree, _nodes($tree));
}

sub tag {
  my ($self, $tag) = @_;
  return undef if (my $tree = $self->tree)->[0] ne 'tag';
  return $tree->[1] unless $tag;
  $tree->[1] = $tag;
  return $self;
}

sub tap { shift->Mojo::Base::tap(@_) }

sub text { _text(_nodes(shift->tree), 0, 0) }

sub to_string { ${shift()}->render }

sub tree { @_ > 1 ? (${$_[0]}->tree($_[1]) and return $_[0]) : ${$_[0]}->tree }

sub type { shift->tree->[0] }

sub val {
  my $self = shift;

  # "option"
  return $self->{value} // $self->text if (my $tag = $self->tag) eq 'option';

  # "input" ("type=checkbox" and "type=radio")
  my $type = $self->{type} // '';
  return $self->{value} // 'on' if $tag eq 'input' && ($type eq 'radio' || $type eq 'checkbox');

  # "textarea", "input" or "button"
  return $tag eq 'textarea' ? $self->text : $self->{value} if $tag ne 'select';

  # "select"
  my $v = $self->find('option:checked:not([disabled])')->grep(sub { !$_->ancestors('optgroup[disabled]')->size })
    ->map('val');
  return exists $self->{multiple} ? $v->size ? $v->to_array : undef : $v->last;
}

sub with_roles { shift->Mojo::Base::with_roles(@_) }

sub wrap         { shift->_wrap(0, @_) }
sub wrap_content { shift->_wrap(1, @_) }

sub xml { @_ > 1 ? (${$_[0]}->xml($_[1]) and return $_[0]) : ${$_[0]}->xml }

sub _add {
  my ($self, $offset, $new) = @_;

  return $self if (my $tree = $self->tree)->[0] eq 'root';

  my $parent = _parent($tree);
  splice @$parent, _offset($parent, $tree) + $offset, 0, @{_link($parent, _nodes($self->_parse($new)))};

  return $self;
}

sub _all {
  my $nodes = shift;
  @$nodes = map { $_->[0] eq 'tag' ? ($_, @{_all(_nodes($_))}) : ($_) } @$nodes;
  return $nodes;
}

sub _ancestors {
  my ($tree, $root) = @_;

  return () unless $tree = _parent($tree);
  my @ancestors;
  do { push @ancestors, $tree } while ($tree->[0] eq 'tag') && ($tree = $tree->[3]);
  return $root ? $ancestors[-1] : @ancestors[0 .. $#ancestors - 1];
}

sub _build { shift->new->tree(shift)->xml(shift) }

sub _collect {
  my ($self, $nodes) = (shift, shift // []);
  my $xml = $self->xml;
  return Mojo::Collection->new(map { $self->_build($_, $xml) } @$nodes);
}

sub _content {
  my ($self, $start, $offset, $new) = @_;

  my $tree = $self->tree;
  unless ($tree->[0] eq 'root' || $tree->[0] eq 'tag') {
    my $old = $self->content;
    return $self->content($start ? $old . $new : $new . $old);
  }

  $start  = $start  ? ($#$tree + 1) : _start($tree);
  $offset = $offset ? $#$tree       : 0;
  splice @$tree, $start, $offset, @{_link($tree, _nodes($self->_parse($new)))};

  return $self;
}

sub _css { Mojo::DOM::CSS->new(tree => shift->tree) }

sub _fragment { _link(my $r = ['root', @_], [@_]); $r }

sub _link {
  my ($parent, $children) = @_;

  # Link parent to children
  for my $node (@$children) {
    my $offset = $node->[0] eq 'tag' ? 3 : 2;
    $node->[$offset] = $parent;
    weaken $node->[$offset];
  }

  return $children;
}

sub _maybe { $_[1] ? $_[0]->_build($_[1], $_[0]->xml) : undef }

sub _nodes {
  return () unless my $tree = shift;
  my @nodes = @$tree[_start($tree) .. $#$tree];
  return shift() ? [grep { $_->[0] eq 'tag' } @nodes] : \@nodes;
}

sub _offset {
  my ($parent, $child) = @_;
  my $i = _start($parent);
  $_ eq $child ? last : $i++ for @$parent[$i .. $#$parent];
  return $i;
}

sub _parent { $_[0]->[$_[0][0] eq 'tag' ? 3 : 2] }

sub _parse {
  my ($self, $input) = @_;
  return Mojo::DOM::HTML->new(xml => $self->xml)->parse($input)->tree unless blessed $input && $input->isa('Mojo::DOM');
  my $tree = dclone $input->tree;
  return $tree->[0] eq 'root' ? $tree : _fragment($tree);
}

sub _replace {
  my ($self, $parent, $child, $nodes) = @_;
  splice @$parent, _offset($parent, $child), 1, @{_link($parent, $nodes)};
  return $self->parent;
}

sub _select { $_[1] ? $_[0]->grep(matches => $_[1]) : $_[0] }

sub _siblings {
  my ($tree, $tags, $tail, $i) = @_;

  return defined $i ? undef : [] if $tree->[0] eq 'root';

  my $nodes = _nodes(_parent($tree));
  my $match = -1;
  defined($match++) and $_ eq $tree and last for @$nodes;

  if ($tail) { splice @$nodes, 0, $match + 1 }
  else       { splice @$nodes, $match, ($#$nodes + 1) - $match }

  @$nodes = grep { $_->[0] eq 'tag' } @$nodes if $tags;

  return defined $i ? $i == -1 && !@$nodes ? undef : $nodes->[$i] : $nodes;
}

sub _start { $_[0][0] eq 'root' ? 1 : 4 }

sub _text {
  my ($nodes, $xml, $all) = @_;

  my $text = '';
  while (my $node = shift @$nodes) {
    my $type = $node->[0];

    # Text
    if ($type eq 'text' || $type eq 'cdata' || $type eq 'raw') { $text .= $node->[1] }

    # Nested tag
    elsif ($type eq 'tag' && $all) {
      unshift @$nodes, @{_nodes($node)} if $xml || ($node->[1] ne 'script' && $node->[1] ne 'style');
    }
  }

  return $text;
}

sub _wrap {
  my ($self, $content, $new) = @_;

  return $self if (my $tree = $self->tree)->[0] eq 'root' && !$content;
  return $self if $tree->[0] ne 'root' && $tree->[0] ne 'tag' && $content;

  # Find innermost tag
  my $current;
  my $first = $new = $self->_parse($new);
  $current = $first while $first = _nodes($first, 1)->[0];
  return $self unless $current;

  # Wrap content
  if ($content) {
    push @$current, @{_link($current, _nodes($tree))};
    splice @$tree, _start($tree), $#$tree, @{_link($tree, _nodes($new))};
    return $self;
  }

  # Wrap element
  $self->_replace(_parent($tree), $tree, _nodes($new));
  push @$current, @{_link($current, [$tree])};
  return $self;
}

1;

=encoding utf8

=head1 NAME

Mojo::DOM - Minimalistic HTML/XML DOM parser with CSS selectors

=head1 SYNOPSIS

  use Mojo::DOM;

  # Parse
  my $dom = Mojo::DOM->new('<div><p id="a">Test</p><p id="b">123</p></div>');

  # Find
  say $dom->at('#b')->text;
  say $dom->find('p')->map('text')->join("\n");
  say $dom->find('[id]')->map(attr => 'id')->join("\n");

  # Iterate
  $dom->find('p[id]')->reverse->each(sub { say $_->{id} });

  # Loop
  for my $e ($dom->find('p[id]')->each) {
    say $e->{id}, ':', $e->text;
  }

  # Modify
  $dom->find('div p')->last->append('<p id="c">456</p>');
  $dom->at('#c')->prepend($dom->new_tag('p', id => 'd', '789'));
  $dom->find(':not(p)')->map('strip');

  # Render
  say "$dom";

=head1 DESCRIPTION

L<Mojo::DOM> is a minimalistic and relaxed HTML/XML DOM parser with CSS selector support. It will even try to interpret
broken HTML and XML, so you should not use it for validation.

=head1 NODES AND ELEMENTS

When we parse an HTML/XML fragment, it gets turned into a tree of nodes.

  <!DOCTYPE html>
  <html>
    <head><title>Hello</title></head>
    <body>World!</body>
  </html>

There are currently eight different kinds of nodes, C<cdata>, C<comment>, C<doctype>, C<pi>, C<raw>, C<root>, C<tag>
and C<text>. Elements are nodes of the type C<tag>.

  root
  |- doctype (html)
  +- tag (html)
     |- tag (head)
     |  +- tag (title)
     |     +- raw (Hello)
     +- tag (body)
        +- text (World!)

While all node types are represented as L<Mojo::DOM> objects, some methods like L</"attr"> and L</"namespace"> only
apply to elements.

=head1 HTML AND XML

L<Mojo::DOM> defaults to HTML semantics, that means all tags and attribute names are lowercased and selectors need to
be lowercase as well.

  # HTML semantics
  my $dom = Mojo::DOM->new('<P ID="greeting">Hi!</P>');
  say $dom->at('p[id]')->text;

If an XML declaration is found, the parser will automatically switch into XML mode and everything becomes
case-sensitive.

  # XML semantics
  my $dom = Mojo::DOM->new('<?xml version="1.0"?><P ID="greeting">Hi!</P>');
  say $dom->at('P[ID]')->text;

HTML or XML semantics can also be forced with the L</"xml"> method.

  # Force HTML semantics
  my $dom = Mojo::DOM->new->xml(0)->parse('<P ID="greeting">Hi!</P>');
  say $dom->at('p[id]')->text;

  # Force XML semantics
  my $dom = Mojo::DOM->new->xml(1)->parse('<P ID="greeting">Hi!</P>');
  say $dom->at('P[ID]')->text;

=head1 METHODS

L<Mojo::DOM> implements the following methods.

=head2 all_text

  my $text = $dom->all_text;

Extract text content from all descendant nodes of this element. For HTML documents C<script> and C<style> elements are
excluded.

  # "foo\nbarbaz\n"
  $dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->all_text;

=head2 ancestors

  my $collection = $dom->ancestors;
  my $collection = $dom->ancestors('div ~ p');

Find all ancestor elements of this node matching the CSS selector and return a L<Mojo::Collection> object containing
these elements as L<Mojo::DOM> objects. All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.

  # List tag names of ancestor elements
  say $dom->ancestors->map('tag')->join("\n");

=head2 append

  $dom = $dom->append('<p>I â™¥ Mojolicious!</p>');
  $dom = $dom->append(Mojo::DOM->new);

Append HTML/XML fragment to this node (for all node types other than C<root>).

  # "<div><h1>Test</h1><h2>123</h2></div>"
  $dom->parse('<div><h1>Test</h1></div>')
    ->at('h1')->append('<h2>123</h2>')->root;

  # "<p>Test 123</p>"
  $dom->parse('<p>Test</p>')->at('p')
    ->child_nodes->first->append(' 123')->root;

=head2 append_content

  $dom = $dom->append_content('<p>I â™¥ Mojolicious!</p>');
  $dom = $dom->append_content(Mojo::DOM->new);

Append HTML/XML fragment (for C<root> and C<tag> nodes) or raw content to this node's content.

  # "<div><h1>Test123</h1></div>"
  $dom->parse('<div><h1>Test</h1></div>')
    ->at('h1')->append_content('123')->root;

  # "<!-- Test 123 --><br>"
  $dom->parse('<!-- Test --><br>')
    ->child_nodes->first->append_content('123 ')->root;

  # "<p>Test<i>123</i></p>"
  $dom->parse('<p>Test</p>')->at('p')->append_content('<i>123</i>')->root;

=head2 at

  my $result = $dom->at('div ~ p');
  my $result = $dom->at('svg|line', svg => 'http://www.w3.org/2000/svg');

Find first descendant element of this element matching the CSS selector and return it as a L<Mojo::DOM> object, or
C<undef> if none could be found. All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.

  # Find first element with "svg" namespace definition
  my $namespace = $dom->at('[xmlns\:svg]')->{'xmlns:svg'};

Trailing key/value pairs can be used to declare xml namespace aliases.

  # "<rect />"
  $dom->parse('<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>')
    ->at('svg|rect', svg => 'http://www.w3.org/2000/svg');

=head2 attr

  my $hash = $dom->attr;
  my $foo  = $dom->attr('foo');
  $dom     = $dom->attr({foo => 'bar'});
  $dom     = $dom->attr(foo => 'bar');

This element's attributes.

  # Remove an attribute
  delete $dom->attr->{id};

  # Attribute without value
  $dom->attr(selected => undef);

  # List id attributes
  say $dom->find('*')->map(attr => 'id')->compact->join("\n");

=head2 child_nodes

  my $collection = $dom->child_nodes;

Return a L<Mojo::Collection> object containing all child nodes of this element as L<Mojo::DOM> objects.

  # "<p><b>123</b></p>"
  $dom->parse('<p>Test<b>123</b></p>')->at('p')->child_nodes->first->remove;

  # "<!DOCTYPE html>"
  $dom->parse('<!DOCTYPE html><b>123</b>')->child_nodes->first;

  # " Test "
  $dom->parse('<b>123</b><!-- Test -->')->child_nodes->last->content;

=head2 children

  my $collection = $dom->children;
  my $collection = $dom->children('div ~ p');

Find all child elements of this element matching the CSS selector and return a L<Mojo::Collection> object containing
these elements as L<Mojo::DOM> objects. All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.

  # Show tag name of random child element
  say $dom->children->shuffle->first->tag;

=head2 content

  my $str = $dom->content;
  $dom    = $dom->content('<p>I â™¥ Mojolicious!</p>');
  $dom    = $dom->content(Mojo::DOM->new);

Return this node's content or replace it with HTML/XML fragment (for C<root> and C<tag> nodes) or raw content.

  # "<b>Test</b>"
  $dom->parse('<div><b>Test</b></div>')->at('div')->content;

  # "<div><h1>123</h1></div>"
  $dom->parse('<div><h1>Test</h1></div>')->at('h1')->content('123')->root;

  # "<p><i>123</i></p>"
  $dom->parse('<p>Test</p>')->at('p')->content('<i>123</i>')->root;

  # "<div><h1></h1></div>"
  $dom->parse('<div><h1>Test</h1></div>')->at('h1')->content('')->root;

  # " Test "
  $dom->parse('<!-- Test --><br>')->child_nodes->first->content;

  # "<div><!-- 123 -->456</div>"
  $dom->parse('<div><!-- Test -->456</div>')
    ->at('div')->child_nodes->first->content(' 123 ')->root;

=head2 descendant_nodes

  my $collection = $dom->descendant_nodes;

Return a L<Mojo::Collection> object containing all descendant nodes of this element as L<Mojo::DOM> objects.

  # "<p><b>123</b></p>"
  $dom->parse('<p><!-- Test --><b>123<!-- 456 --></b></p>')
    ->descendant_nodes->grep(sub { $_->type eq 'comment' })
    ->map('remove')->first;

  # "<p><b>test</b>test</p>"
  $dom->parse('<p><b>123</b>456</p>')
    ->at('p')->descendant_nodes->grep(sub { $_->type eq 'text' })
    ->map(content => 'test')->first->root;

=head2 find

  my $collection = $dom->find('div ~ p');
  my $collection = $dom->find('svg|line', svg => 'http://www.w3.org/2000/svg');

Find all descendant elements of this element matching the CSS selector and return a L<Mojo::Collection> object
containing these elements as L<Mojo::DOM> objects. All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.

  # Find a specific element and extract information
  my $id = $dom->find('div')->[23]{id};

  # Extract information from multiple elements
  my @headers = $dom->find('h1, h2, h3')->map('text')->each;

  # Count all the different tags
  my $hash = $dom->find('*')->reduce(sub { $a->{$b->tag}++; $a }, {});

  # Find elements with a class that contains dots
  my @divs = $dom->find('div.foo\.bar')->each;

Trailing key/value pairs can be used to declare xml namespace aliases.

  # "<rect />"
  $dom->parse('<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>')
    ->find('svg|rect', svg => 'http://www.w3.org/2000/svg')->first;

=head2 following

  my $collection = $dom->following;
  my $collection = $dom->following('div ~ p');

Find all sibling elements after this node matching the CSS selector and return a L<Mojo::Collection> object containing
these elements as L<Mojo::DOM> objects. All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.

  # List tags of sibling elements after this node
  say $dom->following->map('tag')->join("\n");

=head2 following_nodes

  my $collection = $dom->following_nodes;

Return a L<Mojo::Collection> object containing all sibling nodes after this node as L<Mojo::DOM> objects.

  # "C"
  $dom->parse('<p>A</p><!-- B -->C')->at('p')->following_nodes->last->content;

=head2 matches

  my $bool = $dom->matches('div ~ p');
  my $bool = $dom->matches('svg|line', svg => 'http://www.w3.org/2000/svg');

Check if this element matches the CSS selector. All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.

  # True
  $dom->parse('<p class="a">A</p>')->at('p')->matches('.a');
  $dom->parse('<p class="a">A</p>')->at('p')->matches('p[class]');

  # False
  $dom->parse('<p class="a">A</p>')->at('p')->matches('.b');
  $dom->parse('<p class="a">A</p>')->at('p')->matches('p[id]');

Trailing key/value pairs can be used to declare xml namespace aliases.

  # True
  $dom->parse('<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>')
    ->matches('svg|rect', svg => 'http://www.w3.org/2000/svg');

=head2 namespace

  my $namespace = $dom->namespace;

Find this element's namespace, or return C<undef> if none could be found.

  # "http://www.w3.org/2000/svg"
  Mojo::DOM->new('<svg xmlns:svg="http://www.w3.org/2000/svg"><svg:circle>3.14</svg:circle></svg>')->at('svg\:circle')->namespace;

  # Find namespace for an element with namespace prefix
  my $namespace = $dom->at('svg > svg\:circle')->namespace;

  # Find namespace for an element that may or may not have a namespace prefix
  my $namespace = $dom->at('svg > circle')->namespace;

=head2 new

  my $dom = Mojo::DOM->new;
  my $dom = Mojo::DOM->new('<foo bar="baz">I â™¥ Mojolicious!</foo>');

Construct a new scalar-based L<Mojo::DOM> object and L</"parse"> HTML/XML fragment if necessary.

=head2 new_tag

  my $tag = Mojo::DOM->new_tag('div');
  my $tag = $dom->new_tag('div');
  my $tag = $dom->new_tag('div', id => 'foo', hidden => undef);
  my $tag = $dom->new_tag('div', 'safe content');
  my $tag = $dom->new_tag('div', id => 'foo', 'safe content');
  my $tag = $dom->new_tag('div', data => {mojo => 'rocks'}, 'safe content');
  my $tag = $dom->new_tag('div', id => 'foo', sub { 'unsafe content' });

Construct a new L<Mojo::DOM> object for an HTML/XML tag with or without attributes and content. The C<data> attribute
may contain a hash reference with key/value pairs to generate attributes from.

  # "<br>"
  $dom->new_tag('br');

  # "<div></div>"
  $dom->new_tag('div');

  # "<div id="foo" hidden></div>"
  $dom->new_tag('div', id => 'foo', hidden => undef);

  # "<div>test &amp; 123</div>"
  $dom->new_tag('div', 'test & 123');

  # "<div id="foo">test &amp; 123</div>"
  $dom->new_tag('div', id => 'foo', 'test & 123');

  # "<div data-foo="1" data-bar="test">test &amp; 123</div>""
  $dom->new_tag('div', data => {foo => 1, Bar => 'test'}, 'test & 123');

  # "<div id="foo">test & 123</div>"
  $dom->new_tag('div', id => 'foo', sub { 'test & 123' });

  # "<div>Hello<b>Mojo!</b></div>"
  $dom->parse('<div>Hello</div>')->at('div')
    ->append_content($dom->new_tag('b', 'Mojo!'))->root;

=head2 next

  my $sibling = $dom->next;

Return L<Mojo::DOM> object for next sibling element, or C<undef> if there are no more siblings.

  # "<h2>123</h2>"
  $dom->parse('<div><h1>Test</h1><h2>123</h2></div>')->at('h1')->next;

=head2 next_node

  my $sibling = $dom->next_node;

Return L<Mojo::DOM> object for next sibling node, or C<undef> if there are no more siblings.

  # "456"
  $dom->parse('<p><b>123</b><!-- Test -->456</p>')
    ->at('b')->next_node->next_node;

  # " Test "
  $dom->parse('<p><b>123</b><!-- Test -->456</p>')
    ->at('b')->next_node->content;

=head2 parent

  my $parent = $dom->parent;

Return L<Mojo::DOM> object for parent of this node, or C<undef> if this node has no parent.

  # "<b><i>Test</i></b>"
  $dom->parse('<p><b><i>Test</i></b></p>')->at('i')->parent;

=head2 parse

  $dom = $dom->parse('<foo bar="baz">I â™¥ Mojolicious!</foo>');

Parse HTML/XML fragment with L<Mojo::DOM::HTML>.

  # Parse XML
  my $dom = Mojo::DOM->new->xml(1)->parse('<foo>I â™¥ Mojolicious!</foo>');

=head2 preceding

  my $collection = $dom->preceding;
  my $collection = $dom->preceding('div ~ p');

Find all sibling elements before this node matching the CSS selector and return a L<Mojo::Collection> object containing
these elements as L<Mojo::DOM> objects. All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.

  # List tags of sibling elements before this node
  say $dom->preceding->map('tag')->join("\n");

=head2 preceding_nodes

  my $collection = $dom->preceding_nodes;

Return a L<Mojo::Collection> object containing all sibling nodes before this node as L<Mojo::DOM> objects.

  # "A"
  $dom->parse('A<!-- B --><p>C</p>')->at('p')->preceding_nodes->first->content;

=head2 prepend

  $dom = $dom->prepend('<p>I â™¥ Mojolicious!</p>');
  $dom = $dom->prepend(Mojo::DOM->new);

Prepend HTML/XML fragment to this node (for all node types other than C<root>).

  # "<div><h1>Test</h1><h2>123</h2></div>"
  $dom->parse('<div><h2>123</h2></div>')
    ->at('h2')->prepend('<h1>Test</h1>')->root;

  # "<p>Test 123</p>"
  $dom->parse('<p>123</p>')
    ->at('p')->child_nodes->first->prepend('Test ')->root;

=head2 prepend_content

  $dom = $dom->prepend_content('<p>I â™¥ Mojolicious!</p>');
  $dom = $dom->prepend_content(Mojo::DOM->new);

Prepend HTML/XML fragment (for C<root> and C<tag> nodes) or raw content to this node's content.

  # "<div><h2>Test123</h2></div>"
  $dom->parse('<div><h2>123</h2></div>')
    ->at('h2')->prepend_content('Test')->root;

  # "<!-- Test 123 --><br>"
  $dom->parse('<!-- 123 --><br>')
    ->child_nodes->first->prepend_content(' Test')->root;

  # "<p><i>123</i>Test</p>"
  $dom->parse('<p>Test</p>')->at('p')->prepend_content('<i>123</i>')->root;

=head2 previous

  my $sibling = $dom->previous;

Return L<Mojo::DOM> object for previous sibling element, or C<undef> if there are no more siblings.

  # "<h1>Test</h1>"
  $dom->parse('<div><h1>Test</h1><h2>123</h2></div>')->at('h2')->previous;

=head2 previous_node

  my $sibling = $dom->previous_node;

Return L<Mojo::DOM> object for previous sibling node, or C<undef> if there are no more siblings.

  # "123"
  $dom->parse('<p>123<!-- Test --><b>456</b></p>')
    ->at('b')->previous_node->previous_node;

  # " Test "
  $dom->parse('<p>123<!-- Test --><b>456</b></p>')
    ->at('b')->previous_node->content;

=head2 remove

  my $parent = $dom->remove;

Remove this node and return L</"root"> (for C<root> nodes) or L</"parent">.

  # "<div></div>"
  $dom->parse('<div><h1>Test</h1></div>')->at('h1')->remove;

  # "<p><b>456</b></p>"
  $dom->parse('<p>123<b>456</b></p>')
    ->at('p')->child_nodes->first->remove->root;

=head2 replace

  my $parent = $dom->replace('<div>I â™¥ Mojolicious!</div>');
  my $parent = $dom->replace(Mojo::DOM->new);

Replace this node with HTML/XML fragment and return L</"root"> (for C<root> nodes) or L</"parent">.

  # "<div><h2>123</h2></div>"
  $dom->parse('<div><h1>Test</h1></div>')->at('h1')->replace('<h2>123</h2>');

  # "<p><b>123</b></p>"
  $dom->parse('<p>Test</p>')
    ->at('p')->child_nodes->[0]->replace('<b>123</b>')->root;

=head2 root

  my $root = $dom->root;

Return L<Mojo::DOM> object for C<root> node.

=head2 selector

  my $selector = $dom->selector;

Get a unique CSS selector for this element.

  # "ul:nth-child(1) > li:nth-child(2)"
  $dom->parse('<ul><li>Test</li><li>123</li></ul>')->find('li')->last->selector;

  # "p:nth-child(1) > b:nth-child(1) > i:nth-child(1)"
  $dom->parse('<p><b><i>Test</i></b></p>')->at('i')->selector;

=head2 strip

  my $parent = $dom->strip;

Remove this element while preserving its content and return L</"parent">.

  # "<div>Test</div>"
  $dom->parse('<div><h1>Test</h1></div>')->at('h1')->strip;

=head2 tag

  my $tag = $dom->tag;
  $dom    = $dom->tag('div');

This element's tag name.

  # List tag names of child elements
  say $dom->children->map('tag')->join("\n");

=head2 tap

  $dom = $dom->tap(sub {...});

Alias for L<Mojo::Base/"tap">.

=head2 text

  my $text = $dom->text;

Extract text content from this element only (not including child elements).

  # "bar"
  $dom->parse("<div>foo<p>bar</p>baz</div>")->at('p')->text;

  # "foo\nbaz\n"
  $dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->text;

To extract text content from all descendant nodes see L</"all_text">.

=head2 to_string

  my $str = $dom->to_string;

Render this node and its content to HTML/XML.

  # "<b>Test</b>"
  $dom->parse('<div><b>Test</b></div>')->at('div b')->to_string;

=head2 tree

  my $tree = $dom->tree;
  $dom     = $dom->tree(['root']);

Document Object Model. Note that this structure should only be used very carefully since it is very dynamic.

=head2 type

  my $type = $dom->type;

This node's type, usually C<cdata>, C<comment>, C<doctype>, C<pi>, C<raw>, C<root>, C<tag> or C<text>.

  # "cdata"
  $dom->parse('<![CDATA[Test]]>')->child_nodes->first->type;

  # "comment"
  $dom->parse('<!-- Test -->')->child_nodes->first->type;

  # "doctype"
  $dom->parse('<!DOCTYPE html>')->child_nodes->first->type;

  # "pi"
  $dom->parse('<?xml version="1.0"?>')->child_nodes->first->type;

  # "raw"
  $dom->parse('<title>Test</title>')->at('title')->child_nodes->first->type;

  # "root"
  $dom->parse('<p>Test</p>')->type;

  # "tag"
  $dom->parse('<p>Test</p>')->at('p')->type;

  # "text"
  $dom->parse('<p>Test</p>')->at('p')->child_nodes->first->type;

=head2 val

  my $value = $dom->val;

Extract value from form element (such as C<button>, C<input>, C<option>, C<select> and C<textarea>), or return C<undef>
if this element has no value. In the case of C<select> with C<multiple> attribute, find C<option> elements with
C<selected> attribute and return an array reference with all values, or C<undef> if none could be found.

  # "a"
  $dom->parse('<input name=test value=a>')->at('input')->val;

  # "b"
  $dom->parse('<textarea>b</textarea>')->at('textarea')->val;

  # "c"
  $dom->parse('<option value="c">Test</option>')->at('option')->val;

  # "d"
  $dom->parse('<select><option selected>d</option></select>')
    ->at('select')->val;

  # "e"
  $dom->parse('<select multiple><option selected>e</option></select>')
    ->at('select')->val->[0];

  # "on"
  $dom->parse('<input name=test type=checkbox>')->at('input')->val;

=head2 with_roles

  my $new_class = Mojo::DOM->with_roles('Mojo::DOM::Role::One');
  my $new_class = Mojo::DOM->with_roles('+One', '+Two');
  $dom          = $dom->with_roles('+One', '+Two');

Alias for L<Mojo::Base/"with_roles">.

=head2 wrap

  $dom = $dom->wrap('<div></div>');
  $dom = $dom->wrap(Mojo::DOM->new);

Wrap HTML/XML fragment around this node (for all node types other than C<root>), placing it as the last child of the
first innermost element.

  # "<p>123<b>Test</b></p>"
  $dom->parse('<b>Test</b>')->at('b')->wrap('<p>123</p>')->root;

  # "<div><p><b>Test</b></p>123</div>"
  $dom->parse('<b>Test</b>')->at('b')->wrap('<div><p></p>123</div>')->root;

  # "<p><b>Test</b></p><p>123</p>"
  $dom->parse('<b>Test</b>')->at('b')->wrap('<p></p><p>123</p>')->root;

  # "<p><b>Test</b></p>"
  $dom->parse('<p>Test</p>')->at('p')->child_nodes->first->wrap('<b>')->root;

=head2 wrap_content

  $dom = $dom->wrap_content('<div></div>');
  $dom = $dom->wrap_content(Mojo::DOM->new);

Wrap HTML/XML fragment around this node's content (for C<root> and C<tag> nodes), placing it as the last children of
the first innermost element.

  # "<p><b>123Test</b></p>"
  $dom->parse('<p>Test<p>')->at('p')->wrap_content('<b>123</b>')->root;

  # "<p><b>Test</b></p><p>123</p>"
  $dom->parse('<b>Test</b>')->wrap_content('<p></p><p>123</p>');

=head2 xml

  my $bool = $dom->xml;
  $dom     = $dom->xml($bool);

Disable HTML semantics in parser and activate case-sensitivity, defaults to auto-detection based on XML declarations.

=head1 OPERATORS

L<Mojo::DOM> overloads the following operators.

=head2 array

  my @nodes = @$dom;

Alias for L</"child_nodes">.

  # "<!-- Test -->"
  $dom->parse('<!-- Test --><b>123</b>')->[0];

=head2 bool

  my $bool = !!$dom;

Always true.

=head2 hash

  my %attrs = %$dom;

Alias for L</"attr">.

  # "test"
  $dom->parse('<div id="test">Test</div>')->at('div')->{id};

=head2 stringify

  my $str = "$dom";

Alias for L</"to_string">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Reactor::EV;
use Mojo::Base 'Mojo::Reactor::Poll';

use Carp qw(croak);
use EV 4.32;

my $EV;

sub DESTROY { undef $EV }

sub again {
  my ($self, $id, $after) = @_;
  croak 'Timer not active' unless my $timer = $self->{timers}{$id};
  my $w = $timer->{watcher};
  defined $after ? $w->set($after, $w->repeat ? $after : 0) : $w->again;
}

# We have to fall back to Mojo::Reactor::Poll, since EV is unique
sub new { $EV++ ? Mojo::Reactor::Poll->new : shift->SUPER::new }

sub one_tick {
  my $self = shift;
  local $self->{running} = 1 unless $self->{running};
  EV::run(EV::RUN_ONCE);
}

sub recurring { shift->_timer(1, @_) }

sub start {
  my $self = shift;
  local $self->{running} = 1 unless $self->{running};
  EV::run;
}

sub stop { EV::break(EV::BREAK_ALL) }

sub timer { shift->_timer(0, @_) }

sub watch {
  my ($self, $handle, $read, $write) = @_;

  my $fd = fileno $handle;
  croak 'I/O watcher not active' unless my $io = $self->{io}{$fd};

  my $mode = 0;
  $mode |= EV::READ  if $read;
  $mode |= EV::WRITE if $write;

  if    ($mode == 0)             { delete $io->{watcher} }
  elsif (my $w = $io->{watcher}) { $w->events($mode) }
  else {
    my $cb = sub {
      my ($w, $revents) = @_;
      $self->_try('I/O watcher', $self->{io}{$fd}{cb}, 0) if EV::READ & $revents;
      $self->_try('I/O watcher', $self->{io}{$fd}{cb}, 1) if EV::WRITE & $revents && $self->{io}{$fd};
    };
    $io->{watcher} = EV::io($fd, $mode, $cb);
  }

  return $self;
}

sub _timer {
  my ($self, $recurring, $after, $cb) = @_;
  $after ||= 0.0001 if $recurring;

  my $id      = $self->_id;
  my $wrapper = sub {
    delete $self->{timers}{$id} unless $recurring;
    $self->_try('Timer', $cb);
  };
  EV::now_update() if $after > 0;
  $self->{timers}{$id}{watcher} = EV::timer($after, $after, $wrapper);

  return $id;
}

1;

=encoding utf8

=head1 NAME

Mojo::Reactor::EV - Low-level event reactor with libev support

=head1 SYNOPSIS

  use Mojo::Reactor::EV;

  # Watch if handle becomes readable or writable
  my $reactor = Mojo::Reactor::EV->new;
  $reactor->io($first => sub ($reactor, $writable) {
    say $writable ? 'First handle is writable' : 'First handle is readable';
  });

  # Change to watching only if handle becomes writable
  $reactor->watch($first, 0, 1);

  # Turn file descriptor into handle and watch if it becomes readable
  my $second = IO::Handle->new_from_fd($fd, 'r');
  $reactor->io($second => sub ($reactor, $writable) {
    say $writable ? 'Second handle is writable' : 'Second handle is readable';
  })->watch($second, 1, 0);

  # Add a timer
  $reactor->timer(15 => sub ($reactor) {
    $reactor->remove($first);
    $reactor->remove($second);
    say 'Timeout!';
  });

  # Start reactor if necessary
  $reactor->start unless $reactor->is_running;

=head1 DESCRIPTION

L<Mojo::Reactor::EV> is a low-level event reactor based on L<EV> (4.32+).

=head1 EVENTS

L<Mojo::Reactor::EV> inherits all events from L<Mojo::Reactor::Poll>.

=head1 METHODS

L<Mojo::Reactor::EV> inherits all methods from L<Mojo::Reactor::Poll> and implements the following new ones.

=head2 again

  $reactor->again($id);
  $reactor->again($id, 0.5);

Restart timer and optionally change the invocation time. Note that this method requires an active timer.

=head2 new

  my $reactor = Mojo::Reactor::EV->new;

Construct a new L<Mojo::Reactor::EV> object.

=head2 one_tick

  $reactor->one_tick;

Run reactor until an event occurs or no events are being watched anymore.

  # Don't block longer than 0.5 seconds
  my $id = $reactor->timer(0.5 => sub {});
  $reactor->one_tick;
  $reactor->remove($id);

=head2 recurring

  my $id = $reactor->recurring(0.25 => sub {...});

Create a new recurring timer, invoking the callback repeatedly after a given amount of time in seconds.

=head2 start

  $reactor->start;

Start watching for I/O and timer events, this will block until L</"stop"> is called or no events are being watched
anymore.

  # Start reactor only if it is not running already
  $reactor->start unless $reactor->is_running;

=head2 stop

  $reactor->stop;

Stop watching for I/O and timer events.

=head2 timer

  my $id = $reactor->timer(0.5 => sub {...});

Create a new timer, invoking the callback after a given amount of time in seconds.

=head2 watch

  $reactor = $reactor->watch($handle, $readable, $writable);

Change I/O events to watch handle for with true and false values. Note that this method requires an active I/O watcher.

  # Watch only for readable events
  $reactor->watch($handle, 1, 0);

  # Watch only for writable events
  $reactor->watch($handle, 0, 1);

  # Watch for readable and writable events
  $reactor->watch($handle, 1, 1);

  # Pause watching for events
  $reactor->watch($handle, 0, 0);

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Reactor::Poll;
use Mojo::Base 'Mojo::Reactor';

use Carp        qw(croak);
use IO::Poll    qw(POLLERR POLLHUP POLLIN POLLNVAL POLLOUT POLLPRI);
use List::Util  qw(min);
use Mojo::Util  qw(md5_sum steady_time);
use Time::HiRes qw(usleep);

sub again {
  my ($self, $id, $after) = @_;
  croak 'Timer not active' unless my $timer = $self->{timers}{$id};
  $timer->{after} = $after if defined $after;
  $timer->{time}  = steady_time + $timer->{after};
}

sub io {
  my ($self, $handle, $cb) = @_;
  $self->{io}{fileno($handle) // croak 'Handle is closed'} = {cb => $cb};
  return $self->watch($handle, 1, 1);
}

sub is_running { !!shift->{running} }

sub next_tick {
  my ($self, $cb) = @_;
  push @{$self->{next_tick}}, $cb;
  $self->{next_timer} //= $self->timer(0 => \&_next);
  return undef;
}

sub one_tick {
  my $self = shift;

  # Just one tick
  local $self->{running} = 1 unless $self->{running};

  # Wait for one event
  my $i;
  until ($i || !$self->{running}) {

    # Stop automatically if there is nothing to watch
    return $self->stop unless keys %{$self->{timers}} || keys %{$self->{io}};

    # Calculate ideal timeout based on timers and round up to next millisecond
    my $min     = min map { $_->{time} } values %{$self->{timers}};
    my $timeout = defined $min ? $min - steady_time : 0.5;
    $timeout = $timeout <= 0 ? 0 : int($timeout * 1000) + 1;

    # I/O
    if (keys %{$self->{io}}) {
      my @poll = map { $_ => $self->{io}{$_}{mode} } keys %{$self->{io}};

      # This may break in the future, but is worth it for performance
      if (IO::Poll::_poll($timeout, @poll) > 0) {
        while (my ($fd, $mode) = splice @poll, 0, 2) {

          if ($mode & (POLLIN | POLLPRI | POLLNVAL | POLLHUP | POLLERR)) {
            next unless my $io = $self->{io}{$fd};
            ++$i and $self->_try('I/O watcher', $io->{cb}, 0);
          }
          next unless $mode & POLLOUT && (my $io = $self->{io}{$fd});
          ++$i and $self->_try('I/O watcher', $io->{cb}, 1);
        }
      }
    }

    # Wait for timeout if poll can't be used
    elsif ($timeout) { usleep($timeout * 1000) }

    # Timers (time should not change in between timers)
    my $now = steady_time;
    for my $id (keys %{$self->{timers}}) {
      next unless my $t = $self->{timers}{$id};
      next unless $t->{time} <= $now;

      # Recurring timer
      if ($t->{recurring}) { $t->{time} = $now + $t->{after} }

      # Normal timer
      else { $self->remove($id) }

      ++$i and $self->_try('Timer', $t->{cb}) if $t->{cb};
    }
  }
}

sub recurring { shift->_timer(1, @_) }

sub remove {
  my ($self, $remove) = @_;
  return !!delete $self->{timers}{$remove} unless ref $remove;
  return !!delete $self->{io}{fileno($remove) // croak 'Handle is closed'};
}

sub reset { delete @{shift()}{qw(events io next_tick next_timer running timers)} }

sub start {
  my $self = shift;
  local $self->{running} = ($self->{running} || 0) + 1;
  $self->one_tick while $self->{running};
}

sub stop { delete shift->{running} }

sub timer { shift->_timer(0, @_) }

sub watch {
  my ($self, $handle, $read, $write) = @_;

  croak 'I/O watcher not active' unless my $io = $self->{io}{fileno $handle};
  $io->{mode} = 0;
  $io->{mode} |= POLLIN | POLLPRI if $read;
  $io->{mode} |= POLLOUT          if $write;

  return $self;
}

sub _id {
  my $self = shift;
  my $id;
  do { $id = md5_sum 't' . steady_time . rand } while $self->{timers}{$id};
  return $id;
}

sub _next {
  my $self = shift;
  delete $self->{next_timer};
  while (my $cb = shift @{$self->{next_tick}}) { $self->$cb }
}

sub _timer {
  my ($self, $recurring, $after, $cb) = @_;
  my $id = $self->_id;
  $self->{timers}{$id} = {cb => $cb, after => $after, recurring => $recurring, time => steady_time + $after};
  return $id;
}

sub _try {
  my ($self, $what, $cb) = (shift, shift, shift);
  eval { $self->$cb(@_); 1 } or $self->emit(error => "$what failed: $@");
}

1;

=encoding utf8

=head1 NAME

Mojo::Reactor::Poll - Low-level event reactor with poll support

=head1 SYNOPSIS

  use Mojo::Reactor::Poll;

  # Watch if handle becomes readable or writable
  my $reactor = Mojo::Reactor::Poll->new;
  $reactor->io($first => sub ($reactor, $writable) {
    say $writable ? 'First handle is writable' : 'First handle is readable';
  });

  # Change to watching only if handle becomes writable
  $reactor->watch($first, 0, 1);

  # Turn file descriptor into handle and watch if it becomes readable
  my $second = IO::Handle->new_from_fd($fd, 'r');
  $reactor->io($second => sub ($reactor, $writable) {
    say $writable ? 'Second handle is writable' : 'Second handle is readable';
  })->watch($second, 1, 0);

  # Add a timer
  $reactor->timer(15 => sub ($reactor) {
    $reactor->remove($first);
    $reactor->remove($second);
    say 'Timeout!';
  });

  # Start reactor if necessary
  $reactor->start unless $reactor->is_running;

=head1 DESCRIPTION

L<Mojo::Reactor::Poll> is a low-level event reactor based on L<IO::Poll>.

=head1 EVENTS

L<Mojo::Reactor::Poll> inherits all events from L<Mojo::Reactor>.

=head1 METHODS

L<Mojo::Reactor::Poll> inherits all methods from L<Mojo::Reactor> and implements the following new ones.

=head2 again

  $reactor->again($id);
  $reactor->again($id, 0.5);

Restart timer and optionally change the invocation time. Note that this method requires an active timer.

=head2 io

  $reactor = $reactor->io($handle => sub {...});

Watch handle for I/O events, invoking the callback whenever handle becomes readable or writable.

  # Callback will be executed twice if handle becomes readable and writable
  $reactor->io($handle => sub ($reactor, $writable) {
    say $writable ? 'Handle is writable' : 'Handle is readable';
  });

=head2 is_running

  my $bool = $reactor->is_running;

Check if reactor is running.

=head2 next_tick

  my $undef = $reactor->next_tick(sub {...});

Execute callback as soon as possible, but not before returning or other callbacks that have been registered with this
method, always returns C<undef>.

=head2 one_tick

  $reactor->one_tick;

Run reactor until an event occurs or no events are being watched anymore.

  # Don't block longer than 0.5 seconds
  my $id = $reactor->timer(0.5 => sub {});
  $reactor->one_tick;
  $reactor->remove($id);

=head2 recurring

  my $id = $reactor->recurring(0.25 => sub {...});

Create a new recurring timer, invoking the callback repeatedly after a given amount of time in seconds.

=head2 remove

  my $bool = $reactor->remove($handle);
  my $bool = $reactor->remove($id);

Remove handle or timer.

=head2 reset

  $reactor->reset;

Remove all handles and timers.

=head2 start

  $reactor->start;

Start watching for I/O and timer events, this will block until L</"stop"> is called or no events are being watched
anymore.

  # Start reactor only if it is not running already
  $reactor->start unless $reactor->is_running;

=head2 stop

  $reactor->stop;

Stop watching for I/O and timer events.

=head2 timer

  my $id = $reactor->timer(0.5 => sub {...});

Create a new timer, invoking the callback after a given amount of time in seconds.

=head2 watch

  $reactor = $reactor->watch($handle, $readable, $writable);

Change I/O events to watch handle for with true and false values. Note that this method requires an active I/O watcher.

  # Watch only for readable events
  $reactor->watch($handle, 1, 0);

  # Watch only for writable events
  $reactor->watch($handle, 0, 1);

  # Watch for readable and writable events
  $reactor->watch($handle, 1, 1);

  # Pause watching for events
  $reactor->watch($handle, 0, 0);

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::URL;
use Mojo::Base -base;
use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;

use Mojo::Parameters;
use Mojo::Path;
use Mojo::Util qw(decode encode punycode_decode punycode_encode url_escape url_unescape);

has base => sub { Mojo::URL->new };
has [qw(fragment host port scheme userinfo)];

sub clone {
  my $self  = shift;
  my $clone = $self->new;
  @$clone{keys %$self} = values %$self;
  $clone->{$_} && ($clone->{$_} = $clone->{$_}->clone) for qw(base path query);
  return $clone;
}

sub host_port {
  my ($self, $host_port) = @_;

  if (defined $host_port) {
    $self->port($1) if $host_port =~ s/:(\d+)$//;
    my $host = url_unescape $host_port;
    return $host =~ /[^\x00-\x7f]/ ? $self->ihost($host) : $self->host($host);
  }

  return undef unless defined(my $host = $self->ihost);
  return $host unless defined(my $port = $self->port);
  return "$host:$port";
}

sub ihost {
  my $self = shift;

  # Decode
  return $self->host(join '.', map { /^xn--(.+)$/ ? punycode_decode $1 : $_ } split(/\./, shift, -1)) if @_;

  # Check if host needs to be encoded
  return undef unless defined(my $host = $self->host);
  return $host unless $host =~ /[^\x00-\x7f]/;

  # Encode
  return join '.', map { /[^\x00-\x7f]/ ? ('xn--' . punycode_encode $_) : $_ } split(/\./, $host, -1);
}

sub is_abs { !!shift->scheme }

sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }

sub parse {
  my ($self, $url) = @_;

  # Official regex from RFC 3986
  $url =~ m!^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?!;
  $self->scheme($2)                         if defined $2;
  $self->path($5)                           if defined $5;
  $self->query($7)                          if defined $7;
  $self->fragment(_decode(url_unescape $9)) if defined $9;
  if (defined(my $auth = $4)) {
    $self->userinfo(_decode(url_unescape $1)) if $auth =~ s/^([^\@]+)\@//;
    $self->host_port($auth);
  }

  return $self;
}

sub password { (shift->userinfo // '') =~ /:(.*)$/ ? $1 : undef }

sub path {
  my $self = shift;

  # Old path
  $self->{path} ||= Mojo::Path->new;
  return $self->{path} unless @_;

  # New path
  $self->{path} = ref $_[0] ? $_[0] : $self->{path}->merge($_[0]);

  return $self;
}

sub path_query {
  my ($self, $pq) = @_;

  if (defined $pq) {
    return $self unless $pq =~ /^([^?#]*)(?:\?([^#]*))?/;
    return defined $2 ? $self->path($1)->query($2) : $self->path($1);
  }

  my $query = $self->query->to_string;
  return $self->path->to_string . (length $query ? "?$query" : '');
}

sub protocol { lc(shift->scheme // '') }

sub query {
  my $self = shift;

  # Old parameters
  my $q = $self->{query} ||= Mojo::Parameters->new;
  return $q unless @_;

  # Replace with list
  if (@_ > 1) { $q->pairs([])->parse(@_) }

  # Merge with hash
  elsif (ref $_[0] eq 'HASH') { $q->merge(%{$_[0]}) }

  # Append array
  elsif (ref $_[0] eq 'ARRAY') { $q->append(@{$_[0]}) }

  # New parameters
  else { $self->{query} = ref $_[0] ? $_[0] : $q->parse($_[0]) }

  return $self;
}

sub to_abs {
  my $self = shift;

  my $abs = $self->clone;
  return $abs if $abs->is_abs;

  # Scheme
  my $base = shift || $abs->base;
  $abs->base($base)->scheme($base->scheme);

  # Authority
  return $abs if $abs->host;
  $abs->userinfo($base->userinfo)->host($base->host)->port($base->port);

  # Absolute path
  my $path = $abs->path;
  return $abs if $path->leading_slash;

  # Inherit path
  if (!@{$path->parts}) {
    $abs->path($base->path->clone->canonicalize);

    # Query
    $abs->query($base->query->clone) unless length $abs->query->to_string;
  }

  # Merge paths
  else { $abs->path($base->path->clone->merge($path)->canonicalize) }

  return $abs;
}

sub to_string        { shift->_string(0) }
sub to_unsafe_string { shift->_string(1) }

sub username { (shift->userinfo // '') =~ /^([^:]+)/ ? $1 : undef }

sub _decode { decode('UTF-8', $_[0]) // $_[0] }

sub _encode { url_escape encode('UTF-8', $_[0]), $_[1] }

sub _string {
  my ($self, $unsafe) = @_;

  # Scheme
  my $url = '';
  if (my $proto = $self->protocol) { $url .= "$proto:" }

  # Authority
  my $auth = $self->host_port;
  $auth = _encode($auth, '^A-Za-z0-9\-._~!$&\'()*+,;=:\[\]') if defined $auth;
  if ($unsafe && defined(my $info = $self->userinfo)) {
    $auth = _encode($info, '^A-Za-z0-9\-._~!$&\'()*+,;=:') . '@' . $auth;
  }
  $url .= "//$auth" if defined $auth;

  # Path and query
  my $path = $self->path_query;
  $url .= !$auth || !length $path || $path =~ m!^[/?]! ? $path : "/$path";

  # Fragment
  return $url unless defined(my $fragment = $self->fragment);
  return $url . '#' . _encode($fragment, '^A-Za-z0-9\-._~!$&\'()*+,;=:@/?');
}

1;

=encoding utf8

=head1 NAME

Mojo::URL - Uniform Resource Locator

=head1 SYNOPSIS

  use Mojo::URL;

  # Parse
  my $url = Mojo::URL->new('http://sri:foo@example.com:3000/foo?foo=bar#23');
  say $url->scheme;
  say $url->userinfo;
  say $url->host;
  say $url->port;
  say $url->path;
  say $url->query;
  say $url->fragment;

  # Build
  my $url = Mojo::URL->new;
  $url->scheme('http');
  $url->host('example.com');
  $url->port(3000);
  $url->path('/foo/bar');
  $url->query(foo => 'bar');
  $url->fragment(23);
  say "$url";

=head1 DESCRIPTION

L<Mojo::URL> implements a subset of L<RFC 3986|https://tools.ietf.org/html/rfc3986>, L<RFC
3987|https://tools.ietf.org/html/rfc3987> and the L<URL Living Standard|https://url.spec.whatwg.org> for Uniform
Resource Locators with support for IDNA and IRIs.

=head1 ATTRIBUTES

L<Mojo::URL> implements the following attributes.

=head2 base

  my $base = $url->base;
  $url     = $url->base(Mojo::URL->new);

Base of this URL, defaults to a L<Mojo::URL> object.

  "http://example.com/a/b?c"
  Mojo::URL->new("/a/b?c")->base(Mojo::URL->new("http://example.com"))->to_abs;

=head2 fragment

  my $fragment = $url->fragment;
  $url         = $url->fragment('â™¥mojoliciousâ™¥');

Fragment part of this URL.

  # "yada"
  Mojo::URL->new('http://example.com/foo?bar=baz#yada')->fragment;

=head2 host

  my $host = $url->host;
  $url     = $url->host('127.0.0.1');

Host part of this URL.

  # "example.com"
  Mojo::URL->new('http://sri:t3st@example.com:8080/foo')->host;

=head2 port

  my $port = $url->port;
  $url     = $url->port(8080);

Port part of this URL.

  # "8080"
  Mojo::URL->new('http://sri:t3st@example.com:8080/foo')->port;

=head2 scheme

  my $scheme = $url->scheme;
  $url       = $url->scheme('http');

Scheme part of this URL.

  # "http"
  Mojo::URL->new('http://example.com/foo')->scheme;

=head2 userinfo

  my $info = $url->userinfo;
  $url     = $url->userinfo('root:â™¥');

Userinfo part of this URL.

  # "sri:t3st"
  Mojo::URL->new('https://sri:t3st@example.com/foo')->userinfo;

=head1 METHODS

L<Mojo::URL> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 clone

  my $url2 = $url->clone;

Return a new L<Mojo::URL> object cloned from this URL.

=head2 host_port

  my $host_port = $url->host_port;
  $url          = $url->host_port('example.com:8080');

Normalized version of L</"host"> and L</"port">.

  # "xn--n3h.net:8080"
  Mojo::URL->new('http://â˜ƒ.net:8080/test')->host_port;

  # "example.com"
  Mojo::URL->new('http://example.com/test')->host_port;

=head2 ihost

  my $ihost = $url->ihost;
  $url      = $url->ihost('xn--bcher-kva.ch');

Host part of this URL in punycode format.

  # "xn--n3h.net"
  Mojo::URL->new('http://â˜ƒ.net')->ihost;

  # "example.com"
  Mojo::URL->new('http://example.com')->ihost;

=head2 is_abs

  my $bool = $url->is_abs;

Check if URL is absolute.

  # True
  Mojo::URL->new('http://example.com')->is_abs;
  Mojo::URL->new('http://example.com/test/index.html')->is_abs;

  # False
  Mojo::URL->new('test/index.html')->is_abs;
  Mojo::URL->new('/test/index.html')->is_abs;
  Mojo::URL->new('//example.com/test/index.html')->is_abs;

=head2 new

  my $url = Mojo::URL->new;
  my $url = Mojo::URL->new('http://127.0.0.1:3000/foo?f=b&baz=2#foo');

Construct a new L<Mojo::URL> object and L</"parse"> URL if necessary.

=head2 parse

  $url = $url->parse('http://127.0.0.1:3000/foo/bar?fo=o&baz=23#foo');

Parse relative or absolute URL.

  # "/test/123"
  $url->parse('/test/123?foo=bar')->path;

  # "example.com"
  $url->parse('http://example.com/test/123?foo=bar')->host;

  # "sri@example.com"
  $url->parse('mailto:sri@example.com')->path;

=head2 password

  my $password = $url->password;

Password part of L</"userinfo">.

  # "s3cret"
  Mojo::URL->new('http://isabel:s3cret@mojolicious.org')->password;

  # "s:3:c:r:e:t"
  Mojo::URL->new('http://isabel:s:3:c:r:e:t@mojolicious.org')->password;

=head2 path

  my $path = $url->path;
  $url     = $url->path('foo/bar');
  $url     = $url->path('/foo/bar');
  $url     = $url->path(Mojo::Path->new);

Path part of this URL, relative paths will be merged with L<Mojo::Path/"merge">, defaults to a L<Mojo::Path> object.

  # "test"
  Mojo::URL->new('http://example.com/test/Mojo')->path->parts->[0];

  # "/test/DOM/HTML"
  Mojo::URL->new('http://example.com/test/Mojo')->path->merge('DOM/HTML');

  # "http://example.com/DOM/HTML"
  Mojo::URL->new('http://example.com/test/Mojo')->path('/DOM/HTML');

  # "http://example.com/test/DOM/HTML"
  Mojo::URL->new('http://example.com/test/Mojo')->path('DOM/HTML');

  # "http://example.com/test/Mojo/DOM/HTML"
  Mojo::URL->new('http://example.com/test/Mojo/')->path('DOM/HTML');

=head2 path_query

  my $path_query = $url->path_query;
  $url           = $url->path_query('/foo/bar?a=1&b=2');

Normalized version of L</"path"> and L</"query">.

  # "/test?a=1&b=2"
  Mojo::URL->new('http://example.com/test?a=1&b=2')->path_query;

  # "/"
  Mojo::URL->new('http://example.com/')->path_query;

=head2 protocol

  my $proto = $url->protocol;

Normalized version of L</"scheme">.

  # "http"
  Mojo::URL->new('HtTp://example.com')->protocol;

=head2 query

  my $query = $url->query;
  $url      = $url->query({merge => 'to'});
  $url      = $url->query([append => 'with']);
  $url      = $url->query(replace => 'with');
  $url      = $url->query('a=1&b=2');
  $url      = $url->query(Mojo::Parameters->new);

Query part of this URL, key/value pairs in an array reference will be appended with L<Mojo::Parameters/"append">, and
key/value pairs in a hash reference merged with L<Mojo::Parameters/"merge">, defaults to a L<Mojo::Parameters> object.

  # "2"
  Mojo::URL->new('http://example.com?a=1&b=2')->query->param('b');

  # "a=2&b=2&c=3"
  Mojo::URL->new('http://example.com?a=1&b=2')->query->merge(a => 2, c => 3);

  # "http://example.com?a=2&c=3"
  Mojo::URL->new('http://example.com?a=1&b=2')->query(a => 2, c => 3);

  # "http://example.com?a=2&a=3"
  Mojo::URL->new('http://example.com?a=1&b=2')->query(a => [2, 3]);

  # "http://example.com?a=2&b=2&c=3"
  Mojo::URL->new('http://example.com?a=1&b=2')->query({a => 2, c => 3});

  # "http://example.com?b=2"
  Mojo::URL->new('http://example.com?a=1&b=2')->query({a => undef});

  # "http://example.com?a=1&b=2&a=2&c=3"
  Mojo::URL->new('http://example.com?a=1&b=2')->query([a => 2, c => 3]);

=head2 to_abs

  my $abs = $url->to_abs;
  my $abs = $url->to_abs(Mojo::URL->new('http://example.com/foo'));

Return a new L<Mojo::URL> object cloned from this relative URL and turn it into an absolute one using L</"base"> or
provided base URL.

  # "http://example.com/foo/baz.xml?test=123"
  Mojo::URL->new('baz.xml?test=123')
    ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));

  # "http://example.com/baz.xml?test=123"
  Mojo::URL->new('/baz.xml?test=123')
    ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));

  # "http://example.com/foo/baz.xml?test=123"
  Mojo::URL->new('//example.com/foo/baz.xml?test=123')
    ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));

=head2 to_string

  my $str = $url->to_string;

Turn URL into a string. Note that L</"userinfo"> will not be included for security reasons.

  # "http://mojolicious.org"
  Mojo::URL->new->scheme('http')->host('mojolicious.org')->to_string;

  # "http://mojolicious.org"
  Mojo::URL->new('http://daniel:s3cret@mojolicious.org')->to_string;

=head2 to_unsafe_string

  my $str = $url->to_unsafe_string;

Same as L</"to_string">, but includes L</"userinfo">.

  # "http://daniel:s3cret@mojolicious.org"
  Mojo::URL->new('http://daniel:s3cret@mojolicious.org')->to_unsafe_string;

=head2 username

  my $username = $url->username;

Username part of L</"userinfo">.

  # "isabel"
  Mojo::URL->new('http://isabel:s3cret@mojolicious.org')->username;

=head1 OPERATORS

L<Mojo::URL> overloads the following operators.

=head2 bool

  my $bool = !!$url;

Always true.

=head2 stringify

  my $str = "$url";

Alias for L</"to_string">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Promise;
use Mojo::Base -base;

use Carp qw(carp croak);
use Mojo::Exception;
use Mojo::IOLoop;
use Scalar::Util qw(blessed);

use constant DEBUG => $ENV{MOJO_PROMISE_DEBUG} || 0;

has ioloop => sub { Mojo::IOLoop->singleton }, weak => 1;

sub AWAIT_CHAIN_CANCEL { }
sub AWAIT_CLONE        { _await('clone', @_) }
sub AWAIT_DONE         { _settle_await(resolve => @_) }
sub AWAIT_FAIL         { _settle_await(reject  => @_) }

sub AWAIT_GET {
  my $self    = shift;
  my @results = @{$self->{results} // []};
  return wantarray ? @results : $results[0] if $self->{status} eq 'resolve';
  die $results[0]                           if ref $results[0] || $results[0] =~ m!\n!;
  croak $results[0];
}

sub AWAIT_IS_CANCELLED {undef}

sub AWAIT_IS_READY {
  my $self = shift;
  $self->{handled} = 1;
  return !!$self->{results} && !@{$self->{resolve}} && !@{$self->{reject}};
}

sub AWAIT_NEW_DONE { _await('resolve', @_) }
sub AWAIT_NEW_FAIL { _await('reject',  @_) }

sub AWAIT_ON_CANCEL { }

sub AWAIT_ON_READY {
  shift->_finally(0, @_)->catch(sub { });
}

sub AWAIT_WAIT {
  my $self = shift;
  $self->catch(sub { })->wait;
  return $self->AWAIT_GET;
}

sub DESTROY {
  my $self = shift;
  return if $self->{handled} || ($self->{status} // '') ne 'reject' || !$self->{results};
  carp "Unhandled rejected promise: @{$self->{results}}";
  warn $self->{debug}->message("-- Destroyed promise\n")->verbose(1)->to_string if DEBUG;
}

sub all         { _all(2, @_) }
sub all_settled { _all(0, @_) }
sub any         { _all(3, @_) }

sub catch { shift->then(undef, shift) }

sub clone { $_[0]->new->ioloop($_[0]->ioloop) }

sub finally { shift->_finally(1, @_) }

sub map {
  my ($class, $options, $cb, @items) = (shift, ref $_[0] eq 'HASH' ? shift : {}, @_);

  return $class->all(map { $_->$cb } @items) if !$options->{concurrency} || @items <= $options->{concurrency};

  my @start = map { $_->$cb } splice @items, 0, $options->{concurrency};
  my @wait  = map { $start[0]->clone } 0 .. $#items;

  my $start_next = sub {
    return () unless my $item = shift @items;
    my ($start_next, $chain) = (__SUB__, shift @wait);
    $_->$cb->then(sub { $chain->resolve(@_); $start_next->() }, sub { $chain->reject(@_); @items = () }) for $item;
    return ();
  };

  $_->then($start_next, sub { }) for @start;

  return $class->all(@start, @wait);
}

sub new {
  my $self = shift->SUPER::new;
  $self->{debug} = Mojo::Exception->new->trace if DEBUG;
  shift->(sub { $self->resolve(@_) }, sub { $self->reject(@_) }) if @_;
  return $self;
}

sub race { _all(1, @_) }

sub reject  { shift->_settle('reject',  @_) }
sub resolve { shift->_settle('resolve', @_) }

sub then {
  my ($self, $resolve, $reject) = @_;

  my $new = $self->clone;
  $self->{handled} = 1;
  push @{$self->{resolve}}, sub { _then_cb($new, $resolve, 'resolve', @_) };
  push @{$self->{reject}},  sub { _then_cb($new, $reject,  'reject',  @_) };

  $self->_defer if $self->{results};

  return $new;
}

sub timer   { shift->_timer('resolve', @_) }
sub timeout { shift->_timer('reject',  @_) }

sub wait {
  my $self = shift;
  return if (my $loop = $self->ioloop)->is_running;
  my $done;
  $self->_finally(0, sub { $done++; $loop->stop })->catch(sub { });
  $loop->start until $done;
}

sub _all {
  my ($type, $class, @promises) = @_;

  my $all       = $promises[0]->clone;
  my $results   = [];
  my $remaining = scalar @promises;
  for my $i (0 .. $#promises) {

    # "race"
    if ($type == 1) {
      $promises[$i]->then(sub { $all->resolve(@_); () }, sub { $all->reject(@_); () });
    }

    # "all"
    elsif ($type == 2) {
      $promises[$i]->then(
        sub {
          $results->[$i] = [@_];
          $all->resolve(@$results) if --$remaining <= 0;
          return ();
        },
        sub { $all->reject(@_); () }
      );
    }

    # "any"
    elsif ($type == 3) {
      $promises[$i]->then(
        sub { $all->resolve(@_); () },
        sub {
          $results->[$i] = [@_];
          $all->reject(@$results) if --$remaining <= 0;
          return ();
        }
      );
    }

    # "all_settled"
    else {
      $promises[$i]->then(
        sub {
          $results->[$i] = {status => 'fulfilled', value => [@_]};
          $all->resolve(@$results) if --$remaining <= 0;
          return ();
        },
        sub {
          $results->[$i] = {status => 'rejected', reason => [@_]};
          $all->resolve(@$results) if --$remaining <= 0;
          return ();
        }
      );
    }
  }

  return $all;
}

sub _await {
  my ($method, $class) = (shift, shift);
  my $promise = $class->$method(@_);
  $promise->{cycle} = $promise;
  return $promise;
}

sub _defer {
  my $self = shift;

  return unless my $results = $self->{results};
  my $cbs = $self->{status} eq 'resolve' ? $self->{resolve} : $self->{reject};
  @{$self}{qw(cycle resolve reject)} = (undef, [], []);

  $self->ioloop->next_tick(sub { $_->(@$results) for @$cbs });
}

sub _finally {
  my ($self, $handled, $finally) = @_;

  my $new = $self->clone;
  my $cb  = sub {
    my @results = @_;
    $new->resolve($finally->())->then(sub {@results});
  };

  my $before = $self->{handled};
  $self->catch($cb);
  my $next = $self->then($cb);
  delete $self->{handled} if !$before && !$handled;

  return $next;
}

sub _settle {
  my ($self, $status, @results) = @_;

  my $thenable = blessed $results[0] && $results[0]->can('then');
  unless (ref $self) {
    return $results[0] if $thenable && $status eq 'resolve' && $results[0]->isa('Mojo::Promise');
    $self = $self->new;
  }

  if ($thenable && $status eq 'resolve') {
    $results[0]->then(sub { $self->resolve(@_); () }, sub { $self->reject(@_); () });
  }
  elsif (!$self->{results}) {
    @{$self}{qw(results status)} = (\@results, $status);
    $self->_defer;
  }

  return $self;
}

sub _settle_await {
  my ($status, $self, @results) = @_;
  return $results[0]->then(sub { $self->resolve(@_); () }, sub { $self->reject(@_); () })
    if blessed $results[0] && $results[0]->can('then');
  @{$self}{qw(results status)} = ([@results], $status) if !$self->{results};
  $self->_defer;
}

sub _then_cb {
  my ($new, $cb, $method, @results) = @_;

  return $new->$method(@results) unless defined $cb;

  my @res;
  return $new->reject($@) unless eval { @res = $cb->(@results); 1 };
  return $new->resolve(@res);
}

sub _timer {
  my ($self, $method, $after, @results) = @_;
  $self = $self->new unless ref $self;
  $results[0] = 'Promise timeout' if $method eq 'reject' && !@results;
  $self->ioloop->timer($after => sub { $self->$method(@results) });
  return $self;
}

1;

=encoding utf8

=head1 NAME

Mojo::Promise - Promises/A+

=head1 SYNOPSIS

  use Mojo::Promise;
  use Mojo::UserAgent;

  # Wrap continuation-passing style APIs with promises
  my $ua = Mojo::UserAgent->new;
  sub get_p {
    my $promise = Mojo::Promise->new;
    $ua->get(@_ => sub ($ua, $tx) {
      my $err = $tx->error;
      if   (!$err || $err->{code}) { $promise->resolve($tx) }
      else                         { $promise->reject($err->{message}) }
    });
    return $promise;
  }

  # Perform non-blocking operations sequentially
  get_p('https://mojolicious.org')->then(sub ($mojo) {
    say $mojo->res->code;
    return get_p('https://metacpan.org');
  })->then(sub ($cpan) {
    say $cpan->res->code;
  })->catch(sub ($err) {
    warn "Something went wrong: $err";
  })->wait;

  # Synchronize non-blocking operations (all)
  my $mojo = get_p('https://mojolicious.org');
  my $cpan = get_p('https://metacpan.org');
  Mojo::Promise->all($mojo, $cpan)->then(sub ($mojo, $cpan) {
    say $mojo->[0]->res->code;
    say $cpan->[0]->res->code;
  })->catch(sub ($err) {
    warn "Something went wrong: $err";
  })->wait;

  # Synchronize non-blocking operations (race)
  my $mojo = get_p('https://mojolicious.org');
  my $cpan = get_p('https://metacpan.org');
  Mojo::Promise->race($mojo, $cpan)->then(sub ($tx) {
    say $tx->req->url, ' won!';
  })->catch(sub ($err) {
    warn "Something went wrong: $err";
  })->wait;

=head1 DESCRIPTION

L<Mojo::Promise> is a Perl-ish implementation of L<Promises/A+|https://promisesaplus.com> and a superset of L<ES6
Promises|https://duckduckgo.com/?q=\mdn%20Promise>.

=head1 STATES

A promise is an object representing the eventual completion or failure of a non-blocking operation. It allows
non-blocking functions to return values, like blocking functions. But instead of immediately returning the final value,
the non-blocking function returns a promise to supply the value at some point in the future.

A promise can be in one of three states:

=over 2

=item pending

Initial state, neither fulfilled nor rejected.

=item fulfilled

Meaning that the operation completed successfully.

=item rejected

Meaning that the operation failed.

=back

A pending promise can either be fulfilled with a value or rejected with a reason. When either happens, the associated
handlers queued up by a promise's L</"then"> method are called.

=head1 ATTRIBUTES

L<Mojo::Promise> implements the following attributes.

=head2 ioloop

  my $loop = $promise->ioloop;
  $promise = $promise->ioloop(Mojo::IOLoop->new);

Event loop object to control, defaults to the global L<Mojo::IOLoop> singleton. Note that this attribute is weakened.

=head1 METHODS

L<Mojo::Promise> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 all

  my $new = Mojo::Promise->all(@promises);

Returns a new L<Mojo::Promise> object that either fulfills when all of the passed L<Mojo::Promise> objects have
fulfilled or rejects as soon as one of them rejects. If the returned promise fulfills, it is fulfilled with the values
from the fulfilled promises in the same order as the passed promises.

=head2 all_settled

  my $new = Mojo::Promise->all_settled(@promises);

Returns a new L<Mojo::Promise> object that fulfills when all of the passed L<Mojo::Promise> objects have fulfilled or
rejected, with hash references that describe the outcome of each promise.

=head2 any

  my $new = Mojo::Promise->any(@promises);

Returns a new L<Mojo::Promise> object that fulfills as soon as one of the passed L<Mojo::Promise> objects fulfills,
with the value from that promise.

=head2 catch

  my $new = $promise->catch(sub {...});

Appends a rejection handler callback to the promise, and returns a new L<Mojo::Promise> object resolving to the return
value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.

  # Longer version
  my $new = $promise->then(undef, sub {...});

  # Pass along the rejection reason
  $promise->catch(sub (@reason) {
    warn "Something went wrong: $reason[0]";
    return @reason;
  });

  # Change the rejection reason
  $promise->catch(sub (@reason) { "This is bad: $reason[0]" });

=head2 clone

  my $new = $promise->clone;

Return a new L<Mojo::Promise> object cloned from this promise that is still pending.

=head2 finally

  my $new = $promise->finally(sub {...});

Appends a fulfillment and rejection handler to the promise, and returns a new L<Mojo::Promise> object resolving to the
original fulfillment value or rejection reason.

  # Do something on fulfillment and rejection
  $promise->finally(sub { say "We are done!" });

=head2 map

  my $new = Mojo::Promise->map(sub {...}, @items);
  my $new = Mojo::Promise->map({concurrency => 3}, sub {...}, @items);

Apply a function that returns a L<Mojo::Promise> to each item in a list of items while optionally limiting concurrency.
Returns a L<Mojo::Promise> that collects the results in the same manner as L</all>. If any item's promise is rejected,
any remaining items which have not yet been mapped will not be.

  # Perform 3 requests at a time concurrently
  Mojo::Promise->map({concurrency => 3}, sub { $ua->get_p($_) }, @urls)
    ->then(sub{ say $_->[0]->res->dom->at('title')->text for @_ });

These options are currently available:

=over 2

=item concurrency

  concurrency => 3

The maximum number of items that are in progress at the same time.

=back

=head2 new

  my $promise = Mojo::Promise->new;
  my $promise = Mojo::Promise->new(sub {...});

Construct a new L<Mojo::Promise> object.

  # Wrap a continuation-passing style API
  my $promise = Mojo::Promise->new(sub ($resolve, $reject) {
    Mojo::IOLoop->timer(5 => sub {
      if (int rand 2) { $resolve->('Lucky!') }
      else            { $reject->('Unlucky!') }
    });
  });

=head2 race

  my $new = Mojo::Promise->race(@promises);

Returns a new L<Mojo::Promise> object that fulfills or rejects as soon as one of the passed L<Mojo::Promise> objects
fulfills or rejects, with the value or reason from that promise.

=head2 reject

  my $new  = Mojo::Promise->reject(@reason);
  $promise = $promise->reject(@reason);

Build rejected L<Mojo::Promise> object or reject the promise with one or more rejection reasons.

  # Longer version
  my $promise = Mojo::Promise->new->reject(@reason);

=head2 resolve

  my $new  = Mojo::Promise->resolve(@value);
  $promise = $promise->resolve(@value);

Build resolved L<Mojo::Promise> object or resolve the promise with one or more fulfillment values.

  # Longer version
  my $promise = Mojo::Promise->new->resolve(@value);

=head2 then

  my $new = $promise->then(sub {...});
  my $new = $promise->then(sub {...}, sub {...});
  my $new = $promise->then(undef, sub {...});

Appends fulfillment and rejection handlers to the promise, and returns a new L<Mojo::Promise> object resolving to the
return value of the called handler.

  # Pass along the fulfillment value or rejection reason
  $promise->then(
    sub (@value) {
      say "The result is $value[0]";
      return @value;
    },
    sub (@reason) {
      warn "Something went wrong: $reason[0]";
      return @reason;
    }
  );

  # Change the fulfillment value or rejection reason
  $promise->then(
    sub (@value)  { return "This is good: $value[0]" },
    sub (@reason) { return "This is bad: $reason[0]" }
  );

=head2 timer

  my $new  = Mojo::Promise->timer(5 => 'Success!');
  $promise = $promise->timer(5 => 'Success!');
  $promise = $promise->timer(5);

Create a new L<Mojo::Promise> object with a timer or attach a timer to an existing promise. The promise will be
resolved after the given amount of time in seconds with or without a value.

=head2 timeout

  my $new  = Mojo::Promise->timeout(5 => 'Timeout!');
  $promise = $promise->timeout(5 => 'Timeout!');
  $promise = $promise->timeout(5);

Create a new L<Mojo::Promise> object with a timeout or attach a timeout to an existing promise. The promise will be
rejected after the given amount of time in seconds with a reason, which defaults to C<Promise timeout>.

=head2 wait

  $promise->wait;

Start L</"ioloop"> and stop it again once the promise has been fulfilled or rejected, does nothing when L</"ioloop"> is
already running.

=head1 DEBUGGING

You can set the C<MOJO_PROMISE_DEBUG> environment variable to get some advanced diagnostics information printed to
C<STDERR>.

  MOJO_PROMISE_DEBUG=1

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Cache;
use Mojo::Base -base;

has 'max_keys' => 100;

sub get { (shift->{cache} // {})->{shift()} }

sub set {
  my ($self, $key, $value) = @_;

  return $self unless (my $max = $self->max_keys) > 0;

  my $cache = $self->{cache} //= {};
  my $queue = $self->{queue} //= [];
  delete $cache->{shift @$queue} while @$queue >= $max;
  push @$queue, $key unless exists $cache->{$key};
  $cache->{$key} = $value;

  return $self;
}

1;

=encoding utf8

=head1 NAME

Mojo::Cache - Naive in-memory cache

=head1 SYNOPSIS

  use Mojo::Cache;

  my $cache = Mojo::Cache->new(max_keys => 50);
  $cache->set(foo => 'bar');
  my $foo = $cache->get('foo');

=head1 DESCRIPTION

L<Mojo::Cache> is a naive in-memory cache with size limits.

=head1 ATTRIBUTES

L<Mojo::Cache> implements the following attributes.

=head2 max_keys

  my $max = $cache->max_keys;
  $cache  = $cache->max_keys(50);

Maximum number of cache keys, defaults to C<100>. Setting the value to C<0> will disable caching.

=head1 METHODS

L<Mojo::Cache> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 get

  my $value = $cache->get('foo');

Get cached value.

=head2 set

  $cache = $cache->set(foo => 'bar');

Set cached value.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::IOLoop;
use Mojo::Base 'Mojo::EventEmitter';

# "Professor: Amy, technology isn't intrinsically good or evil. It's how it's
#             used. Like the death ray."
use Carp qw(croak);
use Mojo::IOLoop::Client;
use Mojo::IOLoop::Server;
use Mojo::IOLoop::Stream;
use Mojo::IOLoop::Subprocess;
use Mojo::Reactor::Poll;
use Mojo::Util   qw(md5_sum steady_time);
use Scalar::Util qw(blessed weaken);

use constant DEBUG => $ENV{MOJO_IOLOOP_DEBUG} || 0;

has max_accepts     => 0;
has max_connections => 1000;
has reactor         => sub {
  my $class = Mojo::Reactor::Poll->detect;
  warn "-- Reactor initialized ($class)\n" if DEBUG;
  return $class->new->catch(sub { warn "@{[blessed $_[0]]}: $_[1]" });
};

# Ignore PIPE signal
$SIG{PIPE} = 'IGNORE';

# Initialize singleton reactor early
__PACKAGE__->singleton->reactor;

sub acceptor {
  my ($self, $acceptor) = (_instance(shift), @_);

  # Find acceptor for id
  return $self->{acceptors}{$acceptor} unless ref $acceptor;

  # Connect acceptor with reactor
  $self->{acceptors}{my $id = $self->_id} = $acceptor->reactor($self->reactor);

  # Allow new acceptor to get picked up
  $self->_not_accepting->_maybe_accepting;

  return $id;
}

sub client {
  my ($self, $cb) = (_instance(shift), pop);

  my $id     = $self->_id;
  my $client = $self->{out}{$id}{client} = Mojo::IOLoop::Client->new(reactor => $self->reactor);

  weaken $self;
  $client->on(
    connect => sub {
      delete $self->{out}{$id}{client};
      my $stream = Mojo::IOLoop::Stream->new(pop);
      $self->_stream($stream => $id);
      $self->$cb(undef, $stream);
    }
  );
  $client->on(error => sub { $self->_remove($id); $self->$cb(pop, undef) });
  $client->connect(@_);

  return $id;
}

sub is_running { _instance(shift)->reactor->is_running }

sub next_tick {
  my ($self, $cb) = (_instance(shift), @_);
  weaken $self;
  return $self->reactor->next_tick(sub { $self->$cb });
}

sub one_tick {
  my $self = _instance(shift);
  croak 'Mojo::IOLoop already running' if $self->is_running;
  $self->reactor->one_tick;
}

sub recurring { shift->_timer(recurring => @_) }

sub remove {
  my ($self, $id) = (_instance(shift), @_);
  my $c = $self->{in}{$id} || $self->{out}{$id};
  if ($c && (my $stream = $c->{stream})) { return $stream->close_gracefully }
  $self->_remove($id);
}

sub reset {
  my ($self, $options) = (_instance(shift), shift // {});

  $self->emit('reset')->stop;
  if ($options->{freeze}) {
    state @frozen;
    push @frozen, {%$self};
    delete $self->{reactor};
  }
  else { $self->reactor->reset }

  delete @$self{qw(accepting acceptors events in out stop)};
}

sub server {
  my ($self, $cb) = (_instance(shift), pop);

  my $server = Mojo::IOLoop::Server->new;
  weaken $self;
  $server->on(
    accept => sub {
      my $stream = Mojo::IOLoop::Stream->new(pop);
      $self->$cb($stream, $self->_stream($stream, $self->_id, 1));

      # Enforce connection limit (randomize to improve load balancing)
      if (my $max = $self->max_accepts) {
        $self->{accepts} //= $max - int rand $max / 2;
        $self->stop_gracefully if ($self->{accepts} -= 1) <= 0;
      }

      # Stop accepting if connection limit has been reached
      $self->_not_accepting if $self->_limit;
    }
  );
  $server->listen(@_);

  return $self->acceptor($server);
}

sub singleton { state $loop = shift->new }

sub start {
  my $self = _instance(shift);
  croak 'Mojo::IOLoop already running' if $self->is_running;
  $self->reactor->start;
}

sub stop { _instance(shift)->reactor->stop }

sub stop_gracefully {
  my $self = _instance(shift)->_not_accepting;
  ++$self->{stop} and !$self->emit('finish')->_in and $self->stop;
}

sub stream {
  my ($self, $stream) = (_instance(shift), @_);
  return $self->_stream($stream => $self->_id) if ref $stream;
  my $c = $self->{in}{$stream} || $self->{out}{$stream} // {};
  return $c->{stream};
}

sub subprocess {
  my $subprocess = Mojo::IOLoop::Subprocess->new(ioloop => _instance(shift));
  return @_ ? $subprocess->run(@_) : $subprocess;
}

sub timer { shift->_timer(timer => @_) }

sub _id {
  my $self = shift;
  my $id;
  do { $id = md5_sum 'c' . steady_time . rand } while $self->{in}{$id} || $self->{out}{$id} || $self->{acceptors}{$id};
  return $id;
}

sub _in { scalar keys %{shift->{in} // {}} }

sub _instance { ref $_[0] ? $_[0] : $_[0]->singleton }

sub _limit { $_[0]{stop} ? 1 : $_[0]->_in >= $_[0]->max_connections }

sub _maybe_accepting {
  my $self = shift;
  return if $self->{accepting} || $self->_limit;
  $_->start for values %{$self->{acceptors} // {}};
  $self->{accepting} = 1;
}

sub _not_accepting {
  my $self = shift;
  return $self unless delete $self->{accepting};
  $_->stop for values %{$self->{acceptors} // {}};
  return $self;
}

sub _out { scalar keys %{shift->{out} // {}} }

sub _remove {
  my ($self, $id) = @_;

  # Timer
  return undef unless my $reactor = $self->reactor;
  return undef if $reactor->remove($id);

  # Acceptor
  return $self->_not_accepting->_maybe_accepting if delete $self->{acceptors}{$id};

  # Connection
  return undef unless delete $self->{in}{$id} || delete $self->{out}{$id};
  return $self->stop if $self->{stop} && !$self->_in;
  $self->_maybe_accepting;
  warn "-- $id <<< $$ (@{[$self->_in]}:@{[$self->_out]})\n" if DEBUG;
}

sub _stream {
  my ($self, $stream, $id, $server) = @_;

  # Connect stream with reactor
  $self->{$server ? 'in' : 'out'}{$id}{stream} = $stream->reactor($self->reactor);
  warn "-- $id >>> $$ (@{[$self->_in]}:@{[$self->_out]})\n" if DEBUG;
  weaken $self;
  $stream->on(close => sub { $self && $self->_remove($id) });
  $stream->start;

  return $id;
}

sub _timer {
  my ($self, $method, $after, $cb) = (_instance(shift), @_);
  weaken $self;
  return $self->reactor->$method($after => sub { $self->$cb });
}

1;

=encoding utf8

=head1 NAME

Mojo::IOLoop - Minimalistic event loop

=head1 SYNOPSIS

  use Mojo::IOLoop;

  # Listen on port 3000
  Mojo::IOLoop->server({port => 3000} => sub ($loop, $stream, $id) {
    $stream->on(read => sub ($stream, $bytes) {
      # Process input chunk
      say $bytes;

      # Write response
      $stream->write('HTTP/1.1 200 OK');
    });
  });

  # Connect to port 3000
  my $id = Mojo::IOLoop->client({port => 3000} => sub ($loop, $err, $stream) {
    $stream->on(read => sub ($stream, $bytes) {
      # Process input
      say "Input: $bytes";
    });

    # Write request
    $stream->write("GET / HTTP/1.1\x0d\x0a\x0d\x0a");
  });

  # Add a timer
  Mojo::IOLoop->timer(5 => sub ($loop) { $loop->remove($id) });

  # Start event loop if necessary
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head1 DESCRIPTION

L<Mojo::IOLoop> is a very minimalistic event loop based on L<Mojo::Reactor>, it has been reduced to the absolute
minimal feature set required to build solid and scalable non-blocking clients and servers.

Depending on operating system, the default per-process and system-wide file descriptor limits are often very low and
need to be tuned for better scalability. The C<LIBEV_FLAGS> environment variable should also be used to select the best
possible L<EV> backend, which usually defaults to the not very scalable C<select>.

  LIBEV_FLAGS=1    # select
  LIBEV_FLAGS=2    # poll
  LIBEV_FLAGS=4    # epoll (Linux)
  LIBEV_FLAGS=8    # kqueue (*BSD, OS X)
  LIBEV_FLAGS=64   # Linux AIO

The event loop will be resilient to time jumps if a monotonic clock is available through L<Time::HiRes>. A TLS
certificate and key are also built right in, to make writing test servers as easy as possible. Also note that for
convenience the C<PIPE> signal will be set to C<IGNORE> when L<Mojo::IOLoop> is loaded.

For better scalability (epoll, kqueue) and to provide non-blocking name resolution, SOCKS5 as well as TLS support, the
optional modules L<EV> (4.32+), L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and L<IO::Socket::SSL>
(2.009+) will be used automatically if possible. Individual features can also be disabled with the C<MOJO_NO_NNR>,
C<MOJO_NO_SOCKS> and C<MOJO_NO_TLS> environment variables.

See L<Mojolicious::Guides::Cookbook/"REAL-TIME WEB"> for more.

=head1 EVENTS

L<Mojo::IOLoop> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 finish

  $loop->on(finish => sub ($loop) {...});

Emitted when the event loop wants to shut down gracefully and is just waiting for all existing connections to be
closed.

=head2 reset

  $loop->on(reset => sub ($loop) {...});

Emitted when the event loop is reset, this usually happens after the process is forked to clean up resources that
cannot be shared.

=head1 ATTRIBUTES

L<Mojo::IOLoop> implements the following attributes.

=head2 max_accepts

  my $max = $loop->max_accepts;
  $loop   = $loop->max_accepts(1000);

The maximum number of connections this event loop is allowed to accept, before shutting down gracefully without
interrupting existing connections, defaults to C<0>. Setting the value to C<0> will allow this event loop to accept new
connections indefinitely. Note that up to half of this value can be subtracted randomly to improve load balancing
between multiple server processes, and to make sure that not all of them restart at the same time.

=head2 max_connections

  my $max = $loop->max_connections;
  $loop   = $loop->max_connections(100);

The maximum number of accepted connections this event loop is allowed to handle concurrently, before stopping to accept
new incoming connections, defaults to C<1000>.

=head2 reactor

  my $reactor = $loop->reactor;
  $loop       = $loop->reactor(Mojo::Reactor->new);

Low-level event reactor, usually a L<Mojo::Reactor::Poll> or L<Mojo::Reactor::EV> object with a default subscriber to
the event L<Mojo::Reactor/"error">.

  # Watch if handle becomes readable or writable
  Mojo::IOLoop->singleton->reactor->io($handle => sub ($reactor, $writable) {
    say $writable ? 'Handle is writable' : 'Handle is readable';
  });

  # Change to watching only if handle becomes writable
  Mojo::IOLoop->singleton->reactor->watch($handle, 0, 1);

  # Remove handle again
  Mojo::IOLoop->singleton->reactor->remove($handle);

=head1 METHODS

L<Mojo::IOLoop> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 acceptor

  my $server = Mojo::IOLoop->acceptor($id);
  my $server = $loop->acceptor($id);
  my $id     = $loop->acceptor(Mojo::IOLoop::Server->new);

Get L<Mojo::IOLoop::Server> object for id or turn object into an acceptor.

=head2 client

  my $id = Mojo::IOLoop->client(address => '127.0.0.1', port => 3000, sub {...});
  my $id = $loop->client(address => '127.0.0.1', port => 3000, sub {...});
  my $id = $loop->client({address => '127.0.0.1', port => 3000} => sub {...});

Open a TCP/IP or UNIX domain socket connection with L<Mojo::IOLoop::Client> and create a stream object (usually
L<Mojo::IOLoop::Stream>), takes the same arguments as L<Mojo::IOLoop::Client/"connect">.

=head2 is_running

  my $bool = Mojo::IOLoop->is_running;
  my $bool = $loop->is_running;

Check if event loop is running.

=head2 next_tick

  my $undef = Mojo::IOLoop->next_tick(sub ($loop) {...});
  my $undef = $loop->next_tick(sub ($loop) {...});

Execute callback as soon as possible, but not before returning or other callbacks that have been registered with this
method, always returns C<undef>.

  # Perform operation on next reactor tick
  Mojo::IOLoop->next_tick(sub ($loop) {...});

=head2 one_tick

  Mojo::IOLoop->one_tick;
  $loop->one_tick;

Run event loop until an event occurs.

  # Don't block longer than 0.5 seconds
  my $id = Mojo::IOLoop->timer(0.5 => sub ($loop) {});
  Mojo::IOLoop->one_tick;
  Mojo::IOLoop->remove($id);

=head2 recurring

  my $id = Mojo::IOLoop->recurring(3 => sub ($loop) {...});
  my $id = $loop->recurring(0 => sub ($loop) {...});
  my $id = $loop->recurring(0.25 => sub ($loop) {...});

Create a new recurring timer, invoking the callback repeatedly after a given amount of time in seconds.

  # Perform operation every 5 seconds
  Mojo::IOLoop->recurring(5 => sub ($loop) {...});

=head2 remove

  Mojo::IOLoop->remove($id);
  $loop->remove($id);

Remove anything with an id, connections will be dropped gracefully by allowing them to finish writing all data in their
write buffers.

=head2 reset

  Mojo::IOLoop->reset;
  $loop->reset;
  $loop->reset({freeze => 1});

Remove everything and stop the event loop.

These options are currently available:

=over 2

=item freeze

  freeze => 1

Freeze the current state of the event loop in time before resetting it. This will prevent active connections from
getting closed immediately, which can help with many unintended side effects when processes are forked. Note that this
option is B<EXPERIMENTAL> and might change without warning!

=back

=head2 server

  my $id = Mojo::IOLoop->server(port => 3000, sub {...});
  my $id = $loop->server(port => 3000, sub {...});
  my $id = $loop->server({port => 3000} => sub {...});

Accept TCP/IP and UNIX domain socket connections with L<Mojo::IOLoop::Server> and create stream objects (usually
L<Mojo::IOLoop::Stream>, takes the same arguments as L<Mojo::IOLoop::Server/"listen">.

  # Listen on random port
  my $id = Mojo::IOLoop->server({address => '127.0.0.1'} => sub ($loop, $stream, $id) {...});
  my $port = Mojo::IOLoop->acceptor($id)->port;

=head2 singleton

  my $loop = Mojo::IOLoop->singleton;

The global L<Mojo::IOLoop> singleton, used to access a single shared event loop object from everywhere inside the
process.

  # Many methods also allow you to take shortcuts
  Mojo::IOLoop->timer(2 => sub { Mojo::IOLoop->stop });
  Mojo::IOLoop->start;

  # Restart active timer
  my $id = Mojo::IOLoop->timer(3 => sub { say 'Timeout!' });
  Mojo::IOLoop->singleton->reactor->again($id);

  # Turn file descriptor into handle and watch if it becomes readable
  my $handle = IO::Handle->new_from_fd($fd, 'r');
  Mojo::IOLoop->singleton->reactor->io($handle => sub ($reactor, $writable) {
    say $writable ? 'Handle is writable' : 'Handle is readable';
  })->watch($handle, 1, 0);

=head2 start

  Mojo::IOLoop->start;
  $loop->start;

Start the event loop, this will block until L</"stop"> is called. Note that some reactors stop automatically if there
are no events being watched anymore.

  # Start event loop only if it is not running already
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 stop

  Mojo::IOLoop->stop;
  $loop->stop;

Stop the event loop, this will not interrupt any existing connections and the event loop can be restarted by running
L</"start"> again.

=head2 stop_gracefully

  Mojo::IOLoop->stop_gracefully;
  $loop->stop_gracefully;

Stop accepting new connections and wait for already accepted connections to be closed, before stopping the event loop.

=head2 stream

  my $stream = Mojo::IOLoop->stream($id);
  my $stream = $loop->stream($id);
  my $id     = $loop->stream(Mojo::IOLoop::Stream->new);

Get L<Mojo::IOLoop::Stream> object for id or turn object into a connection.

  # Increase inactivity timeout for connection to 300 seconds
  Mojo::IOLoop->stream($id)->timeout(300);

=head2 subprocess

  my $subprocess = Mojo::IOLoop->subprocess;
  my $subprocess = $loop->subprocess;
  my $subprocess = $loop->subprocess(sub ($subprocess) {...}, sub ($subprocess, $err, @results) {...});

Build L<Mojo::IOLoop::Subprocess> object to perform computationally expensive operations in subprocesses, without
blocking the event loop. Callbacks will be passed along to L<Mojo::IOLoop::Subprocess/"run">.

  # Operation that would block the event loop for 5 seconds
  Mojo::IOLoop->subprocess->run_p(sub {
    sleep 5;
    return 'â™¥', 'Mojolicious';
  })->then(sub (@results) {
    say "I $results[0] $results[1]!";
  })->catch(sub ($err) {
    say "Subprocess error: $err";
  });

=head2 timer

  my $id = Mojo::IOLoop->timer(3 => sub ($loop) {...});
  my $id = $loop->timer(0 => sub ($loop) {...});
  my $id = $loop->timer(0.25 => sub ($loop) {...});

Create a new timer, invoking the callback after a given amount of time in seconds.

  # Perform operation in 5 seconds
  Mojo::IOLoop->timer(5 => sub ($loop) {...});

=head1 DEBUGGING

You can set the C<MOJO_IOLOOP_DEBUG> environment variable to get some advanced diagnostics information printed to
C<STDERR>.

  MOJO_IOLOOP_DEBUG=1

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::ByteStream;
use Mojo::Base -strict;
use overload bool => sub {1}, '""' => sub { ${$_[0]} }, fallback => 1;

use Exporter qw(import);
use Mojo::Collection;
use Mojo::Util;

our @EXPORT_OK = ('b');

# Turn most functions from Mojo::Util into methods
my @UTILS = (
  qw(b64_decode b64_encode camelize decamelize gunzip gzip hmac_sha1_sum html_unescape humanize_bytes md5_bytes),
  qw(md5_sum punycode_decode punycode_encode quote sha1_bytes sha1_sum slugify term_escape trim unindent unquote),
  qw(url_escape url_unescape xml_escape xor_encode)
);
for my $name (@UTILS) {
  my $sub = Mojo::Util->can($name);
  Mojo::Util::monkey_patch __PACKAGE__, $name, sub {
    my $self = shift;
    $$self = $sub->($$self, @_);
    return $self;
  };
}

sub b { __PACKAGE__->new(@_) }

sub clone { $_[0]->new(${$_[0]}) }

sub decode { shift->_delegate(\&Mojo::Util::decode, @_) }
sub encode { shift->_delegate(\&Mojo::Util::encode, @_) }

sub new {
  my $class = shift;
  return bless \(my $dummy = join '', @_), ref $class || $class;
}

sub say {
  my ($self, $handle) = @_;
  $handle ||= \*STDOUT;
  say $handle $$self;
  return $self;
}

sub secure_compare { Mojo::Util::secure_compare ${shift()}, shift }

sub size { length ${$_[0]} }

sub split {
  my ($self, $pat, $lim) = (shift, shift, shift // 0);
  return Mojo::Collection->new(map { $self->new($_) } split $pat, $$self, $lim);
}

sub tap { shift->Mojo::Base::tap(@_) }

sub to_string { ${$_[0]} }

sub with_roles { shift->Mojo::Base::with_roles(@_) }

sub _delegate {
  my ($self, $sub) = (shift, shift);
  $$self = $sub->(shift || 'UTF-8', $$self);
  return $self;
}

1;

=encoding utf8

=head1 NAME

Mojo::ByteStream - ByteStream

=head1 SYNOPSIS

  use Mojo::ByteStream;

  # Manipulate bytestream
  my $stream = Mojo::ByteStream->new('foo_bar_baz');
  say $stream->camelize;

  # Chain methods
  my $stream = Mojo::ByteStream->new('foo bar baz')->quote;
  $stream = $stream->unquote->encode('UTF-8')->b64_encode('');
  say "$stream";

  # Use the alternative constructor
  use Mojo::ByteStream qw(b);
  my $stream = b('foobarbaz')->b64_encode('')->say;

=head1 DESCRIPTION

L<Mojo::ByteStream> is a scalar-based container for bytestreams that provides a more friendly API for many of the
functions in L<Mojo::Util>.

  # Access scalar directly to manipulate bytestream
  my $stream = Mojo::ByteStream->new('foo');
  $$stream .= 'bar';

=head1 FUNCTIONS

L<Mojo::ByteStream> implements the following functions, which can be imported individually.

=head2 b

  my $stream = b('test123');

Construct a new scalar-based L<Mojo::ByteStream> object.

=head1 METHODS

L<Mojo::ByteStream> implements the following methods.

=head2 b64_decode

  $stream = $stream->b64_decode;

Base64 decode bytestream with L<Mojo::Util/"b64_decode">.

=head2 b64_encode

  $stream = $stream->b64_encode;
  $stream = $stream->b64_encode("\n");

Base64 encode bytestream with L<Mojo::Util/"b64_encode">.

  # "Zm9vIGJhciBiYXo="
  b('foo bar baz')->b64_encode('');

=head2 camelize

  $stream = $stream->camelize;

Camelize bytestream with L<Mojo::Util/"camelize">.

=head2 clone

  my $stream2 = $stream->clone;

Return a new L<Mojo::ByteStream> object cloned from this bytestream.

=head2 decamelize

  $stream = $stream->decamelize;

Decamelize bytestream with L<Mojo::Util/"decamelize">.

=head2 decode

  $stream = $stream->decode;
  $stream = $stream->decode('iso-8859-1');

Decode bytestream with L<Mojo::Util/"decode">, defaults to using C<UTF-8>.

  # "â™¥"
  b('%E2%99%A5')->url_unescape->decode;

=head2 encode

  $stream = $stream->encode;
  $stream = $stream->encode('iso-8859-1');

Encode bytestream with L<Mojo::Util/"encode">, defaults to using C<UTF-8>.

  # "%E2%99%A5"
  b('â™¥')->encode->url_escape;

=head2 gunzip

  $stream = $stream->gunzip;

Uncompress bytestream with L<Mojo::Util/"gunzip">.

=head2 gzip

  stream = $stream->gzip;

Compress bytestream with L<Mojo::Util/"gzip">.

=head2 hmac_sha1_sum

  $stream = $stream->hmac_sha1_sum('passw0rd');

Generate HMAC-SHA1 checksum for bytestream with L<Mojo::Util/"hmac_sha1_sum">.

  # "7fbdc89263974a89210ea71f171c77d3f8c21471"
  b('foo bar baz')->hmac_sha1_sum('secr3t');

=head2 html_unescape

  $stream = $stream->html_unescape;

Unescape all HTML entities in bytestream with L<Mojo::Util/"html_unescape">.

  # "%3Chtml%3E"
  b('&lt;html&gt;')->html_unescape->url_escape;

=head2 humanize_bytes

  $stream = $stream->humanize_bytes;

Turn number of bytes into a simplified human readable format for bytestream with L<Mojo::Util/"humanize_bytes">.

=head2 md5_bytes

  $stream = $stream->md5_bytes;

Generate binary MD5 checksum for bytestream with L<Mojo::Util/"md5_bytes">.

=head2 md5_sum

  $stream = $stream->md5_sum;

Generate MD5 checksum for bytestream with L<Mojo::Util/"md5_sum">.

=head2 new

  my $stream = Mojo::ByteStream->new('test123');

Construct a new scalar-based L<Mojo::ByteStream> object.

=head2 punycode_decode

  $stream = $stream->punycode_decode;

Punycode decode bytestream with L<Mojo::Util/"punycode_decode">.

=head2 punycode_encode

  $stream = $stream->punycode_encode;

Punycode encode bytestream with L<Mojo::Util/"punycode_encode">.

=head2 quote

  $stream = $stream->quote;

Quote bytestream with L<Mojo::Util/"quote">.

=head2 say

  $stream = $stream->say;
  $stream = $stream->say(*STDERR);

Print bytestream to handle and append a newline, defaults to using C<STDOUT>.

=head2 secure_compare

  my $bool = $stream->secure_compare($str);

Compare bytestream with L<Mojo::Util/"secure_compare">.

=head2 sha1_bytes

  $stream = $stream->sha1_bytes;

Generate binary SHA1 checksum for bytestream with L<Mojo::Util/"sha1_bytes">.

=head2 sha1_sum

  $stream = $stream->sha1_sum;

Generate SHA1 checksum for bytestream with L<Mojo::Util/"sha1_sum">.

=head2 size

  my $size = $stream->size;

Size of bytestream.

=head2 slugify

  $stream = $stream->slugify;
  $stream = $stream->slugify($bool);

Generate URL slug for bytestream with L<Mojo::Util/"slugify">.

=head2 split

  my $collection = $stream->split(',');
  my $collection = $stream->split(',', -1);

Turn bytestream into L<Mojo::Collection> object containing L<Mojo::ByteStream> objects.

  # "One,Two,Three"
  b("one,two,three")->split(',')->map('camelize')->join(',');

  # "One,Two,Three,,,"
  b("one,two,three,,,")->split(',', -1)->map('camelize')->join(',');

=head2 tap

  $stream = $stream->tap(sub {...});

Alias for L<Mojo::Base/"tap">.

=head2 term_escape

  $stream = $stream->term_escape;

Escape POSIX control characters in bytestream with L<Mojo::Util/"term_escape">.

  # Print binary checksum to terminal
  b('foo')->sha1_bytes->term_escape->say;

=head2 to_string

  my $str = $stream->to_string;

Stringify bytestream.

=head2 trim

  $stream = $stream->trim;

Trim whitespace characters from both ends of bytestream with L<Mojo::Util/"trim">.

=head2 unindent

  $stream = $stream->unindent;

Unindent bytestream with L<Mojo::Util/"unindent">.

=head2 unquote

  $stream = $stream->unquote;

Unquote bytestream with L<Mojo::Util/"unquote">.

=head2 url_escape

  $stream = $stream->url_escape;
  $stream = $stream->url_escape('^A-Za-z0-9\-._~');

Percent encode all unsafe characters in bytestream with L<Mojo::Util/"url_escape">.

  # "%E2%98%83"
  b('â˜ƒ')->encode->url_escape;

=head2 url_unescape

  $stream = $stream->url_unescape;

Decode percent encoded characters in bytestream with L<Mojo::Util/"url_unescape">.

  # "&lt;html&gt;"
  b('%3Chtml%3E')->url_unescape->xml_escape;

=head2 with_roles

  my $new_class = Mojo::ByteStream->with_roles('Mojo::ByteStream::Role::One');
  my $new_class = Mojo::ByteStream->with_roles('+One', '+Two');
  $stream       = $stream->with_roles('+One', '+Two');

Alias for L<Mojo::Base/"with_roles">.

=head2 xml_escape

  $stream = $stream->xml_escape;

Escape only the characters C<&>, C<E<lt>>, C<E<gt>>, C<"> and C<'> in bytestream with L<Mojo::Util/"xml_escape">.

=head2 xor_encode

  $stream = $stream->xor_encode($key);

XOR encode bytestream with L<Mojo::Util/"xor_encode">.

  # "%04%0E%15B%03%1B%10"
  b('foo bar')->xor_encode('baz')->url_escape;

=head1 OPERATORS

L<Mojo::ByteStream> overloads the following operators.

=head2 bool

  my $bool = !!$bytestream;

Always true.

=head2 stringify

  my $str = "$bytestream";

Alias for L</"to_string">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Base;

use strict;
use warnings;
use utf8;
use feature ':5.16';
use mro;

# No imports because we get subclassed, a lot!
use Carp         ();
use Scalar::Util ();

# Defer to runtime so Mojo::Util can use "-strict"
require Mojo::Util;

# Role support requires Role::Tiny 2.000001+
use constant ROLES => !!(eval { require Role::Tiny; Role::Tiny->VERSION('2.000001'); 1 });

# async/await support requires Future::AsyncAwait 0.52+
use constant ASYNC => $ENV{MOJO_NO_ASYNC}
  ? 0
  : !!(eval { require Future::AsyncAwait; Future::AsyncAwait->VERSION('0.52'); 1 });

# Protect subclasses using AUTOLOAD
sub DESTROY { }

sub attr {
  my ($self, $attrs, $value, %kv) = @_;
  return unless (my $class = ref $self || $self) && $attrs;

  Carp::croak 'Default has to be a code reference or constant value' if ref $value && ref $value ne 'CODE';
  Carp::croak 'Unsupported attribute option'                         if grep { $_ ne 'weak' } keys %kv;

  # Weaken
  if ($kv{weak}) {
    state %weak_names;
    unless ($weak_names{$class}) {
      my $names = $weak_names{$class} = [];
      my $sub   = sub {
        my $self = shift->next::method(@_);
        ref $self->{$_} and Scalar::Util::weaken $self->{$_} for @$names;
        return $self;
      };
      Mojo::Util::monkey_patch(my $base = $class . '::_Base', 'new', $sub);
      no strict 'refs';
      unshift @{"${class}::ISA"}, $base;
    }
    push @{$weak_names{$class}}, ref $attrs eq 'ARRAY' ? @$attrs : $attrs;
  }

  for my $attr (@{ref $attrs eq 'ARRAY' ? $attrs : [$attrs]}) {
    Carp::croak qq{Attribute "$attr" invalid} unless $attr =~ /^[a-zA-Z_]\w*$/;

    # Very performance-sensitive code with lots of micro-optimizations
    my $sub;
    if ($kv{weak}) {
      if (ref $value) {
        $sub = sub {
          return
            exists $_[0]{$attr}
            ? $_[0]{$attr}
            : (ref($_[0]{$attr} = $value->($_[0])) && Scalar::Util::weaken($_[0]{$attr}), $_[0]{$attr})
            if @_ == 1;
          ref($_[0]{$attr} = $_[1]) and Scalar::Util::weaken($_[0]{$attr});
          $_[0];
        };
      }
      else {
        $sub = sub {
          return $_[0]{$attr} if @_ == 1;
          ref($_[0]{$attr} = $_[1]) and Scalar::Util::weaken($_[0]{$attr});
          $_[0];
        };
      }
    }
    elsif (ref $value) {
      $sub = sub {
        return exists $_[0]{$attr} ? $_[0]{$attr} : ($_[0]{$attr} = $value->($_[0])) if @_ == 1;
        $_[0]{$attr} = $_[1];
        $_[0];
      };
    }
    elsif (defined $value) {
      $sub = sub {
        return exists $_[0]{$attr} ? $_[0]{$attr} : ($_[0]{$attr} = $value) if @_ == 1;
        $_[0]{$attr} = $_[1];
        $_[0];
      };
    }
    else {
      $sub = sub { return $_[0]{$attr} if @_ == 1; $_[0]{$attr} = $_[1]; $_[0] };
    }
    Mojo::Util::monkey_patch($class, $attr, $sub);
  }
}

sub import {
  my ($class, $caller) = (shift, caller);
  return unless my @flags = @_;

  # Mojo modules are strict!
  $_->import for qw(strict warnings utf8);
  feature->import(':5.16');

  while (my $flag = shift @flags) {

    # Base
    if ($flag eq '-base') { push @flags, $class }

    # Role
    elsif ($flag eq '-role') {
      Carp::croak 'Role::Tiny 2.000001+ is required for roles' unless ROLES;
      Mojo::Util::monkey_patch($caller, 'has', sub { attr($caller, @_) });
      eval "package $caller; use Role::Tiny; 1" or die $@;
    }

    # async/await
    elsif ($flag eq '-async_await') {
      Carp::croak 'Future::AsyncAwait 0.52+ is required for async/await' unless ASYNC;
      require Mojo::Promise;
      Future::AsyncAwait->import_into($caller, future_class => 'Mojo::Promise');
    }

    # Signatures (Perl 5.20+)
    elsif ($flag eq '-signatures') {
      Carp::croak 'Subroutine signatures require Perl 5.20+' if $] < 5.020;
      require experimental;
      experimental->import($_) for qw(signatures postderef);
    }

    # Module
    elsif ($flag !~ /^-/) {
      no strict 'refs';
      require(Mojo::Util::class_to_path($flag)) unless $flag->can('new');
      push @{"${caller}::ISA"}, $flag;
      Mojo::Util::monkey_patch($caller, 'has', sub { attr($caller, @_) });
    }

    elsif ($flag ne '-strict') { Carp::croak "Unsupported flag: $flag" }
  }
}

sub new {
  my $class = shift;
  bless @_ ? @_ > 1 ? {@_} : {%{$_[0]}} : {}, ref $class || $class;
}

sub tap {
  my ($self, $cb) = (shift, shift);
  $_->$cb(@_) for $self;
  return $self;
}

sub with_roles {
  Carp::croak 'Role::Tiny 2.000001+ is required for roles' unless ROLES;
  my ($self, @roles) = @_;
  return $self unless @roles;

  return Role::Tiny->create_class_with_roles($self, map { /^\+(.+)$/ ? "${self}::Role::$1" : $_ } @roles)
    unless my $class = Scalar::Util::blessed $self;

  return Role::Tiny->apply_roles_to_object($self, map { /^\+(.+)$/ ? "${class}::Role::$1" : $_ } @roles);
}

1;

=encoding utf8

=head1 NAME

Mojo::Base - Minimal base class for Mojo projects

=head1 SYNOPSIS

  package Cat;
  use Mojo::Base -base;

  has name => 'Nyan';
  has ['age', 'weight'] => 4;

  package Tiger;
  use Mojo::Base 'Cat';

  has friend  => sub { Cat->new };
  has stripes => 42;

  package main;
  use Mojo::Base -strict;

  my $mew = Cat->new(name => 'Longcat');
  say $mew->age;
  say $mew->age(3)->weight(5)->age;

  my $rawr = Tiger->new(stripes => 38, weight => 250);
  say $rawr->tap(sub { $_->friend->name('Tacgnol') })->weight;

=head1 DESCRIPTION

L<Mojo::Base> is a simple base class for L<Mojo> projects with fluent interfaces.

  # Automatically enables "strict", "warnings", "utf8" and Perl 5.16 features
  use Mojo::Base -strict;
  use Mojo::Base -base;
  use Mojo::Base 'SomeBaseClass';
  use Mojo::Base -role;

All four forms save a lot of typing. Note that role support depends on L<Role::Tiny> (2.000001+).

  # use Mojo::Base -strict;
  use strict;
  use warnings;
  use utf8;
  use feature ':5.16';
  use mro;

  # use Mojo::Base -base;
  use strict;
  use warnings;
  use utf8;
  use feature ':5.16';
  use mro;
  push @ISA, 'Mojo::Base';
  sub has { Mojo::Base::attr(__PACKAGE__, @_) }

  # use Mojo::Base 'SomeBaseClass';
  use strict;
  use warnings;
  use utf8;
  use feature ':5.16';
  use mro;
  require SomeBaseClass;
  push @ISA, 'SomeBaseClass';
  sub has { Mojo::Base::attr(__PACKAGE__, @_) }

  # use Mojo::Base -role;
  use strict;
  use warnings;
  use utf8;
  use feature ':5.16';
  use mro;
  use Role::Tiny;
  sub has { Mojo::Base::attr(__PACKAGE__, @_) }

On Perl 5.20+ you can also use the C<-signatures> flag with all four forms and enable support for L<subroutine
signatures|perlsub/"Signatures">.

  # Also enable signatures
  use Mojo::Base -strict, -signatures;
  use Mojo::Base -base, -signatures;
  use Mojo::Base 'SomeBaseClass', -signatures;
  use Mojo::Base -role, -signatures;

If you have L<Future::AsyncAwait> 0.52+ installed you can also use the C<-async_await> flag to activate the C<async>
and C<await> keywords to deal much more efficiently with promises. Note that this feature is B<EXPERIMENTAL> and might
change without warning!

  # Also enable async/await
  use Mojo::Base -strict, -async_await;
  use Mojo::Base -base, -signatures, -async_await;

This will also disable experimental warnings on versions of Perl where this feature was still experimental.

=head1 FLUENT INTERFACES

Fluent interfaces are a way to design object-oriented APIs around method chaining to create domain-specific languages,
with the goal of making the readability of the source code close to written prose.

  package Duck;
  use Mojo::Base -base, -signatures;

  has 'name';

  sub quack ($self) {
    my $name = $self->name;
    say "$name: Quack!"
  }

L<Mojo::Base> will help you with this by having all attribute accessors created with L</"has"> (or L</"attr">) return
their invocant (C<$self>) whenever they are used to assign a new attribute value.

  Duck->new->name('Donald')->quack;

In this case the C<name> attribute accessor is called on the object created by C<Duck-E<gt>new>. It assigns a new
attribute value and then returns the C<Duck> object, so the C<quack> method can be called on it afterwards. These
method chains can continue until one of the methods called does not return the C<Duck> object.

=head1 FUNCTIONS

L<Mojo::Base> implements the following functions, which can be imported with the C<-base> flag or by setting a base
class.

=head2 has

  has 'name';
  has ['name1', 'name2', 'name3'];
  has name => 'foo';
  has name => sub {...};
  has ['name1', 'name2', 'name3'] => 'foo';
  has ['name1', 'name2', 'name3'] => sub {...};
  has name => sub {...}, weak => 1;
  has name => undef, weak => 1;
  has ['name1', 'name2', 'name3'] => sub {...}, weak => 1;

Create attributes for hash-based objects, just like the L</"attr"> method.

=head1 METHODS

L<Mojo::Base> implements the following methods.

=head2 attr

  $object->attr('name');
  SubClass->attr('name');
  SubClass->attr(['name1', 'name2', 'name3']);
  SubClass->attr(name => 'foo');
  SubClass->attr(name => sub {...});
  SubClass->attr(['name1', 'name2', 'name3'] => 'foo');
  SubClass->attr(['name1', 'name2', 'name3'] => sub {...});
  SubClass->attr(name => sub {...}, weak => 1);
  SubClass->attr(name => undef, weak => 1);
  SubClass->attr(['name1', 'name2', 'name3'] => sub {...}, weak => 1);

Create attribute accessors for hash-based objects, an array reference can be used to create more than one at a time.
Pass an optional second argument to set a default value, it should be a constant or a callback. The callback will be
executed at accessor read time if there's no set value, and gets passed the current instance of the object as first
argument. Accessors can be chained, that means they return their invocant when they are called with an argument.

These options are currently available:

=over 2

=item weak

  weak => $bool

Weaken attribute reference to avoid L<circular references|perlref/"Circular-References"> and memory leaks.

=back

=head2 new

  my $object = SubClass->new;
  my $object = SubClass->new(name => 'value');
  my $object = SubClass->new({name => 'value'});

This base class provides a basic constructor for hash-based objects. You can pass it either a hash or a hash reference
with attribute values.

=head2 tap

  $object = $object->tap(sub {...});
  $object = $object->tap('some_method');
  $object = $object->tap('some_method', @args);

Tap into a method chain to perform operations on an object within the chain (also known as a K combinator or Kestrel).
The object will be the first argument passed to the callback, and is also available as C<$_>. The callback's return
value will be ignored; instead, the object (the callback's first argument) will be the return value. In this way,
arbitrary code can be used within (i.e., spliced or tapped into) a chained set of object method calls.

  # Longer version
  $object = $object->tap(sub { $_->some_method(@args) });

  # Inject side effects into a method chain
  $object->foo('A')->tap(sub { say $_->foo })->foo('B');

=head2 with_roles

  my $new_class = SubClass->with_roles('SubClass::Role::One');
  my $new_class = SubClass->with_roles('+One', '+Two');
  $object       = $object->with_roles('+One', '+Two');

Create a new class with one or more L<Role::Tiny> roles. If called on a class returns the new class, or if called on an
object reblesses the object into the new class. For roles following the naming scheme C<MyClass::Role::RoleName> you
can use the shorthand C<+RoleName>. Note that role support depends on L<Role::Tiny> (2.000001+).

  # Create a new class with the role "SubClass::Role::Foo" and instantiate it
  my $new_class = SubClass->with_roles('+Foo');
  my $object    = $new_class->new;

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Transaction::WebSocket;
use Mojo::Base 'Mojo::Transaction';

use Compress::Raw::Zlib qw(Z_SYNC_FLUSH);
use List::Util          qw(first);
use Mojo::JSON          qw(encode_json j);
use Mojo::Util          qw(decode encode trim);
use Mojo::WebSocket     qw(WS_BINARY WS_CLOSE WS_CONTINUATION WS_PING WS_PONG WS_TEXT);

has [qw(compressed established handshake masked)];
has max_websocket_size => sub { $ENV{MOJO_MAX_WEBSOCKET_SIZE} || 262144 };

sub build_message {
  my ($self, $frame) = @_;

  # Text
  $frame = {text => encode('UTF-8', $frame)} if ref $frame ne 'HASH';

  # JSON
  $frame->{text} = encode_json($frame->{json}) if exists $frame->{json};

  # Raw text or binary
  if   (exists $frame->{text}) { $frame = [1, 0, 0, 0, WS_TEXT,   $frame->{text}] }
  else                         { $frame = [1, 0, 0, 0, WS_BINARY, $frame->{binary}] }

  # "permessage-deflate" extension
  return $frame unless $self->compressed;
  my $deflate = $self->{deflate}
    ||= Compress::Raw::Zlib::Deflate->new(AppendOutput => 1, MemLevel => 8, WindowBits => -15);
  $deflate->deflate($frame->[5], my $out);
  $deflate->flush($out, Z_SYNC_FLUSH);
  @$frame[1, 5] = (1, substr($out, 0, length($out) - 4));

  return $frame;
}

sub client_read  { shift->server_read(@_) }
sub client_write { shift->server_write(@_) }

sub closed {
  my $self = shift->completed;
  my @args = $self->{close} ? (@{$self->{close}}) : (1006);
  return $self->emit(finish => @args > 1 ? @args : (@args, undef));
}

sub connection { shift->handshake->connection }

sub finish {
  my $self = shift;

  my $close   = $self->{close} = [@_];
  my $payload = $close->[0] ? pack('n', $close->[0]) : '';
  $payload .= encode 'UTF-8', $close->[1] if defined $close->[1];
  $close->[0] //= 1005;
  $self->send([1, 0, 0, 0, WS_CLOSE, $payload])->{closing} = 1;

  return $self;
}

sub is_websocket {1}

sub kept_alive    { shift->handshake->kept_alive }
sub local_address { shift->handshake->local_address }
sub local_port    { shift->handshake->local_port }

sub parse_message {
  my ($self, $frame) = @_;

  $self->emit(frame => $frame);

  # Ping/Pong
  my $op = $frame->[4];
  return $self->send([1, 0, 0, 0, WS_PONG, $frame->[5]]) if $op == WS_PING;
  return undef                                           if $op == WS_PONG;

  # Close
  if ($op == WS_CLOSE) {
    return $self->finish unless length $frame->[5] >= 2;
    return $self->finish(unpack('n', substr($frame->[5], 0, 2, '')), decode('UTF-8', $frame->[5]));
  }

  # Append chunk and check message size
  @{$self}{qw(op pmc)} = ($op, $self->compressed && $frame->[1]) unless exists $self->{op};
  $self->{message} .= $frame->[5];
  my $max = $self->max_websocket_size;
  return $self->finish(1009) if length $self->{message} > $max;

  # No FIN bit (Continuation)
  return undef unless $frame->[0];

  # "permessage-deflate" extension (handshake and RSV1)
  my $msg = delete $self->{message};
  if ($self->compressed && $self->{pmc}) {
    my $inflate = $self->{inflate}
      ||= Compress::Raw::Zlib::Inflate->new(Bufsize => $max, LimitOutput => 1, WindowBits => -15);
    $inflate->inflate(($msg .= "\x00\x00\xff\xff"), my $out);
    return $self->finish(1009) if length $msg;
    $msg = $out;
  }

  $self->emit(json => j($msg)) if $self->has_subscribers('json');
  $op = delete $self->{op};
  $self->emit($op == WS_TEXT ? 'text' : 'binary' => $msg);
  $self->emit(message => $op == WS_TEXT ? decode 'UTF-8', $msg : $msg) if $self->has_subscribers('message');
}

sub protocol { shift->res->headers->sec_websocket_protocol }

sub remote_address { shift->handshake->remote_address }
sub remote_port    { shift->handshake->remote_port }
sub req            { shift->handshake->req }
sub res            { shift->handshake->res }

sub resume { $_[0]->handshake->resume and return $_[0] }

sub send {
  my ($self, $msg, $cb) = @_;
  $self->once(drain => $cb) if $cb;
  $msg = $self->build_message($msg) unless ref $msg eq 'ARRAY';
  $self->{write} .= Mojo::WebSocket::build_frame($self->masked, @$msg);
  return $self->emit('resume');
}

sub server_read {
  my ($self, $chunk) = @_;

  $self->{read} .= $chunk;
  my $max = $self->max_websocket_size;
  while (my $frame = Mojo::WebSocket::parse_frame(\$self->{read}, $max)) {
    $self->finish(1009) and last unless ref $frame;
    $self->parse_message($frame);
  }

  $self->emit('resume');
}

sub server_write {
  my $self = shift;
  $self->emit('drain') unless length($self->{write} //= '');
  $self->completed if !length $self->{write} && $self->{closing};
  return delete $self->{write};
}

sub with_compression {
  my $self = shift;

  # "permessage-deflate" extension
  $self->compressed(1) and $self->res->headers->sec_websocket_extensions('permessage-deflate')
    if ($self->req->headers->sec_websocket_extensions // '') =~ /permessage-deflate/;
}

sub with_protocols {
  my $self = shift;

  my %protos = map { trim($_) => 1 } split /,/, $self->req->headers->sec_websocket_protocol // '';
  return undef unless defined(my $proto = first { $protos{$_} } @_);

  $self->res->headers->sec_websocket_protocol($proto);
  return $proto;
}

1;

=encoding utf8

=head1 NAME

Mojo::Transaction::WebSocket - WebSocket transaction

=head1 SYNOPSIS

  use Mojo::Transaction::WebSocket;

  # Send and receive WebSocket messages
  my $ws = Mojo::Transaction::WebSocket->new;
  $ws->send('Hello World!');
  $ws->on(message => sub ($ws, $msg) { say "Message: $msg" });
  $ws->on(finish => sub ($ws, $code, $reason) { say "WebSocket closed with status $code." });

=head1 DESCRIPTION

L<Mojo::Transaction::WebSocket> is a container for WebSocket transactions, based on L<RFC
6455|https://tools.ietf.org/html/rfc6455> and L<RFC 7692|https://tools.ietf.org/html/rfc7692>.

=head1 EVENTS

L<Mojo::Transaction::WebSocket> inherits all events from L<Mojo::Transaction> and can emit the following new ones.

=head2 binary

  $ws->on(binary => sub ($ws, $bytes) {...});

Emitted when a complete WebSocket binary message has been received.

  $ws->on(binary => sub ($ws, $bytes) { say "Binary: $bytes" });

=head2 drain

  $ws->on(drain => sub ($ws) {...});

Emitted once all data has been sent.

  $ws->on(drain => sub ($ws) { $ws->send(time) });

=head2 finish

  $ws->on(finish => sub ($ws, $code, $reason) {...});

Emitted when the WebSocket connection has been closed.

=head2 frame

  $ws->on(frame => sub ($ws, $frame) {...});

Emitted when a WebSocket frame has been received.

  $ws->on(frame => sub ($ws, $frame) {
    say "FIN: $frame->[0]";
    say "RSV1: $frame->[1]";
    say "RSV2: $frame->[2]";
    say "RSV3: $frame->[3]";
    say "Opcode: $frame->[4]";
    say "Payload: $frame->[5]";
  });

=head2 json

  $ws->on(json => sub ($ws, $json) {...});

Emitted when a complete WebSocket message has been received, all text and binary messages will be automatically JSON
decoded. Note that this event only gets emitted when it has at least one subscriber.

  $ws->on(json => sub ($ws, $hash) { say "Message: $hash->{msg}" });

=head2 message

  $ws->on(message => sub ($ws, $msg) {...});

Emitted when a complete WebSocket message has been received, text messages will be automatically decoded. Note that
this event only gets emitted when it has at least one subscriber.

  $ws->on(message => sub ($ws, $msg) { say "Message: $msg" });

=head2 resume

  $tx->on(resume => sub ($tx) {...});

Emitted when transaction is resumed.

=head2 text

  $ws->on(text => sub ($ws, $bytes) {...});

Emitted when a complete WebSocket text message has been received.

  $ws->on(text => sub ($ws, $bytes) { say "Text: $bytes" });

=head1 ATTRIBUTES

L<Mojo::Transaction::WebSocket> inherits all attributes from L<Mojo::Transaction> and implements the following new
ones.

=head2 compressed

  my $bool = $ws->compressed;
  $ws      = $ws->compressed($bool);

Compress messages with C<permessage-deflate> extension.

=head2 established

  my $bool = $ws->established;
  $ws      = $ws->established($bool);

WebSocket connection established.

=head2 handshake

  my $handshake = $ws->handshake;
  $ws           = $ws->handshake(Mojo::Transaction::HTTP->new);

The original handshake transaction, usually a L<Mojo::Transaction::HTTP> object.

=head2 masked

  my $bool = $ws->masked;
  $ws      = $ws->masked($bool);

Mask outgoing frames with XOR cipher and a random 32-bit key.

=head2 max_websocket_size

  my $size = $ws->max_websocket_size;
  $ws      = $ws->max_websocket_size(1024);

Maximum WebSocket message size in bytes, defaults to the value of the C<MOJO_MAX_WEBSOCKET_SIZE> environment variable
or C<262144> (256KiB).

=head1 METHODS

L<Mojo::Transaction::WebSocket> inherits all methods from L<Mojo::Transaction> and implements the following new ones.

=head2 build_message

  my $frame = $ws->build_message({binary => $bytes});
  my $frame = $ws->build_message({text   => $bytes});
  my $frame = $ws->build_message({json   => {test => [1, 2, 3]}});
  my $frame = $ws->build_message($chars);

Build WebSocket message.

=head2 client_read

  $ws->client_read($data);

Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.

=head2 client_write

  my $bytes = $ws->client_write;

Write data client-side, used to implement user agents such as L<Mojo::UserAgent>.

=head2 closed

  $tx = $tx->closed;

Same as L<Mojo::Transaction/"completed">, but also indicates that all transaction data has been sent.

=head2 connection

  my $id = $ws->connection;

Connection identifier.

=head2 finish

  $ws = $ws->finish;
  $ws = $ws->finish(1000);
  $ws = $ws->finish(1003 => 'Cannot accept data!');

Close WebSocket connection gracefully.

=head2 is_websocket

  my $bool = $ws->is_websocket;

True, this is a L<Mojo::Transaction::WebSocket> object.

=head2 kept_alive

  my $bool = $ws->kept_alive;

Connection has been kept alive.

=head2 local_address

  my $address = $ws->local_address;

Local interface address.

=head2 local_port

  my $port = $ws->local_port;

Local interface port.

=head2 parse_message

  $ws->parse_message([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);

Parse WebSocket message.

=head2 protocol

  my $proto = $ws->protocol;

Return negotiated subprotocol or C<undef>.

=head2 remote_address

  my $address = $ws->remote_address;

Remote interface address.

=head2 remote_port

  my $port = $ws->remote_port;

Remote interface port.

=head2 req

  my $req = $ws->req;

Handshake request, usually a L<Mojo::Message::Request> object.

=head2 res

  my $res = $ws->res;

Handshake response, usually a L<Mojo::Message::Response> object.

=head2 resume

  $ws = $ws->resume;

Resume L</"handshake"> transaction.

=head2 send

  $ws = $ws->send({binary => $bytes});
  $ws = $ws->send({text   => $bytes});
  $ws = $ws->send({json   => {test => [1, 2, 3]}});
  $ws = $ws->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
  $ws = $ws->send($chars);
  $ws = $ws->send($chars => sub {...});

Send message or frame non-blocking via WebSocket, the optional drain callback will be executed once all data has been
written.

  # Send "Ping" frame
  use Mojo::WebSocket qw(WS_PING);
  $ws->send([1, 0, 0, 0, WS_PING, 'Hello World!']);

=head2 server_read

  $ws->server_read($data);

Read data server-side, used to implement web servers such as L<Mojo::Server::Daemon>.

=head2 server_write

  my $bytes = $ws->server_write;

Write data server-side, used to implement web servers such as L<Mojo::Server::Daemon>.

=head2 with_compression

  $ws->with_compression;

Negotiate C<permessage-deflate> extension for this WebSocket connection.

=head2 with_protocols

  my $proto = $ws->with_protocols('v2.proto', 'v1.proto');

Negotiate subprotocol for this WebSocket connection.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Transaction::HTTP;
use Mojo::Base 'Mojo::Transaction';

has 'previous';

sub client_read {
  my ($self, $chunk) = @_;

  # Skip body for HEAD request
  my $res = $self->res;
  $res->content->skip_body(1) if uc $self->req->method eq 'HEAD';
  return undef unless $res->parse($chunk)->is_finished;

  # Unexpected 1xx response
  return $self->completed if !$res->is_info || $res->headers->upgrade;
  $self->res($res->new)->emit(unexpected => $res);
  return undef unless length(my $leftovers = $res->content->leftovers);
  $self->client_read($leftovers);
}

sub client_write { shift->_write(0) }

sub is_empty { !!(uc $_[0]->req->method eq 'HEAD' || $_[0]->res->is_empty) }

sub keep_alive {
  my $self = shift;

  # Close
  my $req      = $self->req;
  my $res      = $self->res;
  my $req_conn = lc($req->headers->connection // '');
  my $res_conn = lc($res->headers->connection // '');
  return undef if $req_conn eq 'close' || $res_conn eq 'close';

  # Keep-alive is optional for 1.0
  return $res_conn eq 'keep-alive' if $res->version eq '1.0';
  return $req_conn eq 'keep-alive' if $req->version eq '1.0';

  # Keep-alive is the default for 1.1
  return 1;
}

sub redirects {
  my $previous = shift;
  my @redirects;
  unshift @redirects, $previous while $previous = $previous->previous;
  return \@redirects;
}

sub resume { ++$_[0]{writing} and return $_[0]->emit('resume') }

sub server_read {
  my ($self, $chunk) = @_;

  # Parse request
  my $req = $self->req;
  $req->parse($chunk) unless $req->error;

  # Generate response
  $self->emit('request') if $req->is_finished && !$self->{handled}++;
}

sub server_write { shift->_write(1) }

sub _body {
  my ($self, $msg, $finish) = @_;

  # Prepare body chunk
  my $buffer = $msg->get_body_chunk($self->{offset});
  $self->{offset} += defined $buffer ? length $buffer : 0;

  # Delayed
  $self->{writing} = 0 unless defined $buffer;

  # Finished
  $finish ? $self->completed : ($self->{writing} = 0) if defined $buffer && !length $buffer;

  return $buffer // '';
}

sub _headers {
  my ($self, $msg, $head) = @_;

  # Prepare header chunk
  my $buffer  = $msg->get_header_chunk($self->{offset});
  my $written = defined $buffer ? length $buffer : 0;
  $self->{write}  -= $written;
  $self->{offset} += $written;

  # Switch to body
  if ($self->{write} <= 0) {
    @$self{qw(http_state offset)} = ('body', 0);

    # Response without body
    $self->completed->{http_state} = 'empty' if $head && $self->is_empty;
  }

  return $buffer;
}

sub _start_line {
  my ($self, $msg) = @_;

  # Prepare start-line chunk
  my $buffer  = $msg->get_start_line_chunk($self->{offset});
  my $written = defined $buffer ? length $buffer : 0;
  $self->{write}  -= $written;
  $self->{offset} += $written;

  # Switch to headers
  @$self{qw(http_state write offset)} = ('headers', $msg->header_size, 0) if $self->{write} <= 0;

  return $buffer;
}

sub _write {
  my ($self, $server) = @_;

  # Client starts writing right away
  return '' unless $server ? $self->{writing} : ($self->{writing} //= 1);

  # Nothing written yet
  $self->{$_} ||= 0 for qw(offset write);
  my $msg = $server ? $self->res : $self->req;
  @$self{qw(http_state write)} = ('start_line', $msg->start_line_size) unless $self->{http_state};

  # Start-line
  my $chunk = '';
  $chunk .= $self->_start_line($msg) if $self->{http_state} eq 'start_line';

  # Headers
  $chunk .= $self->_headers($msg, $server) if $self->{http_state} eq 'headers';

  # Body
  $chunk .= $self->_body($msg, $server) if $self->{http_state} eq 'body';

  return $chunk;
}

1;

=encoding utf8

=head1 NAME

Mojo::Transaction::HTTP - HTTP transaction

=head1 SYNOPSIS

  use Mojo::Transaction::HTTP;

  # Client
  my $tx = Mojo::Transaction::HTTP->new;
  $tx->req->method('GET');
  $tx->req->url->parse('http://example.com');
  $tx->req->headers->accept('application/json');
  say $tx->res->code;
  say $tx->res->headers->content_type;
  say $tx->res->body;
  say $tx->remote_address;

  # Server
  my $tx = Mojo::Transaction::HTTP->new;
  say $tx->req->method;
  say $tx->req->url->to_abs;
  say $tx->req->headers->accept;
  say $tx->remote_address;
  $tx->res->code(200);
  $tx->res->headers->content_type('text/plain');
  $tx->res->body('Hello World!');

=head1 DESCRIPTION

L<Mojo::Transaction::HTTP> is a container for HTTP transactions, based on L<RFC
7230|https://tools.ietf.org/html/rfc7230> and L<RFC 7231|https://tools.ietf.org/html/rfc7231>.

=head1 EVENTS

L<Mojo::Transaction::HTTP> inherits all events from L<Mojo::Transaction> and can emit the following new ones.

=head2 request

  $tx->on(request => sub ($tx) {...});

Emitted when a request is ready and needs to be handled.

  $tx->on(request => sub ($tx) { $tx->res->headers->header('X-Bender' => 'Bite my shiny metal ass!') });

=head2 resume

  $tx->on(resume => sub ($tx) {...});

Emitted when transaction is resumed.

=head2 unexpected

  $tx->on(unexpected => sub ($tx, $res) {...});

Emitted for unexpected C<1xx> responses that will be ignored.

  $tx->on(unexpected => sub ($tx) { $tx->res->on(finish => sub { say 'Follow-up response is finished.' }) });

=head1 ATTRIBUTES

L<Mojo::Transaction::HTTP> inherits all attributes from L<Mojo::Transaction> and implements the following new ones.

=head2 previous

  my $previous = $tx->previous;
  $tx          = $tx->previous(Mojo::Transaction::HTTP->new);

Previous transaction that triggered this follow-up transaction, usually a L<Mojo::Transaction::HTTP> object.

  # Paths of previous requests
  say $tx->previous->previous->req->url->path;
  say $tx->previous->req->url->path;

=head1 METHODS

L<Mojo::Transaction::HTTP> inherits all methods from L<Mojo::Transaction> and implements the following new ones.

=head2 client_read

  $tx->client_read($bytes);

Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.

=head2 client_write

  my $bytes = $tx->client_write;

Write data client-side, used to implement user agents such as L<Mojo::UserAgent>.

=head2 is_empty

  my $bool = $tx->is_empty;

Check transaction for C<HEAD> request and C<1xx>, C<204> or C<304> response.

=head2 keep_alive

  my $bool = $tx->keep_alive;

Check if connection can be kept alive.

=head2 redirects

  my $redirects = $tx->redirects;

Return an array reference with all previous transactions that preceded this follow-up transaction.

  # Paths of all previous requests
  say $_->req->url->path for @{$tx->redirects};

=head2 resume

  $tx = $tx->resume;

Resume transaction.

=head2 server_read

  $tx->server_read($bytes);

Read data server-side, used to implement web servers such as L<Mojo::Server::Daemon>.

=head2 server_write

  my $bytes = $tx->server_write;

Write data server-side, used to implement web servers such as L<Mojo::Server::Daemon>.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Exception;
use Mojo::Base -base;
use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;

use Carp         qw(croak);
use Exporter     qw(import);
use Mojo::Util   qw(decode);
use Scalar::Util qw(blessed);

has [qw(frames line lines_after lines_before)] => sub { [] };
has message                                    => 'Exception!';
has verbose                                    => sub { $ENV{MOJO_EXCEPTION_VERBOSE} };

our @EXPORT_OK = qw(check raise);

sub check {
  my ($err, $spec) = @_;
  return undef unless $err;

  croak "Array reference of pattern/handler pairs required to dispatch exceptions"
    if ref $spec ne 'ARRAY' || @$spec % 2;

  my ($default, $handler);
  my ($is_obj,  $str) = (!!blessed($err), "$err");
CHECK: for (my $i = 0; $i < @$spec; $i += 2) {
    my ($checks, $cb) = @{$spec}[$i, $i + 1];

    ($default = $cb) and next if $checks eq 'default';

    for my $c (ref $checks eq 'ARRAY' ? @$checks : $checks) {
      my $is_re = !!ref $c;
      ($handler = $cb) and last CHECK if $is_obj && !$is_re && $err->isa($c);
      ($handler = $cb) and last CHECK if $is_re  && $str =~ $c;
    }
  }

  # Rethrow if no handler could be found
  die $err unless $handler ||= $default;
  $handler->($_) for $err;

  return 1;
}

sub inspect {
  my ($self, @sources) = @_;

  return $self if @{$self->line};

  # Extract file and line from message
  my @files;
  my $msg = $self->message;
  unshift @files, [$1, $2] while $msg =~ /at\s+(.+?)\s+line\s+(\d+)/g;

  # Extract file and line from stack trace
  if (my $zero = $self->frames->[0]) { push @files, [$zero->[1], $zero->[2]] }

  # Search for context in files
  for my $file (@files) {
    next unless -r $file->[0] && open my $handle, '<', $file->[0];
    $self->_context($file->[1], [[<$handle>]]);
    return $self;
  }

  # Search for context in sources
  $self->_context($files[-1][1], [map { [split /\n/] } @sources]) if @sources;

  return $self;
}

sub new { defined $_[1] ? shift->SUPER::new(message => shift) : shift->SUPER::new }

sub raise {
  my ($class, $err) = @_ > 1 ? (@_) : (__PACKAGE__, shift);

  if    (!$class->can('new'))       { die $@ unless eval "package $class; use Mojo::Base 'Mojo::Exception'; 1" }
  elsif (!$class->isa(__PACKAGE__)) { die "$class is not a Mojo::Exception subclass" }

  CORE::die $class->new($err)->trace;
}

sub to_string {
  my $self = shift;

  my $str = $self->message;

  my $frames = $self->frames;
  if ($str !~ /\n$/) {
    $str .= @$frames ? " at $frames->[0][1] line $frames->[0][2].\n" : "\n";
  }
  return $str unless $self->verbose;

  my $line = $self->line;
  if (@$line) {
    $str .= "Context:\n";
    $str .= "  $_->[0]: $_->[1]\n" for @{$self->lines_before};
    $str .= "  $line->[0]: $line->[1]\n";
    $str .= "  $_->[0]: $_->[1]\n" for @{$self->lines_after};
  }

  if (my $max = @$frames) {
    $str .= "Traceback (most recent call first):\n";
    $str .= qq{  File "$_->[1]", line $_->[2], in "$_->[3]"\n} for @$frames;
  }

  return $str;
}

sub throw { CORE::die shift->new(shift)->trace }

sub trace {
  my ($self, $start) = (shift, shift // 1);
  my @frames;
  while (my @trace = caller($start++)) { push @frames, \@trace }
  return $self->frames(\@frames);
}

sub _append {
  my ($stack, $line) = @_;
  $line = decode('UTF-8', $line) // $line;
  chomp $line;
  push @$stack, $line;
}

sub _context {
  my ($self, $num, $sources) = @_;

  # Line
  return unless defined $sources->[0][$num - 1];
  $self->line([$num]);
  _append($self->line, $_->[$num - 1]) for @$sources;

  # Before
  for my $i (2 .. 6) {
    last if ((my $previous = $num - $i) < 0);
    unshift @{$self->lines_before}, [$previous + 1];
    _append($self->lines_before->[0], $_->[$previous]) for @$sources;
  }

  # After
  for my $i (0 .. 4) {
    next if ((my $next = $num + $i) < 0);
    next unless defined $sources->[0][$next];
    push @{$self->lines_after}, [$next + 1];
    _append($self->lines_after->[-1], $_->[$next]) for @$sources;
  }
}

1;

=encoding utf8

=head1 NAME

Mojo::Exception - Exception base class

=head1 SYNOPSIS

  # Create exception classes
  package MyApp::X::Foo {
    use Mojo::Base 'Mojo::Exception';
  }
  package MyApp::X::Bar {
    use Mojo::Base 'Mojo::Exception';
  }

  # Throw exceptions and handle them gracefully
  use Mojo::Exception qw(check);
  eval {
    MyApp::X::Foo->throw('Something went wrong!');
  };
  check $@ => [
    'MyApp::X::Foo' => sub { say "Foo: $_" },
    'MyApp::X::Bar' => sub { say "Bar: $_" }
  ];

  # Generate exception classes on demand
  use Mojo::Exception qw(check raise);
  eval {
    raise 'MyApp::X::Name', 'The name Minion is already taken';
  };
  check $@ => [
    'MyApp::X::Name' => sub { say "Name error: $_" },
    default          => sub { say "Error: $_" }
  ];

=head1 DESCRIPTION

L<Mojo::Exception> is a container for exceptions with context information.

=head1 FUNCTIONS

L<Mojo::Exception> implements the following functions, which can be imported individually.

=head2 check

  my $bool = check $err => ['MyApp::X::Foo' => sub {...}];

Process exceptions by dispatching them to handlers with one or more matching conditions. Exceptions that could not be
handled will be rethrown automatically. Note that this function is B<EXPERIMENTAL> and might change without warning!

  # Handle various types of exceptions
  eval {
    dangerous_code();
  };
  check $@ => [
    'MyApp::X::Foo'     => sub { say "Foo: $_" },
    qr/^Could not open/ => sub { say "Open error: $_" },
    default             => sub { say "Something went wrong: $_" }
  ];

Matching conditions can be class names for ISA checks on exception objects, or regular expressions to match string
exceptions and stringified exception objects. The matching exception will be the first argument passed to the callback,
and is also available as C<$_>.

  # Catch MyApp::X::Foo object or a specific string exception
  eval {
    dangerous_code();
  };
  check $@ => [
    'MyApp::X::Foo'     => sub { say "Foo: $_" },
    qr/^Could not open/ => sub { say "Open error: $_" }
  ];

An array reference can be used to share the same handler with multiple conditions, of which only one needs to match.
And since exception handlers are just callbacks, they can also throw their own exceptions.

  # Handle MyApp::X::Foo and MyApp::X::Bar the same
  eval {
    dangerous_code();
  };
  check $@ => [
    ['MyApp::X::Foo', 'MyApp::X::Bar'] => sub { die "Foo/Bar: $_" }
  ];

There is currently only one keywords you can use to set special handlers. The C<default> handler is used when no other
handler matched.

  # Use "default" to catch everything
  eval {
    dangerous_code();
  };
  check $@ => [
    default => sub { say "Error: $_" }
  ];

=head2 raise

  raise 'Something went wrong!';
  raise 'MyApp::X::Foo', 'Something went wrong!';

Raise a L<Mojo::Exception>, if the class does not exist yet (classes are checked for a C<new> method), one is created
as a L<Mojo::Exception> subclass on demand. Note that this function is B<EXPERIMENTAL> and might change without
warning!

=head1 ATTRIBUTES

L<Mojo::Exception> implements the following attributes.

=head2 frames

  my $frames = $e->frames;
  $e         = $e->frames([$frame1, $frame2]);

Stack trace if available.

  # Extract information from the last frame
  my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext,
      $is_require, $hints, $bitmask, $hinthash) = @{$e->frames->[-1]};

=head2 line

  my $line = $e->line;
  $e       = $e->line([3, 'die;']);

The line where the exception occurred if available.

=head2 lines_after

  my $lines = $e->lines_after;
  $e        = $e->lines_after([[4, 'say $foo;'], [5, 'say $bar;']]);

Lines after the line where the exception occurred if available.

=head2 lines_before

  my $lines = $e->lines_before;
  $e        = $e->lines_before([[1, 'my $foo = 23;'], [2, 'my $bar = 24;']]);

Lines before the line where the exception occurred if available.

=head2 message

  my $msg = $e->message;
  $e      = $e->message('Died at test.pl line 3.');

Exception message, defaults to C<Exception!>.

=head2 verbose

  my $bool = $e->verbose;
  $e       = $e->verbose($bool);

Show more information with L</"to_string">, such as L</"frames">, defaults to the value of the
C<MOJO_EXCEPTION_VERBOSE> environment variable.

=head1 METHODS

L<Mojo::Exception> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 inspect

  $e = $e->inspect;
  $e = $e->inspect($source1, $source2);

Inspect L</"message">, L</"frames"> and optional additional sources to fill L</"lines_before">, L</"line"> and
L</"lines_after"> with context information.

=head2 new

  my $e = Mojo::Exception->new;
  my $e = Mojo::Exception->new('Died at test.pl line 3.');

Construct a new L<Mojo::Exception> object and assign L</"message"> if necessary.

=head2 to_string

  my $str = $e->to_string;

Render exception. Note that the output format may change as more features are added, only the error message at the
beginning is guaranteed not to be modified to allow regex matching.

=head2 throw

  Mojo::Exception->throw('Something went wrong!');

Throw exception from the current execution context.

  # Longer version
  die Mojo::Exception->new('Something went wrong!')->trace;

=head2 trace

  $e = $e->trace;
  $e = $e->trace($skip);

Generate stack trace and store all L</"frames">, defaults to skipping C<1> call frame.

  # Skip 3 call frames
  $e->trace(3);

  # Skip no call frames
  $e->trace(0);

=head1 OPERATORS

L<Mojo::Exception> overloads the following operators.

=head2 bool

  my $bool = !!$e;

Always true.

=head2 stringify

  my $str = "$e";

Alias for L</"to_string">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Transaction;
use Mojo::Base 'Mojo::EventEmitter';

use Carp       qw(croak);
use List::Util qw(any);
use Mojo::Message::Request;
use Mojo::Message::Response;
use Mojo::Util qw(network_contains);

has [qw(kept_alive local_address local_port original_remote_address remote_port)];
has req => sub { Mojo::Message::Request->new };
has res => sub { Mojo::Message::Response->new };

sub client_read  { croak 'Method "client_read" not implemented by subclass' }
sub client_write { croak 'Method "client_write" not implemented by subclass' }

sub closed { shift->completed->emit('finish') }

sub completed { ++$_[0]{completed} and return $_[0] }

sub connection {
  my $self = shift;
  return $self->emit(connection => $self->{connection} = shift) if @_;
  return $self->{connection};
}

sub error { $_[0]->req->error || $_[0]->res->error }

sub is_finished { !!shift->{completed} }

sub is_websocket {undef}

sub remote_address {
  my $self = shift;

  return $self->original_remote_address(@_) if @_;
  return $self->original_remote_address unless $self->req->reverse_proxy;

  # Reverse proxy
  my @addrs   = split /\s*,\s*/, ($self->req->headers->header('X-Forwarded-For') // '');
  my $trusted = $self->req->trusted_proxies;
  return @addrs ? $addrs[-1] : $self->original_remote_address unless @$trusted;

  push @addrs, $self->original_remote_address;
  for my $addr (reverse @addrs) {
    return $addr unless any { network_contains($_, $addr) } @$trusted;
  }
  return $addrs[0];
}

sub result {
  my $self = shift;
  my $err  = $self->error;
  return !$err || $err->{code} ? $self->res : croak $err->{message};
}

sub server_read  { croak 'Method "server_read" not implemented by subclass' }
sub server_write { croak 'Method "server_write" not implemented by subclass' }

1;

=encoding utf8

=head1 NAME

Mojo::Transaction - Transaction base class

=head1 SYNOPSIS

  package Mojo::Transaction::MyTransaction;
  use Mojo::Base 'Mojo::Transaction';

  sub client_read  {...}
  sub client_write {...}
  sub server_read  {...}
  sub server_write {...}

=head1 DESCRIPTION

L<Mojo::Transaction> is an abstract base class for transactions, like L<Mojo::Transaction::HTTP> and
L<Mojo::Transaction::WebSocket>.

=head1 EVENTS

L<Mojo::Transaction> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 connection

  $tx->on(connection => sub ($tx, $connection) {...});

Emitted when a connection has been assigned to transaction.

=head2 finish

  $tx->on(finish => sub ($tx) {...});

Emitted when transaction is finished.

=head1 ATTRIBUTES

L<Mojo::Transaction> implements the following attributes.

=head2 kept_alive

  my $bool = $tx->kept_alive;
  $tx      = $tx->kept_alive($bool);

Connection has been kept alive.

=head2 local_address

  my $address = $tx->local_address;
  $tx         = $tx->local_address('127.0.0.1');

Local interface address.

=head2 local_port

  my $port = $tx->local_port;
  $tx      = $tx->local_port(8080);

Local interface port.

=head2 original_remote_address

  my $address = $tx->original_remote_address;
  $tx         = $tx->original_remote_address('127.0.0.1');

Remote interface address.

=head2 remote_port

  my $port = $tx->remote_port;
  $tx      = $tx->remote_port(8081);

Remote interface port.

=head2 req

  my $req = $tx->req;
  $tx     = $tx->req(Mojo::Message::Request->new);

HTTP request, defaults to a L<Mojo::Message::Request> object.

  # Access request information
  my $method = $tx->req->method;
  my $url    = $tx->req->url->to_abs;
  my $info   = $tx->req->url->to_abs->userinfo;
  my $host   = $tx->req->url->to_abs->host;
  my $agent  = $tx->req->headers->user_agent;
  my $custom = $tx->req->headers->header('Custom-Header');
  my $bytes  = $tx->req->body;
  my $str    = $tx->req->text;
  my $hash   = $tx->req->params->to_hash;
  my $all    = $tx->req->uploads;
  my $value  = $tx->req->json;
  my $foo    = $tx->req->json('/23/foo');
  my $dom    = $tx->req->dom;
  my $bar    = $tx->req->dom('div.bar')->first->text;

=head2 res

  my $res = $tx->res;
  $tx     = $tx->res(Mojo::Message::Response->new);

HTTP response, defaults to a L<Mojo::Message::Response> object.

  # Access response information
  my $code    = $tx->res->code;
  my $message = $tx->res->message;
  my $server  = $tx->res->headers->server;
  my $custom  = $tx->res->headers->header('Custom-Header');
  my $bytes   = $tx->res->body;
  my $str     = $tx->res->text;
  my $value   = $tx->res->json;
  my $foo     = $tx->res->json('/23/foo');
  my $dom     = $tx->res->dom;
  my $bar     = $tx->res->dom('div.bar')->first->text;

=head1 METHODS

L<Mojo::Transaction> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 client_read

  $tx->client_read($bytes);

Read data client-side, used to implement user agents such as L<Mojo::UserAgent>. Meant to be overloaded in a subclass.

=head2 client_write

  my $bytes = $tx->client_write;

Write data client-side, used to implement user agents such as L<Mojo::UserAgent>. Meant to be overloaded in a subclass.

=head2 closed

  $tx = $tx->closed;

Same as L</"completed">, but also indicates that all transaction data has been sent.

=head2 completed

  $tx = $tx->completed;

Low-level method to finalize transaction.

=head2 connection

  my $id = $tx->connection;
  $tx    = $tx->connection($id);

Connection identifier.

=head2 error

  my $err = $tx->error;

Get request or response error and return C<undef> if there is no error.

  # Longer version
  my $err = $tx->req->error || $tx->res->error;

  # Check for 4xx/5xx response and connection errors
  if (my $err = $tx->error) {
    die "$err->{code} response: $err->{message}" if $err->{code};
    die "Connection error: $err->{message}";
  }

=head2 is_finished

  my $bool = $tx->is_finished;

Check if transaction is finished.

=head2 is_websocket

  my $bool = $tx->is_websocket;

False, this is not a L<Mojo::Transaction::WebSocket> object.

=head2 remote_address

  my $address = $tx->remote_address;
  $tx         = $tx->remote_address('127.0.0.1');

Same as L</"original_remote_address"> unless L</"req"> has been performed via a L<Mojo::Message::Request/reverse_proxy>.
If so then the last value of C<X-Forwarded-For> header is returned. Additionally if
L<Mojo::Message::Request/trusted_proxies> are also provided then the original address must be trusted and any
C<X-Forwarded-For> entries that are trusted are ignored, returning the last untrusted address or the first address if
all are trusted.

=head2 result

  my $res = $tx->result;

Returns the L<Mojo::Message::Response> object from L</"res"> or dies if a connection error has occurred.

  # Fine grained response handling (dies on connection errors)
  my $res = $tx->result;
  if    ($res->is_success)  { say $res->body }
  elsif ($res->is_error)    { say $res->message }
  elsif ($res->code == 301) { say $res->headers->location }
  else                      { say 'Whatever...' }

=head2 server_read

  $tx->server_read($bytes);

Read data server-side, used to implement web servers such as L<Mojo::Server::Daemon>. Meant to be overloaded in a
subclass.

=head2 server_write

  my $bytes = $tx->server_write;

Write data server-side, used to implement web servers such as L<Mojo::Server::Daemon>. Meant to be overloaded in a
subclass.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::UserAgent;
use Mojo::Base 'Mojo::EventEmitter';

# "Fry: Since when is the Internet about robbing people of their privacy?
#  Bender: August 6, 1991."
use Mojo::IOLoop;
use Mojo::Promise;
use Mojo::Util qw(monkey_patch term_escape);
use Mojo::UserAgent::CookieJar;
use Mojo::UserAgent::Proxy;
use Mojo::UserAgent::Server;
use Mojo::UserAgent::Transactor;
use Scalar::Util qw(weaken);

use constant DEBUG => $ENV{MOJO_CLIENT_DEBUG} || 0;

has ca                 => sub { $ENV{MOJO_CA_FILE} };
has cert               => sub { $ENV{MOJO_CERT_FILE} };
has connect_timeout    => sub { $ENV{MOJO_CONNECT_TIMEOUT} || 10 };
has cookie_jar         => sub { Mojo::UserAgent::CookieJar->new };
has inactivity_timeout => sub { $ENV{MOJO_INACTIVITY_TIMEOUT} // 40 };
has insecure           => sub { $ENV{MOJO_INSECURE} };
has 'max_response_size';
has ioloop                           => sub { Mojo::IOLoop->new };
has key                              => sub { $ENV{MOJO_KEY_FILE} };
has max_connections                  => 5;
has max_redirects                    => sub { $ENV{MOJO_MAX_REDIRECTS} || 0 };
has proxy                            => sub { Mojo::UserAgent::Proxy->new };
has request_timeout                  => sub { $ENV{MOJO_REQUEST_TIMEOUT} // 0 };
has server                           => sub { Mojo::UserAgent::Server->new(ioloop => shift->ioloop) };
has [qw(socket_options tls_options)] => sub { {} };
has transactor                       => sub { Mojo::UserAgent::Transactor->new };

# Common HTTP methods
for my $name (qw(DELETE GET HEAD OPTIONS PATCH POST PUT)) {
  monkey_patch __PACKAGE__, lc $name, sub {
    my ($self, $cb) = (shift, ref $_[-1] eq 'CODE' ? pop : undef);
    return $self->start($self->build_tx($name, @_), $cb);
  };
  monkey_patch __PACKAGE__, lc($name) . '_p', sub {
    my $self = shift;
    return $self->start_p($self->build_tx($name, @_));
  };
}

sub DESTROY { shift->_cleanup unless ${^GLOBAL_PHASE} eq 'DESTRUCT' }

sub build_tx           { shift->transactor->tx(@_) }
sub build_websocket_tx { shift->transactor->websocket(@_) }

sub start {
  my ($self, $tx, $cb) = @_;

  # Fork-safety
  $self->_cleanup->server->restart if $self->{pid} && $self->{pid} ne $$;
  $self->{pid} //= $$;

  # Non-blocking
  if ($cb) {
    warn "-- Non-blocking request (@{[_url($tx)]})\n" if DEBUG;
    return $self->_start(Mojo::IOLoop->singleton, $tx, $cb);
  }

  # Blocking
  warn "-- Blocking request (@{[_url($tx)]})\n" if DEBUG;
  $self->_start($self->ioloop, $tx => sub { shift->ioloop->stop; $tx = shift });
  $self->ioloop->start;

  return $tx;
}

sub start_p {
  my ($self, $tx) = @_;
  my $promise = Mojo::Promise->new;
  $self->start($tx => sub { shift->transactor->promisify($promise, shift) });
  return $promise;
}

sub websocket {
  my ($self, $cb) = (shift, pop);
  $self->start($self->build_websocket_tx(@_), $cb);
}

sub websocket_p {
  my $self = shift;
  return $self->start_p($self->build_websocket_tx(@_));
}

sub _cleanup {
  my $self = shift;
  delete $self->{pid};
  $self->_finish($_, 1) for keys %{$self->{connections} // {}};
  return $self;
}

sub _connect {
  my ($self, $loop, $tx, $handle) = @_;

  my $t = $self->transactor;
  my ($proto, $host, $port) = $handle ? $t->endpoint($tx) : $t->peer($tx);

  my %options = (timeout => $self->connect_timeout);
  if   ($proto eq 'http+unix') { $options{path}             = $host }
  else                         { @options{qw(address port)} = ($host, $port) }
  $options{socket_options} = $self->socket_options;
  $options{handle}         = $handle if $handle;

  # SOCKS
  if ($proto eq 'socks') {
    @options{qw(socks_address socks_port)} = @options{qw(address port)};
    ($proto, @options{qw(address port)}) = $t->endpoint($tx);
    my $userinfo = $tx->req->via_proxy(0)->proxy->userinfo;
    @options{qw(socks_user socks_pass)} = split /:/, $userinfo if $userinfo;
  }

  # TLS
  if ($options{tls} = $proto eq 'https') {
    map { $options{"tls_$_"} = $self->$_ } qw(ca cert key);
    $options{tls_options} = $self->tls_options;
    $options{tls_options}{SSL_verify_mode} = 0x00 if $self->insecure;
  }

  weaken $self;
  my $id;
  return $id = $loop->client(
    %options => sub {
      my ($loop, $err, $stream) = @_;

      # Connection error
      return unless $self;
      return $self->_error($id, $err) if $err;

      # Connection established
      $stream->on(timeout => sub { $self->_error($id, 'Inactivity timeout') });
      $stream->on(close   => sub { $self && $self->_finish($id, 1) });
      $stream->on(error   => sub { $self && $self->_error($id, pop) });
      $stream->on(read    => sub { $self->_read($id, pop) });
      $self->_process($id);
    }
  );
}

sub _connect_proxy {
  my ($self, $loop, $old, $cb) = @_;

  # Start CONNECT request
  return undef unless my $new = $self->transactor->proxy_connect($old);
  my $id;
  return $id = $self->_start(
    ($loop, $new) => sub {
      my ($self, $tx) = @_;

      # Real transaction
      $old->previous($tx)->req->via_proxy(0);
      my $c = $self->{connections}{$id} = {cb => $cb, ioloop => $loop, tx => $old};

      # CONNECT failed
      return $self->_error($id, 'Proxy connection failed') if $tx->error || !$tx->res->is_success || !$tx->keep_alive;

      # Start real transaction without TLS upgrade
      return $self->_process($id) unless $tx->req->url->protocol eq 'https';

      # TLS upgrade before starting the real transaction
      my $handle = $loop->stream($id)->steal_handle;
      $self->_remove($id);
      $id = $self->_connect($loop, $old, $handle);
      $self->{connections}{$id} = $c;
    }
  );
}

sub _connection {
  my ($self, $loop, $tx, $cb) = @_;

  # Reuse connection
  my ($proto, $host, $port) = $self->transactor->endpoint($tx);
  my $id;
  if ($id = $self->_dequeue($loop, "$proto:$host:$port", 1)) {
    warn "-- Reusing connection $id ($proto://$host:$port)\n" if DEBUG;
    @{$self->{connections}{$id}}{qw(cb tx)} = ($cb, $tx);
    $tx->kept_alive(1) unless $tx->connection;
    $self->_process($id);
    return $id;
  }

  # CONNECT request to proxy required
  if (my $id = $self->_connect_proxy($loop, $tx, $cb)) { return $id }

  # New connection
  $tx->res->error({message => "Unsupported protocol: $proto"}) and return $loop->next_tick(sub { $self->$cb($tx) })
    unless $proto eq 'http' || $proto eq 'https' || $proto eq 'http+unix';
  $id = $self->_connect($loop, $tx);
  warn "-- Connect $id ($proto://$host:$port)\n" if DEBUG;
  $self->{connections}{$id} = {cb => $cb, ioloop => $loop, tx => $tx};

  return $id;
}

sub _dequeue {
  my ($self, $loop, $name, $test) = @_;

  my $old = $self->{queue}{$loop} //= [];
  my ($found, @new);
  for my $queued (@$old) {
    push @new, $queued and next if $found || !grep { $_ eq $name } @$queued;

    # Search for id/name and sort out corrupted connections if necessary
    next unless my $stream = $loop->stream($queued->[1]);
    $test && $stream->is_readable ? $stream->close : ($found = $queued->[1]);
  }
  @$old = @new;

  return $found;
}

sub _error {
  my ($self, $id, $err) = @_;
  my $tx = $self->{connections}{$id}{tx};
  $tx->res->error({message => $err}) if $tx;
  $self->_finish($id, 1);
}

sub _finish {
  my ($self, $id, $close) = @_;

  # Remove request timeout and finish transaction
  return undef unless my $c = $self->{connections}{$id};
  $c->{ioloop}->remove(delete $c->{timeout}) if $c->{timeout};
  return $self->_reuse($id, $close) unless my $old = $c->{tx};

  # Premature connection close
  my $res = $old->closed->res->finish;
  $res->error({message => 'Premature connection close'}) if $close && !$res->code && !$res->error;

  # Always remove connection for WebSockets
  return $self->_remove($id) if $old->is_websocket;
  $self->cookie_jar->collect($old);

  # Upgrade connection to WebSocket
  if (my $new = $self->transactor->upgrade($old)) {
    weaken $self;
    $new->on(resume => sub { $self->_write($id) });
    $c->{cb}($self, $c->{tx} = $new);
    return $new->client_read($old->res->content->leftovers);
  }

  # CONNECT requests always have a follow-up request
  $self->_reuse($id, $close) unless uc $old->req->method eq 'CONNECT';
  $res->error({message => $res->message, code => $res->code}) if $res->is_error;
  $c->{cb}($self, $old) unless $self->_redirect($c, $old);
}

sub _process {
  my ($self, $id) = @_;

  my $c      = $self->{connections}{$id};
  my $stream = $c->{ioloop}->stream($id)->timeout($self->inactivity_timeout);
  my $tx     = $c->{tx}->connection($id);
  my $handle = $stream->handle;
  unless ($handle->isa('IO::Socket::UNIX')) {
    $tx->local_address($handle->sockhost)->local_port($handle->sockport);
    $tx->remote_address($handle->peerhost)->remote_port($handle->peerport);
  }

  weaken $self;
  $tx->on(resume => sub { $self->_write($id) });
  $self->_write($id);
}

sub _read {
  my ($self, $id, $chunk) = @_;

  # Corrupted connection
  return $self->_remove($id) unless my $tx = $self->{connections}{$id}{tx};
  warn term_escape "-- Client <<< Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;
  $tx->client_read($chunk);
  $self->_finish($id) if $tx->is_finished;
}

sub _redirect {
  my ($self, $c, $old) = @_;
  return undef unless my $new = $self->transactor->redirect($old);
  return undef unless @{$old->redirects} < $self->max_redirects;
  return $self->_start($c->{ioloop}, $new, delete $c->{cb});
}

sub _remove {
  my ($self, $id) = @_;
  my $c = delete $self->{connections}{$id};
  return unless $c->{ioloop};
  $self->_dequeue($c->{ioloop}, $id);
  $c->{ioloop}->remove($id);
}

sub _reuse {
  my ($self, $id, $close) = @_;

  # Connection close
  my $c   = $self->{connections}{$id};
  my $tx  = delete $c->{tx};
  my $max = $self->max_connections;
  return $self->_remove($id) if $close || !$tx || !$max || !$tx->keep_alive || $tx->error;

  # Keep connection alive
  my $queue = $self->{queue}{$c->{ioloop}} //= [];
  $self->_remove(shift(@$queue)->[1]) while @$queue && @$queue >= $max;
  push @$queue, [join(':', $self->transactor->endpoint($tx)), $id];
}

sub _start {
  my ($self, $loop, $tx, $cb) = @_;

  # Application server
  $self->emit(prepare => $tx);
  my $url = $tx->req->url;
  if (!$url->is_abs && (my $server = $self->server)) {
    my $base = $loop == $self->ioloop ? $server->url : $server->nb_url;
    $url->scheme($base->scheme)->host($base->host)->port($base->port);
  }

  $_->prepare($tx) for $self->proxy, $self->cookie_jar;
  my $max = $self->max_response_size;
  $tx->res->max_message_size($max) if defined $max;
  $self->emit(start => $tx);

  # Allow test servers sharing the same event loop to clean up connections
  !$loop->next_tick(sub { }) and $loop->one_tick unless $loop->is_running;
  return undef                                   unless my $id = $self->_connection($loop, $tx, $cb);

  if (my $t = $self->request_timeout) {
    weaken $self;
    $self->{connections}{$id}{timeout} ||= $loop->timer($t => sub { $self->_error($id, 'Request timeout') });
  }

  return $id;
}

sub _url { shift->req->url->to_abs }

sub _write {
  my ($self, $id) = @_;

  # Protect from resume event recursion
  my $c = $self->{connections}{$id};
  return if !(my $tx = $c->{tx}) || $c->{writing};
  local $c->{writing} = 1;
  my $chunk = $tx->client_write;
  warn term_escape "-- Client >>> Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;
  return unless length $chunk;

  weaken $self;
  $c->{ioloop}->stream($id)->write($chunk => sub { $self && $self->_write($id) });
}

1;

=encoding utf8

=head1 NAME

Mojo::UserAgent - Non-blocking I/O HTTP and WebSocket user agent

=head1 SYNOPSIS

  use Mojo::UserAgent;

  # Fine grained response handling (dies on connection errors)
  my $ua  = Mojo::UserAgent->new;
  my $res = $ua->get('docs.mojolicious.org')->result;
  if    ($res->is_success)  { say $res->body }
  elsif ($res->is_error)    { say $res->message }
  elsif ($res->code == 301) { say $res->headers->location }
  else                      { say 'Whatever...' }

  # Say hello to the Unicode snowman and include an Accept header
  say $ua->get('www.â˜ƒ.net?hello=there' => {Accept => '*/*'})->result->body;

  # Extract data from HTML and XML resources with CSS selectors
  say $ua->get('www.perl.org')->result->dom->at('title')->text;

  # Scrape the latest headlines from a news site
  say $ua->get('blogs.perl.org')->result->dom->find('h2 > a')->map('text')->join("\n");

  # IPv6 PUT request with Content-Type header and content
  my $tx = $ua->put('[::1]:3000' => {'Content-Type' => 'text/plain'} => 'Hi!');

  # Quick JSON API request with Basic authentication
  my $url = Mojo::URL->new('https://example.com/test.json')->userinfo('sri:â˜ƒ');
  my $value = $ua->get($url)->result->json;

  # JSON POST (application/json) with TLS certificate authentication
  my $tx = $ua->cert('tls.crt')->key('tls.key')->post('https://example.com' => json => {top => 'secret'});

  # Form POST (application/x-www-form-urlencoded)
  my $tx = $ua->post('https://metacpan.org/search' => form => {q => 'mojo'});

  # Search DuckDuckGo anonymously through Tor
  $ua->proxy->http('socks://127.0.0.1:9050');
  say $ua->get('api.3g2upl4pq6kufc4m.onion/?q=mojolicious&format=json')->result->json('/Abstract');

  # GET request via UNIX domain socket "/tmp/myapp.sock" (percent encoded slash)
  say $ua->get('http+unix://%2Ftmp%2Fmyapp.sock/test')->result->body;

  # Follow redirects to download Mojolicious from GitHub
  $ua->max_redirects(5)
    ->get('https://www.github.com/mojolicious/mojo/tarball/main')
    ->result->save_to('/home/sri/mojo.tar.gz');

  # Non-blocking request
  $ua->get('mojolicious.org' => sub ($ua, $tx) { say $tx->result->dom->at('title')->text });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

  # Concurrent non-blocking requests (synchronized with promises)
  my $mojo_promise = $ua->get_p('mojolicious.org');
  my $cpan_promise = $ua->get_p('cpan.org');
  Mojo::Promise->all($mojo_promise, $cpan_promise)->then(sub ($mojo, $cpan) {
    say $mojo->[0]->result->dom->at('title')->text;
    say $cpan->[0]->result->dom->at('title')->text;
  })->wait;

  # WebSocket connection sending and receiving JSON via UNIX domain socket
  $ua->websocket('ws+unix://%2Ftmp%2Fmyapp.sock/echo.json' => sub ($ua, $tx) {
    say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
    $tx->on(json => sub ($tx, $hash) {
      say "WebSocket message via JSON: $hash->{msg}";
      $tx->finish;
    });
    $tx->send({json => {msg => 'Hello World!'}});
  });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head1 DESCRIPTION

L<Mojo::UserAgent> is a full featured non-blocking I/O HTTP and WebSocket user agent, with IPv6, TLS, SNI, IDNA,
HTTP/SOCKS5 proxy, UNIX domain socket, Comet (long polling), Promises/A+, keep-alive, connection pooling, timeout,
cookie, multipart, gzip compression and multiple event loop support.

All connections will be reset automatically if a new process has been forked, this allows multiple processes to share
the same L<Mojo::UserAgent> object safely.

For better scalability (epoll, kqueue) and to provide non-blocking name resolution, SOCKS5 as well as TLS support, the
optional modules L<EV> (4.32+), L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and L<IO::Socket::SSL>
(2.009+) will be used automatically if possible. Individual features can also be disabled with the C<MOJO_NO_NNR>,
C<MOJO_NO_SOCKS> and C<MOJO_NO_TLS> environment variables.

See L<Mojolicious::Guides::Cookbook/"USER AGENT"> for more.

=head1 EVENTS

L<Mojo::UserAgent> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 prepare

  $ua->on(prepare => sub ($ua, $tx) {...});

Emitted whenever a new transaction is being prepared, before relative URLs are rewritten and cookies added. This
includes automatically prepared proxy C<CONNECT> requests and followed redirects.

  $ua->on(prepare => sub ($ua, $tx) {
    $tx->req->url(Mojo::URL->new('/mock-mojolicious')) if $tx->req->url->host eq 'mojolicious.org';
  });

=head2 start

  $ua->on(start => sub ($ua, $tx) {...});

Emitted whenever a new transaction is about to start. This includes automatically prepared proxy C<CONNECT> requests
and followed redirects.

  $ua->on(start => sub ($ua, $tx) {
    $tx->req->headers->header('X-Bender' => 'Bite my shiny metal ass!');
  });

=head1 ATTRIBUTES

L<Mojo::UserAgent> implements the following attributes.

=head2 ca

  my $ca = $ua->ca;
  $ua    = $ua->ca('/etc/tls/ca.crt');

Path to TLS certificate authority file used to verify the peer certificate, defaults to the value of the
C<MOJO_CA_FILE> environment variable.

  # Show certificate authorities for debugging
  IO::Socket::SSL::set_defaults(SSL_verify_callback => sub { say "Authority: $_[2]" and return $_[0] });

=head2 cert

  my $cert = $ua->cert;
  $ua      = $ua->cert('/etc/tls/client.crt');

Path to TLS certificate file, defaults to the value of the C<MOJO_CERT_FILE> environment variable.

=head2 connect_timeout

  my $timeout = $ua->connect_timeout;
  $ua         = $ua->connect_timeout(5);

Maximum amount of time in seconds establishing a connection may take before getting canceled, defaults to the value of
the C<MOJO_CONNECT_TIMEOUT> environment variable or C<10>.

=head2 cookie_jar

  my $cookie_jar = $ua->cookie_jar;
  $ua            = $ua->cookie_jar(Mojo::UserAgent::CookieJar->new);

Cookie jar to use for requests performed by this user agent, defaults to a L<Mojo::UserAgent::CookieJar> object.

  # Ignore all cookies
  $ua->cookie_jar->ignore(sub { 1 });

  # Ignore cookies for public suffixes
  my $ps = IO::Socket::SSL::PublicSuffix->default;
  $ua->cookie_jar->ignore(sub ($cookie) {
    return undef unless my $domain = $cookie->domain;
    return ($ps->public_suffix($domain))[0] eq '';
  });

  # Add custom cookie to the jar
  $ua->cookie_jar->add(
    Mojo::Cookie::Response->new(
      name   => 'foo',
      value  => 'bar',
      domain => 'docs.mojolicious.org',
      path   => '/Mojolicious'
    )
  );

=head2 inactivity_timeout

  my $timeout = $ua->inactivity_timeout;
  $ua         = $ua->inactivity_timeout(15);

Maximum amount of time in seconds a connection can be inactive before getting closed, defaults to the value of the
C<MOJO_INACTIVITY_TIMEOUT> environment variable or C<40>. Setting the value to C<0> will allow connections to be
inactive indefinitely.

=head2 insecure

  my $bool = $ua->insecure;
  $ua      = $ua->insecure($bool);

Do not require a valid TLS certificate to access HTTPS/WSS sites, defaults to the value of the C<MOJO_INSECURE>
environment variable.

  # Disable TLS certificate verification for testing
  say $ua->insecure(1)->get('https://127.0.0.1:3000')->result->code;

=head2 ioloop

  my $loop = $ua->ioloop;
  $ua      = $ua->ioloop(Mojo::IOLoop->new);

Event loop object to use for blocking I/O operations, defaults to a L<Mojo::IOLoop> object.

=head2 key

  my $key = $ua->key;
  $ua     = $ua->key('/etc/tls/client.crt');

Path to TLS key file, defaults to the value of the C<MOJO_KEY_FILE> environment variable.

=head2 max_connections

  my $max = $ua->max_connections;
  $ua     = $ua->max_connections(5);

Maximum number of keep-alive connections that the user agent will retain before it starts closing the oldest ones,
defaults to C<5>. Setting the value to C<0> will prevent any connections from being kept alive.

=head2 max_redirects

  my $max = $ua->max_redirects;
  $ua     = $ua->max_redirects(3);

Maximum number of redirects the user agent will follow before it fails, defaults to the value of the
C<MOJO_MAX_REDIRECTS> environment variable or C<0>.

=head2 max_response_size

  my $max = $ua->max_response_size;
  $ua     = $ua->max_response_size(16777216);

Maximum response size in bytes, defaults to the value of L<Mojo::Message::Response/"max_message_size">. Setting the
value to C<0> will allow responses of indefinite size. Note that increasing this value can also drastically increase
memory usage, should you for example attempt to parse an excessively large response body with the methods
L<Mojo::Message/"dom"> or L<Mojo::Message/"json">.

=head2 proxy

  my $proxy = $ua->proxy;
  $ua       = $ua->proxy(Mojo::UserAgent::Proxy->new);

Proxy manager, defaults to a L<Mojo::UserAgent::Proxy> object.

  # Detect proxy servers from environment
  $ua->proxy->detect;

  # Manually configure HTTP proxy (using CONNECT for HTTPS/WebSockets)
  $ua->proxy->http('http://127.0.0.1:8080')->https('http://127.0.0.1:8080');

  # Manually configure Tor (SOCKS5)
  $ua->proxy->http('socks://127.0.0.1:9050')->https('socks://127.0.0.1:9050');

  # Manually configure UNIX domain socket (using CONNECT for HTTPS/WebSockets)
  $ua->proxy->http('http+unix://%2Ftmp%2Fproxy.sock') ->https('http+unix://%2Ftmp%2Fproxy.sock');

=head2 request_timeout

  my $timeout = $ua->request_timeout;
  $ua         = $ua->request_timeout(5);

Maximum amount of time in seconds establishing a connection, sending the request and receiving a whole response may
take before getting canceled, defaults to the value of the C<MOJO_REQUEST_TIMEOUT> environment variable or C<0>.
Setting the value to C<0> will allow the user agent to wait indefinitely. The timeout will reset for every followed
redirect.

  # Total limit of 5 seconds, of which 3 seconds may be spent connecting
  $ua->max_redirects(0)->connect_timeout(3)->request_timeout(5);

=head2 server

  my $server = $ua->server;
  $ua        = $ua->server(Mojo::UserAgent::Server->new);

Application server relative URLs will be processed with, defaults to a L<Mojo::UserAgent::Server> object.

  # Mock web service
  $ua->server->app(Mojolicious->new);
  $ua->server->app->routes->get('/time' => sub ($c) {
    $c->render(json => {now => time});
  });
  my $time = $ua->get('/time')->result->json->{now};

  # Change log level
  $ua->server->app->log->level('fatal');

  # Port currently used for processing relative URLs blocking
  say $ua->server->url->port;

  # Port currently used for processing relative URLs non-blocking
  say $ua->server->nb_url->port;

=head2 socket_options

  my $options = $ua->socket_options;
  $ua         = $ua->socket_options({LocalAddr => '127.0.0.1'});

Additional options for L<IO::Socket::IP> when opening new connections.

=head2 tls_options

  my $options = $ua->tls_options;
  $ua         = $ua->tls_options({SSL_cipher_list => 'DEFAULT:!DH@SECLEVEL=1'});

Additional options for L<IO::Socket::SSL> when opening new connections.

=head2 transactor

  my $t = $ua->transactor;
  $ua   = $ua->transactor(Mojo::UserAgent::Transactor->new);

Transaction builder, defaults to a L<Mojo::UserAgent::Transactor> object.

  # Change name of user agent
  $ua->transactor->name('MyUA 1.0');

  # Disable compression
  $ua->transactor->compressed(0);

=head1 METHODS

L<Mojo::UserAgent> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 build_tx

  my $tx = $ua->build_tx(GET => 'example.com');
  my $tx = $ua->build_tx(PUT => 'http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->build_tx(PUT => 'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->build_tx(PUT => 'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Generate L<Mojo::Transaction::HTTP> object with L<Mojo::UserAgent::Transactor/"tx">.

  # Request with custom cookie
  my $tx = $ua->build_tx(GET => 'https://example.com/account');
  $tx->req->cookies({name => 'user', value => 'sri'});
  $tx = $ua->start($tx);

  # Deactivate gzip compression
  my $tx = $ua->build_tx(GET => 'example.com');
  $tx->req->headers->remove('Accept-Encoding');
  $tx = $ua->start($tx);

  # Interrupt response by raising an error
  my $tx = $ua->build_tx(GET => 'http://example.com');
  $tx->res->on(progress => sub ($res) {
    return unless my $server = $res->headers->server;
    $res->error({message => 'Oh noes, it is IIS!'}) if $server =~ /IIS/;
  });
  $tx = $ua->start($tx);

=head2 build_websocket_tx

  my $tx = $ua->build_websocket_tx('ws://example.com');
  my $tx = $ua->build_websocket_tx( 'ws://example.com' => {DNT => 1} => ['v1.proto']);

Generate L<Mojo::Transaction::HTTP> object with L<Mojo::UserAgent::Transactor/"websocket">.

  # Custom WebSocket handshake with cookie
  my $tx = $ua->build_websocket_tx('wss://example.com/echo');
  $tx->req->cookies({name => 'user', value => 'sri'});
  $ua->start($tx => sub ($ua, $tx) {
    say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
    $tx->on(message => sub ($tx, $msg) {
      say "WebSocket message: $msg";
      $tx->finish;
    });
    $tx->send('Hi!');
  });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 delete

  my $tx = $ua->delete('example.com');
  my $tx = $ua->delete('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->delete('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->delete('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<DELETE> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<DELETE> method, which is implied). You can also append a callback
to perform requests non-blocking.

  $ua->delete('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 delete_p

  my $promise = $ua->delete_p('http://example.com');

Same as L</"delete">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting
a callback.

  $ua->delete_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 get

  my $tx = $ua->get('example.com');
  my $tx = $ua->get('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->get('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->get('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<GET> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<GET> method, which is implied). You can also append a callback to
perform requests non-blocking.

  $ua->get('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 get_p

  my $promise = $ua->get_p('http://example.com');

Same as L</"get">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting a
callback.

  $ua->get_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 head

  my $tx = $ua->head('example.com');
  my $tx = $ua->head('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->head('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->head('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<HEAD> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<HEAD> method, which is implied). You can also append a callback
to perform requests non-blocking.

  $ua->head('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 head_p

  my $promise = $ua->head_p('http://example.com');

Same as L</"head">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting a
callback.

  $ua->head_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 options

  my $tx = $ua->options('example.com');
  my $tx = $ua->options('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->options('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->options('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<OPTIONS> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<OPTIONS> method, which is implied). You can also append a
callback to perform requests non-blocking.

  $ua->options('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 options_p

  my $promise = $ua->options_p('http://example.com');

Same as L</"options">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of
accepting a callback.

  $ua->options_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 patch

  my $tx = $ua->patch('example.com');
  my $tx = $ua->patch('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->patch('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->patch('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<PATCH> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<PATCH> method, which is implied). You can also append a callback
to perform requests non-blocking.

  $ua->patch('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 patch_p

  my $promise = $ua->patch_p('http://example.com');

Same as L</"patch">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting
a callback.

  $ua->patch_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 post

  my $tx = $ua->post('example.com');
  my $tx = $ua->post('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->post('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->post('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<POST> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<POST> method, which is implied). You can also append a callback
to perform requests non-blocking.

  $ua->post('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 post_p

  my $promise = $ua->post_p('http://example.com');

Same as L</"post">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting a
callback.

  $ua->post_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 put

  my $tx = $ua->put('example.com');
  my $tx = $ua->put('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->put('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->put('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<PUT> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<PUT> method, which is implied). You can also append a callback to
perform requests non-blocking.

  $ua->put('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 put_p

  my $promise = $ua->put_p('http://example.com');

Same as L</"put">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting a
callback.

  $ua->put_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 start

  my $tx = $ua->start(Mojo::Transaction::HTTP->new);

Perform blocking request for a custom L<Mojo::Transaction::HTTP> object, which can be prepared manually or with
L</"build_tx">. You can also append a callback to perform requests non-blocking.

  my $tx = $ua->build_tx(GET => 'http://example.com');
  $ua->start($tx => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 start_p

  my $promise = $ua->start_p(Mojo::Transaction::HTTP->new);

Same as L</"start">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting
a callback.

  my $tx = $ua->build_tx(GET => 'http://example.com');
  $ua->start_p($tx)->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 websocket

  $ua->websocket('ws://example.com' => sub {...});
  $ua->websocket('ws://example.com' => {DNT => 1} => ['v1.proto'] => sub {...});

Open a non-blocking WebSocket connection with transparent handshake, takes the same arguments as
L<Mojo::UserAgent::Transactor/"websocket">. The callback will receive either a L<Mojo::Transaction::WebSocket> or
L<Mojo::Transaction::HTTP> object, depending on if the handshake was successful.

  $ua->websocket('wss://example.com/echo' => ['v1.proto'] => sub ($ua, $tx) {
    say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
    say 'Subprotocol negotiation failed!' and return unless $tx->protocol;
    $tx->on(finish => sub ($tx, $code, $reason) { say "WebSocket closed with status $code." });
    $tx->on(message => sub ($tx, $msg) {
      say "WebSocket message: $msg";
      $tx->finish;
    });
    $tx->send('Hi!');
  });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

You can activate C<permessage-deflate> compression by setting the C<Sec-WebSocket-Extensions> header, this can result
in much better performance, but also increases memory usage by up to 300KiB per connection.

  $ua->websocket('ws://example.com/foo' => {
    'Sec-WebSocket-Extensions' => 'permessage-deflate'
  } => sub {...});

=head2 websocket_p

  my $promise = $ua->websocket_p('ws://example.com');

Same as L</"websocket">, but returns a L<Mojo::Promise> object instead of accepting a callback.

  $ua->websocket_p('wss://example.com/echo')->then(sub ($tx) {
    my $promise = Mojo::Promise->new;
    $tx->on(finish => sub { $promise->resolve });
    $tx->on(message => sub ($tx, $msg) {
      say "WebSocket message: $msg";
      $tx->finish;
    });
    $tx->send('Hi!');
    return $promise;
  })->catch(sub ($err) {
    warn "WebSocket error: $err";
  })->wait;

=head1 DEBUGGING

You can set the C<MOJO_CLIENT_DEBUG> environment variable to get some advanced diagnostics information printed to
C<STDERR>.

  MOJO_CLIENT_DEBUG=1

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Headers;
use Mojo::Base -base;

use Carp       qw(croak);
use Mojo::Util qw(header_params monkey_patch);

has max_line_size => sub { $ENV{MOJO_MAX_LINE_SIZE} || 8192 };
has max_lines     => sub { $ENV{MOJO_MAX_LINES}     || 100 };

# Common headers
my %NAMES = map { lc() => $_ } (
  qw(Accept Accept-Charset Accept-Encoding Accept-Language Accept-Ranges Access-Control-Allow-Origin Allow),
  qw(Authorization Cache-Control Connection Content-Disposition Content-Encoding Content-Language Content-Length),
  qw(Content-Location Content-Range Content-Security-Policy Content-Type Cookie DNT Date ETag Expect Expires Host),
  qw(If-Modified-Since If-None-Match Last-Modified Link Location Origin Proxy-Authenticate Proxy-Authorization),
  qw(Range Sec-WebSocket-Accept Sec-WebSocket-Extensions Sec-WebSocket-Key Sec-WebSocket-Protocol),
  qw(Sec-WebSocket-Version Server Server-Timing Set-Cookie Status Strict-Transport-Security TE Trailer),
  qw(Transfer-Encoding Upgrade User-Agent Vary WWW-Authenticate)
);
for my $header (keys %NAMES) {
  my $name = $header;
  $name =~ y/-/_/;
  monkey_patch __PACKAGE__, $name, sub {
    my $self = shift;
    $self->{headers}{$header} = [@_] and return $self if @_;
    return undef unless my $headers = $self->{headers}{$header};
    return join ', ', @$headers;
  };
}

# Hop-by-hop headers
my @HOP_BY_HOP
  = map {lc} qw(Connection Keep-Alive Proxy-Authenticate Proxy-Authorization TE Trailer Transfer-Encoding Upgrade);

sub add {
  my ($self, $name) = (shift, shift);

  tr/\x0d\x0a// and croak "Invalid characters in $name header" for @_;

  # Make sure we have a normal case entry for name
  my $key = lc $name;
  $self->{names}{$key} //= $name unless $NAMES{$key};
  push @{$self->{headers}{$key}}, @_;

  return $self;
}

sub append {
  my ($self, $name, $value) = @_;
  my $old = $self->header($name);
  return $self->header($name => defined $old ? "$old, $value" : $value);
}

sub clone {
  my $self = shift;

  my $clone = $self->new;
  %{$clone->{names}} = %{$self->{names} // {}};
  @{$clone->{headers}{$_}} = @{$self->{headers}{$_}} for keys %{$self->{headers}};

  return $clone;
}

sub dehop {
  my $self = shift;
  delete @{$self->{headers}}{@HOP_BY_HOP};
  return $self;
}

sub every_header { shift->{headers}{lc shift} // [] }

sub from_hash {
  my ($self, $hash) = @_;

  # Empty hash deletes all headers
  delete $self->{headers} if keys %{$hash} == 0;

  # Merge
  for my $header (keys %$hash) {
    my $value = $hash->{$header};
    $self->add($header => ref $value eq 'ARRAY' ? @$value : $value);
  }

  return $self;
}

sub header {
  my ($self, $name) = (shift, shift);

  # Replace
  return $self->remove($name)->add($name, @_) if @_;

  return undef unless my $headers = $self->{headers}{lc $name};
  return join ', ', @$headers;
}

sub is_finished { (shift->{state} // '') eq 'finished' }

sub is_limit_exceeded { !!shift->{limit} }

sub leftovers { delete shift->{buffer} }

sub links {
  my ($self, $links) = @_;

  return $self->link(join(', ', map {qq{<$links->{$_}>; rel="$_"}} sort keys %$links)) if $links;

  my $header = $self->link // '';
  my $data   = {};
  while ($header =~ s/^[,\s]*<(.+?)>//) {
    my $target = $1;
    (my $params, $header) = header_params $header;
    $data->{$params->{rel}} //= {%$params, link => $target} if defined $params->{rel};
  }

  return $data;
}

sub names {
  my $self = shift;
  return [map { $NAMES{$_} || $self->{names}{$_} } sort keys %{$self->{headers}}];
}

sub parse {
  my ($self, $chunk) = @_;

  $self->{state} = 'headers';
  $self->{buffer} .= $chunk;
  my $headers = $self->{cache} //= [];
  my $size    = $self->max_line_size;
  my $lines   = $self->max_lines;
  while ($self->{buffer} =~ s/^(.*?)\x0d?\x0a//) {
    my $line = $1;

    # Check line size limit
    if ($+[0] > $size || @$headers >= $lines) {
      @$self{qw(state limit)} = ('finished', 1);
      return $self;
    }

    # New header
    if ($line =~ /^(\S[^:]*):\s*(.*)$/) { push @$headers, [$1, $2] }

    # Multi-line
    elsif ($line =~ s/^\s+// && @$headers) { $headers->[-1][1] .= " $line" }

    # Empty line
    else {
      $self->add(@$_) for @$headers;
      @$self{qw(state cache)} = ('finished', []);
      return $self;
    }
  }

  # Check line size limit
  @$self{qw(state limit)} = ('finished', 1) if length $self->{buffer} > $size;

  return $self;
}

sub referer  { shift->referrer(@_) }
sub referrer { shift->header(Referer => @_) }

sub remove {
  my ($self, $name) = @_;
  delete $self->{headers}{lc $name};
  return $self;
}

sub to_hash {
  my ($self, $multi) = @_;
  return {map { $_ => $self->{headers}{lc $_} } @{$self->names}} if $multi;
  return {map { $_ => $self->header($_) } @{$self->names}};
}

sub to_string {
  my $self = shift;

  # Make sure multi-line values are formatted correctly
  my @headers;
  for my $name (@{$self->names}) { push @headers, "$name: $_" for @{$self->{headers}{lc $name}} }

  return join "\x0d\x0a", @headers;
}

1;

=encoding utf8

=head1 NAME

Mojo::Headers - HTTP headers

=head1 SYNOPSIS

  use Mojo::Headers;

  # Parse
  my $headers = Mojo::Headers->new;
  $headers->parse("Content-Length: 42\x0d\x0a");
  $headers->parse("Content-Type: text/html\x0d\x0a\x0d\x0a");
  say $headers->content_length;
  say $headers->content_type;

  # Build
  my $headers = Mojo::Headers->new;
  $headers->content_length(42);
  $headers->content_type('text/plain');
  say $headers->to_string;

=head1 DESCRIPTION

L<Mojo::Headers> is a container for HTTP headers, based on L<RFC 7230|https://tools.ietf.org/html/rfc7230> and L<RFC
7231|https://tools.ietf.org/html/rfc7231>.

=head1 ATTRIBUTES

L<Mojo::Headers> implements the following attributes.

=head2 max_line_size

  my $size = $headers->max_line_size;
  $headers = $headers->max_line_size(1024);

Maximum header line size in bytes, defaults to the value of the C<MOJO_MAX_LINE_SIZE> environment variable or C<8192>
(8KiB).

=head2 max_lines

  my $num  = $headers->max_lines;
  $headers = $headers->max_lines(200);

Maximum number of header lines, defaults to the value of the C<MOJO_MAX_LINES> environment variable or C<100>.

=head1 METHODS

L<Mojo::Headers> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 accept

  my $accept = $headers->accept;
  $headers   = $headers->accept('application/json');

Get or replace current header value, shortcut for the C<Accept> header.

=head2 accept_charset

  my $charset = $headers->accept_charset;
  $headers    = $headers->accept_charset('UTF-8');

Get or replace current header value, shortcut for the C<Accept-Charset> header.

=head2 accept_encoding

  my $encoding = $headers->accept_encoding;
  $headers     = $headers->accept_encoding('gzip');

Get or replace current header value, shortcut for the C<Accept-Encoding> header.

=head2 accept_language

  my $language = $headers->accept_language;
  $headers     = $headers->accept_language('de, en');

Get or replace current header value, shortcut for the C<Accept-Language> header.

=head2 accept_ranges

  my $ranges = $headers->accept_ranges;
  $headers   = $headers->accept_ranges('bytes');

Get or replace current header value, shortcut for the C<Accept-Ranges> header.

=head2 access_control_allow_origin

  my $origin = $headers->access_control_allow_origin;
  $headers   = $headers->access_control_allow_origin('*');

Get or replace current header value, shortcut for the C<Access-Control-Allow-Origin> header from L<Cross-Origin
Resource Sharing|https://www.w3.org/TR/cors/>.

=head2 add

  $headers = $headers->add(Foo => 'one value');
  $headers = $headers->add(Foo => 'first value', 'second value');

Add header with one or more lines.

  # "Vary: Accept
  #  Vary: Accept-Encoding"
  $headers->add(Vary => 'Accept')->add(Vary => 'Accept-Encoding')->to_string;

=head2 allow

  my $allow = $headers->allow;
  $headers  = $headers->allow('GET, POST');

Get or replace current header value, shortcut for the C<Allow> header.

=head2 append

  $headers = $headers->append(Vary => 'Accept-Encoding');

Append value to header and flatten it if necessary.

  # "Vary: Accept"
  $headers->append(Vary => 'Accept')->to_string;

  # "Vary: Accept, Accept-Encoding"
  $headers->vary('Accept')->append(Vary => 'Accept-Encoding')->to_string;

=head2 authorization

  my $authorization = $headers->authorization;
  $headers          = $headers->authorization('Basic Zm9vOmJhcg==');

Get or replace current header value, shortcut for the C<Authorization> header.

=head2 cache_control

  my $cache_control = $headers->cache_control;
  $headers          = $headers->cache_control('max-age=1, no-cache');

Get or replace current header value, shortcut for the C<Cache-Control> header.

=head2 clone

  my $clone = $headers->clone;

Return a new L<Mojo::Headers> object cloned from these headers.

=head2 connection

  my $connection = $headers->connection;
  $headers       = $headers->connection('close');

Get or replace current header value, shortcut for the C<Connection> header.

=head2 content_disposition

  my $disposition = $headers->content_disposition;
  $headers        = $headers->content_disposition('foo');

Get or replace current header value, shortcut for the C<Content-Disposition> header.

=head2 content_encoding

  my $encoding = $headers->content_encoding;
  $headers     = $headers->content_encoding('gzip');

Get or replace current header value, shortcut for the C<Content-Encoding> header.

=head2 content_language

  my $language = $headers->content_language;
  $headers     = $headers->content_language('en');

Get or replace current header value, shortcut for the C<Content-Language> header.

=head2 content_length

  my $len  = $headers->content_length;
  $headers = $headers->content_length(4000);

Get or replace current header value, shortcut for the C<Content-Length> header.

=head2 content_location

  my $location = $headers->content_location;
  $headers     = $headers->content_location('http://127.0.0.1/foo');

Get or replace current header value, shortcut for the C<Content-Location> header.

=head2 content_range

  my $range = $headers->content_range;
  $headers  = $headers->content_range('bytes 2-8/100');

Get or replace current header value, shortcut for the C<Content-Range> header.

=head2 content_security_policy

  my $policy = $headers->content_security_policy;
  $headers   = $headers->content_security_policy('default-src https:');

Get or replace current header value, shortcut for the C<Content-Security-Policy> header from L<Content Security Policy
1.0|https://www.w3.org/TR/CSP/>.

=head2 content_type

  my $type = $headers->content_type;
  $headers = $headers->content_type('text/plain');

Get or replace current header value, shortcut for the C<Content-Type> header.

=head2 cookie

  my $cookie = $headers->cookie;
  $headers   = $headers->cookie('f=b');

Get or replace current header value, shortcut for the C<Cookie> header from L<RFC
6265|https://tools.ietf.org/html/rfc6265>.

=head2 date

  my $date = $headers->date;
  $headers = $headers->date('Sun, 17 Aug 2008 16:27:35 GMT');

Get or replace current header value, shortcut for the C<Date> header.

=head2 dehop

  $headers = $headers->dehop;

Remove hop-by-hop headers that should not be retransmitted.

=head2 dnt

  my $dnt  = $headers->dnt;
  $headers = $headers->dnt(1);

Get or replace current header value, shortcut for the C<DNT> (Do Not Track) header, which has no specification yet, but
is very commonly used.

=head2 etag

  my $etag = $headers->etag;
  $headers = $headers->etag('"abc321"');

Get or replace current header value, shortcut for the C<ETag> header.

=head2 every_header

  my $all = $headers->every_header('Location');

Similar to L</"header">, but returns all headers sharing the same name as an array reference.

  # Get first header value
  say $headers->every_header('Location')->[0];

=head2 expect

  my $expect = $headers->expect;
  $headers   = $headers->expect('100-continue');

Get or replace current header value, shortcut for the C<Expect> header.

=head2 expires

  my $expires = $headers->expires;
  $headers    = $headers->expires('Thu, 01 Dec 1994 16:00:00 GMT');

Get or replace current header value, shortcut for the C<Expires> header.

=head2 from_hash

  $headers = $headers->from_hash({'Cookie' => 'a=b'});
  $headers = $headers->from_hash({'Cookie' => ['a=b', 'c=d']});
  $headers = $headers->from_hash({});

Parse headers from a hash reference, an empty hash removes all headers.

=head2 header

  my $value = $headers->header('Foo');
  $headers  = $headers->header(Foo => 'one value');
  $headers  = $headers->header(Foo => 'first value', 'second value');

Get or replace the current header values.

=head2 host

  my $host = $headers->host;
  $headers = $headers->host('127.0.0.1');

Get or replace current header value, shortcut for the C<Host> header.

=head2 if_modified_since

  my $date = $headers->if_modified_since;
  $headers = $headers->if_modified_since('Sun, 17 Aug 2008 16:27:35 GMT');

Get or replace current header value, shortcut for the C<If-Modified-Since> header.

=head2 if_none_match

  my $etag = $headers->if_none_match;
  $headers = $headers->if_none_match('"abc321"');

Get or replace current header value, shortcut for the C<If-None-Match> header.

=head2 is_finished

  my $bool = $headers->is_finished;

Check if header parser is finished.

=head2 is_limit_exceeded

  my $bool = $headers->is_limit_exceeded;

Check if headers have exceeded L</"max_line_size"> or L</"max_lines">.

=head2 last_modified

  my $date = $headers->last_modified;
  $headers = $headers->last_modified('Sun, 17 Aug 2008 16:27:35 GMT');

Get or replace current header value, shortcut for the C<Last-Modified> header.

=head2 leftovers

  my $bytes = $headers->leftovers;

Get and remove leftover data from header parser.

=head2 link

  my $link = $headers->link;
  $headers = $headers->link('<http://127.0.0.1/foo/3>; rel="next"');

Get or replace current header value, shortcut for the C<Link> header from L<RFC
5988|https://tools.ietf.org/html/rfc5988>.

=head2 links

  my $links = $headers->links;
  $headers  = $headers->links({next => 'http://example.com/foo', prev => 'http://example.com/bar'});

Get or set web links from or to C<Link> header according to L<RFC 5988|http://tools.ietf.org/html/rfc5988>.

  # Extract information about next page
  say $headers->links->{next}{link};
  say $headers->links->{next}{title};

=head2 location

  my $location = $headers->location;
  $headers     = $headers->location('http://127.0.0.1/foo');

Get or replace current header value, shortcut for the C<Location> header.

=head2 names

  my $names = $headers->names;

Return an array reference with all currently defined headers.

  # Names of all headers
  say for @{$headers->names};

=head2 origin

  my $origin = $headers->origin;
  $headers   = $headers->origin('http://example.com');

Get or replace current header value, shortcut for the C<Origin> header from L<RFC
6454|https://tools.ietf.org/html/rfc6454>.

=head2 parse

  $headers = $headers->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");

Parse formatted headers.

=head2 proxy_authenticate

  my $authenticate = $headers->proxy_authenticate;
  $headers         = $headers->proxy_authenticate('Basic "realm"');

Get or replace current header value, shortcut for the C<Proxy-Authenticate> header.

=head2 proxy_authorization

  my $authorization = $headers->proxy_authorization;
  $headers          = $headers->proxy_authorization('Basic Zm9vOmJhcg==');

Get or replace current header value, shortcut for the C<Proxy-Authorization> header.

=head2 range

  my $range = $headers->range;
  $headers  = $headers->range('bytes=2-8');

Get or replace current header value, shortcut for the C<Range> header.

=head2 referer

  my $referrer = $headers->referer;
  $headers     = $headers->referer('http://example.com');

Alias for L</"referrer">.

=head2 referrer

  my $referrer = $headers->referrer;
  $headers     = $headers->referrer('http://example.com');

Get or replace current header value, shortcut for the C<Referer> header, there was a typo in L<RFC
2068|https://tools.ietf.org/html/rfc2068> which resulted in C<Referer> becoming an official header.

=head2 remove

  $headers = $headers->remove('Foo');

Remove a header.

=head2 sec_websocket_accept

  my $accept = $headers->sec_websocket_accept;
  $headers   = $headers->sec_websocket_accept('s3pPLMBiTxaQ9kYGzzhZRbK+xOo=');

Get or replace current header value, shortcut for the C<Sec-WebSocket-Accept> header from L<RFC
6455|https://tools.ietf.org/html/rfc6455>.

=head2 sec_websocket_extensions

  my $extensions = $headers->sec_websocket_extensions;
  $headers       = $headers->sec_websocket_extensions('foo');

Get or replace current header value, shortcut for the C<Sec-WebSocket-Extensions> header from L<RFC
6455|https://tools.ietf.org/html/rfc6455>.

=head2 sec_websocket_key

  my $key  = $headers->sec_websocket_key;
  $headers = $headers->sec_websocket_key('dGhlIHNhbXBsZSBub25jZQ==');

Get or replace current header value, shortcut for the C<Sec-WebSocket-Key> header from L<RFC
6455|https://tools.ietf.org/html/rfc6455>.

=head2 sec_websocket_protocol

  my $proto = $headers->sec_websocket_protocol;
  $headers  = $headers->sec_websocket_protocol('sample');

Get or replace current header value, shortcut for the C<Sec-WebSocket-Protocol> header from L<RFC
6455|https://tools.ietf.org/html/rfc6455>.

=head2 sec_websocket_version

  my $version = $headers->sec_websocket_version;
  $headers    = $headers->sec_websocket_version(13);

Get or replace current header value, shortcut for the C<Sec-WebSocket-Version> header from L<RFC
6455|https://tools.ietf.org/html/rfc6455>.

=head2 server

  my $server = $headers->server;
  $headers   = $headers->server('Mojo');

Get or replace current header value, shortcut for the C<Server> header.

=head2 server_timing

  my $timing = $headers->server_timing;
  $headers   = $headers->server_timing('app;desc=Mojolicious;dur=0.0001');

Get or replace current header value, shortcut for the C<Server-Timing> header from L<Server
Timing|https://www.w3.org/TR/server-timing/>.

=head2 set_cookie

  my $cookie = $headers->set_cookie;
  $headers   = $headers->set_cookie('f=b; path=/');

Get or replace current header value, shortcut for the C<Set-Cookie> header from L<RFC
6265|https://tools.ietf.org/html/rfc6265>.

=head2 status

  my $status = $headers->status;
  $headers   = $headers->status('200 OK');

Get or replace current header value, shortcut for the C<Status> header from L<RFC
3875|https://tools.ietf.org/html/rfc3875>.

=head2 strict_transport_security

  my $policy = $headers->strict_transport_security;
  $headers   = $headers->strict_transport_security('max-age=31536000');

Get or replace current header value, shortcut for the C<Strict-Transport-Security> header from L<RFC
6797|https://tools.ietf.org/html/rfc6797>.

=head2 te

  my $te   = $headers->te;
  $headers = $headers->te('chunked');

Get or replace current header value, shortcut for the C<TE> header.

=head2 to_hash

  my $single = $headers->to_hash;
  my $multi  = $headers->to_hash(1);

Turn headers into hash reference, array references to represent multiple headers with the same name are disabled by
default.

  say $headers->to_hash->{DNT};

=head2 to_string

  my $str = $headers->to_string;

Turn headers into a string, suitable for HTTP messages.

=head2 trailer

  my $trailer = $headers->trailer;
  $headers    = $headers->trailer('X-Foo');

Get or replace current header value, shortcut for the C<Trailer> header.

=head2 transfer_encoding

  my $encoding = $headers->transfer_encoding;
  $headers     = $headers->transfer_encoding('chunked');

Get or replace current header value, shortcut for the C<Transfer-Encoding> header.

=head2 upgrade

  my $upgrade = $headers->upgrade;
  $headers    = $headers->upgrade('websocket');

Get or replace current header value, shortcut for the C<Upgrade> header.

=head2 user_agent

  my $agent = $headers->user_agent;
  $headers  = $headers->user_agent('Mojo/1.0');

Get or replace current header value, shortcut for the C<User-Agent> header.

=head2 vary

  my $vary = $headers->vary;
  $headers = $headers->vary('*');

Get or replace current header value, shortcut for the C<Vary> header.

=head2 www_authenticate

  my $authenticate = $headers->www_authenticate;
  $headers         = $headers->www_authenticate('Basic realm="realm"');

Get or replace current header value, shortcut for the C<WWW-Authenticate> header.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Cookie::Response;
use Mojo::Base 'Mojo::Cookie';

use Mojo::Date;
use Mojo::Util qw(quote split_cookie_header);

has [qw(domain expires host_only httponly max_age path samesite secure)];

my %ATTRS = map { $_ => 1 } qw(domain expires httponly max-age path samesite secure);

sub parse {
  my ($self, $str) = @_;

  my @cookies;
  my $tree = split_cookie_header $str // '';
  while (my $pairs = shift @$tree) {
    my ($name, $value) = splice @$pairs, 0, 2;
    push @cookies, $self->new(name => $name, value => $value // '');

    while (my ($name, $value) = splice @$pairs, 0, 2) {
      next unless $ATTRS{my $attr = lc $name};
      $value =~ s/^\.// if $attr eq 'domain' && defined $value;
      $value = Mojo::Date->new($value // '')->epoch if $attr eq 'expires';
      $value = 1                                    if $attr eq 'secure' || $attr eq 'httponly';
      $cookies[-1]{$attr eq 'max-age' ? 'max_age' : $attr} = $value;
    }
  }

  return \@cookies;
}

sub to_string {
  my $self = shift;

  # Name and value
  return '' unless length(my $name = $self->name // '');
  my $value  = $self->value // '';
  my $cookie = join '=', $name, $value =~ /[,;" ]/ ? quote $value : $value;

  # "expires"
  my $expires = $self->expires;
  $cookie .= '; expires=' . Mojo::Date->new($expires) if defined $expires;

  # "domain"
  if (my $domain = $self->domain) { $cookie .= "; domain=$domain" }

  # "path"
  if (my $path = $self->path) { $cookie .= "; path=$path" }

  # "secure"
  $cookie .= "; secure" if $self->secure;

  # "HttpOnly"
  $cookie .= "; HttpOnly" if $self->httponly;

  # "Same-Site"
  if (my $samesite = $self->samesite) { $cookie .= "; SameSite=$samesite" }

  # "Max-Age"
  if (defined(my $max = $self->max_age)) { $cookie .= "; Max-Age=$max" }

  return $cookie;
}

1;

=encoding utf8

=head1 NAME

Mojo::Cookie::Response - HTTP response cookie

=head1 SYNOPSIS

  use Mojo::Cookie::Response;

  my $cookie = Mojo::Cookie::Response->new;
  $cookie->name('foo');
  $cookie->value('bar');
  say "$cookie";

=head1 DESCRIPTION

L<Mojo::Cookie::Response> is a container for HTTP response cookies, based on L<RFC
6265|https://tools.ietf.org/html/rfc6265>.

=head1 ATTRIBUTES

L<Mojo::Cookie::Response> inherits all attributes from L<Mojo::Cookie> and implements the following new ones.

=head2 domain

  my $domain = $cookie->domain;
  $cookie    = $cookie->domain('localhost');

Cookie domain.

=head2 expires

  my $expires = $cookie->expires;
  $cookie     = $cookie->expires(time + 60);

Expiration for cookie.

=head2 host_only

  my $bool = $cookie->host_only;
  $cookie  = $cookie->host_only($bool);

Host-only flag, indicating that the canonicalized request-host is identical to the cookie's L</"domain">.

=head2 httponly

  my $bool = $cookie->httponly;
  $cookie  = $cookie->httponly($bool);

HttpOnly flag, which can prevent client-side scripts from accessing this cookie.

=head2 max_age

  my $max_age = $cookie->max_age;
  $cookie     = $cookie->max_age(60);

Max age for cookie.

=head2 path

  my $path = $cookie->path;
  $cookie  = $cookie->path('/test');

Cookie path.

=head2 samesite

  my $samesite = $cookie->samesite;
  $cookie      = $cookie->samesite('Lax');

SameSite value. Note that this attribute is B<EXPERIMENTAL> because even though most commonly used browsers support the
feature, there is no specification yet besides L<this
draft|https://tools.ietf.org/html/draft-west-first-party-cookies-07>.

=head2 secure

  my $bool = $cookie->secure;
  $cookie  = $cookie->secure($bool);

Secure flag, which instructs browsers to only send this cookie over HTTPS connections.

=head1 METHODS

L<Mojo::Cookie::Response> inherits all methods from L<Mojo::Cookie> and implements the following new ones.

=head2 parse

  my $cookies = Mojo::Cookie::Response->parse('f=b; path=/');

Parse cookies.

=head2 to_string

  my $str = $cookie->to_string;

Render cookie.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Cookie::Request;
use Mojo::Base 'Mojo::Cookie';

use Mojo::Util qw(quote split_header);

sub parse {
  my ($self, $str) = @_;

  my @cookies;
  my @pairs = map {@$_} @{split_header $str // ''};
  while (my ($name, $value) = splice @pairs, 0, 2) {
    next if $name =~ /^\$/;
    push @cookies, $self->new(name => $name, value => $value // '');
  }

  return \@cookies;
}

sub to_string {
  my $self = shift;
  return '' unless length(my $name = $self->name // '');
  my $value = $self->value // '';
  return join '=', $name, $value =~ /[,;" ]/ ? quote $value : $value;
}

1;

=encoding utf8

=head1 NAME

Mojo::Cookie::Request - HTTP request cookie

=head1 SYNOPSIS

  use Mojo::Cookie::Request;

  my $cookie = Mojo::Cookie::Request->new;
  $cookie->name('foo');
  $cookie->value('bar');
  say "$cookie";

=head1 DESCRIPTION

L<Mojo::Cookie::Request> is a container for HTTP request cookies, based on L<RFC
6265|https://tools.ietf.org/html/rfc6265>.

=head1 ATTRIBUTES

L<Mojo::Cookie::Request> inherits all attributes from L<Mojo::Cookie>.

=head1 METHODS

L<Mojo::Cookie::Request> inherits all methods from L<Mojo::Cookie> and implements the following new ones.

=head2 parse

  my $cookies = Mojo::Cookie::Request->parse('f=b; g=a');

Parse cookies.

=head2 to_string

  my $str = $cookie->to_string;

Render cookie.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Date;
use Mojo::Base -base;
use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;

use Time::Local qw(timegm);

has epoch => sub {time};

my $RFC3339_RE = qr/
  ^(\d+)-(\d+)-(\d+)\D+(\d+):(\d+):(\d+(?:\.\d+)?)   # Date and time
  (?:Z|([+-])(\d+):(\d+))?$                          # Offset
/xi;

my @DAYS   = qw(Sun Mon Tue Wed Thu Fri Sat);
my @MONTHS = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
my %MONTHS;
@MONTHS{@MONTHS} = (0 .. 11);

sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }

sub parse {
  my ($self, $date) = @_;

  # epoch (784111777)
  return $self->epoch($date) if $date =~ /^\d+$|^\d+\.\d+$/;

  # RFC 822/1123 (Sun, 06 Nov 1994 08:49:37 GMT)
  # RFC 850/1036 (Sunday, 06-Nov-94 08:49:37 GMT)
  my $offset = 0;
  my ($day, $month, $year, $h, $m, $s);
  if ($date =~ /^\w+\W+(\d+)\W+(\w+)\W+(\d+)\W+(\d+):(\d+):(\d+)\W*\w+$/) {
    ($day, $month, $year, $h, $m, $s) = ($1, $MONTHS{$2}, $3, $4, $5, $6);
  }

  # RFC 3339 (1994-11-06T08:49:37Z)
  elsif ($date =~ $RFC3339_RE) {
    ($year, $month, $day, $h, $m, $s) = ($1, $2 - 1, $3, $4, $5, $6);
    $offset = (($8 * 3600) + ($9 * 60)) * ($7 eq '+' ? -1 : 1) if $7;
  }

  # ANSI C asctime() (Sun Nov  6 08:49:37 1994)
  elsif ($date =~ /^\w+\s+(\w+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+(\d+)$/) {
    ($month, $day, $h, $m, $s, $year) = ($MONTHS{$1}, $2, $3, $4, $5, $6);
  }

  # Invalid
  else { return $self->epoch(undef) }

  my $epoch = eval { timegm $s, $m, $h, $day, $month, $year };
  return $self->epoch((defined $epoch && ($epoch += $offset) >= 0) ? $epoch : undef);
}

sub to_datetime {

  # RFC 3339 (1994-11-06T08:49:37Z)
  my ($s, $m, $h, $day, $month, $year) = gmtime(my $epoch = shift->epoch);
  my $str = sprintf '%04d-%02d-%02dT%02d:%02d:%02d', $year + 1900, $month + 1, $day, $h, $m, $s;
  return $str . ($epoch =~ /(\.\d+)$/ ? $1 : '') . 'Z';
}

sub to_string {

  # RFC 7231 (Sun, 06 Nov 1994 08:49:37 GMT)
  my ($s, $m, $h, $mday, $month, $year, $wday) = gmtime shift->epoch;
  return sprintf '%s, %02d %s %04d %02d:%02d:%02d GMT', $DAYS[$wday], $mday, $MONTHS[$month], $year + 1900, $h, $m, $s;
}

1;

=encoding utf8

=head1 NAME

Mojo::Date - HTTP date

=head1 SYNOPSIS

  use Mojo::Date;

  # Parse
  my $date = Mojo::Date->new('Sun, 06 Nov 1994 08:49:37 GMT');
  say $date->epoch;

  # Build
  my $date = Mojo::Date->new(time + 60);
  say "$date";

=head1 DESCRIPTION

L<Mojo::Date> implements HTTP date and time functions, based on L<RFC 7230|https://tools.ietf.org/html/rfc7230>, L<RFC
7231|https://tools.ietf.org/html/rfc7231> and L<RFC 3339|https://tools.ietf.org/html/rfc3339>.

=head1 ATTRIBUTES

L<Mojo::Date> implements the following attributes.

=head2 epoch

  my $epoch = $date->epoch;
  $date     = $date->epoch(784111777);

Epoch seconds, defaults to the current time.

=head1 METHODS

L<Mojo::Date> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 new

  my $date = Mojo::Date->new;
  my $date = Mojo::Date->new('Sun Nov  6 08:49:37 1994');

Construct a new L<Mojo::Date> object and L</"parse"> date if necessary.

=head2 parse

  $date = $date->parse('Sun Nov  6 08:49:37 1994');

Parse date.

  # Epoch
  say Mojo::Date->new('784111777')->epoch;
  say Mojo::Date->new('784111777.21')->epoch;

  # RFC 822/1123
  say Mojo::Date->new('Sun, 06 Nov 1994 08:49:37 GMT')->epoch;

  # RFC 850/1036
  say Mojo::Date->new('Sunday, 06-Nov-94 08:49:37 GMT')->epoch;

  # Ansi C asctime()
  say Mojo::Date->new('Sun Nov  6 08:49:37 1994')->epoch;

  # RFC 3339
  say Mojo::Date->new('1994-11-06T08:49:37Z')->epoch;
  say Mojo::Date->new('1994-11-06T08:49:37')->epoch;
  say Mojo::Date->new('1994-11-06T08:49:37.21Z')->epoch;
  say Mojo::Date->new('1994-11-06T08:49:37+01:00')->epoch;
  say Mojo::Date->new('1994-11-06T08:49:37-01:00')->epoch;

=head2 to_datetime

  my $str = $date->to_datetime;

Render L<RFC 3339|https://tools.ietf.org/html/rfc3339> date and time.

  # "1994-11-06T08:49:37Z"
  Mojo::Date->new(784111777)->to_datetime;

  # "1994-11-06T08:49:37.21Z"
  Mojo::Date->new(784111777.21)->to_datetime;

=head2 to_string

  my $str = $date->to_string;

Render date suitable for HTTP messages.

  # "Sun, 06 Nov 1994 08:49:37 GMT"
  Mojo::Date->new(784111777)->to_string;

=head1 OPERATORS

L<Mojo::Date> overloads the following operators.

=head2 bool

  my $bool = !!$date;

Always true.

=head2 stringify

  my $str = "$date";

Alias for L</"to_string">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
package Mojo::Cookie;
use Mojo::Base -base;
use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;

use Carp qw(croak);

has [qw(name value)];

sub parse     { croak 'Method "parse" not implemented by subclass' }
sub to_string { croak 'Method "to_string" not implemented by subclass' }

1;

=encoding utf8

=head1 NAME

Mojo::Cookie - HTTP cookie base class

=head1 SYNOPSIS

  package Mojo::Cookie::MyCookie;
  use Mojo::Base 'Mojo::Cookie';

  sub parse     {...}
  sub to_string {...}

=head1 DESCRIPTION

L<Mojo::Cookie> is an abstract base class for HTTP cookie containers, based on L<RFC
6265|https://tools.ietf.org/html/rfc6265>, like L<Mojo::Cookie::Request> and L<Mojo::Cookie::Response>.

=head1 ATTRIBUTES

L<Mojo::Cookie> implements the following attributes.

=head2 name

  my $name = $cookie->name;
  $cookie  = $cookie->name('foo');

Cookie name.

=head2 value

  my $value = $cookie->value;
  $cookie   = $cookie->value('/test');

Cookie value.

=head1 METHODS

L<Mojo::Cookie> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 parse

  my $cookies = $cookie->parse($str);

Parse cookies. Meant to be overloaded in a subclass.

=head2 to_string

  my $str = $cookie->to_string;

Render cookie. Meant to be overloaded in a subclass.

=head1 OPERATORS

L<Mojo::Cookie> overloads the following operators.

=head2 bool

  my $bool = !!$cookie;

Always true.

=head2 stringify

  my $str = "$cookie";

Alias for L</"to_string">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut

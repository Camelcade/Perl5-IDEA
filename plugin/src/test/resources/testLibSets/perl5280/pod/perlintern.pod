-*- buffer-read-only: t -*-
!!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
This file is built by autodoc.pl extracting documentation from the C source
files.
Any changes made here will be lost!

=head1 NAME

perlintern - autogenerated documentation of purely B<internal>
		 Perl functions

=head1 DESCRIPTION
X<internal Perl functions> X<interpreter functions>

This file is the autogenerated documentation of functions in the
Perl interpreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl API.  In other words,
B<they are not for use in extensions>!


=head1 Compile-time scope hooks

=over 8

=item BhkENTRY
X<BhkENTRY>


NOTE: this function is experimental and may change or be
removed without notice.


Return an entry from the BHK structure.  C<which> is a preprocessor token
indicating which entry to return.  If the appropriate flag is not set
this will return C<NULL>.  The type of the return value depends on which
entry you ask for.

	void *	BhkENTRY(BHK *hk, which)

=for hackers
Found in file op.h

=item BhkFLAGS
X<BhkFLAGS>


NOTE: this function is experimental and may change or be
removed without notice.


Return the BHK's flags.

	U32	BhkFLAGS(BHK *hk)

=for hackers
Found in file op.h

=item CALL_BLOCK_HOOKS
X<CALL_BLOCK_HOOKS>


NOTE: this function is experimental and may change or be
removed without notice.


Call all the registered block hooks for type C<which>.  C<which> is a
preprocessing token; the type of C<arg> depends on C<which>.

	void	CALL_BLOCK_HOOKS(which, arg)

=for hackers
Found in file op.h


=back

=head1 Custom Operators

=over 8

=item core_prototype
X<core_prototype>

This function assigns the prototype of the named core function to C<sv>, or
to a new mortal SV if C<sv> is C<NULL>.  It returns the modified C<sv>, or
C<NULL> if the core function has no prototype.  C<code> is a code as returned
by C<keyword()>.  It must not be equal to 0.

	SV *	core_prototype(SV *sv, const char *name,
		               const int code,
		               int * const opnum)

=for hackers
Found in file op.c


=back

=head1 CV Manipulation Functions

=over 8

=item docatch
X<docatch>

Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.

0 is used as continue inside eval,

3 is used for a die caught by an inner eval - continue inner loop

See F<cop.h>: je_mustcatch, when set at any runlevel to TRUE, means eval ops must
establish a local jmpenv to handle exception traps.

	OP*	docatch(Perl_ppaddr_t firstpp)

=for hackers
Found in file pp_ctl.c


=back

=head1 CV reference counts and CvOUTSIDE

=over 8

=item CvWEAKOUTSIDE
X<CvWEAKOUTSIDE>

Each CV has a pointer, C<CvOUTSIDE()>, to its lexically enclosing
CV (if any).  Because pointers to anonymous sub prototypes are
stored in C<&> pad slots, it is a possible to get a circular reference,
with the parent pointing to the child and vice-versa.  To avoid the
ensuing memory leak, we do not increment the reference count of the CV
pointed to by C<CvOUTSIDE> in the I<one specific instance> that the parent
has a C<&> pad slot pointing back to us.  In this case, we set the
C<CvWEAKOUTSIDE> flag in the child.  This allows us to determine under what
circumstances we should decrement the refcount of the parent when freeing
the child.

There is a further complication with non-closure anonymous subs (i.e. those
that do not refer to any lexicals outside that sub).  In this case, the
anonymous prototype is shared rather than being cloned.  This has the
consequence that the parent may be freed while there are still active
children, I<e.g.>,

    BEGIN { $a = sub { eval '$x' } }

In this case, the BEGIN is freed immediately after execution since there
are no active references to it: the anon sub prototype has
C<CvWEAKOUTSIDE> set since it's not a closure, and $a points to the same
CV, so it doesn't contribute to BEGIN's refcount either.  When $a is
executed, the C<eval '$x'> causes the chain of C<CvOUTSIDE>s to be followed,
and the freed BEGIN is accessed.

To avoid this, whenever a CV and its associated pad is freed, any
C<&> entries in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon sub is still positive, then that
child's C<CvOUTSIDE> is set to point to its grandparent.  This will only
occur in the single specific case of a non-closure anon prototype
having one or more active references (such as C<$a> above).

One other thing to consider is that a CV may be merely undefined
rather than freed, eg C<undef &foo>.  In this case, its refcount may
not have reached zero, but we still delete its pad and its C<CvROOT> etc.
Since various children may still have their C<CvOUTSIDE> pointing at this
undefined CV, we keep its own C<CvOUTSIDE> for the time being, so that
the chain of lexical scopes is unbroken.  For example, the following
should print 123:

    my $x = 123;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &tmp;
    print  $a->();

	bool	CvWEAKOUTSIDE(CV *cv)

=for hackers
Found in file cv.h


=back

=head1 Embedding Functions

=over 8

=item cv_dump
X<cv_dump>

dump the contents of a CV

	void	cv_dump(CV *cv, const char *title)

=for hackers
Found in file pad.c

=item cv_forget_slab
X<cv_forget_slab>

When a CV has a reference count on its slab (C<CvSLABBED>), it is responsible
for making sure it is freed.  (Hence, no two CVs should ever have a
reference count on the same slab.)  The CV only needs to reference the slab
during compilation.  Once it is compiled and C<CvROOT> attached, it has
finished its job, so it can forget the slab.

	void	cv_forget_slab(CV *cv)

=for hackers
Found in file pad.c

=item do_dump_pad
X<do_dump_pad>

Dump the contents of a padlist

	void	do_dump_pad(I32 level, PerlIO *file,
		            PADLIST *padlist, int full)

=for hackers
Found in file pad.c

=item pad_alloc_name
X<pad_alloc_name>

Allocates a place in the currently-compiling
pad (via L<perlapi/pad_alloc>) and
then stores a name for that entry.  C<name> is adopted and
becomes the name entry; it must already contain the name
string.  C<typestash> and C<ourstash> and the C<padadd_STATE>
flag get added to C<name>.  None of the other
processing of L<perlapi/pad_add_name_pvn>
is done.  Returns the offset of the allocated pad slot.

	PADOFFSET pad_alloc_name(PADNAME *name, U32 flags,
	                         HV *typestash, HV *ourstash)

=for hackers
Found in file pad.c

=item pad_block_start
X<pad_block_start>

Update the pad compilation state variables on entry to a new block.

	void	pad_block_start(int full)

=for hackers
Found in file pad.c

=item pad_check_dup
X<pad_check_dup>

Check for duplicate declarations: report any of:

     * a 'my' in the current scope with the same name;
     * an 'our' (anywhere in the pad) with the same name and the
       same stash as 'ourstash'

C<is_our> indicates that the name to check is an C<"our"> declaration.

	void	pad_check_dup(PADNAME *name, U32 flags,
		              const HV *ourstash)

=for hackers
Found in file pad.c

=item pad_findlex
X<pad_findlex>

Find a named lexical anywhere in a chain of nested pads.  Add fake entries
in the inner pads if it's found in an outer one.

Returns the offset in the bottom pad of the lex or the fake lex.
C<cv> is the CV in which to start the search, and seq is the current C<cop_seq>
to match against.  If C<warn> is true, print appropriate warnings.  The C<out_>*
vars return values, and so are pointers to where the returned values
should be stored.  C<out_capture>, if non-null, requests that the innermost
instance of the lexical is captured; C<out_name> is set to the innermost
matched pad name or fake pad name; C<out_flags> returns the flags normally
associated with the C<PARENT_FAKELEX_FLAGS> field of a fake pad name.

Note that C<pad_findlex()> is recursive; it recurses up the chain of CVs,
then comes back down, adding fake entries
as it goes.  It has to be this way
because fake names in anon protoypes have to store in C<xpadn_low> the
index into the parent pad.

	PADOFFSET pad_findlex(const char *namepv,
	                      STRLEN namelen, U32 flags,
	                      const CV* cv, U32 seq, int warn,
	                      SV** out_capture,
	                      PADNAME** out_name,
	                      int *out_flags)

=for hackers
Found in file pad.c

=item pad_fixup_inner_anons
X<pad_fixup_inner_anons>

For any anon CVs in the pad, change C<CvOUTSIDE> of that CV from
C<old_cv> to C<new_cv> if necessary.  Needed when a newly-compiled CV has to be
moved to a pre-existing CV struct.

	void	pad_fixup_inner_anons(PADLIST *padlist,
		                      CV *old_cv, CV *new_cv)

=for hackers
Found in file pad.c

=item pad_free
X<pad_free>

Free the SV at offset po in the current pad.

	void	pad_free(PADOFFSET po)

=for hackers
Found in file pad.c

=item pad_leavemy
X<pad_leavemy>

Cleanup at end of scope during compilation: set the max seq number for
lexicals in this scope and warn of any lexicals that never got introduced.

	void	pad_leavemy()

=for hackers
Found in file pad.c

=item padlist_dup
X<padlist_dup>

Duplicates a pad.

	PADLIST * padlist_dup(PADLIST *srcpad,
	                      CLONE_PARAMS *param)

=for hackers
Found in file pad.c

=item padname_dup
X<padname_dup>

Duplicates a pad name.

	PADNAME * padname_dup(PADNAME *src, CLONE_PARAMS *param)

=for hackers
Found in file pad.c

=item padnamelist_dup
X<padnamelist_dup>

Duplicates a pad name list.

	PADNAMELIST * padnamelist_dup(PADNAMELIST *srcpad,
	                              CLONE_PARAMS *param)

=for hackers
Found in file pad.c

=item pad_push
X<pad_push>

Push a new pad frame onto the padlist, unless there's already a pad at
this depth, in which case don't bother creating a new one.  Then give
the new pad an C<@_> in slot zero.

	void	pad_push(PADLIST *padlist, int depth)

=for hackers
Found in file pad.c

=item pad_reset
X<pad_reset>

Mark all the current temporaries for reuse

	void	pad_reset()

=for hackers
Found in file pad.c

=item pad_swipe
X<pad_swipe>

Abandon the tmp in the current pad at offset C<po> and replace with a
new one.

	void	pad_swipe(PADOFFSET po, bool refadjust)

=for hackers
Found in file pad.c


=back

=head1 GV Functions

=over 8

=item gv_try_downgrade
X<gv_try_downgrade>


NOTE: this function is experimental and may change or be
removed without notice.


If the typeglob C<gv> can be expressed more succinctly, by having
something other than a real GV in its place in the stash, replace it
with the optimised form.  Basic requirements for this are that C<gv>
is a real typeglob, is sufficiently ordinary, and is only referenced
from its package.  This function is meant to be used when a GV has been
looked up in part to see what was there, causing upgrading, but based
on what was found it turns out that the real GV isn't required after all.

If C<gv> is a completely empty typeglob, it is deleted from the stash.

If C<gv> is a typeglob containing only a sufficiently-ordinary constant
sub, the typeglob is replaced with a scalar-reference placeholder that
more compactly represents the same thing.

	void	gv_try_downgrade(GV* gv)

=for hackers
Found in file gv.c


=back

=head1 Hash Manipulation Functions

=over 8

=item hv_ename_add
X<hv_ename_add>

Adds a name to a stash's internal list of effective names.  See
C<L</hv_ename_delete>>.

This is called when a stash is assigned to a new location in the symbol
table.

	void	hv_ename_add(HV *hv, const char *name, U32 len,
		             U32 flags)

=for hackers
Found in file hv.c

=item hv_ename_delete
X<hv_ename_delete>

Removes a name from a stash's internal list of effective names.  If this is
the name returned by C<HvENAME>, then another name in the list will take
its place (C<HvENAME> will use it).

This is called when a stash is deleted from the symbol table.

	void	hv_ename_delete(HV *hv, const char *name,
		                U32 len, U32 flags)

=for hackers
Found in file hv.c

=item refcounted_he_chain_2hv
X<refcounted_he_chain_2hv>

Generates and returns a C<HV *> representing the content of a
C<refcounted_he> chain.
C<flags> is currently unused and must be zero.

	HV *	refcounted_he_chain_2hv(
		    const struct refcounted_he *c, U32 flags
		)

=for hackers
Found in file hv.c

=item refcounted_he_fetch_pv
X<refcounted_he_fetch_pv>

Like L</refcounted_he_fetch_pvn>, but takes a nul-terminated string
instead of a string/length pair.

	SV *	refcounted_he_fetch_pv(
		    const struct refcounted_he *chain,
		    const char *key, U32 hash, U32 flags
		)

=for hackers
Found in file hv.c

=item refcounted_he_fetch_pvn
X<refcounted_he_fetch_pvn>

Search along a C<refcounted_he> chain for an entry with the key specified
by C<keypv> and C<keylen>.  If C<flags> has the C<REFCOUNTED_HE_KEY_UTF8>
bit set, the key octets are interpreted as UTF-8, otherwise they
are interpreted as Latin-1.  C<hash> is a precomputed hash of the key
string, or zero if it has not been precomputed.  Returns a mortal scalar
representing the value associated with the key, or C<&PL_sv_placeholder>
if there is no value associated with the key.

	SV *	refcounted_he_fetch_pvn(
		    const struct refcounted_he *chain,
		    const char *keypv, STRLEN keylen, U32 hash,
		    U32 flags
		)

=for hackers
Found in file hv.c

=item refcounted_he_fetch_pvs
X<refcounted_he_fetch_pvs>

Like L</refcounted_he_fetch_pvn>, but takes a literal string
instead of a string/length pair, and no precomputed hash.

	SV *	refcounted_he_fetch_pvs(
		    const struct refcounted_he *chain,
		    "literal string" key, U32 flags
		)

=for hackers
Found in file hv.h

=item refcounted_he_fetch_sv
X<refcounted_he_fetch_sv>

Like L</refcounted_he_fetch_pvn>, but takes a Perl scalar instead of a
string/length pair.

	SV *	refcounted_he_fetch_sv(
		    const struct refcounted_he *chain, SV *key,
		    U32 hash, U32 flags
		)

=for hackers
Found in file hv.c

=item refcounted_he_free
X<refcounted_he_free>

Decrements the reference count of a C<refcounted_he> by one.  If the
reference count reaches zero the structure's memory is freed, which
(recursively) causes a reduction of its parent C<refcounted_he>'s
reference count.  It is safe to pass a null pointer to this function:
no action occurs in this case.

	void	refcounted_he_free(struct refcounted_he *he)

=for hackers
Found in file hv.c

=item refcounted_he_inc
X<refcounted_he_inc>

Increment the reference count of a C<refcounted_he>.  The pointer to the
C<refcounted_he> is also returned.  It is safe to pass a null pointer
to this function: no action occurs and a null pointer is returned.

	struct refcounted_he * refcounted_he_inc(
	                           struct refcounted_he *he
	                       )

=for hackers
Found in file hv.c

=item refcounted_he_new_pv
X<refcounted_he_new_pv>

Like L</refcounted_he_new_pvn>, but takes a nul-terminated string instead
of a string/length pair.

	struct refcounted_he * refcounted_he_new_pv(
	                           struct refcounted_he *parent,
	                           const char *key, U32 hash,
	                           SV *value, U32 flags
	                       )

=for hackers
Found in file hv.c

=item refcounted_he_new_pvn
X<refcounted_he_new_pvn>

Creates a new C<refcounted_he>.  This consists of a single key/value
pair and a reference to an existing C<refcounted_he> chain (which may
be empty), and thus forms a longer chain.  When using the longer chain,
the new key/value pair takes precedence over any entry for the same key
further along the chain.

The new key is specified by C<keypv> and C<keylen>.  If C<flags> has
the C<REFCOUNTED_HE_KEY_UTF8> bit set, the key octets are interpreted
as UTF-8, otherwise they are interpreted as Latin-1.  C<hash> is
a precomputed hash of the key string, or zero if it has not been
precomputed.

C<value> is the scalar value to store for this key.  C<value> is copied
by this function, which thus does not take ownership of any reference
to it, and later changes to the scalar will not be reflected in the
value visible in the C<refcounted_he>.  Complex types of scalar will not
be stored with referential integrity, but will be coerced to strings.
C<value> may be either null or C<&PL_sv_placeholder> to indicate that no
value is to be associated with the key; this, as with any non-null value,
takes precedence over the existence of a value for the key further along
the chain.

C<parent> points to the rest of the C<refcounted_he> chain to be
attached to the new C<refcounted_he>.  This function takes ownership
of one reference to C<parent>, and returns one reference to the new
C<refcounted_he>.

	struct refcounted_he * refcounted_he_new_pvn(
	                           struct refcounted_he *parent,
	                           const char *keypv,
	                           STRLEN keylen, U32 hash,
	                           SV *value, U32 flags
	                       )

=for hackers
Found in file hv.c

=item refcounted_he_new_pvs
X<refcounted_he_new_pvs>

Like L</refcounted_he_new_pvn>, but takes a literal string
instead of a string/length pair, and no precomputed hash.

	struct refcounted_he * refcounted_he_new_pvs(
	                           struct refcounted_he *parent,
	                           "literal string" key,
	                           SV *value, U32 flags
	                       )

=for hackers
Found in file hv.h

=item refcounted_he_new_sv
X<refcounted_he_new_sv>

Like L</refcounted_he_new_pvn>, but takes a Perl scalar instead of a
string/length pair.

	struct refcounted_he * refcounted_he_new_sv(
	                           struct refcounted_he *parent,
	                           SV *key, U32 hash, SV *value,
	                           U32 flags
	                       )

=for hackers
Found in file hv.c


=back

=head1 IO Functions

=over 8

=item start_glob
X<start_glob>


NOTE: this function is experimental and may change or be
removed without notice.


Function called by C<do_readline> to spawn a glob (or do the glob inside
perl on VMS).  This code used to be inline, but now perl uses C<File::Glob>
this glob starter is only used by miniperl during the build process,
or when PERL_EXTERNAL_GLOB is defined.
Moving it away shrinks F<pp_hot.c>; shrinking F<pp_hot.c> helps speed perl up.

	PerlIO*	start_glob(SV *tmpglob, IO *io)

=for hackers
Found in file doio.c


=back

=head1 Lexer interface

=over 8

=item validate_proto
X<validate_proto>


NOTE: this function is experimental and may change or be
removed without notice.


This function performs syntax checking on a prototype, C<proto>.
If C<warn> is true, any illegal characters or mismatched brackets
will trigger illegalproto warnings, declaring that they were
detected in the prototype for C<name>.

The return value is C<true> if this is a valid prototype, and
C<false> if it is not, regardless of whether C<warn> was C<true> or
C<false>.

Note that C<NULL> is a valid C<proto> and will always return C<true>.

NOTE: the perl_ form of this function is deprecated.

	bool	validate_proto(SV *name, SV *proto, bool warn,
		               bool curstash)

=for hackers
Found in file toke.c


=back

=head1 Magical Functions

=over 8

=item magic_clearhint
X<magic_clearhint>

Triggered by a delete from C<%^H>, records the key to
C<PL_compiling.cop_hints_hash>.

	int	magic_clearhint(SV* sv, MAGIC* mg)

=for hackers
Found in file mg.c

=item magic_clearhints
X<magic_clearhints>

Triggered by clearing C<%^H>, resets C<PL_compiling.cop_hints_hash>.

	int	magic_clearhints(SV* sv, MAGIC* mg)

=for hackers
Found in file mg.c

=item magic_methcall
X<magic_methcall>

Invoke a magic method (like FETCH).

C<sv> and C<mg> are the tied thingy and the tie magic.

C<meth> is the name of the method to call.

C<argc> is the number of args (in addition to $self) to pass to the method.

The C<flags> can be:

    G_DISCARD     invoke method with G_DISCARD flag and don't
                  return a value
    G_UNDEF_FILL  fill the stack with argc pointers to
                  PL_sv_undef

The arguments themselves are any values following the C<flags> argument.

Returns the SV (if any) returned by the method, or C<NULL> on failure.


	SV*	magic_methcall(SV *sv, const MAGIC *mg,
		               SV *meth, U32 flags, U32 argc,
		               ...)

=for hackers
Found in file mg.c

=item magic_sethint
X<magic_sethint>

Triggered by a store to C<%^H>, records the key/value pair to
C<PL_compiling.cop_hints_hash>.  It is assumed that hints aren't storing
anything that would need a deep copy.  Maybe we should warn if we find a
reference.

	int	magic_sethint(SV* sv, MAGIC* mg)

=for hackers
Found in file mg.c

=item mg_localize
X<mg_localize>

Copy some of the magic from an existing SV to new localized version of that
SV.  Container magic (I<e.g.>, C<%ENV>, C<$1>, C<tie>)
gets copied, value magic doesn't (I<e.g.>,
C<taint>, C<pos>).

If C<setmagic> is false then no set magic will be called on the new (empty) SV.
This typically means that assignment will soon follow (e.g. S<C<'local $x = $y'>>),
and that will handle the magic.

	void	mg_localize(SV* sv, SV* nsv, bool setmagic)

=for hackers
Found in file mg.c


=back

=head1 Miscellaneous Functions

=over 8

=item free_c_backtrace
X<free_c_backtrace>

Deallocates a backtrace received from get_c_bracktrace.

	void	free_c_backtrace(Perl_c_backtrace* bt)

=for hackers
Found in file util.c

=item get_c_backtrace
X<get_c_backtrace>

Collects the backtrace (aka "stacktrace") into a single linear
malloced buffer, which the caller B<must> C<Perl_free_c_backtrace()>.

Scans the frames back by S<C<depth + skip>>, then drops the C<skip> innermost,
returning at most C<depth> frames.

	Perl_c_backtrace* get_c_backtrace(int max_depth,
	                                  int skip)

=for hackers
Found in file util.c


=back

=head1 MRO Functions

=over 8

=item mro_get_linear_isa_dfs
X<mro_get_linear_isa_dfs>

Returns the Depth-First Search linearization of C<@ISA>
the given stash.  The return value is a read-only AV*.
C<level> should be 0 (it is used internally in this
function's recursion).

You are responsible for C<SvREFCNT_inc()> on the
return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted
out from under you the next time the cache is
invalidated).

	AV*	mro_get_linear_isa_dfs(HV* stash, U32 level)

=for hackers
Found in file mro_core.c

=item mro_isa_changed_in
X<mro_isa_changed_in>

Takes the necessary steps (cache invalidations, mostly)
when the C<@ISA> of the given package has changed.  Invoked
by the C<setisa> magic, should not need to invoke directly.

	void	mro_isa_changed_in(HV* stash)

=for hackers
Found in file mro_core.c

=item mro_package_moved
X<mro_package_moved>

Call this function to signal to a stash that it has been assigned to
another spot in the stash hierarchy.  C<stash> is the stash that has been
assigned.  C<oldstash> is the stash it replaces, if any.  C<gv> is the glob
that is actually being assigned to.

This can also be called with a null first argument to
indicate that C<oldstash> has been deleted.

This function invalidates isa caches on the old stash, on all subpackages
nested inside it, and on the subclasses of all those, including
non-existent packages that have corresponding entries in C<stash>.

It also sets the effective names (C<HvENAME>) on all the stashes as
appropriate.

If the C<gv> is present and is not in the symbol table, then this function
simply returns.  This checked will be skipped if C<flags & 1>.

	void	mro_package_moved(HV * const stash,
		                  HV * const oldstash,
		                  const GV * const gv,
		                  U32 flags)

=for hackers
Found in file mro_core.c


=back

=head1 Optree Manipulation Functions

=over 8

=item finalize_optree
X<finalize_optree>

This function finalizes the optree.  Should be called directly after
the complete optree is built.  It does some additional
checking which can't be done in the normal C<ck_>xxx functions and makes
the tree thread-safe.

	void	finalize_optree(OP* o)

=for hackers
Found in file op.c

=item newATTRSUB_x
X<newATTRSUB_x>

Construct a Perl subroutine, also performing some surrounding jobs.

This function is expected to be called in a Perl compilation context,
and some aspects of the subroutine are taken from global variables
associated with compilation.  In particular, C<PL_compcv> represents
the subroutine that is currently being compiled.  It must be non-null
when this function is called, and some aspects of the subroutine being
constructed are taken from it.  The constructed subroutine may actually
be a reuse of the C<PL_compcv> object, but will not necessarily be so.

If C<block> is null then the subroutine will have no body, and for the
time being it will be an error to call it.  This represents a forward
subroutine declaration such as S<C<sub foo ($$);>>.  If C<block> is
non-null then it provides the Perl code of the subroutine body, which
will be executed when the subroutine is called.  This body includes
any argument unwrapping code resulting from a subroutine signature or
similar.  The pad use of the code must correspond to the pad attached
to C<PL_compcv>.  The code is not expected to include a C<leavesub> or
C<leavesublv> op; this function will add such an op.  C<block> is consumed
by this function and will become part of the constructed subroutine.

C<proto> specifies the subroutine's prototype, unless one is supplied
as an attribute (see below).  If C<proto> is null, then the subroutine
will not have a prototype.  If C<proto> is non-null, it must point to a
C<const> op whose value is a string, and the subroutine will have that
string as its prototype.  If a prototype is supplied as an attribute, the
attribute takes precedence over C<proto>, but in that case C<proto> should
preferably be null.  In any case, C<proto> is consumed by this function.

C<attrs> supplies attributes to be applied the subroutine.  A handful of
attributes take effect by built-in means, being applied to C<PL_compcv>
immediately when seen.  Other attributes are collected up and attached
to the subroutine by this route.  C<attrs> may be null to supply no
attributes, or point to a C<const> op for a single attribute, or point
to a C<list> op whose children apart from the C<pushmark> are C<const>
ops for one or more attributes.  Each C<const> op must be a string,
giving the attribute name optionally followed by parenthesised arguments,
in the manner in which attributes appear in Perl source.  The attributes
will be applied to the sub by this function.  C<attrs> is consumed by
this function.

If C<o_is_gv> is false and C<o> is null, then the subroutine will
be anonymous.  If C<o_is_gv> is false and C<o> is non-null, then C<o>
must point to a C<const> op, which will be consumed by this function,
and its string value supplies a name for the subroutine.  The name may
be qualified or unqualified, and if it is unqualified then a default
stash will be selected in some manner.  If C<o_is_gv> is true, then C<o>
doesn't point to an C<OP> at all, but is instead a cast pointer to a C<GV>
by which the subroutine will be named.

If there is already a subroutine of the specified name, then the new
sub will either replace the existing one in the glob or be merged with
the existing one.  A warning may be generated about redefinition.

If the subroutine has one of a few special names, such as C<BEGIN> or
C<END>, then it will be claimed by the appropriate queue for automatic
running of phase-related subroutines.  In this case the relevant glob will
be left not containing any subroutine, even if it did contain one before.
In the case of C<BEGIN>, the subroutine will be executed and the reference
to it disposed of before this function returns.

The function returns a pointer to the constructed subroutine.  If the sub
is anonymous then ownership of one counted reference to the subroutine
is transferred to the caller.  If the sub is named then the caller does
not get ownership of a reference.  In most such cases, where the sub
has a non-phase name, the sub will be alive at the point it is returned
by virtue of being contained in the glob that names it.  A phase-named
subroutine will usually be alive by virtue of the reference owned by the
phase's automatic run queue.  But a C<BEGIN> subroutine, having already
been executed, will quite likely have been destroyed already by the
time this function returns, making it erroneous for the caller to make
any use of the returned pointer.  It is the caller's responsibility to
ensure that it knows which of these situations applies.

	CV *	newATTRSUB_x(I32 floor, OP *o, OP *proto,
		             OP *attrs, OP *block, bool o_is_gv)

=for hackers
Found in file op.c

=item newXS_len_flags
X<newXS_len_flags>

Construct an XS subroutine, also performing some surrounding jobs.

The subroutine will have the entry point C<subaddr>.  It will have
the prototype specified by the nul-terminated string C<proto>, or
no prototype if C<proto> is null.  The prototype string is copied;
the caller can mutate the supplied string afterwards.  If C<filename>
is non-null, it must be a nul-terminated filename, and the subroutine
will have its C<CvFILE> set accordingly.  By default C<CvFILE> is set to
point directly to the supplied string, which must be static.  If C<flags>
has the C<XS_DYNAMIC_FILENAME> bit set, then a copy of the string will
be taken instead.

Other aspects of the subroutine will be left in their default state.
If anything else needs to be done to the subroutine for it to function
correctly, it is the caller's responsibility to do that after this
function has constructed it.  However, beware of the subroutine
potentially being destroyed before this function returns, as described
below.

If C<name> is null then the subroutine will be anonymous, with its
C<CvGV> referring to an C<__ANON__> glob.  If C<name> is non-null then the
subroutine will be named accordingly, referenced by the appropriate glob.
C<name> is a string of length C<len> bytes giving a sigilless symbol name,
in UTF-8 if C<flags> has the C<SVf_UTF8> bit set and in Latin-1 otherwise.
The name may be either qualified or unqualified, with the stash defaulting
in the same manner as for C<gv_fetchpvn_flags>.  C<flags> may contain
flag bits understood by C<gv_fetchpvn_flags> with the same meaning as
they have there, such as C<GV_ADDWARN>.  The symbol is always added to
the stash if necessary, with C<GV_ADDMULTI> semantics.

If there is already a subroutine of the specified name, then the new sub
will replace the existing one in the glob.  A warning may be generated
about the redefinition.  If the old subroutine was C<CvCONST> then the
decision about whether to warn is influenced by an expectation about
whether the new subroutine will become a constant of similar value.
That expectation is determined by C<const_svp>.  (Note that the call to
this function doesn't make the new subroutine C<CvCONST> in any case;
that is left to the caller.)  If C<const_svp> is null then it indicates
that the new subroutine will not become a constant.  If C<const_svp>
is non-null then it indicates that the new subroutine will become a
constant, and it points to an C<SV*> that provides the constant value
that the subroutine will have.

If the subroutine has one of a few special names, such as C<BEGIN> or
C<END>, then it will be claimed by the appropriate queue for automatic
running of phase-related subroutines.  In this case the relevant glob will
be left not containing any subroutine, even if it did contain one before.
In the case of C<BEGIN>, the subroutine will be executed and the reference
to it disposed of before this function returns, and also before its
prototype is set.  If a C<BEGIN> subroutine would not be sufficiently
constructed by this function to be ready for execution then the caller
must prevent this happening by giving the subroutine a different name.

The function returns a pointer to the constructed subroutine.  If the sub
is anonymous then ownership of one counted reference to the subroutine
is transferred to the caller.  If the sub is named then the caller does
not get ownership of a reference.  In most such cases, where the sub
has a non-phase name, the sub will be alive at the point it is returned
by virtue of being contained in the glob that names it.  A phase-named
subroutine will usually be alive by virtue of the reference owned by the
phase's automatic run queue.  But a C<BEGIN> subroutine, having already
been executed, will quite likely have been destroyed already by the
time this function returns, making it erroneous for the caller to make
any use of the returned pointer.  It is the caller's responsibility to
ensure that it knows which of these situations applies.

	CV *	newXS_len_flags(const char *name, STRLEN len,
		                XSUBADDR_t subaddr,
		                const char *const filename,
		                const char *const proto,
		                SV **const_svp, U32 flags)

=for hackers
Found in file op.c

=item optimize_optree
X<optimize_optree>

This function applies some optimisations to the optree in top-down order.
It is called before the peephole optimizer, which processes ops in
execution order. Note that finalize_optree() also does a top-down scan,
but is called *after* the peephole optimizer.

	void	optimize_optree(OP* o)

=for hackers
Found in file op.c


=back

=head1 Pad Data Structures

=over 8

=item CX_CURPAD_SAVE
X<CX_CURPAD_SAVE>

Save the current pad in the given context block structure.

	void	CX_CURPAD_SAVE(struct context)

=for hackers
Found in file pad.h

=item CX_CURPAD_SV
X<CX_CURPAD_SV>

Access the SV at offset C<po> in the saved current pad in the given
context block structure (can be used as an lvalue).

	SV *	CX_CURPAD_SV(struct context, PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_BASE_SV
X<PAD_BASE_SV>

Get the value from slot C<po> in the base (DEPTH=1) pad of a padlist

	SV *	PAD_BASE_SV(PADLIST padlist, PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_CLONE_VARS
X<PAD_CLONE_VARS>

Clone the state variables associated with running and compiling pads.

	void	PAD_CLONE_VARS(PerlInterpreter *proto_perl,
		               CLONE_PARAMS* param)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_FLAGS
X<PAD_COMPNAME_FLAGS>

Return the flags for the current compiling pad name
at offset C<po>.  Assumes a valid slot entry.

	U32	PAD_COMPNAME_FLAGS(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_GEN
X<PAD_COMPNAME_GEN>

The generation number of the name at offset C<po> in the current
compiling pad (lvalue).

	STRLEN	PAD_COMPNAME_GEN(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_GEN_set
X<PAD_COMPNAME_GEN_set>

Sets the generation number of the name at offset C<po> in the current
ling pad (lvalue) to C<gen>.
	STRLEN	PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_OURSTASH
X<PAD_COMPNAME_OURSTASH>

Return the stash associated with an C<our> variable.
Assumes the slot entry is a valid C<our> lexical.

	HV *	PAD_COMPNAME_OURSTASH(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_PV
X<PAD_COMPNAME_PV>

Return the name of the current compiling pad name
at offset C<po>.  Assumes a valid slot entry.

	char *	PAD_COMPNAME_PV(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_COMPNAME_TYPE
X<PAD_COMPNAME_TYPE>

Return the type (stash) of the current compiling pad name at offset
C<po>.  Must be a valid name.  Returns null if not typed.

	HV *	PAD_COMPNAME_TYPE(PADOFFSET po)

=for hackers
Found in file pad.h

=item PadnameIsOUR
X<PadnameIsOUR>

Whether this is an "our" variable.

	bool	PadnameIsOUR(PADNAME pn)

=for hackers
Found in file pad.h

=item PadnameIsSTATE
X<PadnameIsSTATE>

Whether this is a "state" variable.

	bool	PadnameIsSTATE(PADNAME pn)

=for hackers
Found in file pad.h

=item PadnameOURSTASH
X<PadnameOURSTASH>

The stash in which this "our" variable was declared.

	HV *	PadnameOURSTASH()

=for hackers
Found in file pad.h

=item PadnameOUTER
X<PadnameOUTER>

Whether this entry belongs to an outer pad.  Entries for which this is true
are often referred to as 'fake'.

	bool	PadnameOUTER(PADNAME pn)

=for hackers
Found in file pad.h

=item PadnameTYPE
X<PadnameTYPE>

The stash associated with a typed lexical.  This returns the C<%Foo::> hash
for C<my Foo $bar>.

	HV *	PadnameTYPE(PADNAME pn)

=for hackers
Found in file pad.h

=item PAD_RESTORE_LOCAL
X<PAD_RESTORE_LOCAL>

Restore the old pad saved into the local variable C<opad> by C<PAD_SAVE_LOCAL()>

	void	PAD_RESTORE_LOCAL(PAD *opad)

=for hackers
Found in file pad.h

=item PAD_SAVE_LOCAL
X<PAD_SAVE_LOCAL>

Save the current pad to the local variable C<opad>, then make the
current pad equal to C<npad>

	void	PAD_SAVE_LOCAL(PAD *opad, PAD *npad)

=for hackers
Found in file pad.h

=item PAD_SAVE_SETNULLPAD
X<PAD_SAVE_SETNULLPAD>

Save the current pad then set it to null.

	void	PAD_SAVE_SETNULLPAD()

=for hackers
Found in file pad.h

=item PAD_SETSV
X<PAD_SETSV>

Set the slot at offset C<po> in the current pad to C<sv>

	SV *	PAD_SETSV(PADOFFSET po, SV* sv)

=for hackers
Found in file pad.h

=item PAD_SET_CUR
X<PAD_SET_CUR>

Set the current pad to be pad C<n> in the padlist, saving
the previous current pad.  NB currently this macro expands to a string too
long for some compilers, so it's best to replace it with

    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);


	void	PAD_SET_CUR(PADLIST padlist, I32 n)

=for hackers
Found in file pad.h

=item PAD_SET_CUR_NOSAVE
X<PAD_SET_CUR_NOSAVE>

like PAD_SET_CUR, but without the save

	void	PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)

=for hackers
Found in file pad.h

=item PAD_SV
X<PAD_SV>

Get the value at offset C<po> in the current pad

	SV *	PAD_SV(PADOFFSET po)

=for hackers
Found in file pad.h

=item PAD_SVl
X<PAD_SVl>

Lightweight and lvalue version of C<PAD_SV>.
Get or set the value at offset C<po> in the current pad.
Unlike C<PAD_SV>, does not print diagnostics with -DX.
For internal use only.

	SV *	PAD_SVl(PADOFFSET po)

=for hackers
Found in file pad.h

=item SAVECLEARSV
X<SAVECLEARSV>

Clear the pointed to pad value on scope exit.  (i.e. the runtime action of
C<my>)

	void	SAVECLEARSV(SV **svp)

=for hackers
Found in file pad.h

=item SAVECOMPPAD
X<SAVECOMPPAD>

save C<PL_comppad> and C<PL_curpad>


	void	SAVECOMPPAD()

=for hackers
Found in file pad.h

=item SAVEPADSV
X<SAVEPADSV>

Save a pad slot (used to restore after an iteration)

XXX DAPM it would make more sense to make the arg a PADOFFSET
	void	SAVEPADSV(PADOFFSET po)

=for hackers
Found in file pad.h


=back

=head1 Per-Interpreter Variables

=over 8

=item PL_DBsingle
X<PL_DBsingle>

When Perl is run in debugging mode, with the B<-d> switch, this SV is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's $DB::single variable.  See
C<L</PL_DBsub>>.

	SV *	PL_DBsingle

=for hackers
Found in file intrpvar.h

=item PL_DBsub
X<PL_DBsub>

When Perl is run in debugging mode, with the B<-d> switch, this GV contains
the SV which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's $DB::sub variable.  See
C<L</PL_DBsingle>>.

	GV *	PL_DBsub

=for hackers
Found in file intrpvar.h

=item PL_DBtrace
X<PL_DBtrace>

Trace variable used when Perl is run in debugging mode, with the B<-d>
switch.  This is the C variable which corresponds to Perl's $DB::trace
variable.  See C<L</PL_DBsingle>>.

	SV *	PL_DBtrace

=for hackers
Found in file intrpvar.h

=item PL_dowarn
X<PL_dowarn>

The C variable that roughly corresponds to Perl's C<$^W> warning variable.
However, C<$^W> is treated as a boolean, whereas C<PL_dowarn> is a
collection of flag bits.

	U8	PL_dowarn

=for hackers
Found in file intrpvar.h

=item PL_last_in_gv
X<PL_last_in_gv>

The GV which was last used for a filehandle input operation.  (C<< <FH> >>)

	GV*	PL_last_in_gv

=for hackers
Found in file intrpvar.h

=item PL_ofsgv
X<PL_ofsgv>

The glob containing the output field separator - C<*,> in Perl space.

	GV*	PL_ofsgv

=for hackers
Found in file intrpvar.h

=item PL_rs
X<PL_rs>

The input record separator - C<$/> in Perl space.

	SV*	PL_rs

=for hackers
Found in file intrpvar.h


=back

=head1 Stack Manipulation Macros

=over 8

=item djSP
X<djSP>

Declare Just C<SP>.  This is actually identical to C<dSP>, and declares
a local copy of perl's stack pointer, available via the C<SP> macro.
See C<L<perlapi/SP>>.  (Available for backward source code compatibility with
the old (Perl 5.005) thread model.)

		djSP;

=for hackers
Found in file pp.h

=item LVRET
X<LVRET>

True if this op will be the return value of an lvalue subroutine

=for hackers
Found in file pp.h


=back

=head1 SV-Body Allocation

=over 8

=item sv_2num
X<sv_2num>


NOTE: this function is experimental and may change or be
removed without notice.


Return an SV with the numeric value of the source SV, doing any necessary
reference or overload conversion.  The caller is expected to have handled
get-magic already.

	SV*	sv_2num(SV *const sv)

=for hackers
Found in file sv.c


=back

=head1 SV Manipulation Functions

An SV (or AV, HV, etc.) is allocated in two parts: the head (struct
sv, av, hv...) contains type and reference count information, and for
many types, a pointer to the body (struct xrv, xpv, xpviv...), which
contains fields specific to each type.  Some types store all they need
in the head, so don't have a body.

In all but the most memory-paranoid configurations (ex: PURIFY), heads
and bodies are allocated out of arenas, which by default are
approximately 4K chunks of memory parcelled up into N heads or bodies.
Sv-bodies are allocated by their sv-type, guaranteeing size
consistency needed to allocate safely from arrays.

For SV-heads, the first slot in each arena is reserved, and holds a
link to the next arena, some flags, and a note of the number of slots.
Snaked through each arena chain is a linked list of free items; when
this becomes empty, an extra arena is allocated and divided up into N
items which are threaded into the free list.

SV-bodies are similar, but they use arena-sets by default, which
separate the link and info from the arena itself, and reclaim the 1st
slot in the arena.  SV-bodies are further described later.

The following global variables are associated with arenas:

 PL_sv_arenaroot     pointer to list of SV arenas
 PL_sv_root          pointer to list of free SV structures

 PL_body_arenas      head of linked-list of body arenas
 PL_body_roots[]     array of pointers to list of free bodies of svtype
                     arrays are indexed by the svtype needed

A few special SV heads are not allocated from an arena, but are
instead directly created in the interpreter structure, eg PL_sv_undef.
The size of arenas can be changed from the default by setting
PERL_ARENA_SIZE appropriately at compile time.

The SV arena serves the secondary purpose of allowing still-live SVs
to be located and destroyed during final cleanup.

At the lowest level, the macros new_SV() and del_SV() grab and free
an SV head.  (If debugging with -DD, del_SV() calls the function S_del_sv()
to return the SV to the free list with error checking.) new_SV() calls
more_sv() / sv_add_arena() to add an extra arena if the free list is empty.
SVs in the free list have their SvTYPE field set to all ones.

At the time of very final cleanup, sv_free_arenas() is called from
perl_destruct() to physically free all the arenas allocated since the
start of the interpreter.

The function visit() scans the SV arenas list, and calls a specified
function for each SV it finds which is still live - ie which has an SvTYPE
other than all 1's, and a non-zero SvREFCNT. visit() is used by the
following functions (specified as [function that calls visit()] / [function
called by visit() for each SV]):

    sv_report_used() / do_report_used()
			dump all remaining SVs (debugging aid)

    sv_clean_objs() / do_clean_objs(),do_clean_named_objs(),
		      do_clean_named_io_objs(),do_curse()
			Attempt to free all objects pointed to by RVs,
			try to do the same for all objects indir-
			ectly referenced by typeglobs too, and
			then do a final sweep, cursing any
			objects that remain.  Called once from
			perl_destruct(), prior to calling sv_clean_all()
			below.

    sv_clean_all() / do_clean_all()
			SvREFCNT_dec(sv) each remaining SV, possibly
			triggering an sv_free(). It also sets the
			SVf_BREAK flag on the SV to indicate that the
			refcnt has been artificially lowered, and thus
			stopping sv_free() from giving spurious warnings
			about SVs which unexpectedly have a refcnt
			of zero.  called repeatedly from perl_destruct()
			until there are no SVs left.


=over 8

=item sv_add_arena
X<sv_add_arena>

Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.

	void	sv_add_arena(char *const ptr, const U32 size,
		             const U32 flags)

=for hackers
Found in file sv.c

=item sv_clean_all
X<sv_clean_all>

Decrement the refcnt of each remaining SV, possibly triggering a
cleanup.  This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.

	I32	sv_clean_all()

=for hackers
Found in file sv.c

=item sv_clean_objs
X<sv_clean_objs>

Attempt to destroy all objects not yet freed.

	void	sv_clean_objs()

=for hackers
Found in file sv.c

=item sv_free_arenas
X<sv_free_arenas>

Deallocate the memory used by all arenas.  Note that all the individual SV
heads and bodies within the arenas must already have been freed.

	void	sv_free_arenas()

=for hackers
Found in file sv.c

=item SvTHINKFIRST
X<SvTHINKFIRST>

A quick flag check to see whether an C<sv> should be passed to C<sv_force_normal>
to be "downgraded" before C<SvIVX> or C<SvPVX> can be modified directly.

For example, if your scalar is a reference and you want to modify the C<SvIVX>
slot, you can't just do C<SvROK_off>, as that will leak the referent.

This is used internally by various sv-modifying functions, such as
C<sv_setsv>, C<sv_setiv> and C<sv_pvn_force>.

One case that this does not handle is a gv without SvFAKE set.  After

    if (SvTHINKFIRST(gv)) sv_force_normal(gv);

it will still be a gv.

C<SvTHINKFIRST> sometimes produces false positives.  In those cases
C<sv_force_normal> does nothing.

	U32	SvTHINKFIRST(SV *sv)

=for hackers
Found in file sv.h


=back

=head1 Unicode Support

=over 8

=item find_uninit_var
X<find_uninit_var>


NOTE: this function is experimental and may change or be
removed without notice.


Find the name of the undefined variable (if any) that caused the operator
to issue a "Use of uninitialized value" warning.
If match is true, only return a name if its value matches C<uninit_sv>.
So roughly speaking, if a unary operator (such as C<OP_COS>) generates a
warning, then following the direct child of the op may yield an
C<OP_PADSV> or C<OP_GV> that gives the name of the undefined variable.  On the
other hand, with C<OP_ADD> there are two branches to follow, so we only print
the variable name if we get an exact match.
C<desc_p> points to a string pointer holding the description of the op.
This may be updated if needed.

The name is returned as a mortal SV.

Assumes that C<PL_op> is the OP that originally triggered the error, and that
C<PL_comppad>/C<PL_curpad> points to the currently executing pad.

	SV*	find_uninit_var(const OP *const obase,
		                const SV *const uninit_sv,
		                bool match, const char **desc_p)

=for hackers
Found in file sv.c

=item isSCRIPT_RUN
X<isSCRIPT_RUN>

Returns a bool as to whether or not the sequence of bytes from C<s> up to but
not including C<send> form a "script run".  C<utf8_target> is TRUE iff the
sequence starting at C<s> is to be treated as UTF-8.  To be precise, except for
two degenerate cases given below, this function returns TRUE iff all code
points in it come from any combination of three "scripts" given by the Unicode
"Script Extensions" property: Common, Inherited, and possibly one other.
Additionally all decimal digits must come from the same consecutive sequence of
10.

For example, if all the characters in the sequence are Greek, or Common, or
Inherited, this function will return TRUE, provided any decimal digits in it
are the ASCII digits "0".."9".  For scripts (unlike Greek) that have their own
digits defined this will accept either digits from that set or from 0..9, but
not a combination of the two.  Some scripts, such as Arabic, have more than one
set of digits.  All digits must come from the same set for this function to
return TRUE.

C<*ret_script>, if C<ret_script> is not NULL, will on return of TRUE
contain the script found, using the C<SCX_enum> typedef.  Its value will be
C<SCX_INVALID> if the function returns FALSE.

If the sequence is empty, TRUE is returned, but C<*ret_script> (if asked for)
will be C<SCX_INVALID>.

If the sequence contains a single code point which is unassigned to a character
in the version of Unicode being used, the function will return TRUE, and the
script will be C<SCX_Unknown>.  Any other combination of unassigned code points
in the input sequence will result in the function treating the input as not
being a script run.

The returned script will be C<SCX_Inherited> iff all the code points in it are
from the Inherited script.

Otherwise, the returned script will be C<SCX_Common> iff all the code points in
it are from the Inherited or Common scripts.

	bool	isSCRIPT_RUN(const U8 *s, const U8 *send,
		             const bool utf8_target)

=for hackers
Found in file regexec.c

=item is_utf8_non_invariant_string
X<is_utf8_non_invariant_string>

Returns TRUE if L<perlapi/is_utf8_invariant_string> returns FALSE for the first
C<len> bytes of the string C<s>, but they are, nonetheless, legal Perl-extended
UTF-8; otherwise returns FALSE.

A TRUE return means that at least one code point represented by the sequence
either is a wide character not representable as a single byte, or the
representation differs depending on whether the sequence is encoded in UTF-8 or
not.

See also
C<L<perlapi/is_utf8_invariant_string>>,
C<L<perlapi/is_utf8_string>>

	bool	is_utf8_non_invariant_string(const U8* const s,
		                             STRLEN len)

=for hackers
Found in file inline.h

=item report_uninit
X<report_uninit>

Print appropriate "Use of uninitialized variable" warning.

	void	report_uninit(const SV *uninit_sv)

=for hackers
Found in file sv.c

=item variant_under_utf8_count
X<variant_under_utf8_count>

This function looks at the sequence of bytes between C<s> and C<e>, which are
assumed to be encoded in ASCII/Latin1, and returns how many of them would
change should the string be translated into UTF-8.  Due to the nature of UTF-8,
each of these would occupy two bytes instead of the single one in the input
string.  Thus, this function returns the precise number of bytes the string
would expand by when translated to UTF-8.

Unlike most of the other functions that have C<utf8> in their name, the input
to this function is NOT a UTF-8-encoded string.  The function name is slightly
I<odd> to emphasize this.

This function is internal to Perl because khw thinks that any XS code that
would want this is probably operating too close to the internals.  Presenting a
valid use case could change that.

See also
C<L<perlapi/is_utf8_invariant_string>>
and
C<L<perlapi/is_utf8_invariant_string_loc>>,

	Size_t	variant_under_utf8_count(const U8* const s,
		                         const U8* const e)

=for hackers
Found in file inline.h


=back

=head1 Undocumented functions

The following functions are currently undocumented.  If you use one of
them, you may wish to consider creating and submitting documentation for
it.

=over

=item PerlIO_restore_errno
X<PerlIO_restore_errno>

=item PerlIO_save_errno
X<PerlIO_save_errno>

=item PerlLIO_dup2_cloexec
X<PerlLIO_dup2_cloexec>

=item PerlLIO_dup_cloexec
X<PerlLIO_dup_cloexec>

=item PerlLIO_open3_cloexec
X<PerlLIO_open3_cloexec>

=item PerlLIO_open_cloexec
X<PerlLIO_open_cloexec>

=item PerlProc_pipe_cloexec
X<PerlProc_pipe_cloexec>

=item PerlSock_accept_cloexec
X<PerlSock_accept_cloexec>

=item PerlSock_socket_cloexec
X<PerlSock_socket_cloexec>

=item PerlSock_socketpair_cloexec
X<PerlSock_socketpair_cloexec>

=item Slab_Alloc
X<Slab_Alloc>

=item Slab_Free
X<Slab_Free>

=item Slab_to_ro
X<Slab_to_ro>

=item Slab_to_rw
X<Slab_to_rw>

=item _add_range_to_invlist
X<_add_range_to_invlist>

=item _byte_dump_string
X<_byte_dump_string>

=item _core_swash_init
X<_core_swash_init>

=item _get_regclass_nonbitmap_data
X<_get_regclass_nonbitmap_data>

=item _get_swash_invlist
X<_get_swash_invlist>

=item _inverse_folds
X<_inverse_folds>

=item _invlistEQ
X<_invlistEQ>

=item _invlist_array_init
X<_invlist_array_init>

=item _invlist_contains_cp
X<_invlist_contains_cp>

=item _invlist_dump
X<_invlist_dump>

=item _invlist_intersection
X<_invlist_intersection>

=item _invlist_intersection_maybe_complement_2nd
X<_invlist_intersection_maybe_complement_2nd>

=item _invlist_invert
X<_invlist_invert>

=item _invlist_len
X<_invlist_len>

=item _invlist_populate_swatch
X<_invlist_populate_swatch>

=item _invlist_search
X<_invlist_search>

=item _invlist_subtract
X<_invlist_subtract>

=item _invlist_union
X<_invlist_union>

=item _invlist_union_maybe_complement_2nd
X<_invlist_union_maybe_complement_2nd>

=item _is_grapheme
X<_is_grapheme>

=item _is_in_locale_category
X<_is_in_locale_category>

=item _mem_collxfrm
X<_mem_collxfrm>

=item _new_invlist
X<_new_invlist>

=item _new_invlist_C_array
X<_new_invlist_C_array>

=item _setup_canned_invlist
X<_setup_canned_invlist>

=item _swash_to_invlist
X<_swash_to_invlist>

=item _to_fold_latin1
X<_to_fold_latin1>

=item _to_upper_title_latin1
X<_to_upper_title_latin1>

=item _warn_problematic_locale
X<_warn_problematic_locale>

=item abort_execution
X<abort_execution>

=item add_cp_to_invlist
X<add_cp_to_invlist>

=item alloc_LOGOP
X<alloc_LOGOP>

=item alloc_maybe_populate_EXACT
X<alloc_maybe_populate_EXACT>

=item allocmy
X<allocmy>

=item amagic_is_enabled
X<amagic_is_enabled>

=item append_utf8_from_native_byte
X<append_utf8_from_native_byte>

=item apply
X<apply>

=item av_extend_guts
X<av_extend_guts>

=item av_nonelem
X<av_nonelem>

=item av_reify
X<av_reify>

=item bind_match
X<bind_match>

=item boot_core_PerlIO
X<boot_core_PerlIO>

=item boot_core_UNIVERSAL
X<boot_core_UNIVERSAL>

=item boot_core_mro
X<boot_core_mro>

=item cando
X<cando>

=item check_utf8_print
X<check_utf8_print>

=item ck_anoncode
X<ck_anoncode>

=item ck_backtick
X<ck_backtick>

=item ck_bitop
X<ck_bitop>

=item ck_cmp
X<ck_cmp>

=item ck_concat
X<ck_concat>

=item ck_defined
X<ck_defined>

=item ck_delete
X<ck_delete>

=item ck_each
X<ck_each>

=item ck_entersub_args_core
X<ck_entersub_args_core>

=item ck_eof
X<ck_eof>

=item ck_eval
X<ck_eval>

=item ck_exec
X<ck_exec>

=item ck_exists
X<ck_exists>

=item ck_ftst
X<ck_ftst>

=item ck_fun
X<ck_fun>

=item ck_glob
X<ck_glob>

=item ck_grep
X<ck_grep>

=item ck_index
X<ck_index>

=item ck_join
X<ck_join>

=item ck_length
X<ck_length>

=item ck_lfun
X<ck_lfun>

=item ck_listiob
X<ck_listiob>

=item ck_match
X<ck_match>

=item ck_method
X<ck_method>

=item ck_null
X<ck_null>

=item ck_open
X<ck_open>

=item ck_prototype
X<ck_prototype>

=item ck_readline
X<ck_readline>

=item ck_refassign
X<ck_refassign>

=item ck_repeat
X<ck_repeat>

=item ck_require
X<ck_require>

=item ck_return
X<ck_return>

=item ck_rfun
X<ck_rfun>

=item ck_rvconst
X<ck_rvconst>

=item ck_sassign
X<ck_sassign>

=item ck_select
X<ck_select>

=item ck_shift
X<ck_shift>

=item ck_smartmatch
X<ck_smartmatch>

=item ck_sort
X<ck_sort>

=item ck_spair
X<ck_spair>

=item ck_split
X<ck_split>

=item ck_stringify
X<ck_stringify>

=item ck_subr
X<ck_subr>

=item ck_substr
X<ck_substr>

=item ck_svconst
X<ck_svconst>

=item ck_tell
X<ck_tell>

=item ck_trunc
X<ck_trunc>

=item closest_cop
X<closest_cop>

=item compute_EXACTish
X<compute_EXACTish>

=item coresub_op
X<coresub_op>

=item create_eval_scope
X<create_eval_scope>

=item croak_caller
X<croak_caller>

=item croak_no_mem
X<croak_no_mem>

=item croak_popstack
X<croak_popstack>

=item current_re_engine
X<current_re_engine>

=item custom_op_get_field
X<custom_op_get_field>

=item cv_ckproto_len_flags
X<cv_ckproto_len_flags>

=item cv_clone_into
X<cv_clone_into>

=item cv_const_sv_or_av
X<cv_const_sv_or_av>

=item cv_undef_flags
X<cv_undef_flags>

=item cvgv_from_hek
X<cvgv_from_hek>

=item cvgv_set
X<cvgv_set>

=item cvstash_set
X<cvstash_set>

=item deb_stack_all
X<deb_stack_all>

=item defelem_target
X<defelem_target>

=item delete_eval_scope
X<delete_eval_scope>

=item delimcpy_no_escape
X<delimcpy_no_escape>

=item die_unwind
X<die_unwind>

=item do_aexec
X<do_aexec>

=item do_aexec5
X<do_aexec5>

=item do_eof
X<do_eof>

=item do_exec
X<do_exec>

=item do_exec3
X<do_exec3>

=item do_ipcctl
X<do_ipcctl>

=item do_ipcget
X<do_ipcget>

=item do_msgrcv
X<do_msgrcv>

=item do_msgsnd
X<do_msgsnd>

=item do_ncmp
X<do_ncmp>

=item do_open6
X<do_open6>

=item do_open_raw
X<do_open_raw>

=item do_print
X<do_print>

=item do_readline
X<do_readline>

=item do_seek
X<do_seek>

=item do_semop
X<do_semop>

=item do_shmio
X<do_shmio>

=item do_sysseek
X<do_sysseek>

=item do_tell
X<do_tell>

=item do_trans
X<do_trans>

=item do_vecget
X<do_vecget>

=item do_vecset
X<do_vecset>

=item do_vop
X<do_vop>

=item does_utf8_overflow
X<does_utf8_overflow>

=item dofile
X<dofile>

=item drand48_init_r
X<drand48_init_r>

=item drand48_r
X<drand48_r>

=item dtrace_probe_call
X<dtrace_probe_call>

=item dtrace_probe_load
X<dtrace_probe_load>

=item dtrace_probe_op
X<dtrace_probe_op>

=item dtrace_probe_phase
X<dtrace_probe_phase>

=item dump_all_perl
X<dump_all_perl>

=item dump_packsubs_perl
X<dump_packsubs_perl>

=item dump_sub_perl
X<dump_sub_perl>

=item dump_sv_child
X<dump_sv_child>

=item emulate_cop_io
X<emulate_cop_io>

=item feature_is_enabled
X<feature_is_enabled>

=item find_lexical_cv
X<find_lexical_cv>

=item find_runcv_where
X<find_runcv_where>

=item find_script
X<find_script>

=item form_short_octal_warning
X<form_short_octal_warning>

=item free_tied_hv_pool
X<free_tied_hv_pool>

=item get_db_sub
X<get_db_sub>

=item get_debug_opts
X<get_debug_opts>

=item get_hash_seed
X<get_hash_seed>

=item get_invlist_iter_addr
X<get_invlist_iter_addr>

=item get_invlist_offset_addr
X<get_invlist_offset_addr>

=item get_invlist_previous_index_addr
X<get_invlist_previous_index_addr>

=item get_no_modify
X<get_no_modify>

=item get_opargs
X<get_opargs>

=item get_re_arg
X<get_re_arg>

=item getenv_len
X<getenv_len>

=item grok_atoUV
X<grok_atoUV>

=item grok_bslash_c
X<grok_bslash_c>

=item grok_bslash_o
X<grok_bslash_o>

=item grok_bslash_x
X<grok_bslash_x>

=item gv_fetchmeth_internal
X<gv_fetchmeth_internal>

=item gv_override
X<gv_override>

=item gv_setref
X<gv_setref>

=item gv_stashpvn_internal
X<gv_stashpvn_internal>

=item gv_stashsvpvn_cached
X<gv_stashsvpvn_cached>

=item handle_named_backref
X<handle_named_backref>

=item hfree_next_entry
X<hfree_next_entry>

=item hv_backreferences_p
X<hv_backreferences_p>

=item hv_kill_backrefs
X<hv_kill_backrefs>

=item hv_placeholders_p
X<hv_placeholders_p>

=item hv_pushkv
X<hv_pushkv>

=item hv_undef_flags
X<hv_undef_flags>

=item init_argv_symbols
X<init_argv_symbols>

=item init_constants
X<init_constants>

=item init_dbargs
X<init_dbargs>

=item init_debugger
X<init_debugger>

=item init_named_cv
X<init_named_cv>

=item init_uniprops
X<init_uniprops>

=item invert
X<invert>

=item invlist_array
X<invlist_array>

=item invlist_clear
X<invlist_clear>

=item invlist_clone
X<invlist_clone>

=item invlist_highest
X<invlist_highest>

=item invlist_is_iterating
X<invlist_is_iterating>

=item invlist_iterfinish
X<invlist_iterfinish>

=item invlist_iterinit
X<invlist_iterinit>

=item invlist_max
X<invlist_max>

=item invlist_previous_index
X<invlist_previous_index>

=item invlist_set_len
X<invlist_set_len>

=item invlist_set_previous_index
X<invlist_set_previous_index>

=item invlist_trim
X<invlist_trim>

=item io_close
X<io_close>

=item isFF_OVERLONG
X<isFF_OVERLONG>

=item isFOO_lc
X<isFOO_lc>

=item is_utf8_common
X<is_utf8_common>

=item is_utf8_common_with_len
X<is_utf8_common_with_len>

=item is_utf8_overlong_given_start_byte_ok
X<is_utf8_overlong_given_start_byte_ok>

=item isinfnansv
X<isinfnansv>

=item jmaybe
X<jmaybe>

=item keyword
X<keyword>

=item keyword_plugin_standard
X<keyword_plugin_standard>

=item list
X<list>

=item localize
X<localize>

=item magic_clear_all_env
X<magic_clear_all_env>

=item magic_cleararylen_p
X<magic_cleararylen_p>

=item magic_clearenv
X<magic_clearenv>

=item magic_clearisa
X<magic_clearisa>

=item magic_clearpack
X<magic_clearpack>

=item magic_clearsig
X<magic_clearsig>

=item magic_copycallchecker
X<magic_copycallchecker>

=item magic_existspack
X<magic_existspack>

=item magic_freearylen_p
X<magic_freearylen_p>

=item magic_freeovrld
X<magic_freeovrld>

=item magic_get
X<magic_get>

=item magic_getarylen
X<magic_getarylen>

=item magic_getdebugvar
X<magic_getdebugvar>

=item magic_getdefelem
X<magic_getdefelem>

=item magic_getnkeys
X<magic_getnkeys>

=item magic_getpack
X<magic_getpack>

=item magic_getpos
X<magic_getpos>

=item magic_getsig
X<magic_getsig>

=item magic_getsubstr
X<magic_getsubstr>

=item magic_gettaint
X<magic_gettaint>

=item magic_getuvar
X<magic_getuvar>

=item magic_getvec
X<magic_getvec>

=item magic_killbackrefs
X<magic_killbackrefs>

=item magic_nextpack
X<magic_nextpack>

=item magic_regdata_cnt
X<magic_regdata_cnt>

=item magic_regdatum_get
X<magic_regdatum_get>

=item magic_regdatum_set
X<magic_regdatum_set>

=item magic_scalarpack
X<magic_scalarpack>

=item magic_set
X<magic_set>

=item magic_set_all_env
X<magic_set_all_env>

=item magic_setarylen
X<magic_setarylen>

=item magic_setcollxfrm
X<magic_setcollxfrm>

=item magic_setdbline
X<magic_setdbline>

=item magic_setdebugvar
X<magic_setdebugvar>

=item magic_setdefelem
X<magic_setdefelem>

=item magic_setenv
X<magic_setenv>

=item magic_setisa
X<magic_setisa>

=item magic_setlvref
X<magic_setlvref>

=item magic_setmglob
X<magic_setmglob>

=item magic_setnkeys
X<magic_setnkeys>

=item magic_setnonelem
X<magic_setnonelem>

=item magic_setpack
X<magic_setpack>

=item magic_setpos
X<magic_setpos>

=item magic_setregexp
X<magic_setregexp>

=item magic_setsig
X<magic_setsig>

=item magic_setsubstr
X<magic_setsubstr>

=item magic_settaint
X<magic_settaint>

=item magic_setutf8
X<magic_setutf8>

=item magic_setuvar
X<magic_setuvar>

=item magic_setvec
X<magic_setvec>

=item magic_sizepack
X<magic_sizepack>

=item magic_wipepack
X<magic_wipepack>

=item malloc_good_size
X<malloc_good_size>

=item malloced_size
X<malloced_size>

=item mem_collxfrm
X<mem_collxfrm>

=item mem_log_alloc
X<mem_log_alloc>

=item mem_log_free
X<mem_log_free>

=item mem_log_realloc
X<mem_log_realloc>

=item mg_find_mglob
X<mg_find_mglob>

=item mode_from_discipline
X<mode_from_discipline>

=item more_bodies
X<more_bodies>

=item mro_meta_dup
X<mro_meta_dup>

=item mro_meta_init
X<mro_meta_init>

=item multiconcat_stringify
X<multiconcat_stringify>

=item multideref_stringify
X<multideref_stringify>

=item my_attrs
X<my_attrs>

=item my_clearenv
X<my_clearenv>

=item my_lstat_flags
X<my_lstat_flags>

=item my_memrchr
X<my_memrchr>

=item my_mkostemp
X<my_mkostemp>

=item my_mkstemp
X<my_mkstemp>

=item my_mkstemp_cloexec
X<my_mkstemp_cloexec>

=item my_stat_flags
X<my_stat_flags>

=item my_strerror
X<my_strerror>

=item my_unexec
X<my_unexec>

=item newGP
X<newGP>

=item newMETHOP_internal
X<newMETHOP_internal>

=item newSTUB
X<newSTUB>

=item newSVavdefelem
X<newSVavdefelem>

=item newXS_deffile
X<newXS_deffile>

=item new_warnings_bitfield
X<new_warnings_bitfield>

=item nextargv
X<nextargv>

=item noperl_die
X<noperl_die>

=item notify_parser_that_changed_to_utf8
X<notify_parser_that_changed_to_utf8>

=item oopsAV
X<oopsAV>

=item oopsHV
X<oopsHV>

=item op_clear
X<op_clear>

=item op_integerize
X<op_integerize>

=item op_lvalue_flags
X<op_lvalue_flags>

=item op_refcnt_dec
X<op_refcnt_dec>

=item op_refcnt_inc
X<op_refcnt_inc>

=item op_relocate_sv
X<op_relocate_sv>

=item op_std_init
X<op_std_init>

=item op_unscope
X<op_unscope>

=item opmethod_stash
X<opmethod_stash>

=item opslab_force_free
X<opslab_force_free>

=item opslab_free
X<opslab_free>

=item opslab_free_nopad
X<opslab_free_nopad>

=item package
X<package>

=item package_version
X<package_version>

=item pad_add_weakref
X<pad_add_weakref>

=item padlist_store
X<padlist_store>

=item padname_free
X<padname_free>

=item padnamelist_free
X<padnamelist_free>

=item parse_unicode_opts
X<parse_unicode_opts>

=item parse_uniprop_string
X<parse_uniprop_string>

=item parser_free
X<parser_free>

=item parser_free_nexttoke_ops
X<parser_free_nexttoke_ops>

=item path_is_searchable
X<path_is_searchable>

=item peep
X<peep>

=item pmruntime
X<pmruntime>

=item populate_isa
X<populate_isa>

=item ptr_hash
X<ptr_hash>

=item qerror
X<qerror>

=item re_exec_indentf
X<re_exec_indentf>

=item re_indentf
X<re_indentf>

=item re_op_compile
X<re_op_compile>

=item re_printf
X<re_printf>

=item reg_named_buff
X<reg_named_buff>

=item reg_named_buff_iter
X<reg_named_buff_iter>

=item reg_numbered_buff_fetch
X<reg_numbered_buff_fetch>

=item reg_numbered_buff_length
X<reg_numbered_buff_length>

=item reg_numbered_buff_store
X<reg_numbered_buff_store>

=item reg_qr_package
X<reg_qr_package>

=item reg_skipcomment
X<reg_skipcomment>

=item reg_temp_copy
X<reg_temp_copy>

=item regcurly
X<regcurly>

=item regprop
X<regprop>

=item report_evil_fh
X<report_evil_fh>

=item report_redefined_cv
X<report_redefined_cv>

=item report_wrongway_fh
X<report_wrongway_fh>

=item rpeep
X<rpeep>

=item rsignal_restore
X<rsignal_restore>

=item rsignal_save
X<rsignal_save>

=item rxres_save
X<rxres_save>

=item same_dirent
X<same_dirent>

=item save_strlen
X<save_strlen>

=item save_to_buffer
X<save_to_buffer>

=item sawparens
X<sawparens>

=item scalar
X<scalar>

=item scalarvoid
X<scalarvoid>

=item set_caret_X
X<set_caret_X>

=item set_numeric_standard
X<set_numeric_standard>

=item set_numeric_underlying
X<set_numeric_underlying>

=item set_padlist
X<set_padlist>

=item setfd_cloexec
X<setfd_cloexec>

=item setfd_cloexec_for_nonsysfd
X<setfd_cloexec_for_nonsysfd>

=item setfd_cloexec_or_inhexec_by_sysfdness
X<setfd_cloexec_or_inhexec_by_sysfdness>

=item setfd_inhexec
X<setfd_inhexec>

=item setfd_inhexec_for_sysfd
X<setfd_inhexec_for_sysfd>

=item should_warn_nl
X<should_warn_nl>

=item sighandler
X<sighandler>

=item softref2xv
X<softref2xv>

=item ssc_add_range
X<ssc_add_range>

=item ssc_clear_locale
X<ssc_clear_locale>

=item ssc_cp_and
X<ssc_cp_and>

=item ssc_intersection
X<ssc_intersection>

=item ssc_union
X<ssc_union>

=item sub_crush_depth
X<sub_crush_depth>

=item sv_add_backref
X<sv_add_backref>

=item sv_buf_to_ro
X<sv_buf_to_ro>

=item sv_del_backref
X<sv_del_backref>

=item sv_free2
X<sv_free2>

=item sv_kill_backrefs
X<sv_kill_backrefs>

=item sv_len_utf8_nomg
X<sv_len_utf8_nomg>

=item sv_magicext_mglob
X<sv_magicext_mglob>

=item sv_mortalcopy_flags
X<sv_mortalcopy_flags>

=item sv_only_taint_gmagic
X<sv_only_taint_gmagic>

=item sv_or_pv_pos_u2b
X<sv_or_pv_pos_u2b>

=item sv_resetpvn
X<sv_resetpvn>

=item sv_sethek
X<sv_sethek>

=item sv_setsv_cow
X<sv_setsv_cow>

=item sv_unglob
X<sv_unglob>

=item swash_fetch
X<swash_fetch>

=item swash_init
X<swash_init>

=item tied_method
X<tied_method>

=item tmps_grow_p
X<tmps_grow_p>

=item translate_substr_offsets
X<translate_substr_offsets>

=item try_amagic_bin
X<try_amagic_bin>

=item try_amagic_un
X<try_amagic_un>

=item unshare_hek
X<unshare_hek>

=item utf16_to_utf8
X<utf16_to_utf8>

=item utf16_to_utf8_reversed
X<utf16_to_utf8_reversed>

=item utilize
X<utilize>

=item varname
X<varname>

=item vivify_defelem
X<vivify_defelem>

=item vivify_ref
X<vivify_ref>

=item wait4pid
X<wait4pid>

=item was_lvalue_sub
X<was_lvalue_sub>

=item watch
X<watch>

=item win32_croak_not_implemented
X<win32_croak_not_implemented>

=item write_to_stderr
X<write_to_stderr>

=item xs_boot_epilog
X<xs_boot_epilog>

=item xs_handshake
X<xs_handshake>

=item yyerror
X<yyerror>

=item yyerror_pv
X<yyerror_pv>

=item yyerror_pvn
X<yyerror_pvn>

=item yylex
X<yylex>

=item yyparse
X<yyparse>

=item yyquit
X<yyquit>

=item yyunlex
X<yyunlex>

=back


=head1 AUTHORS

The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl.  Documentation is by whoever was kind enough to
document their functions.

=head1 SEE ALSO

L<perlguts>, L<perlapi>

=cut

ex: set ro:

Statistics:
	COMMENTS: 51462 occurrences
	CODE: 23081 occurrences
	LITERALS: 11536 occurrences
================================
Token types mappings:
	Perl5: ARRAY_NAME: CODE
	Perl5: BLOCK_NAME: CODE
	Perl5: COMMENT_LINE: COMMENTS
	Perl5: GLOB_NAME: CODE
	Perl5: HANDLE: CODE
	Perl5: HASH_NAME: CODE
	Perl5: HEREDOC_END: CODE
	Perl5: IDENTIFIER: CODE
	Perl5: SCALAR_NAME: CODE
	Perl5: STRING_CONTENT: LITERALS
	Perl5: STRING_CONTENT_QQ: LITERALS
	Perl5: STRING_CONTENT_XQ: LITERALS
	Perl5: package::name: CODE
	Perl5: package::name::: CODE
	Perl5: subname: CODE
================================
Tokens by type:
	CODE
		is_if_elsif_else_unless_while_until_for_foreach
		is_static_block_comment_without_leading_space
		make_block_brace_vertical_tightness_pattern
		is_if_unless_and_or_last_next_redo_return
		rOpts_break_at_old_attribute_breakpoints
		rOpts_closing_side_comment_maximum_text
		unmatched_closing_indexes_in_this_batch
		unmatched_opening_indexes_in_this_batch
		block_brace_vertical_tightness_pattern
		make_closing_side_comment_list_pattern
		rOpts_break_at_old_keyword_breakpoints
		rOpts_break_at_old_logical_breakpoints
		rOpts_break_at_old_ternary_breakpoints
		find_next_nonblank_token_on_this_line
		permanently_decrease_AVAILABLE_SPACES
		rOpts_short_concatenation_item_length
		semicolons_before_block_self_destruct
		tentatively_decrease_AVAILABLE_SPACES
		is_keyword_with_special_leading_term
		last_vertical_alignment_before_index
		peek_ahead_for_n_nonblank_pre_tokens
		rOpts_block_brace_vertical_tightness
		rOpts_break_at_old_comma_breakpoints
		rOpts_closing_side_comment_else_flag
		closing_side_comment_prefix_pattern
		is_not_zero_continuation_block_type
		leading_block_text_length_exceeded
		ok_to_add_semicolon_for_block_type
		previous_outdentable_closing_paren
		rOpts_variable_maximum_line_length
		started_looking_for_here_target_at
		closing_side_comment_list_pattern
		last_last_nonblank_container_type
		make_static_block_comment_pattern
		rOpts_fixed_position_side_comment
		rOpts_ignore_side_comment_lengths
		this_line_is_semicolon_terminated
		FORMATTER_DEBUG_FLAG_BOND_TABLES
		continuation_string_in_tokenizer
		improve_continuation_indentation
		last_last_nonblank_type_sequence
		make_closing_side_comment_prefix
		make_static_side_comment_pattern
		match_opening_and_closing_tokens
		reduce_valign_buffer_indentation
		cached_line_leading_space_count
		extra_indentation_spaces_wanted
		find_angle_operator_termination
		find_starting_indentation_level
		guess_if_pattern_or_conditional
		intervening_secondary_structure
		is_zero_continuation_block_type
		last_output_short_opening_token
		rOpts_stack_closing_block_brace
		FORMATTER_DEBUG_FLAG_RECOMBINE
		check_for_long_gnu_style_lines
		get_consecutive_nonblank_lines
		last_last_nonblank_index_to_go
		last_last_nonblank_token_to_go
		leading_block_text_line_length
		leading_block_text_line_number
		rOpts_continuation_indentation
		rOpts_entab_leading_whitespace
		rOpts_keep_interior_semicolons
		rOpts_maximum_fields_per_table
		rOpts_minimum_space_to_comment
		send_lines_to_vertical_aligner
		set_vertical_alignment_markers
		some_closing_token_indentation
		square_bracket_structural_type
		starting_line_of_current_depth
		TOKENIZER_DEBUG_FLAG_TOKENIZE
		format_skipping_pattern_begin
		get_rvertical_tightness_flags
		is_vertical_alignment_keyword
		last_last_nonblank_block_type
		last_last_nonblank_type_to_go
		last_side_comment_line_number
		maximum_line_length_for_level
		nearly_matched_here_target_at
		opening_structure_index_stack
		peek_ahead_for_nonblank_token
		rOpts_comma_arrow_breakpoints
		reset_consecutive_blank_lines
		set_for_semicolon_breakpoints
		vert_last_nonblank_block_type
		FORMATTER_DEBUG_FLAG_NOBREAK
		TOKENIZER_DEBUG_FLAG_SCAN_ID
		decrement_output_line_number
		expand_command_abbreviations
		forced_breakpoint_undo_count
		forced_breakpoint_undo_stack
		get_available_space_on_right
		guess_if_pattern_or_division
		is_anon_sub_1_brace_follower
		is_simple_logical_expression
		last_last_line_leading_level
		last_nonblank_container_type
		make_format_skipping_pattern
		make_line_information_string
		rOpts_ignore_old_breakpoints
		rOpts_tight_secret_operators
		rblock_leading_if_elsif_text
		reset_block_text_accumulator
		rleading_block_if_elsif_text
		set_vertical_tightness_flags
		static_block_comment_pattern
		structural_indentation_level
		undo_forced_breakpoint_stack
		FORMATTER_DEBUG_FLAG_OUTPUT
		FORMATTER_DEBUG_FLAG_SPARSE
		FORMATTER_DEBUG_FLAG_UNDOBP
		TOKENIZER_DEBUG_FLAG_EXPECT
		accumulating_text_for_block
		check_for_new_minimum_depth
		clear_breakpoint_undo_stack
		comma_arrow_count_contained
		comment_leading_space_count
		container_environment_to_go
		do_uncontained_comma_breaks
		error_if_expecting_OPERATOR
		format_skipping_pattern_end
		get_is_hanging_side_comment
		guess_old_indentation_level
		has_old_logical_breakpoints
		increase_RECOVERABLE_SPACES
		last_nonblank_type_sequence
		last_unadjusted_indentation
		prepare_for_new_input_lines
		rOpts_block_brace_tightness
		rOpts_brace_left_and_indent
		rOpts_delete_old_whitespace
		set_is_hanging_side_comment
		static_side_comment_pattern
		FORMATTER_DEBUG_FLAG_BREAK
		FORMATTER_DEBUG_FLAG_FLUSH
		FORMATTER_DEBUG_FLAG_FORCE
		FORMATTER_DEBUG_FLAG_STORE
		FORMATTER_DEBUG_FLAG_WHITE
		TOKENIZER_DEBUG_FLAG_NSCAN
		TOKENIZER_DEBUG_FLAG_QUOTE
		check_final_nesting_depths
		closing_vertical_tightness
		compare_indentation_levels
		consecutive_block_comments
		default_adjust_indentation
		first_deleted_semicolon_at
		first_line_length_error_at
		first_tabbing_disagreement
		get_AVAILABLE_SPACES_to_go
		in_format_skipping_section
		index_start_one_line_block
		initialize_tokenizer_state
		is_anon_sub_brace_follower
		is_block_without_semicolon
		is_good_keyword_breakpoint
		is_terminal_alignment_type
		is_vertical_alignment_type
		last_colon_sequence_number
		last_line_had_side_comment
		last_nonblank_seqno_string
		logical_continuation_lines
		lookup_opening_indentation
		old_breakpoint_count_stack
		opening_vertical_tightness
		previous_maximum_jmax_seen
		previous_minimum_jmax_seen
		process_command_line_cache
		rOpts_keep_old_blank_lines
		rOpts_space_function_paren
		report_tokenization_errors
		secret_operator_whitespace
		set_block_text_accumulator
		tabbing_disagreement_count
		write_error_indicator_pair
		FORMATTER_DEBUG_FLAG_BOND
		FORMATTER_DEBUG_FLAG_LIST
		RVERTICAL_TIGHTNESS_FLAGS
		VALIGN_DEBUG_FLAG_APPEND0
		VALIGN_DEBUG_FLAG_TERNARY
		block_opening_line_number
		closing_token_indentation
		decrease_AVAILABLE_SPACES
		forbidden_file_extensions
		get_added_semicolon_count
		get_maximum_fields_wanted
		guessed_indentation_level
		in_prototype_or_signature
		in_statement_continuation
		is_keyword_returning_list
		is_matching_terminal_line
		is_q_qq_qw_qx_qr_s_y_tr_m
		last_deleted_semicolon_at
		last_line_length_error_at
		last_nonblank_index_to_go
		last_nonblank_token_to_go
		last_old_breakpoint_count
		last_tabbing_disagreement
		max_output_line_length_at
		must_break_open_container
		rOpts_line_up_parentheses
		rOpts_maximum_line_length
		rOpts_space_keyword_paren
		report_line_length_errors
		restore_alignment_columns
		rvertical_tightness_flags
		saved_opening_indentation
		starting_breakpoint_count
		VALIGN_DEBUG_FLAG_APPEND
		add_closing_side_comment
		expecting_operator_token
		expecting_operator_types
		find_next_nonblank_token
		find_token_starting_list
		first_added_semicolon_at
		get_extra_leading_spaces
		get_stream_as_named_file
		initialize_for_new_group
		insert_additional_breaks
		is_indirect_object_taker
		is_last_next_redo_return
		is_sort_map_grep_eval_do
		is_unbreakable_container
		last_indentation_written
		last_last_nonblank_token
		last_leading_space_count
		last_nonblank_block_type
		last_nonblank_type_to_go
		last_side_comment_length
		leading_block_text_level
		leading_whitespace_count
		max_line_length_error_at
		maximum_number_of_fields
		next_nonblank_block_type
		next_nonblank_token_type
		operator_requestor_types
		rOpts_character_encoding
		require_blank_code_lines
		rpending_logfile_message
		save_opening_indentation
		saw_VERSION_in_this_file
		set_adjusted_indentation
		set_comma_breakpoints_do
		vert_last_nonblank_token
		want_previous_breakpoint
		FORMATTER_DEBUG_FLAG_CI
		IS_HANGING_SIDE_COMMENT
		TYPE_SEQUENCE_INCREMENT
		actual_output_extension
		allowed_quote_modifiers
		ask_user_for_bug_report
		continuation_line_count
		convergence_log_message
		current_sequence_number
		deleted_semicolon_count
		error_if_expecting_TERM
		first_line_length_error
		first_outdented_line_at
		first_side_comment_line
		forced_breakpoint_count
		forced_breakpoint_to_go
		forced_indentation_flag
		get_leading_space_count
		get_opening_indentation
		in_tabbing_disagreement
		is_blocktype_with_paren
		is_essential_whitespace
		is_hanging_side_comment
		is_isolated_block_brace
		is_leading_secret_token
		is_non_structural_brace
		is_other_brace_follower
		is_semicolon_terminated
		is_static_block_comment
		last_added_semicolon_at
		last_input_line_written
		last_last_nonblank_type
		last_line_leading_level
		last_nonblank_prototype
		last_output_indentation
		last_side_comment_level
		leading_alignment_token
		line_information_string
		line_length_error_count
		make_alignment_patterns
		maximum_alignment_index
		nesting_sequence_number
		new_lp_indentation_item
		nonblank_lines_at_depth
		old_line_count_in_batch
		previous_nonblank_token
		rOpts_fuzzy_line_length
		report_anything_unusual
		reset_indentation_level
		restore_tokenizer_state
		saw_function_definition
		scan_bare_identifier_do
		set_continuation_breaks
		set_leading_space_count
		set_logical_breakpoints
		set_non_alignment_flags
		starting_one_line_block
		table_columns_available
		test_csc_prefix_pattern
		use_separate_first_term
		user_function_prototype
		vert_last_nonblank_type
		vertical_aligner_object
		we_are_at_the_last_line
		VALIGN_DEBUG_FLAG_TABS
		break_all_chain_tokens
		ci_string_in_tokenizer
		correct_lp_indentation
		decrease_nesting_depth
		default_file_extension
		destroy_one_line_block
		find_input_line_ending
		first_line_comma_count
		get_RECOVERABLE_SPACES
		get_jmax_original_line
		get_outdent_long_lines
		get_output_line_number
		gnu_position_predictor
		i_effective_last_comma
		i_lowest_next_nonblank
		i_old_assignment_break
		identifier_count_stack
		increase_nesting_depth
		index_max_forced_break
		input_file_permissions
		insert_new_token_to_go
		is_block_list_function
		is_else_brace_follower
		is_keyword_taking_list
		is_redo_last_next_goto
		last_line_leading_type
		last_line_length_error
		last_outdented_line_at
		leading_alignment_type
		line_start_index_to_go
		make_abbreviated_names
		make_getopt_long_names
		max_output_line_length
		nesting_block_string_i
		nesting_token_string_i
		note_deleted_semicolon
		prepare_for_a_new_file
		quoted_stream_filename
		rOpts_whitespace_cycle
		rcontainer_environment
		really_open_debug_file
		reconstructed_original
		routput_container_type
		save_alignment_columns
		set_RECOVERABLE_SPACES
		set_closing_breakpoint
		set_default_properties
		set_jmax_original_line
		set_leading_whitespace
		set_outdent_long_lines
		set_ragged_breakpoints
		whitespace_level_stack
		write_style_sheet_data
		write_style_sheet_file
		_process_command_line
		accumulate_block_text
		added_semicolon_count
		brace_structural_type
		breakpoint_undo_stack
		col_matching_terminal
		container_environment
		create_one_line_block
		debugger_object_final
		dump_options_category
		dump_want_right_space
		first_embedded_tab_at
		get_indentation_level
		get_input_line_number
		has_comma_breakpoints
		i_last_nonblank_token
		increment_brace_error
		is_file_test_operator
		is_sort_map_grep_eval
		is_terminal_statement
		is_vertically_aligned
		j_tight_closing_paren
		max_line_length_error
		missing_html_entities
		multiple_comma_arrows
		nested_statement_type
		nesting_list_string_i
		nesting_type_string_i
		new_matching_patterns
		number_of_fields_best
		old_comma_break_count
		paren_semicolon_count
		paren_structural_type
		rOpts_format_skipping
		recombine_breakpoints
		reduce_lp_indentation
		restore_current_token
		routput_type_sequence
		saw_opening_structure
		scan_replacement_text
		set_comma_breakpoints
		set_forced_breakpoint
		study_list_complexity
		token_sequence_length
		total_depth_variation
		valign_buffer_filling
		vertical_aligner_self
		whitespace_last_level
		write_blank_code_line
		write_column_headings
		write_unindented_line
		allow_quote_comments
		binary_bond_strength
		comma_count_in_batch
		copy_old_breakpoints
		csc_new_statement_ok
		decide_if_code_block
		dump_want_left_space
		eliminate_new_fields
		eliminate_old_fields
		ending_in_quote_last
		expecting_term_token
		expecting_term_types
		extra_leading_spaces
		fix_terminal_ternary
		follow_quoted_string
		get_AVAILABLE_SPACES
		here_quote_character
		i_block_leading_text
		i_next_next_nonblank
		in_hierarchical_list
		increase_field_width
		input_line_separator
		inverse_pretoken_map
		is_VERSION_statement
		is_if_brace_follower
		is_logical_container
		join_hanging_comment
		keyword_on_same_line
		last_diagnostic_file
		last_embedded_tab_at
		leading_spaces_to_go
		leading_string_cache
		lower_case_labels_at
		matches_without_bang
		matching_start_token
		matching_token_to_go
		max_allowed_sparsity
		nesting_block_string
		nesting_blocks_to_go
		nesting_token_string
		new_identifier_count
		no_internal_newlines
		note_added_semicolon
		number_of_fields_max
		old_breakpoint_count
		old_breakpoint_to_go
		outdented_line_count
		postponed_breakpoint
		print_line_of_tokens
		process_command_line
		rOpts_add_whitespace
		rOpts_indent_columns
		rconfig_file_chatter
		really_open_tee_file
		reduced_spaces_to_go
		ri_ragged_break_list
		save_tokenizer_state
		scan_bare_identifier
		set_white_space_flag
		side_comment_follows
		side_comment_history
		square_bracket_depth
		starting_field_width
		summed_lengths_to_go
		untrimmed_input_line
		valign_output_step_A
		valign_output_step_B
		valign_output_step_C
		valign_output_step_D
		value_requestor_type
		write_logfile_header
		BRACE_WARNING_LIMIT
		LEADING_SPACE_COUNT
		MAXIMUM_LINE_LENGTH
		accumulate_csc_text
		adjust_side_comment
		bond_strength_to_go
		cached_seqno_string
		change_anchor_names
		closing_brace_names
		columns_if_unbroken
		current_field_width
		do_convergence_test
		file_test_operators
		forget_side_comment
		get_SEQUENCE_NUMBER
		get_saw_brace_error
		get_starting_column
		gnu_sequence_number
		group_leader_length
		has_leading_op_next
		i_ragged_break_list
		id_scan_state_begin
		insert_final_breaks
		interior_chain_type
		is_code_block_token
		is_simple_last_term
		is_simple_next_term
		is_terminal_ternary
		is_unbalanced_batch
		is_valid_token_type
		keyword_taking_list
		last_break_strength
		last_comment_column
		last_nonblank_token
		leading_space_count
		logger_object_final
		markup_html_element
		max_gnu_stack_index
		maximum_field_index
		maximum_line_length
		min_gnu_indentation
		nested_ternary_flag
		nesting_depth_to_go
		nesting_list_string
		nesting_type_string
		new_matching_tokens
		next_nonblank_token
		opening_brace_names
		opening_environment
		opening_indentation
		opening_token_right
		rdo_not_break_apart
		report_definite_bug
		report_possible_bug
		rfor_semicolon_list
		right_bond_strength
		routput_indent_flag
		saw_good_breakpoint
		set_fake_breakpoint
		set_logical_padding
		set_starting_column
		short_to_long_names
		side_comment_column
		side_comment_length
		slevel_in_tokenizer
		space_after_keyword
		square_bracket_type
		stack_closing_token
		stack_opening_token
		stripped_block_type
		terminal_block_type
		token_lengths_to_go
		total_nesting_depth
		type_sequence_to_go
		unstore_token_to_go
		write_logfile_entry
		JMAX_ORIGINAL_LINE
		OUTDENT_LONG_LINES
		RECOVERABLE_SPACES
		adjust_indentation
		block_leading_text
		check_vms_filename
		complex_item_count
		csc_prefix_pattern
		cscw_block_comment
		definitely_complex
		destination_stream
		diagnostics_object
		do_not_break_apart
		dump_abbreviations
		dump_options_range
		dump_valign_buffer
		embedded_tab_count
		excess_line_length
		exists_config_file
		field_width_growth
		file_writer_object
		get_STARTING_INDEX
		get_leading_string
		get_matching_token
		has_broken_sublist
		html_src_extension
		html_toc_extension
		in_continued_quote
		index_before_arrow
		input_line_tabbing
		is_format_END_DATA
		is_unaligned_colon
		jmax_original_line
		last_leading_token
		last_level_written
		last_nonblank_type
		leading_block_text
		left_bond_strength
		level_in_tokenizer
		line_buffer_object
		line_source_object
		make_block_pattern
		make_else_csc_text
		make_numbered_line
		matching_end_token
		max_gnu_item_index
		maximum_line_index
		need_lp_break_open
		nesting_block_flag
		nesting_string_new
		next_nonblank_type
		numerator_expected
		opening_brace_line
		operator_requestor
		outdent_long_lines
		output_line_number
		rOpts_add_newlines
		rOpts_cuddled_else
		routput_block_type
		routput_token_list
		routput_token_type
		rpending_complaint
		save_current_token
		saw_good_alignment
		saw_ignore_profile
		scan_identifier_do
		set_bond_strengths
		set_matching_token
		standard_increment
		start_package_list
		tabulated_bond_str
		tokenize_this_line
		unblock_log_output
		write_on_underline
		cached_line_valid
		close_output_file
		comma_arrow_count
		decide_if_aligned
		definitely_simple
		dump_getopt_flags
		dump_options_type
		error_redirection
		find_file_upwards
		finish_formatting
		first_term_length
		fix_terminal_else
		forced_breakpoint
		formatted_columns
		get_serial_number
		get_starting_line
		get_warning_count
		group_maximum_gap
		guess_if_here_doc
		have_side_comment
		here_doc_expected
		i_last_last_break
		i_true_last_comma
		in_attribute_list
		in_quote_starting
		in_same_container
		indentation_count
		indented_if_level
		input_line_ending
		input_line_number
		interrupt_logfile
		is_binary_keyword
		is_block_function
		is_block_operator
		is_chain_operator
		is_good_alignment
		is_one_line_block
		is_outdented_line
		last_leading_type
		last_output_level
		leading_amp_count
		lowest_next_token
		make_side_comment
		max_skipped_count
		max_tokens_wanted
		max_valign_buffer
		maximum_jmax_seen
		minimum_jmax_seen
		missing_file_spec
		nesting_list_flag
		new_trailing_dots
		note_embedded_tab
		operator_expected
		output_line_to_go
		padding_available
		perltidyrc_stream
		postfilter_buffer
		process_this_file
		rhere_target_list
		rindentation_list
		rlookahead_buffer
		rpre_string_stack
		rwhite_space_flag
		saw_opening_paren
		set_default_color
		set_starting_line
		sink_object_final
		spaces_both_sides
		spaces_right_side
		starting_in_quote
		store_token_to_go
		token_short_names
		tokenization_code
		total_line_length
		total_variation_1
		total_variation_2
		valid_token_types
		want_break_before
		want_right_spaces
		write_debug_entry
		write_diagnostics
		AVAILABLE_SPACES
		DUMP_BREAKPOINTS
		MAX_NAG_MESSAGES
		_decrement_count
		_increment_count
		available_spaces
		backup_extension
		balance_csc_text
		block_line_count
		block_log_output
		block_type_to_go
		breakpoint_stack
		cached_line_flag
		cached_line_text
		cached_line_type
		candidate_target
		close_debug_file
		close_input_file
		columns_per_line
		compactify_table
		current_ci_level
		dump_config_file
		dump_short_names
		dump_token_types
		end_package_list
		endings_inverted
		errorfile_stream
		find_config_file
		generate_options
		html_file_opened
		identifier_begin
		identifier_count
		increment_column
		infile_syntax_ok
		interrupted_list
		is_block_comment
		is_closing_BLOCK
		is_closing_token
		is_opening_BLOCK
		is_opening_token
		is_sort_grep_map
		is_sort_map_grep
		is_user_function
		istream_filename
		item_count_stack
		j_terminal_match
		last_comma_index
		last_item_length
		line_sink_object
		line_start_quote
		look_for_Windows
		looking_for_else
		lowest_next_type
		make_bli_pattern
		mate_index_to_go
		new_statement_ok
		number_of_fields
		ostream_filename
		output_extension
		output_file_open
		pattern_expected
		pre_string_stack
		read_config_file
		readable_options
		really_want_term
		replacement_text
		right_chain_type
		roption_category
		saw_END_or_DATA_
		saw_dump_profile
		secret_operators
		spaces_left_side
		special_keywords
		want_comma_break
		want_right_space
		white_space_flag
		write_frame_html
		HERE_DOC_WINDOW
		IndentationItem
		SEQUENCE_NUMBER
		STARTING_COLUMN
		UNDEFINED_INDEX
		UNKNOWN_CONTEXT
		VerticalAligner
		Win_Config_Locs
		alignment_token
		available_space
		beginning_token
		binary_ws_rules
		bli_list_string
		check_prototype
		ci_levels_to_go
		close_html_file
		code_block_type
		colons_in_order
		csc_block_label
		current_package
		current_pattern
		debugger_object
		decrease_SPACES
		divide_expected
		do_scan_package
		do_syntax_check
		dump_alignments
		dump_long_names
		encode_entities
		ending_in_quote
		extra_indent_ok
		finish_lp_batch
		formatted_lines
		get_ALIGN_PAREN
		get_ARROW_COUNT
		get_COMMA_COUNT
		get_STACK_DEPTH
		get_ending_line
		get_indentation
		gnu_arrow_count
		gnu_comma_count
		group_list_type
		here_doc_target
		i_closing_paren
		i_next_nonblank
		i_opening_minus
		i_opening_paren
		in_place_modify
		is_closing_type
		is_forced_break
		is_opening_type
		last_block_type
		last_elsif_text
		last_gnu_equals
		last_nonblank_i
		left_chain_type
		long_first_term
		lowest_strength
		max_index_to_go
		max_token_index
		must_break_open
		new_line_length
		not_first_token
		number_of_files
		option_category
		outdent_keyword
		pad_array_to_go
		quote_character
		quote_modifiers
		quoted_string_1
		quoted_string_2
		ralignment_list
		rbrace_follower
		rcolored_tokens
		rcontainer_type
		report_v_string
		rin_toc_package
		rnesting_blocks
		rnesting_tokens
		rtoc_item_count
		rtoc_name_count
		saw_brace_error
		saw_indentation
		scan_identifier
		set_ARROW_COUNT
		set_COMMA_COUNT
		set_ending_line
		set_indentation
		spaces_wanted_2
		starting_column
		stream_filename
		test_csc_prefix
		total_pad_count
		value_requestor
		want_blank_line
		want_left_space
		weighted_length
		write_code_line
		ConfigDefaults
		MATCHING_TOKEN
		QUESTION_COLON
		SCALAR_CONTEXT
		SQUARE_BRACKET
		STARTING_INDEX
		alignment_type
		bias_table_key
		block_type_map
		close_tee_file
		colored_tokens
		combine_fields
		container_name
		container_type
		csc_last_label
		decide_if_list
		deleted_spaces
		depth_question
		dump_functions
		fileglob_to_re
		first_length_2
		formatter_self
		frame_filename
		get_HAVE_CHILD
		get_alignments
		get_use_prefix
		has_leading_op
		i_colon_breaks
		ibeg_next_next
		in_toc_package
		indent_columns
		indicate_error
		is_binary_type
		is_colon_chain
		is_do_follower
		is_for_foreach
		is_lt_gt_le_ge
		is_short_quote
		is_sub_package
		is_use_require
		last_dot_index
		last_line_type
		leading_spaces
		leading_string
		line_character
		line_of_dashes
		line_of_tokens
		line_separator
		logfile_output
		logfile_stream
		long_last_term
		make_alignment
		make_extension
		marginal_match
		matching_token
		max_iterations
		nesting_blocks
		nesting_string
		nesting_tokens
		new_alignments
		next_next_type
		opening_exists
		opening_offset
		options_string
		packed_columns
		padding_so_far
		precedes_colon
		restore_column
		resume_logfile
		rif_elsif_text
		roption_string
		rpackage_stack
		rpretoken_type
		rtype_sequence
		saw_chain_type
		saw_good_break
		saw_modifier_e
		scan_number_do
		set_HAVE_CHILD
		set_alignments
		set_input_file
		src_frame_name
		starting_depth
		starting_index
		starting_level
		statement_type
		tightness_flag
		toc_item_count
		token_beg_next
		tokenizer_self
		unused_columns
		user_formatter
		write_toc_html
		IOScalarArray
		MediumOrchid3
		SERIAL_NUMBER
		STARTING_LINE
		WARNING_LIMIT
		_default_data
		all_operators
		beginning_tok
		brace_context
		brace_package
		brace_warning
		caller_is_obj
		category_name
		check_options
		ci_start_plus
		ci_string_sum
		closing_index
		closing_token
		current_depth
		current_field
		current_level
		death_message
		debug_warning
		delete_backup
		dump_defaults
		existing_name
		extract_token
		find_here_doc
		fname_comment
		follows_colon
		get_alignment
		get_list_type
		get_rpatterns
		gnu_item_list
		html_filename
		i_break_right
		i_first_colon
		i_first_comma
		id_scan_state
		in_comma_list
		indentation_1
		indentation_2
		indentation_t
		is_assignment
		is_blank_line
		is_plus_minus
		j_first_break
		last_length_2
		leading_token
		logger_object
		markup_tokens
		matching_char
		max_pretokens
		minimum_depth
		nesting_lists
		nesting_types
		nobreak_to_go
		numbered_line
		old_rpatterns
		open_or_close
		opening_token
		option_string
		package_saved
		predicted_pos
		quoted_string
		rGetopt_flags
		rgetopt_names
		ri_break_list
		ri_term_begin
		ri_term_comma
		rinput_buffer
		ritem_lengths
		roption_range
		routput_array
		rpatterns_old
		rpretoken_map
		rslevel_stack
		rtoken_length
		set_alignment
		set_list_type
		set_rpatterns
		skipped_count
		source_object
		source_stream
		spaces_needed
		spaces_wanted
		starting_line
		stderr_stream
		strip_comment
		subname_saved
		terminal_type
		test_position
		tok_next_next
		tokens_differ
		total_columns
		type_sequence
		valign_buffer
		warning_count
		DeepSkyBlue4
		GetOSVersion
		Getopt_flags
		LIST_CONTEXT
		SAVED_COLUMN
		Windows_type
		abbrev_count
		add_to_group
		add_toc_item
		added_length
		break_before
		break_equals
		buffer_index
		cached_seqno
		check_syntax
		css_filename
		css_linkname
		current_line
		do_not_align
		dump_options
		first_anchor
		found_target
		get_CI_LEVEL
		get_hash_ref
		i_break_left
		i_last_break
		i_last_comma
		i_line_start
		i_term_begin
		i_term_comma
		is_if_unless
		is_long_line
		is_long_term
		is_outdented
		item_lengths
		leading_type
		level_change
		levels_to_go
		old_ci_level
		option_range
		packed_lines
		peeked_ahead
		pre_bg_color
		pre_tokenize
		quote_target
		rOpts_valign
		rand_or_list
		rcomma_index
		rconfig_list
		right_margin
		rraw_options
		save_logfile
		saw_body_end
		saw_code_bug
		seqno_string
		set_nobreaks
		show_version
		small_length
		src_basename
		src_filename
		starting_sum
		streamhandle
		success_flag
		toc_basename
		toc_filename
		token_length
		tokens_match
		tokens_to_go
		top_basename
		valign_input
		warning_file
		ALIGN_PAREN
		ARROW_COUNT
		COMMA_COUNT
		DIAGNOSTICS
		Diagnostics
		ENDING_LINE
		END_OF_LIST
		ForestGreen
		INDENTATION
		NORMAL_EXIT
		RALIGNMENTS
		STACK_DEPTH
		VERY_STRONG
		WS_OPTIONAL
		Win_OS_Type
		align_paren
		arrow_count
		backup_name
		bias_tokens
		bli_pattern
		block_label
		brace_depth
		break_after
		break_count
		check_match
		ci_string_i
		colon_count
		comma_count
		comma_index
		config_file
		config_list
		depth_array
		depth_brace
		do_scan_sub
		dot_pattern
		ending_line
		escape_html
		extra_space
		fh_warnings
		get_rfields
		get_rtokens
		group_level
		group_lines
		html_italic
		html_pod_fh
		html_pre_fh
		html_toc_fh
		i_prev_plus
		indent_flag
		indentation
		inext_to_go
		insert_list
		interrupted
		iprev_to_go
		is_constant
		is_mult_div
		is_trigraph
		keyword_map
		last_equals
		last_length
		last_spaces
		level_comma
		line_number
		local_count
		logfile_gap
		n_last_line
		new_tmpfile
		next_length
		nobreak_lhs
		nobreak_rhs
		nolong_name
		nshort_name
		odd_or_even
		old_rfields
		old_rtokens
		op_expected
		output_file
		paren_depth
		perl_output
		pod_to_html
		quote_count
		quote_depth
		quote_items
		raw_options
		rblock_type
		rbody_parts
		rfields_old
		ri_term_end
		rlast_level
		rpod_string
		rpre_string
		rpre_tokens
		rtoc_string
		rtoken_type
		rtokens_old
		save_column
		saved_token
		saw_extrude
		scan_number
		search_file
		set_rfields
		set_rtokens
		show_tokens
		sink_buffer
		sink_object
		space_count
		split_words
		stack_depth
		stderr_file
		total_depth
		type_ibeg_1
		type_ibeg_2
		type_iend_1
		type_iend_2
		types_match
		types_to_go
		unique_name
		ERROR_EXIT
		FileWriter
		GetOptions
		HAVE_CHILD
		HTML_START
		HtmlWriter
		IndianRed3
		LineBuffer
		LineSource
		_index_map
		actual_pos
		add_option
		allow_tick
		blank_line
		block_type
		body_parts
		bond_str_1
		bond_str_2
		bond_str_3
		bond_str_4
		brace_type
		candidates
		colon_list
		combine_ok
		csc_prefix
		css_string
		debug_file
		debug_list
		delta_bias
		depth_last
		do_not_pad
		dont_align
		dump_array
		first_char
		found_file
		get_CLOSED
		get_MARKED
		get_SPACES
		get_column
		good_combo
		group_type
		have_child
		hid_equals
		html_color
		html_print
		i_last_end
		i_line_end
		i_nonblank
		i_question
		i_term_end
		i_terminal
		identifier
		inext_next
		initialize
		input_file
		input_hash
		input_line
		input_type
		is_Windows
		is_amp_amp
		is_digraph
		is_keyword
		is_leading
		is_math_op
		is_pattern
		is_ternary
		is_tmpfile
		item_count
		keep_going
		last_level
		last_token
		level_jump
		line_count
		make_frame
		max_excess
		max_length
		max_passes
		min_ci_gap
		min_fields
		more_to_do
		move_right
		must_break
		must_flush
		new_fields
		next_token
		old_spaces
		ones_count
		output_str
		pad_spaces
		pair_width
		paren_type
		parse_args
		pass_count
		peek_ahead
		pod_string
		postfilter
		pre_string
		pre_tokens
		quote_char
		quote_mark
		quote_type
		rOpts_tabs
		rci_levels
		rexpansion
		rpre_types
		rtoken_map
		saved_text
		scan_id_do
		search_dir
		seqno_last
		set_CLOSED
		set_MARKED
		set_column
		short_name
		test_token
		text_color
		toc_string
		token_next
		token_prev
		token_save
		token_type
		undo_lp_ci
		unexpected
		valid_flag
		want_blank
		want_break
		want_paren
		write_line
		zero_count
		Alignment
		Configure
		Formatter
		LEAVE_SRC
		LIST_TYPE
		RPATTERNS
		Tokenizer
		VERY_WEAK
		alignment
		backslash
		black_box
		block_str
		cache_key
		candidate
		check_RGB
		check_fit
		ci_spaces
		ci_string
		code_bias
		depth_beg
		expansion
		expecting
		extension
		fh_config
		fh_stderr
		fh_stream
		fileparse
		formatter
		get_INDEX
		get_LEVEL
		get_count
		get_seqno
		gnu_stack
		good_keys
		html_bold
		html_file
		html_line
		i_closing
		i_opening
		i_start_2
		ibeg_next
		ibeg_nmax
		iend_next
		is_and_or
		is_my_our
		jquestion
		last_type
		lev_start
		level_abs
		level_end
		line_open
		line_type
		list_type
		long_name
		max_pairs
		max_width
		next_char
		next_type
		nmax_last
		obp_count
		ok_to_pad
		old_level
		pad_token
		pre_types
		prefilter
		prev_type
		prototype
		quote_pos
		rdefaults
		right_key
		rpatterns
		saw_alpha
		saw_error
		saw_index
		saw_paren
		scan_list
		separator
		seqno_beg
		seqno_end
		seqno_now
		signature
		skip_line
		stackable
		start_dir
		structure
		tab_count
		test_file
		test_line
		test_name
		test_path
		tightness
		tiny_bias
		tok_begin
		tok_brace
		tok_paren
		token_end
		token_map
		token_str
		tokenizer
		trigraphs
		truncated
		type_next
		type_save
		underline
		use_cache
		Basename
		CI_LEVEL
		Debugger
		Entities
		Exporter
		FB_CROAK
		HTML_END
		IOScalar
		Keywords
		LineSink
		NO_BREAK
		NO_MATCH
		OPERATOR
		allusers
		bad_keys
		bg_color
		bond_str
		bp_count
		bs_tweak
		category
		ci_level
		ci_stack
		complain
		constant
		csc_text
		defaults
		digraphs
		do_quote
		extra_or
		extra_vr
		filename
		fileroot
		fix_type
		for_html
		get_jmax
		get_line
		hash_ref
		i_equals
		i_lowest
		i_testp2
		in_match
		in_quote
		is_chain
		is_quote
		label_ok
		last_tok
		left_key
		length_1
		length_2
		length_t
		lev_last
		lev_want
		list_str
		log_file
		magenta4
		max_bias
		max_line
		min_move
		my_flush
		new_argv
		new_line
		new_path
		next_tok
		no_print
		ok_comma
		old_line
		old_path
		opt_name
		patterns
		perltidy
		pod2html
		pos_prev
		pre_type
		prev_tok
		quit_now
		realpath
		ri_first
		ri_right
		ri_start
		rpattern
		rslevels
		saw_body
		saw_type
		set_jmax
		slevel_i
		sparsity
		src_path
		stop_now
		strength
		sub_name
		tee_file
		tee_line
		tempfile
		test_tok
		toc_path
		tok_next
		tok_test
		too_long
		total_ci
		try_path
		type_beg
		type_str
		ul_level
		warnings
		DESTROY
		DevNull
		END_PRE
		NOMINAL
		PRE_END
		RFIELDS
		RTOKENS
		TOC_END
		UNKNOWN
		VERSION
		binmode
		bs_best
		catfile
		col_now
		columns
		comment
		confess
		context
		default
		dirname
		end_tok
		endings
		fh_name
		formats
		getline
		halfway
		html_fh
		i_begin
		i_break
		i_colon
		i_debug
		i_first
		i_start
		ibreakm
		if_next
		if_text
		is_unix
		is_utf8
		istream
		level_i
		line_no
		max_pad
		md5_hex
		message
		min_pad
		new_csc
		new_tok
		newname
		old_csc
		old_pos
		old_tok
		oldname
		ostream
		out_str
		outdent
		package
		pattern
		pos_beg
		pos_chr
		pre_tok
		raw_tok
		retvals
		rfields
		ri_last
		ri_left
		rlevels
		rscalar
		rtokens
		saw_md5
		saw_pbp
		scan_id
		slevels
		subname
		tabbing
		tabsize
		tee_off
		therest
		tmpfile
		tok_beg
		tokenll
		toklast
		trailer
		undo_ci
		warning
		CLOSED
		COLUMN
		ENDCSS
		EXPORT
		Encode
		Getopt
		INFILE
		Logger
		MARKED
		RETURN
		SEQ_QW
		SPACES
		STDERR
		STDOUT
		STRONG
		WS_YES
		_count
		abbrev
		beauty
		but_is
		caller
		carrat
		ci_lev
		closed
		column
		decode
		digest
		encode
		ending
		exceed
		excess
		exists
		factor
		fh_css
		fh_tee
		fh_tmp
		field1
		fields
		filter
		finish
		forced
		i_last
		i_mate
		i_next
		i_prev
		i_save
		i_test
		ibeg_0
		ibeg_1
		ibeg_2
		ibeg_3
		ibeg_4
		ibeg_t
		ibreak
		icomma
		iend_1
		iend_2
		iend_t
		ifname
		in_toc
		indent
		iother
		is_odd
		italic
		itokmm
		itokpp
		ixlast
		j_here
		j_next
		jbrace
		jlimit
		jparen
		length
		levels
		line_1
		line_2
		line_t
		lineno
		marked
		n_best
		newpad
		num_sc
		number
		object
		offset
		ofname
		outstr
		pdepth
		prefix
		prompt
		rarray
		result
		ri_beg
		ri_end
		rlines
		rstate
		slevel
		spaces
		stream
		strict
		string
		suffix
		system
		target
		tee_on
		tmpnam
		tok_kw
		tokbeg
		tokenl
		tokenr
		tokens
		typell
		typem1
		typem2
		BEGIN
		BRACE
		INDEX
		LEVEL
		PAREN
		STDIN
		WS_NO
		Win32
		array
		attrs
		avail
		black
		bname
		build
		check
		class
		close
		colon
		color
		count
		croak
		death
		depth
		eight
		error
		files
		first
		flags
		flush
		fname
		found
		guess
		i_beg
		i_max
		i_odd
		i_tok
		ibegm
		ibegp
		iendm
		ilast
		index
		inext
		instr
		iprev
		istop
		iterm
		itest
		itokm
		itokp
		joint
		level
		ljump
		ltype
		major
		match
		minor
		month
		names
		next1
		next2
		nline
		param
		print
		proto
		rOpts
		rargv
		rtype
		seqno
		test1
		test2
		thing
		title
		token
		truth
		typel
		typer
		undef
		usage
		valid
		value
		white
		words
		ARGV
		Carp
		Copy
		Exit
		File
		HTML
		JMAX
		Line
		Long
		Opts
		Perl
		Spec
		TERM
		Temp
		Tidy
		WEAK
		Warn
		args
		argv
		base
		bext
		bias
		body
		bold
		case
		char
		code
		copy
		date
		diff
		envs
		file
		flag
		fout
		hint
		href
		ibeg
		iend
		imax
		imin
		ipad
		item
		iter
		itok
		jadd
		jbeg
		jend
		jmax
		kmax
		line
		list
		ltok
		mode
		move
		name
		need
		next
		nlev
		nmax
		numc
		olev
		part
		path
		post
		rTV1
		rTV2
		rTV3
		rTV4
		rTV5
		rTV6
		rmap
		rtoc
		rtok
		seen
		self
		test
		text
		tokj
		trim
		type
		utf8
		vars
		what
		word
		ws_1
		ws_2
		ws_3
		ws_4
		year
		Cwd
		DIE
		DIR
		Die
		ENV
		EOF
		EOM
		EOS
		ISA
		New
		SIG
		abr
		arg
		bit
		bsl
		bsr
		buf
		can
		cis
		col
		csc
		cti
		cvt
		day
		dot
		enc
		ess
		ext
		fbc
		fmt
		gap
		glc
		i_b
		i_e
		i_f
		i_l
		ibg
		im1
		im2
		im3
		inc
		key
		kwd
		lbs
		len
		lev
		lno
		lsp
		max
		min
		mll
		msg
		new
		num
		ole
		opt
		ovt
		pad
		pkg
		pos
		pre
		qs1
		qs2
		rbs
		red
		ref
		rel
		rht
		rml
		rsl
		sgb
		str
		sub
		toc
		tok
		top
		two
		val
		var
		vtc
		IO
		aa
		bb
		bk
		br
		bs
		ci
		dd
		dl
		el
		fh
		i1
		i2
		ib
		id
		ie
		ii
		il
		im
		ir
		jj
		kw
		lc
		ll
		ml
		ok
		op
		os
		pr
		sb
		sl
		tm
		tv
		vt
		wl
		wr
		ws
		1
		2
		3
		4
		5
		O
		_
		a
		b
		c
		i
		j
		k
		l
		n
		x
	COMMENTS
		$rOpts_break_at_old_keyword_breakpoints
		$rOpts_closing_side_comment_else_flag
		Professional_Perl_Programming_Code
		$continuation_string_in_tokenizer
		$intervening_secondary_structure
		a_rather_long_variable_name_here
		$rOpts_comma_arrow_breakpoints
		send_lines_to_vertical_aligner
		starting_line_of_current_depth
		$accumulating_text_for_block
		$previous_minimum_jmax_seen
		$in_statement_continuation
		$must_break_open_container
		$rOpts_line_up_parentheses
		maximum_whitespace_columns
		$is_indirect_object_taker
		$last_indentation_written
		$last_last_nonblank_token
		$last_nonblank_block_type
		$next_nonblank_block_type
		add_content_defer_opening
		$forced_breakpoint_to_go
		$forced_indentation_flag
		$is_isolated_block_brace
		$last_nonblank_prototype
		maximum_space_to_comment
		set_adjusted_indentation
		set_comma_breakpoints_do
		$ci_string_in_tokenizer
		$i_old_assignment_break
		$reconstructed_original
		_unexpected_error_count
		binary_whitespace_rules
		current_sequence_number
		forced_breakpoint_count
		forced_breakpoint_to_go
		get_opening_indentation
		is_essential_whitespace
		is_non_structural_brace
		make_alignment_patterns
		saw_function_definition
		set_continuation_breaks
		starting_one_line_block
		$caller_tokenizer_self
		$j_tight_closing_paren
		$number_of_fields_best
		$total_depth_variation
		set_closing_breakpoint
		set_default_properties
		set_leading_whitespace
		set_ragged_breakpoints
		$is_logical_container
		$matching_token_to_go
		$max_allowed_sparsity
		$nesting_block_string
		$old_breakpoint_to_go
		$side_comment_history
		$square_bracket_depth
		COLOR_CODE_FOREGROUND
		_here_quote_character
		_lower_case_labels_at
		_process_command_line
		_square_bracket_depth
		recombine_breakpoints
		set_forced_breakpoint
		$LATEX2HTMLVERSIONS$
		$do_convergence_test
		$last_nonblank_token
		$maximum_field_index
		$nesting_depth_to_go
		$nesting_list_string
		$next_nonblank_token
		blast_general_params
		get_AVAILABLE_SPACES
		matching_token_to_go
		print_line_of_tokens
		process_command_line
		scan_bare_identifier
		set_white_space_flag
		summed_lengths_to_go
		valign_output_step_B
		$do_not_break_apart
		$has_broken_sublist
		$index_before_arrow
		$last_nonblank_type
		$level_in_tokenizer
		$maximum_line_index
		$nesting_block_flag
		$next_nonblank_type
		$saw_good_alignment
		_diagnostics_object
		_line_buffer_object
		i_ragged_break_list
		last_nonblank_token
		leading_space_count
		set_logical_padding
		space_after_keyword
		$AllowZeroFilesize
		$in_attribute_list
		$input_line_number
		$is_block_function
		$max_tokens_wanted
		$maximum_jmax_seen
		$nesting_list_flag
		$output_block_type
		$perltidyrc_stream
		$rindentation_list
		_curly_brace_depth
		_in_attribute_list
		_rhere_target_list
		_starting_in_quote
		adjust_indentation
		block_leading_text
		check_vms_filename
		continuation_level
		get_leading_string
		numerator_expected
		set_bond_strengths
		tokenize_this_line
		$bigwasteofspace1
		$bigwasteofspace2
		$bigwasteofspace3
		$bigwasteofspace4
		$block_type_to_go
		$interrupted_list
		$item_count_stack
		$number_of_fields
		$replacement_text
		$vt100_compatible
		$want_comma_break
		$white_space_flag
		CAUSES_FORMATTING
		EIGHTY_CHARACTERS
		LineBuffer_object
		_line_start_quote
		decide_if_aligned
		dump_options_type
		inext_index_to_go
		max_tokens_wanted
		operator_expected
		output_line_to_go
		set_output_filter
		spaces_both_sides
		store_token_to_go
		unmatched_indexes
		valid_token_types
		write_diagnostics
		$THRf_R_DETACHED
		$THRf_R_JOINABLE
		$available_space
		$current_package
		$formatted_lines
		$group_list_type
		$i_opening_paren
		$input_file_copy
		$max_index_to_go
		$max_token_index
		$not_first_token
		$quote_character
		$quoted_string_1
		$quoted_string_2
		$weighted_length
		Error_OutOfRange
		_ending_in_quote
		_here_doc_target
		balance_csc_text
		dump_short_names
		dump_token_types
		generate_options
		get_next_tex_cmd
		get_quote_target
		indentation_item
		infile_syntax_ok
		quoted_string_1s
		set_continuation
		token_long_names
		want_right_space
		white_space_flag
		$alignment_type
		$container_type
		$depth_increase
		$ibeg_next_next
		$marginal_match
		$max_iterations
		$packed_columns
		$rif_elsif_text
		$saw_good_break
		$statement_type
		$tokenizer_self
		$type_next_next
		IndentationItem
		MERCHANTABILITY
		REPLACEMENTLIST
		VerticalAligner
		_starting_level
		binary_ws_rules
		code_block_type
		continued_quote
		do_scan_package
		experimentation
		extended_syntax
		extra_indent_ok
		formatted_lines
		inconsistencies
		item_complexity
		load_components
		max_index_to_go
		msixpodualngcer
		scan_identifier
		synchronization
		unused_keywords
		want_left_space
		$beginning_tok
		$current_depth
		$death_message
		$delete_backup
		$html_filename
		$i_first_comma
		$id_scan_state
		$is_assignment
		$minimum_depth
		$numbered_line
		$opening_token
		$page$page_ext
		$quoted_string
		$routput_array
		$rslevel_stack
		$spaces_needed
		$type_sequence
		Correspondence
		beautification
		compile_bblock
		conformability
		considerations
		distinguishing
		exponentiation
		indent_columns
		initialization
		interpretation
		itemsUnderArea
		leasing_spaces
		line_of_tokens
		myotherfreezer
		recombinations
		representation
		statement_type
		$$old_rtokens
		$case_matters
		$found_target
		$i_last_comma
		$i_line_start
		$is_long_term
		$is_multiline
		$levels_to_go
		$option_range
		$packed_lines
		$quote_target
		$seqno_string
		$tokens_to_go
		Approximation
		Contributions
		IOScalarArray
		Unfortunately
		_quote_target
		abbreviations
		allow_options
		automatically
		bond_strength
		circumstances
		classesbyname
		compatability
		compatibility
		concatenation
		configuration
		corresponding
		current_depth
		customization
		default_color
		distinguished
		documentation
		exponentation
		id_scan_state
		inconsistency
		incrementally
		indeterminate
		infinite_loop
		insensitivity
		interpolation
		msixpodualngc
		opening_paren
		option_string
		parenthesized
		pre_tokenizer
		recombination
		significantly
		source_object
		theoretically
		to_filehandle
		unfortunately
		$THRf_ZOMBIE
		$brace_depth
		$color_value
		$depth_array
		$extra_space
		$ids_excl_uc
		$indent_flag
		$indentation
		$interrupted
		$mask_string
		$mass_pellet
		$output_file
		$paren_depth
		$quote_depth
		$server_data
		$sub$lib_ext
		$types_to_go
		010101010101
		Continuation
		EXPERIMENTAL
		GetOSVersion
		Hugenschmidt
		SQL_SMALLINT
		Transmission
		WARNING_BITS
		_in_here_doc
		_paren_depth
		abbreviation
		accidentally
		accumulating
		alphanumeric
		applications
		blast_params
		calculations
		combinations
		complexities
		continuation
		declarations
		distribution
		do_something
		experimental
		hierarchical
		implementing
		inconsistent
		indentations
		individually
		instructions
		interactions
		intermediate
		introduction
		invalidating
		jskdjfjkosvk
		manipulation
		max_sparsity
		mistokenized
		modification
		new_filename
		occasionally
		optimization
		option_range
		particularly
		pid_filename
		pre_tokenize
		recognizable
		redistribute
		reformatting
		reinitialize
		side_comment
		skip_symbols
		streamhandle
		substitution
		successfully
		synchronized
		tokenization
		tokens_to_go
		transferring
		undocumented
		unexpectedly
		unidentified
		valign_input
		$IMAGE_TYPE
		$Is_MSWin32
		$Is_NetWare
		$ado_consts
		$block_type
		$depth_stop
		$do_not_pad
		$html_icons
		$i_terminal
		$identifier
		$if_tmpfile
		$input_line
		$is_math_op
		$is_pattern
		$item_count
		$min_ci_gap
		$pad_spaces
		$paren_type
		$rtoken_map
		$short_name
		$usage_fref
		Accumulates
		COLOR_INDEX
		CONSTRUCTOR
		Checkbutton
		Constructor
		Contributed
		Controlling
		DEACTIVATED
		DIAGNOSTICS
		Deactivated
		Diagnostics
		Distributed
		Eliminating
		HERE_TARGET
		INFILE_COPY
		Indentation
		Initialized
		Intermingle
		Interrupted
		LONGER_THAN
		MCONVERSION
		OPT_EXECCGI
		Programming
		RECOMMENDED
		REPLACEMENT
		SaddleBrown
		ScalarArray
		Some_method
		Suggestions
		Tentatively
		VERY_STRONG
		WS_OPTIONAL
		__PACKAGE__
		accelerator
		accordingly
		accumulated
		adjustments
		alternative
		appropriate
		approximate
		arbitrarily
		assignments
		blast_usage
		breakpoints
		calculation
		check_match
		combination
		comma_count
		complicated
		concatenate
		conditional
		consecutive
		considering
		constraints
		constructed
		constructor
		containment
		continually
		contributed
		convergence
		corrections
		counterpart
		cunningham4
		currentRoom
		deactivated
		declaration
		decremented
		definitions
		depth_array
		description
		descriptive
		destination
		determining
		development
		diagnostics
		differences
		directories
		distinction
		distinguish
		distributed
		do_scan_sub
		elimination
		encountered
		ensurrogate
		environment
		essentially
		expectation
		expressions
		fabrice_bug
		flexibility
		group_lines
		html_pod_fh
		html_pre_fh
		html_toc_fh
		identifiers
		identifying
		ids_excl_uc
		immediately
		implemented
		incorrectly
		incremental
		incremented
		indentation
		independent
		information
		informative
		initialized
		interesting
		interleaved
		intermixing
		interrupted
		intervening
		investments
		is_constant
		jskdfjskdfj
		log_message
		maintaining
		maintenance
		manipulated
		memoization
		msixpodualn
		n$type$pod2
		necessarily
		numerically
		operational
		oscillating
		oscillation
		outdentable
		parentheses
		permissions
		possibility
		postfilters
		potentially
		predictable
		predictions
		preferences
		preliminary
		programmers
		programming
		propagating
		punctuation
		readability
		recognizing
		recombining
		recommended
		recoverable
		recursively
		redirecting
		redirection
		remembering
		replacement
		responsible
		restrictive
		scan_number
		schwartzian
		selectively
		sidecomment
		significant
		sink_object
		some_method
		sourceforge
		subtracting
		suggestions
		technically
		temporarily
		tentatively
		termination
		tokenizaton
		typesbyname
		unbreakable
		underscores
		undesirable
		undoubtedly
		unformatted
		unnecessary
		$$ri_first
		$THRf_DEAD
		$block_str
		$expecting
		$file_data
		$firstline
		$i_closing
		$i_opening
		$i_start_2
		$level_abs
		$line_type
		$list_type
		$peercount
		$quote_pos
		$rpatterns
		$saw_error
		$something
		$token_str
		$too_close
		$type_next
		$underline
		Additional
		AutoLoader
		BLOCK_TYPE
		COMPLEXITY
		Categories
		Consortium
		Coordinate
		DATA_START
		Decreasing
		Eventually
		Everything
		FORMAT_END
		FileWriter
		Foundation
		GetOptions
		HtmlWriter
		Incomplete
		Increasing
		Initialize
		LineBuffer
		LineSource
		Menubutton
		MonthChars
		NEW_TOKENS
		NoWarnings
		PARTICULAR
		POSTDEFREF
		PROTOTYPES
		Parameters
		Prefilters
		Presumably
		SEARCHLIST
		SelfLoader
		Smartmatch
		Structural
		Unbalanced
		Vertically
		Whitespace
		_in_format
		_line_type
		accumulate
		adSmallInt
		adaptation
		additional
		adjustment
		afterwards
		algorithms
		alignments
		allowances
		anonynmous
		apparently
		appearance
		assignment
		associated
		assumption
		attributes
		background
		block_type
		boundaries
		brace_type
		breakpoint
		calculated
		categories
		characters
		collecting
		comparison
		compatible
		completely
		complexity
		components
		compressed
		compromise
		considered
		containers
		containing
		continuing
		controlled
		convenient
		convention
		conversion
		coordinate
		correction
		correspond
		createOval
		critically
		decreasing
		defined_or
		definitely
		definition
		delimiters
		dependents
		describing
		determined
		determines
		diagnosing
		diagnostic
		difference
		directives
		discussion
		documented
		downstream
		duplicated
		especially
		estimating
		evaluation
		eventually
		everything
		exceptions
		executable
		exercising
		expansions
		expression
		extensions
		extracting
		filehandle
		formatting
		frequently
		get_SPACES
		glVertex3d
		has_broken
		identified
		identifier
		illustrate
		impossible
		incomplete
		increasing
		indentaion
		indicating
		indication
		individual
		initialize
		instructed
		interested
		interfaces
		interlaced
		introduced
		introduces
		invaluable
		iterations
		legibility
		localizing
		maintained
		manipulate
		meaningful
		misaligned
		misparsing
		next_block
		noticeable
		obfuscated
		occasional
		ones_count
		operations
		optimistic
		optionally
		originally
		oscillates
		outdenting
		outputting
		overridden
		parameters
		paren_type
		particular
		peek_ahead
		perlsecret
		perltidyrc
		podchecker
		population
		postfilter
		precaution
		precedence
		preceeding
		previously
		primitives
		processing
		propagated
		properties
		prototypes
		quantities
		reasonable
		recipients
		recombined
		referenced
		references
		regardless
		relatively
		repeatedly
		requesting
		rescanning
		restricted
		reversible
		semicolons
		separately
		separating
		separators
		sequential
		signatures
		simplicity
		simplified
		simplifies
		situations
		smartmatch
		specifying
		statements
		structural
		structures
		sub_string
		subroutine
		subsequent
		successful
		sufficient
		summarized
		supporting
		suspicious
		terminated
		themselves
		tokenizers
		tokenizing
		transition
		triggering
		unbalanced
		underscore
		unexpected
		unfinished
		unindented
		variations
		vertically
		whatsoever
		whitespace
		write_line
		$$rfields
		$$rtokens
		$Exporter
		$Is_MacOS
		$Revision
		$TEXTONLY
		$accessor
		$bp_count
		$casefold
		$ci_level
		$contents
		$filename
		$i_lowest
		$ifclosed
		$in_quote
		$infoline
		$leapyear
		$mask_str
		$max_line
		$opt_excl
		$question
		$r_pellet
		$ri_first
		$sc_line0
		$sc_line1
		$sc_line2
		$sparsity
		$too_long
		$variable
		Alignment
		AutoSplit
		BEGINNING
		BEGinning
		CONSTANTS
		Calculate
		ChangeLog
		ColorCode
		Computing
		Concerned
		Container
		Copyright
		Currently
		Debugging
		Directory
		Documents
		Dumpvalue
		END_START
		EXAMINING
		Essential
		Estimated
		Excepting
		Exception
		FOLLOWING
		Formatter
		Implement
		Intercept
		Introduce
		LATEXFILE
		LIKE_THIS
		Linebreak
		MakeMaker
		Matarazzo
		Moskowitz
		NAMESPACE
		NO_BREAKS
		NO_BREAKs
		O_ACCMODE
		O_Control
		Otherwise
		POD_START
		PROTOTYPE
		Practices
		Recombine
		Retaining
		SIGNATURE
		Sebastien
		September
		Something
		Sometimes
		Standards
		Suggested
		Testfiles
		Therefore
		Tightness
		Tokenizer
		UNITCHECK
		Uncomment
		Underbars
		VARIABLES
		VERY_WEAK
		_expected
		_in_error
		_in_quote
		accepting
		according
		addresses
		agreement
		algorithm
		alignment
		allowable
		alternate
		ambiguity
		ambiguous
		announces
		anonymous
		appending
		arbitrary
		arguments
		assembles
		attribute
		automatic
		available
		backslash
		backticks
		backtrack
		backwards
		balancing
		barewords
		basenames
		beginning
		blocktype
		breakable
		broadcast
		calculate
		candidate
		carefully
		character
		clobbered
		collapsed
		collected
		combining
		comparing
		complaint
		computing
		condition
		conflicts
		confusing
		confusion
		constants
		construct
		contained
		container
		contining
		continued
		continues
		converged
		converted
		corrected
		correctly
		corrector
		currently
		customary
		debugging
		decisions
		decorated
		decreases
		decrement
		defensive
		delimeter
		delimited
		delimiter
		dependent
		depending
		describes
		desirable
		determine
		different
		differing
		difficult
		dimension
		directory
		disappear
		displayed
		duplicate
		effective
		efficient
		eliminate
		elsewhere
		empirical
		enclosing
		encounter
		enforcing
		entabbing
		essential
		estimated
		exceeding
		exception
		excessive
		excluding
		executing
		existence
		expansion
		expecting
		extension
		extracted
		factorial
		filenames
		filetypes
		find2perl
		fixstyle2
		flattened
		followers
		following
		formatted
		formatter
		fragments
		functions
		gathering
		generally
		generated
		hardwired
		hash_bang
		here_docs
		hierarchy
		identical
		imitating
		immediate
		implement
		important
		imprecise
		including
		incorrect
		increased
		increases
		increment
		indenting
		indention
		indicated
		indicates
		influence
		initially
		innermost
		inserting
		instances
		intensive
		interface
		interrupt
		introduce
		is_boundp
		item_list
		iterating
		iteration
		list_type
		locations
		magnitude
		maintains
		mandatory
		masontidy
		mechanism
		mentioned
		menuitems
		misplaced
		mistaking
		modifiers
		modifying
		monotonic
		multifind
		namespace
		necessary
		normalise
		numbering
		numerator
		numerical
		obviously
		operating
		operation
		operators
		otherwise
		outdented
		ov_method
		overwrite
		parameter
		parenless
		perfectly
		perlstyle
		permanent
		pointless
		positions
		postponed
		potential
		pre_token
		preceding
		predicted
		predictor
		preferred
		prefilter
		premature
		prepended
		preserver
		pretokens
		primitive
		printable
		processed
		processes
		producing
		promising
		propagate
		prototype
		published
		quotation
		quote_pos
		recognize
		recombine
		recursion
		reduction
		reference
		regarding
		remainder
		remaining
		replacing
		reporting
		requested
		requiring
		returning
		rightmost
		scan_list
		searching
		secondary
		semicolon
		sensitive
		separated
		separator
		sequences
		situation
		something
		sometimes
		somewhere
		specially
		specified
		splitting
		squeezing
		statement
		strangely
		strengths
		structure
		suggested
		summarize
		switching
		tabulated
		technique
		temporary
		tentative
		terminate
		testfiles
		text_unit
		therefore
		thousands
		threshold
		tightness
		tokenized
		tokenizer
		tolerance
		transform
		treatment
		triggered
		trigraphs
		truncated
		typeglobs
		typically
		unaligned
		unchanged
		uncuddled
		undefined
		underline
		unescaped
		unmatched
		unstoring
		unvisited
		utilities
		variables
		variation
		virtually
		wallclock
		$EndYear
		$RTXSQP1
		$RTYSQP1
		$VERSION
		$archive
		$blksize
		$columns
		$context
		$default
		$i_colon
		$inputeq
		$istream
		$max_pad
		$menubar
		$min_pad
		$mkFloor
		$ostream
		$package
		$pattern
		$rfields
		$rho_ice
		$ri_last
		$rtokens
		$saw_pbp
		$sc_col0
		$sc_col1
		$sc_col2
		$seconds
		$section
		$sysarea
		$tabsize
		$tokenll
		AUTOLOAD
		Actually
		Although
		Anything
		Aperghis
		Basename
		BasicLyx
		Blinking
		Borrower
		Breaking
		COMMENTS
		CONTENTS
		Cartmell
		Comments
		Complain
		Compound
		ConfigDb
		Consider
		Contents
		Controls
		Creating
		DELETING
		Debugger
		December
		Decorate
		Entities
		Examples
		Exporter
		February
		Franklin
		Generate
		HERE_END
		IOScalar
		Identify
		Ignoring
		Internet
		Jonathan
		Keywords
		LOCATION
		Likewise
		LineSink
		MYHANDLE
		NO_BREAK
		Normally
		November
		OPERATOR
		O_RDONLY
		Original
		PERLTIDY
		PREMATCH
		PREVIOUS
		Philippe
		Pod2html
		Remember
		Routines
		SYNOPSIS
		Sequence
		Settings
		Shortcut
		Software
		Stacking
		Starting
		Strength
		Symbolic
		Testfile
		Validate
		Vertical
		WARRANTY
		Wherever
		Williams
		__DATA__
		__FILE__
		__LINE__
		_in_data
		absolute
		accepted
		accesses
		actually
		addition
		adjacent
		adjusted
		alex_bug
		aligning
		allowing
		altering
		although
		analyzes
		annoying
		anything
		appended
		applying
		argument
		assemble
		assigned
		assuming
		attempts
		avoiding
		bVERSION
		backlink
		balanced
		bareword
		basename
		beautify
		becoming
		behavior
		blinkers
		blinking
		blktype1
		boundary
		bracebrk
		brackets
		breakage
		breaking
		bypassed
		cachedir
		casefold
		category
		changing
		checking
		circular
		citation
		collects
		colonbug
		colorMap
		coloring
		colorize
		combined
		combines
		commands
		comments
		compiled
		complain
		complete
		computed
		computer
		computes
		conflict
		consider
		constant
		contains
		contents
		contests
		continue
		controls
		converge
		corrects
		counters
		counting
		creating
		creation
		critical
		debugger
		deciding
		decision
		declared
		decorate
		decrease
		defaults
		defining
		deleting
		designed
		detailed
		diagnose
		dictated
		digraphs
		directed
		directly
		disallow
		disaster
		disobeys
		distance
		diverted
		division
		document
		downside
		elements
		embedded
		encloses
		encoding
		endpoint
		entabbed
		entering
		entirely
		equation
		escaping
		estimate
		examines
		examples
		exceeded
		excluded
		existing
		expanded
		expected
		explicit
		extended
		external
		extremes
		filename
		finished
		followed
		follower
		formerly
		fraction
		framebox
		function
		gauntlet
		generate
		generous
		get_line
		greatest
		grouping
		guessing
		handling
		happened
		hardware
		harmless
		here_doc
		htmlroot
		identify
		ignoring
		improved
		improves
		in_quote
		included
		includes
		increase
		indented
		indenter
		indicate
		indirect
		infinite
		inserted
		insisted
		insuring
		integers
		interest
		interior
		internal
		interval
		involves
		is_multi
		isolated
		join$all
		jonathan
		keywords
		localize
		location
		lockarea
		marginal
		matching
		matrices
		meanings
		messages
		metacpan
		midpoint
		migrated
		minimize
		mistaken
		modified
		modifier
		movement
		multiple
		multiply
		my$logic
		nameless
		needless
		negation
		negative
		newlines
		nomethod
		nonblank
		normally
		notation
		numbered
		numerous
		occurred
		official
		operated
		operates
		operator
		optimize
		optional
		oriented
		original
		overload
		override
		packages
		patterns
		perltidy
		physical
		pipeline
		pleasing
		pod2html
		position
		positive
		possible
		possibly
		postpone
		practice
		preceded
		precedes
		prefixed
		prepared
		preserve
		pretoken
		prevents
		previous
		priority
		prnterr1
		probable
		probably
		problems
		produced
		programs
		progress
		properly
		property
		provided
		provides
		provokes
		question
		readmail
		received
		recently
		recovery
		reducing
		referent
		register
		rejected
		relative
		reliably
		remember
		removing
		repeated
		reported
		requests
		required
		requires
		resemble
		retained
		returned
		reversed
		reworked
		rokicki4
		routines
		sc_line0
		sc_line2
		scanning
		sections
		selected
		sentinel
		separate
		sequence
		set_list
		settings
		shipment
		shortcut
		sidecmt1
		silently
		simplify
		skipping
		slightly
		software
		solution
		somebody
		somewhat
		spanning
		sparsity
		specific
		stacking
		standard
		starting
		stopping
		straight
		stranded
		strategy
		strength
		stripped
		stronger
		strongly
		stumbles
		sub_name
		sublists
		subnames
		subtract
		suggests
		suitable
		supplied
		supplies
		switches
		symlinks
		synopsis
		terminal
		testfile
		tidyview
		together
		tokenize
		tolerate
		tracking
		trailing
		treating
		trigraph
		trimming
		typeglob
		unclosed
		underway
		uniquely
		unlikely
		unlinked
		unquoted
		unwanted
		updating
		validate
		variable
		verbatim
		versions
		vertical
		vorboard
		warnings
		warranty
		whatever
		whenever
		wildcard
		writable
		yourself
		$before
		$blocks
		$change
		$endian
		$factor
		$i_prev
		$i_test
		$ibeg_1
		$ibeg_2
		$ibreak
		$iend_1
		$iend_2
		$j_next
		$jlimit
		$lineno
		$lookup
		$losing
		$method
		$myhash
		$offset
		$qclass
		$retval
		$ri_beg
		$ri_end
		$slevel
		$sortby
		$stream
		$t_melt
		$t_stop
		$tok_kw
		$tokenl
		$tokenr
		$typell
		ALLOWED
		Abandon
		Another
		Because
		CAUTION
		CHANGES
		CLOSING
		COMMENT
		COPYING
		Calling
		Cascade
		Caution
		Changed
		Combine
		Comment
		Compare
		Complex
		Compute
		Control
		Convert
		Current
		DBERROR
		DEFAULT
		DESTROY
		DebConf
		Default
		Defines
		DevNull
		EXAMPLE
		Examine
		Example
		FITNESS
		Further
		GLOBALS
		General
		GetOpts
		Hancock
		However
		Indexes
		Install
		January
		Kington
		Leading
		License
		MacPerl
		Maximum
		Memoize
		Menubar
		Michael
		NOBREAK
		NOMINAL
		Nothing
		OPENING
		October
		Opening
		Options
		PACKAGE
		PADDING
		PATCHES
		PATTERN
		POD_END
		PURPOSE
		Parents
		Patched
		Perform
		PodView
		Postfix
		Problem
		Quietly
		REMOVES
		RETURNS
		Removed
		Require
		Returns
		Routine
		SAVEOUT
		SCALARS
		SEEALSO
		SPECIAL
		S_IRUSR
		Section
		Setting
		Shouldn
		Specify
		Strange
		Systems
		TESTING
		Testing
		Toolbar
		Tramoni
		Turning
		TypeFoo
		UNKNOWN
		UPDATES
		Unicode
		Updated
		VERSION
		WARNING
		WITHOUT
		Warning
		Whereas
		Win2000
		Win2003
		Windows
		Without
		__DIE__
		__END__
		_in_end
		_in_pod
		accepts
		account
		achieve
		aligned
		aligner
		allowed
		already
		amounts
		anchors
		ancient
		another
		applied
		applies
		assumed
		assumes
		attempt
		authors
		avoided
		badfile
		balance
		batches
		because
		becomes
		besides
		between
		bgcolor
		binmode
		blinker
		blktype
		blurred
		bracket
		brainer
		breaker
		breakup
		buffers
		bundled
		c_entry
		callers
		calling
		capable
		capture
		careful
		catches
		causing
		certain
		chances
		changed
		changes
		chasing
		checked
		clarity
		clauses
		closing
		closure
		collect
		columns
		combine
		command
		comment
		compact
		compare
		complex
		compute
		confuse
		consume
		contain
		context
		control
		convert
		correct
		counter
		covered
		created
		creates
		crowded
		cuddled
		current
		dealing
		decided
		decides
		decimal
		default
		defined
		defines
		deleted
		deletes
		density
		depends
		desired
		destroy
		details
		devnull
		digraph
		display
		disrupt
		dlister
		dropped
		dumping
		earlier
		echoing
		editing
		editors
		emptied
		empties
		encoded
		entered
		entries
		entring
		erratic
		escaped
		escapes
		exactly
		examine
		example
		exceeds
		exclude
		expands
		extract
		extrude
		failure
		farther
		favored
		feature
		fhandle
		finally
		finding
		flushed
		follows
		foreach
		forgets
		formats
		formula
		forward
		freedom
		friends
		further
		garbage
		general
		getline
		getting
		gettree
		greater
		guessed
		guesses
		handled
		handles
		hanging
		happens
		hardest
		heading
		helpful
		heredoc
		hereerr
		highest
		history
		holding
		honored
		htmlify
		i_first
		ignores
		illegal
		implied
		implies
		improve
		include
		indexed
		indexes
		indices
		initial
		inserts
		install
		instead
		integer
		invalid
		invoked
		involve
		italics
		joining
		keeping
		keyword
		knowing
		labeled
		largest
		leading
		leaving
		lengths
		letters
		lexical
		lextest
		liberal
		libpods
		license
		limited
		located
		logfile
		logical
		longest
		looking
		looping
		machine
		mangled
		manpage
		mapping
		markers
		marking
		matched
		matches
		maximum
		md5_hex
		meaning
		measure
		message
		methods
		metrics
		minimal
		minimum
		missing
		mistake
		modules
		modulus
		myfile1
		myfile2
		negated
		neglect
		nesting
		network
		newline
		noblank
		nobreak
		nominal
		nothing
		numbers
		numeric
		objects
		obvious
		omitted
		oneline
		opening
		operate
		options
		outdent
		outfile
		outside
		overall
		package
		padding
		parsing
		partial
		passing
		patched
		patches
		pattern
		peeking
		pending
		perfect
		perhaps
		perldoc
		perlsyn
		placing
		podpath
		podroot
		pointer
		popping
		pos_chr
		precede
		prepare
		prepend
		present
		pretend
		prevent
		primary
		printer
		private
		problem
		proceed
		process
		produce
		profile
		program
		promote
		protect
		purpose
		pushing
		quickly
		quietly
		quoting
		reached
		reading
		reasons
		records
		recover
		recurse
		recycle
		reduced
		refined
		regexes
		regexps
		regular
		rejects
		related
		remains
		removed
		renamed
		replace
		reports
		request
		require
		resolve
		respond
		restart
		restore
		results
		returns
		reverse
		risking
		roughly
		routine
		running
		sc_col0
		sc_col1
		sc_col2
		scalars
		scan_id
		scanned
		scanner
		scbreak
		screwed
		scripts
		section
		segment
		selects
		serious
		setting
		several
		shipped
		shorter
		shouldn
		showing
		sidecmt
		signals
		similar
		skipped
		slashes
		snippet
		someday
		somehow
		someone
		sorting
		spacing
		sparser
		special
		specify
		sprintf
		squeeze
		stacked
		started
		stopped
		storage
		storing
		storrs4
		strange
		strcoll
		strings
		sublist
		subname
		success
		suffers
		summary
		support
		suspend
		swallow
		swapped
		symbols
		systems
		tabbing
		tabsize
		targets
		telling
		ternary
		testing
		through
		tidying
		tightly
		tmp_imp
		tmpfile
		towards
		treated
		trigger
		trimmed
		trivial
		trouble
		tweaked
		typical
		undoing
		unhappy
		uniform
		unknown
		unstore
		unusual
		updated
		updates
		upwards
		usually
		utility
		variety
		various
		verbose
		version
		visited
		vstring
		warning
		wasting
		weakest
		welcome
		whereas
		whether
		without
		working
		wrapped
		writing
		written
		$54321
		$TRANS
		$atime
		$avail
		$bodyA
		$bubba
		$check
		$class
		$color
		$comma
		$ctime
		$depth
		$det_a
		$det_b
		$dummy
		$flags
		$fname
		$i_beg
		$id_uc
		$input
		$k_ice
		$level
		$mname
		$mtime
		$nlink
		$opt_b
		$opt_c
		$opt_d
		$opt_f
		$opt_i
		$opt_l
		$opt_o
		$opt_x
		$param
		$qtype
		$rOpts
		$sigma
		$state
		$style
		$t_ice
		$tcold
		$title
		$token
		$typel
		$typer
		$value
		$yesno
		101547
		102371
		104427
		105484
		3rules
		ARRAYS
		Accept
		Actual
		Adding
		Adjust
		Always
		Append
		Assign
		Assume
		August
		BEFORE
		BLOCKS
		Binary
		Boston
		Braces
		Bruhat
		Button
		Called
		Caller
		Cannot
		Change
		Coding
		Commas
		Conway
		Couldn
		Create
		DIVIDE
		Damian
		Daniel
		Debian
		Decide
		Define
		Delete
		Double
		ENDing
		Either
		Entity
		FORMAT
		FUTURE
		Finish
		Follow
		Forced
		Forget
		Future
		GLOBAL
		Getopt
		HIGHER
		Handle
		Having
		Holder
		Ignore
		Indent
		LOGDIR
		Logger
		Merijn
		Method
		Modify
		Number
		OUTPUT
		Output
		PARAM1
		PARAM2
		PARAMS
		PREFIX
		Please
		Public
		Quadro
		RETURN
		Rarity
		Reduce
		Reject
		Remove
		Report
		Return
		SPACES
		SPACEY
		STDERR
		STDOUT
		STRING
		STRONG
		SWITCH
		SYSTEM
		Safety
		Scalar
		Second
		Select
		Server
		Simple
		Single
		Slight
		Street
		Swartz
		Switch
		Syntax
		System
		Toggle
		Tokens
		Trizen
		Trying
		Tyrell
		UNLESS
		Unless
		Unpack
		Update
		Values
		WS_YES
		Weaken
		Win32s
		WinNT3
		WinNT4
		XEvent
		_to_go
		accept
		access
		across
		acting
		actual
		adding
		adjust
		agrees
		align3
		aligns
		allows
		almost
		always
		amount
		anchor
		answer
		anyway
		appear
		append
		around
		arrays
		arrive
		arrows
		assert
		assign
		assist
		assume
		attrib
		avoids
		backup
		barney
		become
		before
		begins
		behave
		better
		beyond
		biased
		binary
		blanks
		blocks
		borris
		bottom
		bounce
		bounds
		braces
		break1
		breaks
		broken
		buffer
		bypass
		cached
		called
		caller
		cannot
		caputo
		catdir
		caught
		caused
		causes
		chains
		change
		checks
		choice
		chosen
		clause
		clever
		closed
		closer
		closes
		coding
		colons
		colors
		column
		commas
		commit
		common
		config
		copies
		couldn
		counts
		couple
		create
		curdir
		damage
		darken
		dashes
		decide
		deeply
		define
		deken4
		delete
		depths
		detect
		differ
		digits
		divide
		dotted
		double
		dumped
		during
		easier
		echo$$
		editor
		effect
		either
		elseif
		elsif2
		enable
		encode
		ending
		enough
		enters
		entire
		entity
		equals
		errors
		escape
		events
		exceed
		except
		excess
		exists
		expand
		expect
		extend
		factor
		fairly
		faster
		fields
		figure
		fileno
		filter
		finish
		finite
		flames
		follow
		fooled
		forced
		forces
		forget
		format
		frames
		future
		gained
		galgen
		gamble
		gather
		george
		getkwd
		getopt
		giving
		glitch
		global
		glyphs
		groups
		handle
		happen
		harder
		hashes
		having
		header
		helped
		higher
		i_last
		ignore
		indent
		infile
		inline
		inputs
		insert
		inside
		insure
		intact
		invoke
		italic
		itself
		joined
		killed
		labels
		larger
		lately
		latest
		latter
		laying
		layout
		leaves
		length
		lesser
		letter
		levels
		likely
		limits
		liners
		linked
		listed
		little
		logger
		longer
		looked
		lookup
		lowest
		mainly
		making
		mangle
		manual
		mapped
		margin
		marked
		marker
		markup
		master
		matrix
		matter
		maxpad
		member
		messed
		messes
		method
		midway
		minpad
		mirror
		missed
		modify
		module
		modulo
		months
		myfile
		myfunc
		n$text
		nearby
		needed
		nested
		newest
		nicely
		normal
		notidy
		noting
		number
		object
		occurs
		offset
		opened
		option
		others
		output
		owning
		packed
		padded
		panels
		parbox
		parens
		parsed
		parser
		parses
		passed
		passes
		people
		period
		perl58
		perlop
		placed
		places
		played
		please
		plenty
		points
		prefer
		prefix
		preset
		pretty
		printf
		proper
		quoted
		quotes
		ragged
		ranges
		rather
		rdonly
		really
		reason
		recent
		record
		reduce
		reject
		relief
		remain
		remove
		report
		result
		resume
		retain
		return
		revert
		routes
		safely
		safest
		safety
		saying
		scalar
		scheme
		script
		search
		second
		secret
		seeing
		seemed
		select
		series
		severe
		shared
		sheets
		shells
		should
		signal
		simple
		simply
		single
		slices
		smooth
		sorted
		source
		spaced
		spaces
		spacey
		sparse
		speeds
		splice
		square
		stable
		stacks
		stages
		starts
		states
		static
		status
		stdout
		stored
		strand
		stream
		strict
		string
		styles
		substr
		subtle
		suited
		summed
		sunken
		supply
		swartz
		switch
		symbol
		syntax
		system
		tables
		taking
		target
		tested
		things
		though
		tidied
		toggle
		tokens
		toward
		tracks
		tricks
		tricky
		trying
		tuning
		turned
		unable
		undoes
		undone
		unique
		unless
		unlink
		unsafe
		unsure
		unused
		update
		uptime
		useful
		valign
		values
		varies
		wanted
		weaker
		weight
		widths
		win32s
		within
		wouldn
		writer
		writes
		$ECHO
		$File
		$HOME
		$Year
		$area
		$args
		$code
		$dat1
		$data
		$diff
		$done
		$file
		$font
		$have
		$heap
		$ibeg
		$icon
		$ids_
		$iend
		$ipad
		$item
		$iter
		$jmax
		$line
		$main
		$mode
		$move
		$name
		$opts
		$page
		$rdev
		$res1
		$res2
		$root
		$rtoc
		$self
		$size
		$text
		$this
		$thot
		$time
		$type
		$upem
		$user
		$var1
		$var2
		$want
		$wmkf
		$year
		02110
		10000
		15_02
		81854
		81866
		88020
		94338
		94354
		95708
		96101
		97159
		98902
		99514
		99961
		AFTER
		ANGLE
		ARRAY
		ATTRS
		Added
		After
		Allow
		Apply
		April
		Arena
		Avoid
		BEGIN
		BLOCK
		BUBBA
		Based
		Basic
		Begin
		Blank
		Brace
		Brand
		Break
		Build
		CATCH
		CHECK
		Check
		Colin
		Color
		Count
		DEBUG
		DENSE
		Debug
		Denis
		Depth
		Doing
		ERROR
		Entry
		Error
		FIXME
		FULLY
		Fcntl
		Field
		Fifth
		First
		Flags
		Floor
		Flush
		Force
		Found
		Given
		Guess
		HELLO
		HINTS
		Honor
		INDEX
		LABEL
		LISTX
		LISTY
		LOWER
		Later
		Lines
		Looks
		MAJOR
		MINOR
		MacOS
		Magic
		March
		Match
		Maybe
		Myers
		NICOL
		NOTES
		NSCAN
		Never
		Often
		Orton
		Other
		PATCH
		PERL6
		PROTO
		Parse
		Patch
		Place
		Plain
		Prima
		Print
		RIGHT
		Ready
		Right
		Rules
		STDIN
		STUFF
		Short
		Since
		Space
		Split
		Start
		Steve
		Strip
		Style
		TOKEN
		TText
		TYPES
		Table
		There
		These
		Think
		Token
		Treat
		Under
		Users
		WS_NO
		Win32
		Win95
		Win98
		WinMe
		WinXP
		World
		Would
		Write
		_text
		about
		above
		acute
		adapt
		added
		after
		again
		agree
		ahead
		alert
		alias
		align
		allow
		alone
		along
		alpha
		among
		angle
		apart
		apply
		array
		arrow
		ascii
		asdfa
		asked
		atan2
		attrs
		avail
		avoid
		based
		bases
		basic
		basis
		batch
		begin
		being
		below
		black
		blank
		bless
		block
		bonds
		bound
		brace
		break
		brief
		broke
		bubba
		build
		built
		bytes
		cache
		calls
		camel
		caret
		caron
		cases
		catch
		cause
		chain
		check
		child
		chose
		class
		clean
		clear
		close
		coded
		codes
		colon
		color
		comes
		comma
		could
		count
		crash
		cross
		crude
		curly
		debug
		dense
		depth
		digit
		doesn
		doing
		dummy
		dumps
		early
		eaten
		elroy
		elses
		elsif
		email
		empty
		ended
		entab
		enter
		entry
		equal
		error
		event
		every
		exact
		exist
		extra
		fails
		false
		fatal
		fewer
		field
		files
		final
		first
		fixed
		fixup
		flags
		flush
		force
		forms
		found
		frame
		fully
		fussy
		fuzzy
		gefor
		given
		gives
		globs
		goals
		going
		grave
		group
		guess
		hates
		haven
		hello
		helps
		hence
		hides
		holds
		homer
		honor
		howdy
		https
		ideas
		image
		index
		inner
		input
		inter
		issue
		item_
		items
		joins
		joint
		jumps
		keeps
		known
		knows
		label
		large
		later
		leads
		least
		leave
		level
		liked
		limit
		lines
		links
		lists
		local
		logic
		looks
		loops
		lower
		major
		makes
		march
		marge
		marks
		match
		maybe
		means
		meant
		merge
		messy
		might
		mimic
		minor
		minus
		mixed
		mixes
		moved
		msdos
		multi
		my$ft
		mycan
		myfun
		named
		names
		nasty
		needn
		needs
		never
		nicer
		nodes
		nofoo
		notes
		occur
		octal
		often
		older
		opath
		order
		other
		outer
		pairs
		panel
		paren
		parse
		parts
		patch
		paths
		penco
		peren
		piece
		place
		point
		print
		prior
		proto
		punct
		qoute
		quasi
		quick
		quiet
		quirk
		quite
		quote
		reach
		reads
		ready
		regex
		rerun
		reset
		right
		risky
		rnorm
		route
		rules
		safer
		saved
		saves
		scope
		seems
		sends
		sense
		serve
		setup
		sheet
		shell
		shift
		short
		shown
		shows
		sides
		sigil
		since
		slash
		small
		solve
		space
		spans
		speed
		split
		spoil
		stack
		stage
		stand
		start
		state
		stays
		stdin
		steps
		steve
		stick
		still
		store
		stray
		strip
		stuff
		style
		table
		taken
		takes
		tends
		terms
		test1
		test8
		tests
		their
		there
		these
		thing
		think
		third
		those
		three
		throw
		tight
		times
		title
		to_go
		token
		total
		touch
		track
		treat
		trial
		tried
		tries
		tweak
		types
		unary
		undef
		under
		unset
		until
		upper
		usage
		users
		using
		usual
		utils
		valid
		value
		verge
		visit
		wants
		warns
		watch
		weird
		where
		which
		while
		whine
		white
		whole
		whose
		width
		win32
		witch
		words
		works
		worry
		worse
		worst
		worth
		would
		wrath
		write
		wrong
		wrote
		xvals
		yvals
		$$op
		$BUB
		$Bar
		$ENV
		$Net
		$col
		$dev
		$env
		$eps
		$foo
		$gid
		$ino
		$key
		$msg
		$num
		$ord
		$pad
		$pat
		$pos
		$q_0
		$ref
		$rht
		$sec
		$str
		$tau
		$tok
		$uid
		$var
		0041
		0061
		0755
		0x41
		1000
		1024
		1234
		1235
		1301
		1601
		2000
		2001
		2003
		2012
		2014
		2016
		2899
		ARGV
		ATTR
		Also
		Attr
		Auto
		Axel
		BODY
		BOOL
		Best
		Bond
		Both
		CASE
		CM11
		CODE
		CORE
		Carp
		Case
		Code
		Copy
		Core
		DATA
		DESC
		Deja
		Dont
		Dump
		Each
		FILE
		File
		Find
		Free
		From
		Full
		GOOD
		HARM
		HASH
		HERE
		HOME
		HREF
		HTML
		Hand
		Head
		Here
		Hope
		Html
		Hugh
		INIT
		July
		June
		Just
		Keep
		LEFT
		LINE
		LIST
		Line
		List
		Loca
		Long
		Look
		Loop
		MAIL
		MORE
		MSDN
		Mail
		Make
		Many
		Mark
		Meta
		Most
		Must
		NAME
		NEXT
		NOTE
		Name
		Need
		Next
		None
		Note
		ONLY
		Once
		Only
		Opts
		POOR
		Path
		Peek
		Perl
		Pick
		QAML
		Rose
		Rule
		SINK
		Save
		Scan
		Send
		Skip
		Some
		Spec
		Step
		TERM
		THAN
		THIS
		TODO
		TRIM
		TRUE
		TYPE
		Tabs
		Take
		Test
		That
		Then
		They
		This
		Thus
		Tidy
		Timg
		Tres
		Turn
		Type
		USER
		USES
		Ueli
		Undo
		Unix
		User
		Uses
		VARS
		View
		WEAK
		Walk
		Warn
		What
		When
		Wide
		Will
		Work
		YVES
		Yves
		_tdy
		able
		acts
		adds
		also
		aran
		area
		aren
		args
		asap
		asbl
		asdf
		auto
		back
		bang
		bare
		bart
		bdiv
		been
		best
		bext
		bias
		bind
		body
		bold
		bond
		bool
		both
		bugs
		bump
		call
		came
		caps
		care
		case
		cdsr
		ceil
		chan
		char
		clip
		code
		col1
		col2
		col3
		col4
		cols
		come
		copy
		core
		cpan
		csci
		cscw
		csys
		cusr
		dash
		data
		date
		deep
		didn
		dies
		diff
		dima
		docs
		does
		doif
		doit
		done
		dots
		down
		dump
		each
		easy
		edge
		else
		ends
		eval
		even
		ever
		exec
		exit
		expr
		fail
		fake
		fall
		file
		fill
		find
		fine
		fits
		flag
		flow
		form
		fpsc
		fred
		free
		from
		full
		gaps
		gets
		give
		glob
		gnu2
		goal
		goes
		good
		goto
		grep
		hadn
		half
		hand
		hard
		harm
		hash
		hasn
		have
		head
		help
		here
		hide
		high
		hits
		hold
		hole
		home
		hope
		howe
		html
		http
		huge
		idea
		imax
		info
		into
		isbc
		item
		jane
		jmax
		join
		jump
		just
		keep
		kept
		keys
		kill
		kind
		know
		land
		last
		lead
		left
		less
		lets
		like
		line
		link
		list
		load
		loca
		long
		look
		loop
		lose
		loss
		lots
		luck
		made
		main
		make
		many
		map1
		mark
		mate
		math
		mess
		misc
		miss
		mode
		more
		most
		move
		much
		must
		name
		near
		need
		nest
		next
		nice
		nmax
		node
		none
		note
		npvl
		nsak
		ntqw
		null
		okay
		omit
		once
		ones
		only
		onto
		open
		opts
		over
		pack
		pads
		page
		pair
		part
		pass
		past
		path
		pbug
		perl
		pick
		pipe
		plus
		poor
		post
		pull
		pure
		push
		puts
		quit
		rare
		read
		real
		redo
		refs
		rest
		room
		root
		rsvd
		rule
		runs
		safe
		said
		same
		sane
		save
		says
		sbcp
		scan
		secs
		seek
		seem
		seen
		sees
		self
		semi
		send
		sent
		sets
		ship
		show
		side
		sink
		size
		skip
		slot
		slow
		some
		sort
		stat
		stay
		step
		stmt
		stop
		subs
		such
		sure
		tabs
		tack
		tags
		take
		talk
		task
		tcsh
		tell
		temp
		term
		test
		text
		than
		that
		them
		then
		they
		this
		thus
		tick
		ties
		time
		tiny
		toke
		trim
		true
		tune
		turn
		type
		ugly
		undo
		unit
		unix
		upon
		used
		user
		uses
		utf8
		v101
		vars
		vary
		very
		vmll
		wait
		walk
		want
		warn
		ways
		well
		were
		what
		when
		wide
		wild
		will
		wish
		with
		wlll
		word
		work
		wrap
		xMin
		xxxx
		your
		zero
		$Qs
		$XY
		$bb
		$cs
		$cu
		$cx
		$cy
		$dd
		$fh
		$fn
		$hu
		$ib
		$ie
		$in
		$no
		$nu
		$op
		$os
		$pi
		$ps
		$pu
		$pw
		$s2
		$to
		$ts
		$tt
		$wu
		$x1
		$x2
		$xd
		$xn
		$xs
		$y1
		$y2
		$ys
		004
		005
		009
		032
		100
		123
		127
		128
		147
		256
		2nd
		400
		703
		999
		ANY
		API
		ARE
		ARG
		Add
		All
		And
		Any
		BAD
		BLA
		BUT
		Bar
		Bug
		But
		CGI
		CPU
		Con
		DBI
		DCL
		DID
		DNS
		Dan
		Don
		Dot
		Due
		END
		ENV
		EOF
		EOT
		ERR
		End
		FOR
		Fax
		Feb
		Foo
		For
		GNU
		GPL
		How
		III
		Inc
		Jan
		Joe
		LOG
		Let
		LoL
		MAY
		Mar
		May
		NEW
		NOT
		NT3
		NT4
		NUM
		Net
		New
		Not
		Nov
		Now
		OLD
		ONE
		OS2
		Old
		One
		POD
		Pod
		Put
		RGB
		RIB
		Run
		SIG
		STR
		Sam
		See
		Set
		Sub
		Sum
		TBD
		THE
		TV1
		TV2
		TV3
		TV4
		TV5
		TV6
		The
		Try
		Two
		USA
		USE
		Uno
		Use
		VMS
		Web
		X11
		You
		abc
		abs
		act
		add
		adj
		aid
		all
		and
		any
		are
		arg
		bad
		bak
		bar
		baz
		big
		bit
		bla
		bli
		box
		bug
		but
		can
		ccc
		cmp
		cos
		csc
		css
		cti
		cut
		dac
		dap
		def
		dev
		dfi
		did
		die
		dir
		doc
		don
		dor
		dos
		dot
		dtt
		due
		els
		end
		eof
		err
		etc
		exp
		far
		few
		fit
		fix
		fll
		foo
		for
		gap
		get
		ghi
		gnu
		got
		had
		has
		hcc
		hck
		hex
		hit
		hoc
		how
		ian
		ibc
		icb
		icp
		img
		ini
		iob
		isn
		ith
		its
		job
		jth
		key
		lbl
		let
		log
		lop
		lot
		low
		mac
		man
		map
		max
		may
		mbl
		mid
		min
		mis
		mix
		msg
		nag
		net
		new
		non
		not
		now
		nth
		odd
		off
		old
		ole
		one
		org
		our
		out
		own
		pad
		pbp
		per
		ple
		plx
		pod
		poe
		pom
		pop
		pos
		pre
		pro
		put
		raw
		ref
		rhs
		row
		run
		s2p
		saw
		say
		sbl
		scl
		sct
		see
		sel
		set
		sil
		sin
		sot
		spw
		str
		sub
		sum
		sys
		tab
		tag
		tan
		tdy
		the
		tie
		tk3
		toc
		tok
		too
		top
		try
		tso
		two
		txt
		use
		usr
		var
		via
		vim
		vtc
		was
		way
		wba
		wbb
		who
		why
		win
		wls
		won
		wrs
		x10
		x79
		xxx
		yes
		yet
		you
		yyy
		$$
		$1
		$4
		$5
		$A
		$B
		$C
		$D
		$E
		$F
		$G
		$M
		$R
		$X
		$Y
		$_
		$a
		$b
		$c
		$d
		$e
		$f
		$h
		$i
		$j
		$m
		$n
		$q
		$r
		$s
		$t
		$u
		$v
		$w
		$x
		$y
		$z
		01
		03
		0H
		1$
		10
		11
		12
		13
		15
		16
		18
		19
		1a
		1b
		1c
		1d
		20
		22
		26
		27
		28
		29
		2d
		2k
		32
		40
		42
		51
		53
		55
		74
		78
		80
		95
		98
		9x
		An
		As
		At
		BE
		Be
		By
		DO
		Do
		FH
		ID
		IO
		IS
		IT
		If
		In
		It
		LI
		MA
		ME
		MS
		Me
		My
		NB
		NO
		NT
		No
		OK
		OS
		Ok
		On
		Or
		PK
		PP
		RT
		Re
		So
		Tc
		Tk
		To
		We
		XP
		aa
		ad
		am
		an
		as
		at
		be
		bl
		bt
		by
		ci
		cm
		co
		cr
		dd
		do
		e2
		e3
		e6
		eq
		er
		et
		f1
		f3
		fh
		gc
		go
		gt
		hi
		hr
		i1
		i2
		id
		ie
		if
		in
		io
		ip
		is
		it
		lc
		ll
		lp
		lt
		mQ
		mm
		my
		ne
		no
		of
		oh
		ok
		on
		op
		or
		pi
		pl
		pm
		pp
		pt
		pu
		qr
		qw
		rd
		re
		rt
		sc
		so
		st
		tb
		to
		tr
		ul
		un
		up
		us
		v3
		ve
		vs
		vt
		vu
		we
		ws
		x4
		xx
		$
		0
		1
		2
		3
		4
		5
		6
		7
		8
		9
		A
		B
		C
		D
		E
		F
		G
		I
		K
		L
		O
		P
		Q
		R
		S
		T
		U
		V
		W
		X
		Y
		Z
		_
		a
		b
		c
		d
		e
		f
		g
		h
		i
		k
		l
		m
		n
		o
		p
		q
		r
		s
		t
		v
		w
		x
		y
		z
	LITERALS
		_started_looking_for_here_target_at
		FORMATTER_DEBUG_FLAG_BOND_TABLES
		find_angle_operator_termination
		FORMATTER_DEBUG_FLAG_RECOMBINE
		_nearly_matched_here_target_at
		_wrote_line_information_string
		TOKENIZER_DEBUG_FLAG_TOKENIZE
		FORMATTER_DEBUG_FLAG_NOBREAK
		TOKENIZER_DEBUG_FLAG_SCAN_ID
		undo_forced_breakpoint_stack
		FORMATTER_DEBUG_FLAG_OUTPUT
		FORMATTER_DEBUG_FLAG_SPARSE
		FORMATTER_DEBUG_FLAG_UNDOBP
		TOKENIZER_DEBUG_FLAG_EXPECT
		_consecutive_nonblank_lines
		_first_line_length_error_at
		FORMATTER_DEBUG_FLAG_BREAK
		FORMATTER_DEBUG_FLAG_FLUSH
		FORMATTER_DEBUG_FLAG_FORCE
		FORMATTER_DEBUG_FLAG_STORE
		FORMATTER_DEBUG_FLAG_WHITE
		TOKENIZER_DEBUG_FLAG_NSCAN
		TOKENIZER_DEBUG_FLAG_QUOTE
		_guessed_indentation_level
		_last_line_length_error_at
		_max_output_line_length_at
		lookup_opening_indentation
		FORMATTER_DEBUG_FLAG_BOND
		FORMATTER_DEBUG_FLAG_LIST
		RVERTICAL_TIGHTNESS_FLAGS
		VALIGN_DEBUG_FLAG_APPEND0
		VALIGN_DEBUG_FLAG_TERNARY
		_continuation_indentation
		_max_line_length_error_at
		_saw_negative_indentation
		rvertical_tightness_flags
		VALIGN_DEBUG_FLAG_APPEND
		_consecutive_blank_lines
		_first_line_length_error
		_last_input_line_written
		_line_length_error_count
		_write_diagnostics_count
		continuation_indentation
		FORMATTER_DEBUG_FLAG_CI
		IS_HANGING_SIDE_COMMENT
		TYPE_SEQUENCE_INCREMENT
		_last_line_length_error
		_max_output_line_length
		_rcontainer_environment
		_unexpected_error_count
		is_hanging_side_comment
		VALIGN_DEBUG_FLAG_TABS
		_max_line_length_error
		_rlower_case_labels_at
		_wrote_column_headings
		insert_new_token_to_go
		undo_forced_breakpoint
		_here_quote_character
		_last_diagnostic_file
		_square_bracket_depth
		dump_options_category
		_know_starting_level
		_look_for_autoloader
		_look_for_selfloader
		scan_bare_identifier
		starting_line_number
		valign_output_step_D
		BRACE_WARNING_LIMIT
		FORMATTER_DEBUGGING
		LEADING_SPACE_COUNT
		MAXIMUM_LINE_LENGTH
		TOKENIZER_DEBUGGING
		_diagnostics_object
		_line_buffer_object
		_line_source_object
		_look_for_hash_bang
		_output_line_number
		_started_tokenizing
		leading_space_count
		look_for_autoloader
		look_for_selfloader
		maximum_line_length
		JMAX_ORIGINAL_LINE
		OUTDENT_LONG_LINES
		RECOVERABLE_SPACES
		_curly_brace_depth
		_debug_file_opened
		_in_attribute_list
		_input_line_ending
		_rhere_target_list
		_rlookahead_buffer
		_rpre_string_stack
		_starting_in_quote
		diagnostics_object
		dump_abbreviations
		dump_options_range
		get_leading_string
		jmax_original_line
		look_for_hash_bang
		outdent_long_lines
		_block_log_output
		_html_file_opened
		_last_line_number
		_line_sink_object
		_line_start_quote
		_output_file_open
		dump_getopt_flags
		dump_options_type
		forced_breakpoint
		output_line_to_go
		store_token_to_go
		AVAILABLE_SPACES
		MAX_NAG_MESSAGES
		OLD_PERL_VERSION
		VALIGN_DEBUGGING
		_complaint_count
		_debugger_object
		_ending_in_quote
		_extended_syntax
		_here_doc_target
		_quote_character
		_rcontainer_type
		_rin_toc_package
		_rnesting_blocks
		_rnesting_tokens
		_rtoc_item_count
		_rtoc_name_count
		_saw_brace_error
		_saw_perl_dash_P
		_saw_perl_dash_w
		_tee_file_opened
		getprotobynumber
		HERE_DOC_WINDOW
		SEQUENCE_NUMBER
		STARTING_COLUMN
		UNDEFINED_INDEX
		UNKNOWN_CONTEXT
		VerticalAligner
		_at_end_of_file
		_indent_columns
		_line_of_tokens
		_line_separator
		_outdent_labels
		_rpackage_stack
		_rtype_sequence
		_saw_autoloader
		_saw_selfloader
		_saw_use_strict
		_starting_level
		debugger_object
		extended_syntax
		msixpodualngcer
		perltidyrc_dump
		scan_identifier
		starting_column
		MATCHING_TOKEN
		QUESTION_COLON
		SCALAR_CONTEXT
		SQUARE_BRACKET
		STARTING_INDEX
		Unconventional
		_logger_object
		_pod_cut_count
		_rinput_buffer
		_saw_hash_bang
		_warning_count
		getprotobyname
		indent_columns
		matching_token
		outdent_labels
		starting_level
		Configuration
		MediumOrchid3
		SERIAL_NUMBER
		STARTING_LINE
		WARNING_LIMIT
		_output_array
		_quote_target
		_saw_code_bug
		_saw_v_string
		_src_filename
		_toc_filename
		_warning_file
		abbreviations
		beginning_tok
		concatenation
		configuration
		disagreements
		documentation
		gethostbyaddr
		gethostbyname
		getservbyname
		getservbyport
		leading_count
		logger_object
		msixpodualngc
		serial_number
		source_object
		starting_line
		Combinations
		DeepSkyBlue4
		LIST_CONTEXT
		SAVED_COLUMN
		Transitional
		Unrecognized
		Unterminated
		_fh_warnings
		_html_pod_fh
		_html_pre_fh
		_html_toc_fh
		_in_here_doc
		_line_number
		_logfile_gap
		_output_file
		_paren_depth
		_rblock_type
		_rlast_level
		_rpod_string
		_rtoc_string
		_rtoken_type
		_saw_extrude
		abbreviation
		alphanumeric
		continuation
		disagreement
		distribution
		dump_options
		getnetbyaddr
		getnetbyname
		rraw_options
		saved_column
		tokenization
		tokinization
		transitional
		unidentified
		unreasonably
		unrecognized
		ALIGN_PAREN
		ARROW_COUNT
		BOND_TABLES
		Breakpoints
		COMMA_COUNT
		Controlling
		DIAGNOSTICS
		ENDING_LINE
		END_OF_LIST
		ForestGreen
		INDENTATION
		Indentation
		Programming
		RALIGNMENTS
		STACK_DEPTH
		SaddleBrown
		USERPROFILE
		VERY_STRONG
		WS_OPTIONAL
		Win_OS_Type
		_debug_file
		_input_file
		_rci_levels
		_use_prefix
		alternative
		appreciated
		appropriate
		arbitrarily
		breakpoints
		conditional
		consecutive
		deactivated
		deactivates
		declaration
		description
		destination
		diagnostics
		discouraged
		encountered
		ending_line
		endprotoent
		getpeername
		getpriority
		getprotoent
		getsockname
		implemented
		incorrectly
		indentation
		information
		msixpodualn
		norecombine
		overwritten
		packed_cols
		parentheses
		permissions
		punctuation
		ralignments
		recommended
		replacement
		scan_number
		setpriority
		setprotoent
		sink_object
		sourceforge
		stack_error
		understands
		unnecessary
		Alignments
		Attempting
		AutoLoader
		DATA_START
		Enterprise
		FORMAT_END
		GetOptions
		HAVE_CHILD
		HTML_START
		IndianRed3
		Outdenting
		SUBROUTINE
		SelfLoader
		UNMODIFIED
		Unexpected
		Whitespace
		_html_file
		_in_format
		_line_text
		_line_type
		acceptable
		additional
		appearance
		attempting
		autoloader
		background
		block_list
		characters
		containers
		continuing
		coordinate
		deactivate
		definition
		deprecated
		endhostent
		endservent
		equivalent
		eventually
		formatting
		gethostent
		getservent
		getsockopt
		identified
		identifier
		indirectet
		internally
		iterations
		noconverge
		nopod2html
		occasional
		outdenting
		parameters
		perltidyrc
		podrecurse
		podverbose
		postfilter
		properties
		recommeded
		redefining
		references
		scan_state
		selfloader
		semicolons
		sethostent
		setservent
		setsockopt
		socketpair
		statements
		structural
		stylesheet
		subroutine
		terminator
		translated
		underlined
		unexpected
		vertically
		whitespace
		workaround
		Converged
		Copyright
		Debugging
		Documents
		END_START
		Examining
		Expecting
		Following
		Generated
		HOMESHARE
		LIST_TYPE
		Linebreak
		POD_START
		RECOMBINE
		RPATTERNS
		Retaining
		Sometimes
		Standards
		UNDEFined
		UNITCHECK
		VERY_WEAK
		_filename
		_in_error
		_in_quote
		_log_file
		_rslevels
		_saw_data
		_tee_file
		_tee_flag
		anonymous
		attribute
		automatic
		beginning
		character
		combining
		conflicts
		constants
		container
		corrected
		currently
		debugging
		decrement
		delimiter
		detection
		directory
		enclosing
		endnetent
		entabbing
		errorfile
		essential
		expansion
		expecting
		extension
		filenames
		following
		formatter
		generated
		getnetent
		including
		increment
		indicated
		indicater
		indicates
		installed
		introduce
		iteration
		list_type
		localtime
		mandatory
		modifiers
		next_type
		nocuddled
		nologfile
		noopening
		nooutdent
		noprofile
		noswallow
		nowarning
		operators
		outdented
		pairwidth
		parameter
		podheader
		practices
		prefilter
		prototype
		quote_pos
		quotemeta
		recombine
		reference
		resetting
		rewinddir
		rpatterns
		scan_list
		semicolon
		separator
		setnetent
		sometimes
		specially
		specified
		statement
		structure
		temporary
		tightness
		uncertain
		undefined
		utilities
		wantarray
		AUTOLOAD
		Blinking
		CI_LEVEL
		Complete
		Conflict
		Embedded
		Entering
		Entities
		Expected
		Exporter
		Frameset
		Guessing
		HERE_END
		HTML_END
		Ignoring
		MODIFIED
		NO_BREAK
		OPERATOR
		PATTERNS
		PERLTIDY
		Perltidy
		Possible
		Possibly
		Repeated
		Settings
		Starting
		Stopping
		TOKENIZE
		__DATA__
		__WARN__
		_binmode
		_html_fh
		_in_data
		_rlevels
		_rtokens
		_saw_end
		_started
		_tabsize
		_trim_qw
		accurate
		actually
		addition
		appended
		argument
		backlink
		balanced
		bareword
		brackets
		cachedir
		checking
		ci_level
		circular
		closedir
		commands
		comments
		consider
		constant
		contains
		contents
		continue
		controls
		converge
		critical
		dbmclose
		defaults
		deletion
		detailed
		disables
		discover
		division
		document
		embedded
		encoding
		endgrent
		endpwent
		entabbed
		entering
		entities
		exceeded
		existing
		expected
		extended
		filename
		flushing
		formline
		frameset
		function
		getgrent
		getgrgid
		getgrnam
		getlogin
		getpwent
		getpwnam
		getpwuid
		guessing
		here_doc
		htmlroot
		ignoring
		included
		increase
		indented
		indenter
		indirect
		infinite
		interior
		internet
		interval
		keywords
		last_cmt
		location
		magenta4
		matching
		messages
		modifier
		multiple
		negative
		newlines
		next_tok
		noblanks
		nodelete
		noframes
		noindent
		nostatic
		notation
		one_line
		operator
		optional
		original
		override
		pERLTIDY
		packages
		patterns
		perl2web
		perltidy
		pod2html
		podflush
		podindex
		podquiet
		position
		positive
		possible
		preserve
		previous
		probably
		problems
		produces
		profiles
		readline
		readlink
		readpipe
		redefine
		redirect
		reducing
		renaming
		replaced
		reported
		required
		requires
		reserved
		returned
		scanning
		selected
		sensible
		setgrent
		setpwent
		shmwrite
		shutdown
		skipping
		smallest
		software
		sparsity
		specific
		standard
		starting
		strength
		switches
		syswrite
		tempfile
		terminal
		together
		trailing
		truncate
		variable
		versions
		vertical
		warnings
		whatever
		APPEND0
		Attempt
		COMMENT
		CURRENT
		Caution
		Command
		Comment
		Control
		Current
		DESTROY
		DOCTYPE
		Default
		Deleted
		Dumping
		END_PRE
		Exiting
		General
		Hancock
		However
		Include
		Leading
		License
		Maximum
		Missing
		NOBREAK
		NOMINAL
		Options
		POD_END
		PRE_END
		Partial
		Problem
		Program
		RFIELDS
		RTOKENS
		SCAN_ID
		Suggest
		TERNARY
		TOC_END
		Testing
		UNKNOWN
		Unknown
		Useless
		VERSION
		WARNING
		Win2003
		Windows
		Winking
		__DIE__
		__END__
		_fh_tee
		_in_end
		_in_pod
		aliases
		allowed
		already
		altered
		applied
		attempt
		backing
		because
		believe
		between
		bgcolor
		binmode
		bracket
		capable
		changes
		checked
		clauses
		closing
		columns
		command
		comment
		connect
		contact
		contain
		content
		control
		courier
		created
		cuddled
		dbmopen
		decimal
		default
		defined
		defines
		deleted
		desired
		display
		distant
		efforts
		endings
		entries
		example
		extrude
		follows
		foreach
		further
		getline
		getpgrp
		getppid
		hanging
		ignored
		implies
		include
		instead
		integer
		invalid
		keyword
		lcfirst
		leading
		lengths
		libpods
		logfile
		logical
		matched
		matches
		maximum
		md5_hex
		meaning
		memoize
		merging
		message
		minimum
		missing
		modules
		mystyle
		negated
		negates
		nesting
		nobrace
		nobreak
		nocheck
		nofuzzy
		noquiet
		nospace
		nostack
		numbers
		numeric
		opendir
		opening
		options
		outdent
		outfile
		package
		parsing
		passing
		pattern
		perhaps
		podpath
		podroot
		prevent
		problem
		profile
		program
		readdir
		reading
		regular
		require
		returns
		reverse
		rfields
		rtokens
		running
		sECTION
		scan_id
		scripts
		section
		seekdir
		seeking
		setpgrp
		setting
		shmread
		shouldn
		signals
		simpler
		skipped
		specify
		sprintf
		started
		storing
		strings
		suggest
		summary
		swallow
		symlink
		syscall
		sysopen
		sysread
		sysseek
		systems
		tabbing
		tabsize
		targets
		telldir
		ternary
		through
		trim_qw
		trinary
		trouble
		ucfirst
		unknown
		unshift
		unusual
		utility
		version
		waitpid
		warning
		without
		000000
		00688B
		100000
		228B22
		8B008B
		8B4513
		APPEND
		Allows
		B452CD
		CD5555
		CLOSED
		COLUMN
		Cannot
		Coding
		Config
		Couldn
		DIVIDE
		Delete
		Digest
		ENDCSS
		EXPECT
		Ending
		F0F0F0
		FF0000
		FFFFFF
		FIELDS
		FORMAT
		Getopt
		Giving
		Goatse
		MARKED
		NONAME
		Number
		OUTPUT
		Output
		PUBLIC
		Please
		Public
		SCALAR
		SCANID
		SPACES
		SPARSE
		STDERR
		STDOUT
		STRONG
		SYSTEM
		Scalar
		Should
		String
		Syntax
		TOKENS
		UNDOBP
		Unable
		Venus1
		Venus2
		WS_YES
		_rOpts
		_title
		accept
		allows
		almost
		always
		arrows
		backup
		before
		begins
		binary
		blanks
		blocks
		braces
		breaks
		called
		caller
		cannot
		caught
		caused
		causes
		change
		chroot
		ci_lev
		client
		column
		commas
		config
		copied
		couldn
		create
		dashes
		decode
		define
		delete
		depths
		device
		double
		editor
		effect
		ending
		entire
		errors
		except
		exists
		expand
		failed
		family
		fields
		fileno
		follow
		format
		formed
		frames
		freeze
		gmtime
		handle
		ignore
		indent
		infile
		insert
		italic
		itself
		labels
		length
		levels
		linked
		listed
		listen
		mangle
		manual
		method
		modify
		msgctl
		msgget
		msgrcv
		msgsnd
		needed
		nohtml
		noshow
		notabs
		notidy
		nowant
		number
		object
		opened
		option
		output
		packed
		passed
		passes
		places
		please
		prefix
		printf
		quoted
		quotes
		recent
		record
		remove
		rename
		report
		return
		rewind
		rindex
		safety
		scalar
		script
		search
		secret
		seeing
		select
		semctl
		semget
		sheets
		shmctl
		shmget
		should
		single
		socket
		source
		spaced
		spaces
		sparse
		splice
		square
		stable
		starts
		static
		stderr
		stream
		strict
		string
		substr
		switch
		syntax
		system
		taking
		target
		tested
		toggle
		tokens
		trying
		unable
		unless
		unlink
		unpack
		unused
		update
		useful
		valign
		values
		weight
		win32s
		writes
		xhtml1
		2long
		ANGLE
		ARRAY
		Added
		After
		Array
		BEGIN
		BLANK
		BLOCK
		BRACE
		BREAK
		Basic
		Blank
		Break
		CHECK
		Camel
		Comma
		DEBUG
		ERROR
		Error
		Extra
		FLUSH
		FORCE
		Final
		First
		Flush
		Found
		INDEX
		Index
		Input
		Kite1
		Kite2
		LABEL
		LEVEL
		MacOS
		Maybe
		NSCAN
		Other
		PAREN
		QUOTE
		STDIN
		STORE
		Short
		Space
		Start
		Steve
		TOKEN
		Thank
		There
		These
		Trace
		Usage
		Users
		Using
		WHITE
		WS_NO
		WinNT
		XHTML
		above
		added
		after
		ahead
		alarm
		alias
		align
		allow
		along
		angle
		apply
		array
		arrow
		atan2
		avoid
		bbvtl
		begin
		below
		black
		blank
		bless
		block
		brace
		break
		catch
		cause
		chdir
		check
		chmod
		chomp
		chown
		class
		close
		codes
		colon
		color
		comma
		could
		count
		crypt
		curly
		cycle
		depth
		digit
		elsif
		empty
		entab
		error
		exact
		extra
		fails
		fatal
		fcntl
		field
		file1
		file2
		file3
		files
		final
		fixed
		flags
		flock
		force
		forms
		found
		frame
		fuzzy
		given
		gives
		group
		index
		input
		ioctl
		items
		label
		large
		level
		lines
		lnext
		local
		logic
		loose
		lstat
		ltype
		major
		match
		maybe
		means
		mkdir
		multi
		names
		nconv
		never
		nhent
		nhtml
		nicer
		noadd
		nofoo
		nohbr
		nosbr
		noted
		notee
		nschb
		nscsb
		nsobb
		nsohb
		nsosb
		older
		opath
		order
		other
		pages
		paren
		place
		print
		quiet
		quote
		range
		regex
		rerun
		reset
		right
		rmdir
		rtype
		sbvtc
		seems
		semop
		seqno
		sheet
		shift
		short
		shown
		shows
		since
		sleep
		space
		split
		srand
		stack
		start
		state
		steps
		study
		style
		table
		takes
		terms
		there
		these
		think
		tight
		times
		tired
		title
		token
		trace
		treat
		turns
		types
		umask
		unary
		undef
		under
		untie
		until
		upper
		usage
		using
		utime
		valid
		value
		wants
		where
		which
		while
		white
		would
		write
		wrong
		xhtml
		xmlns
		$ENV
		1999
		2000
		2016
		8859
		ARGV
		BOND
		BUGS
		CODE
		CORE
		Code
		Copy
		DATA
		Didn
		Dump
		Even
		FILE
		File
		HASH
		HERE
		HOME
		HTML
		Hash
		Here
		Hint
		Html
		INIT
		JMAX
		LIST
		Last
		Line
		List
		Long
		NOTE
		Note
		Only
		Oops
		Perl
		Send
		Spec
		TABS
		TERM
		They
		This
		Tidy
		UTF8
		WEAK
		Your
		Zero
		_use
		able
		argv
		asbl
		auto
		baao
		bang
		bare
		bbao
		bbvt
		been
		best
		bext
		bind
		blbp
		blbs
		blil
		body
		bold
		book
		both
		bvtc
		call
		case
		cdsr
		chop
		code
		cols
		conv
		csbi
		cscb
		csce
		csci
		cscl
		cscp
		csct
		cscw
		dash
		dcsc
		didn
		does
		done
		dont
		dpro
		dump
		dwls
		dwrs
		each
		edit
		else
		eval
		even
		exec
		exit
		fail
		file
		find
		flag
		fmtd
		font
		fool
		fork
		form
		fpsc
		free
		from
		full
		getc
		glob
		goes
		goto
		grep
		hash
		have
		hcbg
		head
		help
		hent
		here
		home
		href
		html
		http
		imax
		imid
		into
		isbc
		iscl
		item
		iter
		jmax
		join
		just
		keep
		keys
		kill
		know
		last
		left
		less
		like
		line
		link
		list
		lock
		long
		look
		loop
		main
		make
		many
		mean
		mode
		more
		most
		must
		name
		nanl
		nasc
		nbaa
		nbbs
		ndac
		ndnl
		ndsc
		near
		need
		next
		nfrm
		nicp
		nlal
		nlsl
		nobr
		noll
		nolq
		none
		nopr
		notr
		npod
		npro
		npvl
		nsac
		nsak
		nscp
		nsct
		nsfs
		nsob
		nsop
		nsot
		ntac
		ntoc
		nwls
		nwrs
		oext
		ohbr
		okay
		okwl
		only
		open
		osbc
		osbr
		pack
		page
		pass
		path
		perl
		pipe
		pods
		pscf
		push
		pvtc
		quit
		quot
		rand
		read
		recv
		redo
		refs
		root
		rows
		same
		save
		sbcp
		sbvt
		scbb
		schb
		scsb
		seek
		seem
		seen
		send
		sets
		sext
		show
		side
		size
		skip
		slev
		slot
		sobb
		sohb
		some
		sort
		sosb
		span
		sqrt
		sscp
		stat
		subs
		such
		sure
		tabs
		take
		tell
		temp
		term
		test
		text
		than
		that
		then
		this
		tidy
		tied
		time
		trim
		true
		type
		undo
		unix
		used
		user
		uses
		utf8
		vars
		vary
		vmll
		void
		wait
		want
		warn
		were
		when
		wide
		will
		with
		wocb
		word
		work
		your
		zero
		$Id
		AND
		All
		Bug
		DIE
		DTD
		Did
		Doc
		END
		EOF
		EOM
		EOS
		ERR
		End
		Exp
		Fat
		For
		GNU
		Has
		Hit
		LOG
		MD5
		NOT
		NT3
		NT4
		Net
		New
		Non
		OS2
		Old
		POD
		Pod
		SRC
		See
		TEE
		The
		UTF
		Use
		VMS
		W3C
		You
		_fh
		abs
		act
		add
		all
		amp
		and
		anl
		any
		are
		asc
		aws
		baa
		bad
		bak
		bar
		bbb
		bbc
		bbs
		bbt
		big
		bli
		boa
		boc
		bok
		bol
		bot
		bug
		but
		bvt
		cab
		can
		cbi
		chr
		cmp
		cos
		cpi
		csc
		css
		cti
		cut
		dac
		dbc
		ddf
		die
		dln
		dnl
		doc
		don
		dop
		dos
		dsc
		dsm
		dsn
		dtd
		dtt
		due
		dws
		enc
		end
		eof
		err
		etc
		exp
		fbl
		fix
		fll
		fmt
		fnl
		foo
		for
		frm
		fsb
		fse
		fws
		gap
		get
		gnu
		got
		had
		has
		hex
		hit
		how
		hsc
		ibc
		icb
		icp
		ids
		ini
		int
		iob
		isn
		iso
		its
		kbl
		key
		kis
		lal
		lbl
		lev
		log
		lsl
		mac
		man
		map
		max
		may
		mbl
		mem
		mft
		msc
		net
		new
		nhb
		nhi
		nlp
		nnn
		non
		not
		nss
		oct
		off
		okl
		okw
		ola
		olc
		old
		ole
		olq
		one
		opr
		opt
		ord
		org
		otr
		our
		out
		pbp
		per
		ple
		pod
		pop
		pos
		pre
		pro
		put
		pvl
		pvt
		raw
		red
		ref
		rel
		row
		run
		sac
		sak
		saw
		say
		sbc
		sbl
		sbt
		scl
		scp
		sct
		see
		set
		sfp
		sfs
		sil
		sin
		skp
		sob
		sop
		sot
		src
		ssc
		str
		sts
		sub
		syn
		tab
		tac
		tag
		tbc
		tdy
		tee
		the
		tie
		toc
		tok
		too
		top
		tqw
		trp
		try
		tsc
		tso
		use
		usr
		vec
		vtc
		was
		wba
		wbb
		web
		win
		wls
		won
		wrs
		www
		xml
		xor
		yes
		yet
		you
		$$
		02
		03
		10
		11
		12
		13
		20
		30
		40
		49
		51
		56
		70
		74
		78
		80
		95
		98
		CI
		Do
		EN
		EQ
		GE
		GT
		IO
		If
		LE
		LT
		Me
		NE
		No
		OP
		TR
		To
		UL
		WS
		We
		XP
		an
		as
		at
		be
		bk
		bl
		bt
		by
		ce
		ch
		ci
		cm
		co
		do
		dp
		dt
		eq
		et
		fs
		ge
		go
		gt
		h1
		h2
		hb
		hc
		hh
		hi
		hr
		if
		in
		io
		is
		it
		lc
		le
		li
		lp
		lt
		mm
		my
		ne
		no
		nt
		of
		ok
		on
		or
		pd
		pl
		pm
		pp
		pt
		pu
		qq
		qr
		qw
		qx
		re
		sc
		se
		so
		sp
		ss
		st
		to
		tp
		tr
		uc
		ul
		un
		up
		vt
		w3
		wc
		we
		xs
		$
		0
		1
		2
		3
		4
		5
		6
		7
		8
		9
		A
		B
		C
		D
		F
		G
		H
		I
		J
		L
		M
		O
		P
		Q
		R
		S
		T
		U
		W
		X
		Y
		Z
		_
		a
		b
		c
		d
		e
		f
		g
		h
		i
		j
		k
		l
		m
		n
		o
		p
		q
		r
		s
		t
		u
		v
		w
		x
		y
		z
================================
#
############################################################
#
#    <COMMENTS>perltidy</COMMENTS> - <COMMENTS>a</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>script</COMMENTS> <COMMENTS>indenter</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>formatter</COMMENTS>
#
#    <COMMENTS>Copyright</COMMENTS> (<COMMENTS>c</COMMENTS>) <COMMENTS>2000</COMMENTS>-<COMMENTS>2016</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>Steve</COMMENTS> <COMMENTS>Hancock</COMMENTS>
#    <COMMENTS>Distributed</COMMENTS> <COMMENTS>under</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>GPL</COMMENTS> <COMMENTS>license</COMMENTS> <COMMENTS>agreement</COMMENTS>; <COMMENTS>see</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>COPYING</COMMENTS>
#
#    <COMMENTS>This</COMMENTS> <COMMENTS>program</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>free</COMMENTS> <COMMENTS>software</COMMENTS>; <COMMENTS>you</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>redistribute</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>and</COMMENTS>/<COMMENTS>or</COMMENTS> <COMMENTS>modify</COMMENTS>
#    <COMMENTS>it</COMMENTS> <COMMENTS>under</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>terms</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>GNU</COMMENTS> <COMMENTS>General</COMMENTS> <COMMENTS>Public</COMMENTS> <COMMENTS>License</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>published</COMMENTS> <COMMENTS>by</COMMENTS>
#    <COMMENTS>the</COMMENTS> <COMMENTS>Free</COMMENTS> <COMMENTS>Software</COMMENTS> <COMMENTS>Foundation</COMMENTS>; <COMMENTS>either</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>License</COMMENTS>, <COMMENTS>or</COMMENTS>
#    (<COMMENTS>at</COMMENTS> <COMMENTS>your</COMMENTS> <COMMENTS>option</COMMENTS>) <COMMENTS>any</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>version</COMMENTS>.
#
#    <COMMENTS>This</COMMENTS> <COMMENTS>program</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>distributed</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>hope</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>useful</COMMENTS>,
#    <COMMENTS>but</COMMENTS> <COMMENTS>WITHOUT</COMMENTS> <COMMENTS>ANY</COMMENTS> <COMMENTS>WARRANTY</COMMENTS>; <COMMENTS>without</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>implied</COMMENTS> <COMMENTS>warranty</COMMENTS> <COMMENTS>of</COMMENTS>
#    <COMMENTS>MERCHANTABILITY</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>FITNESS</COMMENTS> <COMMENTS>FOR</COMMENTS> <COMMENTS>A</COMMENTS> <COMMENTS>PARTICULAR</COMMENTS> <COMMENTS>PURPOSE</COMMENTS>.  <COMMENTS>See</COMMENTS> <COMMENTS>the</COMMENTS>
#    <COMMENTS>GNU</COMMENTS> <COMMENTS>General</COMMENTS> <COMMENTS>Public</COMMENTS> <COMMENTS>License</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>details</COMMENTS>.
#
#    <COMMENTS>You</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>received</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>copy</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>GNU</COMMENTS> <COMMENTS>General</COMMENTS> <COMMENTS>Public</COMMENTS> <COMMENTS>License</COMMENTS> <COMMENTS>along</COMMENTS>
#    <COMMENTS>with</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>program</COMMENTS>; <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS>, <COMMENTS>write</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>Free</COMMENTS> <COMMENTS>Software</COMMENTS> <COMMENTS>Foundation</COMMENTS>, <COMMENTS>Inc</COMMENTS>.,
#    <COMMENTS>51</COMMENTS> <COMMENTS>Franklin</COMMENTS> <COMMENTS>Street</COMMENTS>, <COMMENTS>Fifth</COMMENTS> <COMMENTS>Floor</COMMENTS>, <COMMENTS>Boston</COMMENTS>, <COMMENTS>MA</COMMENTS> <COMMENTS>02110</COMMENTS>-<COMMENTS>1301</COMMENTS> <COMMENTS>USA</COMMENTS>.
#
#    <COMMENTS>For</COMMENTS> <COMMENTS>brief</COMMENTS> <COMMENTS>instructions</COMMENTS>, <COMMENTS>try</COMMENTS> '<COMMENTS>perltidy</COMMENTS> -<COMMENTS>h</COMMENTS>'.
#    <COMMENTS>For</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>complete</COMMENTS> <COMMENTS>documentation</COMMENTS>, <COMMENTS>try</COMMENTS> '<COMMENTS>man</COMMENTS> <COMMENTS>perltidy</COMMENTS>'
#    <COMMENTS>or</COMMENTS> <COMMENTS>visit</COMMENTS> <COMMENTS>http</COMMENTS>://<COMMENTS>perltidy</COMMENTS>.<COMMENTS>sourceforge</COMMENTS>.<COMMENTS>net</COMMENTS>
#
#    <COMMENTS>This</COMMENTS> <COMMENTS>script</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>style</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>formatted</COMMENTS> <COMMENTS>with</COMMENTS>:
#
#      <COMMENTS>perltidy</COMMENTS> <COMMENTS>Tidy</COMMENTS>.<COMMENTS>pm</COMMENTS>
#
#    <COMMENTS>Code</COMMENTS> <COMMENTS>Contributions</COMMENTS>: <COMMENTS>See</COMMENTS> <COMMENTS>ChangeLog</COMMENTS>.<COMMENTS>html</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>complete</COMMENTS> <COMMENTS>history</COMMENTS>.
#      <COMMENTS>Michael</COMMENTS> <COMMENTS>Cartmell</COMMENTS> <COMMENTS>supplied</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>adaptation</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>VMS</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>helped</COMMENTS> <COMMENTS>with</COMMENTS>
#        <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS>.
#      <COMMENTS>Hugh</COMMENTS> <COMMENTS>S</COMMENTS>. <COMMENTS>Myers</COMMENTS> <COMMENTS>supplied</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>streamhandle</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>supporting</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>to</COMMENTS>
#        <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS> <COMMENTS>module</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>operate</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>strings</COMMENTS>, <COMMENTS>arrays</COMMENTS>, <COMMENTS>etc</COMMENTS>.
#      <COMMENTS>Yves</COMMENTS> <COMMENTS>Orton</COMMENTS> <COMMENTS>supplied</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>help</COMMENTS> <COMMENTS>detect</COMMENTS> <COMMENTS>Windows</COMMENTS> <COMMENTS>versions</COMMENTS>.
#      <COMMENTS>Axel</COMMENTS> <COMMENTS>Rose</COMMENTS> <COMMENTS>supplied</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>MacPerl</COMMENTS>.
#      <COMMENTS>Sebastien</COMMENTS> <COMMENTS>Aperghis</COMMENTS>-<COMMENTS>Tramoni</COMMENTS> <COMMENTS>supplied</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>operator</COMMENTS>.
#      <COMMENTS>Dan</COMMENTS> <COMMENTS>Tyrell</COMMENTS> <COMMENTS>contributed</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>binary</COMMENTS> <COMMENTS>I</COMMENTS>/<COMMENTS>O</COMMENTS>.
#      <COMMENTS>Ueli</COMMENTS> <COMMENTS>Hugenschmidt</COMMENTS> <COMMENTS>contributed</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> -<COMMENTS>fpsc</COMMENTS>
#      <COMMENTS>Sam</COMMENTS> <COMMENTS>Kington</COMMENTS> <COMMENTS>supplied</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>identify</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>initial</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS>
#      <COMMENTS>entabbed</COMMENTS> <COMMENTS>code</COMMENTS>.
#      <COMMENTS>jonathan</COMMENTS> <COMMENTS>swartz</COMMENTS> <COMMENTS>supplied</COMMENTS> <COMMENTS>patches</COMMENTS> <COMMENTS>for</COMMENTS>:
#      * .../ <COMMENTS>pattern</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>upwards</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>directory</COMMENTS>
#      * --<COMMENTS>notidy</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>directories</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS>
#        <COMMENTS>accidentally</COMMENTS> <COMMENTS>tidying</COMMENTS>
#      * <COMMENTS>prefilter</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>postfilter</COMMENTS>
#      * <COMMENTS>iterations</COMMENTS> <COMMENTS>option</COMMENTS>
#
#      <COMMENTS>Many</COMMENTS> <COMMENTS>others</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>supplied</COMMENTS> <COMMENTS>key</COMMENTS> <COMMENTS>ideas</COMMENTS>, <COMMENTS>suggestions</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>bug</COMMENTS> <COMMENTS>reports</COMMENTS>;
#        <COMMENTS>see</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>CHANGES</COMMENTS> <COMMENTS>file</COMMENTS>.
#
############################################################
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IOScalar</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IOScalarArray</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSource</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSink</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Diagnostics</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Logger</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>DevNull</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>HtmlWriter</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Formatter</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IndentationItem</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>::<CODE>Line</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>::<CODE>Alignment</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>FileWriter</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Debugger</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineBuffer</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Tokenizer</CODE>;
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>;

# <COMMENTS>Actually</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>about</COMMENTS> <COMMENTS>5</COMMENTS>.<COMMENTS>8</COMMENTS>.<COMMENTS>5</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS>
# <COMMENTS>wide</COMMENTS> <COMMENTS>characters</COMMENTS>.
use 5.004;    # <COMMENTS>need</COMMENTS> <COMMENTS>IO</COMMENTS>::<COMMENTS>File</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>5</COMMENTS>.<COMMENTS>004</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>later</COMMENTS>
use <CODE>warnings</CODE>;
use <CODE>strict</CODE>;
use <CODE>Exporter</CODE>;
use <CODE>Carp</CODE>;
$|++;

use <CODE>vars</CODE> qw{
  $<CODE>VERSION</CODE>
  @<CODE>ISA</CODE>
  @<CODE>EXPORT</CODE>
  $<CODE>missing_file_spec</CODE>
  $<CODE>fh_stderr</CODE>
  $<CODE>rOpts_character_encoding</CODE>
};

@<CODE>ISA</CODE>    = qw( <LITERALS>Exporter</LITERALS> );
@<CODE>EXPORT</CODE> = qw( &<LITERALS>perltidy</LITERALS> );

use <CODE>Cwd</CODE>;
use <CODE>Encode</CODE> ();
use <CODE>IO</CODE>::<CODE>File</CODE>;
use <CODE>File</CODE>::<CODE>Basename</CODE>;
use <CODE>File</CODE>::<CODE>Copy</CODE>;
use <CODE>File</CODE>::<CODE>Temp</CODE> qw(<LITERALS>tempfile</LITERALS>);

<CODE>BEGIN</CODE> {
    ( $<CODE>VERSION</CODE> = q(<LITERALS>$Id</LITERALS>: <LITERALS>Tidy</LITERALS>.<LITERALS>pm</LITERALS>,<LITERALS>v</LITERALS> <LITERALS>1</LITERALS>.<LITERALS>74</LITERALS> <LITERALS>2016</LITERALS>/<LITERALS>03</LITERALS>/<LITERALS>02</LITERALS> <LITERALS>13</LITERALS>:<LITERALS>56</LITERALS>:<LITERALS>49</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>Exp</LITERALS> <LITERALS>$</LITERALS>) ) =~ s/^.*\s+(\d+)\/(\d+)\/(\d+).*$/$<CODE>1</CODE>$<CODE>2</CODE>$<CODE>3</CODE>/; # <COMMENTS>all</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>MakeMaker</COMMENTS>
}

sub <CODE>streamhandle</CODE> {

    # <COMMENTS>given</COMMENTS> <COMMENTS>filename</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>mode</COMMENTS> (<COMMENTS>r</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>w</COMMENTS>), <COMMENTS>create</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>which</COMMENTS>:
    #   <COMMENTS>has</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>getline</COMMENTS>' <COMMENTS>method</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>mode</COMMENTS>='<COMMENTS>r</COMMENTS>', <COMMENTS>and</COMMENTS>
    #   <COMMENTS>has</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>print</COMMENTS>' <COMMENTS>method</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>mode</COMMENTS>='<COMMENTS>w</COMMENTS>'.
    # <COMMENTS>The</COMMENTS> <COMMENTS>objects</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>close</COMMENTS>' <COMMENTS>method</COMMENTS>.
    #
    # <COMMENTS>How</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>made</COMMENTS>:
    #
    # <COMMENTS>if</COMMENTS> <COMMENTS>$filename</COMMENTS> <COMMENTS>is</COMMENTS>:     <COMMENTS>Make</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>using</COMMENTS>:
    # ----------------     -----------------
    # '-'                  (<COMMENTS>STDIN</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>mode</COMMENTS> = '<COMMENTS>r</COMMENTS>', <COMMENTS>STDOUT</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>mode</COMMENTS>='<COMMENTS>w</COMMENTS>')
    # <COMMENTS>string</COMMENTS>               <COMMENTS>IO</COMMENTS>::<COMMENTS>File</COMMENTS>
    # <COMMENTS>ARRAY</COMMENTS>  <COMMENTS>ref</COMMENTS>           <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>IOScalarArray</COMMENTS> (<COMMENTS>formerly</COMMENTS> <COMMENTS>IO</COMMENTS>::<COMMENTS>ScalarArray</COMMENTS>)
    # <COMMENTS>STRING</COMMENTS> <COMMENTS>ref</COMMENTS>           <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>IOScalar</COMMENTS>      (<COMMENTS>formerly</COMMENTS> <COMMENTS>IO</COMMENTS>::<COMMENTS>Scalar</COMMENTS>)
    # <COMMENTS>object</COMMENTS>               <COMMENTS>object</COMMENTS>
    #                      (<COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> '<COMMENTS>print</COMMENTS>' <COMMENTS>method</COMMENTS> <COMMENTS>for</COMMENTS> '<COMMENTS>w</COMMENTS>' <COMMENTS>mode</COMMENTS>)
    #                      (<COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> '<COMMENTS>getline</COMMENTS>' <COMMENTS>method</COMMENTS> <COMMENTS>for</COMMENTS> '<COMMENTS>r</COMMENTS>' <COMMENTS>mode</COMMENTS>)
    my $<CODE>ref</CODE> = ref( my $<CODE>filename</CODE> = shift );
    my $<CODE>mode</CODE> = shift;
    my $<CODE>New</CODE>;
    my $<CODE>fh</CODE>;

    # <COMMENTS>handle</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>reference</COMMENTS>
    if ($<CODE>ref</CODE>) {
        if ( $<CODE>ref</CODE> eq '<LITERALS>ARRAY</LITERALS>' ) {
            $<CODE>New</CODE> = sub { <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IOScalarArray</CODE>-><CODE>new</CODE>(@<CODE>_</CODE>) };
        }
        elsif ( $<CODE>ref</CODE> eq '<LITERALS>SCALAR</LITERALS>' ) {
            $<CODE>New</CODE> = sub { <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IOScalar</CODE>-><CODE>new</CODE>(@<CODE>_</CODE>) };
        }
        else {

            # <COMMENTS>Accept</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>getline</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>reading</COMMENTS>. <COMMENTS>Note</COMMENTS>:
            # <COMMENTS>IO</COMMENTS>::<COMMENTS>File</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>built</COMMENTS>-<COMMENTS>in</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>respond</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>defined</COMMENTS>
            # <COMMENTS>operator</COMMENTS>.  <COMMENTS>If</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>causes</COMMENTS> <COMMENTS>trouble</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS>
            # <COMMENTS>skipped</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>crash</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS>
            # <COMMENTS>getline</COMMENTS>.
            if ( $<CODE>mode</CODE> =~ /[rR]/ ) {

                # <COMMENTS>RT</COMMENTS>#<COMMENTS>97159</COMMENTS>; <COMMENTS>part</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>2</COMMENTS>: <COMMENTS>updated</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> '<COMMENTS>can</COMMENTS>'
                ##<COMMENTS>if</COMMENTS> ( <COMMENTS>$ref</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>IO</COMMENTS>::<COMMENTS>File</COMMENTS>' || <COMMENTS>defined</COMMENTS> &{ <COMMENTS>$ref</COMMENTS> . "::<COMMENTS>getline</COMMENTS>" } ) {
                if ( $<CODE>ref</CODE>-><CODE>can</CODE>('<LITERALS>getline</LITERALS>') ) {
                    $<CODE>New</CODE> = sub { $<CODE>filename</CODE> };
                }
                else {
                    $<CODE>New</CODE> = sub { undef };
                    <CODE>confess</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>No</LITERALS> '<LITERALS>getline</LITERALS>' <LITERALS>method</LITERALS> <LITERALS>is</LITERALS> <LITERALS>defined</LITERALS> <LITERALS>for</LITERALS> <LITERALS>object</LITERALS> <LITERALS>of</LITERALS> <LITERALS>class</LITERALS> $<CODE>ref</CODE>
<LITERALS>Please</LITERALS> <LITERALS>check</LITERALS> <LITERALS>your</LITERALS> <LITERALS>call</LITERALS> <LITERALS>to</LITERALS> <LITERALS>Perl</LITERALS>::<LITERALS>Tidy</LITERALS>::<LITERALS>perltidy</LITERALS>.  <LITERALS>Trace</LITERALS> <LITERALS>follows</LITERALS>.
------------------------------------------------------------------------
<CODE>EOM</CODE>
                }
            }

            # <COMMENTS>Accept</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>print</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>writing</COMMENTS>.
            # <COMMENTS>See</COMMENTS> <COMMENTS>note</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>about</COMMENTS> <COMMENTS>IO</COMMENTS>::<COMMENTS>File</COMMENTS>
            if ( $<CODE>mode</CODE> =~ /[wW]/ ) {

                # <COMMENTS>RT</COMMENTS>#<COMMENTS>97159</COMMENTS>; <COMMENTS>part</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>2</COMMENTS>: <COMMENTS>updated</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> '<COMMENTS>can</COMMENTS>'
                ##<COMMENTS>if</COMMENTS> ( <COMMENTS>$ref</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>IO</COMMENTS>::<COMMENTS>File</COMMENTS>' || <COMMENTS>defined</COMMENTS> &{ <COMMENTS>$ref</COMMENTS> . "::<COMMENTS>print</COMMENTS>" } ) {
                if ( $<CODE>ref</CODE>-><CODE>can</CODE>('<LITERALS>print</LITERALS>') ) {
                    $<CODE>New</CODE> = sub { $<CODE>filename</CODE> };
                }
                else {
                    $<CODE>New</CODE> = sub { undef };
                    <CODE>confess</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>No</LITERALS> '<LITERALS>print</LITERALS>' <LITERALS>method</LITERALS> <LITERALS>is</LITERALS> <LITERALS>defined</LITERALS> <LITERALS>for</LITERALS> <LITERALS>object</LITERALS> <LITERALS>of</LITERALS> <LITERALS>class</LITERALS> $<CODE>ref</CODE>
<LITERALS>Please</LITERALS> <LITERALS>check</LITERALS> <LITERALS>your</LITERALS> <LITERALS>call</LITERALS> <LITERALS>to</LITERALS> <LITERALS>Perl</LITERALS>::<LITERALS>Tidy</LITERALS>::<LITERALS>perltidy</LITERALS>. <LITERALS>Trace</LITERALS> <LITERALS>follows</LITERALS>.
------------------------------------------------------------------------
<CODE>EOM</CODE>
                }
            }
        }
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS>
    else {
        if ( $<CODE>filename</CODE> eq '-' ) {
            $<CODE>New</CODE> = sub { $<CODE>mode</CODE> eq '<LITERALS>w</LITERALS>' ? *<CODE>STDOUT</CODE> : *<CODE>STDIN</CODE> }
        }
        else {
            $<CODE>New</CODE> = sub { <CODE>IO</CODE>::<CODE>File</CODE>-><CODE>new</CODE>(@<CODE>_</CODE>) };
        }
    }
    $<CODE>fh</CODE> = $<CODE>New</CODE>->( $<CODE>filename</CODE>, $<CODE>mode</CODE> )
      or <CODE>Warn</CODE>("<LITERALS>Couldn</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>open</LITERALS> <LITERALS>file</LITERALS>:$<CODE>filename</CODE> <LITERALS>in</LITERALS> <LITERALS>mode</LITERALS>:$<CODE>mode</CODE> : $!\n");

    return $<CODE>fh</CODE>, ( $<CODE>ref</CODE> or $<CODE>filename</CODE> );
}

sub <CODE>find_input_line_ending</CODE> {

    # <COMMENTS>Peek</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>character</COMMENTS>.
    # <COMMENTS>Quietly</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>undef</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>trouble</COMMENTS>.
    my ($<CODE>input_file</CODE>) = @<CODE>_</CODE>;
    my $<CODE>ending</CODE>;

    # <COMMENTS>silently</COMMENTS> <COMMENTS>ignore</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>stdin</COMMENTS>
    if ( ref($<CODE>input_file</CODE>) || $<CODE>input_file</CODE> eq '-' ) {
        return $<CODE>ending</CODE>;
    }
    open( <CODE>INFILE</CODE>, $<CODE>input_file</CODE> ) || return $<CODE>ending</CODE>;

    binmode <CODE>INFILE</CODE>;
    my $<CODE>buf</CODE>;
    read( <CODE>INFILE</CODE>, $<CODE>buf</CODE>, 1024 );
    close <CODE>INFILE</CODE>;
    if ( $<CODE>buf</CODE> && $<CODE>buf</CODE> =~ /([\012\015]+)/ ) {
        my $<CODE>test</CODE> = $<CODE>1</CODE>;

        # <COMMENTS>dos</COMMENTS>
        if ( $<CODE>test</CODE> =~ /^(\015\012)+$/ ) { $<CODE>ending</CODE> = "\015\012" }

        # <COMMENTS>mac</COMMENTS>
        elsif ( $<CODE>test</CODE> =~ /^\015+$/ ) { $<CODE>ending</CODE> = "\015" }

        # <COMMENTS>unix</COMMENTS>
        elsif ( $<CODE>test</CODE> =~ /^\012+$/ ) { $<CODE>ending</CODE> = "\012" }

        # <COMMENTS>unknown</COMMENTS>
        else { }
    }

    # <COMMENTS>no</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>seen</COMMENTS>
    else { }

    return $<CODE>ending</CODE>;
}

sub <CODE>catfile</CODE> {

    # <COMMENTS>concatenate</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>path</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>basename</COMMENTS>
    # <COMMENTS>returns</COMMENTS> <COMMENTS>undef</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>error</COMMENTS>

    <CODE>BEGIN</CODE> { eval "<LITERALS>require</LITERALS> <LITERALS>File</LITERALS>::<LITERALS>Spec</LITERALS>"; $<CODE>missing_file_spec</CODE> = $@; }

    # <COMMENTS>use</COMMENTS> <COMMENTS>File</COMMENTS>::<COMMENTS>Spec</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS>
    unless ($<CODE>missing_file_spec</CODE>) {
        return <CODE>File</CODE>::<CODE>Spec</CODE>-><CODE>catfile</CODE>(@<CODE>_</CODE>);
    }

    # <COMMENTS>Perl</COMMENTS> <COMMENTS>5</COMMENTS>.<COMMENTS>004</COMMENTS> <COMMENTS>systems</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>File</COMMENTS>::<COMMENTS>Spec</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>make</COMMENTS>
    # <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>try</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>assume</COMMENTS> <COMMENTS>File</COMMENTS>::<COMMENTS>Basename</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>available</COMMENTS>.
    # <COMMENTS>return</COMMENTS> <COMMENTS>undef</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>successful</COMMENTS>.
    my $<CODE>name</CODE>      = pop @<CODE>_</CODE>;
    my $<CODE>path</CODE>      = join '/', @<CODE>_</CODE>;
    my $<CODE>test_file</CODE> = $<CODE>path</CODE> . $<CODE>name</CODE>;
    my ( $<CODE>test_name</CODE>, $<CODE>test_path</CODE> ) = <CODE>fileparse</CODE>($<CODE>test_file</CODE>);
    return $<CODE>test_file</CODE> if ( $<CODE>test_name</CODE> eq $<CODE>name</CODE> );
    return undef if ( $^<CODE>O</CODE> eq '<LITERALS>VMS</LITERALS>' );

    # <COMMENTS>this</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>Windows</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>Unix</COMMENTS>:
    $<CODE>test_file</CODE> = $<CODE>path</CODE> . '/' . $<CODE>name</CODE>;
    ( $<CODE>test_name</CODE>, $<CODE>test_path</CODE> ) = <CODE>fileparse</CODE>($<CODE>test_file</CODE>);
    return $<CODE>test_file</CODE> if ( $<CODE>test_name</CODE> eq $<CODE>name</CODE> );
    return undef;
}

# <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>map</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>flow</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>data</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS>
# <COMMENTS>line</COMMENTS> <COMMENTS>sink</COMMENTS>:
#
# <COMMENTS>LineSource</COMMENTS>--><COMMENTS>Tokenizer</COMMENTS>--><COMMENTS>Formatter</COMMENTS>--><COMMENTS>VerticalAligner</COMMENTS>--><COMMENTS>FileWriter</COMMENTS>-->
#       <COMMENTS>input</COMMENTS>                         <COMMENTS>groups</COMMENTS>                 <COMMENTS>output</COMMENTS>
#       <COMMENTS>lines</COMMENTS>   <COMMENTS>tokens</COMMENTS>      <COMMENTS>lines</COMMENTS>       <COMMENTS>of</COMMENTS>          <COMMENTS>lines</COMMENTS>    <COMMENTS>lines</COMMENTS>
#                                      <COMMENTS>lines</COMMENTS>
#
# <COMMENTS>The</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>correspond</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>responsible</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>unit</COMMENTS> <COMMENTS>processes</COMMENTS>.
#
# <COMMENTS>The</COMMENTS> <COMMENTS>overall</COMMENTS> <COMMENTS>process</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>controlled</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> "<COMMENTS>main</COMMENTS>" <COMMENTS>package</COMMENTS>.
#
# <COMMENTS>LineSource</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>stream</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>lines</COMMENTS>
#
# <COMMENTS>Tokenizer</COMMENTS> <COMMENTS>analyzes</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>peeking</COMMENTS> <COMMENTS>ahead</COMMENTS>
# <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>.  <COMMENTS>A</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS>
# <COMMENTS>manipulated</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>entity</COMMENTS> <COMMENTS>during</COMMENTS> <COMMENTS>formatting</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS>
# ',' <COMMENTS>character</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>entire</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>handles</COMMENTS>
# <COMMENTS>the</COMMENTS> <COMMENTS>complexities</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>Perl</COMMENTS> <COMMENTS>syntax</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>distinguishing</COMMENTS> <COMMENTS>between</COMMENTS> '<<' <COMMENTS>as</COMMENTS>
# <COMMENTS>a</COMMENTS> <COMMENTS>shift</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>document</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>distinguishing</COMMENTS> <COMMENTS>between</COMMENTS> '/'
# <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>divide</COMMENTS> <COMMENTS>symbol</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>delimiter</COMMENTS>.
#
# <COMMENTS>Formatter</COMMENTS> <COMMENTS>inserts</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>deletes</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>breaks</COMMENTS>
# <COMMENTS>sequences</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>appropriate</COMMENTS> <COMMENTS>points</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>lines</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>bases</COMMENTS> <COMMENTS>its</COMMENTS>
# <COMMENTS>decisions</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>modified</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>command</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>options</COMMENTS>.
#
# <COMMENTS>VerticalAligner</COMMENTS> <COMMENTS>collects</COMMENTS> <COMMENTS>groups</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>together</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>tries</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS>
# <COMMENTS>certain</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> '=>', '#', <COMMENTS>and</COMMENTS> '=' <COMMENTS>by</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>whitespace</COMMENTS>.
#
# <COMMENTS>FileWriter</COMMENTS> <COMMENTS>simply</COMMENTS> <COMMENTS>writes</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>.
#
# <COMMENTS>The</COMMENTS> <COMMENTS>Logger</COMMENTS> <COMMENTS>package</COMMENTS>, <COMMENTS>not</COMMENTS> <COMMENTS>shown</COMMENTS>, <COMMENTS>records</COMMENTS> <COMMENTS>significant</COMMENTS> <COMMENTS>events</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>warning</COMMENTS>
# <COMMENTS>messages</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>writes</COMMENTS> <COMMENTS>a</COMMENTS> .<COMMENTS>LOG</COMMENTS> <COMMENTS>file</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>saved</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS>
# '-<COMMENTS>log</COMMENTS>' <COMMENTS>or</COMMENTS> <COMMENTS>a</COMMENTS> '-<COMMENTS>g</COMMENTS>' <COMMENTS>flag</COMMENTS>.

sub <CODE>perltidy</CODE> {

    my %<CODE>defaults</CODE> = (
        <LITERALS>argv</LITERALS>                  => undef,
        <LITERALS>destination</LITERALS>           => undef,
        <LITERALS>formatter</LITERALS>             => undef,
        <LITERALS>logfile</LITERALS>               => undef,
        <LITERALS>errorfile</LITERALS>             => undef,
        <LITERALS>perltidyrc</LITERALS>            => undef,
        <LITERALS>source</LITERALS>                => undef,
        <LITERALS>stderr</LITERALS>                => undef,
        <LITERALS>dump_options</LITERALS>          => undef,
        <LITERALS>dump_options_type</LITERALS>     => undef,
        <LITERALS>dump_getopt_flags</LITERALS>     => undef,
        <LITERALS>dump_options_category</LITERALS> => undef,
        <LITERALS>dump_options_range</LITERALS>    => undef,
        <LITERALS>dump_abbreviations</LITERALS>    => undef,
        <LITERALS>prefilter</LITERALS>             => undef,
        <LITERALS>postfilter</LITERALS>            => undef,
    );

    # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>overwrite</COMMENTS> <COMMENTS>callers</COMMENTS> <COMMENTS>ARGV</COMMENTS>
    local @<CODE>ARGV</CODE>   = @<CODE>ARGV</CODE>;
    local *<CODE>STDERR</CODE> = *<CODE>STDERR</CODE>;

    my %<CODE>input_hash</CODE> = @<CODE>_</CODE>;

    if ( my @<CODE>bad_keys</CODE> = grep { !exists $<CODE>defaults</CODE>{$<CODE>_</CODE>} } keys %<CODE>input_hash</CODE> ) {
        local $" = ')(';
        my @<CODE>good_keys</CODE> = sort keys %<CODE>defaults</CODE>;
        @<CODE>bad_keys</CODE> = sort @<CODE>bad_keys</CODE>;
        <CODE>confess</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>Unknown</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>parameter</LITERALS> : (@<CODE>bad_keys</CODE>)
<LITERALS>perltidy</LITERALS> <LITERALS>only</LITERALS> <LITERALS>understands</LITERALS> : (@<CODE>good_keys</CODE>)
------------------------------------------------------------------------

<CODE>EOM</CODE>
    }

    my $<CODE>get_hash_ref</CODE> = sub {
        my ($<CODE>key</CODE>) = @<CODE>_</CODE>;
        my $<CODE>hash_ref</CODE> = $<CODE>input_hash</CODE>{$<CODE>key</CODE>};
        if ( defined($<CODE>hash_ref</CODE>) ) {
            unless ( ref($<CODE>hash_ref</CODE>) eq '<LITERALS>HASH</LITERALS>' ) {
                my $<CODE>what</CODE> = ref($<CODE>hash_ref</CODE>);
                my $<CODE>but_is</CODE> =
                  $<CODE>what</CODE> ? "<LITERALS>but</LITERALS> <LITERALS>is</LITERALS> <LITERALS>ref</LITERALS> <LITERALS>to</LITERALS> $<CODE>what</CODE>" : "<LITERALS>but</LITERALS> <LITERALS>is</LITERALS> <LITERALS>not</LITERALS> <LITERALS>a</LITERALS> <LITERALS>reference</LITERALS>";
                <CODE>croak</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>error</LITERALS> <LITERALS>in</LITERALS> <LITERALS>call</LITERALS> <LITERALS>to</LITERALS> <LITERALS>perltidy</LITERALS>:
-$<CODE>key</CODE> <LITERALS>must</LITERALS> <LITERALS>be</LITERALS> <LITERALS>reference</LITERALS> <LITERALS>to</LITERALS> <LITERALS>HASH</LITERALS> $<CODE>but_is</CODE>
------------------------------------------------------------------------
<CODE>EOM</CODE>
            }
        }
        return $<CODE>hash_ref</CODE>;
    };

    %<CODE>input_hash</CODE> = ( %<CODE>defaults</CODE>, %<CODE>input_hash</CODE> );
    my $<CODE>argv</CODE>               = $<CODE>input_hash</CODE>{'<LITERALS>argv</LITERALS>'};
    my $<CODE>destination_stream</CODE> = $<CODE>input_hash</CODE>{'<LITERALS>destination</LITERALS>'};
    my $<CODE>errorfile_stream</CODE>   = $<CODE>input_hash</CODE>{'<LITERALS>errorfile</LITERALS>'};
    my $<CODE>logfile_stream</CODE>     = $<CODE>input_hash</CODE>{'<LITERALS>logfile</LITERALS>'};
    my $<CODE>perltidyrc_stream</CODE>  = $<CODE>input_hash</CODE>{'<LITERALS>perltidyrc</LITERALS>'};
    my $<CODE>source_stream</CODE>      = $<CODE>input_hash</CODE>{'<LITERALS>source</LITERALS>'};
    my $<CODE>stderr_stream</CODE>      = $<CODE>input_hash</CODE>{'<LITERALS>stderr</LITERALS>'};
    my $<CODE>user_formatter</CODE>     = $<CODE>input_hash</CODE>{'<LITERALS>formatter</LITERALS>'};
    my $<CODE>prefilter</CODE>          = $<CODE>input_hash</CODE>{'<LITERALS>prefilter</LITERALS>'};
    my $<CODE>postfilter</CODE>         = $<CODE>input_hash</CODE>{'<LITERALS>postfilter</LITERALS>'};

    if ($<CODE>stderr_stream</CODE>) {
        ( $<CODE>fh_stderr</CODE>, my $<CODE>stderr_file</CODE> ) =
          <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>streamhandle</CODE>( $<CODE>stderr_stream</CODE>, '<LITERALS>w</LITERALS>' );
        if ( !$<CODE>fh_stderr</CODE> ) {
            <CODE>croak</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>Unable</LITERALS> <LITERALS>to</LITERALS> <LITERALS>redirect</LITERALS> <LITERALS>STDERR</LITERALS> <LITERALS>to</LITERALS> $<CODE>stderr_stream</CODE>
<LITERALS>Please</LITERALS> <LITERALS>check</LITERALS> <LITERALS>value</LITERALS> <LITERALS>of</LITERALS> -<LITERALS>stderr</LITERALS> <LITERALS>in</LITERALS> <LITERALS>call</LITERALS> <LITERALS>to</LITERALS> <LITERALS>perltidy</LITERALS>
------------------------------------------------------------------------
<CODE>EOM</CODE>
        }
    }
    else {
        $<CODE>fh_stderr</CODE> = *<CODE>STDERR</CODE>;
    }

    sub <CODE>Warn</CODE> ($) { $<CODE>fh_stderr</CODE>-><CODE>print</CODE>( $<CODE>_</CODE>[0] ); }

    sub <CODE>Exit</CODE> ($) {
        if   ( $<CODE>_</CODE>[0] ) { goto <CODE>ERROR_EXIT</CODE> }
        else           { goto <CODE>NORMAL_EXIT</CODE> }
    }

    sub <CODE>Die</CODE> ($) { <CODE>Warn</CODE> $<CODE>_</CODE>[0]; <CODE>Exit</CODE>(1); }

    # <COMMENTS>extract</COMMENTS> <COMMENTS>various</COMMENTS> <COMMENTS>dump</COMMENTS> <COMMENTS>parameters</COMMENTS>
    my $<CODE>dump_options_type</CODE>     = $<CODE>input_hash</CODE>{'<LITERALS>dump_options_type</LITERALS>'};
    my $<CODE>dump_options</CODE>          = $<CODE>get_hash_ref</CODE>->('<LITERALS>dump_options</LITERALS>');
    my $<CODE>dump_getopt_flags</CODE>     = $<CODE>get_hash_ref</CODE>->('<LITERALS>dump_getopt_flags</LITERALS>');
    my $<CODE>dump_options_category</CODE> = $<CODE>get_hash_ref</CODE>->('<LITERALS>dump_options_category</LITERALS>');
    my $<CODE>dump_abbreviations</CODE>    = $<CODE>get_hash_ref</CODE>->('<LITERALS>dump_abbreviations</LITERALS>');
    my $<CODE>dump_options_range</CODE>    = $<CODE>get_hash_ref</CODE>->('<LITERALS>dump_options_range</LITERALS>');

    # <COMMENTS>validate</COMMENTS> <COMMENTS>dump_options_type</COMMENTS>
    if ( defined($<CODE>dump_options</CODE>) ) {
        unless ( defined($<CODE>dump_options_type</CODE>) ) {
            $<CODE>dump_options_type</CODE> = '<LITERALS>perltidyrc</LITERALS>';
        }
        unless ( $<CODE>dump_options_type</CODE> =~ /^(perltidyrc|full)$/ ) {
            <CODE>croak</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>Please</LITERALS> <LITERALS>check</LITERALS> <LITERALS>value</LITERALS> <LITERALS>of</LITERALS> -<LITERALS>dump_options_type</LITERALS> <LITERALS>in</LITERALS> <LITERALS>call</LITERALS> <LITERALS>to</LITERALS> <LITERALS>perltidy</LITERALS>;
<LITERALS>saw</LITERALS>: '$<CODE>dump_options_type</CODE>'
<LITERALS>expecting</LITERALS>: '<LITERALS>perltidyrc</LITERALS>' <LITERALS>or</LITERALS> '<LITERALS>full</LITERALS>'
------------------------------------------------------------------------
<CODE>EOM</CODE>

        }
    }
    else {
        $<CODE>dump_options_type</CODE> = "";
    }

    if ($<CODE>user_formatter</CODE>) {

        # <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>defines</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>formatter</COMMENTS>, <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>,
        # <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>null</COMMENTS> <COMMENTS>stream</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>simple</COMMENTS>
        $<CODE>destination_stream</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>DevNull</CODE>-><CODE>new</CODE>();
    }

    # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>ARGV</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>overridden</COMMENTS>
    if ( defined($<CODE>argv</CODE>) ) {

        my $<CODE>rargv</CODE> = ref $<CODE>argv</CODE>;
        if ( $<CODE>rargv</CODE> eq '<LITERALS>SCALAR</LITERALS>' ) { $<CODE>argv</CODE> = $$<CODE>argv</CODE>; $<CODE>rargv</CODE> = undef }

        # <COMMENTS>ref</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>ARRAY</COMMENTS>
        if ($<CODE>rargv</CODE>) {
            if ( $<CODE>rargv</CODE> eq '<LITERALS>ARRAY</LITERALS>' ) {
                @<CODE>ARGV</CODE> = @$<CODE>argv</CODE>;
            }
            else {
                <CODE>croak</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>Please</LITERALS> <LITERALS>check</LITERALS> <LITERALS>value</LITERALS> <LITERALS>of</LITERALS> -<LITERALS>argv</LITERALS> <LITERALS>in</LITERALS> <LITERALS>call</LITERALS> <LITERALS>to</LITERALS> <LITERALS>perltidy</LITERALS>;
<LITERALS>it</LITERALS> <LITERALS>must</LITERALS> <LITERALS>be</LITERALS> <LITERALS>a</LITERALS> <LITERALS>string</LITERALS> <LITERALS>or</LITERALS> <LITERALS>ref</LITERALS> <LITERALS>to</LITERALS> <LITERALS>ARRAY</LITERALS> <LITERALS>but</LITERALS> <LITERALS>is</LITERALS>: $<CODE>rargv</CODE>
------------------------------------------------------------------------
<CODE>EOM</CODE>
            }
        }

        # <COMMENTS>string</COMMENTS>
        else {
            my ( $<CODE>rargv</CODE>, $<CODE>msg</CODE> ) = <CODE>parse_args</CODE>($<CODE>argv</CODE>);
            if ($<CODE>msg</CODE>) {
                <CODE>Die</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>Error</LITERALS> <LITERALS>parsing</LITERALS> <LITERALS>this</LITERALS> <LITERALS>string</LITERALS> <LITERALS>passed</LITERALS> <LITERALS>to</LITERALS> <LITERALS>to</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>with</LITERALS> '<LITERALS>argv</LITERALS>':
$<CODE>msg</CODE>
<CODE>EOM</CODE>
            }
            @<CODE>ARGV</CODE> = @{$<CODE>rargv</CODE>};
        }
    }

    my $<CODE>rpending_complaint</CODE>;
    $$<CODE>rpending_complaint</CODE> = "";
    my $<CODE>rpending_logfile_message</CODE>;
    $$<CODE>rpending_logfile_message</CODE> = "";

    my ( $<CODE>is_Windows</CODE>, $<CODE>Windows_type</CODE> ) = <CODE>look_for_Windows</CODE>($<CODE>rpending_complaint</CODE>);

    # <COMMENTS>VMS</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>restricted</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>40</COMMENTS>.<COMMENTS>40</COMMENTS> <COMMENTS>format</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>_tdy</COMMENTS>
    # <COMMENTS>instead</COMMENTS> <COMMENTS>of</COMMENTS> .<COMMENTS>tdy</COMMENTS>, <COMMENTS>etc</COMMENTS>. (<COMMENTS>but</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>check_vms_filename</COMMENTS>)
    my $<CODE>dot</CODE>;
    my $<CODE>dot_pattern</CODE>;
    if ( $^<CODE>O</CODE> eq '<LITERALS>VMS</LITERALS>' ) {
        $<CODE>dot</CODE>         = '<LITERALS>_</LITERALS>';
        $<CODE>dot_pattern</CODE> = '<LITERALS>_</LITERALS>';
    }
    else {
        $<CODE>dot</CODE>         = '.';
        $<CODE>dot_pattern</CODE> = '\.';    # <COMMENTS>must</COMMENTS> <COMMENTS>escape</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>regex</COMMENTS>
    }

    #---------------------------------------------------------------
    # <COMMENTS>get</COMMENTS> <COMMENTS>command</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>options</COMMENTS>
    #---------------------------------------------------------------
    my ( $<CODE>rOpts</CODE>, $<CODE>config_file</CODE>, $<CODE>rraw_options</CODE>, $<CODE>roption_string</CODE>,
        $<CODE>rexpansion</CODE>, $<CODE>roption_category</CODE>, $<CODE>roption_range</CODE> )
      = <CODE>process_command_line</CODE>(
        $<CODE>perltidyrc_stream</CODE>,  $<CODE>is_Windows</CODE>, $<CODE>Windows_type</CODE>,
        $<CODE>rpending_complaint</CODE>, $<CODE>dump_options_type</CODE>,
      );

    my $<CODE>saw_extrude</CODE> = ( grep m/^-extrude$/, @$<CODE>rraw_options</CODE> ) ? 1 : 0;
    my $<CODE>saw_pbp</CODE> =
      ( grep m/^-(pbp|perl-best-practices)$/, @$<CODE>rraw_options</CODE> ) ? 1 : 0;

    #---------------------------------------------------------------
    # <COMMENTS>Handle</COMMENTS> <COMMENTS>requests</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>dump</COMMENTS> <COMMENTS>information</COMMENTS>
    #---------------------------------------------------------------

    # <COMMENTS>return</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>exit</COMMENTS> <COMMENTS>immediately</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>dumps</COMMENTS>
    my $<CODE>quit_now</CODE> = 0;

    # <COMMENTS>Getopt</COMMENTS> <COMMENTS>parameters</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>flags</COMMENTS>
    if ( defined($<CODE>dump_getopt_flags</CODE>) ) {
        $<CODE>quit_now</CODE> = 1;
        foreach my $<CODE>op</CODE> ( @{$<CODE>roption_string</CODE>} ) {
            my $<CODE>opt</CODE>  = $<CODE>op</CODE>;
            my $<CODE>flag</CODE> = "";

            # <COMMENTS>Examples</COMMENTS>:
            #  <COMMENTS>some</COMMENTS>-<COMMENTS>option</COMMENTS>=<COMMENTS>s</COMMENTS>
            #  <COMMENTS>some</COMMENTS>-<COMMENTS>option</COMMENTS>=<COMMENTS>i</COMMENTS>
            #  <COMMENTS>some</COMMENTS>-<COMMENTS>option</COMMENTS>:<COMMENTS>i</COMMENTS>
            #  <COMMENTS>some</COMMENTS>-<COMMENTS>option</COMMENTS>!
            if ( $<CODE>opt</CODE> =~ /(.*)(!|=.*|:.*)$/ ) {
                $<CODE>opt</CODE>  = $<CODE>1</CODE>;
                $<CODE>flag</CODE> = $<CODE>2</CODE>;
            }
            $<CODE>dump_getopt_flags</CODE>->{$<CODE>opt</CODE>} = $<CODE>flag</CODE>;
        }
    }

    if ( defined($<CODE>dump_options_category</CODE>) ) {
        $<CODE>quit_now</CODE> = 1;
        %{$<CODE>dump_options_category</CODE>} = %{$<CODE>roption_category</CODE>};
    }

    if ( defined($<CODE>dump_options_range</CODE>) ) {
        $<CODE>quit_now</CODE> = 1;
        %{$<CODE>dump_options_range</CODE>} = %{$<CODE>roption_range</CODE>};
    }

    if ( defined($<CODE>dump_abbreviations</CODE>) ) {
        $<CODE>quit_now</CODE> = 1;
        %{$<CODE>dump_abbreviations</CODE>} = %{$<CODE>rexpansion</CODE>};
    }

    if ( defined($<CODE>dump_options</CODE>) ) {
        $<CODE>quit_now</CODE> = 1;
        %{$<CODE>dump_options</CODE>} = %{$<CODE>rOpts</CODE>};
    }

    <CODE>Exit</CODE> 0 if ($<CODE>quit_now</CODE>);

    # <COMMENTS>make</COMMENTS> <COMMENTS>printable</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>run</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>diagnostic</COMMENTS>
    my $<CODE>readable_options</CODE> = <CODE>readable_options</CODE>( $<CODE>rOpts</CODE>, $<CODE>roption_string</CODE> );

    # <COMMENTS>dump</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>command</COMMENTS> <COMMENTS>line</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>dump</LITERALS>-<LITERALS>options</LITERALS>'} ) {
        print <CODE>STDOUT</CODE> $<CODE>readable_options</CODE>;
        <CODE>Exit</CODE> 0;
    }

    #---------------------------------------------------------------
    # <COMMENTS>check</COMMENTS> <COMMENTS>parameters</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>interactions</COMMENTS>
    #---------------------------------------------------------------
    my $<CODE>tabsize</CODE> =
      <CODE>check_options</CODE>( $<CODE>rOpts</CODE>, $<CODE>is_Windows</CODE>, $<CODE>Windows_type</CODE>, $<CODE>rpending_complaint</CODE> );

    if ($<CODE>user_formatter</CODE>) {
        $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'} = '<LITERALS>user</LITERALS>';
    }

    # <COMMENTS>there</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>entry</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>every</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>format</COMMENTS>
    my %<CODE>default_file_extension</CODE> = (
        <LITERALS>tidy</LITERALS> => '<LITERALS>tdy</LITERALS>',
        <LITERALS>html</LITERALS> => '<LITERALS>html</LITERALS>',
        <LITERALS>user</LITERALS> => '',
    );

    $<CODE>rOpts_character_encoding</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>character</LITERALS>-<LITERALS>encoding</LITERALS>'};

    # <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>format</COMMENTS>
    unless ( exists $<CODE>default_file_extension</CODE>{ $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'} } ) {
        my $<CODE>formats</CODE> = join ' ',
          sort map { "'" . $<CODE>_</CODE> . "'" } keys %<CODE>default_file_extension</CODE>;
        my $<CODE>fmt</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'};
        <CODE>Die</CODE> "-<LITERALS>format</LITERALS>='$<CODE>fmt</CODE>' <LITERALS>but</LITERALS> <LITERALS>must</LITERALS> <LITERALS>be</LITERALS> <LITERALS>one</LITERALS> <LITERALS>of</LITERALS>: $<CODE>formats</CODE>\n";
    }

    my $<CODE>output_extension</CODE> = <CODE>make_extension</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>output</LITERALS>-<LITERALS>file</LITERALS>-<LITERALS>extension</LITERALS>'},
        $<CODE>default_file_extension</CODE>{ $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'} }, $<CODE>dot</CODE> );

    # <COMMENTS>If</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>backup</COMMENTS> <COMMENTS>extension</COMMENTS> <COMMENTS>contains</COMMENTS> <COMMENTS>a</COMMENTS> / <COMMENTS>character</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>backup</COMMENTS> <COMMENTS>should</COMMENTS>
    # <COMMENTS>be</COMMENTS> <COMMENTS>deleted</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>b</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>.   <COMMENTS>On</COMMENTS> <COMMENTS>older</COMMENTS> <COMMENTS>versions</COMMENTS> <COMMENTS>of</COMMENTS>
    # <COMMENTS>perltidy</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>generate</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>message</COMMENTS> <COMMENTS>due</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>illegal</COMMENTS>
    # <COMMENTS>file</COMMENTS> <COMMENTS>name</COMMENTS>.
    #
    # <COMMENTS>A</COMMENTS> <COMMENTS>backup</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>generated</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>deleted</COMMENTS>
    # <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS>.  <COMMENTS>If</COMMENTS> -<COMMENTS>bext</COMMENTS>='/' <COMMENTS>then</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>extension</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS> '<COMMENTS>bak</COMMENTS>'.  <COMMENTS>Otherwise</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>whatever</COMMENTS> <COMMENTS>characters</COMMENTS>
    # <COMMENTS>remains</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>all</COMMENTS> '/' <COMMENTS>characters</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>removed</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>:
    # -<COMMENTS>bext</COMMENTS>         <COMMENTS>extension</COMMENTS>     <COMMENTS>slashes</COMMENTS>
    #  '/'          <COMMENTS>bak</COMMENTS>           <COMMENTS>1</COMMENTS>
    #  '/<COMMENTS>delete</COMMENTS>'    <COMMENTS>delete</COMMENTS>        <COMMENTS>1</COMMENTS>
    #  '<COMMENTS>delete</COMMENTS>/'    <COMMENTS>delete</COMMENTS>        <COMMENTS>1</COMMENTS>
    #  '/<COMMENTS>dev</COMMENTS>/<COMMENTS>null</COMMENTS>'  <COMMENTS>devnull</COMMENTS>       <COMMENTS>2</COMMENTS>    (<COMMENTS>Currently</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>allowed</COMMENTS>)
    my $<CODE>bext</CODE>          = $<CODE>rOpts</CODE>->{'<LITERALS>backup</LITERALS>-<LITERALS>file</LITERALS>-<LITERALS>extension</LITERALS>'};
    my $<CODE>delete_backup</CODE> = ( $<CODE>rOpts</CODE>->{'<LITERALS>backup</LITERALS>-<LITERALS>file</LITERALS>-<LITERALS>extension</LITERALS>'} =~ s/\///g );

    # <COMMENTS>At</COMMENTS> <COMMENTS>present</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>forward</COMMENTS> <COMMENTS>slash</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>allowed</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>future</COMMENTS> <COMMENTS>multiple</COMMENTS>
    # <COMMENTS>slashes</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>allowed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>options</COMMENTS>
    if ( $<CODE>delete_backup</CODE> > 1 ) {
        <CODE>Die</CODE> "-<LITERALS>bext</LITERALS>=$<CODE>bext</CODE> <LITERALS>contains</LITERALS> <LITERALS>more</LITERALS> <LITERALS>than</LITERALS> <LITERALS>one</LITERALS> '/'\n";
    }

    my $<CODE>backup_extension</CODE> =
      <CODE>make_extension</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>backup</LITERALS>-<LITERALS>file</LITERALS>-<LITERALS>extension</LITERALS>'}, '<LITERALS>bak</LITERALS>', $<CODE>dot</CODE> );

    my $<CODE>html_toc_extension</CODE> =
      <CODE>make_extension</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>toc</LITERALS>-<LITERALS>extension</LITERALS>'}, '<LITERALS>toc</LITERALS>', $<CODE>dot</CODE> );

    my $<CODE>html_src_extension</CODE> =
      <CODE>make_extension</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>src</LITERALS>-<LITERALS>extension</LITERALS>'}, '<LITERALS>src</LITERALS>', $<CODE>dot</CODE> );

    # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> -<COMMENTS>b</COMMENTS> <COMMENTS>option</COMMENTS>;
    # <COMMENTS>silently</COMMENTS> <COMMENTS>ignore</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>beautify</COMMENTS> <COMMENTS>mode</COMMENTS>
    my $<CODE>in_place_modify</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>backup</LITERALS>-<LITERALS>and</LITERALS>-<LITERALS>modify</LITERALS>-<LITERALS>in</LITERALS>-<LITERALS>place</LITERALS>'}
      && $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'} eq '<LITERALS>tidy</LITERALS>';

    # <COMMENTS>Turn</COMMENTS> <COMMENTS>off</COMMENTS> -<COMMENTS>b</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>warnings</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>conflicts</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>options</COMMENTS>.
    # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>Do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>silently</COMMENTS>, <COMMENTS>without</COMMENTS> <COMMENTS>warnings</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>or</COMMENTS>
    # <COMMENTS>destination</COMMENTS> <COMMENTS>stream</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>b</COMMENTS>
    # <COMMENTS>flag</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> .<COMMENTS>perltidyrc</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>warnings</COMMENTS> <COMMENTS>break</COMMENTS>
    # <COMMENTS>Test</COMMENTS>::<COMMENTS>NoWarnings</COMMENTS>.  <COMMENTS>See</COMMENTS> <COMMENTS>email</COMMENTS> <COMMENTS>discussion</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>Merijn</COMMENTS> <COMMENTS>Brand</COMMENTS> <COMMENTS>26</COMMENTS> <COMMENTS>Feb</COMMENTS> <COMMENTS>2014</COMMENTS>.
    if ($<CODE>in_place_modify</CODE>) {
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>standard</LITERALS>-<LITERALS>output</LITERALS>'} ) {
##            <COMMENTS>my</COMMENTS> <COMMENTS>$msg</COMMENTS> = "<COMMENTS>Ignoring</COMMENTS> -<COMMENTS>b</COMMENTS>; <COMMENTS>you</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>use</COMMENTS> -<COMMENTS>b</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>st</COMMENTS> <COMMENTS>together</COMMENTS>";
##            <COMMENTS>$msg</COMMENTS> .= " (-<COMMENTS>pbp</COMMENTS> <COMMENTS>contains</COMMENTS> -<COMMENTS>st</COMMENTS>; <COMMENTS>see</COMMENTS> <COMMENTS>manual</COMMENTS>)" <COMMENTS>if</COMMENTS> (<COMMENTS>$saw_pbp</COMMENTS>);
##            <COMMENTS>Warn</COMMENTS> "<COMMENTS>$msg</COMMENTS>\<COMMENTS>n</COMMENTS>";
            $<CODE>in_place_modify</CODE> = 0;
        }
        if ($<CODE>destination_stream</CODE>) {
            ##<COMMENTS>Warn</COMMENTS> "<COMMENTS>Ignoring</COMMENTS> -<COMMENTS>b</COMMENTS>; <COMMENTS>you</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>specify</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>destination</COMMENTS> <COMMENTS>stream</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>b</COMMENTS> <COMMENTS>together</COMMENTS>\<COMMENTS>n</COMMENTS>";
            $<CODE>in_place_modify</CODE> = 0;
        }
        if ( ref($<CODE>source_stream</CODE>) ) {
            ##<COMMENTS>Warn</COMMENTS> "<COMMENTS>Ignoring</COMMENTS> -<COMMENTS>b</COMMENTS>; <COMMENTS>you</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>specify</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>b</COMMENTS> <COMMENTS>together</COMMENTS>\<COMMENTS>n</COMMENTS>";
            $<CODE>in_place_modify</CODE> = 0;
        }
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>outfile</LITERALS>'} ) {
            ##<COMMENTS>Warn</COMMENTS> "<COMMENTS>Ignoring</COMMENTS> -<COMMENTS>b</COMMENTS>; <COMMENTS>you</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>use</COMMENTS> -<COMMENTS>b</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>o</COMMENTS> <COMMENTS>together</COMMENTS>\<COMMENTS>n</COMMENTS>";
            $<CODE>in_place_modify</CODE> = 0;
        }
        if ( defined( $<CODE>rOpts</CODE>->{'<LITERALS>output</LITERALS>-<LITERALS>path</LITERALS>'} ) ) {
            ##<COMMENTS>Warn</COMMENTS> "<COMMENTS>Ignoring</COMMENTS> -<COMMENTS>b</COMMENTS>; <COMMENTS>you</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>use</COMMENTS> -<COMMENTS>b</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>opath</COMMENTS> <COMMENTS>together</COMMENTS>\<COMMENTS>n</COMMENTS>";
            $<CODE>in_place_modify</CODE> = 0;
        }
    }

    <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Formatter</CODE>::<CODE>check_options</CODE>($<CODE>rOpts</CODE>);
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'} eq '<LITERALS>html</LITERALS>' ) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>HtmlWriter</CODE>-><CODE>check_options</CODE>($<CODE>rOpts</CODE>);
    }

    # <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>extensions</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>touch</COMMENTS>
    my $<CODE>forbidden_file_extensions</CODE> = "(($<CODE>dot_pattern</CODE>)(<LITERALS>LOG</LITERALS>|<LITERALS>DEBUG</LITERALS>|<LITERALS>ERR</LITERALS>|<LITERALS>TEE</LITERALS>)";
    if ($<CODE>output_extension</CODE>) {
        my $<CODE>ext</CODE> = quotemeta($<CODE>output_extension</CODE>);
        $<CODE>forbidden_file_extensions</CODE> .= "|$<CODE>ext</CODE>";
    }
    if ( $<CODE>in_place_modify</CODE> && $<CODE>backup_extension</CODE> ) {
        my $<CODE>ext</CODE> = quotemeta($<CODE>backup_extension</CODE>);
        $<CODE>forbidden_file_extensions</CODE> .= "|$<CODE>ext</CODE>";
    }
    $<CODE>forbidden_file_extensions</CODE> .= ')<LITERALS>$</LITERALS>';

    # <COMMENTS>Create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>diagnostics</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS>;
    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>useful</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>development</COMMENTS>
    my $<CODE>diagnostics_object</CODE> = undef;
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>DIAGNOSTICS</LITERALS>'} ) {
        $<CODE>diagnostics_object</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Diagnostics</CODE>-><CODE>new</CODE>();
    }

    # <COMMENTS>no</COMMENTS> <COMMENTS>filenames</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>array</COMMENTS>
    if ($<CODE>source_stream</CODE>) {
        if ( @<CODE>ARGV</CODE> > 0 ) {
            <CODE>Die</CODE>
"<LITERALS>You</LITERALS> <LITERALS>may</LITERALS> <LITERALS>not</LITERALS> <LITERALS>specify</LITERALS> <LITERALS>any</LITERALS> <LITERALS>filenames</LITERALS> <LITERALS>when</LITERALS> <LITERALS>a</LITERALS> <LITERALS>source</LITERALS> <LITERALS>array</LITERALS> <LITERALS>is</LITERALS> <LITERALS>given</LITERALS>\n";
        }

        # <COMMENTS>we</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>stuff</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>ARGV</COMMENTS>
        unshift( @<CODE>ARGV</CODE>, $<CODE>source_stream</CODE> );

        # <COMMENTS>No</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>treatment</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>stream</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>filename</COMMENTS>.
        # <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>enable</COMMENTS> <COMMENTS>checks</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>binary</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>stuff</COMMENTS>.
        $<CODE>source_stream</CODE> = undef unless ref($<CODE>source_stream</CODE>);
    }

    # <COMMENTS>use</COMMENTS> <COMMENTS>stdin</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>args</COMMENTS>
    else {
        unshift( @<CODE>ARGV</CODE>, '-' ) unless @<CODE>ARGV</CODE>;
    }

    #---------------------------------------------------------------
    # <COMMENTS>Ready</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>go</COMMENTS>...
    # <COMMENTS>main</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>process</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>argument</COMMENTS> <COMMENTS>list</COMMENTS>
    #---------------------------------------------------------------
    my $<CODE>number_of_files</CODE> = @<CODE>ARGV</CODE>;
    my $<CODE>formatter</CODE>       = undef;
    my $<CODE>tokenizer</CODE>       = undef;
    while ( my $<CODE>input_file</CODE> = shift @<CODE>ARGV</CODE> ) {
        my $<CODE>fileroot</CODE>;
        my $<CODE>input_file_permissions</CODE>;

        #---------------------------------------------------------------
        # <COMMENTS>prepare</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>stream</COMMENTS>
        #---------------------------------------------------------------
        if ($<CODE>source_stream</CODE>) {
            $<CODE>fileroot</CODE> = "<LITERALS>perltidy</LITERALS>";

            # <COMMENTS>If</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>string</COMMENTS>, <COMMENTS>then</COMMENTS> .<COMMENTS>LOG</COMMENTS> <COMMENTS>output</COMMENTS>
            # <COMMENTS>is</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>logfile</COMMENTS> <COMMENTS>stream</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>specified</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>prevents</COMMENTS>
            # <COMMENTS>unexpected</COMMENTS> <COMMENTS>perltidy</COMMENTS>.<COMMENTS>LOG</COMMENTS> <COMMENTS>files</COMMENTS>.
            if ( !defined($<CODE>logfile_stream</CODE>) ) {
                $<CODE>logfile_stream</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>DevNull</CODE>-><CODE>new</CODE>();
            }
        }
        elsif ( $<CODE>input_file</CODE> eq '-' ) {    # '-' <COMMENTS>indicates</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>STDIN</COMMENTS>
            $<CODE>fileroot</CODE> = "<LITERALS>perltidy</LITERALS>";       # <COMMENTS>root</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>for</COMMENTS> .<COMMENTS>ERR</COMMENTS>, .<COMMENTS>LOG</COMMENTS>, <COMMENTS>etc</COMMENTS>
            $<CODE>in_place_modify</CODE> = 0;
        }
        else {
            $<CODE>fileroot</CODE> = $<CODE>input_file</CODE>;
            unless ( -e $<CODE>input_file</CODE> ) {

                # <COMMENTS>file</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>exist</COMMENTS> - <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>glob</COMMENTS>
                if ( $<CODE>input_file</CODE> =~ /([\?\*\[\{])/ ) {

                    # <COMMENTS>Windows</COMMENTS> <COMMENTS>shell</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>quotes</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>it</COMMENTS>
                    my $<CODE>input_file</CODE> = $<CODE>input_file</CODE>;
                    if ( $<CODE>input_file</CODE> =~ /^\'(.+)\'$/ ) { $<CODE>input_file</CODE> = $<CODE>1</CODE> }
                    if ( $<CODE>input_file</CODE> =~ /^\"(.+)\"$/ ) { $<CODE>input_file</CODE> = $<CODE>1</CODE> }
                    my $<CODE>pattern</CODE> = <CODE>fileglob_to_re</CODE>($<CODE>input_file</CODE>);
                    ##<COMMENTS>eval</COMMENTS> "/<COMMENTS>$pattern</COMMENTS>/";
                    if ( !$@ && opendir( <CODE>DIR</CODE>, './' ) ) {
                        my @<CODE>files</CODE> =
                          grep { /$<CODE>pattern</CODE>/ && !-d $<CODE>_</CODE> } readdir(<CODE>DIR</CODE>);
                        closedir(<CODE>DIR</CODE>);
                        if (@<CODE>files</CODE>) {
                            unshift @<CODE>ARGV</CODE>, @<CODE>files</CODE>;
                            next;
                        }
                    }
                }
                <CODE>Warn</CODE> "<LITERALS>skipping</LITERALS> <LITERALS>file</LITERALS>: '$<CODE>input_file</CODE>': <LITERALS>no</LITERALS> <LITERALS>matches</LITERALS> <LITERALS>found</LITERALS>\n";
                next;
            }

            unless ( -f $<CODE>input_file</CODE> ) {
                <CODE>Warn</CODE> "<LITERALS>skipping</LITERALS> <LITERALS>file</LITERALS>: $<CODE>input_file</CODE>: <LITERALS>not</LITERALS> <LITERALS>a</LITERALS> <LITERALS>regular</LITERALS> <LITERALS>file</LITERALS>\n";
                next;
            }

            # <COMMENTS>As</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>safety</COMMENTS> <COMMENTS>precaution</COMMENTS>, <COMMENTS>skip</COMMENTS> <COMMENTS>zero</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>files</COMMENTS>.
            # <COMMENTS>If</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>got</COMMENTS> <COMMENTS>clobbered</COMMENTS> <COMMENTS>somehow</COMMENTS>,
            # <COMMENTS>the</COMMENTS> <COMMENTS>old</COMMENTS> .<COMMENTS>tdy</COMMENTS> <COMMENTS>or</COMMENTS> .<COMMENTS>bak</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>exist</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS>
            # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>overwrite</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>zero</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>files</COMMENTS>.
            unless ( -s $<CODE>input_file</CODE> ) {
                <CODE>Warn</CODE> "<LITERALS>skipping</LITERALS> <LITERALS>file</LITERALS>: $<CODE>input_file</CODE>: <LITERALS>Zero</LITERALS> <LITERALS>size</LITERALS>\n";
                next;
            }

            unless ( ( -T $<CODE>input_file</CODE> ) || $<CODE>rOpts</CODE>->{'<LITERALS>force</LITERALS>-<LITERALS>read</LITERALS>-<LITERALS>binary</LITERALS>'} ) {
                <CODE>Warn</CODE>
                  "<LITERALS>skipping</LITERALS> <LITERALS>file</LITERALS>: $<CODE>input_file</CODE>: <LITERALS>Non</LITERALS>-<LITERALS>text</LITERALS> (<LITERALS>override</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>f</LITERALS>)\n";
                next;
            }

            # <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>filename</COMMENTS> <COMMENTS>now</COMMENTS>
            $<CODE>fileroot</CODE>               = $<CODE>input_file</CODE>;
            $<CODE>input_file_permissions</CODE> = ( stat $<CODE>input_file</CODE> )[2] & 07777;

            if ( $^<CODE>O</CODE> eq '<LITERALS>VMS</LITERALS>' ) {
                ( $<CODE>fileroot</CODE>, $<CODE>dot</CODE> ) = <CODE>check_vms_filename</CODE>($<CODE>fileroot</CODE>);
            }

            # <COMMENTS>add</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>path</COMMENTS> <COMMENTS>here</COMMENTS>
            if ( defined( $<CODE>rOpts</CODE>->{'<LITERALS>output</LITERALS>-<LITERALS>path</LITERALS>'} ) ) {

                my ( $<CODE>base</CODE>, $<CODE>old_path</CODE> ) = <CODE>fileparse</CODE>($<CODE>fileroot</CODE>);
                my $<CODE>new_path</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>output</LITERALS>-<LITERALS>path</LITERALS>'};
                unless ( -d $<CODE>new_path</CODE> ) {
                    unless ( mkdir $<CODE>new_path</CODE>, 0777 ) {
                        <CODE>Die</CODE> "<LITERALS>unable</LITERALS> <LITERALS>to</LITERALS> <LITERALS>create</LITERALS> <LITERALS>directory</LITERALS> $<CODE>new_path</CODE>: $!\n";
                    }
                }
                my $<CODE>path</CODE> = $<CODE>new_path</CODE>;
                $<CODE>fileroot</CODE> = <CODE>catfile</CODE>( $<CODE>path</CODE>, $<CODE>base</CODE> );
                unless ($<CODE>fileroot</CODE>) {
                    <CODE>Die</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>Problem</LITERALS> <LITERALS>combining</LITERALS> $<CODE>new_path</CODE> <LITERALS>and</LITERALS> $<CODE>base</CODE> <LITERALS>to</LITERALS> <LITERALS>make</LITERALS> <LITERALS>a</LITERALS> <LITERALS>filename</LITERALS>; <LITERALS>check</LITERALS> -<LITERALS>opath</LITERALS>
------------------------------------------------------------------------
<CODE>EOM</CODE>
                }
            }
        }

        # <COMMENTS>Skip</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>extension</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>because</COMMENTS>
        # <COMMENTS>this</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>lead</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>messy</COMMENTS> <COMMENTS>situation</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>like</COMMENTS>
        # <COMMENTS>script</COMMENTS>.<COMMENTS>tdy</COMMENTS>.<COMMENTS>tdy</COMMENTS>.<COMMENTS>tdy</COMMENTS> ... <COMMENTS>or</COMMENTS> <COMMENTS>worse</COMMENTS> <COMMENTS>problems</COMMENTS> ...  <COMMENTS>when</COMMENTS> <COMMENTS>you</COMMENTS>
        # <COMMENTS>rerun</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>wildcard</COMMENTS> <COMMENTS>input</COMMENTS>.
        if (
            !$<CODE>source_stream</CODE>
            && (   $<CODE>input_file</CODE> =~ /$<CODE>forbidden_file_extensions</CODE>/o
                || $<CODE>input_file</CODE> eq '<LITERALS>DIAGNOSTICS</LITERALS>' )
          )
        {
            <CODE>Warn</CODE> "<LITERALS>skipping</LITERALS> <LITERALS>file</LITERALS>: $<CODE>input_file</CODE>: <LITERALS>wrong</LITERALS> <LITERALS>extension</LITERALS>\n";
            next;
        }

        # <COMMENTS>the</COMMENTS> '<COMMENTS>source_object</COMMENTS>' <COMMENTS>supplies</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>read</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS>
        my $<CODE>source_object</CODE> =
          <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSource</CODE>-><CODE>new</CODE>( $<CODE>input_file</CODE>, $<CODE>rOpts</CODE>,
            $<CODE>rpending_logfile_message</CODE> );
        next unless ($<CODE>source_object</CODE>);

        # <COMMENTS>Prefilters</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>postfilters</COMMENTS>: <COMMENTS>The</COMMENTS> <COMMENTS>prefilter</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>reference</COMMENTS>
        # <COMMENTS>that</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>applied</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>tidying</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>postfilter</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>result</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>outputting</COMMENTS>.
        if (
            $<CODE>prefilter</CODE>
            || (   $<CODE>rOpts_character_encoding</CODE>
                && $<CODE>rOpts_character_encoding</CODE> eq '<LITERALS>utf8</LITERALS>' )
          )
        {
            my $<CODE>buf</CODE> = '';
            while ( my $<CODE>line</CODE> = $<CODE>source_object</CODE>-><CODE>get_line</CODE>() ) {
                $<CODE>buf</CODE> .= $<CODE>line</CODE>;
            }

            $<CODE>buf</CODE> = $<CODE>prefilter</CODE>->($<CODE>buf</CODE>) if $<CODE>prefilter</CODE>;

            if (   $<CODE>rOpts_character_encoding</CODE>
                && $<CODE>rOpts_character_encoding</CODE> eq '<LITERALS>utf8</LITERALS>'
                && !<CODE>utf8</CODE>::<CODE>is_utf8</CODE>($<CODE>buf</CODE>) )
            {
                eval {
                    $<CODE>buf</CODE> = <CODE>Encode</CODE>::<CODE>decode</CODE>( '<LITERALS>UTF</LITERALS>-<LITERALS>8</LITERALS>', $<CODE>buf</CODE>,
                        <CODE>Encode</CODE>::<CODE>FB_CROAK</CODE> | <CODE>Encode</CODE>::<CODE>LEAVE_SRC</CODE> );
                };
                if ($@) {
                    <CODE>Warn</CODE>
"<LITERALS>skipping</LITERALS> <LITERALS>file</LITERALS>: $<CODE>input_file</CODE>: <LITERALS>Unable</LITERALS> <LITERALS>to</LITERALS> <LITERALS>decode</LITERALS> <LITERALS>source</LITERALS> <LITERALS>as</LITERALS> <LITERALS>UTF</LITERALS>-<LITERALS>8</LITERALS>\n";
                    next;
                }
            }

            $<CODE>source_object</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSource</CODE>-><CODE>new</CODE>( \$<CODE>buf</CODE>, $<CODE>rOpts</CODE>,
                $<CODE>rpending_logfile_message</CODE> );
        }

        # <COMMENTS>register</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>Diagnostics</COMMENTS> <COMMENTS>package</COMMENTS>
        $<CODE>diagnostics_object</CODE>-><CODE>set_input_file</CODE>($<CODE>input_file</CODE>)
          if $<CODE>diagnostics_object</CODE>;

        #---------------------------------------------------------------
        # <COMMENTS>prepare</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>
        #---------------------------------------------------------------
        my $<CODE>output_file</CODE> = undef;
        my $<CODE>actual_output_extension</CODE>;

        if ( $<CODE>rOpts</CODE>->{'<LITERALS>outfile</LITERALS>'} ) {

            if ( $<CODE>number_of_files</CODE> <= 1 ) {

                if ( $<CODE>rOpts</CODE>->{'<LITERALS>standard</LITERALS>-<LITERALS>output</LITERALS>'} ) {
                    my $<CODE>msg</CODE> = "<LITERALS>You</LITERALS> <LITERALS>may</LITERALS> <LITERALS>not</LITERALS> <LITERALS>use</LITERALS> -<LITERALS>o</LITERALS> <LITERALS>and</LITERALS> -<LITERALS>st</LITERALS> <LITERALS>together</LITERALS>";
                    $<CODE>msg</CODE> .= " (-<LITERALS>pbp</LITERALS> <LITERALS>contains</LITERALS> -<LITERALS>st</LITERALS>; <LITERALS>see</LITERALS> <LITERALS>manual</LITERALS>)" if ($<CODE>saw_pbp</CODE>);
                    <CODE>Die</CODE> "$<CODE>msg</CODE>\n";
                }
                elsif ($<CODE>destination_stream</CODE>) {
                    <CODE>Die</CODE>
"<LITERALS>You</LITERALS> <LITERALS>may</LITERALS> <LITERALS>not</LITERALS> <LITERALS>specify</LITERALS> <LITERALS>a</LITERALS> <LITERALS>destination</LITERALS> <LITERALS>array</LITERALS> <LITERALS>and</LITERALS> -<LITERALS>o</LITERALS> <LITERALS>together</LITERALS>\n";
                }
                elsif ( defined( $<CODE>rOpts</CODE>->{'<LITERALS>output</LITERALS>-<LITERALS>path</LITERALS>'} ) ) {
                    <CODE>Die</CODE> "<LITERALS>You</LITERALS> <LITERALS>may</LITERALS> <LITERALS>not</LITERALS> <LITERALS>specify</LITERALS> -<LITERALS>o</LITERALS> <LITERALS>and</LITERALS> -<LITERALS>opath</LITERALS> <LITERALS>together</LITERALS>\n";
                }
                elsif ( defined( $<CODE>rOpts</CODE>->{'<LITERALS>output</LITERALS>-<LITERALS>file</LITERALS>-<LITERALS>extension</LITERALS>'} ) ) {
                    <CODE>Die</CODE> "<LITERALS>You</LITERALS> <LITERALS>may</LITERALS> <LITERALS>not</LITERALS> <LITERALS>specify</LITERALS> -<LITERALS>o</LITERALS> <LITERALS>and</LITERALS> -<LITERALS>oext</LITERALS> <LITERALS>together</LITERALS>\n";
                }
                $<CODE>output_file</CODE> = $<CODE>rOpts</CODE>->{<LITERALS>outfile</LITERALS>};

                # <COMMENTS>make</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>gives</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>after</COMMENTS> -<COMMENTS>o</COMMENTS>
                if ( $<CODE>output_file</CODE> =~ /^-/ ) {
                    <CODE>Die</CODE> "<LITERALS>You</LITERALS> <LITERALS>must</LITERALS> <LITERALS>specify</LITERALS> <LITERALS>a</LITERALS> <LITERALS>valid</LITERALS> <LITERALS>filename</LITERALS> <LITERALS>after</LITERALS> -<LITERALS>o</LITERALS>\n";
                }

                # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>overwrite</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>o</COMMENTS>
                if ( defined($<CODE>input_file_permissions</CODE>)
                    && ( $<CODE>output_file</CODE> eq $<CODE>input_file</CODE> ) )
                {
                    <CODE>Die</CODE> "<LITERALS>Use</LITERALS> '<LITERALS>perltidy</LITERALS> -<LITERALS>b</LITERALS> $<CODE>input_file</CODE>' <LITERALS>to</LITERALS> <LITERALS>modify</LITERALS> <LITERALS>in</LITERALS>-<LITERALS>place</LITERALS>\n";
                }
            }
            else {
                <CODE>Die</CODE> "<LITERALS>You</LITERALS> <LITERALS>may</LITERALS> <LITERALS>not</LITERALS> <LITERALS>use</LITERALS> -<LITERALS>o</LITERALS> <LITERALS>with</LITERALS> <LITERALS>more</LITERALS> <LITERALS>than</LITERALS> <LITERALS>one</LITERALS> <LITERALS>input</LITERALS> <LITERALS>file</LITERALS>\n";
            }
        }
        elsif ( $<CODE>rOpts</CODE>->{'<LITERALS>standard</LITERALS>-<LITERALS>output</LITERALS>'} ) {
            if ($<CODE>destination_stream</CODE>) {
                my $<CODE>msg</CODE> =
                  "<LITERALS>You</LITERALS> <LITERALS>may</LITERALS> <LITERALS>not</LITERALS> <LITERALS>specify</LITERALS> <LITERALS>a</LITERALS> <LITERALS>destination</LITERALS> <LITERALS>array</LITERALS> <LITERALS>and</LITERALS> -<LITERALS>st</LITERALS> <LITERALS>together</LITERALS>\n";
                $<CODE>msg</CODE> .= " (-<LITERALS>pbp</LITERALS> <LITERALS>contains</LITERALS> -<LITERALS>st</LITERALS>; <LITERALS>see</LITERALS> <LITERALS>manual</LITERALS>)" if ($<CODE>saw_pbp</CODE>);
                <CODE>Die</CODE> "$<CODE>msg</CODE>\n";
            }
            $<CODE>output_file</CODE> = '-';

            if ( $<CODE>number_of_files</CODE> <= 1 ) {
            }
            else {
                <CODE>Die</CODE> "<LITERALS>You</LITERALS> <LITERALS>may</LITERALS> <LITERALS>not</LITERALS> <LITERALS>use</LITERALS> -<LITERALS>st</LITERALS> <LITERALS>with</LITERALS> <LITERALS>more</LITERALS> <LITERALS>than</LITERALS> <LITERALS>one</LITERALS> <LITERALS>input</LITERALS> <LITERALS>file</LITERALS>\n";
            }
        }
        elsif ($<CODE>destination_stream</CODE>) {
            $<CODE>output_file</CODE> = $<CODE>destination_stream</CODE>;
        }
        elsif ($<CODE>source_stream</CODE>) {    # <COMMENTS>source</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>destination</COMMENTS> <COMMENTS>goes</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>stdout</COMMENTS>
            $<CODE>output_file</CODE> = '-';
        }
        elsif ( $<CODE>input_file</CODE> eq '-' ) {
            $<CODE>output_file</CODE> = '-';
        }
        else {
            if ($<CODE>in_place_modify</CODE>) {
                $<CODE>output_file</CODE> = <CODE>IO</CODE>::<CODE>File</CODE>-><CODE>new_tmpfile</CODE>()
                  or <CODE>Die</CODE> "<LITERALS>cannot</LITERALS> <LITERALS>open</LITERALS> <LITERALS>temp</LITERALS> <LITERALS>file</LITERALS> <LITERALS>for</LITERALS> -<LITERALS>b</LITERALS> <LITERALS>option</LITERALS>: $!\n";
            }
            else {
                $<CODE>actual_output_extension</CODE> = $<CODE>output_extension</CODE>;
                $<CODE>output_file</CODE>             = $<CODE>fileroot</CODE> . $<CODE>output_extension</CODE>;
            }
        }

        # <COMMENTS>the</COMMENTS> '<COMMENTS>sink_object</COMMENTS>' <COMMENTS>knows</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>file</COMMENTS>
        my $<CODE>tee_file</CODE> = $<CODE>fileroot</CODE> . $<CODE>dot</CODE> . "<LITERALS>TEE</LITERALS>";

        my $<CODE>line_separator</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>output</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>ending</LITERALS>'};
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>preserve</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>endings</LITERALS>'} ) {
            $<CODE>line_separator</CODE> = <CODE>find_input_line_ending</CODE>($<CODE>input_file</CODE>);
        }

        # <COMMENTS>Eventually</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>I</COMMENTS>/<COMMENTS>O</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>binmode</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>now</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS>
        # <COMMENTS>only</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>requests</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>particular</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>separator</COMMENTS>
        # <COMMENTS>through</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>ple</COMMENTS> <COMMENTS>or</COMMENTS> -<COMMENTS>ole</COMMENTS> <COMMENTS>flags</COMMENTS>
        my $<CODE>binmode</CODE> = defined($<CODE>line_separator</CODE>)
          || defined($<CODE>rOpts_character_encoding</CODE>);
        $<CODE>line_separator</CODE> = "\n" unless defined($<CODE>line_separator</CODE>);

        my ( $<CODE>sink_object</CODE>, $<CODE>postfilter_buffer</CODE> );
        if ($<CODE>postfilter</CODE>) {
            $<CODE>sink_object</CODE> =
              <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSink</CODE>-><CODE>new</CODE>( \$<CODE>postfilter_buffer</CODE>, $<CODE>tee_file</CODE>,
                $<CODE>line_separator</CODE>, $<CODE>rOpts</CODE>, $<CODE>rpending_logfile_message</CODE>, $<CODE>binmode</CODE> );
        }
        else {
            $<CODE>sink_object</CODE> =
              <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSink</CODE>-><CODE>new</CODE>( $<CODE>output_file</CODE>, $<CODE>tee_file</CODE>,
                $<CODE>line_separator</CODE>, $<CODE>rOpts</CODE>, $<CODE>rpending_logfile_message</CODE>, $<CODE>binmode</CODE> );
        }

        #---------------------------------------------------------------
        # <COMMENTS>initialize</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>logger</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>file</COMMENTS>
        #---------------------------------------------------------------
        my $<CODE>warning_file</CODE> = $<CODE>fileroot</CODE> . $<CODE>dot</CODE> . "<LITERALS>ERR</LITERALS>";
        if ($<CODE>errorfile_stream</CODE>) { $<CODE>warning_file</CODE> = $<CODE>errorfile_stream</CODE> }
        my $<CODE>log_file</CODE> = $<CODE>fileroot</CODE> . $<CODE>dot</CODE> . "<LITERALS>LOG</LITERALS>";
        if ($<CODE>logfile_stream</CODE>) { $<CODE>log_file</CODE> = $<CODE>logfile_stream</CODE> }

        my $<CODE>logger_object</CODE> =
          <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Logger</CODE>-><CODE>new</CODE>( $<CODE>rOpts</CODE>, $<CODE>log_file</CODE>, $<CODE>warning_file</CODE>,
            $<CODE>fh_stderr</CODE>, $<CODE>saw_extrude</CODE> );
        <CODE>write_logfile_header</CODE>(
            $<CODE>rOpts</CODE>,        $<CODE>logger_object</CODE>, $<CODE>config_file</CODE>,
            $<CODE>rraw_options</CODE>, $<CODE>Windows_type</CODE>,  $<CODE>readable_options</CODE>,
        );
        if ($$<CODE>rpending_logfile_message</CODE>) {
            $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>($$<CODE>rpending_logfile_message</CODE>);
        }
        if ($$<CODE>rpending_complaint</CODE>) {
            $<CODE>logger_object</CODE>-><CODE>complain</CODE>($$<CODE>rpending_complaint</CODE>);
        }

        #---------------------------------------------------------------
        # <COMMENTS>initialize</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>debug</COMMENTS> <COMMENTS>object</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS>
        #---------------------------------------------------------------
        my $<CODE>debugger_object</CODE> = undef;
        if ( $<CODE>rOpts</CODE>->{<LITERALS>DEBUG</LITERALS>} ) {
            $<CODE>debugger_object</CODE> =
              <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Debugger</CODE>-><CODE>new</CODE>( $<CODE>fileroot</CODE> . $<CODE>dot</CODE> . "<LITERALS>DEBUG</LITERALS>" );
        }

        #---------------------------------------------------------------
        # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>iterations</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>stream</COMMENTS>
        #---------------------------------------------------------------

        # <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>convergence</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>iterations</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>allowed</COMMENTS>.
        # <COMMENTS>It</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>pointless</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>fewer</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS>
        # <COMMENTS>two</COMMENTS> <COMMENTS>passes</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>converged</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>test</COMMENTS>
        # <COMMENTS>would</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>slow</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>down</COMMENTS>.
        my $<CODE>max_iterations</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>iterations</LITERALS>'};
        my $<CODE>convergence_log_message</CODE>;
        my %<CODE>saw_md5</CODE>;
        my $<CODE>do_convergence_test</CODE> = $<CODE>max_iterations</CODE> > 2;
        if ($<CODE>do_convergence_test</CODE>) {
            eval "<LITERALS>use</LITERALS> <LITERALS>Digest</LITERALS>::<LITERALS>MD5</LITERALS> <LITERALS>qw</LITERALS>(<LITERALS>md5_hex</LITERALS>)";
            $<CODE>do_convergence_test</CODE> = !$@;

            # <COMMENTS>Trying</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>ancient</COMMENTS> <COMMENTS>versions</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>because</COMMENTS>
            # <COMMENTS>I</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>utf8</COMMENTS>::<COMMENTS>encode</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>introduced</COMMENTS>.
            eval { my $<CODE>string</CODE> = "<LITERALS>perltidy</LITERALS>"; <CODE>utf8</CODE>::<CODE>encode</CODE>($<CODE>string</CODE>) };
            $<CODE>do_convergence_test</CODE> = $<CODE>do_convergence_test</CODE> && !$@;
        }

        # <COMMENTS>save</COMMENTS> <COMMENTS>objects</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>redirecting</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>during</COMMENTS> <COMMENTS>iterations</COMMENTS>
        my $<CODE>sink_object_final</CODE>     = $<CODE>sink_object</CODE>;
        my $<CODE>debugger_object_final</CODE> = $<CODE>debugger_object</CODE>;
        my $<CODE>logger_object_final</CODE>   = $<CODE>logger_object</CODE>;

        for ( my $<CODE>iter</CODE> = 1 ; $<CODE>iter</CODE> <= $<CODE>max_iterations</CODE> ; $<CODE>iter</CODE>++ ) {

            # <COMMENTS>send</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>temp</COMMENTS> <COMMENTS>buffers</COMMENTS> <COMMENTS>until</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>iteration</COMMENTS>
            my $<CODE>sink_buffer</CODE>;
            if ( $<CODE>iter</CODE> < $<CODE>max_iterations</CODE> ) {
                $<CODE>sink_object</CODE> =
                  <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSink</CODE>-><CODE>new</CODE>( \$<CODE>sink_buffer</CODE>, $<CODE>tee_file</CODE>,
                    $<CODE>line_separator</CODE>, $<CODE>rOpts</CODE>, $<CODE>rpending_logfile_message</CODE>,
                    $<CODE>binmode</CODE> );
            }
            else {
                $<CODE>sink_object</CODE> = $<CODE>sink_object_final</CODE>;
            }

            # <COMMENTS>Save</COMMENTS> <COMMENTS>logger</COMMENTS>, <COMMENTS>debugger</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>pass</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>because</COMMENTS>:
            # (<COMMENTS>1</COMMENTS>) <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>references</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>starting</COMMENTS>
            # <COMMENTS>source</COMMENTS>, <COMMENTS>not</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>intermediate</COMMENTS> <COMMENTS>result</COMMENTS>, <COMMENTS>and</COMMENTS>
            # (<COMMENTS>2</COMMENTS>) <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>errors</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>stop</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>iterations</COMMENTS> <COMMENTS>early</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>.
            if ( $<CODE>iter</CODE> > 1 ) {
                $<CODE>debugger_object</CODE> = undef;
                $<CODE>logger_object</CODE>   = undef;
            }

            #------------------------------------------------------------
            # <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>formatter</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>file</COMMENTS> : <COMMENTS>html</COMMENTS> <COMMENTS>writer</COMMENTS> <COMMENTS>or</COMMENTS>
            # <COMMENTS>pretty</COMMENTS> <COMMENTS>printer</COMMENTS>
            #------------------------------------------------------------

            # <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>delete</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>formatter</COMMENTS> <COMMENTS>because</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>safety</COMMENTS>,
            # <COMMENTS>the</COMMENTS> <COMMENTS>formatter</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>one</COMMENTS>.
            $<CODE>formatter</CODE> = undef;

            if ($<CODE>user_formatter</CODE>) {
                $<CODE>formatter</CODE> = $<CODE>user_formatter</CODE>;
            }
            elsif ( $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'} eq '<LITERALS>html</LITERALS>' ) {
                $<CODE>formatter</CODE> =
                  <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>HtmlWriter</CODE>-><CODE>new</CODE>( $<CODE>fileroot</CODE>, $<CODE>output_file</CODE>,
                    $<CODE>actual_output_extension</CODE>, $<CODE>html_toc_extension</CODE>,
                    $<CODE>html_src_extension</CODE> );
            }
            elsif ( $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'} eq '<LITERALS>tidy</LITERALS>' ) {
                $<CODE>formatter</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Formatter</CODE>-><CODE>new</CODE>(
                    <LITERALS>logger_object</LITERALS>      => $<CODE>logger_object</CODE>,
                    <LITERALS>diagnostics_object</LITERALS> => $<CODE>diagnostics_object</CODE>,
                    <LITERALS>sink_object</LITERALS>        => $<CODE>sink_object</CODE>,
                );
            }
            else {
                <CODE>Die</CODE> "<LITERALS>I</LITERALS> <LITERALS>don</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>know</LITERALS> <LITERALS>how</LITERALS> <LITERALS>to</LITERALS> <LITERALS>do</LITERALS> -<LITERALS>format</LITERALS>=$<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'}\n";
            }

            unless ($<CODE>formatter</CODE>) {
                <CODE>Die</CODE> "<LITERALS>Unable</LITERALS> <LITERALS>to</LITERALS> <LITERALS>continue</LITERALS> <LITERALS>with</LITERALS> $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'} <LITERALS>formatting</LITERALS>\n";
            }

            #---------------------------------------------------------------
            # <COMMENTS>create</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>file</COMMENTS>
            #---------------------------------------------------------------
            $<CODE>tokenizer</CODE> = undef;                     # <COMMENTS>must</COMMENTS> <COMMENTS>destroy</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>tokenizer</COMMENTS>
            $<CODE>tokenizer</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Tokenizer</CODE>-><CODE>new</CODE>(
                <LITERALS>source_object</LITERALS>      => $<CODE>source_object</CODE>,
                <LITERALS>logger_object</LITERALS>      => $<CODE>logger_object</CODE>,
                <LITERALS>debugger_object</LITERALS>    => $<CODE>debugger_object</CODE>,
                <LITERALS>diagnostics_object</LITERALS> => $<CODE>diagnostics_object</CODE>,
                <LITERALS>tabsize</LITERALS>            => $<CODE>tabsize</CODE>,

                <LITERALS>starting_level</LITERALS>      => $<CODE>rOpts</CODE>->{'<LITERALS>starting</LITERALS>-<LITERALS>indentation</LITERALS>-<LITERALS>level</LITERALS>'},
                <LITERALS>indent_columns</LITERALS>      => $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>columns</LITERALS>'},
                <LITERALS>look_for_hash_bang</LITERALS>  => $<CODE>rOpts</CODE>->{'<LITERALS>look</LITERALS>-<LITERALS>for</LITERALS>-<LITERALS>hash</LITERALS>-<LITERALS>bang</LITERALS>'},
                <LITERALS>look_for_autoloader</LITERALS> => $<CODE>rOpts</CODE>->{'<LITERALS>look</LITERALS>-<LITERALS>for</LITERALS>-<LITERALS>autoloader</LITERALS>'},
                <LITERALS>look_for_selfloader</LITERALS> => $<CODE>rOpts</CODE>->{'<LITERALS>look</LITERALS>-<LITERALS>for</LITERALS>-<LITERALS>selfloader</LITERALS>'},
                <LITERALS>trim_qw</LITERALS>             => $<CODE>rOpts</CODE>->{'<LITERALS>trim</LITERALS>-<LITERALS>qw</LITERALS>'},
                <LITERALS>extended_syntax</LITERALS>     => $<CODE>rOpts</CODE>->{'<LITERALS>extended</LITERALS>-<LITERALS>syntax</LITERALS>'},

                <LITERALS>continuation_indentation</LITERALS> =>
                  $<CODE>rOpts</CODE>->{'<LITERALS>continuation</LITERALS>-<LITERALS>indentation</LITERALS>'},
                <LITERALS>outdent_labels</LITERALS> => $<CODE>rOpts</CODE>->{'<LITERALS>outdent</LITERALS>-<LITERALS>labels</LITERALS>'},
            );

            #---------------------------------------------------------------
            # <COMMENTS>now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>it</COMMENTS>
            #---------------------------------------------------------------
            <CODE>process_this_file</CODE>( $<CODE>tokenizer</CODE>, $<CODE>formatter</CODE> );

            #---------------------------------------------------------------
            # <COMMENTS>close</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>report</COMMENTS> <COMMENTS>errors</COMMENTS>
            #---------------------------------------------------------------
            $<CODE>source_object</CODE>-><CODE>close_input_file</CODE>();

            # <COMMENTS>line</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>iteration</COMMENTS> (<COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS>) <COMMENTS>comes</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS>
            # <COMMENTS>temporary</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>buffer</COMMENTS>
            if ( $<CODE>iter</CODE> < $<CODE>max_iterations</CODE> ) {

                $<CODE>sink_object</CODE>-><CODE>close_output_file</CODE>();
                $<CODE>source_object</CODE> =
                  <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSource</CODE>-><CODE>new</CODE>( \$<CODE>sink_buffer</CODE>, $<CODE>rOpts</CODE>,
                    $<CODE>rpending_logfile_message</CODE> );

                # <COMMENTS>stop</COMMENTS> <COMMENTS>iterations</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>errors</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>converged</COMMENTS>
                my $<CODE>stop_now</CODE> = $<CODE>logger_object</CODE>->{<LITERALS>_warning_count</LITERALS>};
                if ($<CODE>stop_now</CODE>) {
                    $<CODE>convergence_log_message</CODE> = <<<LITERALS>EOM</LITERALS>;
<LITERALS>Stopping</LITERALS> <LITERALS>iterations</LITERALS> <LITERALS>because</LITERALS> <LITERALS>of</LITERALS> <LITERALS>errors</LITERALS>.
<CODE>EOM</CODE>
                }
                elsif ($<CODE>do_convergence_test</CODE>) {

                    # <COMMENTS>Patch</COMMENTS> <COMMENTS>for</COMMENTS> [<COMMENTS>rt</COMMENTS>.<COMMENTS>cpan</COMMENTS>.<COMMENTS>org</COMMENTS> #<COMMENTS>88020</COMMENTS>]
                    # <COMMENTS>Use</COMMENTS> <COMMENTS>utf8</COMMENTS>::<COMMENTS>encode</COMMENTS> <COMMENTS>since</COMMENTS> <COMMENTS>md5_hex</COMMENTS>() <COMMENTS>only</COMMENTS> <COMMENTS>operates</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>bytes</COMMENTS>.
                    my $<CODE>digest</CODE> = <CODE>md5_hex</CODE>( <CODE>utf8</CODE>::<CODE>encode</CODE>($<CODE>sink_buffer</CODE>) );
                    if ( !$<CODE>saw_md5</CODE>{$<CODE>digest</CODE>} ) {
                        $<CODE>saw_md5</CODE>{$<CODE>digest</CODE>} = $<CODE>iter</CODE>;
                    }
                    else {

                        # <COMMENTS>Deja</COMMENTS> <COMMENTS>vu</COMMENTS>, <COMMENTS>stop</COMMENTS> <COMMENTS>iterating</COMMENTS>
                        $<CODE>stop_now</CODE> = 1;
                        my $<CODE>iterm</CODE> = $<CODE>iter</CODE> - 1;
                        if ( $<CODE>saw_md5</CODE>{$<CODE>digest</CODE>} != $<CODE>iterm</CODE> ) {

                            # <COMMENTS>Blinking</COMMENTS> (<COMMENTS>oscillating</COMMENTS>) <COMMENTS>between</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>stable</COMMENTS>
                            # <COMMENTS>end</COMMENTS> <COMMENTS>states</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>happened</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>past</COMMENTS>
                            # <COMMENTS>but</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>present</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>known</COMMENTS> <COMMENTS>instances</COMMENTS>.
                            $<CODE>convergence_log_message</CODE> = <<<LITERALS>EOM</LITERALS>;
<LITERALS>Blinking</LITERALS>. <LITERALS>Output</LITERALS> <LITERALS>for</LITERALS> <LITERALS>iteration</LITERALS> $<CODE>iter</CODE> <LITERALS>same</LITERALS> <LITERALS>as</LITERALS> <LITERALS>for</LITERALS> $<CODE>saw_md5</CODE>{$<CODE>digest</CODE>}.
<CODE>EOM</CODE>
                            $<CODE>diagnostics_object</CODE>-><CODE>write_diagnostics</CODE>(
                                $<CODE>convergence_log_message</CODE>)
                              if $<CODE>diagnostics_object</CODE>;
                        }
                        else {
                            $<CODE>convergence_log_message</CODE> = <<<LITERALS>EOM</LITERALS>;
<LITERALS>Converged</LITERALS>.  <LITERALS>Output</LITERALS> <LITERALS>for</LITERALS> <LITERALS>iteration</LITERALS> $<CODE>iter</CODE> <LITERALS>same</LITERALS> <LITERALS>as</LITERALS> <LITERALS>for</LITERALS> <LITERALS>iter</LITERALS> $<CODE>iterm</CODE>.
<CODE>EOM</CODE>
                            $<CODE>diagnostics_object</CODE>-><CODE>write_diagnostics</CODE>(
                                $<CODE>convergence_log_message</CODE>)
                              if $<CODE>diagnostics_object</CODE> && $<CODE>iterm</CODE> > 2;
                        }
                    }
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> (<COMMENTS>$do_convergence_test</COMMENTS>)

                if ($<CODE>stop_now</CODE>) {

                    # <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>stopping</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>iterations</COMMENTS> <COMMENTS>early</COMMENTS>;
                    # <COMMENTS>copy</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>final</COMMENTS> <COMMENTS>destination</COMMENTS>
                    $<CODE>sink_object</CODE> = $<CODE>sink_object_final</CODE>;
                    while ( my $<CODE>line</CODE> = $<CODE>source_object</CODE>-><CODE>get_line</CODE>() ) {
                        $<CODE>sink_object</CODE>-><CODE>write_line</CODE>($<CODE>line</CODE>);
                    }
                    $<CODE>source_object</CODE>-><CODE>close_input_file</CODE>();
                    last;
                }
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$iter</COMMENTS> < <COMMENTS>$max_iterations</COMMENTS>)
        }    # <COMMENTS>end</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>iterations</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>file</COMMENTS>

        # <COMMENTS>restore</COMMENTS> <COMMENTS>objects</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>temporarily</COMMENTS> <COMMENTS>undefined</COMMENTS>
        # <COMMENTS>for</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>higher</COMMENTS> <COMMENTS>iterations</COMMENTS>
        $<CODE>debugger_object</CODE> = $<CODE>debugger_object_final</CODE>;
        $<CODE>logger_object</CODE>   = $<CODE>logger_object_final</CODE>;

        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>($<CODE>convergence_log_message</CODE>)
          if $<CODE>convergence_log_message</CODE>;

        #---------------------------------------------------------------
        # <COMMENTS>Perform</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>postfilter</COMMENTS> <COMMENTS>operation</COMMENTS>
        #---------------------------------------------------------------
        if ($<CODE>postfilter</CODE>) {
            $<CODE>sink_object</CODE>-><CODE>close_output_file</CODE>();
            $<CODE>sink_object</CODE> =
              <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSink</CODE>-><CODE>new</CODE>( $<CODE>output_file</CODE>, $<CODE>tee_file</CODE>,
                $<CODE>line_separator</CODE>, $<CODE>rOpts</CODE>, $<CODE>rpending_logfile_message</CODE>, $<CODE>binmode</CODE> );
            my $<CODE>buf</CODE> = $<CODE>postfilter</CODE>->($<CODE>postfilter_buffer</CODE>);
            $<CODE>source_object</CODE> =
              <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSource</CODE>-><CODE>new</CODE>( \$<CODE>buf</CODE>, $<CODE>rOpts</CODE>,
                $<CODE>rpending_logfile_message</CODE> );
            while ( my $<CODE>line</CODE> = $<CODE>source_object</CODE>-><CODE>get_line</CODE>() ) {
                $<CODE>sink_object</CODE>-><CODE>write_line</CODE>($<CODE>line</CODE>);
            }
            $<CODE>source_object</CODE>-><CODE>close_input_file</CODE>();
        }

        # <COMMENTS>Save</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>check</COMMENTS>
        my $<CODE>ifname</CODE> = $<CODE>input_file</CODE>;
        my $<CODE>ofname</CODE> = $<CODE>output_file</CODE>;

        #---------------------------------------------------------------
        # <COMMENTS>handle</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>b</COMMENTS> <COMMENTS>option</COMMENTS> (<COMMENTS>backup</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>modify</COMMENTS> <COMMENTS>in</COMMENTS>-<COMMENTS>place</COMMENTS>)
        #---------------------------------------------------------------
        if ($<CODE>in_place_modify</CODE>) {
            unless ( -f $<CODE>input_file</CODE> ) {

                # <COMMENTS>oh</COMMENTS>, <COMMENTS>oh</COMMENTS>, <COMMENTS>no</COMMENTS> <COMMENTS>real</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>backup</COMMENTS> ..
                # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>numerous</COMMENTS> <COMMENTS>preliminary</COMMENTS> <COMMENTS>checks</COMMENTS>
                <CODE>Die</CODE>
"<LITERALS>problem</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>b</LITERALS> <LITERALS>backing</LITERALS> <LITERALS>up</LITERALS> <LITERALS>input</LITERALS> <LITERALS>file</LITERALS> '$<CODE>input_file</CODE>': <LITERALS>not</LITERALS> <LITERALS>a</LITERALS> <LITERALS>file</LITERALS>\n";
            }
            my $<CODE>backup_name</CODE> = $<CODE>input_file</CODE> . $<CODE>backup_extension</CODE>;
            if ( -f $<CODE>backup_name</CODE> ) {
                unlink($<CODE>backup_name</CODE>)
                  or <CODE>Die</CODE>
"<LITERALS>unable</LITERALS> <LITERALS>to</LITERALS> <LITERALS>remove</LITERALS> <LITERALS>previous</LITERALS> '$<CODE>backup_name</CODE>' <LITERALS>for</LITERALS> -<LITERALS>b</LITERALS> <LITERALS>option</LITERALS>; <LITERALS>check</LITERALS> <LITERALS>permissions</LITERALS>: $!\n";
            }

            # <COMMENTS>backup</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS>
            # <COMMENTS>we</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>copy</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>symlinks</COMMENTS>, <COMMENTS>move</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>regular</COMMENTS> <COMMENTS>files</COMMENTS>
            if ( -l $<CODE>input_file</CODE> ) {
                <CODE>File</CODE>::<CODE>Copy</CODE>::<CODE>copy</CODE>( $<CODE>input_file</CODE>, $<CODE>backup_name</CODE> )
                  or <CODE>Die</CODE> "<LITERALS>File</LITERALS>::<LITERALS>Copy</LITERALS> <LITERALS>failed</LITERALS> <LITERALS>trying</LITERALS> <LITERALS>to</LITERALS> <LITERALS>backup</LITERALS> <LITERALS>source</LITERALS>: $!";
            }
            else {
                rename( $<CODE>input_file</CODE>, $<CODE>backup_name</CODE> )
                  or <CODE>Die</CODE>
"<LITERALS>problem</LITERALS> <LITERALS>renaming</LITERALS> $<CODE>input_file</CODE> <LITERALS>to</LITERALS> $<CODE>backup_name</CODE> <LITERALS>for</LITERALS> -<LITERALS>b</LITERALS> <LITERALS>option</LITERALS>: $!\n";
            }
            $<CODE>ifname</CODE> = $<CODE>backup_name</CODE>;

            # <COMMENTS>copy</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>original</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS>
            # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>nice</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>close</COMMENTS> <COMMENTS>$output_file</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>use</COMMENTS>
            # <COMMENTS>File</COMMENTS>::<COMMENTS>Copy</COMMENTS>::<COMMENTS>copy</COMMENTS> <COMMENTS>here</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>$output_file</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>handle</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>nameless</COMMENTS> <COMMENTS>temporary</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>lose</COMMENTS>
            # <COMMENTS>everything</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>closed</COMMENTS> <COMMENTS>it</COMMENTS>.
            seek( $<CODE>output_file</CODE>, 0, 0 )
              or <CODE>Die</CODE> "<LITERALS>unable</LITERALS> <LITERALS>to</LITERALS> <LITERALS>rewind</LITERALS> <LITERALS>a</LITERALS> <LITERALS>temporary</LITERALS> <LITERALS>file</LITERALS> <LITERALS>for</LITERALS> -<LITERALS>b</LITERALS> <LITERALS>option</LITERALS>: $!\n";
            my $<CODE>fout</CODE> = <CODE>IO</CODE>::<CODE>File</CODE>-><CODE>new</CODE>("> $<CODE>input_file</CODE>")
              or <CODE>Die</CODE>
"<LITERALS>problem</LITERALS> <LITERALS>re</LITERALS>-<LITERALS>opening</LITERALS> $<CODE>input_file</CODE> <LITERALS>for</LITERALS> <LITERALS>write</LITERALS> <LITERALS>for</LITERALS> -<LITERALS>b</LITERALS> <LITERALS>option</LITERALS>; <LITERALS>check</LITERALS> <LITERALS>file</LITERALS> <LITERALS>and</LITERALS> <LITERALS>directory</LITERALS> <LITERALS>permissions</LITERALS>: $!\n";
            binmode $<CODE>fout</CODE>;
            my $<CODE>line</CODE>;
            while ( $<CODE>line</CODE> = $<CODE>output_file</CODE>-><CODE>getline</CODE>() ) {
                $<CODE>fout</CODE>-><CODE>print</CODE>($<CODE>line</CODE>);
            }
            $<CODE>fout</CODE>-><CODE>close</CODE>();
            $<CODE>output_file</CODE> = $<CODE>input_file</CODE>;
            $<CODE>ofname</CODE>      = $<CODE>input_file</CODE>;
        }

        #---------------------------------------------------------------
        # <COMMENTS>clean</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>report</COMMENTS> <COMMENTS>errors</COMMENTS>
        #---------------------------------------------------------------
        $<CODE>sink_object</CODE>-><CODE>close_output_file</CODE>()    if $<CODE>sink_object</CODE>;
        $<CODE>debugger_object</CODE>-><CODE>close_debug_file</CODE>() if $<CODE>debugger_object</CODE>;

        # <COMMENTS>set</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>permissions</COMMENTS>
        if ( $<CODE>output_file</CODE> && -f $<CODE>output_file</CODE> && !-l $<CODE>output_file</CODE> ) {
            if ($<CODE>input_file_permissions</CODE>) {

                # <COMMENTS>give</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>script</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>permissions</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>script</COMMENTS>, <COMMENTS>but</COMMENTS>
                # <COMMENTS>make</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>user</COMMENTS>-<COMMENTS>writable</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>run</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>again</COMMENTS>.
                # <COMMENTS>Thus</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>retain</COMMENTS> <COMMENTS>whatever</COMMENTS> <COMMENTS>executable</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>set</COMMENTS>.
                if ( $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'} eq '<LITERALS>tidy</LITERALS>' ) {
                    chmod( $<CODE>input_file_permissions</CODE> | 0600, $<CODE>output_file</CODE> );
                }

                # <COMMENTS>else</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>permissions</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>format</COMMENTS>
            }
        }

        #---------------------------------------------------------------
        # <COMMENTS>Do</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>possible</COMMENTS>
        #---------------------------------------------------------------
        my $<CODE>infile_syntax_ok</CODE> = 0;    # -<COMMENTS>1</COMMENTS> <COMMENTS>no</COMMENTS>  <COMMENTS>0</COMMENTS>=<COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>know</COMMENTS>   <COMMENTS>1</COMMENTS> <COMMENTS>yes</COMMENTS>
        if (   $<CODE>logger_object</CODE>
            && $<CODE>rOpts</CODE>->{'<LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>'}
            && $<CODE>ifname</CODE>
            && $<CODE>ofname</CODE> )
        {
            $<CODE>infile_syntax_ok</CODE> =
              <CODE>check_syntax</CODE>( $<CODE>ifname</CODE>, $<CODE>ofname</CODE>, $<CODE>logger_object</CODE>, $<CODE>rOpts</CODE> );
        }

        #---------------------------------------------------------------
        # <COMMENTS>remove</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>original</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>in</COMMENTS>-<COMMENTS>place</COMMENTS> <COMMENTS>modify</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>follows</COMMENTS>:
        #   <COMMENTS>$delete_backup</COMMENTS>=<COMMENTS>0</COMMENTS> <COMMENTS>never</COMMENTS>
        #   <COMMENTS>$delete_backup</COMMENTS>=<COMMENTS>1</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>errors</COMMENTS>
        #   <COMMENTS>$delete_backup</COMMENTS>><COMMENTS>1</COMMENTS> <COMMENTS>always</COMMENTS>  : <COMMENTS>NOT</COMMENTS> <COMMENTS>ALLOWED</COMMENTS>, <COMMENTS>too</COMMENTS> <COMMENTS>risky</COMMENTS>, <COMMENTS>see</COMMENTS> <COMMENTS>above</COMMENTS>
        #---------------------------------------------------------------
        if (   $<CODE>in_place_modify</CODE>
            && $<CODE>delete_backup</CODE>
            && -f $<CODE>ifname</CODE>
            && ( $<CODE>delete_backup</CODE> > 1 || !$<CODE>logger_object</CODE>->{<LITERALS>_warning_count</LITERALS>} ) )
        {

            # <COMMENTS>As</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>added</COMMENTS> <COMMENTS>safety</COMMENTS> <COMMENTS>precaution</COMMENTS>, <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>delete</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>file</COMMENTS>
            # <COMMENTS>if</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>size</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>dropped</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>positive</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>zero</COMMENTS>, <COMMENTS>since</COMMENTS> <COMMENTS>this</COMMENTS>
            # <COMMENTS>could</COMMENTS> <COMMENTS>indicate</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>disaster</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>kind</COMMENTS>, <COMMENTS>including</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hardware</COMMENTS>
            # <COMMENTS>failure</COMMENTS>.  <COMMENTS>Actually</COMMENTS>, <COMMENTS>this</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>had</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>of</COMMENTS>
            # <COMMENTS>all</COMMENTS> <COMMENTS>comments</COMMENTS> (<COMMENTS>or</COMMENTS> <COMMENTS>pod</COMMENTS>) <COMMENTS>and</COMMENTS> <COMMENTS>deleted</COMMENTS> <COMMENTS>everything</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>dac</COMMENTS> (-<COMMENTS>dap</COMMENTS>)
            # <COMMENTS>for</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>reason</COMMENTS>.
            if ( !-s $<CODE>output_file</CODE> && -s $<CODE>ifname</CODE> && $<CODE>delete_backup</CODE> == 1 ) {
                <CODE>Warn</CODE>(
"<LITERALS>output</LITERALS> <LITERALS>file</LITERALS> '$<CODE>output_file</CODE>' <LITERALS>missing</LITERALS> <LITERALS>or</LITERALS> <LITERALS>zero</LITERALS> <LITERALS>length</LITERALS>; <LITERALS>original</LITERALS> '$<CODE>ifname</CODE>' <LITERALS>not</LITERALS> <LITERALS>deleted</LITERALS>\n"
                );
            }
            else {
                unlink($<CODE>ifname</CODE>)
                  or <CODE>Die</CODE>
"<LITERALS>unable</LITERALS> <LITERALS>to</LITERALS> <LITERALS>remove</LITERALS> <LITERALS>previous</LITERALS> '$<CODE>ifname</CODE>' <LITERALS>for</LITERALS> -<LITERALS>b</LITERALS> <LITERALS>option</LITERALS>; <LITERALS>check</LITERALS> <LITERALS>permissions</LITERALS>: $!\n";
            }
        }

        $<CODE>logger_object</CODE>-><CODE>finish</CODE>( $<CODE>infile_syntax_ok</CODE>, $<CODE>formatter</CODE> )
          if $<CODE>logger_object</CODE>;
    }    # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>process</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>files</COMMENTS>

  <CODE>NORMAL_EXIT</CODE>:
    return 0;

  <CODE>ERROR_EXIT</CODE>:
    return 1;
}    # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>program</COMMENTS> <COMMENTS>perltidy</COMMENTS>

sub <CODE>get_stream_as_named_file</CODE> {

    # <COMMENTS>Return</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>containing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>stream</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>data</COMMENTS>, <COMMENTS>creating</COMMENTS>
    # <COMMENTS>a</COMMENTS> <COMMENTS>temporary</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>.
    # <COMMENTS>Given</COMMENTS>:
    #  <COMMENTS>$stream</COMMENTS> - <COMMENTS>the</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>stream</COMMENTS>
    # <COMMENTS>Returns</COMMENTS>:
    #  <COMMENTS>$fname</COMMENTS> = <COMMENTS>name</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>possible</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>undef</COMMENTS>
    #  <COMMENTS>$if_tmpfile</COMMENTS> = <COMMENTS>true</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>temp</COMMENTS> <COMMENTS>file</COMMENTS>, <COMMENTS>undef</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>temp</COMMENTS> <COMMENTS>file</COMMENTS>
    #
    # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>passing</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>Perl</COMMENTS> <COMMENTS>for</COMMENTS>
    # <COMMENTS>a</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>check</COMMENTS>.
    my ($<CODE>stream</CODE>) = @<CODE>_</CODE>;
    my $<CODE>is_tmpfile</CODE>;
    my $<CODE>fname</CODE>;
    if ($<CODE>stream</CODE>) {
        if ( ref($<CODE>stream</CODE>) ) {
            my ( $<CODE>fh_stream</CODE>, $<CODE>fh_name</CODE> ) =
              <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>streamhandle</CODE>( $<CODE>stream</CODE>, '<LITERALS>r</LITERALS>' );
            if ($<CODE>fh_stream</CODE>) {
                my ( $<CODE>fout</CODE>, $<CODE>tmpnam</CODE> ) = <CODE>File</CODE>::<CODE>Temp</CODE>::<CODE>tempfile</CODE>();
                if ($<CODE>fout</CODE>) {
                    $<CODE>fname</CODE>      = $<CODE>tmpnam</CODE>;
                    $<CODE>is_tmpfile</CODE> = 1;
                    binmode $<CODE>fout</CODE>;
                    while ( my $<CODE>line</CODE> = $<CODE>fh_stream</CODE>-><CODE>getline</CODE>() ) {
                        $<CODE>fout</CODE>-><CODE>print</CODE>($<CODE>line</CODE>);
                    }
                    $<CODE>fout</CODE>-><CODE>close</CODE>();
                }
                $<CODE>fh_stream</CODE>-><CODE>close</CODE>();
            }
        }
        elsif ( $<CODE>stream</CODE> ne '-' && -f $<CODE>stream</CODE> ) {
            $<CODE>fname</CODE> = $<CODE>stream</CODE>;
        }
    }
    return ( $<CODE>fname</CODE>, $<CODE>is_tmpfile</CODE> );
}

sub <CODE>fileglob_to_re</CODE> {

    # <COMMENTS>modified</COMMENTS> (<COMMENTS>corrected</COMMENTS>) <COMMENTS>from</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>find2perl</COMMENTS>
    my $<CODE>x</CODE> = shift;
    $<CODE>x</CODE> =~ s#([./^\$()])#\\$<CODE>1</CODE>#g;    # <COMMENTS>escape</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>characters</COMMENTS>
    $<CODE>x</CODE> =~ s#\*#.*#g;               # '*' -> '.*'
    $<CODE>x</CODE> =~ s#\?#.#g;                # '?' -> '.'
    "^$<CODE>x</CODE>\\<LITERALS>z</LITERALS>";                      # <COMMENTS>match</COMMENTS> <COMMENTS>whole</COMMENTS> <COMMENTS>word</COMMENTS>
}

sub <CODE>make_extension</CODE> {

    # <COMMENTS>Make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>extension</COMMENTS>, <COMMENTS>including</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>leading</COMMENTS> '.' <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
    # <COMMENTS>The</COMMENTS> '.' <COMMENTS>may</COMMENTS> <COMMENTS>actually</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>an</COMMENTS> '<COMMENTS>_</COMMENTS>' <COMMENTS>under</COMMENTS> <COMMENTS>VMS</COMMENTS>
    my ( $<CODE>extension</CODE>, $<CODE>default</CODE>, $<CODE>dot</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>Use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>none</COMMENTS> <COMMENTS>specified</COMMENTS>
    $<CODE>extension</CODE> = $<CODE>default</CODE> unless ($<CODE>extension</CODE>);

    # <COMMENTS>Only</COMMENTS> <COMMENTS>extensions</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>a</COMMENTS> '.'
    # <COMMENTS>This</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>gives</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>freedom</COMMENTS>
    if ( $<CODE>extension</CODE> =~ /^[a-zA-Z0-9]/ ) {
        $<CODE>extension</CODE> = $<CODE>dot</CODE> . $<CODE>extension</CODE>;
    }
    return $<CODE>extension</CODE>;
}

sub <CODE>write_logfile_header</CODE> {
    my (
        $<CODE>rOpts</CODE>,        $<CODE>logger_object</CODE>, $<CODE>config_file</CODE>,
        $<CODE>rraw_options</CODE>, $<CODE>Windows_type</CODE>,  $<CODE>readable_options</CODE>
    ) = @<CODE>_</CODE>;
    $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
"<LITERALS>perltidy</LITERALS> <LITERALS>version</LITERALS> $<CODE>VERSION</CODE> <LITERALS>log</LITERALS> <LITERALS>file</LITERALS> <LITERALS>on</LITERALS> <LITERALS>a</LITERALS> $^<CODE>O</CODE> <LITERALS>system</LITERALS>, <LITERALS>OLD_PERL_VERSION</LITERALS>=$]\n"
    );
    if ($<CODE>Windows_type</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>("<LITERALS>Windows</LITERALS> <LITERALS>type</LITERALS> <LITERALS>is</LITERALS> $<CODE>Windows_type</CODE>\n");
    }
    my $<CODE>options_string</CODE> = join( ' ', @$<CODE>rraw_options</CODE> );

    if ($<CODE>config_file</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
            "<LITERALS>Found</LITERALS> <LITERALS>Configuration</LITERALS> <LITERALS>File</LITERALS> >>> $<CODE>config_file</CODE> \n");
    }
    $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
        "<LITERALS>Configuration</LITERALS> <LITERALS>and</LITERALS> <LITERALS>command</LITERALS> <LITERALS>line</LITERALS> <LITERALS>parameters</LITERALS> <LITERALS>for</LITERALS> <LITERALS>this</LITERALS> <LITERALS>run</LITERALS>:\n");
    $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>("$<CODE>options_string</CODE>\n");

    if ( $<CODE>rOpts</CODE>->{'<LITERALS>DEBUG</LITERALS>'} || $<CODE>rOpts</CODE>->{'<LITERALS>show</LITERALS>-<LITERALS>options</LITERALS>'} ) {
        $<CODE>rOpts</CODE>->{'<LITERALS>logfile</LITERALS>'} = 1;    # <COMMENTS>force</COMMENTS> <COMMENTS>logfile</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>saved</COMMENTS>
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
            "<LITERALS>Final</LITERALS> <LITERALS>parameter</LITERALS> <LITERALS>set</LITERALS> <LITERALS>for</LITERALS> <LITERALS>this</LITERALS> <LITERALS>run</LITERALS>\n");
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
            "------------------------------------\n");

        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>($<CODE>readable_options</CODE>);

        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
            "------------------------------------\n");
    }
    $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
        "<LITERALS>To</LITERALS> <LITERALS>find</LITERALS> <LITERALS>error</LITERALS> <LITERALS>messages</LITERALS> <LITERALS>search</LITERALS> <LITERALS>for</LITERALS> '<LITERALS>WARNING</LITERALS>' <LITERALS>with</LITERALS> <LITERALS>your</LITERALS> <LITERALS>editor</LITERALS>\n");
}

sub <CODE>generate_options</CODE> {

    ######################################################################
    # <COMMENTS>Generate</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>references</COMMENTS> <COMMENTS>to</COMMENTS>:
    #  @<COMMENTS>option_string</COMMENTS> - <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>passed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>Getopt</COMMENTS>::<COMMENTS>Long</COMMENTS>
    #  @<COMMENTS>defaults</COMMENTS> - <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>options</COMMENTS>
    #  %<COMMENTS>expansion</COMMENTS> - <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>showing</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>abbreviations</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>expanded</COMMENTS>
    #  %<COMMENTS>category</COMMENTS> - <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>giving</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>general</COMMENTS> <COMMENTS>category</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>option</COMMENTS>
    #  %<COMMENTS>option_range</COMMENTS> - <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>giving</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>ranges</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>options</COMMENTS>

    # <COMMENTS>Note</COMMENTS>: <COMMENTS>a</COMMENTS> <COMMENTS>few</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>documented</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>man</COMMENTS> <COMMENTS>page</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>usage</COMMENTS>
    # <COMMENTS>message</COMMENTS>. <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>experimental</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>debug</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>and</COMMENTS>
    # <COMMENTS>may</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>retained</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>future</COMMENTS> <COMMENTS>versions</COMMENTS>.
    #
    # <COMMENTS>Here</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>undocumented</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>far</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>I</COMMENTS> <COMMENTS>know</COMMENTS>.  <COMMENTS>Any</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>them</COMMENTS>
    # <COMMENTS>may</COMMENTS> <COMMENTS>disappear</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>time</COMMENTS>.  <COMMENTS>They</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>mainly</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>fine</COMMENTS>-<COMMENTS>tuning</COMMENTS>
    # <COMMENTS>and</COMMENTS> <COMMENTS>debugging</COMMENTS>.
    #
    # <COMMENTS>fll</COMMENTS> --> <COMMENTS>fuzzy</COMMENTS>-<COMMENTS>line</COMMENTS>-<COMMENTS>length</COMMENTS>           # <COMMENTS>a</COMMENTS> <COMMENTS>trivial</COMMENTS> <COMMENTS>parameter</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>gets</COMMENTS>
    #                                       <COMMENTS>turned</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>extrude</COMMENTS> <COMMENTS>option</COMMENTS>
    #                                       <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>mainly</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>debugging</COMMENTS>
    # <COMMENTS>scl</COMMENTS> --> <COMMENTS>short</COMMENTS>-<COMMENTS>concatenation</COMMENTS>-<COMMENTS>item</COMMENTS>-<COMMENTS>length</COMMENTS>   # <COMMENTS>helps</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> '.'
    # <COMMENTS>recombine</COMMENTS>                           # <COMMENTS>for</COMMENTS> <COMMENTS>debugging</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>breaks</COMMENTS>
    # <COMMENTS>valign</COMMENTS>                              # <COMMENTS>for</COMMENTS> <COMMENTS>debugging</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS>
    # <COMMENTS>I</COMMENTS>   --> <COMMENTS>DIAGNOSTICS</COMMENTS>                 # <COMMENTS>for</COMMENTS> <COMMENTS>debugging</COMMENTS>
    ######################################################################

    # <COMMENTS>here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>summary</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>Getopt</COMMENTS> <COMMENTS>codes</COMMENTS>:
    # <<COMMENTS>none</COMMENTS>> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>take</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>argument</COMMENTS>
    # =<COMMENTS>s</COMMENTS> <COMMENTS>takes</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>mandatory</COMMENTS> <COMMENTS>string</COMMENTS>
    # :<COMMENTS>s</COMMENTS> <COMMENTS>takes</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>optional</COMMENTS> <COMMENTS>string</COMMENTS>  (<COMMENTS>DO</COMMENTS> <COMMENTS>NOT</COMMENTS> <COMMENTS>USE</COMMENTS> - <COMMENTS>filenames</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>eaten</COMMENTS> <COMMENTS>up</COMMENTS>)
    # =<COMMENTS>i</COMMENTS> <COMMENTS>takes</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>mandatory</COMMENTS> <COMMENTS>integer</COMMENTS>
    # :<COMMENTS>i</COMMENTS> <COMMENTS>takes</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>optional</COMMENTS> <COMMENTS>integer</COMMENTS> (<COMMENTS>NOT</COMMENTS> <COMMENTS>RECOMMENDED</COMMENTS> - <COMMENTS>can</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>trouble</COMMENTS>)
    # ! <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>take</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>argument</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>negated</COMMENTS>
    #  <COMMENTS>i</COMMENTS>.<COMMENTS>e</COMMENTS>., -<COMMENTS>foo</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>nofoo</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>allowed</COMMENTS>
    # <COMMENTS>a</COMMENTS> <COMMENTS>double</COMMENTS> <COMMENTS>dash</COMMENTS> <COMMENTS>signals</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>list</COMMENTS>
    #
    #---------------------------------------------------------------
    # <COMMENTS>Define</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>passed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>GetOptions</COMMENTS>.
    #---------------------------------------------------------------

    my @<CODE>option_string</CODE>   = ();
    my %<CODE>expansion</CODE>       = ();
    my %<CODE>option_category</CODE> = ();
    my %<CODE>option_range</CODE>    = ();
    my $<CODE>rexpansion</CODE>      = \%<CODE>expansion</CODE>;

    # <COMMENTS>names</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>categories</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>manual</COMMENTS>
    # <COMMENTS>leading</COMMENTS> <COMMENTS>integers</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>sorting</COMMENTS>
    my @<CODE>category_name</CODE> = (
        '<LITERALS>0</LITERALS>. <LITERALS>I</LITERALS>/<LITERALS>O</LITERALS> <LITERALS>control</LITERALS>',
        '<LITERALS>1</LITERALS>. <LITERALS>Basic</LITERALS> <LITERALS>formatting</LITERALS> <LITERALS>options</LITERALS>',
        '<LITERALS>2</LITERALS>. <LITERALS>Code</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>control</LITERALS>',
        '<LITERALS>3</LITERALS>. <LITERALS>Whitespace</LITERALS> <LITERALS>control</LITERALS>',
        '<LITERALS>4</LITERALS>. <LITERALS>Comment</LITERALS> <LITERALS>controls</LITERALS>',
        '<LITERALS>5</LITERALS>. <LITERALS>Linebreak</LITERALS> <LITERALS>controls</LITERALS>',
        '<LITERALS>6</LITERALS>. <LITERALS>Controlling</LITERALS> <LITERALS>list</LITERALS> <LITERALS>formatting</LITERALS>',
        '<LITERALS>7</LITERALS>. <LITERALS>Retaining</LITERALS> <LITERALS>or</LITERALS> <LITERALS>ignoring</LITERALS> <LITERALS>existing</LITERALS> <LITERALS>line</LITERALS> <LITERALS>breaks</LITERALS>',
        '<LITERALS>8</LITERALS>. <LITERALS>Blank</LITERALS> <LITERALS>line</LITERALS> <LITERALS>control</LITERALS>',
        '<LITERALS>9</LITERALS>. <LITERALS>Other</LITERALS> <LITERALS>controls</LITERALS>',
        '<LITERALS>10</LITERALS>. <LITERALS>HTML</LITERALS> <LITERALS>options</LITERALS>',
        '<LITERALS>11</LITERALS>. <LITERALS>pod2html</LITERALS> <LITERALS>options</LITERALS>',
        '<LITERALS>12</LITERALS>. <LITERALS>Controlling</LITERALS> <LITERALS>HTML</LITERALS> <LITERALS>properties</LITERALS>',
        '<LITERALS>13</LITERALS>. <LITERALS>Debugging</LITERALS>',
    );

    #  <COMMENTS>These</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>parsed</COMMENTS> <COMMENTS>directly</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>perltidy</COMMENTS>:
    #    <COMMENTS>help</COMMENTS> <COMMENTS>h</COMMENTS>
    #    <COMMENTS>version</COMMENTS> <COMMENTS>v</COMMENTS>
    #  <COMMENTS>However</COMMENTS>, <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>included</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>will</COMMENTS>
    #  <COMMENTS>be</COMMENTS> <COMMENTS>seen</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>dump</COMMENTS>.

    # <COMMENTS>These</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>abbreviations</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>treated</COMMENTS> <COMMENTS>specially</COMMENTS>
    @<CODE>option_string</CODE> = qw(
      <LITERALS>html</LITERALS>!
      <LITERALS>noprofile</LITERALS>
      <LITERALS>no</LITERALS>-<LITERALS>profile</LITERALS>
      <LITERALS>npro</LITERALS>
      <LITERALS>recombine</LITERALS>!
      <LITERALS>valign</LITERALS>!
      <LITERALS>notidy</LITERALS>
    );

    my $<CODE>category</CODE> = 13;    # <COMMENTS>Debugging</COMMENTS>
    foreach (@<CODE>option_string</CODE>) {
        my $<CODE>opt</CODE> = $<CODE>_</CODE>;     # <COMMENTS>must</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>changing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>flag</COMMENTS>
        $<CODE>opt</CODE> =~ s/!$//;
        $<CODE>option_category</CODE>{$<CODE>opt</CODE>} = $<CODE>category_name</CODE>[$<CODE>category</CODE>];
    }

    $<CODE>category</CODE> = 11;                                       # <COMMENTS>HTML</COMMENTS>
    $<CODE>option_category</CODE>{<LITERALS>html</LITERALS>} = $<CODE>category_name</CODE>[$<CODE>category</CODE>];

    # <COMMENTS>routine</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>install</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>options</COMMENTS>
    my $<CODE>add_option</CODE> = sub {
        my ( $<CODE>long_name</CODE>, $<CODE>short_name</CODE>, $<CODE>flag</CODE> ) = @<CODE>_</CODE>;
        push @<CODE>option_string</CODE>, $<CODE>long_name</CODE> . $<CODE>flag</CODE>;
        $<CODE>option_category</CODE>{$<CODE>long_name</CODE>} = $<CODE>category_name</CODE>[$<CODE>category</CODE>];
        if ($<CODE>short_name</CODE>) {
            if ( $<CODE>expansion</CODE>{$<CODE>short_name</CODE>} ) {
                my $<CODE>existing_name</CODE> = $<CODE>expansion</CODE>{$<CODE>short_name</CODE>}[0];
                <CODE>Die</CODE>
"<LITERALS>redefining</LITERALS> <LITERALS>abbreviation</LITERALS> $<CODE>short_name</CODE> <LITERALS>for</LITERALS> $<CODE>long_name</CODE>; <LITERALS>already</LITERALS> <LITERALS>used</LITERALS> <LITERALS>for</LITERALS> $<CODE>existing_name</CODE>\n";
            }
            $<CODE>expansion</CODE>{$<CODE>short_name</CODE>} = [$<CODE>long_name</CODE>];
            if ( $<CODE>flag</CODE> eq '!' ) {
                my $<CODE>nshort_name</CODE> = '<LITERALS>n</LITERALS>' . $<CODE>short_name</CODE>;
                my $<CODE>nolong_name</CODE> = '<LITERALS>no</LITERALS>' . $<CODE>long_name</CODE>;
                if ( $<CODE>expansion</CODE>{$<CODE>nshort_name</CODE>} ) {
                    my $<CODE>existing_name</CODE> = $<CODE>expansion</CODE>{$<CODE>nshort_name</CODE>}[0];
                    <CODE>Die</CODE>
"<LITERALS>attempting</LITERALS> <LITERALS>to</LITERALS> <LITERALS>redefine</LITERALS> <LITERALS>abbreviation</LITERALS> $<CODE>nshort_name</CODE> <LITERALS>for</LITERALS> $<CODE>nolong_name</CODE>; <LITERALS>already</LITERALS> <LITERALS>used</LITERALS> <LITERALS>for</LITERALS> $<CODE>existing_name</CODE>\n";
                }
                $<CODE>expansion</CODE>{$<CODE>nshort_name</CODE>} = [$<CODE>nolong_name</CODE>];
            }
        }
    };

    # <COMMENTS>Install</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>abbreviation</COMMENTS>.
    # <COMMENTS>Options</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>code</COMMENTS> '!' <COMMENTS>get</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>negation</COMMENTS> ('<COMMENTS>no</COMMENTS>' <COMMENTS>for</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>names</COMMENTS>,
    # '<COMMENTS>n</COMMENTS>' <COMMENTS>for</COMMENTS> <COMMENTS>abbreviations</COMMENTS>).  <COMMENTS>Categories</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>manual</COMMENTS>.

    ###########################
    $<CODE>category</CODE> = 0;    # <COMMENTS>I</COMMENTS>/<COMMENTS>O_Control</COMMENTS>
    ###########################
    $<CODE>add_option</CODE>->( '<LITERALS>backup</LITERALS>-<LITERALS>and</LITERALS>-<LITERALS>modify</LITERALS>-<LITERALS>in</LITERALS>-<LITERALS>place</LITERALS>', '<LITERALS>b</LITERALS>',     '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>backup</LITERALS>-<LITERALS>file</LITERALS>-<LITERALS>extension</LITERALS>',      '<LITERALS>bext</LITERALS>',  '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>force</LITERALS>-<LITERALS>read</LITERALS>-<LITERALS>binary</LITERALS>',          '<LITERALS>f</LITERALS>',     '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>format</LITERALS>',                     '<LITERALS>fmt</LITERALS>',   '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>iterations</LITERALS>',                 '<LITERALS>it</LITERALS>',    '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>logfile</LITERALS>',                    '<LITERALS>log</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>logfile</LITERALS>-<LITERALS>gap</LITERALS>',                '<LITERALS>g</LITERALS>',     ':<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>outfile</LITERALS>',                    '<LITERALS>o</LITERALS>',     '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>output</LITERALS>-<LITERALS>file</LITERALS>-<LITERALS>extension</LITERALS>',      '<LITERALS>oext</LITERALS>',  '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>output</LITERALS>-<LITERALS>path</LITERALS>',                '<LITERALS>opath</LITERALS>', '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>profile</LITERALS>',                    '<LITERALS>pro</LITERALS>',   '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>quiet</LITERALS>',                      '<LITERALS>q</LITERALS>',     '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>standard</LITERALS>-<LITERALS>error</LITERALS>-<LITERALS>output</LITERALS>',      '<LITERALS>se</LITERALS>',    '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>standard</LITERALS>-<LITERALS>output</LITERALS>',            '<LITERALS>st</LITERALS>',    '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>warning</LITERALS>-<LITERALS>output</LITERALS>',             '<LITERALS>w</LITERALS>',     '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>character</LITERALS>-<LITERALS>encoding</LITERALS>',         '<LITERALS>enc</LITERALS>',   '=<LITERALS>s</LITERALS>' );

    # <COMMENTS>options</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>toggle</COMMENTS> <COMMENTS>switches</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>moved</COMMENTS> <COMMENTS>here</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>hide</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>tidyview</COMMENTS> (<COMMENTS>which</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>show</COMMENTS> <COMMENTS>category</COMMENTS> <COMMENTS>0</COMMENTS> <COMMENTS>flags</COMMENTS>):
    # -<COMMENTS>ole</COMMENTS> <COMMENTS>moved</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>category</COMMENTS> <COMMENTS>1</COMMENTS>
    # -<COMMENTS>sil</COMMENTS> <COMMENTS>moved</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>category</COMMENTS> <COMMENTS>2</COMMENTS>
    $<CODE>add_option</CODE>->( '<LITERALS>output</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>ending</LITERALS>',         '<LITERALS>ole</LITERALS>', '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>starting</LITERALS>-<LITERALS>indentation</LITERALS>-<LITERALS>level</LITERALS>', '<LITERALS>sil</LITERALS>', '=<LITERALS>i</LITERALS>' );

    ########################################
    $<CODE>category</CODE> = 1;    # <COMMENTS>Basic</COMMENTS> <COMMENTS>formatting</COMMENTS> <COMMENTS>options</COMMENTS>
    ########################################
    $<CODE>add_option</CODE>->( '<LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>',                 '<LITERALS>syn</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>entab</LITERALS>-<LITERALS>leading</LITERALS>-<LITERALS>whitespace</LITERALS>',     '<LITERALS>et</LITERALS>',   '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>indent</LITERALS>-<LITERALS>columns</LITERALS>',               '<LITERALS>i</LITERALS>',    '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>',          '<LITERALS>l</LITERALS>',    '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>variable</LITERALS>-<LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>', '<LITERALS>vmll</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>whitespace</LITERALS>-<LITERALS>cycle</LITERALS>',             '<LITERALS>wc</LITERALS>',   '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>perl</LITERALS>-<LITERALS>syntax</LITERALS>-<LITERALS>check</LITERALS>-<LITERALS>flags</LITERALS>',      '<LITERALS>pscf</LITERALS>', '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>preserve</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>endings</LITERALS>',        '<LITERALS>ple</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>tabs</LITERALS>',                         '<LITERALS>t</LITERALS>',    '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>default</LITERALS>-<LITERALS>tabsize</LITERALS>',              '<LITERALS>dt</LITERALS>',   '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>extended</LITERALS>-<LITERALS>syntax</LITERALS>',              '<LITERALS>xs</LITERALS>',   '!' );

    ########################################
    $<CODE>category</CODE> = 2;    # <COMMENTS>Code</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>control</COMMENTS>
    ########################################
    $<CODE>add_option</CODE>->( '<LITERALS>continuation</LITERALS>-<LITERALS>indentation</LITERALS>',           '<LITERALS>ci</LITERALS>',   '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>line</LITERALS>-<LITERALS>up</LITERALS>-<LITERALS>parentheses</LITERALS>',                '<LITERALS>lp</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>outdent</LITERALS>-<LITERALS>keyword</LITERALS>-<LITERALS>list</LITERALS>',               '<LITERALS>okwl</LITERALS>', '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>outdent</LITERALS>-<LITERALS>keywords</LITERALS>',                   '<LITERALS>okw</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>outdent</LITERALS>-<LITERALS>labels</LITERALS>',                     '<LITERALS>ola</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>outdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>quotes</LITERALS>',                '<LITERALS>olq</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>indent</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>brace</LITERALS>',               '<LITERALS>icb</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>closing</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>indentation</LITERALS>',          '<LITERALS>cti</LITERALS>',  '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>closing</LITERALS>-<LITERALS>paren</LITERALS>-<LITERALS>indentation</LITERALS>',          '<LITERALS>cpi</LITERALS>',  '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>closing</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>indentation</LITERALS>',          '<LITERALS>cbi</LITERALS>',  '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>closing</LITERALS>-<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>indentation</LITERALS>', '<LITERALS>csbi</LITERALS>', '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>brace</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>and</LITERALS>-<LITERALS>indent</LITERALS>',              '<LITERALS>bli</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>brace</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>and</LITERALS>-<LITERALS>indent</LITERALS>-<LITERALS>list</LITERALS>',         '<LITERALS>blil</LITERALS>', '=<LITERALS>s</LITERALS>' );

    ########################################
    $<CODE>category</CODE> = 3;    # <COMMENTS>Whitespace</COMMENTS> <COMMENTS>control</COMMENTS>
    ########################################
    $<CODE>add_option</CODE>->( '<LITERALS>add</LITERALS>-<LITERALS>semicolons</LITERALS>',                            '<LITERALS>asc</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>add</LITERALS>-<LITERALS>whitespace</LITERALS>',                            '<LITERALS>aws</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>tightness</LITERALS>',                     '<LITERALS>bbt</LITERALS>',   '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>brace</LITERALS>-<LITERALS>tightness</LITERALS>',                           '<LITERALS>bt</LITERALS>',    '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>delete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>whitespace</LITERALS>',                     '<LITERALS>dws</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>delete</LITERALS>-<LITERALS>semicolons</LITERALS>',                         '<LITERALS>dsm</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>nospace</LITERALS>-<LITERALS>after</LITERALS>-<LITERALS>keyword</LITERALS>',                     '<LITERALS>nsak</LITERALS>',  '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>nowant</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>space</LITERALS>',                         '<LITERALS>nwls</LITERALS>',  '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>nowant</LITERALS>-<LITERALS>right</LITERALS>-<LITERALS>space</LITERALS>',                        '<LITERALS>nwrs</LITERALS>',  '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>paren</LITERALS>-<LITERALS>tightness</LITERALS>',                           '<LITERALS>pt</LITERALS>',    '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>space</LITERALS>-<LITERALS>after</LITERALS>-<LITERALS>keyword</LITERALS>',                       '<LITERALS>sak</LITERALS>',   '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>space</LITERALS>-<LITERALS>for</LITERALS>-<LITERALS>semicolon</LITERALS>',                       '<LITERALS>sfs</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>space</LITERALS>-<LITERALS>function</LITERALS>-<LITERALS>paren</LITERALS>',                      '<LITERALS>sfp</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>space</LITERALS>-<LITERALS>keyword</LITERALS>-<LITERALS>paren</LITERALS>',                       '<LITERALS>skp</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>space</LITERALS>-<LITERALS>terminal</LITERALS>-<LITERALS>semicolon</LITERALS>',                  '<LITERALS>sts</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>tightness</LITERALS>',                  '<LITERALS>sbt</LITERALS>',   '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>',         '<LITERALS>sbvt</LITERALS>',  '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>', '<LITERALS>sbvtc</LITERALS>', '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>tight</LITERALS>-<LITERALS>secret</LITERALS>-<LITERALS>operators</LITERALS>',                    '<LITERALS>tso</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>trim</LITERALS>-<LITERALS>qw</LITERALS>',                                   '<LITERALS>tqw</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>trim</LITERALS>-<LITERALS>pod</LITERALS>',                                  '<LITERALS>trp</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>want</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>space</LITERALS>',                           '<LITERALS>wls</LITERALS>',   '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>want</LITERALS>-<LITERALS>right</LITERALS>-<LITERALS>space</LITERALS>',                          '<LITERALS>wrs</LITERALS>',   '=<LITERALS>s</LITERALS>' );

    ########################################
    $<CODE>category</CODE> = 4;    # <COMMENTS>Comment</COMMENTS> <COMMENTS>controls</COMMENTS>
    ########################################
    $<CODE>add_option</CODE>->( '<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>else</LITERALS>-<LITERALS>flag</LITERALS>',    '<LITERALS>csce</LITERALS>', '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>interval</LITERALS>',     '<LITERALS>csci</LITERALS>', '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>list</LITERALS>',         '<LITERALS>cscl</LITERALS>', '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>maximum</LITERALS>-<LITERALS>text</LITERALS>', '<LITERALS>csct</LITERALS>', '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>prefix</LITERALS>',       '<LITERALS>cscp</LITERALS>', '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>warnings</LITERALS>',     '<LITERALS>cscw</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>',             '<LITERALS>csc</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>-<LITERALS>balanced</LITERALS>',    '<LITERALS>cscb</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>format</LITERALS>-<LITERALS>skipping</LITERALS>',                   '<LITERALS>fs</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>format</LITERALS>-<LITERALS>skipping</LITERALS>-<LITERALS>begin</LITERALS>',             '<LITERALS>fsb</LITERALS>',  '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>format</LITERALS>-<LITERALS>skipping</LITERALS>-<LITERALS>end</LITERALS>',               '<LITERALS>fse</LITERALS>',  '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>hanging</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>',             '<LITERALS>hsc</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>indent</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>',             '<LITERALS>ibc</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>indent</LITERALS>-<LITERALS>spaced</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>',      '<LITERALS>isbc</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>fixed</LITERALS>-<LITERALS>position</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>',       '<LITERALS>fpsc</LITERALS>', '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>minimum</LITERALS>-<LITERALS>space</LITERALS>-<LITERALS>to</LITERALS>-<LITERALS>comment</LITERALS>',          '<LITERALS>msc</LITERALS>',  '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>outdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>comments</LITERALS>',             '<LITERALS>olc</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>outdent</LITERALS>-<LITERALS>static</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>',     '<LITERALS>osbc</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>static</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>prefix</LITERALS>',       '<LITERALS>sbcp</LITERALS>', '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>static</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>',             '<LITERALS>sbc</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>static</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>prefix</LITERALS>',        '<LITERALS>sscp</LITERALS>', '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>static</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>',              '<LITERALS>ssc</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>ignore</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>lengths</LITERALS>',       '<LITERALS>iscl</LITERALS>', '!' );

    ########################################
    $<CODE>category</CODE> = 5;    # <COMMENTS>Linebreak</COMMENTS> <COMMENTS>controls</COMMENTS>
    ########################################
    $<CODE>add_option</CODE>->( '<LITERALS>add</LITERALS>-<LITERALS>newlines</LITERALS>',                            '<LITERALS>anl</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>',          '<LITERALS>bbvt</LITERALS>',  '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>list</LITERALS>',     '<LITERALS>bbvtl</LITERALS>', '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>',                '<LITERALS>bvt</LITERALS>',   '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>',        '<LITERALS>bvtc</LITERALS>',  '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>cuddled</LITERALS>-<LITERALS>else</LITERALS>',                            '<LITERALS>ce</LITERALS>',    '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>delete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>newlines</LITERALS>',                     '<LITERALS>dnl</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>always</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>right</LITERALS>',           '<LITERALS>bar</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>',               '<LITERALS>bl</LITERALS>',    '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>opening</LITERALS>-<LITERALS>hash</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>right</LITERALS>',                '<LITERALS>ohbr</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>opening</LITERALS>-<LITERALS>paren</LITERALS>-<LITERALS>right</LITERALS>',                     '<LITERALS>opr</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>opening</LITERALS>-<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>right</LITERALS>',            '<LITERALS>osbr</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>opening</LITERALS>-<LITERALS>anonymous</LITERALS>-<LITERALS>sub</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>', '<LITERALS>asbl</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>opening</LITERALS>-<LITERALS>sub</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>',           '<LITERALS>sbl</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>paren</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>',                '<LITERALS>pvt</LITERALS>',   '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>paren</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>',        '<LITERALS>pvtc</LITERALS>',  '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>stack</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>',               '<LITERALS>scbb</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>stack</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>hash</LITERALS>-<LITERALS>brace</LITERALS>',                '<LITERALS>schb</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>stack</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>paren</LITERALS>',                     '<LITERALS>scp</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>stack</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>',            '<LITERALS>scsb</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>stack</LITERALS>-<LITERALS>opening</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>',               '<LITERALS>sobb</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>stack</LITERALS>-<LITERALS>opening</LITERALS>-<LITERALS>hash</LITERALS>-<LITERALS>brace</LITERALS>',                '<LITERALS>sohb</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>stack</LITERALS>-<LITERALS>opening</LITERALS>-<LITERALS>paren</LITERALS>',                     '<LITERALS>sop</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>stack</LITERALS>-<LITERALS>opening</LITERALS>-<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>',            '<LITERALS>sosb</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>',                      '<LITERALS>vt</LITERALS>',    '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>',              '<LITERALS>vtc</LITERALS>',   '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>want</LITERALS>-<LITERALS>break</LITERALS>-<LITERALS>after</LITERALS>',                        '<LITERALS>wba</LITERALS>',   '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>want</LITERALS>-<LITERALS>break</LITERALS>-<LITERALS>before</LITERALS>',                       '<LITERALS>wbb</LITERALS>',   '=<LITERALS>s</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>break</LITERALS>-<LITERALS>after</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>operators</LITERALS>',               '<LITERALS>baao</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>break</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>operators</LITERALS>',              '<LITERALS>bbao</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>keep</LITERALS>-<LITERALS>interior</LITERALS>-<LITERALS>semicolons</LITERALS>',                '<LITERALS>kis</LITERALS>',   '!' );

    ########################################
    $<CODE>category</CODE> = 6;    # <COMMENTS>Controlling</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>formatting</COMMENTS>
    ########################################
    $<CODE>add_option</CODE>->( '<LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>comma</LITERALS>-<LITERALS>breakpoints</LITERALS>', '<LITERALS>boc</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>comma</LITERALS>-<LITERALS>arrow</LITERALS>-<LITERALS>breakpoints</LITERALS>',        '<LITERALS>cab</LITERALS>', '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>maximum</LITERALS>-<LITERALS>fields</LITERALS>-<LITERALS>per</LITERALS>-<LITERALS>table</LITERALS>',       '<LITERALS>mft</LITERALS>', '=<LITERALS>i</LITERALS>' );

    ########################################
    $<CODE>category</CODE> = 7;    # <COMMENTS>Retaining</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>ignoring</COMMENTS> <COMMENTS>existing</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>breaks</COMMENTS>
    ########################################
    $<CODE>add_option</CODE>->( '<LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>keyword</LITERALS>-<LITERALS>breakpoints</LITERALS>',   '<LITERALS>bok</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>logical</LITERALS>-<LITERALS>breakpoints</LITERALS>',   '<LITERALS>bol</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>ternary</LITERALS>-<LITERALS>breakpoints</LITERALS>',   '<LITERALS>bot</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>attribute</LITERALS>-<LITERALS>breakpoints</LITERALS>', '<LITERALS>boa</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>ignore</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>breakpoints</LITERALS>',             '<LITERALS>iob</LITERALS>', '!' );

    ########################################
    $<CODE>category</CODE> = 8;    # <COMMENTS>Blank</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>control</COMMENTS>
    ########################################
    $<CODE>add_option</CODE>->( '<LITERALS>blanks</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>blocks</LITERALS>',            '<LITERALS>bbb</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>blanks</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>comments</LITERALS>',          '<LITERALS>bbc</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>',         '<LITERALS>blbs</LITERALS>', '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>packages</LITERALS>',     '<LITERALS>blbp</LITERALS>', '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>long</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>count</LITERALS>',           '<LITERALS>lbl</LITERALS>',  '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>maximum</LITERALS>-<LITERALS>consecutive</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>', '<LITERALS>mbl</LITERALS>',  '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>keep</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>',            '<LITERALS>kbl</LITERALS>',  '=<LITERALS>i</LITERALS>' );

    ########################################
    $<CODE>category</CODE> = 9;    # <COMMENTS>Other</COMMENTS> <COMMENTS>controls</COMMENTS>
    ########################################
    $<CODE>add_option</CODE>->( '<LITERALS>delete</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>',        '<LITERALS>dbc</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>delete</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>', '<LITERALS>dcsc</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>delete</LITERALS>-<LITERALS>pod</LITERALS>',                   '<LITERALS>dp</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>delete</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>',         '<LITERALS>dsc</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>tee</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>',           '<LITERALS>tbc</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>tee</LITERALS>-<LITERALS>pod</LITERALS>',                      '<LITERALS>tp</LITERALS>',   '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>tee</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>',            '<LITERALS>tsc</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>look</LITERALS>-<LITERALS>for</LITERALS>-<LITERALS>autoloader</LITERALS>',          '<LITERALS>lal</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>look</LITERALS>-<LITERALS>for</LITERALS>-<LITERALS>hash</LITERALS>-<LITERALS>bang</LITERALS>',           '<LITERALS>x</LITERALS>',    '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>look</LITERALS>-<LITERALS>for</LITERALS>-<LITERALS>selfloader</LITERALS>',          '<LITERALS>lsl</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>pass</LITERALS>-<LITERALS>version</LITERALS>-<LITERALS>line</LITERALS>',            '<LITERALS>pvl</LITERALS>',  '!' );

    ########################################
    $<CODE>category</CODE> = 13;    # <COMMENTS>Debugging</COMMENTS>
    ########################################
    $<CODE>add_option</CODE>->( '<LITERALS>DEBUG</LITERALS>',                           '<LITERALS>D</LITERALS>',    '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>DIAGNOSTICS</LITERALS>',                     '<LITERALS>I</LITERALS>',    '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>dump</LITERALS>-<LITERALS>defaults</LITERALS>',                   '<LITERALS>ddf</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>dump</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>names</LITERALS>',                 '<LITERALS>dln</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>dump</LITERALS>-<LITERALS>options</LITERALS>',                    '<LITERALS>dop</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>dump</LITERALS>-<LITERALS>profile</LITERALS>',                    '<LITERALS>dpro</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>dump</LITERALS>-<LITERALS>short</LITERALS>-<LITERALS>names</LITERALS>',                '<LITERALS>dsn</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>dump</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>types</LITERALS>',                '<LITERALS>dtt</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>dump</LITERALS>-<LITERALS>want</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>space</LITERALS>',            '<LITERALS>dwls</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>dump</LITERALS>-<LITERALS>want</LITERALS>-<LITERALS>right</LITERALS>-<LITERALS>space</LITERALS>',           '<LITERALS>dwrs</LITERALS>', '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>fuzzy</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>',               '<LITERALS>fll</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>help</LITERALS>',                            '<LITERALS>h</LITERALS>',    '' );
    $<CODE>add_option</CODE>->( '<LITERALS>short</LITERALS>-<LITERALS>concatenation</LITERALS>-<LITERALS>item</LITERALS>-<LITERALS>length</LITERALS>', '<LITERALS>scl</LITERALS>',  '=<LITERALS>i</LITERALS>' );
    $<CODE>add_option</CODE>->( '<LITERALS>show</LITERALS>-<LITERALS>options</LITERALS>',                    '<LITERALS>opt</LITERALS>',  '!' );
    $<CODE>add_option</CODE>->( '<LITERALS>version</LITERALS>',                         '<LITERALS>v</LITERALS>',    '' );
    $<CODE>add_option</CODE>->( '<LITERALS>memoize</LITERALS>',                         '<LITERALS>mem</LITERALS>',  '!' );

    #---------------------------------------------------------------------

    # <COMMENTS>The</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>HtmlWriter</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>own</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>string</COMMENTS>
    <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>HtmlWriter</CODE>-><CODE>make_getopt_long_names</CODE>( \@<CODE>option_string</CODE> );

    ########################################
    # <COMMENTS>Set</COMMENTS> <COMMENTS>categories</COMMENTS> <COMMENTS>10</COMMENTS>, <COMMENTS>11</COMMENTS>, <COMMENTS>12</COMMENTS>
    ########################################
    # <COMMENTS>Based</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>known</COMMENTS> <COMMENTS>order</COMMENTS>
    $<CODE>category</CODE> = 12;    # <COMMENTS>HTML</COMMENTS> <COMMENTS>properties</COMMENTS>
    foreach my $<CODE>opt</CODE> (@<CODE>option_string</CODE>) {
        my $<CODE>long_name</CODE> = $<CODE>opt</CODE>;
        $<CODE>long_name</CODE> =~ s/(!|=.*|:.*)$//;
        unless ( defined( $<CODE>option_category</CODE>{$<CODE>long_name</CODE>} ) ) {
            if ( $<CODE>long_name</CODE> =~ /^html-linked/ ) {
                $<CODE>category</CODE> = 10;    # <COMMENTS>HTML</COMMENTS> <COMMENTS>options</COMMENTS>
            }
            elsif ( $<CODE>long_name</CODE> =~ /^pod2html/ ) {
                $<CODE>category</CODE> = 11;    # <COMMENTS>Pod2html</COMMENTS>
            }
            $<CODE>option_category</CODE>{$<CODE>long_name</CODE>} = $<CODE>category_name</CODE>[$<CODE>category</CODE>];
        }
    }

    #---------------------------------------------------------------
    # <COMMENTS>Assign</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>ranges</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>options</COMMENTS>
    #---------------------------------------------------------------
    # <COMMENTS>In</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>future</COMMENTS>, <COMMENTS>these</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>preliminary</COMMENTS> <COMMENTS>checks</COMMENTS>
    # <COMMENTS>hash</COMMENTS> <COMMENTS>keys</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>names</COMMENTS>
    # <COMMENTS>If</COMMENTS> <COMMENTS>key</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>undefined</COMMENTS>:
    #   <COMMENTS>strings</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>value</COMMENTS>
    #   <COMMENTS>integer</COMMENTS> <COMMENTS>ranges</COMMENTS> <COMMENTS>are</COMMENTS> >=<COMMENTS>0</COMMENTS>
    # <COMMENTS>If</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>defined</COMMENTS>:
    #   <COMMENTS>value</COMMENTS> <COMMENTS>is</COMMENTS> [<COMMENTS>qw</COMMENTS>(<COMMENTS>any</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>words</COMMENTS>)] <COMMENTS>for</COMMENTS> <COMMENTS>strings</COMMENTS>
    #   <COMMENTS>value</COMMENTS> <COMMENTS>is</COMMENTS> [<COMMENTS>min</COMMENTS>, <COMMENTS>max</COMMENTS>] <COMMENTS>for</COMMENTS> <COMMENTS>integers</COMMENTS>
    #   <COMMENTS>if</COMMENTS> <COMMENTS>min</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>undefined</COMMENTS>, <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>lower</COMMENTS> <COMMENTS>limit</COMMENTS>
    #   <COMMENTS>if</COMMENTS> <COMMENTS>max</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>undefined</COMMENTS>, <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>upper</COMMENTS> <COMMENTS>limit</COMMENTS>
    # <COMMENTS>Parameters</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>listed</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>defaults</COMMENTS>
    %<CODE>option_range</CODE> = (
        '<LITERALS>format</LITERALS>'             => [ '<LITERALS>tidy</LITERALS>', '<LITERALS>html</LITERALS>', '<LITERALS>user</LITERALS>' ],
        '<LITERALS>output</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>ending</LITERALS>' => [ '<LITERALS>dos</LITERALS>',  '<LITERALS>win</LITERALS>',  '<LITERALS>mac</LITERALS>', '<LITERALS>unix</LITERALS>' ],
        '<LITERALS>character</LITERALS>-<LITERALS>encoding</LITERALS>' => [ '<LITERALS>none</LITERALS>', '<LITERALS>utf8</LITERALS>' ],

        '<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>tightness</LITERALS>'    => [ 0, 2 ],
        '<LITERALS>brace</LITERALS>-<LITERALS>tightness</LITERALS>'          => [ 0, 2 ],
        '<LITERALS>paren</LITERALS>-<LITERALS>tightness</LITERALS>'          => [ 0, 2 ],
        '<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>tightness</LITERALS>' => [ 0, 2 ],

        '<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'            => [ 0, 2 ],
        '<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'                  => [ 0, 2 ],
        '<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'          => [ 0, 2 ],
        '<LITERALS>paren</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'                  => [ 0, 2 ],
        '<LITERALS>paren</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'          => [ 0, 2 ],
        '<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'         => [ 0, 2 ],
        '<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>' => [ 0, 2 ],
        '<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'                        => [ 0, 2 ],
        '<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'                => [ 0, 2 ],

        '<LITERALS>closing</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>indentation</LITERALS>'          => [ 0, 3 ],
        '<LITERALS>closing</LITERALS>-<LITERALS>paren</LITERALS>-<LITERALS>indentation</LITERALS>'          => [ 0, 3 ],
        '<LITERALS>closing</LITERALS>-<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>indentation</LITERALS>' => [ 0, 3 ],
        '<LITERALS>closing</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>indentation</LITERALS>'          => [ 0, 3 ],

        '<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>else</LITERALS>-<LITERALS>flag</LITERALS>' => [ 0, 2 ],
        '<LITERALS>comma</LITERALS>-<LITERALS>arrow</LITERALS>-<LITERALS>breakpoints</LITERALS>'        => [ 0, 5 ],
    );

    # <COMMENTS>Note</COMMENTS>: <COMMENTS>we</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>actually</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>negative</COMMENTS> <COMMENTS>ci</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>someone</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>wants</COMMENTS> <COMMENTS>it</COMMENTS>:
    # <COMMENTS>$option_range</COMMENTS>{'<COMMENTS>continuation</COMMENTS>-<COMMENTS>indentation</COMMENTS>'} = [ <COMMENTS>undef</COMMENTS>, <COMMENTS>undef</COMMENTS> ];

    #---------------------------------------------------------------
    # <COMMENTS>Assign</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>here</COMMENTS>, <COMMENTS>except</COMMENTS>
    # <COMMENTS>for</COMMENTS> '<COMMENTS>outfile</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>help</COMMENTS>'.
    # <COMMENTS>These</COMMENTS> <COMMENTS>settings</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>approximate</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>perlstyle</COMMENTS>(<COMMENTS>1</COMMENTS>) <COMMENTS>suggestions</COMMENTS>.
    #---------------------------------------------------------------
    my @<CODE>defaults</CODE> = qw(
      <LITERALS>add</LITERALS>-<LITERALS>newlines</LITERALS>
      <LITERALS>add</LITERALS>-<LITERALS>semicolons</LITERALS>
      <LITERALS>add</LITERALS>-<LITERALS>whitespace</LITERALS>
      <LITERALS>blanks</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>blocks</LITERALS>
      <LITERALS>blanks</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>comments</LITERALS>
      <LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>=<LITERALS>1</LITERALS>
      <LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>packages</LITERALS>=<LITERALS>1</LITERALS>
      <LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>brace</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>1</LITERALS>
      <LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>logical</LITERALS>-<LITERALS>breakpoints</LITERALS>
      <LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>ternary</LITERALS>-<LITERALS>breakpoints</LITERALS>
      <LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>attribute</LITERALS>-<LITERALS>breakpoints</LITERALS>
      <LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>keyword</LITERALS>-<LITERALS>breakpoints</LITERALS>
      <LITERALS>comma</LITERALS>-<LITERALS>arrow</LITERALS>-<LITERALS>breakpoints</LITERALS>=<LITERALS>5</LITERALS>
      <LITERALS>nocheck</LITERALS>-<LITERALS>syntax</LITERALS>
      <LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>interval</LITERALS>=<LITERALS>6</LITERALS>
      <LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>maximum</LITERALS>-<LITERALS>text</LITERALS>=<LITERALS>20</LITERALS>
      <LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>else</LITERALS>-<LITERALS>flag</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>-<LITERALS>balanced</LITERALS>
      <LITERALS>closing</LITERALS>-<LITERALS>paren</LITERALS>-<LITERALS>indentation</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>closing</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>indentation</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>closing</LITERALS>-<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>indentation</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>continuation</LITERALS>-<LITERALS>indentation</LITERALS>=<LITERALS>2</LITERALS>
      <LITERALS>delete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>newlines</LITERALS>
      <LITERALS>delete</LITERALS>-<LITERALS>semicolons</LITERALS>
      <LITERALS>extended</LITERALS>-<LITERALS>syntax</LITERALS>
      <LITERALS>fuzzy</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>
      <LITERALS>hanging</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>
      <LITERALS>indent</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>
      <LITERALS>indent</LITERALS>-<LITERALS>columns</LITERALS>=<LITERALS>4</LITERALS>
      <LITERALS>iterations</LITERALS>=<LITERALS>1</LITERALS>
      <LITERALS>keep</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>=<LITERALS>1</LITERALS>
      <LITERALS>long</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>count</LITERALS>=<LITERALS>8</LITERALS>
      <LITERALS>look</LITERALS>-<LITERALS>for</LITERALS>-<LITERALS>autoloader</LITERALS>
      <LITERALS>look</LITERALS>-<LITERALS>for</LITERALS>-<LITERALS>selfloader</LITERALS>
      <LITERALS>maximum</LITERALS>-<LITERALS>consecutive</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>=<LITERALS>1</LITERALS>
      <LITERALS>maximum</LITERALS>-<LITERALS>fields</LITERALS>-<LITERALS>per</LITERALS>-<LITERALS>table</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>=<LITERALS>80</LITERALS>
      <LITERALS>memoize</LITERALS>
      <LITERALS>minimum</LITERALS>-<LITERALS>space</LITERALS>-<LITERALS>to</LITERALS>-<LITERALS>comment</LITERALS>=<LITERALS>4</LITERALS>
      <LITERALS>nobrace</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>and</LITERALS>-<LITERALS>indent</LITERALS>
      <LITERALS>nocuddled</LITERALS>-<LITERALS>else</LITERALS>
      <LITERALS>nodelete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>whitespace</LITERALS>
      <LITERALS>nohtml</LITERALS>
      <LITERALS>nologfile</LITERALS>
      <LITERALS>noquiet</LITERALS>
      <LITERALS>noshow</LITERALS>-<LITERALS>options</LITERALS>
      <LITERALS>nostatic</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>
      <LITERALS>notabs</LITERALS>
      <LITERALS>nowarning</LITERALS>-<LITERALS>output</LITERALS>
      <LITERALS>character</LITERALS>-<LITERALS>encoding</LITERALS>=<LITERALS>none</LITERALS>
      <LITERALS>outdent</LITERALS>-<LITERALS>labels</LITERALS>
      <LITERALS>outdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>quotes</LITERALS>
      <LITERALS>outdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>comments</LITERALS>
      <LITERALS>paren</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>1</LITERALS>
      <LITERALS>paren</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>paren</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>pass</LITERALS>-<LITERALS>version</LITERALS>-<LITERALS>line</LITERALS>
      <LITERALS>recombine</LITERALS>
      <LITERALS>valign</LITERALS>
      <LITERALS>short</LITERALS>-<LITERALS>concatenation</LITERALS>-<LITERALS>item</LITERALS>-<LITERALS>length</LITERALS>=<LITERALS>8</LITERALS>
      <LITERALS>space</LITERALS>-<LITERALS>for</LITERALS>-<LITERALS>semicolon</LITERALS>
      <LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>1</LITERALS>
      <LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>0</LITERALS>
      <LITERALS>static</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>
      <LITERALS>trim</LITERALS>-<LITERALS>qw</LITERALS>
      <LITERALS>format</LITERALS>=<LITERALS>tidy</LITERALS>
      <LITERALS>backup</LITERALS>-<LITERALS>file</LITERALS>-<LITERALS>extension</LITERALS>=<LITERALS>bak</LITERALS>
      <LITERALS>format</LITERALS>-<LITERALS>skipping</LITERALS>
      <LITERALS>default</LITERALS>-<LITERALS>tabsize</LITERALS>=<LITERALS>8</LITERALS>

      <LITERALS>pod2html</LITERALS>
      <LITERALS>html</LITERALS>-<LITERALS>table</LITERALS>-<LITERALS>of</LITERALS>-<LITERALS>contents</LITERALS>
      <LITERALS>html</LITERALS>-<LITERALS>entities</LITERALS>
    );

    push @<CODE>defaults</CODE>, "<LITERALS>perl</LITERALS>-<LITERALS>syntax</LITERALS>-<LITERALS>check</LITERALS>-<LITERALS>flags</LITERALS>=-<LITERALS>c</LITERALS> -<LITERALS>T</LITERALS>";

    #---------------------------------------------------------------
    # <COMMENTS>Define</COMMENTS> <COMMENTS>abbreviations</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>expanded</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>primitives</COMMENTS>.
    # <COMMENTS>These</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>recursively</COMMENTS>.
    #---------------------------------------------------------------
    %<CODE>expansion</CODE> = (
        %<CODE>expansion</CODE>,
        '<LITERALS>freeze</LITERALS>-<LITERALS>newlines</LITERALS>'   => [qw(<LITERALS>noadd</LITERALS>-<LITERALS>newlines</LITERALS> <LITERALS>nodelete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>newlines</LITERALS>)],
        '<LITERALS>fnl</LITERALS>'               => [qw(<LITERALS>freeze</LITERALS>-<LITERALS>newlines</LITERALS>)],
        '<LITERALS>freeze</LITERALS>-<LITERALS>whitespace</LITERALS>' => [qw(<LITERALS>noadd</LITERALS>-<LITERALS>whitespace</LITERALS> <LITERALS>nodelete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>whitespace</LITERALS>)],
        '<LITERALS>fws</LITERALS>'               => [qw(<LITERALS>freeze</LITERALS>-<LITERALS>whitespace</LITERALS>)],
        '<LITERALS>freeze</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>' =>
          [qw(<LITERALS>maximum</LITERALS>-<LITERALS>consecutive</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>keep</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>=<LITERALS>2</LITERALS>)],
        '<LITERALS>fbl</LITERALS>'                => [qw(<LITERALS>freeze</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>)],
        '<LITERALS>indent</LITERALS>-<LITERALS>only</LITERALS>'        => [qw(<LITERALS>freeze</LITERALS>-<LITERALS>newlines</LITERALS> <LITERALS>freeze</LITERALS>-<LITERALS>whitespace</LITERALS>)],
        '<LITERALS>outdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>lines</LITERALS>' => [qw(<LITERALS>outdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>quotes</LITERALS> <LITERALS>outdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>comments</LITERALS>)],
        '<LITERALS>nooutdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>lines</LITERALS>' =>
          [qw(<LITERALS>nooutdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>quotes</LITERALS> <LITERALS>nooutdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>comments</LITERALS>)],
        '<LITERALS>noll</LITERALS>' => [qw(<LITERALS>nooutdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>lines</LITERALS>)],
        '<LITERALS>io</LITERALS>'   => [qw(<LITERALS>indent</LITERALS>-<LITERALS>only</LITERALS>)],
        '<LITERALS>delete</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>comments</LITERALS>' =>
          [qw(<LITERALS>delete</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS> <LITERALS>delete</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS> <LITERALS>delete</LITERALS>-<LITERALS>pod</LITERALS>)],
        '<LITERALS>nodelete</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>comments</LITERALS>' =>
          [qw(<LITERALS>nodelete</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS> <LITERALS>nodelete</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS> <LITERALS>nodelete</LITERALS>-<LITERALS>pod</LITERALS>)],
        '<LITERALS>dac</LITERALS>'  => [qw(<LITERALS>delete</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>comments</LITERALS>)],
        '<LITERALS>ndac</LITERALS>' => [qw(<LITERALS>nodelete</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>comments</LITERALS>)],
        '<LITERALS>gnu</LITERALS>'  => [qw(<LITERALS>gnu</LITERALS>-<LITERALS>style</LITERALS>)],
        '<LITERALS>pbp</LITERALS>'  => [qw(<LITERALS>perl</LITERALS>-<LITERALS>best</LITERALS>-<LITERALS>practices</LITERALS>)],
        '<LITERALS>tee</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>comments</LITERALS>' =>
          [qw(<LITERALS>tee</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS> <LITERALS>tee</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS> <LITERALS>tee</LITERALS>-<LITERALS>pod</LITERALS>)],
        '<LITERALS>notee</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>comments</LITERALS>' =>
          [qw(<LITERALS>notee</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS> <LITERALS>notee</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS> <LITERALS>notee</LITERALS>-<LITERALS>pod</LITERALS>)],
        '<LITERALS>tac</LITERALS>'   => [qw(<LITERALS>tee</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>comments</LITERALS>)],
        '<LITERALS>ntac</LITERALS>'  => [qw(<LITERALS>notee</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>comments</LITERALS>)],
        '<LITERALS>html</LITERALS>'  => [qw(<LITERALS>format</LITERALS>=<LITERALS>html</LITERALS>)],
        '<LITERALS>nhtml</LITERALS>' => [qw(<LITERALS>format</LITERALS>=<LITERALS>tidy</LITERALS>)],
        '<LITERALS>tidy</LITERALS>'  => [qw(<LITERALS>format</LITERALS>=<LITERALS>tidy</LITERALS>)],

        '<LITERALS>utf8</LITERALS>' => [qw(<LITERALS>character</LITERALS>-<LITERALS>encoding</LITERALS>=<LITERALS>utf8</LITERALS>)],
        '<LITERALS>UTF8</LITERALS>' => [qw(<LITERALS>character</LITERALS>-<LITERALS>encoding</LITERALS>=<LITERALS>utf8</LITERALS>)],

        '<LITERALS>swallow</LITERALS>-<LITERALS>optional</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>'   => [qw(<LITERALS>kbl</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>noswallow</LITERALS>-<LITERALS>optional</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>' => [qw(<LITERALS>kbl</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>sob</LITERALS>'                            => [qw(<LITERALS>kbl</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>nsob</LITERALS>'                           => [qw(<LITERALS>kbl</LITERALS>=<LITERALS>1</LITERALS>)],

        '<LITERALS>break</LITERALS>-<LITERALS>after</LITERALS>-<LITERALS>comma</LITERALS>-<LITERALS>arrows</LITERALS>'   => [qw(<LITERALS>cab</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>nobreak</LITERALS>-<LITERALS>after</LITERALS>-<LITERALS>comma</LITERALS>-<LITERALS>arrows</LITERALS>' => [qw(<LITERALS>cab</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>baa</LITERALS>'                        => [qw(<LITERALS>cab</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>nbaa</LITERALS>'                       => [qw(<LITERALS>cab</LITERALS>=<LITERALS>1</LITERALS>)],

        '<LITERALS>blanks</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>'   => [qw(<LITERALS>blbs</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>blbp</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>bbs</LITERALS>'                  => [qw(<LITERALS>blbs</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>blbp</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>noblanks</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>' => [qw(<LITERALS>blbs</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>blbp</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>nbbs</LITERALS>'                 => [qw(<LITERALS>blbs</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>blbp</LITERALS>=<LITERALS>0</LITERALS>)],

        '<LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>trinary</LITERALS>-<LITERALS>breakpoints</LITERALS>' => [qw(<LITERALS>bot</LITERALS>)],

        '<LITERALS>cti</LITERALS>=<LITERALS>0</LITERALS>' => [qw(<LITERALS>cpi</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>cbi</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>csbi</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>cti</LITERALS>=<LITERALS>1</LITERALS>' => [qw(<LITERALS>cpi</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>cbi</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>csbi</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>cti</LITERALS>=<LITERALS>2</LITERALS>' => [qw(<LITERALS>cpi</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>cbi</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>csbi</LITERALS>=<LITERALS>2</LITERALS>)],
        '<LITERALS>icp</LITERALS>'   => [qw(<LITERALS>cpi</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>cbi</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>csbi</LITERALS>=<LITERALS>2</LITERALS>)],
        '<LITERALS>nicp</LITERALS>'  => [qw(<LITERALS>cpi</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>cbi</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>csbi</LITERALS>=<LITERALS>0</LITERALS>)],

        '<LITERALS>closing</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>indentation</LITERALS>=<LITERALS>0</LITERALS>' => [qw(<LITERALS>cpi</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>cbi</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>csbi</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>closing</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>indentation</LITERALS>=<LITERALS>1</LITERALS>' => [qw(<LITERALS>cpi</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>cbi</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>csbi</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>closing</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>indentation</LITERALS>=<LITERALS>2</LITERALS>' => [qw(<LITERALS>cpi</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>cbi</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>csbi</LITERALS>=<LITERALS>2</LITERALS>)],
        '<LITERALS>indent</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>paren</LITERALS>'        => [qw(<LITERALS>cpi</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>cbi</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>csbi</LITERALS>=<LITERALS>2</LITERALS>)],
        '<LITERALS>noindent</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>paren</LITERALS>'      => [qw(<LITERALS>cpi</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>cbi</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>csbi</LITERALS>=<LITERALS>0</LITERALS>)],

        '<LITERALS>vt</LITERALS>=<LITERALS>0</LITERALS>' => [qw(<LITERALS>pvt</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>bvt</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>sbvt</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>vt</LITERALS>=<LITERALS>1</LITERALS>' => [qw(<LITERALS>pvt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>bvt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>sbvt</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>vt</LITERALS>=<LITERALS>2</LITERALS>' => [qw(<LITERALS>pvt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>bvt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>sbvt</LITERALS>=<LITERALS>2</LITERALS>)],

        '<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>0</LITERALS>' => [qw(<LITERALS>pvt</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>bvt</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>sbvt</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>1</LITERALS>' => [qw(<LITERALS>pvt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>bvt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>sbvt</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>2</LITERALS>' => [qw(<LITERALS>pvt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>bvt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>sbvt</LITERALS>=<LITERALS>2</LITERALS>)],

        '<LITERALS>vtc</LITERALS>=<LITERALS>0</LITERALS>' => [qw(<LITERALS>pvtc</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>bvtc</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>sbvtc</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>vtc</LITERALS>=<LITERALS>1</LITERALS>' => [qw(<LITERALS>pvtc</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>bvtc</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>sbvtc</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>vtc</LITERALS>=<LITERALS>2</LITERALS>' => [qw(<LITERALS>pvtc</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>bvtc</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>sbvtc</LITERALS>=<LITERALS>2</LITERALS>)],

        '<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>=<LITERALS>0</LITERALS>' => [qw(<LITERALS>pvtc</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>bvtc</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>sbvtc</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>=<LITERALS>1</LITERALS>' => [qw(<LITERALS>pvtc</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>bvtc</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>sbvtc</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>=<LITERALS>2</LITERALS>' => [qw(<LITERALS>pvtc</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>bvtc</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>sbvtc</LITERALS>=<LITERALS>2</LITERALS>)],

        '<LITERALS>otr</LITERALS>'                   => [qw(<LITERALS>opr</LITERALS> <LITERALS>ohbr</LITERALS> <LITERALS>osbr</LITERALS>)],
        '<LITERALS>opening</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>right</LITERALS>'   => [qw(<LITERALS>opr</LITERALS> <LITERALS>ohbr</LITERALS> <LITERALS>osbr</LITERALS>)],
        '<LITERALS>notr</LITERALS>'                  => [qw(<LITERALS>nopr</LITERALS> <LITERALS>nohbr</LITERALS> <LITERALS>nosbr</LITERALS>)],
        '<LITERALS>noopening</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>right</LITERALS>' => [qw(<LITERALS>nopr</LITERALS> <LITERALS>nohbr</LITERALS> <LITERALS>nosbr</LITERALS>)],

        '<LITERALS>sot</LITERALS>'                    => [qw(<LITERALS>sop</LITERALS> <LITERALS>sohb</LITERALS> <LITERALS>sosb</LITERALS>)],
        '<LITERALS>nsot</LITERALS>'                   => [qw(<LITERALS>nsop</LITERALS> <LITERALS>nsohb</LITERALS> <LITERALS>nsosb</LITERALS>)],
        '<LITERALS>stack</LITERALS>-<LITERALS>opening</LITERALS>-<LITERALS>tokens</LITERALS>'   => [qw(<LITERALS>sop</LITERALS> <LITERALS>sohb</LITERALS> <LITERALS>sosb</LITERALS>)],
        '<LITERALS>nostack</LITERALS>-<LITERALS>opening</LITERALS>-<LITERALS>tokens</LITERALS>' => [qw(<LITERALS>nsop</LITERALS> <LITERALS>nsohb</LITERALS> <LITERALS>nsosb</LITERALS>)],

        '<LITERALS>sct</LITERALS>'                    => [qw(<LITERALS>scp</LITERALS> <LITERALS>schb</LITERALS> <LITERALS>scsb</LITERALS>)],
        '<LITERALS>stack</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>tokens</LITERALS>'   => => [qw(<LITERALS>scp</LITERALS> <LITERALS>schb</LITERALS> <LITERALS>scsb</LITERALS>)],
        '<LITERALS>nsct</LITERALS>'                   => [qw(<LITERALS>nscp</LITERALS> <LITERALS>nschb</LITERALS> <LITERALS>nscsb</LITERALS>)],
        '<LITERALS>nostack</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>tokens</LITERALS>' => [qw(<LITERALS>nscp</LITERALS> <LITERALS>nschb</LITERALS> <LITERALS>nscsb</LITERALS>)],

        '<LITERALS>sac</LITERALS>'                    => [qw(<LITERALS>sot</LITERALS> <LITERALS>sct</LITERALS>)],
        '<LITERALS>nsac</LITERALS>'                   => [qw(<LITERALS>nsot</LITERALS> <LITERALS>nsct</LITERALS>)],
        '<LITERALS>stack</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>containers</LITERALS>'   => [qw(<LITERALS>sot</LITERALS> <LITERALS>sct</LITERALS>)],
        '<LITERALS>nostack</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>containers</LITERALS>' => [qw(<LITERALS>nsot</LITERALS> <LITERALS>nsct</LITERALS>)],

        '<LITERALS>act</LITERALS>=<LITERALS>0</LITERALS>'                      => [qw(<LITERALS>pt</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>sbt</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>bt</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>bbt</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>act</LITERALS>=<LITERALS>1</LITERALS>'                      => [qw(<LITERALS>pt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>sbt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>bt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>bbt</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>act</LITERALS>=<LITERALS>2</LITERALS>'                      => [qw(<LITERALS>pt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>sbt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>bt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>bbt</LITERALS>=<LITERALS>2</LITERALS>)],
        '<LITERALS>all</LITERALS>-<LITERALS>containers</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>0</LITERALS>' => [qw(<LITERALS>pt</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>sbt</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>bt</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>bbt</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>all</LITERALS>-<LITERALS>containers</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>1</LITERALS>' => [qw(<LITERALS>pt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>sbt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>bt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>bbt</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>all</LITERALS>-<LITERALS>containers</LITERALS>-<LITERALS>tightness</LITERALS>=<LITERALS>2</LITERALS>' => [qw(<LITERALS>pt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>sbt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>bt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>bbt</LITERALS>=<LITERALS>2</LITERALS>)],

        '<LITERALS>stack</LITERALS>-<LITERALS>opening</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>'   => [qw(<LITERALS>bbvt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>bbvtl</LITERALS>=*)],
        '<LITERALS>sobb</LITERALS>'                        => [qw(<LITERALS>bbvt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>bbvtl</LITERALS>=*)],
        '<LITERALS>nostack</LITERALS>-<LITERALS>opening</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>' => [qw(<LITERALS>bbvt</LITERALS>=<LITERALS>0</LITERALS>)],
        '<LITERALS>nsobb</LITERALS>'                       => [qw(<LITERALS>bbvt</LITERALS>=<LITERALS>0</LITERALS>)],

        '<LITERALS>converge</LITERALS>'   => [qw(<LITERALS>it</LITERALS>=<LITERALS>4</LITERALS>)],
        '<LITERALS>noconverge</LITERALS>' => [qw(<LITERALS>it</LITERALS>=<LITERALS>1</LITERALS>)],
        '<LITERALS>conv</LITERALS>'       => [qw(<LITERALS>it</LITERALS>=<LITERALS>4</LITERALS>)],
        '<LITERALS>nconv</LITERALS>'      => [qw(<LITERALS>it</LITERALS>=<LITERALS>1</LITERALS>)],

        # '<COMMENTS>mangle</COMMENTS>' <COMMENTS>originally</COMMENTS> <COMMENTS>deleted</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>comments</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>it</COMMENTS>
        # <COMMENTS>reversible</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>longer</COMMENTS> <COMMENTS>does</COMMENTS>.  <COMMENTS>But</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS>
        # <COMMENTS>delete</COMMENTS> <COMMENTS>them</COMMENTS>, <COMMENTS>just</COMMENTS> <COMMENTS>use</COMMENTS>:
        #   -<COMMENTS>mangle</COMMENTS> -<COMMENTS>dac</COMMENTS>

        # <COMMENTS>An</COMMENTS> <COMMENTS>interesting</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>for</COMMENTS> '<COMMENTS>mangle</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS>:
        #    <COMMENTS>perltidy</COMMENTS> -<COMMENTS>mangle</COMMENTS> <COMMENTS>myfile</COMMENTS>.<COMMENTS>pl</COMMENTS> -<COMMENTS>st</COMMENTS> | <COMMENTS>perltidy</COMMENTS> -<COMMENTS>o</COMMENTS> <COMMENTS>myfile</COMMENTS>.<COMMENTS>pl</COMMENTS>.<COMMENTS>new</COMMENTS>
        # <COMMENTS>which</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>form</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>possible</COMMENTS>

        '<LITERALS>mangle</LITERALS>' => [
            qw(
              <LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>
              <LITERALS>keep</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>=<LITERALS>0</LITERALS>
              <LITERALS>delete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>newlines</LITERALS>
              <LITERALS>delete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>whitespace</LITERALS>
              <LITERALS>delete</LITERALS>-<LITERALS>semicolons</LITERALS>
              <LITERALS>indent</LITERALS>-<LITERALS>columns</LITERALS>=<LITERALS>0</LITERALS>
              <LITERALS>maximum</LITERALS>-<LITERALS>consecutive</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>=<LITERALS>0</LITERALS>
              <LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>=<LITERALS>100000</LITERALS>
              <LITERALS>noadd</LITERALS>-<LITERALS>newlines</LITERALS>
              <LITERALS>noadd</LITERALS>-<LITERALS>semicolons</LITERALS>
              <LITERALS>noadd</LITERALS>-<LITERALS>whitespace</LITERALS>
              <LITERALS>noblanks</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>blocks</LITERALS>
              <LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>=<LITERALS>0</LITERALS>
              <LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>packages</LITERALS>=<LITERALS>0</LITERALS>
              <LITERALS>notabs</LITERALS>
              )
        ],

        # '<COMMENTS>extrude</COMMENTS>' <COMMENTS>originally</COMMENTS> <COMMENTS>deleted</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>comments</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>it</COMMENTS>
        # <COMMENTS>reversible</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>longer</COMMENTS> <COMMENTS>does</COMMENTS>.  <COMMENTS>But</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS>
        # <COMMENTS>delete</COMMENTS> <COMMENTS>them</COMMENTS>, <COMMENTS>just</COMMENTS> <COMMENTS>use</COMMENTS>
        #   <COMMENTS>extrude</COMMENTS> -<COMMENTS>dac</COMMENTS>
        #
        # <COMMENTS>An</COMMENTS> <COMMENTS>interesting</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>for</COMMENTS> '<COMMENTS>extrude</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS>:
        #    <COMMENTS>perltidy</COMMENTS> -<COMMENTS>extrude</COMMENTS> <COMMENTS>myfile</COMMENTS>.<COMMENTS>pl</COMMENTS> -<COMMENTS>st</COMMENTS> | <COMMENTS>perltidy</COMMENTS> -<COMMENTS>o</COMMENTS> <COMMENTS>myfile</COMMENTS>.<COMMENTS>pl</COMMENTS>.<COMMENTS>new</COMMENTS>
        # <COMMENTS>which</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS>.

        '<LITERALS>extrude</LITERALS>' => [
            qw(
              <LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>
              <LITERALS>ci</LITERALS>=<LITERALS>0</LITERALS>
              <LITERALS>delete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>newlines</LITERALS>
              <LITERALS>delete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>whitespace</LITERALS>
              <LITERALS>delete</LITERALS>-<LITERALS>semicolons</LITERALS>
              <LITERALS>indent</LITERALS>-<LITERALS>columns</LITERALS>=<LITERALS>0</LITERALS>
              <LITERALS>maximum</LITERALS>-<LITERALS>consecutive</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>=<LITERALS>0</LITERALS>
              <LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>=<LITERALS>1</LITERALS>
              <LITERALS>noadd</LITERALS>-<LITERALS>semicolons</LITERALS>
              <LITERALS>noadd</LITERALS>-<LITERALS>whitespace</LITERALS>
              <LITERALS>noblanks</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>blocks</LITERALS>
              <LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>=<LITERALS>0</LITERALS>
              <LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>packages</LITERALS>=<LITERALS>0</LITERALS>
              <LITERALS>nofuzzy</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>
              <LITERALS>notabs</LITERALS>
              <LITERALS>norecombine</LITERALS>
              )
        ],

        # <COMMENTS>this</COMMENTS> <COMMENTS>style</COMMENTS> <COMMENTS>tries</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>GNU</COMMENTS> <COMMENTS>Coding</COMMENTS> <COMMENTS>Standards</COMMENTS> (<COMMENTS>which</COMMENTS> <COMMENTS>do</COMMENTS>
        # <COMMENTS>not</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>apply</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>perl</COMMENTS>
        # <COMMENTS>programmers</COMMENTS>).
        '<LITERALS>gnu</LITERALS>-<LITERALS>style</LITERALS>' => [
            qw(
              <LITERALS>lp</LITERALS> <LITERALS>bl</LITERALS> <LITERALS>noll</LITERALS> <LITERALS>pt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>bt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>sbt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>cpi</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>csbi</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>cbi</LITERALS>=<LITERALS>1</LITERALS>
              )
        ],

        # <COMMENTS>Style</COMMENTS> <COMMENTS>suggested</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>Damian</COMMENTS> <COMMENTS>Conway</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>Perl</COMMENTS> <COMMENTS>Best</COMMENTS> <COMMENTS>Practices</COMMENTS>
        '<LITERALS>perl</LITERALS>-<LITERALS>best</LITERALS>-<LITERALS>practices</LITERALS>' => [
            qw(<LITERALS>l</LITERALS>=<LITERALS>78</LITERALS> <LITERALS>i</LITERALS>=<LITERALS>4</LITERALS> <LITERALS>ci</LITERALS>=<LITERALS>4</LITERALS> <LITERALS>st</LITERALS> <LITERALS>se</LITERALS> <LITERALS>vt</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>cti</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>pt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>bt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>sbt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>bbt</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>nsfs</LITERALS> <LITERALS>nolq</LITERALS>),
q(<LITERALS>wbb</LITERALS>=% + - * / <LITERALS>x</LITERALS> != == >= <= =~ !~ < > | & = **= += *= &= <<= &&= -= /= |= >>= ||= //= .= %= ^= <LITERALS>x</LITERALS>=)
        ],

        # <COMMENTS>Additional</COMMENTS> <COMMENTS>styles</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>added</COMMENTS> <COMMENTS>here</COMMENTS>
    );

    <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>HtmlWriter</CODE>-><CODE>make_abbreviated_names</CODE>( \%<CODE>expansion</CODE> );

    # <COMMENTS>Uncomment</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>dump</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>expansions</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>debugging</COMMENTS>:
    # <COMMENTS>dump_short_names</COMMENTS>(\%<COMMENTS>expansion</COMMENTS>);
    return (
        \@<CODE>option_string</CODE>,   \@<CODE>defaults</CODE>, \%<CODE>expansion</CODE>,
        \%<CODE>option_category</CODE>, \%<CODE>option_range</CODE>
    );

}    # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>generate_options</COMMENTS>

# <COMMENTS>Memoize</COMMENTS> <COMMENTS>process_command_line</COMMENTS>. <COMMENTS>Given</COMMENTS> <COMMENTS>same</COMMENTS> @<COMMENTS>ARGV</COMMENTS> <COMMENTS>passed</COMMENTS> <COMMENTS>in</COMMENTS>, <COMMENTS>return</COMMENTS> <COMMENTS>same</COMMENTS>
# <COMMENTS>values</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>same</COMMENTS> @<COMMENTS>ARGV</COMMENTS> <COMMENTS>back</COMMENTS>.
# <COMMENTS>This</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>supplied</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>Jonathan</COMMENTS> <COMMENTS>Swartz</COMMENTS> <COMMENTS>Nov</COMMENTS> <COMMENTS>2012</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>significantly</COMMENTS> <COMMENTS>speeds</COMMENTS>
# <COMMENTS>up</COMMENTS> <COMMENTS>masontidy</COMMENTS> (<COMMENTS>https</COMMENTS>://<COMMENTS>metacpan</COMMENTS>.<COMMENTS>org</COMMENTS>/<COMMENTS>module</COMMENTS>/<COMMENTS>masontidy</COMMENTS>)

my %<CODE>process_command_line_cache</CODE>;

sub <CODE>process_command_line</CODE> {

    my (
        $<CODE>perltidyrc_stream</CODE>,  $<CODE>is_Windows</CODE>, $<CODE>Windows_type</CODE>,
        $<CODE>rpending_complaint</CODE>, $<CODE>dump_options_type</CODE>
    ) = @<CODE>_</CODE>;

    my $<CODE>use_cache</CODE> = !defined($<CODE>perltidyrc_stream</CODE>) && !$<CODE>dump_options_type</CODE>;
    if ($<CODE>use_cache</CODE>) {
        my $<CODE>cache_key</CODE> = join( chr(28), @<CODE>ARGV</CODE> );
        if ( my $<CODE>result</CODE> = $<CODE>process_command_line_cache</CODE>{$<CODE>cache_key</CODE>} ) {
            my ( $<CODE>argv</CODE>, @<CODE>retvals</CODE> ) = @$<CODE>result</CODE>;
            @<CODE>ARGV</CODE> = @$<CODE>argv</CODE>;
            return @<CODE>retvals</CODE>;
        }
        else {
            my @<CODE>retvals</CODE> = <CODE>_process_command_line</CODE>(@<CODE>_</CODE>);
            $<CODE>process_command_line_cache</CODE>{$<CODE>cache_key</CODE>} = [ \@<CODE>ARGV</CODE>, @<CODE>retvals</CODE> ]
              if $<CODE>retvals</CODE>[0]->{'<LITERALS>memoize</LITERALS>'};
            return @<CODE>retvals</CODE>;
        }
    }
    else {
        return <CODE>_process_command_line</CODE>(@<CODE>_</CODE>);
    }
}

# (<COMMENTS>note</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>underscore</COMMENTS> <COMMENTS>here</COMMENTS>)
sub <CODE>_process_command_line</CODE> {

    my (
        $<CODE>perltidyrc_stream</CODE>,  $<CODE>is_Windows</CODE>, $<CODE>Windows_type</CODE>,
        $<CODE>rpending_complaint</CODE>, $<CODE>dump_options_type</CODE>
    ) = @<CODE>_</CODE>;

    use <CODE>Getopt</CODE>::<CODE>Long</CODE>;

    my (
        $<CODE>roption_string</CODE>,   $<CODE>rdefaults</CODE>, $<CODE>rexpansion</CODE>,
        $<CODE>roption_category</CODE>, $<CODE>roption_range</CODE>
    ) = <CODE>generate_options</CODE>();

    #---------------------------------------------------------------
    # <COMMENTS>set</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>defaults</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>passing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>GetOptions</COMMENTS>
    #---------------------------------------------------------------
    my %<CODE>Opts</CODE> = ();
    {
        local @<CODE>ARGV</CODE>;
        my $<CODE>i</CODE>;

        # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>load</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>defaults</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>dumping</COMMENTS> <COMMENTS>perltidyrc</COMMENTS>
        unless ( $<CODE>dump_options_type</CODE> eq '<LITERALS>perltidyrc</LITERALS>' ) {
            for $<CODE>i</CODE> (@$<CODE>rdefaults</CODE>) { push @<CODE>ARGV</CODE>, "--" . $<CODE>i</CODE> }
        }

        # <COMMENTS>Patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>save</COMMENTS> <COMMENTS>users</COMMENTS> <COMMENTS>Getopt</COMMENTS>::<COMMENTS>Long</COMMENTS> <COMMENTS>configuration</COMMENTS>
        # <COMMENTS>and</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>Getopt</COMMENTS>::<COMMENTS>Long</COMMENTS> <COMMENTS>defaults</COMMENTS>.  <COMMENTS>Use</COMMENTS> <COMMENTS>eval</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS>
        # <COMMENTS>breaking</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>versions</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>Perl</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>routines</COMMENTS>.
        my $<CODE>glc</CODE>;
        eval { $<CODE>glc</CODE> = <CODE>Getopt</CODE>::<CODE>Long</CODE>::<CODE>Configure</CODE>() };
        unless ($@) {
            eval { <CODE>Getopt</CODE>::<CODE>Long</CODE>::<CODE>ConfigDefaults</CODE>() };
        }
        else { $<CODE>glc</CODE> = undef }

        if ( !<CODE>GetOptions</CODE>( \%<CODE>Opts</CODE>, @$<CODE>roption_string</CODE> ) ) {
            <CODE>Die</CODE> "<LITERALS>Programming</LITERALS> <LITERALS>Bug</LITERALS>: <LITERALS>error</LITERALS> <LITERALS>in</LITERALS> <LITERALS>setting</LITERALS> <LITERALS>default</LITERALS> <LITERALS>options</LITERALS>";
        }

        # <COMMENTS>Patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>Getopt</COMMENTS>::<COMMENTS>Long</COMMENTS> <COMMENTS>configuration</COMMENTS> <COMMENTS>back</COMMENTS>
        eval { <CODE>Getopt</CODE>::<CODE>Long</CODE>::<CODE>Configure</CODE>($<CODE>glc</CODE>) } if defined $<CODE>glc</CODE>;
    }

    my $<CODE>word</CODE>;
    my @<CODE>raw_options</CODE>        = ();
    my $<CODE>config_file</CODE>        = "";
    my $<CODE>saw_ignore_profile</CODE> = 0;
    my $<CODE>saw_dump_profile</CODE>   = 0;
    my $<CODE>i</CODE>;

    #---------------------------------------------------------------
    # <COMMENTS>Take</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>command</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>parameters</COMMENTS>.  <COMMENTS>Do</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>many</COMMENTS>
    # <COMMENTS>immediate</COMMENTS> <COMMENTS>dumps</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>possible</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>confusion</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>perltidyrc</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS>.
    #---------------------------------------------------------------
    foreach $<CODE>i</CODE> (@<CODE>ARGV</CODE>) {

        $<CODE>i</CODE> =~ s/^--/-/;
        if ( $<CODE>i</CODE> =~ /^-(npro|noprofile|no-profile)$/ ) {
            $<CODE>saw_ignore_profile</CODE> = 1;
        }

        # <COMMENTS>note</COMMENTS>: <COMMENTS>this</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>come</COMMENTS> <COMMENTS>before</COMMENTS> -<COMMENTS>pro</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>profile</COMMENTS>, <COMMENTS>below</COMMENTS>:
        elsif ( $<CODE>i</CODE> =~ /^-(dump-profile|dpro)$/ ) {
            $<CODE>saw_dump_profile</CODE> = 1;
        }
        elsif ( $<CODE>i</CODE> =~ /^-(pro|profile)=(.+)/ ) {
            if ($<CODE>config_file</CODE>) {
                <CODE>Warn</CODE>
"<LITERALS>Only</LITERALS> <LITERALS>one</LITERALS> -<LITERALS>pro</LITERALS>=<LITERALS>filename</LITERALS> <LITERALS>allowed</LITERALS>, <LITERALS>using</LITERALS> '$<CODE>2</CODE>' <LITERALS>instead</LITERALS> <LITERALS>of</LITERALS> '$<CODE>config_file</CODE>'\n";
            }
            $<CODE>config_file</CODE> = $<CODE>2</CODE>;

            # <COMMENTS>resolve</COMMENTS> <<COMMENTS>dir</COMMENTS>>/.../<<COMMENTS>file</COMMENTS>>, <COMMENTS>meaning</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>upwards</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>directory</COMMENTS>
            if ( defined($<CODE>config_file</CODE>) ) {
                if ( my ( $<CODE>start_dir</CODE>, $<CODE>search_file</CODE> ) =
                    ( $<CODE>config_file</CODE> =~ m{^(.*)\.\.\./(.*)$} ) )
                {
                    $<CODE>start_dir</CODE> = '.' if !$<CODE>start_dir</CODE>;
                    $<CODE>start_dir</CODE> = <CODE>Cwd</CODE>::<CODE>realpath</CODE>($<CODE>start_dir</CODE>);
                    if ( my $<CODE>found_file</CODE> =
                        <CODE>find_file_upwards</CODE>( $<CODE>start_dir</CODE>, $<CODE>search_file</CODE> ) )
                    {
                        $<CODE>config_file</CODE> = $<CODE>found_file</CODE>;
                    }
                }
            }
            unless ( -e $<CODE>config_file</CODE> ) {
                <CODE>Warn</CODE> "<LITERALS>cannot</LITERALS> <LITERALS>find</LITERALS> <LITERALS>file</LITERALS> <LITERALS>given</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>pro</LITERALS>=$<CODE>config_file</CODE>: $!\n";
                $<CODE>config_file</CODE> = "";
            }
        }
        elsif ( $<CODE>i</CODE> =~ /^-(pro|profile)=?$/ ) {
            <CODE>Die</CODE> "<LITERALS>usage</LITERALS>: -<LITERALS>pro</LITERALS>=<LITERALS>filename</LITERALS> <LITERALS>or</LITERALS> --<LITERALS>profile</LITERALS>=<LITERALS>filename</LITERALS>, <LITERALS>no</LITERALS> <LITERALS>spaces</LITERALS>\n";
        }
        elsif ( $<CODE>i</CODE> =~ /^-(help|h|HELP|H|\?)$/ ) {
            <CODE>usage</CODE>();
            <CODE>Exit</CODE> 0;
        }
        elsif ( $<CODE>i</CODE> =~ /^-(version|v)$/ ) {
            <CODE>show_version</CODE>();
            <CODE>Exit</CODE> 0;
        }
        elsif ( $<CODE>i</CODE> =~ /^-(dump-defaults|ddf)$/ ) {
            <CODE>dump_defaults</CODE>(@$<CODE>rdefaults</CODE>);
            <CODE>Exit</CODE> 0;
        }
        elsif ( $<CODE>i</CODE> =~ /^-(dump-long-names|dln)$/ ) {
            <CODE>dump_long_names</CODE>(@$<CODE>roption_string</CODE>);
            <CODE>Exit</CODE> 0;
        }
        elsif ( $<CODE>i</CODE> =~ /^-(dump-short-names|dsn)$/ ) {
            <CODE>dump_short_names</CODE>($<CODE>rexpansion</CODE>);
            <CODE>Exit</CODE> 0;
        }
        elsif ( $<CODE>i</CODE> =~ /^-(dump-token-types|dtt)$/ ) {
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Tokenizer</CODE>-><CODE>dump_token_types</CODE>(*<CODE>STDOUT</CODE>);
            <CODE>Exit</CODE> 0;
        }
    }

    if ( $<CODE>saw_dump_profile</CODE> && $<CODE>saw_ignore_profile</CODE> ) {
        <CODE>Warn</CODE> "<LITERALS>No</LITERALS> <LITERALS>profile</LITERALS> <LITERALS>to</LITERALS> <LITERALS>dump</LITERALS> <LITERALS>because</LITERALS> <LITERALS>of</LITERALS> -<LITERALS>npro</LITERALS>\n";
        <CODE>Exit</CODE> 1;
    }

    #---------------------------------------------------------------
    # <COMMENTS>read</COMMENTS> <COMMENTS>any</COMMENTS> .<COMMENTS>perltidyrc</COMMENTS> <COMMENTS>configuration</COMMENTS> <COMMENTS>file</COMMENTS>
    #---------------------------------------------------------------
    unless ($<CODE>saw_ignore_profile</CODE>) {

        # <COMMENTS>resolve</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>conflict</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>$perltidyrc_stream</COMMENTS> <COMMENTS>passed</COMMENTS>
        # <COMMENTS>as</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>parameter</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>pro</COMMENTS>=<COMMENTS>filename</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>command</COMMENTS>
        # <COMMENTS>line</COMMENTS>.
        if ($<CODE>perltidyrc_stream</CODE>) {
            if ($<CODE>config_file</CODE>) {
                <CODE>Warn</CODE> <<<LITERALS>EOM</LITERALS>;
 <LITERALS>Conflict</LITERALS>: <LITERALS>a</LITERALS> <LITERALS>perltidyrc</LITERALS> <LITERALS>configuration</LITERALS> <LITERALS>file</LITERALS> <LITERALS>was</LITERALS> <LITERALS>specified</LITERALS> <LITERALS>both</LITERALS> <LITERALS>as</LITERALS> <LITERALS>this</LITERALS>
 <LITERALS>perltidy</LITERALS> <LITERALS>call</LITERALS> <LITERALS>parameter</LITERALS>: $<CODE>perltidyrc_stream</CODE>
 <LITERALS>and</LITERALS> <LITERALS>with</LITERALS> <LITERALS>this</LITERALS> -<LITERALS>profile</LITERALS>=$<CODE>config_file</CODE>.
 <LITERALS>Using</LITERALS> -<LITERALS>profile</LITERALS>=$<CODE>config_file</CODE>.
<CODE>EOM</CODE>
            }
            else {
                $<CODE>config_file</CODE> = $<CODE>perltidyrc_stream</CODE>;
            }
        }

        # <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>config</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>yet</COMMENTS>
        my $<CODE>rconfig_file_chatter</CODE>;
        $$<CODE>rconfig_file_chatter</CODE> = "";
        $<CODE>config_file</CODE> =
          <CODE>find_config_file</CODE>( $<CODE>is_Windows</CODE>, $<CODE>Windows_type</CODE>, $<CODE>rconfig_file_chatter</CODE>,
            $<CODE>rpending_complaint</CODE> )
          unless $<CODE>config_file</CODE>;

        # <COMMENTS>open</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>config</COMMENTS> <COMMENTS>file</COMMENTS>
        my $<CODE>fh_config</CODE>;
        if ($<CODE>config_file</CODE>) {
            ( $<CODE>fh_config</CODE>, $<CODE>config_file</CODE> ) =
              <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>streamhandle</CODE>( $<CODE>config_file</CODE>, '<LITERALS>r</LITERALS>' );
            unless ($<CODE>fh_config</CODE>) {
                $$<CODE>rconfig_file_chatter</CODE> .=
                  "# $<CODE>config_file</CODE> <LITERALS>exists</LITERALS> <LITERALS>but</LITERALS> <LITERALS>cannot</LITERALS> <LITERALS>be</LITERALS> <LITERALS>opened</LITERALS>\n";
            }
        }

        if ($<CODE>saw_dump_profile</CODE>) {
            <CODE>dump_config_file</CODE>( $<CODE>fh_config</CODE>, $<CODE>config_file</CODE>, $<CODE>rconfig_file_chatter</CODE> );
            <CODE>Exit</CODE> 0;
        }

        if ($<CODE>fh_config</CODE>) {

            my ( $<CODE>rconfig_list</CODE>, $<CODE>death_message</CODE> ) =
              <CODE>read_config_file</CODE>( $<CODE>fh_config</CODE>, $<CODE>config_file</CODE>, $<CODE>rexpansion</CODE> );
            <CODE>Die</CODE> $<CODE>death_message</CODE> if ($<CODE>death_message</CODE>);

            # <COMMENTS>process</COMMENTS> <COMMENTS>any</COMMENTS> .<COMMENTS>perltidyrc</COMMENTS> <COMMENTS>parameters</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>now</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS>
            # <COMMENTS>localize</COMMENTS> <COMMENTS>errors</COMMENTS>
            if (@$<CODE>rconfig_list</CODE>) {
                local @<CODE>ARGV</CODE> = @$<CODE>rconfig_list</CODE>;

                <CODE>expand_command_abbreviations</CODE>( $<CODE>rexpansion</CODE>, \@<CODE>raw_options</CODE>,
                    $<CODE>config_file</CODE> );

                if ( !<CODE>GetOptions</CODE>( \%<CODE>Opts</CODE>, @$<CODE>roption_string</CODE> ) ) {
                    <CODE>Die</CODE>
"<LITERALS>Error</LITERALS> <LITERALS>in</LITERALS> <LITERALS>this</LITERALS> <LITERALS>config</LITERALS> <LITERALS>file</LITERALS>: $<CODE>config_file</CODE>  \n<LITERALS>Use</LITERALS> -<LITERALS>npro</LITERALS> <LITERALS>to</LITERALS> <LITERALS>ignore</LITERALS> <LITERALS>this</LITERALS> <LITERALS>file</LITERALS>, -<LITERALS>h</LITERALS> <LITERALS>for</LITERALS> <LITERALS>help</LITERALS>'\n";
                }

                # <COMMENTS>Anything</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>local</COMMENTS> @<COMMENTS>ARGV</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS>
                # <COMMENTS>invalid</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>words</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>configuration</COMMENTS> <COMMENTS>file</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>cannot</COMMENTS>
                # <COMMENTS>check</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>earlier</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>words</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>valid</COMMENTS>
                # <COMMENTS>values</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>parameters</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>had</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>wait</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>GetOptions</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>have</COMMENTS>
                # <COMMENTS>a</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> @<COMMENTS>ARGV</COMMENTS>.
                if (@<CODE>ARGV</CODE>) {
                    my $<CODE>count</CODE> = @<CODE>ARGV</CODE>;
                    my $<CODE>str</CODE>   = "\'" . pop(@<CODE>ARGV</CODE>) . "\'";
                    while ( my $<CODE>param</CODE> = pop(@<CODE>ARGV</CODE>) ) {
                        if ( length($<CODE>str</CODE>) < 70 ) {
                            $<CODE>str</CODE> .= ", '$<CODE>param</CODE>'";
                        }
                        else {
                            $<CODE>str</CODE> .= ", ...";
                            last;
                        }
                    }
                    <CODE>Die</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>There</LITERALS> <LITERALS>are</LITERALS> $<CODE>count</CODE> <LITERALS>unrecognized</LITERALS> <LITERALS>values</LITERALS> <LITERALS>in</LITERALS> <LITERALS>the</LITERALS> <LITERALS>configuration</LITERALS> <LITERALS>file</LITERALS> '$<CODE>config_file</CODE>':
$<CODE>str</CODE>
<LITERALS>Use</LITERALS> <LITERALS>leading</LITERALS> <LITERALS>dashes</LITERALS> <LITERALS>for</LITERALS> <LITERALS>parameters</LITERALS>.  <LITERALS>Use</LITERALS> -<LITERALS>npro</LITERALS> <LITERALS>to</LITERALS> <LITERALS>ignore</LITERALS> <LITERALS>this</LITERALS> <LITERALS>file</LITERALS>.
<CODE>EOM</CODE>
                }

                # <COMMENTS>Undo</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>premature</COMMENTS> <COMMENTS>exit</COMMENTS>.  <COMMENTS>They</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS>
                # <COMMENTS>appropriate</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>config</COMMENTS> <COMMENTS>file</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>hard</COMMENTS> <COMMENTS>to</COMMENTS>
                # <COMMENTS>diagnose</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>premature</COMMENTS> <COMMENTS>exit</COMMENTS>.
                foreach (
                    qw{
                    <LITERALS>dump</LITERALS>-<LITERALS>defaults</LITERALS>
                    <LITERALS>dump</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>names</LITERALS>
                    <LITERALS>dump</LITERALS>-<LITERALS>options</LITERALS>
                    <LITERALS>dump</LITERALS>-<LITERALS>profile</LITERALS>
                    <LITERALS>dump</LITERALS>-<LITERALS>short</LITERALS>-<LITERALS>names</LITERALS>
                    <LITERALS>dump</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>types</LITERALS>
                    <LITERALS>dump</LITERALS>-<LITERALS>want</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>space</LITERALS>
                    <LITERALS>dump</LITERALS>-<LITERALS>want</LITERALS>-<LITERALS>right</LITERALS>-<LITERALS>space</LITERALS>
                    <LITERALS>help</LITERALS>
                    <LITERALS>stylesheet</LITERALS>
                    <LITERALS>version</LITERALS>
                    }
                  )
                {

                    if ( defined( $<CODE>Opts</CODE>{$<CODE>_</CODE>} ) ) {
                        delete $<CODE>Opts</CODE>{$<CODE>_</CODE>};
                        <CODE>Warn</CODE> "<LITERALS>ignoring</LITERALS> --$<CODE>_</CODE> <LITERALS>in</LITERALS> <LITERALS>config</LITERALS> <LITERALS>file</LITERALS>: $<CODE>config_file</CODE>\n";
                    }
                }
            }
        }
    }

    #---------------------------------------------------------------
    # <COMMENTS>now</COMMENTS> <COMMENTS>process</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>command</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>parameters</COMMENTS>
    #---------------------------------------------------------------
    <CODE>expand_command_abbreviations</CODE>( $<CODE>rexpansion</CODE>, \@<CODE>raw_options</CODE>, $<CODE>config_file</CODE> );

    local $<CODE>SIG</CODE>{'<LITERALS>__WARN__</LITERALS>'} = sub { <CODE>Warn</CODE> $<CODE>_</CODE>[0] };
    if ( !<CODE>GetOptions</CODE>( \%<CODE>Opts</CODE>, @$<CODE>roption_string</CODE> ) ) {
        <CODE>Die</CODE> "<LITERALS>Error</LITERALS> <LITERALS>on</LITERALS> <LITERALS>command</LITERALS> <LITERALS>line</LITERALS>; <LITERALS>for</LITERALS> <LITERALS>help</LITERALS> <LITERALS>try</LITERALS> '<LITERALS>perltidy</LITERALS> -<LITERALS>h</LITERALS>'\n";
    }

    return ( \%<CODE>Opts</CODE>, $<CODE>config_file</CODE>, \@<CODE>raw_options</CODE>, $<CODE>roption_string</CODE>,
        $<CODE>rexpansion</CODE>, $<CODE>roption_category</CODE>, $<CODE>roption_range</CODE> );
}    # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>_process_command_line</COMMENTS>

sub <CODE>check_options</CODE> {

    my ( $<CODE>rOpts</CODE>, $<CODE>is_Windows</CODE>, $<CODE>Windows_type</CODE>, $<CODE>rpending_complaint</CODE> ) = @<CODE>_</CODE>;

    #---------------------------------------------------------------
    # <COMMENTS>check</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>interactions</COMMENTS> <COMMENTS>among</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>basic</COMMENTS> <COMMENTS>options</COMMENTS>..
    #---------------------------------------------------------------

    # <COMMENTS>Since</COMMENTS> -<COMMENTS>vt</COMMENTS>, -<COMMENTS>vtc</COMMENTS>, <COMMENTS>and</COMMENTS> -<COMMENTS>cti</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>abbreviations</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>under</COMMENTS>
    # <COMMENTS>msdos</COMMENTS>, <COMMENTS>an</COMMENTS> <COMMENTS>unquoted</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>parameter</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>vtc</COMMENTS>=<COMMENTS>1</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>seen</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>parameters</COMMENTS>, <COMMENTS>vtc</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>1</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>abbreviations</COMMENTS>
    # <COMMENTS>won</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>seen</COMMENTS>.  <COMMENTS>Therefore</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>catch</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>if</COMMENTS>
    # <COMMENTS>they</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>through</COMMENTS>.

    if ( defined $<CODE>rOpts</CODE>->{'<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'} ) {
        my $<CODE>vt</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'};
        $<CODE>rOpts</CODE>->{'<LITERALS>paren</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'}          = $<CODE>vt</CODE>;
        $<CODE>rOpts</CODE>->{'<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'} = $<CODE>vt</CODE>;
        $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'}          = $<CODE>vt</CODE>;
    }

    if ( defined $<CODE>rOpts</CODE>->{'<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'} ) {
        my $<CODE>vtc</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'};
        $<CODE>rOpts</CODE>->{'<LITERALS>paren</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'}          = $<CODE>vtc</CODE>;
        $<CODE>rOpts</CODE>->{'<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'} = $<CODE>vtc</CODE>;
        $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'}          = $<CODE>vtc</CODE>;
    }

    if ( defined $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>indentation</LITERALS>'} ) {
        my $<CODE>cti</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>indentation</LITERALS>'};
        $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>indentation</LITERALS>'} = $<CODE>cti</CODE>;
        $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>indentation</LITERALS>'}          = $<CODE>cti</CODE>;
        $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>paren</LITERALS>-<LITERALS>indentation</LITERALS>'}          = $<CODE>cti</CODE>;
    }

    # <COMMENTS>In</COMMENTS> <COMMENTS>quiet</COMMENTS> <COMMENTS>mode</COMMENTS>, <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>log</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>hence</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>way</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>report</COMMENTS>
    # <COMMENTS>results</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>check</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>it</COMMENTS>.
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>quiet</LITERALS>'} ) {
        $<CODE>rOpts</CODE>->{'<LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>'} = 0;
    }

    # <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>output</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'} ne '<LITERALS>tidy</LITERALS>' ) {
        $<CODE>rOpts</CODE>->{'<LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>'} = 0;
    }

    # <COMMENTS>Never</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>Windows</COMMENTS> <COMMENTS>9x</COMMENTS>/<COMMENTS>Me</COMMENTS> <COMMENTS>systems</COMMENTS> <COMMENTS>run</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>check</COMMENTS> -- <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>a</COMMENTS>
    # <COMMENTS>wide</COMMENTS> <COMMENTS>variety</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>nasty</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>systems</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>cannot</COMMENTS>
    # <COMMENTS>reliably</COMMENTS> <COMMENTS>run</COMMENTS> <COMMENTS>backticks</COMMENTS>.  <COMMENTS>Don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>think</COMMENTS> <COMMENTS>about</COMMENTS> <COMMENTS>changing</COMMENTS> <COMMENTS>this</COMMENTS>!
    if (   $<CODE>rOpts</CODE>->{'<LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>'}
        && $<CODE>is_Windows</CODE>
        && ( !$<CODE>Windows_type</CODE> || $<CODE>Windows_type</CODE> =~ /^(9|Me)/ ) )
    {
        $<CODE>rOpts</CODE>->{'<LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>'} = 0;
    }

    # <COMMENTS>It</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>idea</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>root</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>wrote</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>script</COMMENTS> <COMMENTS>yourself</COMMENTS>.  <COMMENTS>FIXME</COMMENTS>: <COMMENTS>not</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>works</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>VMS</COMMENTS>
    unless ($<CODE>is_Windows</CODE>) {

        if ( $< == 0 && $<CODE>rOpts</CODE>->{'<LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>'} ) {
            $<CODE>rOpts</CODE>->{'<LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>'} = 0;
            $$<CODE>rpending_complaint</CODE> .=
"<LITERALS>Syntax</LITERALS> <LITERALS>check</LITERALS> <LITERALS>deactivated</LITERALS> <LITERALS>for</LITERALS> <LITERALS>safety</LITERALS>; <LITERALS>you</LITERALS> <LITERALS>shouldn</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>run</LITERALS> <LITERALS>this</LITERALS> <LITERALS>as</LITERALS> <LITERALS>root</LITERALS>\n";
        }
    }

    # <COMMENTS>check</COMMENTS> <COMMENTS>iteration</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>quietly</COMMENTS> <COMMENTS>fix</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>:
    # - <COMMENTS>iterations</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>applies</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>beautification</COMMENTS> <COMMENTS>mode</COMMENTS>
    # - <COMMENTS>the</COMMENTS> <COMMENTS>convergence</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>stop</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>runs</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>iteration</COMMENTS> <COMMENTS>2</COMMENTS>, <COMMENTS>and</COMMENTS>
    #   <COMMENTS>virtually</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>iteration</COMMENTS> <COMMENTS>3</COMMENTS>.  <COMMENTS>But</COMMENTS> <COMMENTS>we</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>6</COMMENTS>.
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'} ne '<LITERALS>tidy</LITERALS>' ) {
        $<CODE>rOpts</CODE>->{'<LITERALS>iterations</LITERALS>'} = 1;
    }
    elsif ( defined( $<CODE>rOpts</CODE>->{'<LITERALS>iterations</LITERALS>'} ) ) {
        if    ( $<CODE>rOpts</CODE>->{'<LITERALS>iterations</LITERALS>'} <= 0 ) { $<CODE>rOpts</CODE>->{'<LITERALS>iterations</LITERALS>'} = 1 }
        elsif ( $<CODE>rOpts</CODE>->{'<LITERALS>iterations</LITERALS>'} > 6 )  { $<CODE>rOpts</CODE>->{'<LITERALS>iterations</LITERALS>'} = 6 }
    }
    else {
        $<CODE>rOpts</CODE>->{'<LITERALS>iterations</LITERALS>'} = 1;
    }

    # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>reasonable</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>fix</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>problems</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>'} ) {
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>'} < 0 ) {
            $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>'} = 0;
            <CODE>Warn</CODE> "<LITERALS>negative</LITERALS> <LITERALS>value</LITERALS> <LITERALS>of</LITERALS> -<LITERALS>blbs</LITERALS>, <LITERALS>setting</LITERALS> <LITERALS>0</LITERALS>\n";
        }
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>'} > 100 ) {
            <CODE>Warn</CODE> "<LITERALS>unreasonably</LITERALS> <LITERALS>large</LITERALS> <LITERALS>value</LITERALS> <LITERALS>of</LITERALS> -<LITERALS>blbs</LITERALS>, <LITERALS>reducing</LITERALS>\n";
            $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>'} = 100;
        }
    }
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>packages</LITERALS>'} ) {
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>packages</LITERALS>'} < 0 ) {
            <CODE>Warn</CODE> "<LITERALS>negative</LITERALS> <LITERALS>value</LITERALS> <LITERALS>of</LITERALS> -<LITERALS>blbp</LITERALS>, <LITERALS>setting</LITERALS> <LITERALS>0</LITERALS>\n";
            $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>packages</LITERALS>'} = 0;
        }
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>packages</LITERALS>'} > 100 ) {
            <CODE>Warn</CODE> "<LITERALS>unreasonably</LITERALS> <LITERALS>large</LITERALS> <LITERALS>value</LITERALS> <LITERALS>of</LITERALS> -<LITERALS>blbp</LITERALS>, <LITERALS>reducing</LITERALS>\n";
            $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>packages</LITERALS>'} = 100;
        }
    }

    # <COMMENTS>setting</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>negative</COMMENTS> <COMMENTS>logfile</COMMENTS> <COMMENTS>gap</COMMENTS> <COMMENTS>causes</COMMENTS> <COMMENTS>logfile</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>saved</COMMENTS>
    if ( defined( $<CODE>rOpts</CODE>->{'<LITERALS>logfile</LITERALS>-<LITERALS>gap</LITERALS>'} ) && $<CODE>rOpts</CODE>->{'<LITERALS>logfile</LITERALS>-<LITERALS>gap</LITERALS>'} >= 0 ) {
        $<CODE>rOpts</CODE>->{'<LITERALS>logfile</LITERALS>'} = 1;
    }

    # <COMMENTS>set</COMMENTS> <COMMENTS>short</COMMENTS>-<COMMENTS>cut</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>done</COMMENTS>.
    # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>indent</COMMENTS>-<COMMENTS>only</COMMENTS> <COMMENTS>flag</COMMENTS>.
    if (   !$<CODE>rOpts</CODE>->{'<LITERALS>add</LITERALS>-<LITERALS>whitespace</LITERALS>'}
        && !$<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>whitespace</LITERALS>'}
        && !$<CODE>rOpts</CODE>->{'<LITERALS>add</LITERALS>-<LITERALS>newlines</LITERALS>'}
        && !$<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>newlines</LITERALS>'} )
    {
        $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>only</LITERALS>'} = 1;
    }

    # -<COMMENTS>isbc</COMMENTS> <COMMENTS>implies</COMMENTS> -<COMMENTS>ibc</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>spaced</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>'} ) {
        $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>'} = 1;
    }

    # -<COMMENTS>bli</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>implies</COMMENTS> -<COMMENTS>bl</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>and</LITERALS>-<LITERALS>indent</LITERALS>'} ) {
        $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>'} = 1;
    }

    if (   $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>always</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>right</LITERALS>'}
        && $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>'} )
    {
        <CODE>Warn</CODE> <<<LITERALS>EOM</LITERALS>;
 <LITERALS>Conflict</LITERALS>: <LITERALS>you</LITERALS> <LITERALS>specified</LITERALS> <LITERALS>both</LITERALS> '<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>always</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>right</LITERALS>' (-<LITERALS>bar</LITERALS>) <LITERALS>and</LITERALS>
  '<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>' (-<LITERALS>bl</LITERALS>).  <LITERALS>Ignoring</LITERALS> -<LITERALS>bl</LITERALS>.
<CODE>EOM</CODE>
        $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>'} = 0;
    }

    # <COMMENTS>it</COMMENTS> <COMMENTS>simplifies</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>if</COMMENTS> -<COMMENTS>bl</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>0</COMMENTS> <COMMENTS>rather</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>undefined</COMMENTS>
    if ( !defined( $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>'} ) ) {
        $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>'} = 0;
    }

    # -<COMMENTS>sbl</COMMENTS> <COMMENTS>defaults</COMMENTS> <COMMENTS>to</COMMENTS> -<COMMENTS>bl</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>defined</COMMENTS>
    if ( !defined( $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>sub</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>'} ) ) {
        $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>sub</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>'} =
          $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>'};
    }

    if ( $<CODE>rOpts</CODE>->{'<LITERALS>entab</LITERALS>-<LITERALS>leading</LITERALS>-<LITERALS>whitespace</LITERALS>'} ) {
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>entab</LITERALS>-<LITERALS>leading</LITERALS>-<LITERALS>whitespace</LITERALS>'} < 0 ) {
            <CODE>Warn</CODE> "-<LITERALS>et</LITERALS>=<LITERALS>n</LITERALS> <LITERALS>must</LITERALS> <LITERALS>use</LITERALS> <LITERALS>a</LITERALS> <LITERALS>positive</LITERALS> <LITERALS>integer</LITERALS>; <LITERALS>ignoring</LITERALS> -<LITERALS>et</LITERALS>\n";
            $<CODE>rOpts</CODE>->{'<LITERALS>entab</LITERALS>-<LITERALS>leading</LITERALS>-<LITERALS>whitespace</LITERALS>'} = undef;
        }

        # <COMMENTS>entab</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>priority</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>older</COMMENTS> '<COMMENTS>tabs</COMMENTS>' <COMMENTS>option</COMMENTS>
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>tabs</LITERALS>'} ) { $<CODE>rOpts</CODE>->{'<LITERALS>tabs</LITERALS>'} = 0; }
    }

    # <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>tabsize</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>guessing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>indentation</COMMENTS>
    # <COMMENTS>level</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>run</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>tabs</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>does</COMMENTS>
    # <COMMENTS>use</COMMENTS> <COMMENTS>tabs</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>default</LITERALS>-<LITERALS>tabsize</LITERALS>'} ) {
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>default</LITERALS>-<LITERALS>tabsize</LITERALS>'} < 0 ) {
            <CODE>Warn</CODE> "<LITERALS>negative</LITERALS> <LITERALS>value</LITERALS> <LITERALS>of</LITERALS> -<LITERALS>dt</LITERALS>, <LITERALS>setting</LITERALS> <LITERALS>0</LITERALS>\n";
            $<CODE>rOpts</CODE>->{'<LITERALS>default</LITERALS>-<LITERALS>tabsize</LITERALS>'} = 0;
        }
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>default</LITERALS>-<LITERALS>tabsize</LITERALS>'} > 20 ) {
            <CODE>Warn</CODE> "<LITERALS>unreasonably</LITERALS> <LITERALS>large</LITERALS> <LITERALS>value</LITERALS> <LITERALS>of</LITERALS> -<LITERALS>dt</LITERALS>, <LITERALS>reducing</LITERALS>\n";
            $<CODE>rOpts</CODE>->{'<LITERALS>default</LITERALS>-<LITERALS>tabsize</LITERALS>'} = 20;
        }
    }
    else {
        $<CODE>rOpts</CODE>->{'<LITERALS>default</LITERALS>-<LITERALS>tabsize</LITERALS>'} = 8;
    }

    # <COMMENTS>Define</COMMENTS> <COMMENTS>$tabsize</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>per</COMMENTS> <COMMENTS>tab</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>in</COMMENTS>
    # <COMMENTS>guessing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>tabs</COMMENTS>.
    # <COMMENTS>Assume</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>run</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>tabs</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>used</COMMENTS> , <COMMENTS>otherwise</COMMENTS> <COMMENTS>assume</COMMENTS>
    # <COMMENTS>a</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>value</COMMENTS>, <COMMENTS>typically</COMMENTS> <COMMENTS>8</COMMENTS>
    my $<CODE>tabsize</CODE> =
        $<CODE>rOpts</CODE>->{'<LITERALS>entab</LITERALS>-<LITERALS>leading</LITERALS>-<LITERALS>whitespace</LITERALS>'}
      ? $<CODE>rOpts</CODE>->{'<LITERALS>entab</LITERALS>-<LITERALS>leading</LITERALS>-<LITERALS>whitespace</LITERALS>'}
      : $<CODE>rOpts</CODE>->{'<LITERALS>tabs</LITERALS>'} ? $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>columns</LITERALS>'}
      :                    $<CODE>rOpts</CODE>->{'<LITERALS>default</LITERALS>-<LITERALS>tabsize</LITERALS>'};
    return $<CODE>tabsize</CODE>;
}

sub <CODE>find_file_upwards</CODE> {
    my ( $<CODE>search_dir</CODE>, $<CODE>search_file</CODE> ) = @<CODE>_</CODE>;

    $<CODE>search_dir</CODE> =~ s{/+$}{};
    $<CODE>search_file</CODE> =~ s{^/+}{};

    while (1) {
        my $<CODE>try_path</CODE> = "$<CODE>search_dir</CODE>/$<CODE>search_file</CODE>";
        if ( -f $<CODE>try_path</CODE> ) {
            return $<CODE>try_path</CODE>;
        }
        elsif ( $<CODE>search_dir</CODE> eq '/' ) {
            return undef;
        }
        else {
            $<CODE>search_dir</CODE> = <CODE>dirname</CODE>($<CODE>search_dir</CODE>);
        }
    }
}

sub <CODE>expand_command_abbreviations</CODE> {

    # <COMMENTS>go</COMMENTS> <COMMENTS>through</COMMENTS> @<COMMENTS>ARGV</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>expand</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>abbreviations</COMMENTS>

    my ( $<CODE>rexpansion</CODE>, $<CODE>rraw_options</CODE>, $<CODE>config_file</CODE> ) = @<CODE>_</CODE>;
    my ($<CODE>word</CODE>);

    # <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pass</COMMENTS> <COMMENTS>limit</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>infinite</COMMENTS> <COMMENTS>loop</COMMENTS>;
    # <COMMENTS>10</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>plenty</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>increased</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>deeply</COMMENTS>
    # <COMMENTS>nested</COMMENTS> <COMMENTS>expansions</COMMENTS>.
    my $<CODE>max_passes</CODE> = 10;
    my @<CODE>new_argv</CODE>   = ();

    # <COMMENTS>keep</COMMENTS> <COMMENTS>looping</COMMENTS> <COMMENTS>until</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>expansions</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>converted</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>actual</COMMENTS>
    # <COMMENTS>dash</COMMENTS> <COMMENTS>parameters</COMMENTS>..
    for ( my $<CODE>pass_count</CODE> = 0 ; $<CODE>pass_count</CODE> <= $<CODE>max_passes</CODE> ; $<CODE>pass_count</CODE>++ ) {
        my @<CODE>new_argv</CODE>     = ();
        my $<CODE>abbrev_count</CODE> = 0;

        # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>in</COMMENTS> @<COMMENTS>ARGV</COMMENTS>..
        foreach $<CODE>word</CODE> (@<CODE>ARGV</CODE>) {

            # <COMMENTS>convert</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>leading</COMMENTS> '<COMMENTS>no</COMMENTS>-' <COMMENTS>to</COMMENTS> <COMMENTS>just</COMMENTS> '<COMMENTS>no</COMMENTS>'
            if ( $<CODE>word</CODE> =~ /^(-[-]?no)-(.*)/ ) { $<CODE>word</CODE> = $<CODE>1</CODE> . $<CODE>2</CODE> }

            # <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>dash</COMMENTS> <COMMENTS>flag</COMMENTS> (<COMMENTS>instead</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>name</COMMENTS>)..
            if ( $<CODE>word</CODE> =~ /^-[-]?([\w\-]+)(.*)/ ) {

                my $<CODE>abr</CODE>   = $<CODE>1</CODE>;
                my $<CODE>flags</CODE> = $<CODE>2</CODE>;

                # <COMMENTS>save</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>raw</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>debug</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>circular</COMMENTS> <COMMENTS>refs</COMMENTS>
                if ( $<CODE>pass_count</CODE> == 0 ) {
                    push( @$<CODE>rraw_options</CODE>, $<CODE>word</CODE> );
                }

                # <COMMENTS>recombine</COMMENTS> <COMMENTS>abbreviation</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>flag</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>,
                # <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>abbreviations</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>arguments</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> '-<COMMENTS>vt</COMMENTS>=<COMMENTS>1</COMMENTS>'
                if ( $<CODE>rexpansion</CODE>->{ $<CODE>abr</CODE> . $<CODE>flags</CODE> } ) {
                    $<CODE>abr</CODE>   = $<CODE>abr</CODE> . $<CODE>flags</CODE>;
                    $<CODE>flags</CODE> = "";
                }

                # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>dash</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>expansion</COMMENTS> <COMMENTS>hash</COMMENTS>..
                if ( $<CODE>rexpansion</CODE>->{$<CODE>abr</CODE>} ) {
                    $<CODE>abbrev_count</CODE>++;

                    # <COMMENTS>stuff</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>words</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>expands</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>the</COMMENTS>
                    # <COMMENTS>new</COMMENTS> <COMMENTS>arg</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>pass</COMMENTS>
                    foreach my $<CODE>abbrev</CODE> ( @{ $<CODE>rexpansion</CODE>->{$<CODE>abr</CODE>} } ) {
                        next unless $<CODE>abbrev</CODE>;    # <COMMENTS>for</COMMENTS> <COMMENTS>safety</COMMENTS>; <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>
                        push( @<CODE>new_argv</CODE>, '--' . $<CODE>abbrev</CODE> . $<CODE>flags</CODE> );
                    }
                }

                # <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>expansion</COMMENTS> <COMMENTS>hash</COMMENTS>, <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>name</COMMENTS>
                else {
                    push( @<CODE>new_argv</CODE>, $<CODE>word</CODE> );
                }
            }

            # <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>dash</COMMENTS> <COMMENTS>item</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>save</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>pass</COMMENTS>
            else {
                push( @<CODE>new_argv</CODE>, $<CODE>word</CODE> );
            }
        }    # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>pass</COMMENTS>

        # <COMMENTS>update</COMMENTS> <COMMENTS>parameter</COMMENTS> <COMMENTS>list</COMMENTS> @<COMMENTS>ARGV</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>one</COMMENTS>
        @<CODE>ARGV</CODE> = @<CODE>new_argv</CODE>;
        last unless ( $<CODE>abbrev_count</CODE> > 0 );

        # <COMMENTS>make</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>infinite</COMMENTS> <COMMENTS>loop</COMMENTS>
        if ( $<CODE>pass_count</CODE> == $<CODE>max_passes</CODE> ) {
            local $" = ')(';
            <CODE>Warn</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>I</LITERALS>'<LITERALS>m</LITERALS> <LITERALS>tired</LITERALS>. <LITERALS>We</LITERALS> <LITERALS>seem</LITERALS> <LITERALS>to</LITERALS> <LITERALS>be</LITERALS> <LITERALS>in</LITERALS> <LITERALS>an</LITERALS> <LITERALS>infinite</LITERALS> <LITERALS>loop</LITERALS> <LITERALS>trying</LITERALS> <LITERALS>to</LITERALS> <LITERALS>expand</LITERALS> <LITERALS>aliases</LITERALS>.
<LITERALS>Here</LITERALS> <LITERALS>are</LITERALS> <LITERALS>the</LITERALS> <LITERALS>raw</LITERALS> <LITERALS>options</LITERALS>;
(<LITERALS>rraw_options</LITERALS>)
<CODE>EOM</CODE>
            my $<CODE>num</CODE> = @<CODE>new_argv</CODE>;
            if ( $<CODE>num</CODE> < 50 ) {
                <CODE>Warn</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>After</LITERALS> $<CODE>max_passes</CODE> <LITERALS>passes</LITERALS> <LITERALS>here</LITERALS> <LITERALS>is</LITERALS> <LITERALS>ARGV</LITERALS>
(@<CODE>new_argv</CODE>)
<CODE>EOM</CODE>
            }
            else {
                <CODE>Warn</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>After</LITERALS> $<CODE>max_passes</CODE> <LITERALS>passes</LITERALS> <LITERALS>ARGV</LITERALS> <LITERALS>has</LITERALS> $<CODE>num</CODE> <LITERALS>entries</LITERALS>
<CODE>EOM</CODE>
            }

            if ($<CODE>config_file</CODE>) {
                <CODE>Die</CODE> <<"<LITERALS>DIE</LITERALS>";
<LITERALS>Please</LITERALS> <LITERALS>check</LITERALS> <LITERALS>your</LITERALS> <LITERALS>configuration</LITERALS> <LITERALS>file</LITERALS> $<CODE>config_file</CODE> <LITERALS>for</LITERALS> <LITERALS>circular</LITERALS>-<LITERALS>references</LITERALS>.
<LITERALS>To</LITERALS> <LITERALS>deactivate</LITERALS> <LITERALS>it</LITERALS>, <LITERALS>use</LITERALS> -<LITERALS>npro</LITERALS>.
<CODE>DIE</CODE>
            }
            else {
                <CODE>Die</CODE> <<'<LITERALS>DIE</LITERALS>';
<LITERALS>Program</LITERALS> <LITERALS>bug</LITERALS> - <LITERALS>circular</LITERALS>-<LITERALS>references</LITERALS> <LITERALS>in</LITERALS> <LITERALS>the</LITERALS> %<LITERALS>expansion</LITERALS> <LITERALS>hash</LITERALS>, <LITERALS>probably</LITERALS> <LITERALS>due</LITERALS> <LITERALS>to</LITERALS>
<LITERALS>a</LITERALS> <LITERALS>recent</LITERALS> <LITERALS>program</LITERALS> <LITERALS>change</LITERALS>.
<CODE>DIE</CODE>
            }
        }    # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>circular</COMMENTS> <COMMENTS>references</COMMENTS>
    }    # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>passes</COMMENTS>
}

# <COMMENTS>Debug</COMMENTS> <COMMENTS>routine</COMMENTS> -- <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>dump</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>expansion</COMMENTS> <COMMENTS>hash</COMMENTS>
sub <CODE>dump_short_names</CODE> {
    my $<CODE>rexpansion</CODE> = shift;
    print <CODE>STDOUT</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>List</LITERALS> <LITERALS>of</LITERALS> <LITERALS>short</LITERALS> <LITERALS>names</LITERALS>.  <LITERALS>This</LITERALS> <LITERALS>list</LITERALS> <LITERALS>shows</LITERALS> <LITERALS>how</LITERALS> <LITERALS>all</LITERALS> <LITERALS>abbreviations</LITERALS> <LITERALS>are</LITERALS>
<LITERALS>translated</LITERALS> <LITERALS>into</LITERALS> <LITERALS>other</LITERALS> <LITERALS>abbreviations</LITERALS> <LITERALS>and</LITERALS>, <LITERALS>eventually</LITERALS>, <LITERALS>into</LITERALS> <LITERALS>long</LITERALS> <LITERALS>names</LITERALS>.
<LITERALS>New</LITERALS> <LITERALS>abbreviations</LITERALS> <LITERALS>may</LITERALS> <LITERALS>be</LITERALS> <LITERALS>defined</LITERALS> <LITERALS>in</LITERALS> <LITERALS>a</LITERALS> .<LITERALS>perltidyrc</LITERALS> <LITERALS>file</LITERALS>.
<LITERALS>For</LITERALS> <LITERALS>a</LITERALS> <LITERALS>list</LITERALS> <LITERALS>of</LITERALS> <LITERALS>all</LITERALS> <LITERALS>long</LITERALS> <LITERALS>names</LITERALS>, <LITERALS>use</LITERALS> <LITERALS>perltidy</LITERALS> --<LITERALS>dump</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>names</LITERALS> (-<LITERALS>dln</LITERALS>).
--------------------------------------------------------------------------
<CODE>EOM</CODE>
    foreach my $<CODE>abbrev</CODE> ( sort keys %$<CODE>rexpansion</CODE> ) {
        my @<CODE>list</CODE> = @{ $$<CODE>rexpansion</CODE>{$<CODE>abbrev</CODE>} };
        print <CODE>STDOUT</CODE> "$<CODE>abbrev</CODE> --> @<CODE>list</CODE>\n";
    }
}

sub <CODE>check_vms_filename</CODE> {

    # <COMMENTS>given</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>filename</COMMENTS> (<COMMENTS>the</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS>)
    # <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>modified</COMMENTS> <COMMENTS>filename</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>separator</COMMENTS> <COMMENTS>character</COMMENTS>
    # <COMMENTS>suitable</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>VMS</COMMENTS>.
    #
    # <COMMENTS>Contributed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>Michael</COMMENTS> <COMMENTS>Cartmell</COMMENTS>
    #
    my ( $<CODE>base</CODE>, $<CODE>path</CODE> ) = <CODE>fileparse</CODE>( $<CODE>_</CODE>[0] );

    # <COMMENTS>remove</COMMENTS> <COMMENTS>explicit</COMMENTS> ; <COMMENTS>version</COMMENTS>
    $<CODE>base</CODE> =~ s/;-?\d*$//

      # <COMMENTS>remove</COMMENTS> <COMMENTS>explicit</COMMENTS> . <COMMENTS>version</COMMENTS> <COMMENTS>ie</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>dots</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>filename</COMMENTS> <COMMENTS>NB</COMMENTS> ^ <COMMENTS>escapes</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>dot</COMMENTS>
      or $<CODE>base</CODE> =~ s/(          # <COMMENTS>begin</COMMENTS> <COMMENTS>capture</COMMENTS> <COMMENTS>$1</COMMENTS>
                  (?:^|[^^])\. # <COMMENTS>match</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>dot</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>preceded</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>caret</COMMENTS>
                  (?:          # <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>nothing</COMMENTS>
                    |          # <COMMENTS>or</COMMENTS>
                    .*[^^]     # <COMMENTS>anything</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS> <COMMENTS>caret</COMMENTS>
                  )
                )              # <COMMENTS>end</COMMENTS> <COMMENTS>capture</COMMENTS> <COMMENTS>$1</COMMENTS>
                \.-?\d*$       # <COMMENTS>match</COMMENTS> . <COMMENTS>version</COMMENTS> <COMMENTS>number</COMMENTS>
              /$<CODE>1</CODE>/x;

    # <COMMENTS>normalise</COMMENTS> <COMMENTS>filename</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>unescaped</COMMENTS> <COMMENTS>dots</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>one</COMMENTS>
    $<CODE>base</CODE> .= '.' unless $<CODE>base</CODE> =~ /(?:^|[^^])\./;

    # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>extension</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>extension</COMMENTS>
    my $<CODE>separator</CODE> = ( $<CODE>base</CODE> =~ /\.$/ ) ? "" : "<LITERALS>_</LITERALS>";
    return ( $<CODE>path</CODE> . $<CODE>base</CODE>, $<CODE>separator</CODE> );
}

sub <CODE>Win_OS_Type</CODE> {

    # <COMMENTS>TODO</COMMENTS>: <COMMENTS>are</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>names</COMMENTS>?
    # <COMMENTS>Win32s</COMMENTS> <COMMENTS>Win95</COMMENTS> <COMMENTS>Win98</COMMENTS> <COMMENTS>WinMe</COMMENTS> <COMMENTS>WinNT3</COMMENTS>.<COMMENTS>51</COMMENTS> <COMMENTS>WinNT4</COMMENTS> <COMMENTS>Win2000</COMMENTS> <COMMENTS>WinXP</COMMENTS>/.<COMMENTS>Net</COMMENTS> <COMMENTS>Win2003</COMMENTS>

    # <COMMENTS>Returns</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>determines</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>MS</COMMENTS> <COMMENTS>OS</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>on</COMMENTS>.
    # <COMMENTS>Returns</COMMENTS> <COMMENTS>win32s</COMMENTS>,<COMMENTS>95</COMMENTS>,<COMMENTS>98</COMMENTS>,<COMMENTS>Me</COMMENTS>,<COMMENTS>NT3</COMMENTS>.<COMMENTS>51</COMMENTS>,<COMMENTS>NT4</COMMENTS>,<COMMENTS>2000</COMMENTS>,<COMMENTS>XP</COMMENTS>/.<COMMENTS>Net</COMMENTS>,<COMMENTS>Win2003</COMMENTS>
    # <COMMENTS>Returns</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>MS</COMMENTS> <COMMENTS>system</COMMENTS>.
    # <COMMENTS>Original</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>contributed</COMMENTS> <COMMENTS>by</COMMENTS>: <COMMENTS>Yves</COMMENTS> <COMMENTS>Orton</COMMENTS>
    # <COMMENTS>We</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>config</COMMENTS> <COMMENTS>files</COMMENTS>

    my $<CODE>rpending_complaint</CODE> = shift;
    my $<CODE>os</CODE>                 = "";
    return $<CODE>os</CODE> unless $^<CODE>O</CODE> =~ /win32|dos/i;    # <COMMENTS>is</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>MS</COMMENTS> <COMMENTS>box</COMMENTS>?

    # <COMMENTS>Systems</COMMENTS> <COMMENTS>built</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>Perl</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>Win32</COMMENTS>.<COMMENTS>pm</COMMENTS>
    # <COMMENTS>But</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>Win32</COMMENTS>::<COMMENTS>GetOSVersion</COMMENTS>() <COMMENTS>anyway</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>following</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> '<COMMENTS>required</COMMENTS>':
    # <COMMENTS>return</COMMENTS> <COMMENTS>$os</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>eval</COMMENTS>('<COMMENTS>require</COMMENTS> <COMMENTS>Win32</COMMENTS>');

    # <COMMENTS>Use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>API</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>determine</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>version</COMMENTS>
    my ( $<CODE>undef</CODE>, $<CODE>major</CODE>, $<CODE>minor</CODE>, $<CODE>build</CODE>, $<CODE>id</CODE> );
    eval { ( $<CODE>undef</CODE>, $<CODE>major</CODE>, $<CODE>minor</CODE>, $<CODE>build</CODE>, $<CODE>id</CODE> ) = <CODE>Win32</CODE>::<CODE>GetOSVersion</CODE>() };

    #
    #    <COMMENTS>NAME</COMMENTS>                   <COMMENTS>ID</COMMENTS>   <COMMENTS>MAJOR</COMMENTS>  <COMMENTS>MINOR</COMMENTS>
    #    <COMMENTS>Windows</COMMENTS> <COMMENTS>NT</COMMENTS> <COMMENTS>4</COMMENTS>           <COMMENTS>2</COMMENTS>      <COMMENTS>4</COMMENTS>       <COMMENTS>0</COMMENTS>
    #    <COMMENTS>Windows</COMMENTS> <COMMENTS>2000</COMMENTS>           <COMMENTS>2</COMMENTS>      <COMMENTS>5</COMMENTS>       <COMMENTS>0</COMMENTS>
    #    <COMMENTS>Windows</COMMENTS> <COMMENTS>XP</COMMENTS>             <COMMENTS>2</COMMENTS>      <COMMENTS>5</COMMENTS>       <COMMENTS>1</COMMENTS>
    #    <COMMENTS>Windows</COMMENTS> <COMMENTS>Server</COMMENTS> <COMMENTS>2003</COMMENTS>    <COMMENTS>2</COMMENTS>      <COMMENTS>5</COMMENTS>       <COMMENTS>2</COMMENTS>

    return "<LITERALS>win32s</LITERALS>" unless $<CODE>id</CODE>;    # <COMMENTS>If</COMMENTS> <COMMENTS>id</COMMENTS>==<COMMENTS>0</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>win32s</COMMENTS> <COMMENTS>box</COMMENTS>.
    $<CODE>os</CODE> = {                        # <COMMENTS>Magic</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>MSDN</COMMENTS>
                                   # <COMMENTS>documentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>GetOSVersion</COMMENTS>
        1 => {
            0  => "<LITERALS>95</LITERALS>",
            10 => "<LITERALS>98</LITERALS>",
            90 => "<LITERALS>Me</LITERALS>"
        },
        2 => {
            0  => "<LITERALS>2000</LITERALS>",          # <COMMENTS>or</COMMENTS> <COMMENTS>NT</COMMENTS> <COMMENTS>4</COMMENTS>, <COMMENTS>see</COMMENTS> <COMMENTS>below</COMMENTS>
            1  => "<LITERALS>XP</LITERALS>/.<LITERALS>Net</LITERALS>",
            2  => "<LITERALS>Win2003</LITERALS>",
            51 => "<LITERALS>NT3</LITERALS>.<LITERALS>51</LITERALS>"
        }
    }->{$<CODE>id</CODE>}->{$<CODE>minor</CODE>};

    # <COMMENTS>If</COMMENTS> <COMMENTS>$os</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>undefined</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>date</COMMENTS>.  <COMMENTS>Suggested</COMMENTS> <COMMENTS>updates</COMMENTS>
    # <COMMENTS>are</COMMENTS> <COMMENTS>welcome</COMMENTS>.
    unless ( defined $<CODE>os</CODE> ) {
        $<CODE>os</CODE> = "";
        $$<CODE>rpending_complaint</CODE> .= <<<LITERALS>EOS</LITERALS>;
<LITERALS>Error</LITERALS> <LITERALS>trying</LITERALS> <LITERALS>to</LITERALS> <LITERALS>discover</LITERALS> <LITERALS>Win_OS_Type</LITERALS>: $<CODE>id</CODE>:$<CODE>major</CODE>:$<CODE>minor</CODE> <LITERALS>Has</LITERALS> <LITERALS>no</LITERALS> <LITERALS>name</LITERALS> <LITERALS>of</LITERALS> <LITERALS>record</LITERALS>!
<LITERALS>We</LITERALS> <LITERALS>won</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>be</LITERALS> <LITERALS>able</LITERALS> <LITERALS>to</LITERALS> <LITERALS>look</LITERALS> <LITERALS>for</LITERALS> <LITERALS>a</LITERALS> <LITERALS>system</LITERALS>-<LITERALS>wide</LITERALS> <LITERALS>config</LITERALS> <LITERALS>file</LITERALS>.
<CODE>EOS</CODE>
    }

    # <COMMENTS>Unfortunately</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>various</COMMENTS> <COMMENTS>versions</COMMENTS> <COMMENTS>isn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>clever</COMMENTS>..
    # <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>outside</COMMENTS> <COMMENTS>case</COMMENTS>.
    return ( $<CODE>os</CODE> eq "<LITERALS>2000</LITERALS>" && $<CODE>major</CODE> != 5 ) ? "<LITERALS>NT4</LITERALS>" : $<CODE>os</CODE>;
}

sub <CODE>is_unix</CODE> {
    return
         ( $^<CODE>O</CODE> !~ /win32|dos/i )
      && ( $^<CODE>O</CODE> ne '<LITERALS>VMS</LITERALS>' )
      && ( $^<CODE>O</CODE> ne '<LITERALS>OS2</LITERALS>' )
      && ( $^<CODE>O</CODE> ne '<LITERALS>MacOS</LITERALS>' );
}

sub <CODE>look_for_Windows</CODE> {

    # <COMMENTS>determine</COMMENTS> <COMMENTS>Windows</COMMENTS> <COMMENTS>sub</COMMENTS>-<COMMENTS>type</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>location</COMMENTS> <COMMENTS>of</COMMENTS>
    # <COMMENTS>system</COMMENTS>-<COMMENTS>wide</COMMENTS> <COMMENTS>configuration</COMMENTS> <COMMENTS>files</COMMENTS>
    my $<CODE>rpending_complaint</CODE> = shift;
    my $<CODE>is_Windows</CODE>         = ( $^<CODE>O</CODE> =~ /win32|dos/i );
    my $<CODE>Windows_type</CODE>       = <CODE>Win_OS_Type</CODE>($<CODE>rpending_complaint</CODE>) if $<CODE>is_Windows</CODE>;
    return ( $<CODE>is_Windows</CODE>, $<CODE>Windows_type</CODE> );
}

sub <CODE>find_config_file</CODE> {

    # <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> .<COMMENTS>perltidyrc</COMMENTS> <COMMENTS>configuration</COMMENTS> <COMMENTS>file</COMMENTS>
    # <COMMENTS>For</COMMENTS> <COMMENTS>Windows</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>named</COMMENTS> <COMMENTS>perltidy</COMMENTS>.<COMMENTS>ini</COMMENTS>
    my ( $<CODE>is_Windows</CODE>, $<CODE>Windows_type</CODE>, $<CODE>rconfig_file_chatter</CODE>,
        $<CODE>rpending_complaint</CODE> ) = @<CODE>_</CODE>;

    $$<CODE>rconfig_file_chatter</CODE> .= "# <LITERALS>Config</LITERALS> <LITERALS>file</LITERALS> <LITERALS>search</LITERALS>...<LITERALS>system</LITERALS> <LITERALS>reported</LITERALS> <LITERALS>as</LITERALS>:";
    if ($<CODE>is_Windows</CODE>) {
        $$<CODE>rconfig_file_chatter</CODE> .= "<LITERALS>Windows</LITERALS> $<CODE>Windows_type</CODE>\n";
    }
    else {
        $$<CODE>rconfig_file_chatter</CODE> .= " $^<CODE>O</CODE>\n";
    }

    # <COMMENTS>sub</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>existence</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>record</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tests</COMMENTS>
    my $<CODE>exists_config_file</CODE> = sub {
        my $<CODE>config_file</CODE> = shift;
        return 0 unless $<CODE>config_file</CODE>;
        $$<CODE>rconfig_file_chatter</CODE> .= "# <LITERALS>Testing</LITERALS>: $<CODE>config_file</CODE>\n";
        return -f $<CODE>config_file</CODE>;
    };

    my $<CODE>config_file</CODE>;

    # <COMMENTS>look</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>directory</COMMENTS> <COMMENTS>first</COMMENTS>
    $<CODE>config_file</CODE> = ".<LITERALS>perltidyrc</LITERALS>";
    return $<CODE>config_file</CODE> if $<CODE>exists_config_file</CODE>->($<CODE>config_file</CODE>);
    if ($<CODE>is_Windows</CODE>) {
        $<CODE>config_file</CODE> = "<LITERALS>perltidy</LITERALS>.<LITERALS>ini</LITERALS>";
        return $<CODE>config_file</CODE> if $<CODE>exists_config_file</CODE>->($<CODE>config_file</CODE>);
    }

    # <COMMENTS>Default</COMMENTS> <COMMENTS>environment</COMMENTS> <COMMENTS>vars</COMMENTS>.
    my @<CODE>envs</CODE> = qw(<LITERALS>PERLTIDY</LITERALS> <LITERALS>HOME</LITERALS>);

    # <COMMENTS>Check</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>NT</COMMENTS>/<COMMENTS>2k</COMMENTS>/<COMMENTS>XP</COMMENTS> <COMMENTS>locations</COMMENTS>, <COMMENTS>first</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>local</COMMENTS> <COMMENTS>machine</COMMENTS> <COMMENTS>def</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>a</COMMENTS>
    # <COMMENTS>network</COMMENTS> <COMMENTS>def</COMMENTS>
    push @<CODE>envs</CODE>, qw(<LITERALS>USERPROFILE</LITERALS> <LITERALS>HOMESHARE</LITERALS>) if $^<CODE>O</CODE> =~ /win32/i;

    # <COMMENTS>Now</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>environment</COMMENTS> ...
    foreach my $<CODE>var</CODE> (@<CODE>envs</CODE>) {
        $$<CODE>rconfig_file_chatter</CODE> .= "# <LITERALS>Examining</LITERALS>: \<LITERALS>$ENV</LITERALS>{$<CODE>var</CODE>}";
        if ( defined( $<CODE>ENV</CODE>{$<CODE>var</CODE>} ) ) {
            $$<CODE>rconfig_file_chatter</CODE> .= " = $<CODE>ENV</CODE>{$<CODE>var</CODE>}\n";

            # <COMMENTS>test</COMMENTS> <COMMENTS>ENV</COMMENTS>{ <COMMENTS>PERLTIDY</COMMENTS> } <COMMENTS>as</COMMENTS> <COMMENTS>file</COMMENTS>:
            if ( $<CODE>var</CODE> eq '<LITERALS>PERLTIDY</LITERALS>' ) {
                $<CODE>config_file</CODE> = "$<CODE>ENV</CODE>{$<CODE>var</CODE>}";
                return $<CODE>config_file</CODE> if $<CODE>exists_config_file</CODE>->($<CODE>config_file</CODE>);
            }

            # <COMMENTS>test</COMMENTS> <COMMENTS>ENV</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>directory</COMMENTS>:
            $<CODE>config_file</CODE> = <CODE>catfile</CODE>( $<CODE>ENV</CODE>{$<CODE>var</CODE>}, ".<LITERALS>perltidyrc</LITERALS>" );
            return $<CODE>config_file</CODE> if $<CODE>exists_config_file</CODE>->($<CODE>config_file</CODE>);

            if ($<CODE>is_Windows</CODE>) {
                $<CODE>config_file</CODE> = <CODE>catfile</CODE>( $<CODE>ENV</CODE>{$<CODE>var</CODE>}, "<LITERALS>perltidy</LITERALS>.<LITERALS>ini</LITERALS>" );
                return $<CODE>config_file</CODE> if $<CODE>exists_config_file</CODE>->($<CODE>config_file</CODE>);
            }
        }
        else {
            $$<CODE>rconfig_file_chatter</CODE> .= "\n";
        }
    }

    # <COMMENTS>then</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>system</COMMENTS>-<COMMENTS>wide</COMMENTS> <COMMENTS>definition</COMMENTS>
    # <COMMENTS>where</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>varies</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>OS</COMMENTS>
    if ($<CODE>is_Windows</CODE>) {

        if ($<CODE>Windows_type</CODE>) {
            my ( $<CODE>os</CODE>, $<CODE>system</CODE>, $<CODE>allusers</CODE> ) =
              <CODE>Win_Config_Locs</CODE>( $<CODE>rpending_complaint</CODE>, $<CODE>Windows_type</CODE> );

            # <COMMENTS>Check</COMMENTS> <COMMENTS>All</COMMENTS> <COMMENTS>Users</COMMENTS> <COMMENTS>directory</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>one</COMMENTS>.
            # <COMMENTS>i</COMMENTS>.<COMMENTS>e</COMMENTS>. <COMMENTS>C</COMMENTS>:\<COMMENTS>Documents</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>Settings</COMMENTS>\<COMMENTS>User</COMMENTS>\<COMMENTS>perltidy</COMMENTS>.<COMMENTS>ini</COMMENTS>
            if ($<CODE>allusers</CODE>) {

                $<CODE>config_file</CODE> = <CODE>catfile</CODE>( $<CODE>allusers</CODE>, ".<LITERALS>perltidyrc</LITERALS>" );
                return $<CODE>config_file</CODE> if $<CODE>exists_config_file</CODE>->($<CODE>config_file</CODE>);

                $<CODE>config_file</CODE> = <CODE>catfile</CODE>( $<CODE>allusers</CODE>, "<LITERALS>perltidy</LITERALS>.<LITERALS>ini</LITERALS>" );
                return $<CODE>config_file</CODE> if $<CODE>exists_config_file</CODE>->($<CODE>config_file</CODE>);
            }

            # <COMMENTS>Check</COMMENTS> <COMMENTS>system</COMMENTS> <COMMENTS>directory</COMMENTS>.
            # <COMMENTS>retain</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>someone</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>able</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>create</COMMENTS>
            # <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>period</COMMENTS>.
            $<CODE>config_file</CODE> = <CODE>catfile</CODE>( $<CODE>system</CODE>, ".<LITERALS>perltidyrc</LITERALS>" );
            return $<CODE>config_file</CODE> if $<CODE>exists_config_file</CODE>->($<CODE>config_file</CODE>);

            $<CODE>config_file</CODE> = <CODE>catfile</CODE>( $<CODE>system</CODE>, "<LITERALS>perltidy</LITERALS>.<LITERALS>ini</LITERALS>" );
            return $<CODE>config_file</CODE> if $<CODE>exists_config_file</CODE>->($<CODE>config_file</CODE>);
        }
    }

    # <COMMENTS>Place</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>customization</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>systems</COMMENTS>
    elsif ( $^<CODE>O</CODE> eq '<LITERALS>OS2</LITERALS>' ) {
    }
    elsif ( $^<CODE>O</CODE> eq '<LITERALS>MacOS</LITERALS>' ) {
    }
    elsif ( $^<CODE>O</CODE> eq '<LITERALS>VMS</LITERALS>' ) {
    }

    # <COMMENTS>Assume</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>kind</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>Unix</COMMENTS>
    else {

        $<CODE>config_file</CODE> = "/<LITERALS>usr</LITERALS>/<LITERALS>local</LITERALS>/<LITERALS>etc</LITERALS>/<LITERALS>perltidyrc</LITERALS>";
        return $<CODE>config_file</CODE> if $<CODE>exists_config_file</CODE>->($<CODE>config_file</CODE>);

        $<CODE>config_file</CODE> = "/<LITERALS>etc</LITERALS>/<LITERALS>perltidyrc</LITERALS>";
        return $<CODE>config_file</CODE> if $<CODE>exists_config_file</CODE>->($<CODE>config_file</CODE>);
    }

    # <COMMENTS>Couldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>config</COMMENTS> <COMMENTS>file</COMMENTS>
    return;
}

sub <CODE>Win_Config_Locs</CODE> {

    # <COMMENTS>In</COMMENTS> <COMMENTS>scalar</COMMENTS> <COMMENTS>context</COMMENTS> <COMMENTS>returns</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>OS</COMMENTS> <COMMENTS>name</COMMENTS> (<COMMENTS>95</COMMENTS> <COMMENTS>98</COMMENTS> <COMMENTS>ME</COMMENTS> <COMMENTS>NT3</COMMENTS>.<COMMENTS>51</COMMENTS> <COMMENTS>NT4</COMMENTS> <COMMENTS>2000</COMMENTS> <COMMENTS>XP</COMMENTS>),
    # <COMMENTS>or</COMMENTS> <COMMENTS>undef</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>win32</COMMENTS> <COMMENTS>OS</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>context</COMMENTS> <COMMENTS>returns</COMMENTS> <COMMENTS>OS</COMMENTS>, <COMMENTS>System</COMMENTS>
    # <COMMENTS>Directory</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>All</COMMENTS> <COMMENTS>Users</COMMENTS> <COMMENTS>Directory</COMMENTS>.  <COMMENTS>All</COMMENTS> <COMMENTS>Users</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS>
    # <COMMENTS>9x</COMMENTS>/<COMMENTS>Me</COMMENTS> <COMMENTS>box</COMMENTS>.  <COMMENTS>Contributed</COMMENTS> <COMMENTS>by</COMMENTS>: <COMMENTS>Yves</COMMENTS> <COMMENTS>Orton</COMMENTS>.

    my $<CODE>rpending_complaint</CODE> = shift;
    my $<CODE>os</CODE> = (@<CODE>_</CODE>) ? shift : <CODE>Win_OS_Type</CODE>();
    return unless $<CODE>os</CODE>;

    my $<CODE>system</CODE>   = "";
    my $<CODE>allusers</CODE> = "";

    if ( $<CODE>os</CODE> =~ /9[58]|Me/ ) {
        $<CODE>system</CODE> = "<LITERALS>C</LITERALS>:/<LITERALS>Windows</LITERALS>";
    }
    elsif ( $<CODE>os</CODE> =~ /NT|XP|200?/ ) {
        $<CODE>system</CODE> = ( $<CODE>os</CODE> =~ /XP/ ) ? "<LITERALS>C</LITERALS>:/<LITERALS>Windows</LITERALS>/" : "<LITERALS>C</LITERALS>:/<LITERALS>WinNT</LITERALS>/";
        $<CODE>allusers</CODE> =
          ( $<CODE>os</CODE> =~ /NT/ )
          ? "<LITERALS>C</LITERALS>:/<LITERALS>WinNT</LITERALS>/<LITERALS>profiles</LITERALS>/<LITERALS>All</LITERALS> <LITERALS>Users</LITERALS>/"
          : "<LITERALS>C</LITERALS>:/<LITERALS>Documents</LITERALS> <LITERALS>and</LITERALS> <LITERALS>Settings</LITERALS>/<LITERALS>All</LITERALS> <LITERALS>Users</LITERALS>/";
    }
    else {

        # <COMMENTS>This</COMMENTS> <COMMENTS>currently</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>win32s</COMMENTS> <COMMENTS>computer</COMMENTS>.  <COMMENTS>I</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>have</COMMENTS>
        # <COMMENTS>one</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>test</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>I</COMMENTS> <COMMENTS>am</COMMENTS> <COMMENTS>unsure</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>proceed</COMMENTS>.  <COMMENTS>Suggestions</COMMENTS> <COMMENTS>welcome</COMMENTS>!
        $$<CODE>rpending_complaint</CODE> .=
"<LITERALS>I</LITERALS> <LITERALS>dont</LITERALS> <LITERALS>know</LITERALS> <LITERALS>a</LITERALS> <LITERALS>sensible</LITERALS> <LITERALS>place</LITERALS> <LITERALS>to</LITERALS> <LITERALS>look</LITERALS> <LITERALS>for</LITERALS> <LITERALS>config</LITERALS> <LITERALS>files</LITERALS> <LITERALS>on</LITERALS> <LITERALS>an</LITERALS> $<CODE>os</CODE> <LITERALS>system</LITERALS>.\n";
        return;
    }
    return wantarray ? ( $<CODE>os</CODE>, $<CODE>system</CODE>, $<CODE>allusers</CODE> ) : $<CODE>os</CODE>;
}

sub <CODE>dump_config_file</CODE> {
    my $<CODE>fh</CODE>                   = shift;
    my $<CODE>config_file</CODE>          = shift;
    my $<CODE>rconfig_file_chatter</CODE> = shift;
    print <CODE>STDOUT</CODE> "$$<CODE>rconfig_file_chatter</CODE>";
    if ($<CODE>fh</CODE>) {
        print <CODE>STDOUT</CODE> "# <LITERALS>Dump</LITERALS> <LITERALS>of</LITERALS> <LITERALS>file</LITERALS>: '$<CODE>config_file</CODE>'\n";
        while ( my $<CODE>line</CODE> = $<CODE>fh</CODE>-><CODE>getline</CODE>() ) { print <CODE>STDOUT</CODE> $<CODE>line</CODE> }
        eval { $<CODE>fh</CODE>-><CODE>close</CODE>() };
    }
    else {
        print <CODE>STDOUT</CODE> "# ...<LITERALS>no</LITERALS> <LITERALS>config</LITERALS> <LITERALS>file</LITERALS> <LITERALS>found</LITERALS>\n";
    }
}

sub <CODE>read_config_file</CODE> {

    my ( $<CODE>fh</CODE>, $<CODE>config_file</CODE>, $<CODE>rexpansion</CODE> ) = @<CODE>_</CODE>;
    my @<CODE>config_list</CODE> = ();

    # <COMMENTS>file</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>empty</COMMENTS> <COMMENTS>$death_message</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>returned</COMMENTS>
    my $<CODE>death_message</CODE> = "";

    my $<CODE>name</CODE> = undef;
    my $<CODE>line_no</CODE>;
    my $<CODE>opening_brace_line</CODE>;
    while ( my $<CODE>line</CODE> = $<CODE>fh</CODE>-><CODE>getline</CODE>() ) {
        $<CODE>line_no</CODE>++;
        chomp $<CODE>line</CODE>;
        ( $<CODE>line</CODE>, $<CODE>death_message</CODE> ) =
          <CODE>strip_comment</CODE>( $<CODE>line</CODE>, $<CODE>config_file</CODE>, $<CODE>line_no</CODE> );
        last if ($<CODE>death_message</CODE>);
        next unless $<CODE>line</CODE>;
        $<CODE>line</CODE> =~ s/^\s*(.*?)\s*$/$<CODE>1</CODE>/;    # <COMMENTS>trim</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>ends</COMMENTS>
        next unless $<CODE>line</CODE>;

        my $<CODE>body</CODE> = $<CODE>line</CODE>;
        my $<CODE>newname</CODE>;

        # <COMMENTS>Look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>complete</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>partial</COMMENTS> <COMMENTS>abbreviation</COMMENTS> <COMMENTS>definition</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>form</COMMENTS>
        #     <COMMENTS>name</COMMENTS> { <COMMENTS>body</COMMENTS> }   <COMMENTS>or</COMMENTS>  <COMMENTS>name</COMMENTS> {   <COMMENTS>or</COMMENTS>    <COMMENTS>name</COMMENTS> { <COMMENTS>body</COMMENTS>
        # <COMMENTS>See</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>perltidy</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>perldoc</COMMENTS> <COMMENTS>page</COMMENTS>
        # <COMMENTS>Section</COMMENTS>: <COMMENTS>Other</COMMENTS> <COMMENTS>Controls</COMMENTS> - <COMMENTS>Creating</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>abbreviation</COMMENTS>
        if ( $<CODE>line</CODE> =~ /^((\w+)\s*\{)(.*)?$/ ) {
            my $<CODE>oldname</CODE> = $<CODE>name</CODE>;
            ( $<CODE>name</CODE>, $<CODE>body</CODE> ) = ( $<CODE>2</CODE>, $<CODE>3</CODE> );

            # <COMMENTS>Cannot</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>abbreviation</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>abbreviation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>complete</COMMENTS>
            last if ($<CODE>opening_brace_line</CODE>);

            $<CODE>opening_brace_line</CODE> = $<CODE>line_no</CODE> unless ( $<CODE>body</CODE> && $<CODE>body</CODE> =~ s/\}$// );

            # <COMMENTS>handle</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>alias</COMMENTS> <COMMENTS>definition</COMMENTS>
            if ( ${$<CODE>rexpansion</CODE>}{$<CODE>name</CODE>} ) {
                local $" = ')(';
                my @<CODE>names</CODE> = sort keys %$<CODE>rexpansion</CODE>;
                $<CODE>death_message</CODE> =
                    "<LITERALS>Here</LITERALS> <LITERALS>is</LITERALS> <LITERALS>a</LITERALS> <LITERALS>list</LITERALS> <LITERALS>of</LITERALS> <LITERALS>all</LITERALS> <LITERALS>installed</LITERALS> <LITERALS>aliases</LITERALS>\n(@<CODE>names</CODE>)\n"
                  . "<LITERALS>Attempting</LITERALS> <LITERALS>to</LITERALS> <LITERALS>redefine</LITERALS> <LITERALS>alias</LITERALS> ($<CODE>name</CODE>) <LITERALS>in</LITERALS> <LITERALS>config</LITERALS> <LITERALS>file</LITERALS> $<CODE>config_file</CODE> <LITERALS>line</LITERALS> $.\n";
                last;
            }
            ${$<CODE>rexpansion</CODE>}{$<CODE>name</CODE>} = [];
        }

        # <COMMENTS>leading</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>allowed</COMMENTS>
        elsif ( $<CODE>line</CODE> =~ /^{/ ) {
            $<CODE>opening_brace_line</CODE> = undef;
            $<CODE>death_message</CODE> =
              "<LITERALS>Unexpected</LITERALS> '{' <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> $<CODE>line_no</CODE> <LITERALS>in</LITERALS> <LITERALS>config</LITERALS> <LITERALS>file</LITERALS> '$<CODE>config_file</CODE>'\n";
            last;
        }

        # <COMMENTS>Look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>abbreviation</COMMENTS> <COMMENTS>closing</COMMENTS>:    <COMMENTS>body</COMMENTS> }   <COMMENTS>or</COMMENTS>    }
        elsif ( $<CODE>line</CODE> =~ /^(.*)?\}$/ ) {
            $<CODE>body</CODE> = $<CODE>1</CODE>;
            if ($<CODE>opening_brace_line</CODE>) {
                $<CODE>opening_brace_line</CODE> = undef;
            }
            else {
                $<CODE>death_message</CODE> =
"<LITERALS>Unexpected</LITERALS> '}' <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> $<CODE>line_no</CODE> <LITERALS>in</LITERALS> <LITERALS>config</LITERALS> <LITERALS>file</LITERALS> '$<CODE>config_file</CODE>'\n";
                last;
            }
        }

        # <COMMENTS>Now</COMMENTS> <COMMENTS>store</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>parameters</COMMENTS>
        if ($<CODE>body</CODE>) {

            my ( $<CODE>rbody_parts</CODE>, $<CODE>msg</CODE> ) = <CODE>parse_args</CODE>($<CODE>body</CODE>);
            if ($<CODE>msg</CODE>) {
                $<CODE>death_message</CODE> = <<<LITERALS>EOM</LITERALS>;
<LITERALS>Error</LITERALS> <LITERALS>reading</LITERALS> <LITERALS>file</LITERALS> '$<CODE>config_file</CODE>' <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> <LITERALS>number</LITERALS> $<CODE>line_no</CODE>.
$<CODE>msg</CODE>
<LITERALS>Please</LITERALS> <LITERALS>fix</LITERALS> <LITERALS>this</LITERALS> <LITERALS>line</LITERALS> <LITERALS>or</LITERALS> <LITERALS>use</LITERALS> -<LITERALS>npro</LITERALS> <LITERALS>to</LITERALS> <LITERALS>avoid</LITERALS> <LITERALS>reading</LITERALS> <LITERALS>this</LITERALS> <LITERALS>file</LITERALS>
<CODE>EOM</CODE>
                last;
            }

            if ($<CODE>name</CODE>) {

                # <COMMENTS>remove</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>dashes</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>alias</COMMENTS>
                foreach (@$<CODE>rbody_parts</CODE>) { s/^\-+//; }
                push @{ ${$<CODE>rexpansion</CODE>}{$<CODE>name</CODE>} }, @$<CODE>rbody_parts</CODE>;
            }
            else {
                push( @<CODE>config_list</CODE>, @$<CODE>rbody_parts</CODE> );
            }
        }
    }

    if ($<CODE>opening_brace_line</CODE>) {
        $<CODE>death_message</CODE> =
"<LITERALS>Didn</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>see</LITERALS> <LITERALS>a</LITERALS> '}' <LITERALS>to</LITERALS> <LITERALS>match</LITERALS> <LITERALS>the</LITERALS> '{' <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> $<CODE>opening_brace_line</CODE> <LITERALS>in</LITERALS> <LITERALS>config</LITERALS> <LITERALS>file</LITERALS> '$<CODE>config_file</CODE>'\n";
    }
    eval { $<CODE>fh</CODE>-><CODE>close</CODE>() };
    return ( \@<CODE>config_list</CODE>, $<CODE>death_message</CODE> );
}

sub <CODE>strip_comment</CODE> {

    # <COMMENTS>Strip</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>command</COMMENTS> <COMMENTS>line</COMMENTS>
    my ( $<CODE>instr</CODE>, $<CODE>config_file</CODE>, $<CODE>line_no</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>msg</CODE> = "";

    # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>full</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>comment</COMMENTS>
    if ( $<CODE>instr</CODE> =~ /^\s*#/ ) {
        return ( "", $<CODE>msg</CODE> );
    }

    # <COMMENTS>nothing</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>comments</COMMENTS>
    if ( $<CODE>instr</CODE> !~ /#/ ) {
        return ( $<CODE>instr</CODE>, $<CODE>msg</CODE> );
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>quotes</COMMENTS>
    elsif ( $<CODE>instr</CODE> !~ /['"]/ ) {

        # <COMMENTS>We</COMMENTS> <COMMENTS>now</COMMENTS> <COMMENTS>require</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> # <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
        # <COMMENTS>this</COMMENTS> <COMMENTS>allows</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS>:
        #    -<COMMENTS>sbcp</COMMENTS>=#
        # <COMMENTS>Otherwise</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>quoted</COMMENTS>:
        #    -<COMMENTS>sbcp</COMMENTS>='#'
        $<CODE>instr</CODE> =~ s/\s+\#.*$//;
        return ( $<CODE>instr</CODE>, $<CODE>msg</CODE> );
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>quotes</COMMENTS>
    my $<CODE>outstr</CODE>     = "";
    my $<CODE>quote_char</CODE> = "";
    while (1) {

        # <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>character</COMMENTS>
        if ($<CODE>quote_char</CODE>) {
            if ( $<CODE>instr</CODE> =~ /\G($<CODE>quote_char</CODE>)/gc ) {
                $<CODE>quote_char</CODE> = "";
                $<CODE>outstr</CODE> .= $<CODE>1</CODE>;
            }
            elsif ( $<CODE>instr</CODE> =~ /\G(.)/gc ) {
                $<CODE>outstr</CODE> .= $<CODE>1</CODE>;
            }

            # <COMMENTS>error</COMMENTS>..<COMMENTS>we</COMMENTS> <COMMENTS>reached</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>seeing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>char</COMMENTS>
            else {
                $<CODE>msg</CODE> = <<<LITERALS>EOM</LITERALS>;
<LITERALS>Error</LITERALS> <LITERALS>reading</LITERALS> <LITERALS>file</LITERALS> $<CODE>config_file</CODE> <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> <LITERALS>number</LITERALS> $<CODE>line_no</CODE>.
<LITERALS>Did</LITERALS> <LITERALS>not</LITERALS> <LITERALS>see</LITERALS> <LITERALS>ending</LITERALS> <LITERALS>quote</LITERALS> <LITERALS>character</LITERALS> <$<CODE>quote_char</CODE>> <LITERALS>in</LITERALS> <LITERALS>this</LITERALS> <LITERALS>text</LITERALS>:
$<CODE>instr</CODE>
<LITERALS>Please</LITERALS> <LITERALS>fix</LITERALS> <LITERALS>this</LITERALS> <LITERALS>line</LITERALS> <LITERALS>or</LITERALS> <LITERALS>use</LITERALS> -<LITERALS>npro</LITERALS> <LITERALS>to</LITERALS> <LITERALS>avoid</LITERALS> <LITERALS>reading</LITERALS> <LITERALS>this</LITERALS> <LITERALS>file</LITERALS>
<CODE>EOM</CODE>
                last;
            }
        }

        # <COMMENTS>accumulating</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>string</COMMENTS>
        else {
            if ( $<CODE>instr</CODE> =~ /\G([\"\'])/gc ) {
                $<CODE>outstr</CODE> .= $<CODE>1</CODE>;
                $<CODE>quote_char</CODE> = $<CODE>1</CODE>;
            }

            # <COMMENTS>Note</COMMENTS>: <COMMENTS>not</COMMENTS> <COMMENTS>yet</COMMENTS> <COMMENTS>enforcing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>space</COMMENTS>-<COMMENTS>before</COMMENTS>-<COMMENTS>hash</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>side</COMMENTS>
            # <COMMENTS>comments</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>parameter</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>quoted</COMMENTS>.
            elsif ( $<CODE>instr</CODE> =~ /\G#/gc ) {
                last;
            }
            elsif ( $<CODE>instr</CODE> =~ /\G(.)/gc ) {
                $<CODE>outstr</CODE> .= $<CODE>1</CODE>;
            }
            else {
                last;
            }
        }
    }
    return ( $<CODE>outstr</CODE>, $<CODE>msg</CODE> );
}

sub <CODE>parse_args</CODE> {

    # <COMMENTS>Parse</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>command</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>containing</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>possible</COMMENTS>
    # <COMMENTS>quotes</COMMENTS>, <COMMENTS>into</COMMENTS> <COMMENTS>individual</COMMENTS> <COMMENTS>commands</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>:
    #
    #    -<COMMENTS>wba</COMMENTS>=" + - "  -<COMMENTS>some</COMMENTS>-<COMMENTS>thing</COMMENTS> -<COMMENTS>wbb</COMMENTS>='. && ||'
    #
    # <COMMENTS>There</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>need</COMMENTS>, <COMMENTS>at</COMMENTS> <COMMENTS>present</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>escaped</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>characters</COMMENTS>.
    # (<COMMENTS>They</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>needn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>strings</COMMENTS>).

    my ($<CODE>body</CODE>)     = @<CODE>_</CODE>;
    my @<CODE>body_parts</CODE> = ();
    my $<CODE>quote_char</CODE> = "";
    my $<CODE>part</CODE>       = "";
    my $<CODE>msg</CODE>        = "";
    while (1) {

        # <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>character</COMMENTS>
        if ($<CODE>quote_char</CODE>) {
            if ( $<CODE>body</CODE> =~ /\G($<CODE>quote_char</CODE>)/gc ) {
                $<CODE>quote_char</CODE> = "";
            }
            elsif ( $<CODE>body</CODE> =~ /\G(.)/gc ) {
                $<CODE>part</CODE> .= $<CODE>1</CODE>;
            }

            # <COMMENTS>error</COMMENTS>..<COMMENTS>we</COMMENTS> <COMMENTS>reached</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>seeing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>char</COMMENTS>
            else {
                if ( length($<CODE>part</CODE>) ) { push @<CODE>body_parts</CODE>, $<CODE>part</CODE>; }
                $<CODE>msg</CODE> = <<<LITERALS>EOM</LITERALS>;
<LITERALS>Did</LITERALS> <LITERALS>not</LITERALS> <LITERALS>see</LITERALS> <LITERALS>ending</LITERALS> <LITERALS>quote</LITERALS> <LITERALS>character</LITERALS> <$<CODE>quote_char</CODE>> <LITERALS>in</LITERALS> <LITERALS>this</LITERALS> <LITERALS>text</LITERALS>:
$<CODE>body</CODE>
<CODE>EOM</CODE>
                last;
            }
        }

        # <COMMENTS>accumulating</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>string</COMMENTS>
        else {
            if ( $<CODE>body</CODE> =~ /\G([\"\'])/gc ) {
                $<CODE>quote_char</CODE> = $<CODE>1</CODE>;
            }
            elsif ( $<CODE>body</CODE> =~ /\G(\s+)/gc ) {
                if ( length($<CODE>part</CODE>) ) { push @<CODE>body_parts</CODE>, $<CODE>part</CODE>; }
                $<CODE>part</CODE> = "";
            }
            elsif ( $<CODE>body</CODE> =~ /\G(.)/gc ) {
                $<CODE>part</CODE> .= $<CODE>1</CODE>;
            }
            else {
                if ( length($<CODE>part</CODE>) ) { push @<CODE>body_parts</CODE>, $<CODE>part</CODE>; }
                last;
            }
        }
    }
    return ( \@<CODE>body_parts</CODE>, $<CODE>msg</CODE> );
}

sub <CODE>dump_long_names</CODE> {

    my @<CODE>names</CODE> = sort @<CODE>_</CODE>;
    print <CODE>STDOUT</CODE> <<<LITERALS>EOM</LITERALS>;
# <LITERALS>Command</LITERALS> <LITERALS>line</LITERALS> <LITERALS>long</LITERALS> <LITERALS>names</LITERALS> (<LITERALS>passed</LITERALS> <LITERALS>to</LITERALS> <LITERALS>GetOptions</LITERALS>)
#---------------------------------------------------------------
# <LITERALS>here</LITERALS> <LITERALS>is</LITERALS> <LITERALS>a</LITERALS> <LITERALS>summary</LITERALS> <LITERALS>of</LITERALS> <LITERALS>the</LITERALS> <LITERALS>Getopt</LITERALS> <LITERALS>codes</LITERALS>:
# <<LITERALS>none</LITERALS>> <LITERALS>does</LITERALS> <LITERALS>not</LITERALS> <LITERALS>take</LITERALS> <LITERALS>an</LITERALS> <LITERALS>argument</LITERALS>
# =<LITERALS>s</LITERALS> <LITERALS>takes</LITERALS> <LITERALS>a</LITERALS> <LITERALS>mandatory</LITERALS> <LITERALS>string</LITERALS>
# :<LITERALS>s</LITERALS> <LITERALS>takes</LITERALS> <LITERALS>an</LITERALS> <LITERALS>optional</LITERALS> <LITERALS>string</LITERALS>
# =<LITERALS>i</LITERALS> <LITERALS>takes</LITERALS> <LITERALS>a</LITERALS> <LITERALS>mandatory</LITERALS> <LITERALS>integer</LITERALS>
# :<LITERALS>i</LITERALS> <LITERALS>takes</LITERALS> <LITERALS>an</LITERALS> <LITERALS>optional</LITERALS> <LITERALS>integer</LITERALS>
# ! <LITERALS>does</LITERALS> <LITERALS>not</LITERALS> <LITERALS>take</LITERALS> <LITERALS>an</LITERALS> <LITERALS>argument</LITERALS> <LITERALS>and</LITERALS> <LITERALS>may</LITERALS> <LITERALS>be</LITERALS> <LITERALS>negated</LITERALS>
#  <LITERALS>i</LITERALS>.<LITERALS>e</LITERALS>., -<LITERALS>foo</LITERALS> <LITERALS>and</LITERALS> -<LITERALS>nofoo</LITERALS> <LITERALS>are</LITERALS> <LITERALS>allowed</LITERALS>
# <LITERALS>a</LITERALS> <LITERALS>double</LITERALS> <LITERALS>dash</LITERALS> <LITERALS>signals</LITERALS> <LITERALS>the</LITERALS> <LITERALS>end</LITERALS> <LITERALS>of</LITERALS> <LITERALS>the</LITERALS> <LITERALS>options</LITERALS> <LITERALS>list</LITERALS>
#
#---------------------------------------------------------------
<CODE>EOM</CODE>

    foreach (@<CODE>names</CODE>) { print <CODE>STDOUT</CODE> "$<CODE>_</CODE>\n" }
}

sub <CODE>dump_defaults</CODE> {
    my @<CODE>defaults</CODE> = sort @<CODE>_</CODE>;
    print <CODE>STDOUT</CODE> "<LITERALS>Default</LITERALS> <LITERALS>command</LITERALS> <LITERALS>line</LITERALS> <LITERALS>options</LITERALS>:\n";
    foreach (@<CODE>_</CODE>) { print <CODE>STDOUT</CODE> "$<CODE>_</CODE>\n" }
}

sub <CODE>readable_options</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>run</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>put</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>perltidyrc</COMMENTS> <COMMENTS>file</COMMENTS>
    my ( $<CODE>rOpts</CODE>, $<CODE>roption_string</CODE> ) = @<CODE>_</CODE>;
    my %<CODE>Getopt_flags</CODE>;
    my $<CODE>rGetopt_flags</CODE>    = \%<CODE>Getopt_flags</CODE>;
    my $<CODE>readable_options</CODE> = "# <LITERALS>Final</LITERALS> <LITERALS>parameter</LITERALS> <LITERALS>set</LITERALS> <LITERALS>for</LITERALS> <LITERALS>this</LITERALS> <LITERALS>run</LITERALS>.\n";
    $<CODE>readable_options</CODE> .=
      "# <LITERALS>See</LITERALS> <LITERALS>utility</LITERALS> '<LITERALS>perltidyrc_dump</LITERALS>.<LITERALS>pl</LITERALS>' <LITERALS>for</LITERALS> <LITERALS>nicer</LITERALS> <LITERALS>formatting</LITERALS>.\n";
    foreach my $<CODE>opt</CODE> ( @{$<CODE>roption_string</CODE>} ) {
        my $<CODE>flag</CODE> = "";
        if ( $<CODE>opt</CODE> =~ /(.*)(!|=.*)$/ ) {
            $<CODE>opt</CODE>  = $<CODE>1</CODE>;
            $<CODE>flag</CODE> = $<CODE>2</CODE>;
        }
        if ( defined( $<CODE>rOpts</CODE>->{$<CODE>opt</CODE>} ) ) {
            $<CODE>rGetopt_flags</CODE>->{$<CODE>opt</CODE>} = $<CODE>flag</CODE>;
        }
    }
    foreach my $<CODE>key</CODE> ( sort keys %{$<CODE>rOpts</CODE>} ) {
        my $<CODE>flag</CODE>   = $<CODE>rGetopt_flags</CODE>->{$<CODE>key</CODE>};
        my $<CODE>value</CODE>  = $<CODE>rOpts</CODE>->{$<CODE>key</CODE>};
        my $<CODE>prefix</CODE> = '--';
        my $<CODE>suffix</CODE> = "";
        if ($<CODE>flag</CODE>) {
            if ( $<CODE>flag</CODE> =~ /^=/ ) {
                if ( $<CODE>value</CODE> !~ /^\d+$/ ) { $<CODE>value</CODE> = '"' . $<CODE>value</CODE> . '"' }
                $<CODE>suffix</CODE> = "=" . $<CODE>value</CODE>;
            }
            elsif ( $<CODE>flag</CODE> =~ /^!/ ) {
                $<CODE>prefix</CODE> .= "<LITERALS>no</LITERALS>" unless ($<CODE>value</CODE>);
            }
            else {

                # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>
                $<CODE>readable_options</CODE> .=
                  "# <LITERALS>ERROR</LITERALS> <LITERALS>in</LITERALS> <LITERALS>dump_options</LITERALS>: <LITERALS>unrecognized</LITERALS> <LITERALS>flag</LITERALS> $<CODE>flag</CODE> <LITERALS>for</LITERALS> $<CODE>key</CODE>\n";
            }
        }
        $<CODE>readable_options</CODE> .= $<CODE>prefix</CODE> . $<CODE>key</CODE> . $<CODE>suffix</CODE> . "\n";
    }
    return $<CODE>readable_options</CODE>;
}

sub <CODE>show_version</CODE> {
    print <CODE>STDOUT</CODE> <<"<LITERALS>EOM</LITERALS>";
<LITERALS>This</LITERALS> <LITERALS>is</LITERALS> <LITERALS>perltidy</LITERALS>, <LITERALS>v</LITERALS>$<CODE>VERSION</CODE>

<LITERALS>Copyright</LITERALS> <LITERALS>2000</LITERALS>-<LITERALS>2016</LITERALS>, <LITERALS>Steve</LITERALS> <LITERALS>Hancock</LITERALS>

<LITERALS>Perltidy</LITERALS> <LITERALS>is</LITERALS> <LITERALS>free</LITERALS> <LITERALS>software</LITERALS> <LITERALS>and</LITERALS> <LITERALS>may</LITERALS> <LITERALS>be</LITERALS> <LITERALS>copied</LITERALS> <LITERALS>under</LITERALS> <LITERALS>the</LITERALS> <LITERALS>terms</LITERALS> <LITERALS>of</LITERALS> <LITERALS>the</LITERALS> <LITERALS>GNU</LITERALS>
<LITERALS>General</LITERALS> <LITERALS>Public</LITERALS> <LITERALS>License</LITERALS>, <LITERALS>which</LITERALS> <LITERALS>is</LITERALS> <LITERALS>included</LITERALS> <LITERALS>in</LITERALS> <LITERALS>the</LITERALS> <LITERALS>distribution</LITERALS> <LITERALS>files</LITERALS>.

<LITERALS>Complete</LITERALS> <LITERALS>documentation</LITERALS> <LITERALS>for</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>can</LITERALS> <LITERALS>be</LITERALS> <LITERALS>found</LITERALS> <LITERALS>using</LITERALS> '<LITERALS>man</LITERALS> <LITERALS>perltidy</LITERALS>'
<LITERALS>or</LITERALS> <LITERALS>on</LITERALS> <LITERALS>the</LITERALS> <LITERALS>internet</LITERALS> <LITERALS>at</LITERALS> <LITERALS>http</LITERALS>://<LITERALS>perltidy</LITERALS>.<LITERALS>sourceforge</LITERALS>.<LITERALS>net</LITERALS>.
<CODE>EOM</CODE>
}

sub <CODE>usage</CODE> {

    print <CODE>STDOUT</CODE> <<<LITERALS>EOF</LITERALS>;
<LITERALS>This</LITERALS> <LITERALS>is</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>version</LITERALS> $<CODE>VERSION</CODE>, <LITERALS>a</LITERALS> <LITERALS>perl</LITERALS> <LITERALS>script</LITERALS> <LITERALS>indenter</LITERALS>.  <LITERALS>Usage</LITERALS>:

    <LITERALS>perltidy</LITERALS> [ <LITERALS>options</LITERALS> ] <LITERALS>file1</LITERALS> <LITERALS>file2</LITERALS> <LITERALS>file3</LITERALS> ...
            (<LITERALS>output</LITERALS> <LITERALS>goes</LITERALS> <LITERALS>to</LITERALS> <LITERALS>file1</LITERALS>.<LITERALS>tdy</LITERALS>, <LITERALS>file2</LITERALS>.<LITERALS>tdy</LITERALS>, <LITERALS>file3</LITERALS>.<LITERALS>tdy</LITERALS>, ...)
    <LITERALS>perltidy</LITERALS> [ <LITERALS>options</LITERALS> ] <LITERALS>file1</LITERALS> -<LITERALS>o</LITERALS> <LITERALS>outfile</LITERALS>
    <LITERALS>perltidy</LITERALS> [ <LITERALS>options</LITERALS> ] <LITERALS>file1</LITERALS> -<LITERALS>st</LITERALS> ><LITERALS>outfile</LITERALS>
    <LITERALS>perltidy</LITERALS> [ <LITERALS>options</LITERALS> ] <<LITERALS>infile</LITERALS> ><LITERALS>outfile</LITERALS>

<LITERALS>Options</LITERALS> <LITERALS>have</LITERALS> <LITERALS>short</LITERALS> <LITERALS>and</LITERALS> <LITERALS>long</LITERALS> <LITERALS>forms</LITERALS>. <LITERALS>Short</LITERALS> <LITERALS>forms</LITERALS> <LITERALS>are</LITERALS> <LITERALS>shown</LITERALS>; <LITERALS>see</LITERALS>
<LITERALS>man</LITERALS> <LITERALS>pages</LITERALS> <LITERALS>for</LITERALS> <LITERALS>long</LITERALS> <LITERALS>forms</LITERALS>.  <LITERALS>Note</LITERALS>: '=<LITERALS>s</LITERALS>' <LITERALS>indicates</LITERALS> <LITERALS>a</LITERALS> <LITERALS>required</LITERALS> <LITERALS>string</LITERALS>,
<LITERALS>and</LITERALS> '=<LITERALS>n</LITERALS>' <LITERALS>indicates</LITERALS> <LITERALS>a</LITERALS> <LITERALS>required</LITERALS> <LITERALS>integer</LITERALS>.

<LITERALS>I</LITERALS>/<LITERALS>O</LITERALS> <LITERALS>control</LITERALS>
 -<LITERALS>h</LITERALS>      <LITERALS>show</LITERALS> <LITERALS>this</LITERALS> <LITERALS>help</LITERALS>
 -<LITERALS>o</LITERALS>=<LITERALS>file</LITERALS> <LITERALS>name</LITERALS> <LITERALS>of</LITERALS> <LITERALS>the</LITERALS> <LITERALS>output</LITERALS> <LITERALS>file</LITERALS> (<LITERALS>only</LITERALS> <LITERALS>if</LITERALS> <LITERALS>single</LITERALS> <LITERALS>input</LITERALS> <LITERALS>file</LITERALS>)
 -<LITERALS>oext</LITERALS>=<LITERALS>s</LITERALS> <LITERALS>change</LITERALS> <LITERALS>output</LITERALS> <LITERALS>extension</LITERALS> <LITERALS>from</LITERALS> '<LITERALS>tdy</LITERALS>' <LITERALS>to</LITERALS> <LITERALS>s</LITERALS>
 -<LITERALS>opath</LITERALS>=<LITERALS>path</LITERALS>  <LITERALS>change</LITERALS> <LITERALS>path</LITERALS> <LITERALS>to</LITERALS> <LITERALS>be</LITERALS> '<LITERALS>path</LITERALS>' <LITERALS>for</LITERALS> <LITERALS>output</LITERALS> <LITERALS>files</LITERALS>
 -<LITERALS>b</LITERALS>      <LITERALS>backup</LITERALS> <LITERALS>original</LITERALS> <LITERALS>to</LITERALS> .<LITERALS>bak</LITERALS> <LITERALS>and</LITERALS> <LITERALS>modify</LITERALS> <LITERALS>file</LITERALS> <LITERALS>in</LITERALS>-<LITERALS>place</LITERALS>
 -<LITERALS>bext</LITERALS>=<LITERALS>s</LITERALS> <LITERALS>change</LITERALS> <LITERALS>default</LITERALS> <LITERALS>backup</LITERALS> <LITERALS>extension</LITERALS> <LITERALS>from</LITERALS> '<LITERALS>bak</LITERALS>' <LITERALS>to</LITERALS> <LITERALS>s</LITERALS>
 -<LITERALS>q</LITERALS>      <LITERALS>deactivate</LITERALS> <LITERALS>error</LITERALS> <LITERALS>messages</LITERALS> (<LITERALS>for</LITERALS> <LITERALS>running</LITERALS> <LITERALS>under</LITERALS> <LITERALS>editor</LITERALS>)
 -<LITERALS>w</LITERALS>      <LITERALS>include</LITERALS> <LITERALS>non</LITERALS>-<LITERALS>critical</LITERALS> <LITERALS>warning</LITERALS> <LITERALS>messages</LITERALS> <LITERALS>in</LITERALS> <LITERALS>the</LITERALS> .<LITERALS>ERR</LITERALS> <LITERALS>error</LITERALS> <LITERALS>output</LITERALS>
 -<LITERALS>syn</LITERALS>    <LITERALS>run</LITERALS> <LITERALS>perl</LITERALS> -<LITERALS>c</LITERALS> <LITERALS>to</LITERALS> <LITERALS>check</LITERALS> <LITERALS>syntax</LITERALS> (<LITERALS>default</LITERALS> <LITERALS>under</LITERALS> <LITERALS>unix</LITERALS> <LITERALS>systems</LITERALS>)
 -<LITERALS>log</LITERALS>    <LITERALS>save</LITERALS> .<LITERALS>LOG</LITERALS> <LITERALS>file</LITERALS>, <LITERALS>which</LITERALS> <LITERALS>has</LITERALS> <LITERALS>useful</LITERALS> <LITERALS>diagnostics</LITERALS>
 -<LITERALS>f</LITERALS>      <LITERALS>force</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>to</LITERALS> <LITERALS>read</LITERALS> <LITERALS>a</LITERALS> <LITERALS>binary</LITERALS> <LITERALS>file</LITERALS>
 -<LITERALS>g</LITERALS>      <LITERALS>like</LITERALS> -<LITERALS>log</LITERALS> <LITERALS>but</LITERALS> <LITERALS>writes</LITERALS> <LITERALS>more</LITERALS> <LITERALS>detailed</LITERALS> .<LITERALS>LOG</LITERALS> <LITERALS>file</LITERALS>, <LITERALS>for</LITERALS> <LITERALS>debugging</LITERALS> <LITERALS>scripts</LITERALS>
 -<LITERALS>opt</LITERALS>    <LITERALS>write</LITERALS> <LITERALS>the</LITERALS> <LITERALS>set</LITERALS> <LITERALS>of</LITERALS> <LITERALS>options</LITERALS> <LITERALS>actually</LITERALS> <LITERALS>used</LITERALS> <LITERALS>to</LITERALS> <LITERALS>a</LITERALS> .<LITERALS>LOG</LITERALS> <LITERALS>file</LITERALS>
 -<LITERALS>npro</LITERALS>   <LITERALS>ignore</LITERALS> .<LITERALS>perltidyrc</LITERALS> <LITERALS>configuration</LITERALS> <LITERALS>command</LITERALS> <LITERALS>file</LITERALS>
 -<LITERALS>pro</LITERALS>=<LITERALS>file</LITERALS>   <LITERALS>read</LITERALS> <LITERALS>configuration</LITERALS> <LITERALS>commands</LITERALS> <LITERALS>from</LITERALS> <LITERALS>file</LITERALS> <LITERALS>instead</LITERALS> <LITERALS>of</LITERALS> .<LITERALS>perltidyrc</LITERALS>
 -<LITERALS>st</LITERALS>     <LITERALS>send</LITERALS> <LITERALS>output</LITERALS> <LITERALS>to</LITERALS> <LITERALS>standard</LITERALS> <LITERALS>output</LITERALS>, <LITERALS>STDOUT</LITERALS>
 -<LITERALS>se</LITERALS>     <LITERALS>send</LITERALS> <LITERALS>all</LITERALS> <LITERALS>error</LITERALS> <LITERALS>output</LITERALS> <LITERALS>to</LITERALS> <LITERALS>standard</LITERALS> <LITERALS>error</LITERALS> <LITERALS>output</LITERALS>, <LITERALS>STDERR</LITERALS>
 -<LITERALS>v</LITERALS>      <LITERALS>display</LITERALS> <LITERALS>version</LITERALS> <LITERALS>number</LITERALS> <LITERALS>to</LITERALS> <LITERALS>standard</LITERALS> <LITERALS>output</LITERALS> <LITERALS>and</LITERALS> <LITERALS>quit</LITERALS>

<LITERALS>Basic</LITERALS> <LITERALS>Options</LITERALS>:
 -<LITERALS>i</LITERALS>=<LITERALS>n</LITERALS>    <LITERALS>use</LITERALS> <LITERALS>n</LITERALS> <LITERALS>columns</LITERALS> <LITERALS>per</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>level</LITERALS> (<LITERALS>default</LITERALS> <LITERALS>n</LITERALS>=<LITERALS>4</LITERALS>)
 -<LITERALS>t</LITERALS>      <LITERALS>tabs</LITERALS>: <LITERALS>use</LITERALS> <LITERALS>one</LITERALS> <LITERALS>tab</LITERALS> <LITERALS>character</LITERALS> <LITERALS>per</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>level</LITERALS>, <LITERALS>not</LITERALS> <LITERALS>recommeded</LITERALS>
 -<LITERALS>nt</LITERALS>     <LITERALS>no</LITERALS> <LITERALS>tabs</LITERALS>: <LITERALS>use</LITERALS> <LITERALS>n</LITERALS> <LITERALS>spaces</LITERALS> <LITERALS>per</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>level</LITERALS> (<LITERALS>default</LITERALS>)
 -<LITERALS>et</LITERALS>=<LITERALS>n</LITERALS>   <LITERALS>entab</LITERALS> <LITERALS>leading</LITERALS> <LITERALS>whitespace</LITERALS> <LITERALS>n</LITERALS> <LITERALS>spaces</LITERALS> <LITERALS>per</LITERALS> <LITERALS>tab</LITERALS>; <LITERALS>not</LITERALS> <LITERALS>recommended</LITERALS>
 -<LITERALS>io</LITERALS>     "<LITERALS>indent</LITERALS> <LITERALS>only</LITERALS>": <LITERALS>just</LITERALS> <LITERALS>do</LITERALS> <LITERALS>indentation</LITERALS>, <LITERALS>no</LITERALS> <LITERALS>other</LITERALS> <LITERALS>formatting</LITERALS>.
 -<LITERALS>sil</LITERALS>=<LITERALS>n</LITERALS>  <LITERALS>set</LITERALS> <LITERALS>starting</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>level</LITERALS> <LITERALS>to</LITERALS> <LITERALS>n</LITERALS>;  <LITERALS>use</LITERALS> <LITERALS>if</LITERALS> <LITERALS>auto</LITERALS> <LITERALS>detection</LITERALS> <LITERALS>fails</LITERALS>
 -<LITERALS>ole</LITERALS>=<LITERALS>s</LITERALS>  <LITERALS>specify</LITERALS> <LITERALS>output</LITERALS> <LITERALS>line</LITERALS> <LITERALS>ending</LITERALS> (<LITERALS>s</LITERALS>=<LITERALS>dos</LITERALS> <LITERALS>or</LITERALS> <LITERALS>win</LITERALS>, <LITERALS>mac</LITERALS>, <LITERALS>unix</LITERALS>)
 -<LITERALS>ple</LITERALS>    <LITERALS>keep</LITERALS> <LITERALS>output</LITERALS> <LITERALS>line</LITERALS> <LITERALS>endings</LITERALS> <LITERALS>same</LITERALS> <LITERALS>as</LITERALS> <LITERALS>input</LITERALS> (<LITERALS>input</LITERALS> <LITERALS>must</LITERALS> <LITERALS>be</LITERALS> <LITERALS>filename</LITERALS>)

<LITERALS>Whitespace</LITERALS> <LITERALS>Control</LITERALS>
 -<LITERALS>fws</LITERALS>    <LITERALS>freeze</LITERALS> <LITERALS>whitespace</LITERALS>; <LITERALS>this</LITERALS> <LITERALS>disables</LITERALS> <LITERALS>all</LITERALS> <LITERALS>whitespace</LITERALS> <LITERALS>changes</LITERALS>
           <LITERALS>and</LITERALS> <LITERALS>disables</LITERALS> <LITERALS>the</LITERALS> <LITERALS>following</LITERALS> <LITERALS>switches</LITERALS>:
 -<LITERALS>bt</LITERALS>=<LITERALS>n</LITERALS>   <LITERALS>sets</LITERALS> <LITERALS>brace</LITERALS> <LITERALS>tightness</LITERALS>,  <LITERALS>n</LITERALS>= (<LITERALS>0</LITERALS> = <LITERALS>loose</LITERALS>, <LITERALS>1</LITERALS>=<LITERALS>default</LITERALS>, <LITERALS>2</LITERALS> = <LITERALS>tight</LITERALS>)
 -<LITERALS>bbt</LITERALS>    <LITERALS>same</LITERALS> <LITERALS>as</LITERALS> -<LITERALS>bt</LITERALS> <LITERALS>but</LITERALS> <LITERALS>for</LITERALS> <LITERALS>code</LITERALS> <LITERALS>block</LITERALS> <LITERALS>braces</LITERALS>; <LITERALS>same</LITERALS> <LITERALS>as</LITERALS> -<LITERALS>bt</LITERALS> <LITERALS>if</LITERALS> <LITERALS>not</LITERALS> <LITERALS>given</LITERALS>
 -<LITERALS>bbvt</LITERALS>   <LITERALS>block</LITERALS> <LITERALS>braces</LITERALS> <LITERALS>vertically</LITERALS> <LITERALS>tight</LITERALS>; <LITERALS>use</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>bl</LITERALS> <LITERALS>or</LITERALS> -<LITERALS>bli</LITERALS>
 -<LITERALS>bbvtl</LITERALS>=<LITERALS>s</LITERALS>  <LITERALS>make</LITERALS> -<LITERALS>bbvt</LITERALS> <LITERALS>to</LITERALS> <LITERALS>apply</LITERALS> <LITERALS>to</LITERALS> <LITERALS>selected</LITERALS> <LITERALS>list</LITERALS> <LITERALS>of</LITERALS> <LITERALS>block</LITERALS> <LITERALS>types</LITERALS>
 -<LITERALS>pt</LITERALS>=<LITERALS>n</LITERALS>   <LITERALS>paren</LITERALS> <LITERALS>tightness</LITERALS> (<LITERALS>n</LITERALS>=<LITERALS>0</LITERALS>, <LITERALS>1</LITERALS> <LITERALS>or</LITERALS> <LITERALS>2</LITERALS>)
 -<LITERALS>sbt</LITERALS>=<LITERALS>n</LITERALS>  <LITERALS>square</LITERALS> <LITERALS>bracket</LITERALS> <LITERALS>tightness</LITERALS> (<LITERALS>n</LITERALS>=<LITERALS>0</LITERALS>, <LITERALS>1</LITERALS>, <LITERALS>or</LITERALS> <LITERALS>2</LITERALS>)
 -<LITERALS>bvt</LITERALS>=<LITERALS>n</LITERALS>  <LITERALS>brace</LITERALS> <LITERALS>vertical</LITERALS> <LITERALS>tightness</LITERALS>,
         <LITERALS>n</LITERALS>=(<LITERALS>0</LITERALS>=<LITERALS>open</LITERALS>, <LITERALS>1</LITERALS>=<LITERALS>close</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>multiple</LITERALS> <LITERALS>steps</LITERALS> <LITERALS>on</LITERALS> <LITERALS>a</LITERALS> <LITERALS>line</LITERALS>, <LITERALS>2</LITERALS>=<LITERALS>always</LITERALS> <LITERALS>close</LITERALS>)
 -<LITERALS>pvt</LITERALS>=<LITERALS>n</LITERALS>  <LITERALS>paren</LITERALS> <LITERALS>vertical</LITERALS> <LITERALS>tightness</LITERALS> (<LITERALS>see</LITERALS> -<LITERALS>bvt</LITERALS> <LITERALS>for</LITERALS> <LITERALS>n</LITERALS>)
 -<LITERALS>sbvt</LITERALS>=<LITERALS>n</LITERALS> <LITERALS>square</LITERALS> <LITERALS>bracket</LITERALS> <LITERALS>vertical</LITERALS> <LITERALS>tightness</LITERALS> (<LITERALS>see</LITERALS> -<LITERALS>bvt</LITERALS> <LITERALS>for</LITERALS> <LITERALS>n</LITERALS>)
 -<LITERALS>bvtc</LITERALS>=<LITERALS>n</LITERALS> <LITERALS>closing</LITERALS> <LITERALS>brace</LITERALS> <LITERALS>vertical</LITERALS> <LITERALS>tightness</LITERALS>:
         <LITERALS>n</LITERALS>=(<LITERALS>0</LITERALS>=<LITERALS>open</LITERALS>, <LITERALS>1</LITERALS>=<LITERALS>sometimes</LITERALS> <LITERALS>close</LITERALS>, <LITERALS>2</LITERALS>=<LITERALS>always</LITERALS> <LITERALS>close</LITERALS>)
 -<LITERALS>pvtc</LITERALS>=<LITERALS>n</LITERALS> <LITERALS>closing</LITERALS> <LITERALS>paren</LITERALS> <LITERALS>vertical</LITERALS> <LITERALS>tightness</LITERALS>, <LITERALS>see</LITERALS> -<LITERALS>bvtc</LITERALS> <LITERALS>for</LITERALS> <LITERALS>n</LITERALS>.
 -<LITERALS>sbvtc</LITERALS>=<LITERALS>n</LITERALS> <LITERALS>closing</LITERALS> <LITERALS>square</LITERALS> <LITERALS>bracket</LITERALS> <LITERALS>vertical</LITERALS> <LITERALS>tightness</LITERALS>, <LITERALS>see</LITERALS> -<LITERALS>bvtc</LITERALS> <LITERALS>for</LITERALS> <LITERALS>n</LITERALS>.
 -<LITERALS>ci</LITERALS>=<LITERALS>n</LITERALS>   <LITERALS>sets</LITERALS> <LITERALS>continuation</LITERALS> <LITERALS>indentation</LITERALS>=<LITERALS>n</LITERALS>,  <LITERALS>default</LITERALS> <LITERALS>is</LITERALS> <LITERALS>n</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>spaces</LITERALS>
 -<LITERALS>lp</LITERALS>     <LITERALS>line</LITERALS> <LITERALS>up</LITERALS> <LITERALS>parentheses</LITERALS>, <LITERALS>brackets</LITERALS>, <LITERALS>and</LITERALS> <LITERALS>non</LITERALS>-<LITERALS>BLOCK</LITERALS> <LITERALS>braces</LITERALS>
 -<LITERALS>sfs</LITERALS>    <LITERALS>add</LITERALS> <LITERALS>space</LITERALS> <LITERALS>before</LITERALS> <LITERALS>semicolon</LITERALS> <LITERALS>in</LITERALS> <LITERALS>for</LITERALS>( ; ; )
 -<LITERALS>aws</LITERALS>    <LITERALS>allow</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>to</LITERALS> <LITERALS>add</LITERALS> <LITERALS>whitespace</LITERALS> (<LITERALS>default</LITERALS>)
 -<LITERALS>dws</LITERALS>    <LITERALS>delete</LITERALS> <LITERALS>all</LITERALS> <LITERALS>old</LITERALS> <LITERALS>non</LITERALS>-<LITERALS>essential</LITERALS> <LITERALS>whitespace</LITERALS>
 -<LITERALS>icb</LITERALS>    <LITERALS>indent</LITERALS> <LITERALS>closing</LITERALS> <LITERALS>brace</LITERALS> <LITERALS>of</LITERALS> <LITERALS>a</LITERALS> <LITERALS>code</LITERALS> <LITERALS>block</LITERALS>
 -<LITERALS>cti</LITERALS>=<LITERALS>n</LITERALS>  <LITERALS>closing</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>of</LITERALS> <LITERALS>paren</LITERALS>, <LITERALS>square</LITERALS> <LITERALS>bracket</LITERALS>, <LITERALS>or</LITERALS> <LITERALS>non</LITERALS>-<LITERALS>block</LITERALS> <LITERALS>brace</LITERALS>:
         <LITERALS>n</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>none</LITERALS>, =<LITERALS>1</LITERALS> <LITERALS>align</LITERALS> <LITERALS>with</LITERALS> <LITERALS>opening</LITERALS>, =<LITERALS>2</LITERALS> <LITERALS>one</LITERALS> <LITERALS>full</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>level</LITERALS>
 -<LITERALS>icp</LITERALS>    <LITERALS>equivalent</LITERALS> <LITERALS>to</LITERALS> -<LITERALS>cti</LITERALS>=<LITERALS>2</LITERALS>
 -<LITERALS>wls</LITERALS>=<LITERALS>s</LITERALS>  <LITERALS>want</LITERALS> <LITERALS>space</LITERALS> <LITERALS>left</LITERALS> <LITERALS>of</LITERALS> <LITERALS>tokens</LITERALS> <LITERALS>in</LITERALS> <LITERALS>string</LITERALS>; <LITERALS>i</LITERALS>.<LITERALS>e</LITERALS>. -<LITERALS>nwls</LITERALS>='+ - * /'
 -<LITERALS>wrs</LITERALS>=<LITERALS>s</LITERALS>  <LITERALS>want</LITERALS> <LITERALS>space</LITERALS> <LITERALS>right</LITERALS> <LITERALS>of</LITERALS> <LITERALS>tokens</LITERALS> <LITERALS>in</LITERALS> <LITERALS>string</LITERALS>;
 -<LITERALS>sts</LITERALS>    <LITERALS>put</LITERALS> <LITERALS>space</LITERALS> <LITERALS>before</LITERALS> <LITERALS>terminal</LITERALS> <LITERALS>semicolon</LITERALS> <LITERALS>of</LITERALS> <LITERALS>a</LITERALS> <LITERALS>statement</LITERALS>
 -<LITERALS>sak</LITERALS>=<LITERALS>s</LITERALS>  <LITERALS>put</LITERALS> <LITERALS>space</LITERALS> <LITERALS>between</LITERALS> <LITERALS>keywords</LITERALS> <LITERALS>given</LITERALS> <LITERALS>in</LITERALS> <LITERALS>s</LITERALS> <LITERALS>and</LITERALS> '(';
 -<LITERALS>nsak</LITERALS>=<LITERALS>s</LITERALS> <LITERALS>no</LITERALS> <LITERALS>space</LITERALS> <LITERALS>between</LITERALS> <LITERALS>keywords</LITERALS> <LITERALS>in</LITERALS> <LITERALS>s</LITERALS> <LITERALS>and</LITERALS> '('; <LITERALS>i</LITERALS>.<LITERALS>e</LITERALS>. -<LITERALS>nsak</LITERALS>='<LITERALS>my</LITERALS> <LITERALS>our</LITERALS> <LITERALS>local</LITERALS>'

<LITERALS>Line</LITERALS> <LITERALS>Break</LITERALS> <LITERALS>Control</LITERALS>
 -<LITERALS>fnl</LITERALS>    <LITERALS>freeze</LITERALS> <LITERALS>newlines</LITERALS>; <LITERALS>this</LITERALS> <LITERALS>disables</LITERALS> <LITERALS>all</LITERALS> <LITERALS>line</LITERALS> <LITERALS>break</LITERALS> <LITERALS>changes</LITERALS>
            <LITERALS>and</LITERALS> <LITERALS>disables</LITERALS> <LITERALS>the</LITERALS> <LITERALS>following</LITERALS> <LITERALS>switches</LITERALS>:
 -<LITERALS>anl</LITERALS>    <LITERALS>add</LITERALS> <LITERALS>newlines</LITERALS>;  <LITERALS>ok</LITERALS> <LITERALS>to</LITERALS> <LITERALS>introduce</LITERALS> <LITERALS>new</LITERALS> <LITERALS>line</LITERALS> <LITERALS>breaks</LITERALS>
 -<LITERALS>bbs</LITERALS>    <LITERALS>add</LITERALS> <LITERALS>blank</LITERALS> <LITERALS>line</LITERALS> <LITERALS>before</LITERALS> <LITERALS>subs</LITERALS> <LITERALS>and</LITERALS> <LITERALS>packages</LITERALS>
 -<LITERALS>bbc</LITERALS>    <LITERALS>add</LITERALS> <LITERALS>blank</LITERALS> <LITERALS>line</LITERALS> <LITERALS>before</LITERALS> <LITERALS>block</LITERALS> <LITERALS>comments</LITERALS>
 -<LITERALS>bbb</LITERALS>    <LITERALS>add</LITERALS> <LITERALS>blank</LITERALS> <LITERALS>line</LITERALS> <LITERALS>between</LITERALS> <LITERALS>major</LITERALS> <LITERALS>blocks</LITERALS>
 -<LITERALS>kbl</LITERALS>=<LITERALS>n</LITERALS>  <LITERALS>keep</LITERALS> <LITERALS>old</LITERALS> <LITERALS>blank</LITERALS> <LITERALS>lines</LITERALS>? <LITERALS>0</LITERALS>=<LITERALS>no</LITERALS>, <LITERALS>1</LITERALS>=<LITERALS>some</LITERALS>, <LITERALS>2</LITERALS>=<LITERALS>all</LITERALS>
 -<LITERALS>mbl</LITERALS>=<LITERALS>n</LITERALS>  <LITERALS>maximum</LITERALS> <LITERALS>consecutive</LITERALS> <LITERALS>blank</LITERALS> <LITERALS>lines</LITERALS> <LITERALS>to</LITERALS> <LITERALS>output</LITERALS> (<LITERALS>default</LITERALS>=<LITERALS>1</LITERALS>)
 -<LITERALS>ce</LITERALS>     <LITERALS>cuddled</LITERALS> <LITERALS>else</LITERALS>; <LITERALS>use</LITERALS> <LITERALS>this</LITERALS> <LITERALS>style</LITERALS>: '} <LITERALS>else</LITERALS> {'
 -<LITERALS>dnl</LITERALS>    <LITERALS>delete</LITERALS> <LITERALS>old</LITERALS> <LITERALS>newlines</LITERALS> (<LITERALS>default</LITERALS>)
 -<LITERALS>l</LITERALS>=<LITERALS>n</LITERALS>    <LITERALS>maximum</LITERALS> <LITERALS>line</LITERALS> <LITERALS>length</LITERALS>;  <LITERALS>default</LITERALS> <LITERALS>n</LITERALS>=<LITERALS>80</LITERALS>
 -<LITERALS>bl</LITERALS>     <LITERALS>opening</LITERALS> <LITERALS>brace</LITERALS> <LITERALS>on</LITERALS> <LITERALS>new</LITERALS> <LITERALS>line</LITERALS>
 -<LITERALS>sbl</LITERALS>    <LITERALS>opening</LITERALS> <LITERALS>sub</LITERALS> <LITERALS>brace</LITERALS> <LITERALS>on</LITERALS> <LITERALS>new</LITERALS> <LITERALS>line</LITERALS>.  <LITERALS>value</LITERALS> <LITERALS>of</LITERALS> -<LITERALS>bl</LITERALS> <LITERALS>is</LITERALS> <LITERALS>used</LITERALS> <LITERALS>if</LITERALS> <LITERALS>not</LITERALS> <LITERALS>given</LITERALS>.
 -<LITERALS>bli</LITERALS>    <LITERALS>opening</LITERALS> <LITERALS>brace</LITERALS> <LITERALS>on</LITERALS> <LITERALS>new</LITERALS> <LITERALS>line</LITERALS> <LITERALS>and</LITERALS> <LITERALS>indented</LITERALS>
 -<LITERALS>bar</LITERALS>    <LITERALS>opening</LITERALS> <LITERALS>brace</LITERALS> <LITERALS>always</LITERALS> <LITERALS>on</LITERALS> <LITERALS>right</LITERALS>, <LITERALS>even</LITERALS> <LITERALS>for</LITERALS> <LITERALS>long</LITERALS> <LITERALS>clauses</LITERALS>
 -<LITERALS>vt</LITERALS>=<LITERALS>n</LITERALS>   <LITERALS>vertical</LITERALS> <LITERALS>tightness</LITERALS> (<LITERALS>requires</LITERALS> -<LITERALS>lp</LITERALS>); <LITERALS>n</LITERALS> <LITERALS>controls</LITERALS> <LITERALS>break</LITERALS> <LITERALS>after</LITERALS> <LITERALS>opening</LITERALS>
         <LITERALS>token</LITERALS>: <LITERALS>0</LITERALS>=<LITERALS>never</LITERALS>  <LITERALS>1</LITERALS>=<LITERALS>no</LITERALS> <LITERALS>break</LITERALS> <LITERALS>if</LITERALS> <LITERALS>next</LITERALS> <LITERALS>line</LITERALS> <LITERALS>balanced</LITERALS>   <LITERALS>2</LITERALS>=<LITERALS>no</LITERALS> <LITERALS>break</LITERALS>
 -<LITERALS>vtc</LITERALS>=<LITERALS>n</LITERALS>  <LITERALS>vertical</LITERALS> <LITERALS>tightness</LITERALS> <LITERALS>of</LITERALS> <LITERALS>closing</LITERALS> <LITERALS>container</LITERALS>; <LITERALS>n</LITERALS> <LITERALS>controls</LITERALS> <LITERALS>if</LITERALS> <LITERALS>closing</LITERALS>
         <LITERALS>token</LITERALS> <LITERALS>starts</LITERALS> <LITERALS>new</LITERALS> <LITERALS>line</LITERALS>: <LITERALS>0</LITERALS>=<LITERALS>always</LITERALS>  <LITERALS>1</LITERALS>=<LITERALS>not</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>list</LITERALS>  <LITERALS>1</LITERALS>=<LITERALS>never</LITERALS>
 -<LITERALS>wba</LITERALS>=<LITERALS>s</LITERALS>  <LITERALS>want</LITERALS> <LITERALS>break</LITERALS> <LITERALS>after</LITERALS> <LITERALS>tokens</LITERALS> <LITERALS>in</LITERALS> <LITERALS>string</LITERALS>; <LITERALS>i</LITERALS>.<LITERALS>e</LITERALS>. <LITERALS>wba</LITERALS>=': .'
 -<LITERALS>wbb</LITERALS>=<LITERALS>s</LITERALS>  <LITERALS>want</LITERALS> <LITERALS>break</LITERALS> <LITERALS>before</LITERALS> <LITERALS>tokens</LITERALS> <LITERALS>in</LITERALS> <LITERALS>string</LITERALS>

<LITERALS>Following</LITERALS> <LITERALS>Old</LITERALS> <LITERALS>Breakpoints</LITERALS>
 -<LITERALS>kis</LITERALS>    <LITERALS>keep</LITERALS> <LITERALS>interior</LITERALS> <LITERALS>semicolons</LITERALS>.  <LITERALS>Allows</LITERALS> <LITERALS>multiple</LITERALS> <LITERALS>statements</LITERALS> <LITERALS>per</LITERALS> <LITERALS>line</LITERALS>.
 -<LITERALS>boc</LITERALS>    <LITERALS>break</LITERALS> <LITERALS>at</LITERALS> <LITERALS>old</LITERALS> <LITERALS>comma</LITERALS> <LITERALS>breaks</LITERALS>: <LITERALS>turns</LITERALS> <LITERALS>off</LITERALS> <LITERALS>all</LITERALS> <LITERALS>automatic</LITERALS> <LITERALS>list</LITERALS> <LITERALS>formatting</LITERALS>
 -<LITERALS>bol</LITERALS>    <LITERALS>break</LITERALS> <LITERALS>at</LITERALS> <LITERALS>old</LITERALS> <LITERALS>logical</LITERALS> <LITERALS>breakpoints</LITERALS>: <LITERALS>or</LITERALS>, <LITERALS>and</LITERALS>, ||, && (<LITERALS>default</LITERALS>)
 -<LITERALS>bok</LITERALS>    <LITERALS>break</LITERALS> <LITERALS>at</LITERALS> <LITERALS>old</LITERALS> <LITERALS>list</LITERALS> <LITERALS>keyword</LITERALS> <LITERALS>breakpoints</LITERALS> <LITERALS>such</LITERALS> <LITERALS>as</LITERALS> <LITERALS>map</LITERALS>, <LITERALS>sort</LITERALS> (<LITERALS>default</LITERALS>)
 -<LITERALS>bot</LITERALS>    <LITERALS>break</LITERALS> <LITERALS>at</LITERALS> <LITERALS>old</LITERALS> <LITERALS>conditional</LITERALS> (<LITERALS>ternary</LITERALS> ?:) <LITERALS>operator</LITERALS> <LITERALS>breakpoints</LITERALS> (<LITERALS>default</LITERALS>)
 -<LITERALS>boa</LITERALS>    <LITERALS>break</LITERALS> <LITERALS>at</LITERALS> <LITERALS>old</LITERALS> <LITERALS>attribute</LITERALS> <LITERALS>breakpoints</LITERALS>
 -<LITERALS>cab</LITERALS>=<LITERALS>n</LITERALS>  <LITERALS>break</LITERALS> <LITERALS>at</LITERALS> <LITERALS>commas</LITERALS> <LITERALS>after</LITERALS> <LITERALS>a</LITERALS> <LITERALS>comma</LITERALS>-<LITERALS>arrow</LITERALS> (=>):
         <LITERALS>n</LITERALS>=<LITERALS>0</LITERALS> <LITERALS>break</LITERALS> <LITERALS>at</LITERALS> <LITERALS>all</LITERALS> <LITERALS>commas</LITERALS> <LITERALS>after</LITERALS> =>
         <LITERALS>n</LITERALS>=<LITERALS>1</LITERALS> <LITERALS>stable</LITERALS>: <LITERALS>break</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>this</LITERALS> <LITERALS>breaks</LITERALS> <LITERALS>an</LITERALS> <LITERALS>existing</LITERALS> <LITERALS>one</LITERALS>-<LITERALS>line</LITERALS> <LITERALS>container</LITERALS>
         <LITERALS>n</LITERALS>=<LITERALS>2</LITERALS> <LITERALS>break</LITERALS> <LITERALS>only</LITERALS> <LITERALS>if</LITERALS> <LITERALS>a</LITERALS> <LITERALS>one</LITERALS>-<LITERALS>line</LITERALS> <LITERALS>container</LITERALS> <LITERALS>cannot</LITERALS> <LITERALS>be</LITERALS> <LITERALS>formed</LITERALS>
         <LITERALS>n</LITERALS>=<LITERALS>3</LITERALS> <LITERALS>do</LITERALS> <LITERALS>not</LITERALS> <LITERALS>treat</LITERALS> <LITERALS>commas</LITERALS> <LITERALS>after</LITERALS> => <LITERALS>specially</LITERALS> <LITERALS>at</LITERALS> <LITERALS>all</LITERALS>

<LITERALS>Comment</LITERALS> <LITERALS>controls</LITERALS>
 -<LITERALS>ibc</LITERALS>    <LITERALS>indent</LITERALS> <LITERALS>block</LITERALS> <LITERALS>comments</LITERALS> (<LITERALS>default</LITERALS>)
 -<LITERALS>isbc</LITERALS>   <LITERALS>indent</LITERALS> <LITERALS>spaced</LITERALS> <LITERALS>block</LITERALS> <LITERALS>comments</LITERALS>; <LITERALS>may</LITERALS> <LITERALS>indent</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>no</LITERALS> <LITERALS>leading</LITERALS> <LITERALS>space</LITERALS>
 -<LITERALS>msc</LITERALS>=<LITERALS>n</LITERALS>  <LITERALS>minimum</LITERALS> <LITERALS>desired</LITERALS> <LITERALS>spaces</LITERALS> <LITERALS>to</LITERALS> <LITERALS>side</LITERALS> <LITERALS>comment</LITERALS>, <LITERALS>default</LITERALS> <LITERALS>4</LITERALS>
 -<LITERALS>fpsc</LITERALS>=<LITERALS>n</LITERALS> <LITERALS>fix</LITERALS> <LITERALS>position</LITERALS> <LITERALS>for</LITERALS> <LITERALS>side</LITERALS> <LITERALS>comments</LITERALS>; <LITERALS>default</LITERALS> <LITERALS>0</LITERALS>;
 -<LITERALS>csc</LITERALS>    <LITERALS>add</LITERALS> <LITERALS>or</LITERALS> <LITERALS>update</LITERALS> <LITERALS>closing</LITERALS> <LITERALS>side</LITERALS> <LITERALS>comments</LITERALS> <LITERALS>after</LITERALS> <LITERALS>closing</LITERALS> <LITERALS>BLOCK</LITERALS> <LITERALS>brace</LITERALS>
 -<LITERALS>dcsc</LITERALS>   <LITERALS>delete</LITERALS> <LITERALS>closing</LITERALS> <LITERALS>side</LITERALS> <LITERALS>comments</LITERALS> <LITERALS>created</LITERALS> <LITERALS>by</LITERALS> <LITERALS>a</LITERALS> -<LITERALS>csc</LITERALS> <LITERALS>command</LITERALS>
 -<LITERALS>cscp</LITERALS>=<LITERALS>s</LITERALS> <LITERALS>change</LITERALS> <LITERALS>closing</LITERALS> <LITERALS>side</LITERALS> <LITERALS>comment</LITERALS> <LITERALS>prefix</LITERALS> <LITERALS>to</LITERALS> <LITERALS>be</LITERALS> <LITERALS>other</LITERALS> <LITERALS>than</LITERALS> '## <LITERALS>end</LITERALS>'
 -<LITERALS>cscl</LITERALS>=<LITERALS>s</LITERALS> <LITERALS>change</LITERALS> <LITERALS>closing</LITERALS> <LITERALS>side</LITERALS> <LITERALS>comment</LITERALS> <LITERALS>to</LITERALS> <LITERALS>apply</LITERALS> <LITERALS>to</LITERALS> <LITERALS>selected</LITERALS> <LITERALS>list</LITERALS> <LITERALS>of</LITERALS> <LITERALS>blocks</LITERALS>
 -<LITERALS>csci</LITERALS>=<LITERALS>n</LITERALS> <LITERALS>minimum</LITERALS> <LITERALS>number</LITERALS> <LITERALS>of</LITERALS> <LITERALS>lines</LITERALS> <LITERALS>needed</LITERALS> <LITERALS>to</LITERALS> <LITERALS>apply</LITERALS> <LITERALS>a</LITERALS> -<LITERALS>csc</LITERALS> <LITERALS>tag</LITERALS>, <LITERALS>default</LITERALS> <LITERALS>n</LITERALS>=<LITERALS>6</LITERALS>
 -<LITERALS>csct</LITERALS>=<LITERALS>n</LITERALS> <LITERALS>maximum</LITERALS> <LITERALS>number</LITERALS> <LITERALS>of</LITERALS> <LITERALS>columns</LITERALS> <LITERALS>of</LITERALS> <LITERALS>appended</LITERALS> <LITERALS>text</LITERALS>, <LITERALS>default</LITERALS> <LITERALS>n</LITERALS>=<LITERALS>20</LITERALS>
 -<LITERALS>cscw</LITERALS>   <LITERALS>causes</LITERALS> <LITERALS>warning</LITERALS> <LITERALS>if</LITERALS> <LITERALS>old</LITERALS> <LITERALS>side</LITERALS> <LITERALS>comment</LITERALS> <LITERALS>is</LITERALS> <LITERALS>overwritten</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>csc</LITERALS>

 -<LITERALS>sbc</LITERALS>    <LITERALS>use</LITERALS> '<LITERALS>static</LITERALS> <LITERALS>block</LITERALS> <LITERALS>comments</LITERALS>' <LITERALS>identified</LITERALS> <LITERALS>by</LITERALS> <LITERALS>leading</LITERALS> '##' (<LITERALS>default</LITERALS>)
 -<LITERALS>sbcp</LITERALS>=<LITERALS>s</LITERALS> <LITERALS>change</LITERALS> <LITERALS>static</LITERALS> <LITERALS>block</LITERALS> <LITERALS>comment</LITERALS> <LITERALS>identifier</LITERALS> <LITERALS>to</LITERALS> <LITERALS>be</LITERALS> <LITERALS>other</LITERALS> <LITERALS>than</LITERALS> '##'
 -<LITERALS>osbc</LITERALS>   <LITERALS>outdent</LITERALS> <LITERALS>static</LITERALS> <LITERALS>block</LITERALS> <LITERALS>comments</LITERALS>

 -<LITERALS>ssc</LITERALS>    <LITERALS>use</LITERALS> '<LITERALS>static</LITERALS> <LITERALS>side</LITERALS> <LITERALS>comments</LITERALS>' <LITERALS>identified</LITERALS> <LITERALS>by</LITERALS> <LITERALS>leading</LITERALS> '##' (<LITERALS>default</LITERALS>)
 -<LITERALS>sscp</LITERALS>=<LITERALS>s</LITERALS> <LITERALS>change</LITERALS> <LITERALS>static</LITERALS> <LITERALS>side</LITERALS> <LITERALS>comment</LITERALS> <LITERALS>identifier</LITERALS> <LITERALS>to</LITERALS> <LITERALS>be</LITERALS> <LITERALS>other</LITERALS> <LITERALS>than</LITERALS> '##'

<LITERALS>Delete</LITERALS> <LITERALS>selected</LITERALS> <LITERALS>text</LITERALS>
 -<LITERALS>dac</LITERALS>    <LITERALS>delete</LITERALS> <LITERALS>all</LITERALS> <LITERALS>comments</LITERALS> <LITERALS>AND</LITERALS> <LITERALS>pod</LITERALS>
 -<LITERALS>dbc</LITERALS>    <LITERALS>delete</LITERALS> <LITERALS>block</LITERALS> <LITERALS>comments</LITERALS>
 -<LITERALS>dsc</LITERALS>    <LITERALS>delete</LITERALS> <LITERALS>side</LITERALS> <LITERALS>comments</LITERALS>
 -<LITERALS>dp</LITERALS>     <LITERALS>delete</LITERALS> <LITERALS>pod</LITERALS>

<LITERALS>Send</LITERALS> <LITERALS>selected</LITERALS> <LITERALS>text</LITERALS> <LITERALS>to</LITERALS> <LITERALS>a</LITERALS> '.<LITERALS>TEE</LITERALS>' <LITERALS>file</LITERALS>
 -<LITERALS>tac</LITERALS>    <LITERALS>tee</LITERALS> <LITERALS>all</LITERALS> <LITERALS>comments</LITERALS> <LITERALS>AND</LITERALS> <LITERALS>pod</LITERALS>
 -<LITERALS>tbc</LITERALS>    <LITERALS>tee</LITERALS> <LITERALS>block</LITERALS> <LITERALS>comments</LITERALS>
 -<LITERALS>tsc</LITERALS>    <LITERALS>tee</LITERALS> <LITERALS>side</LITERALS> <LITERALS>comments</LITERALS>
 -<LITERALS>tp</LITERALS>     <LITERALS>tee</LITERALS> <LITERALS>pod</LITERALS>

<LITERALS>Outdenting</LITERALS>
 -<LITERALS>olq</LITERALS>    <LITERALS>outdent</LITERALS> <LITERALS>long</LITERALS> <LITERALS>quoted</LITERALS> <LITERALS>strings</LITERALS> (<LITERALS>default</LITERALS>)
 -<LITERALS>olc</LITERALS>    <LITERALS>outdent</LITERALS> <LITERALS>a</LITERALS> <LITERALS>long</LITERALS> <LITERALS>block</LITERALS> <LITERALS>comment</LITERALS> <LITERALS>line</LITERALS>
 -<LITERALS>ola</LITERALS>    <LITERALS>outdent</LITERALS> <LITERALS>statement</LITERALS> <LITERALS>labels</LITERALS>
 -<LITERALS>okw</LITERALS>    <LITERALS>outdent</LITERALS> <LITERALS>control</LITERALS> <LITERALS>keywords</LITERALS> (<LITERALS>redo</LITERALS>, <LITERALS>next</LITERALS>, <LITERALS>last</LITERALS>, <LITERALS>goto</LITERALS>, <LITERALS>return</LITERALS>)
 -<LITERALS>okwl</LITERALS>=<LITERALS>s</LITERALS> <LITERALS>specify</LITERALS> <LITERALS>alternative</LITERALS> <LITERALS>keywords</LITERALS> <LITERALS>for</LITERALS> -<LITERALS>okw</LITERALS> <LITERALS>command</LITERALS>

<LITERALS>Other</LITERALS> <LITERALS>controls</LITERALS>
 -<LITERALS>mft</LITERALS>=<LITERALS>n</LITERALS>  <LITERALS>maximum</LITERALS> <LITERALS>fields</LITERALS> <LITERALS>per</LITERALS> <LITERALS>table</LITERALS>; <LITERALS>default</LITERALS> <LITERALS>n</LITERALS>=<LITERALS>40</LITERALS>
 -<LITERALS>x</LITERALS>      <LITERALS>do</LITERALS> <LITERALS>not</LITERALS> <LITERALS>format</LITERALS> <LITERALS>lines</LITERALS> <LITERALS>before</LITERALS> <LITERALS>hash</LITERALS>-<LITERALS>bang</LITERALS> <LITERALS>line</LITERALS> (<LITERALS>i</LITERALS>.<LITERALS>e</LITERALS>., <LITERALS>for</LITERALS> <LITERALS>VMS</LITERALS>)
 -<LITERALS>asc</LITERALS>    <LITERALS>allows</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>to</LITERALS> <LITERALS>add</LITERALS> <LITERALS>a</LITERALS> ';' <LITERALS>when</LITERALS> <LITERALS>missing</LITERALS> (<LITERALS>default</LITERALS>)
 -<LITERALS>dsm</LITERALS>    <LITERALS>allows</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>to</LITERALS> <LITERALS>delete</LITERALS> <LITERALS>an</LITERALS> <LITERALS>unnecessary</LITERALS> ';'  (<LITERALS>default</LITERALS>)

<LITERALS>Combinations</LITERALS> <LITERALS>of</LITERALS> <LITERALS>other</LITERALS> <LITERALS>parameters</LITERALS>
 -<LITERALS>gnu</LITERALS>     <LITERALS>attempt</LITERALS> <LITERALS>to</LITERALS> <LITERALS>follow</LITERALS> <LITERALS>GNU</LITERALS> <LITERALS>Coding</LITERALS> <LITERALS>Standards</LITERALS> <LITERALS>as</LITERALS> <LITERALS>applied</LITERALS> <LITERALS>to</LITERALS> <LITERALS>perl</LITERALS>
 -<LITERALS>mangle</LITERALS>  <LITERALS>remove</LITERALS> <LITERALS>as</LITERALS> <LITERALS>many</LITERALS> <LITERALS>newlines</LITERALS> <LITERALS>as</LITERALS> <LITERALS>possible</LITERALS> (<LITERALS>but</LITERALS> <LITERALS>keep</LITERALS> <LITERALS>comments</LITERALS> <LITERALS>and</LITERALS> <LITERALS>pods</LITERALS>)
 -<LITERALS>extrude</LITERALS>  <LITERALS>insert</LITERALS> <LITERALS>as</LITERALS> <LITERALS>many</LITERALS> <LITERALS>newlines</LITERALS> <LITERALS>as</LITERALS> <LITERALS>possible</LITERALS>

<LITERALS>Dump</LITERALS> <LITERALS>and</LITERALS> <LITERALS>die</LITERALS>, <LITERALS>debugging</LITERALS>
 -<LITERALS>dop</LITERALS>    <LITERALS>dump</LITERALS> <LITERALS>options</LITERALS> <LITERALS>used</LITERALS> <LITERALS>in</LITERALS> <LITERALS>this</LITERALS> <LITERALS>run</LITERALS> <LITERALS>to</LITERALS> <LITERALS>standard</LITERALS> <LITERALS>output</LITERALS> <LITERALS>and</LITERALS> <LITERALS>quit</LITERALS>
 -<LITERALS>ddf</LITERALS>    <LITERALS>dump</LITERALS> <LITERALS>default</LITERALS> <LITERALS>options</LITERALS> <LITERALS>to</LITERALS> <LITERALS>standard</LITERALS> <LITERALS>output</LITERALS> <LITERALS>and</LITERALS> <LITERALS>quit</LITERALS>
 -<LITERALS>dsn</LITERALS>    <LITERALS>dump</LITERALS> <LITERALS>all</LITERALS> <LITERALS>option</LITERALS> <LITERALS>short</LITERALS> <LITERALS>names</LITERALS> <LITERALS>to</LITERALS> <LITERALS>standard</LITERALS> <LITERALS>output</LITERALS> <LITERALS>and</LITERALS> <LITERALS>quit</LITERALS>
 -<LITERALS>dln</LITERALS>    <LITERALS>dump</LITERALS> <LITERALS>option</LITERALS> <LITERALS>long</LITERALS> <LITERALS>names</LITERALS> <LITERALS>to</LITERALS> <LITERALS>standard</LITERALS> <LITERALS>output</LITERALS> <LITERALS>and</LITERALS> <LITERALS>quit</LITERALS>
 -<LITERALS>dpro</LITERALS>   <LITERALS>dump</LITERALS> <LITERALS>whatever</LITERALS> <LITERALS>configuration</LITERALS> <LITERALS>file</LITERALS> <LITERALS>is</LITERALS> <LITERALS>in</LITERALS> <LITERALS>effect</LITERALS> <LITERALS>to</LITERALS> <LITERALS>standard</LITERALS> <LITERALS>output</LITERALS>
 -<LITERALS>dtt</LITERALS>    <LITERALS>dump</LITERALS> <LITERALS>all</LITERALS> <LITERALS>token</LITERALS> <LITERALS>types</LITERALS> <LITERALS>to</LITERALS> <LITERALS>standard</LITERALS> <LITERALS>output</LITERALS> <LITERALS>and</LITERALS> <LITERALS>quit</LITERALS>

<LITERALS>HTML</LITERALS>
 -<LITERALS>html</LITERALS> <LITERALS>write</LITERALS> <LITERALS>an</LITERALS> <LITERALS>html</LITERALS> <LITERALS>file</LITERALS> (<LITERALS>see</LITERALS> '<LITERALS>man</LITERALS> <LITERALS>perl2web</LITERALS>' <LITERALS>for</LITERALS> <LITERALS>many</LITERALS> <LITERALS>options</LITERALS>)
       <LITERALS>Note</LITERALS>: <LITERALS>when</LITERALS> -<LITERALS>html</LITERALS> <LITERALS>is</LITERALS> <LITERALS>used</LITERALS>, <LITERALS>no</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>or</LITERALS> <LITERALS>formatting</LITERALS> <LITERALS>are</LITERALS> <LITERALS>done</LITERALS>.
       <LITERALS>Hint</LITERALS>: <LITERALS>try</LITERALS> <LITERALS>perltidy</LITERALS> -<LITERALS>html</LITERALS> -<LITERALS>css</LITERALS>=<LITERALS>mystyle</LITERALS>.<LITERALS>css</LITERALS> <LITERALS>filename</LITERALS>.<LITERALS>pl</LITERALS>
       <LITERALS>and</LITERALS> <LITERALS>edit</LITERALS> <LITERALS>mystyle</LITERALS>.<LITERALS>css</LITERALS> <LITERALS>to</LITERALS> <LITERALS>change</LITERALS> <LITERALS>the</LITERALS> <LITERALS>appearance</LITERALS> <LITERALS>of</LITERALS> <LITERALS>filename</LITERALS>.<LITERALS>html</LITERALS>.
       -<LITERALS>nnn</LITERALS> <LITERALS>gives</LITERALS> <LITERALS>line</LITERALS> <LITERALS>numbers</LITERALS>
       -<LITERALS>pre</LITERALS> <LITERALS>only</LITERALS> <LITERALS>writes</LITERALS> <LITERALS>out</LITERALS> <<LITERALS>pre</LITERALS>>..</<LITERALS>pre</LITERALS>> <LITERALS>code</LITERALS> <LITERALS>section</LITERALS>
       -<LITERALS>toc</LITERALS> <LITERALS>places</LITERALS> <LITERALS>a</LITERALS> <LITERALS>table</LITERALS> <LITERALS>of</LITERALS> <LITERALS>contents</LITERALS> <LITERALS>to</LITERALS> <LITERALS>subs</LITERALS> <LITERALS>at</LITERALS> <LITERALS>the</LITERALS> <LITERALS>top</LITERALS> (<LITERALS>default</LITERALS>)
       -<LITERALS>pod</LITERALS> <LITERALS>passes</LITERALS> <LITERALS>pod</LITERALS> <LITERALS>text</LITERALS> <LITERALS>through</LITERALS> <LITERALS>pod2html</LITERALS> (<LITERALS>default</LITERALS>)
       -<LITERALS>frm</LITERALS> <LITERALS>write</LITERALS> <LITERALS>html</LITERALS> <LITERALS>as</LITERALS> <LITERALS>a</LITERALS> <LITERALS>frame</LITERALS> (<LITERALS>3</LITERALS> <LITERALS>files</LITERALS>)
       -<LITERALS>text</LITERALS>=<LITERALS>s</LITERALS> <LITERALS>extra</LITERALS> <LITERALS>extension</LITERALS> <LITERALS>for</LITERALS> <LITERALS>table</LITERALS> <LITERALS>of</LITERALS> <LITERALS>contents</LITERALS> <LITERALS>if</LITERALS> -<LITERALS>frm</LITERALS>, <LITERALS>default</LITERALS>='<LITERALS>toc</LITERALS>'
       -<LITERALS>sext</LITERALS>=<LITERALS>s</LITERALS> <LITERALS>extra</LITERALS> <LITERALS>extension</LITERALS> <LITERALS>for</LITERALS> <LITERALS>file</LITERALS> <LITERALS>content</LITERALS> <LITERALS>if</LITERALS> -<LITERALS>frm</LITERALS>, <LITERALS>default</LITERALS>='<LITERALS>src</LITERALS>'

<LITERALS>A</LITERALS> <LITERALS>prefix</LITERALS> <LITERALS>of</LITERALS> "<LITERALS>n</LITERALS>" <LITERALS>negates</LITERALS> <LITERALS>short</LITERALS> <LITERALS>form</LITERALS> <LITERALS>toggle</LITERALS> <LITERALS>switches</LITERALS>, <LITERALS>and</LITERALS> <LITERALS>a</LITERALS> <LITERALS>prefix</LITERALS> <LITERALS>of</LITERALS> "<LITERALS>no</LITERALS>"
<LITERALS>negates</LITERALS> <LITERALS>the</LITERALS> <LITERALS>long</LITERALS> <LITERALS>forms</LITERALS>.  <LITERALS>For</LITERALS> <LITERALS>example</LITERALS>, -<LITERALS>nasc</LITERALS> <LITERALS>means</LITERALS> <LITERALS>don</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>add</LITERALS> <LITERALS>missing</LITERALS>
<LITERALS>semicolons</LITERALS>.

<LITERALS>If</LITERALS> <LITERALS>you</LITERALS> <LITERALS>are</LITERALS> <LITERALS>unable</LITERALS> <LITERALS>to</LITERALS> <LITERALS>see</LITERALS> <LITERALS>this</LITERALS> <LITERALS>entire</LITERALS> <LITERALS>text</LITERALS>, <LITERALS>try</LITERALS> "<LITERALS>perltidy</LITERALS> -<LITERALS>h</LITERALS> | <LITERALS>more</LITERALS>"
<LITERALS>For</LITERALS> <LITERALS>more</LITERALS> <LITERALS>detailed</LITERALS> <LITERALS>information</LITERALS>, <LITERALS>and</LITERALS> <LITERALS>additional</LITERALS> <LITERALS>options</LITERALS>, <LITERALS>try</LITERALS> "<LITERALS>man</LITERALS> <LITERALS>perltidy</LITERALS>",
<LITERALS>or</LITERALS> <LITERALS>go</LITERALS> <LITERALS>to</LITERALS> <LITERALS>the</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>home</LITERALS> <LITERALS>page</LITERALS> <LITERALS>at</LITERALS> <LITERALS>http</LITERALS>://<LITERALS>perltidy</LITERALS>.<LITERALS>sourceforge</LITERALS>.<LITERALS>net</LITERALS>
<CODE>EOF</CODE>

}

sub <CODE>process_this_file</CODE> {

    my ( $<CODE>truth</CODE>, $<CODE>beauty</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>process</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>file</COMMENTS>
    while ( my $<CODE>line_of_tokens</CODE> = $<CODE>truth</CODE>-><CODE>get_line</CODE>() ) {
        $<CODE>beauty</CODE>-><CODE>write_line</CODE>($<CODE>line_of_tokens</CODE>);
    }

    # <COMMENTS>finish</COMMENTS> <COMMENTS>up</COMMENTS>
    eval { $<CODE>beauty</CODE>-><CODE>finish_formatting</CODE>() };
    $<CODE>truth</CODE>-><CODE>report_tokenization_errors</CODE>();
}

sub <CODE>check_syntax</CODE> {

    # <COMMENTS>Use</COMMENTS> '<COMMENTS>perl</COMMENTS> -<COMMENTS>c</COMMENTS>' <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>did</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>syntax</COMMENTS>
    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>independent</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>programming</COMMENTS> <COMMENTS>errors</COMMENTS>
    #
    # <COMMENTS>Given</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>files</COMMENTS>, (<COMMENTS>$istream</COMMENTS>, <COMMENTS>$ostream</COMMENTS>),
    # <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>:
    # - <COMMENTS>check</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS>
    # - <COMMENTS>if</COMMENTS> <COMMENTS>bad</COMMENTS>, <COMMENTS>all</COMMENTS> <COMMENTS>done</COMMENTS> (<COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>incomplete</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>snippet</COMMENTS>)
    # - <COMMENTS>if</COMMENTS> <COMMENTS>infile</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>ok</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>file</COMMENTS>;
    #   - <COMMENTS>if</COMMENTS> <COMMENTS>outfile</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>bad</COMMENTS>, <COMMENTS>issue</COMMENTS> <COMMENTS>warning</COMMENTS>; <COMMENTS>this</COMMENTS> <COMMENTS>implies</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>bug</COMMENTS>!
    # - <COMMENTS>set</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>flag</COMMENTS> "<COMMENTS>infile_syntax_ok</COMMENTS>" : =-<COMMENTS>1</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>0</COMMENTS> <COMMENTS>unknown</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>good</COMMENTS>

    my ( $<CODE>istream</CODE>, $<CODE>ostream</CODE>, $<CODE>logger_object</CODE>, $<CODE>rOpts</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>infile_syntax_ok</CODE> = 0;
    my $<CODE>line_of_dashes</CODE>   = '-' x 42 . "\n";

    my $<CODE>flags</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>perl</LITERALS>-<LITERALS>syntax</LITERALS>-<LITERALS>check</LITERALS>-<LITERALS>flags</LITERALS>'};

    # <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>invoke</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>c</COMMENTS>
    # <COMMENTS>note</COMMENTS>: <COMMENTS>perl</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>accept</COMMENTS> <COMMENTS>repeated</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>like</COMMENTS> '-<COMMENTS>c</COMMENTS> -<COMMENTS>c</COMMENTS>'.  <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>safest</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>another</COMMENTS> -<COMMENTS>c</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>interior</COMMENTS> <COMMENTS>bundled</COMMENTS> <COMMENTS>c</COMMENTS>, <COMMENTS>as</COMMENTS>
    # <COMMENTS>in</COMMENTS> -<COMMENTS>Tc</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>c</COMMENTS>' <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>string</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>.
    if ( $<CODE>flags</CODE> !~ /(^-c|\s+-c)/ ) { $<CODE>flags</CODE> .= " -<LITERALS>c</LITERALS>" }

    # <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>invoke</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>x</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS>
    # <COMMENTS>same</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>about</COMMENTS> <COMMENTS>repeated</COMMENTS> <COMMENTS>parameters</COMMENTS> <COMMENTS>applies</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>look</LITERALS>-<LITERALS>for</LITERALS>-<LITERALS>hash</LITERALS>-<LITERALS>bang</LITERALS>'} ) {
        if ( $<CODE>flags</CODE> !~ /(^-x|\s+-x)/ ) { $<CODE>flags</CODE> .= " -<LITERALS>x</LITERALS>" }
    }

    # <COMMENTS>this</COMMENTS> <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>temporary</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>couldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>made</COMMENTS>
    if ( $<CODE>istream</CODE> eq '-' ) {
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
            "<LITERALS>Cannot</LITERALS> <LITERALS>run</LITERALS> <LITERALS>perl</LITERALS> -<LITERALS>c</LITERALS> <LITERALS>on</LITERALS> <LITERALS>STDIN</LITERALS> <LITERALS>and</LITERALS> <LITERALS>STDOUT</LITERALS>\n");
        return $<CODE>infile_syntax_ok</CODE>;
    }

    $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
        "<LITERALS>checking</LITERALS> <LITERALS>input</LITERALS> <LITERALS>file</LITERALS> <LITERALS>syntax</LITERALS> <LITERALS>with</LITERALS> <LITERALS>perl</LITERALS> $<CODE>flags</CODE>\n");

    # <COMMENTS>Not</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>operating</COMMENTS> <COMMENTS>systems</COMMENTS>/<COMMENTS>shells</COMMENTS> <COMMENTS>support</COMMENTS> <COMMENTS>redirection</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>standard</COMMENTS>
    # <COMMENTS>error</COMMENTS> <COMMENTS>output</COMMENTS>.
    my $<CODE>error_redirection</CODE> = ( $^<CODE>O</CODE> eq '<LITERALS>VMS</LITERALS>' ) ? "" : '<LITERALS>2</LITERALS>>&<LITERALS>1</LITERALS>';

    my ( $<CODE>istream_filename</CODE>, $<CODE>perl_output</CODE> ) =
      <CODE>do_syntax_check</CODE>( $<CODE>istream</CODE>, $<CODE>flags</CODE>, $<CODE>error_redirection</CODE> );
    $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
        "<LITERALS>Input</LITERALS> <LITERALS>stream</LITERALS> <LITERALS>passed</LITERALS> <LITERALS>to</LITERALS> <LITERALS>Perl</LITERALS> <LITERALS>as</LITERALS> <LITERALS>file</LITERALS> $<CODE>istream_filename</CODE>\n");
    $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>($<CODE>line_of_dashes</CODE>);
    $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>("$<CODE>perl_output</CODE>\n");

    if ( $<CODE>perl_output</CODE> =~ /syntax\s*OK/ ) {
        $<CODE>infile_syntax_ok</CODE> = 1;
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>($<CODE>line_of_dashes</CODE>);
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
            "<LITERALS>checking</LITERALS> <LITERALS>output</LITERALS> <LITERALS>file</LITERALS> <LITERALS>syntax</LITERALS> <LITERALS>with</LITERALS> <LITERALS>perl</LITERALS> $<CODE>flags</CODE> ...\n");
        my ( $<CODE>ostream_filename</CODE>, $<CODE>perl_output</CODE> ) =
          <CODE>do_syntax_check</CODE>( $<CODE>ostream</CODE>, $<CODE>flags</CODE>, $<CODE>error_redirection</CODE> );
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
            "<LITERALS>Output</LITERALS> <LITERALS>stream</LITERALS> <LITERALS>passed</LITERALS> <LITERALS>to</LITERALS> <LITERALS>Perl</LITERALS> <LITERALS>as</LITERALS> <LITERALS>file</LITERALS> $<CODE>ostream_filename</CODE>\n");
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>($<CODE>line_of_dashes</CODE>);
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>("$<CODE>perl_output</CODE>\n");

        unless ( $<CODE>perl_output</CODE> =~ /syntax\s*OK/ ) {
            $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>($<CODE>line_of_dashes</CODE>);
            $<CODE>logger_object</CODE>-><CODE>warning</CODE>(
"<LITERALS>The</LITERALS> <LITERALS>output</LITERALS> <LITERALS>file</LITERALS> <LITERALS>has</LITERALS> <LITERALS>a</LITERALS> <LITERALS>syntax</LITERALS> <LITERALS>error</LITERALS> <LITERALS>when</LITERALS> <LITERALS>tested</LITERALS> <LITERALS>with</LITERALS> <LITERALS>perl</LITERALS> $<CODE>flags</CODE> $<CODE>ostream</CODE> !\n"
            );
            $<CODE>logger_object</CODE>-><CODE>warning</CODE>(
                "<LITERALS>This</LITERALS> <LITERALS>implies</LITERALS> <LITERALS>an</LITERALS> <LITERALS>error</LITERALS> <LITERALS>in</LITERALS> <LITERALS>perltidy</LITERALS>; <LITERALS>the</LITERALS> <LITERALS>file</LITERALS> $<CODE>ostream</CODE> <LITERALS>is</LITERALS> <LITERALS>bad</LITERALS>\n"
            );
            $<CODE>logger_object</CODE>-><CODE>report_definite_bug</CODE>();

            # <COMMENTS>the</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>helpful</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>diagnosing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>problem</COMMENTS>
            $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
                qx/<LITERALS>perl</LITERALS> -<LITERALS>v</LITERALS> $<CODE>error_redirection</CODE>/ . "\n" );
        }
    }
    else {

        # <COMMENTS>Only</COMMENTS> <COMMENTS>warn</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS> -<COMMENTS>c</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>errors</COMMENTS>.  <COMMENTS>Other</COMMENTS> <COMMENTS>messages</COMMENTS>,
        # <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>missing</COMMENTS> <COMMENTS>modules</COMMENTS>, <COMMENTS>are</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>common</COMMENTS>.  <COMMENTS>They</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS>
        # <COMMENTS>seen</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>running</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>perltidy</COMMENTS> -<COMMENTS>w</COMMENTS>
        $<CODE>logger_object</CODE>-><CODE>complain</CODE>("<LITERALS>A</LITERALS> <LITERALS>syntax</LITERALS> <LITERALS>check</LITERALS> <LITERALS>using</LITERALS> <LITERALS>perl</LITERALS> $<CODE>flags</CODE>\n");
        $<CODE>logger_object</CODE>-><CODE>complain</CODE>(
            "<LITERALS>for</LITERALS> <LITERALS>the</LITERALS> <LITERALS>output</LITERALS> <LITERALS>in</LITERALS> <LITERALS>file</LITERALS> $<CODE>istream_filename</CODE> <LITERALS>gives</LITERALS>:\n");
        $<CODE>logger_object</CODE>-><CODE>complain</CODE>($<CODE>line_of_dashes</CODE>);
        $<CODE>logger_object</CODE>-><CODE>complain</CODE>("$<CODE>perl_output</CODE>\n");
        $<CODE>logger_object</CODE>-><CODE>complain</CODE>($<CODE>line_of_dashes</CODE>);
        $<CODE>infile_syntax_ok</CODE> = -1;
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>($<CODE>line_of_dashes</CODE>);
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(
"<LITERALS>The</LITERALS> <LITERALS>output</LITERALS> <LITERALS>file</LITERALS> <LITERALS>will</LITERALS> <LITERALS>not</LITERALS> <LITERALS>be</LITERALS> <LITERALS>checked</LITERALS> <LITERALS>because</LITERALS> <LITERALS>of</LITERALS> <LITERALS>input</LITERALS> <LITERALS>file</LITERALS> <LITERALS>problems</LITERALS>\n"
        );
    }
    return $<CODE>infile_syntax_ok</CODE>;
}

sub <CODE>do_syntax_check</CODE> {
    my ( $<CODE>stream</CODE>, $<CODE>flags</CODE>, $<CODE>error_redirection</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>We</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>named</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>executing</COMMENTS> <COMMENTS>perl</COMMENTS>
    my ( $<CODE>stream_filename</CODE>, $<CODE>is_tmpfile</CODE> ) = <CODE>get_stream_as_named_file</CODE>($<CODE>stream</CODE>);

    # <COMMENTS>TODO</COMMENTS>: <COMMENTS>Need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>log</COMMENTS> <COMMENTS>somewhere</COMMENTS>
    # <COMMENTS>otherwise</COMMENTS> <COMMENTS>Perl</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>hard</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>read</COMMENTS>
    if ( !$<CODE>stream_filename</CODE> ) { return $<CODE>stream_filename</CODE>, "" }

    # <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>filename</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>unusual</COMMENTS> <COMMENTS>characters</COMMENTS>
    # <COMMENTS>or</COMMENTS> <COMMENTS>spaces</COMMENTS>.  <COMMENTS>Example</COMMENTS>: <COMMENTS>this</COMMENTS> <COMMENTS>filename</COMMENTS> #<COMMENTS>CM11</COMMENTS>.<COMMENTS>pm</COMMENTS># <COMMENTS>gives</COMMENTS> <COMMENTS>trouble</COMMENTS>.
    my $<CODE>quoted_stream_filename</CODE> = '"' . $<CODE>stream_filename</CODE> . '"';

    # <COMMENTS>Under</COMMENTS> <COMMENTS>VMS</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> -<COMMENTS>T</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>become</COMMENTS> -<COMMENTS>t</COMMENTS> (<COMMENTS>and</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS>) <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS>
    # <COMMENTS>will</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>quotes</COMMENTS> <COMMENTS>around</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>flags</COMMENTS>.  <COMMENTS>Double</COMMENTS> <COMMENTS>quotes</COMMENTS> <COMMENTS>seem</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>on</COMMENTS>
    # <COMMENTS>Unix</COMMENTS>/<COMMENTS>Windows</COMMENTS>/<COMMENTS>VMS</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>systems</COMMENTS>.  (<COMMENTS>Single</COMMENTS>
    # <COMMENTS>quotes</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>under</COMMENTS> <COMMENTS>Windows</COMMENTS>).  <COMMENTS>It</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>become</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS>
    # <COMMENTS>put</COMMENTS> <COMMENTS>double</COMMENTS> <COMMENTS>quotes</COMMENTS> <COMMENTS>around</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>flag</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS>:  -"<COMMENTS>c</COMMENTS>"  -"<COMMENTS>T</COMMENTS>"
    # <COMMENTS>We</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>eventually</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>system</COMMENTS>-<COMMENTS>dependent</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>here</COMMENTS>.
    $<CODE>flags</CODE> = '"' . $<CODE>flags</CODE> . '"';

    # <COMMENTS>now</COMMENTS> <COMMENTS>wish</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>luck</COMMENTS>...
    my $<CODE>msg</CODE> = qx/<LITERALS>perl</LITERALS> $<CODE>flags</CODE> $<CODE>quoted_stream_filename</CODE> $<CODE>error_redirection</CODE>/;

    unlink $<CODE>stream_filename</CODE> if ($<CODE>is_tmpfile</CODE>);
    return $<CODE>stream_filename</CODE>, $<CODE>msg</CODE>;
}

#####################################################################
#
# <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>stripped</COMMENTS> <COMMENTS>down</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>IO</COMMENTS>::<COMMENTS>Scalar</COMMENTS>
# <COMMENTS>Given</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>scalar</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>supplies</COMMENTS> <COMMENTS>either</COMMENTS>:
# <COMMENTS>a</COMMENTS> <COMMENTS>getline</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>reads</COMMENTS> <COMMENTS>lines</COMMENTS> (<COMMENTS>mode</COMMENTS>='<COMMENTS>r</COMMENTS>'), <COMMENTS>or</COMMENTS>
# <COMMENTS>a</COMMENTS> <COMMENTS>print</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>reads</COMMENTS> <COMMENTS>lines</COMMENTS> (<COMMENTS>mode</COMMENTS>='<COMMENTS>w</COMMENTS>')
#
#####################################################################
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IOScalar</CODE>;
use <CODE>Carp</CODE>;

sub <CODE>new</CODE> {
    my ( $<CODE>package</CODE>, $<CODE>rscalar</CODE>, $<CODE>mode</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>ref</CODE> = ref $<CODE>rscalar</CODE>;
    if ( $<CODE>ref</CODE> ne '<LITERALS>SCALAR</LITERALS>' ) {
        <CODE>confess</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>expecting</LITERALS> <LITERALS>ref</LITERALS> <LITERALS>to</LITERALS> <LITERALS>SCALAR</LITERALS> <LITERALS>but</LITERALS> <LITERALS>got</LITERALS> <LITERALS>ref</LITERALS> <LITERALS>to</LITERALS> ($<CODE>ref</CODE>); <LITERALS>trace</LITERALS> <LITERALS>follows</LITERALS>:
------------------------------------------------------------------------
<CODE>EOM</CODE>

    }
    if ( $<CODE>mode</CODE> eq '<LITERALS>w</LITERALS>' ) {
        $$<CODE>rscalar</CODE> = "";
        return bless [ $<CODE>rscalar</CODE>, $<CODE>mode</CODE> ], $<CODE>package</CODE>;
    }
    elsif ( $<CODE>mode</CODE> eq '<LITERALS>r</LITERALS>' ) {

        # <COMMENTS>Convert</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>scalar</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>array</COMMENTS>.
        # <COMMENTS>This</COMMENTS> <COMMENTS>avoids</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> "\<COMMENTS>n</COMMENTS>" <COMMENTS>on</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>getline</COMMENTS>
        #
        # <COMMENTS>NOTES</COMMENTS>: <COMMENTS>The</COMMENTS> -<COMMENTS>1</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>loss</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>lines</COMMENTS>
        # (<COMMENTS>which</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>important</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>DATA</COMMENTS> <COMMENTS>section</COMMENTS>).
        my @<CODE>array</CODE>;
        if ( $<CODE>rscalar</CODE> && ${$<CODE>rscalar</CODE>} ) {
            @<CODE>array</CODE> = map { $<CODE>_</CODE> .= "\n" } split /\n/, ${$<CODE>rscalar</CODE>}, -1;

            # <COMMENTS>remove</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>introduced</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>split</COMMENTS>
            if ( @<CODE>array</CODE> && $<CODE>array</CODE>[-1] eq "\n" ) { pop @<CODE>array</CODE> }
        }
        my $<CODE>i_next</CODE> = 0;
        return bless [ \@<CODE>array</CODE>, $<CODE>mode</CODE>, $<CODE>i_next</CODE> ], $<CODE>package</CODE>;
    }
    else {
        <CODE>confess</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>expecting</LITERALS> <LITERALS>mode</LITERALS> = '<LITERALS>r</LITERALS>' <LITERALS>or</LITERALS> '<LITERALS>w</LITERALS>' <LITERALS>but</LITERALS> <LITERALS>got</LITERALS> <LITERALS>mode</LITERALS> ($<CODE>mode</CODE>); <LITERALS>trace</LITERALS> <LITERALS>follows</LITERALS>:
------------------------------------------------------------------------
<CODE>EOM</CODE>
    }
}

sub <CODE>getline</CODE> {
    my $<CODE>self</CODE> = shift;
    my $<CODE>mode</CODE> = $<CODE>self</CODE>->[1];
    if ( $<CODE>mode</CODE> ne '<LITERALS>r</LITERALS>' ) {
        <CODE>confess</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>getline</LITERALS> <LITERALS>call</LITERALS> <LITERALS>requires</LITERALS> <LITERALS>mode</LITERALS> = '<LITERALS>r</LITERALS>' <LITERALS>but</LITERALS> <LITERALS>mode</LITERALS> = ($<CODE>mode</CODE>); <LITERALS>trace</LITERALS> <LITERALS>follows</LITERALS>:
------------------------------------------------------------------------
<CODE>EOM</CODE>
    }
    my $<CODE>i</CODE> = $<CODE>self</CODE>->[2]++;
    return $<CODE>self</CODE>->[0]->[$<CODE>i</CODE>];
}

sub <CODE>print</CODE> {
    my $<CODE>self</CODE> = shift;
    my $<CODE>mode</CODE> = $<CODE>self</CODE>->[1];
    if ( $<CODE>mode</CODE> ne '<LITERALS>w</LITERALS>' ) {
        <CODE>confess</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>print</LITERALS> <LITERALS>call</LITERALS> <LITERALS>requires</LITERALS> <LITERALS>mode</LITERALS> = '<LITERALS>w</LITERALS>' <LITERALS>but</LITERALS> <LITERALS>mode</LITERALS> = ($<CODE>mode</CODE>); <LITERALS>trace</LITERALS> <LITERALS>follows</LITERALS>:
------------------------------------------------------------------------
<CODE>EOM</CODE>
    }
    ${ $<CODE>self</CODE>->[0] } .= $<CODE>_</CODE>[0];
}
sub <CODE>close</CODE> { return }

#####################################################################
#
# <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>stripped</COMMENTS> <COMMENTS>down</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>IO</COMMENTS>::<COMMENTS>ScalarArray</COMMENTS>
# <COMMENTS>Given</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>array</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>supplies</COMMENTS> <COMMENTS>either</COMMENTS>:
# <COMMENTS>a</COMMENTS> <COMMENTS>getline</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>reads</COMMENTS> <COMMENTS>lines</COMMENTS> (<COMMENTS>mode</COMMENTS>='<COMMENTS>r</COMMENTS>'), <COMMENTS>or</COMMENTS>
# <COMMENTS>a</COMMENTS> <COMMENTS>print</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>reads</COMMENTS> <COMMENTS>lines</COMMENTS> (<COMMENTS>mode</COMMENTS>='<COMMENTS>w</COMMENTS>')
#
# <COMMENTS>NOTE</COMMENTS>: <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>assumes</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>aren</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>embedded</COMMENTS>
# <COMMENTS>newlines</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>elements</COMMENTS>.  <COMMENTS>There</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>checks</COMMENTS>
# <COMMENTS>for</COMMENTS> <COMMENTS>that</COMMENTS>.
#
#####################################################################
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IOScalarArray</CODE>;
use <CODE>Carp</CODE>;

sub <CODE>new</CODE> {
    my ( $<CODE>package</CODE>, $<CODE>rarray</CODE>, $<CODE>mode</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>ref</CODE> = ref $<CODE>rarray</CODE>;
    if ( $<CODE>ref</CODE> ne '<LITERALS>ARRAY</LITERALS>' ) {
        <CODE>confess</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>expecting</LITERALS> <LITERALS>ref</LITERALS> <LITERALS>to</LITERALS> <LITERALS>ARRAY</LITERALS> <LITERALS>but</LITERALS> <LITERALS>got</LITERALS> <LITERALS>ref</LITERALS> <LITERALS>to</LITERALS> ($<CODE>ref</CODE>); <LITERALS>trace</LITERALS> <LITERALS>follows</LITERALS>:
------------------------------------------------------------------------
<CODE>EOM</CODE>

    }
    if ( $<CODE>mode</CODE> eq '<LITERALS>w</LITERALS>' ) {
        @$<CODE>rarray</CODE> = ();
        return bless [ $<CODE>rarray</CODE>, $<CODE>mode</CODE> ], $<CODE>package</CODE>;
    }
    elsif ( $<CODE>mode</CODE> eq '<LITERALS>r</LITERALS>' ) {
        my $<CODE>i_next</CODE> = 0;
        return bless [ $<CODE>rarray</CODE>, $<CODE>mode</CODE>, $<CODE>i_next</CODE> ], $<CODE>package</CODE>;
    }
    else {
        <CODE>confess</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>expecting</LITERALS> <LITERALS>mode</LITERALS> = '<LITERALS>r</LITERALS>' <LITERALS>or</LITERALS> '<LITERALS>w</LITERALS>' <LITERALS>but</LITERALS> <LITERALS>got</LITERALS> <LITERALS>mode</LITERALS> ($<CODE>mode</CODE>); <LITERALS>trace</LITERALS> <LITERALS>follows</LITERALS>:
------------------------------------------------------------------------
<CODE>EOM</CODE>
    }
}

sub <CODE>getline</CODE> {
    my $<CODE>self</CODE> = shift;
    my $<CODE>mode</CODE> = $<CODE>self</CODE>->[1];
    if ( $<CODE>mode</CODE> ne '<LITERALS>r</LITERALS>' ) {
        <CODE>confess</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>getline</LITERALS> <LITERALS>requires</LITERALS> <LITERALS>mode</LITERALS> = '<LITERALS>r</LITERALS>' <LITERALS>but</LITERALS> <LITERALS>mode</LITERALS> = ($<CODE>mode</CODE>); <LITERALS>trace</LITERALS> <LITERALS>follows</LITERALS>:
------------------------------------------------------------------------
<CODE>EOM</CODE>
    }
    my $<CODE>i</CODE> = $<CODE>self</CODE>->[2]++;
    return $<CODE>self</CODE>->[0]->[$<CODE>i</CODE>];
}

sub <CODE>print</CODE> {
    my $<CODE>self</CODE> = shift;
    my $<CODE>mode</CODE> = $<CODE>self</CODE>->[1];
    if ( $<CODE>mode</CODE> ne '<LITERALS>w</LITERALS>' ) {
        <CODE>confess</CODE> <<<LITERALS>EOM</LITERALS>;
------------------------------------------------------------------------
<LITERALS>print</LITERALS> <LITERALS>requires</LITERALS> <LITERALS>mode</LITERALS> = '<LITERALS>w</LITERALS>' <LITERALS>but</LITERALS> <LITERALS>mode</LITERALS> = ($<CODE>mode</CODE>); <LITERALS>trace</LITERALS> <LITERALS>follows</LITERALS>:
------------------------------------------------------------------------
<CODE>EOM</CODE>
    }
    push @{ $<CODE>self</CODE>->[0] }, $<CODE>_</CODE>[0];
}
sub <CODE>close</CODE> { return }

#####################################################################
#
# <COMMENTS>the</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>LineSource</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>supplies</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>get_line</COMMENTS>()' <COMMENTS>method</COMMENTS>
# <COMMENTS>which</COMMENTS> <COMMENTS>returns</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>parsed</COMMENTS>
#
#####################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSource</CODE>;

sub <CODE>new</CODE> {

    my ( $<CODE>class</CODE>, $<CODE>input_file</CODE>, $<CODE>rOpts</CODE>, $<CODE>rpending_logfile_message</CODE> ) = @<CODE>_</CODE>;

    my $<CODE>input_line_ending</CODE>;
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>preserve</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>endings</LITERALS>'} ) {
        $<CODE>input_line_ending</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>find_input_line_ending</CODE>($<CODE>input_file</CODE>);
    }

    ( my $<CODE>fh</CODE>, $<CODE>input_file</CODE> ) = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>streamhandle</CODE>( $<CODE>input_file</CODE>, '<LITERALS>r</LITERALS>' );
    return undef unless $<CODE>fh</CODE>;

    # <COMMENTS>in</COMMENTS> <COMMENTS>order</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>,
    # <COMMENTS>or</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>copy</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>file</COMMENTS>
    if ( ( $<CODE>input_file</CODE> eq '-' || ref $<CODE>input_file</CODE> ) && $<CODE>rOpts</CODE>->{'<LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>'} )
    {

        # <COMMENTS>Turning</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>.
        # <COMMENTS>The</COMMENTS> <COMMENTS>reason</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>temporary</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>on</COMMENTS>
        # <COMMENTS>on</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>systems</COMMENTS>.
        $<CODE>rOpts</CODE>->{'<LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>'} = 0;

        $$<CODE>rpending_logfile_message</CODE> .= <<<LITERALS>EOM</LITERALS>;
<LITERALS>Note</LITERALS>: --<LITERALS>syntax</LITERALS> <LITERALS>check</LITERALS> <LITERALS>will</LITERALS> <LITERALS>be</LITERALS> <LITERALS>skipped</LITERALS> <LITERALS>because</LITERALS> <LITERALS>standard</LITERALS> <LITERALS>input</LITERALS> <LITERALS>is</LITERALS> <LITERALS>used</LITERALS>
<CODE>EOM</CODE>

    }

    return bless {
        <LITERALS>_fh</LITERALS>                => $<CODE>fh</CODE>,
        <LITERALS>_filename</LITERALS>          => $<CODE>input_file</CODE>,
        <LITERALS>_input_line_ending</LITERALS> => $<CODE>input_line_ending</CODE>,
        <LITERALS>_rinput_buffer</LITERALS>     => [],
        <LITERALS>_started</LITERALS>           => 0,
    }, $<CODE>class</CODE>;
}

sub <CODE>close_input_file</CODE> {
    my $<CODE>self</CODE> = shift;

    # <COMMENTS>Only</COMMENTS> <COMMENTS>close</COMMENTS> <COMMENTS>physical</COMMENTS> <COMMENTS>files</COMMENTS>, <COMMENTS>not</COMMENTS> <COMMENTS>STDIN</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>objects</COMMENTS>
    my $<CODE>filename</CODE> = $<CODE>self</CODE>->{<LITERALS>_filename</LITERALS>};
    if ( $<CODE>filename</CODE> ne '-' && !ref $<CODE>filename</CODE> ) {
        eval { $<CODE>self</CODE>->{<LITERALS>_fh</LITERALS>}-><CODE>close</CODE>() };
    }
}

sub <CODE>get_line</CODE> {
    my $<CODE>self</CODE>          = shift;
    my $<CODE>line</CODE>          = undef;
    my $<CODE>fh</CODE>            = $<CODE>self</CODE>->{<LITERALS>_fh</LITERALS>};
    my $<CODE>rinput_buffer</CODE> = $<CODE>self</CODE>->{<LITERALS>_rinput_buffer</LITERALS>};

    if ( scalar(@$<CODE>rinput_buffer</CODE>) ) {
        $<CODE>line</CODE> = shift @$<CODE>rinput_buffer</CODE>;
    }
    else {
        $<CODE>line</CODE> = $<CODE>fh</CODE>-><CODE>getline</CODE>();

        # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>read</COMMENTS> <COMMENTS>raw</COMMENTS> <COMMENTS>mac</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>under</COMMENTS> <COMMENTS>unix</COMMENTS>, <COMMENTS>dos</COMMENTS>
        # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>embedded</COMMENTS> \<COMMENTS>r</COMMENTS>'<COMMENTS>s</COMMENTS>
        if ( $<CODE>line</CODE> && !$<CODE>self</CODE>->{<LITERALS>_started</LITERALS>} ) {
            if ( $<CODE>line</CODE> =~ /[\015][^\015\012]/ ) {

                # <COMMENTS>found</COMMENTS> <COMMENTS>one</COMMENTS> -- <COMMENTS>break</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>store</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>buffer</COMMENTS>
                @$<CODE>rinput_buffer</CODE> = map { $<CODE>_</CODE> . "\n" } split /\015/, $<CODE>line</CODE>;
                my $<CODE>count</CODE> = @$<CODE>rinput_buffer</CODE>;
                $<CODE>line</CODE> = shift @$<CODE>rinput_buffer</CODE>;
            }
            $<CODE>self</CODE>->{<LITERALS>_started</LITERALS>}++;
        }
    }
    return $<CODE>line</CODE>;
}

#####################################################################
#
# <COMMENTS>the</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>LineSink</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>supplies</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>write_line</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>for</COMMENTS>
# <COMMENTS>actual</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>writing</COMMENTS>
#
#####################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSink</CODE>;

sub <CODE>new</CODE> {

    my ( $<CODE>class</CODE>, $<CODE>output_file</CODE>, $<CODE>tee_file</CODE>, $<CODE>line_separator</CODE>, $<CODE>rOpts</CODE>,
        $<CODE>rpending_logfile_message</CODE>, $<CODE>binmode</CODE> )
      = @<CODE>_</CODE>;
    my $<CODE>fh</CODE>     = undef;
    my $<CODE>fh_tee</CODE> = undef;

    my $<CODE>output_file_open</CODE> = 0;

    if ( $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>'} eq '<LITERALS>tidy</LITERALS>' ) {
        ( $<CODE>fh</CODE>, $<CODE>output_file</CODE> ) = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>streamhandle</CODE>( $<CODE>output_file</CODE>, '<LITERALS>w</LITERALS>' );
        unless ($<CODE>fh</CODE>) { <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE> "<LITERALS>Cannot</LITERALS> <LITERALS>write</LITERALS> <LITERALS>to</LITERALS> <LITERALS>output</LITERALS> <LITERALS>stream</LITERALS>\n"; }
        $<CODE>output_file_open</CODE> = 1;
        if ($<CODE>binmode</CODE>) {
            if ( ref($<CODE>fh</CODE>) eq '<LITERALS>IO</LITERALS>::<LITERALS>File</LITERALS>' ) {
                if (   $<CODE>rOpts</CODE>->{'<LITERALS>character</LITERALS>-<LITERALS>encoding</LITERALS>'}
                    && $<CODE>rOpts</CODE>->{'<LITERALS>character</LITERALS>-<LITERALS>encoding</LITERALS>'} eq '<LITERALS>utf8</LITERALS>' )
                {
                    binmode $<CODE>fh</CODE>, ":<LITERALS>encoding</LITERALS>(<LITERALS>UTF</LITERALS>-<LITERALS>8</LITERALS>)";
                }
                else { binmode $<CODE>fh</CODE> }
            }
            if ( $<CODE>output_file</CODE> eq '-' ) { binmode <CODE>STDOUT</CODE> }
        }
    }

    # <COMMENTS>in</COMMENTS> <COMMENTS>order</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>,
    # <COMMENTS>or</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>copy</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>file</COMMENTS>
    if ( $<CODE>output_file</CODE> eq '-' || ref $<CODE>output_file</CODE> ) {
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>'} ) {

            # <COMMENTS>Turning</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>.
            # <COMMENTS>The</COMMENTS> <COMMENTS>reason</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>temporary</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>on</COMMENTS>
            # <COMMENTS>on</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>systems</COMMENTS>.
            $<CODE>rOpts</CODE>->{'<LITERALS>check</LITERALS>-<LITERALS>syntax</LITERALS>'} = 0;
            $$<CODE>rpending_logfile_message</CODE> .= <<<LITERALS>EOM</LITERALS>;
<LITERALS>Note</LITERALS>: --<LITERALS>syntax</LITERALS> <LITERALS>check</LITERALS> <LITERALS>will</LITERALS> <LITERALS>be</LITERALS> <LITERALS>skipped</LITERALS> <LITERALS>because</LITERALS> <LITERALS>standard</LITERALS> <LITERALS>output</LITERALS> <LITERALS>is</LITERALS> <LITERALS>used</LITERALS>
<CODE>EOM</CODE>

        }
    }

    bless {
        <LITERALS>_fh</LITERALS>               => $<CODE>fh</CODE>,
        <LITERALS>_fh_tee</LITERALS>           => $<CODE>fh_tee</CODE>,
        <LITERALS>_output_file</LITERALS>      => $<CODE>output_file</CODE>,
        <LITERALS>_output_file_open</LITERALS> => $<CODE>output_file_open</CODE>,
        <LITERALS>_tee_flag</LITERALS>         => 0,
        <LITERALS>_tee_file</LITERALS>         => $<CODE>tee_file</CODE>,
        <LITERALS>_tee_file_opened</LITERALS>  => 0,
        <LITERALS>_line_separator</LITERALS>   => $<CODE>line_separator</CODE>,
        <LITERALS>_binmode</LITERALS>          => $<CODE>binmode</CODE>,
    }, $<CODE>class</CODE>;
}

sub <CODE>write_line</CODE> {

    my $<CODE>self</CODE> = shift;
    my $<CODE>fh</CODE>   = $<CODE>self</CODE>->{<LITERALS>_fh</LITERALS>};

    my $<CODE>output_file_open</CODE> = $<CODE>self</CODE>->{<LITERALS>_output_file_open</LITERALS>};
    chomp $<CODE>_</CODE>[0];
    $<CODE>_</CODE>[0] .= $<CODE>self</CODE>->{<LITERALS>_line_separator</LITERALS>};

    $<CODE>fh</CODE>-><CODE>print</CODE>( $<CODE>_</CODE>[0] ) if ( $<CODE>self</CODE>->{<LITERALS>_output_file_open</LITERALS>} );

    if ( $<CODE>self</CODE>->{<LITERALS>_tee_flag</LITERALS>} ) {
        unless ( $<CODE>self</CODE>->{<LITERALS>_tee_file_opened</LITERALS>} ) { $<CODE>self</CODE>-><CODE>really_open_tee_file</CODE>() }
        my $<CODE>fh_tee</CODE> = $<CODE>self</CODE>->{<LITERALS>_fh_tee</LITERALS>};
        print $<CODE>fh_tee</CODE> $<CODE>_</CODE>[0];
    }
}

sub <CODE>tee_on</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>->{<LITERALS>_tee_flag</LITERALS>} = 1;
}

sub <CODE>tee_off</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>->{<LITERALS>_tee_flag</LITERALS>} = 0;
}

sub <CODE>really_open_tee_file</CODE> {
    my $<CODE>self</CODE>     = shift;
    my $<CODE>tee_file</CODE> = $<CODE>self</CODE>->{<LITERALS>_tee_file</LITERALS>};
    my $<CODE>fh_tee</CODE>;
    $<CODE>fh_tee</CODE> = <CODE>IO</CODE>::<CODE>File</CODE>-><CODE>new</CODE>(">$<CODE>tee_file</CODE>")
      or <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE>("<LITERALS>couldn</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>open</LITERALS> <LITERALS>TEE</LITERALS> <LITERALS>file</LITERALS> $<CODE>tee_file</CODE>: $!\n");
    binmode $<CODE>fh_tee</CODE> if $<CODE>self</CODE>->{<LITERALS>_binmode</LITERALS>};
    $<CODE>self</CODE>->{<LITERALS>_tee_file_opened</LITERALS>} = 1;
    $<CODE>self</CODE>->{<LITERALS>_fh_tee</LITERALS>}          = $<CODE>fh_tee</CODE>;
}

sub <CODE>close_output_file</CODE> {
    my $<CODE>self</CODE> = shift;

    # <COMMENTS>Only</COMMENTS> <COMMENTS>close</COMMENTS> <COMMENTS>physical</COMMENTS> <COMMENTS>files</COMMENTS>, <COMMENTS>not</COMMENTS> <COMMENTS>STDOUT</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>objects</COMMENTS>
    my $<CODE>output_file</CODE> = $<CODE>self</CODE>->{<LITERALS>_output_file</LITERALS>};
    if ( $<CODE>output_file</CODE> ne '-' && !ref $<CODE>output_file</CODE> ) {
        eval { $<CODE>self</CODE>->{<LITERALS>_fh</LITERALS>}-><CODE>close</CODE>() } if $<CODE>self</CODE>->{<LITERALS>_output_file_open</LITERALS>};
    }
    $<CODE>self</CODE>-><CODE>close_tee_file</CODE>();
}

sub <CODE>close_tee_file</CODE> {
    my $<CODE>self</CODE> = shift;

    # <COMMENTS>Only</COMMENTS> <COMMENTS>close</COMMENTS> <COMMENTS>physical</COMMENTS> <COMMENTS>files</COMMENTS>, <COMMENTS>not</COMMENTS> <COMMENTS>STDOUT</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>objects</COMMENTS>
    if ( $<CODE>self</CODE>->{<LITERALS>_tee_file_opened</LITERALS>} ) {
        my $<CODE>tee_file</CODE> = $<CODE>self</CODE>->{<LITERALS>_tee_file</LITERALS>};
        if ( $<CODE>tee_file</CODE> ne '-' && !ref $<CODE>tee_file</CODE> ) {
            eval { $<CODE>self</CODE>->{<LITERALS>_fh_tee</LITERALS>}-><CODE>close</CODE>() };
            $<CODE>self</CODE>->{<LITERALS>_tee_file_opened</LITERALS>} = 0;
        }
    }
}

#####################################################################
#
# <COMMENTS>The</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Diagnostics</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>writes</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>DIAGNOSTICS</COMMENTS> <COMMENTS>file</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS>
# <COMMENTS>useful</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>program</COMMENTS> <COMMENTS>development</COMMENTS>.
#
# <COMMENTS>Only</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>created</COMMENTS> <COMMENTS>regardless</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>input</COMMENTS>
# <COMMENTS>files</COMMENTS> <COMMENTS>processed</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>allows</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>results</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>processing</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>files</COMMENTS>
# <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>summarized</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>file</COMMENTS>.
#
#####################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Diagnostics</CODE>;

sub <CODE>new</CODE> {

    my $<CODE>class</CODE> = shift;
    bless {
        <LITERALS>_write_diagnostics_count</LITERALS> => 0,
        <LITERALS>_last_diagnostic_file</LITERALS>    => "",
        <LITERALS>_input_file</LITERALS>              => "",
        <LITERALS>_fh</LITERALS>                      => undef,
    }, $<CODE>class</CODE>;
}

sub <CODE>set_input_file</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>->{<LITERALS>_input_file</LITERALS>} = $<CODE>_</CODE>[0];
}

# <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>diagnostic</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>useful</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>program</COMMENTS> <COMMENTS>development</COMMENTS>.
# <COMMENTS>Output</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>debug</COMMENTS> <COMMENTS>messages</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>named</COMMENTS> <COMMENTS>DIAGNOSTICS</COMMENTS>, <COMMENTS>where</COMMENTS>
# <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>labeled</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>allows</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS>
# <COMMENTS>scanned</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>once</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>particular</COMMENTS> <COMMENTS>condition</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>interest</COMMENTS>.
sub <CODE>write_diagnostics</CODE> {
    my $<CODE>self</CODE> = shift;

    unless ( $<CODE>self</CODE>->{<LITERALS>_write_diagnostics_count</LITERALS>} ) {
        open <CODE>DIAGNOSTICS</CODE>, "><LITERALS>DIAGNOSTICS</LITERALS>"
          or <CODE>death</CODE>("<LITERALS>couldn</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>open</LITERALS> <LITERALS>DIAGNOSTICS</LITERALS>: $!\n");
    }

    my $<CODE>last_diagnostic_file</CODE> = $<CODE>self</CODE>->{<LITERALS>_last_diagnostic_file</LITERALS>};
    my $<CODE>input_file</CODE>           = $<CODE>self</CODE>->{<LITERALS>_input_file</LITERALS>};
    if ( $<CODE>last_diagnostic_file</CODE> ne $<CODE>input_file</CODE> ) {
        print <CODE>DIAGNOSTICS</CODE> "\n<LITERALS>FILE</LITERALS>:$<CODE>input_file</CODE>\n";
    }
    $<CODE>self</CODE>->{<LITERALS>_last_diagnostic_file</LITERALS>} = $<CODE>input_file</CODE>;
    my $<CODE>input_line_number</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Tokenizer</CODE>::<CODE>get_input_line_number</CODE>();
    print <CODE>DIAGNOSTICS</CODE> "$<CODE>input_line_number</CODE>:\t@<CODE>_</CODE>";
    $<CODE>self</CODE>->{<LITERALS>_write_diagnostics_count</LITERALS>}++;
}

#####################################################################
#
# <COMMENTS>The</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Logger</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>writes</COMMENTS> <COMMENTS>the</COMMENTS> .<COMMENTS>LOG</COMMENTS> <COMMENTS>and</COMMENTS> .<COMMENTS>ERR</COMMENTS> <COMMENTS>files</COMMENTS>
#
#####################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Logger</CODE>;

sub <CODE>new</CODE> {
    my $<CODE>class</CODE> = shift;
    my $<CODE>fh</CODE>;
    my ( $<CODE>rOpts</CODE>, $<CODE>log_file</CODE>, $<CODE>warning_file</CODE>, $<CODE>fh_stderr</CODE>, $<CODE>saw_extrude</CODE>, ) = @<CODE>_</CODE>;

    my $<CODE>fh_warnings</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>standard</LITERALS>-<LITERALS>error</LITERALS>-<LITERALS>output</LITERALS>'} ? $<CODE>fh_stderr</CODE> : undef;

    # <COMMENTS>remove</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>one</COMMENTS>
    unless ( $<CODE>fh_warnings</CODE> || ref($<CODE>warning_file</CODE>) ) {
        if ( -e $<CODE>warning_file</CODE> ) { unlink($<CODE>warning_file</CODE>) }
    }

    my $<CODE>logfile_gap</CODE> =
      defined( $<CODE>rOpts</CODE>->{'<LITERALS>logfile</LITERALS>-<LITERALS>gap</LITERALS>'} )
      ? $<CODE>rOpts</CODE>->{'<LITERALS>logfile</LITERALS>-<LITERALS>gap</LITERALS>'}
      : 50;
    if ( $<CODE>logfile_gap</CODE> == 0 ) { $<CODE>logfile_gap</CODE> = 1 }

    bless {
        <LITERALS>_log_file</LITERALS>                      => $<CODE>log_file</CODE>,
        <LITERALS>_logfile_gap</LITERALS>                   => $<CODE>logfile_gap</CODE>,
        <LITERALS>_rOpts</LITERALS>                         => $<CODE>rOpts</CODE>,
        <LITERALS>_fh_warnings</LITERALS>                   => $<CODE>fh_warnings</CODE>,
        <LITERALS>_last_input_line_written</LITERALS>       => 0,
        <LITERALS>_at_end_of_file</LITERALS>                => 0,
        <LITERALS>_use_prefix</LITERALS>                    => 1,
        <LITERALS>_block_log_output</LITERALS>              => 0,
        <LITERALS>_line_of_tokens</LITERALS>                => undef,
        <LITERALS>_output_line_number</LITERALS>            => undef,
        <LITERALS>_wrote_line_information_string</LITERALS> => 0,
        <LITERALS>_wrote_column_headings</LITERALS>         => 0,
        <LITERALS>_warning_file</LITERALS>                  => $<CODE>warning_file</CODE>,
        <LITERALS>_warning_count</LITERALS>                 => 0,
        <LITERALS>_complaint_count</LITERALS>               => 0,
        <LITERALS>_saw_code_bug</LITERALS>    => -1,             # -<COMMENTS>1</COMMENTS>=<COMMENTS>no</COMMENTS> <COMMENTS>0</COMMENTS>=<COMMENTS>maybe</COMMENTS> <COMMENTS>1</COMMENTS>=<COMMENTS>for</COMMENTS> <COMMENTS>sure</COMMENTS>
        <LITERALS>_saw_brace_error</LITERALS> => 0,
        <LITERALS>_saw_extrude</LITERALS>     => $<CODE>saw_extrude</CODE>,
        <LITERALS>_output_array</LITERALS>    => [],
    }, $<CODE>class</CODE>;
}

sub <CODE>get_warning_count</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->{<LITERALS>_warning_count</LITERALS>};
}

sub <CODE>get_use_prefix</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->{<LITERALS>_use_prefix</LITERALS>};
}

sub <CODE>block_log_output</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>->{<LITERALS>_block_log_output</LITERALS>} = 1;
}

sub <CODE>unblock_log_output</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>->{<LITERALS>_block_log_output</LITERALS>} = 0;
}

sub <CODE>interrupt_logfile</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>->{<LITERALS>_use_prefix</LITERALS>} = 0;
    $<CODE>self</CODE>-><CODE>warning</CODE>("\n");
    $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>( '#' x 24 . "  <LITERALS>WARNING</LITERALS>  " . '#' x 25 . "\n" );
}

sub <CODE>resume_logfile</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>( '#' x 60 . "\n" );
    $<CODE>self</CODE>->{<LITERALS>_use_prefix</LITERALS>} = 1;
}

sub <CODE>we_are_at_the_last_line</CODE> {
    my $<CODE>self</CODE> = shift;
    unless ( $<CODE>self</CODE>->{<LITERALS>_wrote_line_information_string</LITERALS>} ) {
        $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>("<LITERALS>Last</LITERALS> <LITERALS>line</LITERALS>\n\n");
    }
    $<CODE>self</CODE>->{<LITERALS>_at_end_of_file</LITERALS>} = 1;
}

# <COMMENTS>record</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>stuff</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>down</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>flames</COMMENTS>
sub <CODE>black_box</CODE> {
    my $<CODE>self</CODE> = shift;
    my ( $<CODE>line_of_tokens</CODE>, $<CODE>output_line_number</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>input_line</CODE>        = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_text</LITERALS>};
    my $<CODE>input_line_number</CODE> = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_number</LITERALS>};

    # <COMMENTS>save</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>information</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>logfile</COMMENTS> <COMMENTS>message</COMMENTS>
    $<CODE>self</CODE>->{<LITERALS>_line_of_tokens</LITERALS>}                = $<CODE>line_of_tokens</CODE>;
    $<CODE>self</CODE>->{<LITERALS>_output_line_number</LITERALS>}            = $<CODE>output_line_number</CODE>;
    $<CODE>self</CODE>->{<LITERALS>_wrote_line_information_string</LITERALS>} = 0;

    my $<CODE>last_input_line_written</CODE> = $<CODE>self</CODE>->{<LITERALS>_last_input_line_written</LITERALS>};
    my $<CODE>rOpts</CODE>                   = $<CODE>self</CODE>->{<LITERALS>_rOpts</LITERALS>};
    if (
        (
            ( $<CODE>input_line_number</CODE> - $<CODE>last_input_line_written</CODE> ) >=
            $<CODE>self</CODE>->{<LITERALS>_logfile_gap</LITERALS>}
        )
        || ( $<CODE>input_line</CODE> =~ /^\s*(sub|package)\s+(\w+)/ )
      )
    {
        my $<CODE>rlevels</CODE>                      = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rlevels</LITERALS>};
        my $<CODE>structural_indentation_level</CODE> = $$<CODE>rlevels</CODE>[0];
        $<CODE>self</CODE>->{<LITERALS>_last_input_line_written</LITERALS>} = $<CODE>input_line_number</CODE>;
        ( my $<CODE>out_str</CODE> = $<CODE>input_line</CODE> ) =~ s/^\s*//;
        chomp $<CODE>out_str</CODE>;

        $<CODE>out_str</CODE> = ( '.' x $<CODE>structural_indentation_level</CODE> ) . $<CODE>out_str</CODE>;

        if ( length($<CODE>out_str</CODE>) > 35 ) {
            $<CODE>out_str</CODE> = substr( $<CODE>out_str</CODE>, 0, 35 ) . " ....";
        }
        $<CODE>self</CODE>-><CODE>logfile_output</CODE>( "", "$<CODE>out_str</CODE>\n" );
    }
}

sub <CODE>write_logfile_entry</CODE> {
    my $<CODE>self</CODE> = shift;

    # <COMMENTS>add</COMMENTS> <COMMENTS>leading</COMMENTS> >>> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>confusing</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>messages</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>code</COMMENTS>
    $<CODE>self</CODE>-><CODE>logfile_output</CODE>( ">>>", "@<CODE>_</CODE>" );
}

sub <CODE>write_column_headings</CODE> {
    my $<CODE>self</CODE> = shift;

    $<CODE>self</CODE>->{<LITERALS>_wrote_column_headings</LITERALS>} = 1;
    my $<CODE>routput_array</CODE> = $<CODE>self</CODE>->{<LITERALS>_output_array</LITERALS>};
    push @{$<CODE>routput_array</CODE>}, <<<LITERALS>EOM</LITERALS>;
<LITERALS>The</LITERALS> <LITERALS>nesting</LITERALS> <LITERALS>depths</LITERALS> <LITERALS>in</LITERALS> <LITERALS>the</LITERALS> <LITERALS>table</LITERALS> <LITERALS>below</LITERALS> <LITERALS>are</LITERALS> <LITERALS>at</LITERALS> <LITERALS>the</LITERALS> <LITERALS>start</LITERALS> <LITERALS>of</LITERALS> <LITERALS>the</LITERALS> <LITERALS>lines</LITERALS>.
<LITERALS>The</LITERALS> <LITERALS>indicated</LITERALS> <LITERALS>output</LITERALS> <LITERALS>line</LITERALS> <LITERALS>numbers</LITERALS> <LITERALS>are</LITERALS> <LITERALS>not</LITERALS> <LITERALS>always</LITERALS> <LITERALS>exact</LITERALS>.
<LITERALS>ci</LITERALS> = <LITERALS>levels</LITERALS> <LITERALS>of</LITERALS> <LITERALS>continuation</LITERALS> <LITERALS>indentation</LITERALS>; <LITERALS>bk</LITERALS> = <LITERALS>1</LITERALS> <LITERALS>if</LITERALS> <LITERALS>in</LITERALS> <LITERALS>BLOCK</LITERALS>, <LITERALS>0</LITERALS> <LITERALS>if</LITERALS> <LITERALS>not</LITERALS>.

<LITERALS>in</LITERALS>:<LITERALS>out</LITERALS> <LITERALS>indent</LITERALS> <LITERALS>c</LITERALS> <LITERALS>b</LITERALS>  <LITERALS>nesting</LITERALS>   <LITERALS>code</LITERALS> + <LITERALS>messages</LITERALS>; (<LITERALS>messages</LITERALS> <LITERALS>begin</LITERALS> <LITERALS>with</LITERALS> >>>)
<LITERALS>lines</LITERALS>  <LITERALS>levels</LITERALS> <LITERALS>i</LITERALS> <LITERALS>k</LITERALS>            (<LITERALS>code</LITERALS> <LITERALS>begins</LITERALS> <LITERALS>with</LITERALS> <LITERALS>one</LITERALS> '.' <LITERALS>per</LITERALS> <LITERALS>indent</LITERALS> <LITERALS>level</LITERALS>)
------  ----- - - --------   -------------------------------------------
<CODE>EOM</CODE>
}

sub <CODE>make_line_information_string</CODE> {

    # <COMMENTS>make</COMMENTS> <COMMENTS>columns</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>information</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>logfile</COMMENTS> <COMMENTS>message</COMMENTS> <COMMENTS>needs</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>out</COMMENTS>
    my $<CODE>self</CODE>                    = shift;
    my $<CODE>line_of_tokens</CODE>          = $<CODE>self</CODE>->{<LITERALS>_line_of_tokens</LITERALS>};
    my $<CODE>input_line_number</CODE>       = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_number</LITERALS>};
    my $<CODE>line_information_string</CODE> = "";
    if ($<CODE>input_line_number</CODE>) {

        my $<CODE>output_line_number</CODE>   = $<CODE>self</CODE>->{<LITERALS>_output_line_number</LITERALS>};
        my $<CODE>brace_depth</CODE>          = $<CODE>line_of_tokens</CODE>->{<LITERALS>_curly_brace_depth</LITERALS>};
        my $<CODE>paren_depth</CODE>          = $<CODE>line_of_tokens</CODE>->{<LITERALS>_paren_depth</LITERALS>};
        my $<CODE>square_bracket_depth</CODE> = $<CODE>line_of_tokens</CODE>->{<LITERALS>_square_bracket_depth</LITERALS>};
        my $<CODE>guessed_indentation_level</CODE> =
          $<CODE>line_of_tokens</CODE>->{<LITERALS>_guessed_indentation_level</LITERALS>};
        my $<CODE>rlevels</CODE>         = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rlevels</LITERALS>};
        my $<CODE>rnesting_tokens</CODE> = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rnesting_tokens</LITERALS>};
        my $<CODE>rci_levels</CODE>      = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rci_levels</LITERALS>};
        my $<CODE>rnesting_blocks</CODE> = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rnesting_blocks</LITERALS>};

        my $<CODE>structural_indentation_level</CODE> = $$<CODE>rlevels</CODE>[0];

        $<CODE>self</CODE>-><CODE>write_column_headings</CODE>() unless $<CODE>self</CODE>->{<LITERALS>_wrote_column_headings</LITERALS>};

        # <COMMENTS>keep</COMMENTS> <COMMENTS>logfile</COMMENTS> <COMMENTS>columns</COMMENTS> <COMMENTS>aligned</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>scripts</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>999</COMMENTS> <COMMENTS>lines</COMMENTS>;
        # <COMMENTS>for</COMMENTS> <COMMENTS>longer</COMMENTS> <COMMENTS>scripts</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>matter</COMMENTS>
        my $<CODE>extra_space</CODE> = "";
        $<CODE>extra_space</CODE> .=
            ( $<CODE>input_line_number</CODE> < 10 )  ? "  "
          : ( $<CODE>input_line_number</CODE> < 100 ) ? " "
          :                                "";
        $<CODE>extra_space</CODE> .=
            ( $<CODE>output_line_number</CODE> < 10 )  ? "  "
          : ( $<CODE>output_line_number</CODE> < 100 ) ? " "
          :                                 "";

        # <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>strings</COMMENTS>:
        # <COMMENTS>the</COMMENTS> <COMMENTS>original</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:  (<COMMENTS>0</COMMENTS> [<COMMENTS>1</COMMENTS> {<COMMENTS>2</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>one</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:  {{[
        # <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>easier</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>read</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>shows</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>order</COMMENTS>, <COMMENTS>but</COMMENTS>
        # <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>arbitrarily</COMMENTS> <COMMENTS>long</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>long</COMMENTS>
        my $<CODE>nesting_string</CODE> =
          "($<CODE>paren_depth</CODE> [$<CODE>square_bracket_depth</CODE> {$<CODE>brace_depth</CODE>";
        my $<CODE>nesting_string_new</CODE> = $$<CODE>rnesting_tokens</CODE>[0];

        my $<CODE>ci_level</CODE> = $$<CODE>rci_levels</CODE>[0];
        if ( $<CODE>ci_level</CODE> > 9 ) { $<CODE>ci_level</CODE> = '*' }
        my $<CODE>bk</CODE> = ( $$<CODE>rnesting_blocks</CODE>[0] =~ /1$/ ) ? '<LITERALS>1</LITERALS>' : '<LITERALS>0</LITERALS>';

        if ( length($<CODE>nesting_string_new</CODE>) <= 8 ) {
            $<CODE>nesting_string</CODE> =
              $<CODE>nesting_string_new</CODE> . " " x ( 8 - length($<CODE>nesting_string_new</CODE>) );
        }
        $<CODE>line_information_string</CODE> =
"<LITERALS>L</LITERALS>$<CODE>input_line_number</CODE>:$<CODE>output_line_number</CODE>$<CODE>extra_space</CODE> <LITERALS>i</LITERALS>$<CODE>guessed_indentation_level</CODE>:$<CODE>structural_indentation_level</CODE> $<CODE>ci_level</CODE> $<CODE>bk</CODE> $<CODE>nesting_string</CODE>";
    }
    return $<CODE>line_information_string</CODE>;
}

sub <CODE>logfile_output</CODE> {
    my $<CODE>self</CODE> = shift;
    my ( $<CODE>prompt</CODE>, $<CODE>msg</CODE> ) = @<CODE>_</CODE>;
    return if ( $<CODE>self</CODE>->{<LITERALS>_block_log_output</LITERALS>} );

    my $<CODE>routput_array</CODE> = $<CODE>self</CODE>->{<LITERALS>_output_array</LITERALS>};
    if ( $<CODE>self</CODE>->{<LITERALS>_at_end_of_file</LITERALS>} || !$<CODE>self</CODE>->{<LITERALS>_use_prefix</LITERALS>} ) {
        push @{$<CODE>routput_array</CODE>}, "$<CODE>msg</CODE>";
    }
    else {
        my $<CODE>line_information_string</CODE> = $<CODE>self</CODE>-><CODE>make_line_information_string</CODE>();
        $<CODE>self</CODE>->{<LITERALS>_wrote_line_information_string</LITERALS>} = 1;

        if ($<CODE>line_information_string</CODE>) {
            push @{$<CODE>routput_array</CODE>}, "$<CODE>line_information_string</CODE>   $<CODE>prompt</CODE>$<CODE>msg</CODE>";
        }
        else {
            push @{$<CODE>routput_array</CODE>}, "$<CODE>msg</CODE>";
        }
    }
}

sub <CODE>get_saw_brace_error</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->{<LITERALS>_saw_brace_error</LITERALS>};
}

sub <CODE>increment_brace_error</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>->{<LITERALS>_saw_brace_error</LITERALS>}++;
}

sub <CODE>brace_warning</CODE> {
    my $<CODE>self</CODE> = shift;
    use <CODE>constant</CODE> <LITERALS>BRACE_WARNING_LIMIT</LITERALS> => 10;
    my $<CODE>saw_brace_error</CODE> = $<CODE>self</CODE>->{<LITERALS>_saw_brace_error</LITERALS>};

    if ( $<CODE>saw_brace_error</CODE> < <CODE>BRACE_WARNING_LIMIT</CODE> ) {
        $<CODE>self</CODE>-><CODE>warning</CODE>(@<CODE>_</CODE>);
    }
    $<CODE>saw_brace_error</CODE>++;
    $<CODE>self</CODE>->{<LITERALS>_saw_brace_error</LITERALS>} = $<CODE>saw_brace_error</CODE>;

    if ( $<CODE>saw_brace_error</CODE> == <CODE>BRACE_WARNING_LIMIT</CODE> ) {
        $<CODE>self</CODE>-><CODE>warning</CODE>("<LITERALS>No</LITERALS> <LITERALS>further</LITERALS> <LITERALS>warnings</LITERALS> <LITERALS>of</LITERALS> <LITERALS>this</LITERALS> <LITERALS>type</LITERALS> <LITERALS>will</LITERALS> <LITERALS>be</LITERALS> <LITERALS>given</LITERALS>\n");
    }
}

sub <CODE>complain</CODE> {

    # <COMMENTS>handle</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>critical</COMMENTS> <COMMENTS>warning</COMMENTS> <COMMENTS>messages</COMMENTS> <COMMENTS>based</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>flag</COMMENTS>
    my $<CODE>self</CODE>  = shift;
    my $<CODE>rOpts</CODE> = $<CODE>self</CODE>->{<LITERALS>_rOpts</LITERALS>};

    # <COMMENTS>these</COMMENTS> <COMMENTS>appear</COMMENTS> <COMMENTS>in</COMMENTS> .<COMMENTS>ERR</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> -<COMMENTS>w</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>warning</LITERALS>-<LITERALS>output</LITERALS>'} ) {
        $<CODE>self</CODE>-><CODE>warning</CODE>(@<CODE>_</CODE>);
    }

    # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>they</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> .<COMMENTS>LOG</COMMENTS> <COMMENTS>file</COMMENTS>
    else {
        $<CODE>self</CODE>->{<LITERALS>_complaint_count</LITERALS>}++;
        $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>warning</CODE> {

    # <COMMENTS>report</COMMENTS> <COMMENTS>errors</COMMENTS> <COMMENTS>to</COMMENTS> .<COMMENTS>ERR</COMMENTS> <COMMENTS>file</COMMENTS> (<COMMENTS>or</COMMENTS> <COMMENTS>stdout</COMMENTS>)
    my $<CODE>self</CODE> = shift;
    use <CODE>constant</CODE> <LITERALS>WARNING_LIMIT</LITERALS> => 50;

    my $<CODE>rOpts</CODE> = $<CODE>self</CODE>->{<LITERALS>_rOpts</LITERALS>};
    unless ( $<CODE>rOpts</CODE>->{'<LITERALS>quiet</LITERALS>'} ) {

        my $<CODE>warning_count</CODE> = $<CODE>self</CODE>->{<LITERALS>_warning_count</LITERALS>};
        my $<CODE>fh_warnings</CODE>   = $<CODE>self</CODE>->{<LITERALS>_fh_warnings</LITERALS>};
        if ( !$<CODE>fh_warnings</CODE> ) {
            my $<CODE>warning_file</CODE> = $<CODE>self</CODE>->{<LITERALS>_warning_file</LITERALS>};
            ( $<CODE>fh_warnings</CODE>, my $<CODE>filename</CODE> ) =
              <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>streamhandle</CODE>( $<CODE>warning_file</CODE>, '<LITERALS>w</LITERALS>' );
            $<CODE>fh_warnings</CODE> or <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE>("<LITERALS>couldn</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>open</LITERALS> $<CODE>filename</CODE> $!\n");
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE> "## <LITERALS>Please</LITERALS> <LITERALS>see</LITERALS> <LITERALS>file</LITERALS> $<CODE>filename</CODE>\n"
              unless ref($<CODE>warning_file</CODE>);
            $<CODE>self</CODE>->{<LITERALS>_fh_warnings</LITERALS>} = $<CODE>fh_warnings</CODE>;
            $<CODE>fh_warnings</CODE>-><CODE>print</CODE>("<LITERALS>Perltidy</LITERALS> <LITERALS>version</LITERALS> <LITERALS>is</LITERALS> $<CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VERSION</CODE>\n");
        }

        if ( $<CODE>warning_count</CODE> < <CODE>WARNING_LIMIT</CODE> ) {
            if ( $<CODE>self</CODE>-><CODE>get_use_prefix</CODE>() > 0 ) {
                my $<CODE>input_line_number</CODE> =
                  <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Tokenizer</CODE>::<CODE>get_input_line_number</CODE>();
                if ( !defined($<CODE>input_line_number</CODE>) ) { $<CODE>input_line_number</CODE> = -1 }
                $<CODE>fh_warnings</CODE>-><CODE>print</CODE>("$<CODE>input_line_number</CODE>:\t@<CODE>_</CODE>");
                $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>("<LITERALS>WARNING</LITERALS>: @<CODE>_</CODE>");
            }
            else {
                $<CODE>fh_warnings</CODE>-><CODE>print</CODE>(@<CODE>_</CODE>);
                $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>(@<CODE>_</CODE>);
            }
        }
        $<CODE>warning_count</CODE>++;
        $<CODE>self</CODE>->{<LITERALS>_warning_count</LITERALS>} = $<CODE>warning_count</CODE>;

        if ( $<CODE>warning_count</CODE> == <CODE>WARNING_LIMIT</CODE> ) {
            $<CODE>fh_warnings</CODE>-><CODE>print</CODE>("<LITERALS>No</LITERALS> <LITERALS>further</LITERALS> <LITERALS>warnings</LITERALS> <LITERALS>will</LITERALS> <LITERALS>be</LITERALS> <LITERALS>given</LITERALS>\n");
        }
    }
}

# <COMMENTS>programming</COMMENTS> <COMMENTS>bug</COMMENTS> <COMMENTS>codes</COMMENTS>:
#   -<COMMENTS>1</COMMENTS> = <COMMENTS>no</COMMENTS> <COMMENTS>bug</COMMENTS>
#    <COMMENTS>0</COMMENTS> = <COMMENTS>maybe</COMMENTS>, <COMMENTS>not</COMMENTS> <COMMENTS>sure</COMMENTS>.
#    <COMMENTS>1</COMMENTS> = <COMMENTS>definitely</COMMENTS>
sub <CODE>report_possible_bug</CODE> {
    my $<CODE>self</CODE>         = shift;
    my $<CODE>saw_code_bug</CODE> = $<CODE>self</CODE>->{<LITERALS>_saw_code_bug</LITERALS>};
    $<CODE>self</CODE>->{<LITERALS>_saw_code_bug</LITERALS>} = ( $<CODE>saw_code_bug</CODE> < 0 ) ? 0 : $<CODE>saw_code_bug</CODE>;
}

sub <CODE>report_definite_bug</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>->{<LITERALS>_saw_code_bug</LITERALS>} = 1;
}

sub <CODE>ask_user_for_bug_report</CODE> {
    my $<CODE>self</CODE> = shift;

    my ( $<CODE>infile_syntax_ok</CODE>, $<CODE>formatter</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>saw_code_bug</CODE> = $<CODE>self</CODE>->{<LITERALS>_saw_code_bug</LITERALS>};
    if ( ( $<CODE>saw_code_bug</CODE> == 0 ) && ( $<CODE>infile_syntax_ok</CODE> == 1 ) ) {
        $<CODE>self</CODE>-><CODE>warning</CODE>(<<<LITERALS>EOM</LITERALS>);

<LITERALS>You</LITERALS> <LITERALS>may</LITERALS> <LITERALS>have</LITERALS> <LITERALS>encountered</LITERALS> <LITERALS>a</LITERALS> <LITERALS>code</LITERALS> <LITERALS>bug</LITERALS> <LITERALS>in</LITERALS> <LITERALS>perltidy</LITERALS>.  <LITERALS>If</LITERALS> <LITERALS>you</LITERALS> <LITERALS>think</LITERALS> <LITERALS>so</LITERALS>, <LITERALS>and</LITERALS>
<LITERALS>the</LITERALS> <LITERALS>problem</LITERALS> <LITERALS>is</LITERALS> <LITERALS>not</LITERALS> <LITERALS>listed</LITERALS> <LITERALS>in</LITERALS> <LITERALS>the</LITERALS> <LITERALS>BUGS</LITERALS> <LITERALS>file</LITERALS> <LITERALS>at</LITERALS>
<LITERALS>http</LITERALS>://<LITERALS>perltidy</LITERALS>.<LITERALS>sourceforge</LITERALS>.<LITERALS>net</LITERALS>, <LITERALS>please</LITERALS> <LITERALS>report</LITERALS> <LITERALS>it</LITERALS> <LITERALS>so</LITERALS> <LITERALS>that</LITERALS> <LITERALS>it</LITERALS> <LITERALS>can</LITERALS> <LITERALS>be</LITERALS>
<LITERALS>corrected</LITERALS>.  <LITERALS>Include</LITERALS> <LITERALS>the</LITERALS> <LITERALS>smallest</LITERALS> <LITERALS>possible</LITERALS> <LITERALS>script</LITERALS> <LITERALS>which</LITERALS> <LITERALS>has</LITERALS> <LITERALS>the</LITERALS> <LITERALS>problem</LITERALS>,
<LITERALS>along</LITERALS> <LITERALS>with</LITERALS> <LITERALS>the</LITERALS> .<LITERALS>LOG</LITERALS> <LITERALS>file</LITERALS>. <LITERALS>See</LITERALS> <LITERALS>the</LITERALS> <LITERALS>manual</LITERALS> <LITERALS>pages</LITERALS> <LITERALS>for</LITERALS> <LITERALS>contact</LITERALS> <LITERALS>information</LITERALS>.
<LITERALS>Thank</LITERALS> <LITERALS>you</LITERALS>!
<CODE>EOM</CODE>

    }
    elsif ( $<CODE>saw_code_bug</CODE> == 1 ) {
        if ( $<CODE>self</CODE>->{<LITERALS>_saw_extrude</LITERALS>} ) {
            $<CODE>self</CODE>-><CODE>warning</CODE>(<<<LITERALS>EOM</LITERALS>);

<LITERALS>You</LITERALS> <LITERALS>may</LITERALS> <LITERALS>have</LITERALS> <LITERALS>encountered</LITERALS> <LITERALS>a</LITERALS> <LITERALS>bug</LITERALS> <LITERALS>in</LITERALS> <LITERALS>perltidy</LITERALS>.  <LITERALS>However</LITERALS>, <LITERALS>since</LITERALS> <LITERALS>you</LITERALS> <LITERALS>are</LITERALS> <LITERALS>using</LITERALS> <LITERALS>the</LITERALS>
-<LITERALS>extrude</LITERALS> <LITERALS>option</LITERALS>, <LITERALS>the</LITERALS> <LITERALS>problem</LITERALS> <LITERALS>may</LITERALS> <LITERALS>be</LITERALS> <LITERALS>with</LITERALS> <LITERALS>perl</LITERALS> <LITERALS>or</LITERALS> <LITERALS>one</LITERALS> <LITERALS>of</LITERALS> <LITERALS>its</LITERALS> <LITERALS>modules</LITERALS>, <LITERALS>which</LITERALS> <LITERALS>have</LITERALS>
<LITERALS>occasional</LITERALS> <LITERALS>problems</LITERALS> <LITERALS>with</LITERALS> <LITERALS>this</LITERALS> <LITERALS>type</LITERALS> <LITERALS>of</LITERALS> <LITERALS>file</LITERALS>.  <LITERALS>If</LITERALS> <LITERALS>you</LITERALS> <LITERALS>believe</LITERALS> <LITERALS>that</LITERALS> <LITERALS>the</LITERALS>
<LITERALS>problem</LITERALS> <LITERALS>is</LITERALS> <LITERALS>with</LITERALS> <LITERALS>perltidy</LITERALS>, <LITERALS>and</LITERALS> <LITERALS>the</LITERALS> <LITERALS>problem</LITERALS> <LITERALS>is</LITERALS> <LITERALS>not</LITERALS> <LITERALS>listed</LITERALS> <LITERALS>in</LITERALS> <LITERALS>the</LITERALS> <LITERALS>BUGS</LITERALS> <LITERALS>file</LITERALS> <LITERALS>at</LITERALS>
<LITERALS>http</LITERALS>://<LITERALS>perltidy</LITERALS>.<LITERALS>sourceforge</LITERALS>.<LITERALS>net</LITERALS>, <LITERALS>please</LITERALS> <LITERALS>report</LITERALS> <LITERALS>it</LITERALS> <LITERALS>so</LITERALS> <LITERALS>that</LITERALS> <LITERALS>it</LITERALS> <LITERALS>can</LITERALS> <LITERALS>be</LITERALS> <LITERALS>corrected</LITERALS>.
<LITERALS>Include</LITERALS> <LITERALS>the</LITERALS> <LITERALS>smallest</LITERALS> <LITERALS>possible</LITERALS> <LITERALS>script</LITERALS> <LITERALS>which</LITERALS> <LITERALS>has</LITERALS> <LITERALS>the</LITERALS> <LITERALS>problem</LITERALS>, <LITERALS>along</LITERALS> <LITERALS>with</LITERALS> <LITERALS>the</LITERALS> .<LITERALS>LOG</LITERALS>
<LITERALS>file</LITERALS>. <LITERALS>See</LITERALS> <LITERALS>the</LITERALS> <LITERALS>manual</LITERALS> <LITERALS>pages</LITERALS> <LITERALS>for</LITERALS> <LITERALS>contact</LITERALS> <LITERALS>information</LITERALS>.
<LITERALS>Thank</LITERALS> <LITERALS>you</LITERALS>!
<CODE>EOM</CODE>
        }
        else {
            $<CODE>self</CODE>-><CODE>warning</CODE>(<<<LITERALS>EOM</LITERALS>);

<LITERALS>Oops</LITERALS>, <LITERALS>you</LITERALS> <LITERALS>seem</LITERALS> <LITERALS>to</LITERALS> <LITERALS>have</LITERALS> <LITERALS>encountered</LITERALS> <LITERALS>a</LITERALS> <LITERALS>bug</LITERALS> <LITERALS>in</LITERALS> <LITERALS>perltidy</LITERALS>.  <LITERALS>Please</LITERALS> <LITERALS>check</LITERALS> <LITERALS>the</LITERALS>
<LITERALS>BUGS</LITERALS> <LITERALS>file</LITERALS> <LITERALS>at</LITERALS> <LITERALS>http</LITERALS>://<LITERALS>perltidy</LITERALS>.<LITERALS>sourceforge</LITERALS>.<LITERALS>net</LITERALS>.  <LITERALS>If</LITERALS> <LITERALS>the</LITERALS> <LITERALS>problem</LITERALS> <LITERALS>is</LITERALS> <LITERALS>not</LITERALS>
<LITERALS>listed</LITERALS> <LITERALS>there</LITERALS>, <LITERALS>please</LITERALS> <LITERALS>report</LITERALS> <LITERALS>it</LITERALS> <LITERALS>so</LITERALS> <LITERALS>that</LITERALS> <LITERALS>it</LITERALS> <LITERALS>can</LITERALS> <LITERALS>be</LITERALS> <LITERALS>corrected</LITERALS>.  <LITERALS>Include</LITERALS> <LITERALS>the</LITERALS>
<LITERALS>smallest</LITERALS> <LITERALS>possible</LITERALS> <LITERALS>script</LITERALS> <LITERALS>which</LITERALS> <LITERALS>produces</LITERALS> <LITERALS>this</LITERALS> <LITERALS>message</LITERALS>, <LITERALS>along</LITERALS> <LITERALS>with</LITERALS> <LITERALS>the</LITERALS>
.<LITERALS>LOG</LITERALS> <LITERALS>file</LITERALS> <LITERALS>if</LITERALS> <LITERALS>appropriate</LITERALS>.  <LITERALS>See</LITERALS> <LITERALS>the</LITERALS> <LITERALS>manual</LITERALS> <LITERALS>pages</LITERALS> <LITERALS>for</LITERALS> <LITERALS>contact</LITERALS> <LITERALS>information</LITERALS>.
<LITERALS>Your</LITERALS> <LITERALS>efforts</LITERALS> <LITERALS>are</LITERALS> <LITERALS>appreciated</LITERALS>.
<LITERALS>Thank</LITERALS> <LITERALS>you</LITERALS>!
<CODE>EOM</CODE>
            my $<CODE>added_semicolon_count</CODE> = 0;
            eval {
                $<CODE>added_semicolon_count</CODE> =
                  $<CODE>formatter</CODE>-><CODE>get_added_semicolon_count</CODE>();
            };
            if ( $<CODE>added_semicolon_count</CODE> > 0 ) {
                $<CODE>self</CODE>-><CODE>warning</CODE>(<<<LITERALS>EOM</LITERALS>);

<LITERALS>The</LITERALS> <LITERALS>log</LITERALS> <LITERALS>file</LITERALS> <LITERALS>shows</LITERALS> <LITERALS>that</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>added</LITERALS> $<CODE>added_semicolon_count</CODE> <LITERALS>semicolons</LITERALS>.
<LITERALS>Please</LITERALS> <LITERALS>rerun</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>nasc</LITERALS> <LITERALS>to</LITERALS> <LITERALS>see</LITERALS> <LITERALS>if</LITERALS> <LITERALS>that</LITERALS> <LITERALS>is</LITERALS> <LITERALS>the</LITERALS> <LITERALS>cause</LITERALS> <LITERALS>of</LITERALS> <LITERALS>the</LITERALS> <LITERALS>syntax</LITERALS> <LITERALS>error</LITERALS>.  <LITERALS>Even</LITERALS>
<LITERALS>if</LITERALS> <LITERALS>that</LITERALS> <LITERALS>is</LITERALS> <LITERALS>the</LITERALS> <LITERALS>problem</LITERALS>, <LITERALS>please</LITERALS> <LITERALS>report</LITERALS> <LITERALS>it</LITERALS> <LITERALS>so</LITERALS> <LITERALS>that</LITERALS> <LITERALS>it</LITERALS> <LITERALS>can</LITERALS> <LITERALS>be</LITERALS> <LITERALS>fixed</LITERALS>.
<CODE>EOM</CODE>

            }
        }
    }
}

sub <CODE>finish</CODE> {

    # <COMMENTS>called</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>formatting</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>summarize</COMMENTS> <COMMENTS>errors</COMMENTS>
    my $<CODE>self</CODE> = shift;
    my ( $<CODE>infile_syntax_ok</CODE>, $<CODE>formatter</CODE> ) = @<CODE>_</CODE>;

    my $<CODE>rOpts</CODE>         = $<CODE>self</CODE>->{<LITERALS>_rOpts</LITERALS>};
    my $<CODE>warning_count</CODE> = $<CODE>self</CODE>->{<LITERALS>_warning_count</LITERALS>};
    my $<CODE>saw_code_bug</CODE>  = $<CODE>self</CODE>->{<LITERALS>_saw_code_bug</LITERALS>};

    my $<CODE>save_logfile</CODE> =
         ( $<CODE>saw_code_bug</CODE> == 0 && $<CODE>infile_syntax_ok</CODE> == 1 )
      || $<CODE>saw_code_bug</CODE> == 1
      || $<CODE>rOpts</CODE>->{'<LITERALS>logfile</LITERALS>'};
    my $<CODE>log_file</CODE> = $<CODE>self</CODE>->{<LITERALS>_log_file</LITERALS>};
    if ($<CODE>warning_count</CODE>) {
        if ($<CODE>save_logfile</CODE>) {
            $<CODE>self</CODE>-><CODE>block_log_output</CODE>();    # <COMMENTS>avoid</COMMENTS> <COMMENTS>echoing</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>logfile</COMMENTS>
            $<CODE>self</CODE>-><CODE>warning</CODE>(
                "<LITERALS>The</LITERALS> <LITERALS>logfile</LITERALS> $<CODE>log_file</CODE> <LITERALS>may</LITERALS> <LITERALS>contain</LITERALS> <LITERALS>useful</LITERALS> <LITERALS>information</LITERALS>\n");
            $<CODE>self</CODE>-><CODE>unblock_log_output</CODE>();
        }

        if ( $<CODE>self</CODE>->{<LITERALS>_complaint_count</LITERALS>} > 0 ) {
            $<CODE>self</CODE>-><CODE>warning</CODE>(
"<LITERALS>To</LITERALS> <LITERALS>see</LITERALS> $<CODE>self</CODE>->{<LITERALS>_complaint_count</LITERALS>} <LITERALS>non</LITERALS>-<LITERALS>critical</LITERALS> <LITERALS>warnings</LITERALS> <LITERALS>rerun</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>w</LITERALS>\n"
            );
        }

        if ( $<CODE>self</CODE>->{<LITERALS>_saw_brace_error</LITERALS>}
            && ( $<CODE>self</CODE>->{<LITERALS>_logfile_gap</LITERALS>} > 1 || !$<CODE>save_logfile</CODE> ) )
        {
            $<CODE>self</CODE>-><CODE>warning</CODE>("<LITERALS>To</LITERALS> <LITERALS>save</LITERALS> <LITERALS>a</LITERALS> <LITERALS>full</LITERALS> .<LITERALS>LOG</LITERALS> <LITERALS>file</LITERALS> <LITERALS>rerun</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>g</LITERALS>\n");
        }
    }
    $<CODE>self</CODE>-><CODE>ask_user_for_bug_report</CODE>( $<CODE>infile_syntax_ok</CODE>, $<CODE>formatter</CODE> );

    if ($<CODE>save_logfile</CODE>) {
        my $<CODE>log_file</CODE> = $<CODE>self</CODE>->{<LITERALS>_log_file</LITERALS>};
        my ( $<CODE>fh</CODE>, $<CODE>filename</CODE> ) = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>streamhandle</CODE>( $<CODE>log_file</CODE>, '<LITERALS>w</LITERALS>' );
        if ($<CODE>fh</CODE>) {
            my $<CODE>routput_array</CODE> = $<CODE>self</CODE>->{<LITERALS>_output_array</LITERALS>};
            foreach ( @{$<CODE>routput_array</CODE>} ) { $<CODE>fh</CODE>-><CODE>print</CODE>($<CODE>_</CODE>) }
            if ( $<CODE>log_file</CODE> ne '-' && !ref $<CODE>log_file</CODE> ) {
                eval { $<CODE>fh</CODE>-><CODE>close</CODE>() };
            }
        }
    }
}

#####################################################################
#
# <COMMENTS>The</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>DevNull</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>supplies</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>dummy</COMMENTS> <COMMENTS>print</COMMENTS> <COMMENTS>method</COMMENTS>
#
#####################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>DevNull</CODE>;
sub <CODE>new</CODE> { return bless {}, $<CODE>_</CODE>[0] }
sub <CODE>print</CODE> { return }
sub <CODE>close</CODE> { return }

#####################################################################
#
# <COMMENTS>The</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>HtmlWriter</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>writes</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>copy</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>stream</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>html</COMMENTS>
#
#####################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>HtmlWriter</CODE>;

use <CODE>File</CODE>::<CODE>Basename</CODE>;

# <COMMENTS>class</COMMENTS> <COMMENTS>variables</COMMENTS>
use <CODE>vars</CODE> qw{
  %<CODE>html_color</CODE>
  %<CODE>html_bold</CODE>
  %<CODE>html_italic</CODE>
  %<CODE>token_short_names</CODE>
  %<CODE>short_to_long_names</CODE>
  $<CODE>rOpts</CODE>
  $<CODE>css_filename</CODE>
  $<CODE>css_linkname</CODE>
  $<CODE>missing_html_entities</CODE>
};

# <COMMENTS>replace</COMMENTS> <COMMENTS>unsafe</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>HTML</COMMENTS> <COMMENTS>entity</COMMENTS> <COMMENTS>representation</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>HTML</COMMENTS>::<COMMENTS>Entities</COMMENTS>
# <COMMENTS>is</COMMENTS> <COMMENTS>available</COMMENTS>
{ eval "<LITERALS>use</LITERALS> <LITERALS>HTML</LITERALS>::<LITERALS>Entities</LITERALS>"; $<CODE>missing_html_entities</CODE> = $@; }

sub <CODE>new</CODE> {

    my ( $<CODE>class</CODE>, $<CODE>input_file</CODE>, $<CODE>html_file</CODE>, $<CODE>extension</CODE>, $<CODE>html_toc_extension</CODE>,
        $<CODE>html_src_extension</CODE> )
      = @<CODE>_</CODE>;

    my $<CODE>html_file_opened</CODE> = 0;
    my $<CODE>html_fh</CODE>;
    ( $<CODE>html_fh</CODE>, my $<CODE>html_filename</CODE> ) =
      <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>streamhandle</CODE>( $<CODE>html_file</CODE>, '<LITERALS>w</LITERALS>' );
    unless ($<CODE>html_fh</CODE>) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE>("<LITERALS>can</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>open</LITERALS> $<CODE>html_file</CODE>: $!\n");
        return undef;
    }
    $<CODE>html_file_opened</CODE> = 1;

    if ( !$<CODE>input_file</CODE> || $<CODE>input_file</CODE> eq '-' || ref($<CODE>input_file</CODE>) ) {
        $<CODE>input_file</CODE> = "<LITERALS>NONAME</LITERALS>";
    }

    # <COMMENTS>write</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS>
    my $<CODE>toc_string</CODE>;
    my $<CODE>html_toc_fh</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IOScalar</CODE>-><CODE>new</CODE>( \$<CODE>toc_string</CODE>, '<LITERALS>w</LITERALS>' );

    my $<CODE>html_pre_fh</CODE>;
    my @<CODE>pre_string_stack</CODE>;
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>pre</LITERALS>-<LITERALS>only</LITERALS>'} ) {

        # <COMMENTS>pre</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>goes</COMMENTS> <COMMENTS>directly</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>
        $<CODE>html_pre_fh</CODE> = $<CODE>html_fh</CODE>;
        $<CODE>html_pre_fh</CODE>-><CODE>print</CODE>( <<"<LITERALS>PRE_END</LITERALS>");
<<LITERALS>pre</LITERALS>>
<CODE>PRE_END</CODE>
    }
    else {

        # <COMMENTS>pre</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>temporary</COMMENTS> <COMMENTS>string</COMMENTS>
        my $<CODE>pre_string</CODE>;
        $<CODE>html_pre_fh</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IOScalar</CODE>-><CODE>new</CODE>( \$<CODE>pre_string</CODE>, '<LITERALS>w</LITERALS>' );
        push @<CODE>pre_string_stack</CODE>, \$<CODE>pre_string</CODE>;
    }

    # <COMMENTS>pod</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>gets</COMMENTS> <COMMENTS>diverted</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>pod2html</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>
    my $<CODE>html_pod_fh</CODE>;
    my $<CODE>pod_string</CODE>;
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>pod2html</LITERALS>'} ) {
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>pre</LITERALS>-<LITERALS>only</LITERALS>'} ) {
            undef $<CODE>rOpts</CODE>->{'<LITERALS>pod2html</LITERALS>'};
        }
        else {
            eval "<LITERALS>use</LITERALS> <LITERALS>Pod</LITERALS>::<LITERALS>Html</LITERALS>";
            if ($@) {
                <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE>
"<LITERALS>unable</LITERALS> <LITERALS>to</LITERALS> <LITERALS>find</LITERALS> <LITERALS>Pod</LITERALS>::<LITERALS>Html</LITERALS>; <LITERALS>cannot</LITERALS> <LITERALS>use</LITERALS> <LITERALS>pod2html</LITERALS>\n-<LITERALS>npod</LITERALS> <LITERALS>disables</LITERALS> <LITERALS>this</LITERALS> <LITERALS>message</LITERALS>\n";
                undef $<CODE>rOpts</CODE>->{'<LITERALS>pod2html</LITERALS>'};
            }
            else {
                $<CODE>html_pod_fh</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IOScalar</CODE>-><CODE>new</CODE>( \$<CODE>pod_string</CODE>, '<LITERALS>w</LITERALS>' );
            }
        }
    }

    my $<CODE>toc_filename</CODE>;
    my $<CODE>src_filename</CODE>;
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>frames</LITERALS>'} ) {
        unless ($<CODE>extension</CODE>) {
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE>
"<LITERALS>cannot</LITERALS> <LITERALS>use</LITERALS> <LITERALS>frames</LITERALS> <LITERALS>without</LITERALS> <LITERALS>a</LITERALS> <LITERALS>specified</LITERALS> <LITERALS>output</LITERALS> <LITERALS>extension</LITERALS>; <LITERALS>ignoring</LITERALS> -<LITERALS>frm</LITERALS>\n";
            undef $<CODE>rOpts</CODE>->{'<LITERALS>frames</LITERALS>'};
        }
        else {
            $<CODE>toc_filename</CODE> = $<CODE>input_file</CODE> . $<CODE>html_toc_extension</CODE> . $<CODE>extension</CODE>;
            $<CODE>src_filename</CODE> = $<CODE>input_file</CODE> . $<CODE>html_src_extension</CODE> . $<CODE>extension</CODE>;
        }
    }

    # ----------------------------------------------------------
    # <COMMENTS>Output</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>now</COMMENTS> <COMMENTS>directed</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>follows</COMMENTS>:
    # <COMMENTS>html_toc_fh</COMMENTS> <-- <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>items</COMMENTS>
    # <COMMENTS>html_pre_fh</COMMENTS> <-- <COMMENTS>the</COMMENTS> <<COMMENTS>pre</COMMENTS>> <COMMENTS>section</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>formatted</COMMENTS> <COMMENTS>code</COMMENTS>, <COMMENTS>except</COMMENTS>:
    # <COMMENTS>html_pod_fh</COMMENTS> <-- <COMMENTS>pod</COMMENTS> <COMMENTS>goes</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pod2html</COMMENTS> <COMMENTS>option</COMMENTS>
    # ----------------------------------------------------------

    my $<CODE>title</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>title</LITERALS>'};
    unless ($<CODE>title</CODE>) {
        ( $<CODE>title</CODE>, my $<CODE>path</CODE> ) = <CODE>fileparse</CODE>($<CODE>input_file</CODE>);
    }
    my $<CODE>toc_item_count</CODE> = 0;
    my $<CODE>in_toc_package</CODE> = "";
    my $<CODE>last_level</CODE>     = 0;
    bless {
        <LITERALS>_input_file</LITERALS>        => $<CODE>input_file</CODE>,          # <COMMENTS>name</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS>
        <LITERALS>_title</LITERALS>             => $<CODE>title</CODE>,               # <COMMENTS>title</COMMENTS>, <COMMENTS>unescaped</COMMENTS>
        <LITERALS>_html_file</LITERALS>         => $<CODE>html_file</CODE>,           # <COMMENTS>name</COMMENTS> <COMMENTS>of</COMMENTS> .<COMMENTS>html</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>file</COMMENTS>
        <LITERALS>_toc_filename</LITERALS>      => $<CODE>toc_filename</CODE>,        # <COMMENTS>for</COMMENTS> <COMMENTS>frames</COMMENTS> <COMMENTS>option</COMMENTS>
        <LITERALS>_src_filename</LITERALS>      => $<CODE>src_filename</CODE>,        # <COMMENTS>for</COMMENTS> <COMMENTS>frames</COMMENTS> <COMMENTS>option</COMMENTS>
        <LITERALS>_html_file_opened</LITERALS>  => $<CODE>html_file_opened</CODE>,    # <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS>
        <LITERALS>_html_fh</LITERALS>           => $<CODE>html_fh</CODE>,             # <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>
        <LITERALS>_html_pre_fh</LITERALS>       => $<CODE>html_pre_fh</CODE>,         # <COMMENTS>pre</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>goes</COMMENTS> <COMMENTS>here</COMMENTS>
        <LITERALS>_rpre_string_stack</LITERALS> => \@<CODE>pre_string_stack</CODE>,   # <COMMENTS>stack</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>pre</COMMENTS> <COMMENTS>sections</COMMENTS>
        <LITERALS>_html_pod_fh</LITERALS>       => $<CODE>html_pod_fh</CODE>,         # <COMMENTS>pod</COMMENTS> <COMMENTS>goes</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>pod2html</COMMENTS>
        <LITERALS>_rpod_string</LITERALS>       => \$<CODE>pod_string</CODE>,         # <COMMENTS>string</COMMENTS> <COMMENTS>holding</COMMENTS> <COMMENTS>pod</COMMENTS>
        <LITERALS>_pod_cut_count</LITERALS>     => 0,                    # <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> =<COMMENTS>cut</COMMENTS>'<COMMENTS>s</COMMENTS>?
        <LITERALS>_html_toc_fh</LITERALS>       => $<CODE>html_toc_fh</CODE>,         # <COMMENTS>fh</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS>
        <LITERALS>_rtoc_string</LITERALS>       => \$<CODE>toc_string</CODE>,         # <COMMENTS>string</COMMENTS> <COMMENTS>holding</COMMENTS> <COMMENTS>toc</COMMENTS>
        <LITERALS>_rtoc_item_count</LITERALS>   => \$<CODE>toc_item_count</CODE>,     # <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>toc</COMMENTS> <COMMENTS>items</COMMENTS>
        <LITERALS>_rin_toc_package</LITERALS>   => \$<CODE>in_toc_package</CODE>,     # <COMMENTS>package</COMMENTS> <COMMENTS>name</COMMENTS>
        <LITERALS>_rtoc_name_count</LITERALS>   => {},                   # <COMMENTS>hash</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>track</COMMENTS> <COMMENTS>unique</COMMENTS> <COMMENTS>names</COMMENTS>
        <LITERALS>_rpackage_stack</LITERALS>    => [],                   # <COMMENTS>stack</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>package</COMMENTS>
                                                    # <COMMENTS>name</COMMENTS> <COMMENTS>changes</COMMENTS>
        <LITERALS>_rlast_level</LITERALS>       => \$<CODE>last_level</CODE>,         # <COMMENTS>brace</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS>
    }, $<CODE>class</CODE>;
}

sub <CODE>add_toc_item</CODE> {

    # <COMMENTS>Add</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS>.
    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>written</COMMENTS>,
    # <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>anchors</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <<COMMENTS>pre</COMMENTS>> <COMMENTS>text</COMMENTS>.
    # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>anchor</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>type</COMMENTS>; <COMMENTS>types</COMMENTS> <COMMENTS>are</COMMENTS>:
    #      '<COMMENTS>package</COMMENTS>', '<COMMENTS>sub</COMMENTS>', '<COMMENTS>__END__</COMMENTS>', '<COMMENTS>__DATA__</COMMENTS>', '<COMMENTS>EOF</COMMENTS>'
    # <COMMENTS>There</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>an</COMMENTS> '<COMMENTS>EOF</COMMENTS>' <COMMENTS>call</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>wrap</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>up</COMMENTS>.
    my $<CODE>self</CODE> = shift;
    my ( $<CODE>name</CODE>, $<CODE>type</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>html_toc_fh</CODE>     = $<CODE>self</CODE>->{<LITERALS>_html_toc_fh</LITERALS>};
    my $<CODE>html_pre_fh</CODE>     = $<CODE>self</CODE>->{<LITERALS>_html_pre_fh</LITERALS>};
    my $<CODE>rtoc_name_count</CODE> = $<CODE>self</CODE>->{<LITERALS>_rtoc_name_count</LITERALS>};
    my $<CODE>rtoc_item_count</CODE> = $<CODE>self</CODE>->{<LITERALS>_rtoc_item_count</LITERALS>};
    my $<CODE>rlast_level</CODE>     = $<CODE>self</CODE>->{<LITERALS>_rlast_level</LITERALS>};
    my $<CODE>rin_toc_package</CODE> = $<CODE>self</CODE>->{<LITERALS>_rin_toc_package</LITERALS>};
    my $<CODE>rpackage_stack</CODE>  = $<CODE>self</CODE>->{<LITERALS>_rpackage_stack</LITERALS>};

    # <COMMENTS>packages</COMMENTS> <COMMENTS>contain</COMMENTS> <COMMENTS>sublists</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>subs</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>errors</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>package</COMMENTS>
    # <COMMENTS>items</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>written</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>finished</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>routines</COMMENTS>
    my $<CODE>end_package_list</CODE> = sub {
        if ($$<CODE>rin_toc_package</CODE>) {
            $<CODE>html_toc_fh</CODE>-><CODE>print</CODE>("</<LITERALS>ul</LITERALS>>\n</<LITERALS>li</LITERALS>>\n");
            $$<CODE>rin_toc_package</CODE> = "";
        }
    };

    my $<CODE>start_package_list</CODE> = sub {
        my ( $<CODE>unique_name</CODE>, $<CODE>package</CODE> ) = @<CODE>_</CODE>;
        if ($$<CODE>rin_toc_package</CODE>) { $<CODE>end_package_list</CODE>->() }
        $<CODE>html_toc_fh</CODE>-><CODE>print</CODE>(<<<LITERALS>EOM</LITERALS>);
<<LITERALS>li</LITERALS>><<LITERALS>a</LITERALS> <LITERALS>href</LITERALS>=\"#$<CODE>unique_name</CODE>\"><LITERALS>package</LITERALS> $<CODE>package</CODE></<LITERALS>a</LITERALS>>
<<LITERALS>ul</LITERALS>>
<CODE>EOM</CODE>
        $$<CODE>rin_toc_package</CODE> = $<CODE>package</CODE>;
    };

    # <COMMENTS>start</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>item</COMMENTS>
    unless ($$<CODE>rtoc_item_count</CODE>) {

        # <COMMENTS>but</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>quit</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>hit</COMMENTS> <COMMENTS>EOF</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>entries</COMMENTS>
        # <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>case</COMMENTS>, <COMMENTS>there</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>toc</COMMENTS>
        return if ( $<CODE>type</CODE> eq '<LITERALS>EOF</LITERALS>' );
        $<CODE>html_toc_fh</CODE>-><CODE>print</CODE>( <<"<LITERALS>TOC_END</LITERALS>");
<!-- <LITERALS>BEGIN</LITERALS> <LITERALS>CODE</LITERALS> <LITERALS>INDEX</LITERALS> --><<LITERALS>a</LITERALS> <LITERALS>name</LITERALS>="<LITERALS>code</LITERALS>-<LITERALS>index</LITERALS>"></<LITERALS>a</LITERALS>>
<<LITERALS>ul</LITERALS>>
<CODE>TOC_END</CODE>
    }
    $$<CODE>rtoc_item_count</CODE>++;

    # <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>unique</COMMENTS> <COMMENTS>anchor</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>location</COMMENTS>:
    #   - <COMMENTS>packages</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>package</COMMENTS>-' <COMMENTS>prefix</COMMENTS>
    #   - <COMMENTS>subs</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>names</COMMENTS>
    my $<CODE>unique_name</CODE> = $<CODE>name</CODE>;
    if ( $<CODE>type</CODE> eq '<LITERALS>package</LITERALS>' ) { $<CODE>unique_name</CODE> = "<LITERALS>package</LITERALS>-$<CODE>name</CODE>" }

    # <COMMENTS>append</COMMENTS> '-<COMMENTS>1</COMMENTS>', '-<COMMENTS>2</COMMENTS>', <COMMENTS>etc</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>unique</COMMENTS>; <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS>
    # <COMMENTS>be</COMMENTS> <COMMENTS>unique</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>subs</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>packages</COMMENTS> <COMMENTS>cannot</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> '-'
    if ( my $<CODE>count</CODE> = $<CODE>rtoc_name_count</CODE>->{ lc $<CODE>unique_name</CODE> }++ ) {
        $<CODE>unique_name</CODE> .= "-$<CODE>count</CODE>";
    }

    #   - <COMMENTS>all</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>terminal</COMMENTS> '-' <COMMENTS>if</COMMENTS> <COMMENTS>pod2html</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS>
    #     <COMMENTS>conflicts</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>anchor</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>created</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>pod2html</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>pod2html</LITERALS>'} ) { $<CODE>unique_name</CODE> .= '-' }

    # <COMMENTS>start</COMMENTS>/<COMMENTS>stop</COMMENTS> <COMMENTS>lists</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>subs</COMMENTS>
    if ( $<CODE>type</CODE> eq '<LITERALS>sub</LITERALS>' ) {
        my $<CODE>package</CODE> = $<CODE>rpackage_stack</CODE>->[$$<CODE>rlast_level</CODE>];
        unless ($<CODE>package</CODE>) { $<CODE>package</CODE> = '<LITERALS>main</LITERALS>' }

        # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS>'<COMMENTS>re</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>package</COMMENTS>/<COMMENTS>sub</COMMENTS> <COMMENTS>list</COMMENTS>, <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS>
        # <COMMENTS>package</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>close</COMMENTS> <COMMENTS>it</COMMENTS>
        if ( $$<CODE>rin_toc_package</CODE> && $$<CODE>rin_toc_package</CODE> ne $<CODE>package</CODE> ) {
            $<CODE>end_package_list</CODE>->();
        }

        # <COMMENTS>start</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>package</COMMENTS>/<COMMENTS>sub</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
        unless ($$<CODE>rin_toc_package</CODE>) {
            $<CODE>start_package_list</CODE>->( $<CODE>unique_name</CODE>, $<CODE>package</CODE> );
        }
    }

    # <COMMENTS>now</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>entry</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>toc</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>item</COMMENTS>
    if ( $<CODE>type</CODE> eq '<LITERALS>package</LITERALS>' ) {
        $<CODE>start_package_list</CODE>->( $<CODE>unique_name</CODE>, $<CODE>name</CODE> );
    }
    elsif ( $<CODE>type</CODE> eq '<LITERALS>sub</LITERALS>' ) {
        $<CODE>html_toc_fh</CODE>-><CODE>print</CODE>("<<LITERALS>li</LITERALS>><<LITERALS>a</LITERALS> <LITERALS>href</LITERALS>=\"#$<CODE>unique_name</CODE>\">$<CODE>name</CODE></<LITERALS>a</LITERALS>></<LITERALS>li</LITERALS>>\n");
    }
    else {
        $<CODE>end_package_list</CODE>->();
        $<CODE>html_toc_fh</CODE>-><CODE>print</CODE>("<<LITERALS>li</LITERALS>><<LITERALS>a</LITERALS> <LITERALS>href</LITERALS>=\"#$<CODE>unique_name</CODE>\">$<CODE>name</CODE></<LITERALS>a</LITERALS>></<LITERALS>li</LITERALS>>\n");
    }

    # <COMMENTS>write</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>anchor</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <<COMMENTS>pre</COMMENTS>> <COMMENTS>section</COMMENTS>
    $<CODE>html_pre_fh</CODE>-><CODE>print</CODE>("<<LITERALS>a</LITERALS> <LITERALS>name</LITERALS>=\"$<CODE>unique_name</CODE>\"></<LITERALS>a</LITERALS>>");

    # <COMMENTS>end</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS>, <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>file</COMMENTS>
    if ( $<CODE>type</CODE> eq '<LITERALS>EOF</LITERALS>' ) {
        $<CODE>html_toc_fh</CODE>-><CODE>print</CODE>( <<"<LITERALS>TOC_END</LITERALS>");
</<LITERALS>ul</LITERALS>>
<!-- <LITERALS>END</LITERALS> <LITERALS>CODE</LITERALS> <LITERALS>INDEX</LITERALS> -->
<CODE>TOC_END</CODE>
    }
}

<CODE>BEGIN</CODE> {

    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>official</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>identified</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>user</COMMENTS>.  <COMMENTS>Long</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>getopt</COMMENTS> <COMMENTS>keys</COMMENTS>.  <COMMENTS>Short</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>are</COMMENTS>
    # <COMMENTS>convenient</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>abbreviations</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>specifying</COMMENTS> <COMMENTS>input</COMMENTS>.  <COMMENTS>Short</COMMENTS> <COMMENTS>names</COMMENTS>
    # <COMMENTS>somewhat</COMMENTS> <COMMENTS>resemble</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>characters</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>often</COMMENTS> <COMMENTS>different</COMMENTS>
    # <COMMENTS>because</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>alphanumeric</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>command</COMMENTS> <COMMENTS>line</COMMENTS>
    # <COMMENTS>input</COMMENTS>.  <COMMENTS>Also</COMMENTS>, <COMMENTS>note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>insensitivity</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>html</COMMENTS>,
    # <COMMENTS>this</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>only</COMMENTS> (<COMMENTS>I</COMMENTS>'<COMMENTS>ve</COMMENTS> <COMMENTS>chosen</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>all</COMMENTS>
    # <COMMENTS>lower</COMMENTS> <COMMENTS>case</COMMENTS>).
    # <COMMENTS>When</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>NEW_TOKENS</COMMENTS>: <COMMENTS>update</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>table</COMMENTS>
    # <COMMENTS>short</COMMENTS> <COMMENTS>names</COMMENTS> => <COMMENTS>long</COMMENTS> <COMMENTS>names</COMMENTS>
    %<CODE>short_to_long_names</CODE> = (
        '<LITERALS>n</LITERALS>'  => '<LITERALS>numeric</LITERALS>',
        '<LITERALS>p</LITERALS>'  => '<LITERALS>paren</LITERALS>',
        '<LITERALS>q</LITERALS>'  => '<LITERALS>quote</LITERALS>',
        '<LITERALS>s</LITERALS>'  => '<LITERALS>structure</LITERALS>',
        '<LITERALS>c</LITERALS>'  => '<LITERALS>comment</LITERALS>',
        '<LITERALS>v</LITERALS>'  => '<LITERALS>v</LITERALS>-<LITERALS>string</LITERALS>',
        '<LITERALS>cm</LITERALS>' => '<LITERALS>comma</LITERALS>',
        '<LITERALS>w</LITERALS>'  => '<LITERALS>bareword</LITERALS>',
        '<LITERALS>co</LITERALS>' => '<LITERALS>colon</LITERALS>',
        '<LITERALS>pu</LITERALS>' => '<LITERALS>punctuation</LITERALS>',
        '<LITERALS>i</LITERALS>'  => '<LITERALS>identifier</LITERALS>',
        '<LITERALS>j</LITERALS>'  => '<LITERALS>label</LITERALS>',
        '<LITERALS>h</LITERALS>'  => '<LITERALS>here</LITERALS>-<LITERALS>doc</LITERALS>-<LITERALS>target</LITERALS>',
        '<LITERALS>hh</LITERALS>' => '<LITERALS>here</LITERALS>-<LITERALS>doc</LITERALS>-<LITERALS>text</LITERALS>',
        '<LITERALS>k</LITERALS>'  => '<LITERALS>keyword</LITERALS>',
        '<LITERALS>sc</LITERALS>' => '<LITERALS>semicolon</LITERALS>',
        '<LITERALS>m</LITERALS>'  => '<LITERALS>subroutine</LITERALS>',
        '<LITERALS>pd</LITERALS>' => '<LITERALS>pod</LITERALS>-<LITERALS>text</LITERALS>',
    );

    # <COMMENTS>Now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>map</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>short</COMMENTS>
    # <COMMENTS>names</COMMENTS>; <COMMENTS>any</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>mapped</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>get</COMMENTS> '<COMMENTS>punctuation</COMMENTS>'
    # <COMMENTS>properties</COMMENTS>.

    # <COMMENTS>The</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>correspond</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>keys</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>previous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>table</COMMENTS>.
    # <COMMENTS>The</COMMENTS> <COMMENTS>keys</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>seen</COMMENTS>
    # <COMMENTS>by</COMMENTS> <COMMENTS>running</COMMENTS> <COMMENTS>with</COMMENTS> --<COMMENTS>dump</COMMENTS>-<COMMENTS>token</COMMENTS>-<COMMENTS>types</COMMENTS> (-<COMMENTS>dtt</COMMENTS>).

    # <COMMENTS>When</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>NEW_TOKENS</COMMENTS>: <COMMENTS>update</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>table</COMMENTS>
    # <COMMENTS>$type</COMMENTS> => <COMMENTS>$short_name</COMMENTS>
    %<CODE>token_short_names</CODE> = (
        '#'  => '<LITERALS>c</LITERALS>',
        '<LITERALS>n</LITERALS>'  => '<LITERALS>n</LITERALS>',
        '<LITERALS>v</LITERALS>'  => '<LITERALS>v</LITERALS>',
        '<LITERALS>k</LITERALS>'  => '<LITERALS>k</LITERALS>',
        '<LITERALS>F</LITERALS>'  => '<LITERALS>k</LITERALS>',
        '<LITERALS>Q</LITERALS>'  => '<LITERALS>q</LITERALS>',
        '<LITERALS>q</LITERALS>'  => '<LITERALS>q</LITERALS>',
        '<LITERALS>J</LITERALS>'  => '<LITERALS>j</LITERALS>',
        '<LITERALS>j</LITERALS>'  => '<LITERALS>j</LITERALS>',
        '<LITERALS>h</LITERALS>'  => '<LITERALS>h</LITERALS>',
        '<LITERALS>H</LITERALS>'  => '<LITERALS>hh</LITERALS>',
        '<LITERALS>w</LITERALS>'  => '<LITERALS>w</LITERALS>',
        ','  => '<LITERALS>cm</LITERALS>',
        '=>' => '<LITERALS>cm</LITERALS>',
        ';'  => '<LITERALS>sc</LITERALS>',
        ':'  => '<LITERALS>co</LITERALS>',
        '<LITERALS>f</LITERALS>'  => '<LITERALS>sc</LITERALS>',
        '('  => '<LITERALS>p</LITERALS>',
        ')'  => '<LITERALS>p</LITERALS>',
        '<LITERALS>M</LITERALS>'  => '<LITERALS>m</LITERALS>',
        '<LITERALS>P</LITERALS>'  => '<LITERALS>pd</LITERALS>',
        '<LITERALS>A</LITERALS>'  => '<LITERALS>co</LITERALS>',
    );

    # <COMMENTS>These</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>identifiers</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>now</COMMENTS>
    # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>could</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>modules</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>type</COMMENTS>
    my @<CODE>identifier</CODE> = qw" <LITERALS>i</LITERALS> <LITERALS>t</LITERALS> <LITERALS>U</LITERALS> <LITERALS>C</LITERALS> <LITERALS>Y</LITERALS> <LITERALS>Z</LITERALS> <LITERALS>G</LITERALS> :: <LITERALS>CORE</LITERALS>::";
    @<CODE>token_short_names</CODE>{@<CODE>identifier</CODE>} = ('<LITERALS>i</LITERALS>') x scalar(@<CODE>identifier</CODE>);

    # <COMMENTS>These</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>called</COMMENTS> '<COMMENTS>structure</COMMENTS>'
    my @<CODE>structure</CODE> = qw" { } ";
    @<CODE>token_short_names</CODE>{@<CODE>structure</CODE>} = ('<LITERALS>s</LITERALS>') x scalar(@<CODE>structure</CODE>);

    # <COMMENTS>OLD</COMMENTS> <COMMENTS>NOTES</COMMENTS>: <COMMENTS>save</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>reference</COMMENTS>
    # <COMMENTS>Any</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>added</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>useful</COMMENTS>.
    # <COMMENTS>For</COMMENTS> <COMMENTS>now</COMMENTS>, <COMMENTS>they</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>become</COMMENTS> <COMMENTS>punctuation</COMMENTS>
    #    <COMMENTS>my</COMMENTS> @<COMMENTS>list</COMMENTS> = <COMMENTS>qw</COMMENTS>" <COMMENTS>L</COMMENTS> <COMMENTS>R</COMMENTS> [ ] ";
    #    @<COMMENTS>token_long_names</COMMENTS>{@<COMMENTS>list</COMMENTS>} = ('<COMMENTS>non</COMMENTS>-<COMMENTS>structure</COMMENTS>') <COMMENTS>x</COMMENTS> <COMMENTS>scalar</COMMENTS>(@<COMMENTS>list</COMMENTS>);
    #
    #    <COMMENTS>my</COMMENTS> @<COMMENTS>list</COMMENTS> = <COMMENTS>qw</COMMENTS>"
    #      / /= * *= ** **= + += - -= % %= = ++ -- << <<= >> >>= <COMMENTS>pp</COMMENTS> <COMMENTS>p</COMMENTS> <COMMENTS>m</COMMENTS> <COMMENTS>mm</COMMENTS>
    #      ";
    #    @<COMMENTS>token_long_names</COMMENTS>{@<COMMENTS>list</COMMENTS>} = ('<COMMENTS>math</COMMENTS>') <COMMENTS>x</COMMENTS> <COMMENTS>scalar</COMMENTS>(@<COMMENTS>list</COMMENTS>);
    #
    #    <COMMENTS>my</COMMENTS> @<COMMENTS>list</COMMENTS> = <COMMENTS>qw</COMMENTS>" & &= ~ ~= ^ ^= | |= ";
    #    @<COMMENTS>token_long_names</COMMENTS>{@<COMMENTS>list</COMMENTS>} = ('<COMMENTS>bit</COMMENTS>') <COMMENTS>x</COMMENTS> <COMMENTS>scalar</COMMENTS>(@<COMMENTS>list</COMMENTS>);
    #
    #    <COMMENTS>my</COMMENTS> @<COMMENTS>list</COMMENTS> = <COMMENTS>qw</COMMENTS>" == != < > <= <=> ";
    #    @<COMMENTS>token_long_names</COMMENTS>{@<COMMENTS>list</COMMENTS>} = ('<COMMENTS>numerical</COMMENTS>-<COMMENTS>comparison</COMMENTS>') <COMMENTS>x</COMMENTS> <COMMENTS>scalar</COMMENTS>(@<COMMENTS>list</COMMENTS>);
    #
    #    <COMMENTS>my</COMMENTS> @<COMMENTS>list</COMMENTS> = <COMMENTS>qw</COMMENTS>" && || ! &&= ||= //= ";
    #    @<COMMENTS>token_long_names</COMMENTS>{@<COMMENTS>list</COMMENTS>} = ('<COMMENTS>logical</COMMENTS>') <COMMENTS>x</COMMENTS> <COMMENTS>scalar</COMMENTS>(@<COMMENTS>list</COMMENTS>);
    #
    #    <COMMENTS>my</COMMENTS> @<COMMENTS>list</COMMENTS> = <COMMENTS>qw</COMMENTS>" . .= =~ !~ <COMMENTS>x</COMMENTS> <COMMENTS>x</COMMENTS>= ";
    #    @<COMMENTS>token_long_names</COMMENTS>{@<COMMENTS>list</COMMENTS>} = ('<COMMENTS>string</COMMENTS>-<COMMENTS>operators</COMMENTS>') <COMMENTS>x</COMMENTS> <COMMENTS>scalar</COMMENTS>(@<COMMENTS>list</COMMENTS>);
    #
    #    # <COMMENTS>Incomplete</COMMENTS>..
    #    <COMMENTS>my</COMMENTS> @<COMMENTS>list</COMMENTS> = <COMMENTS>qw</COMMENTS>" .. -> <> ... \ ? ";
    #    @<COMMENTS>token_long_names</COMMENTS>{@<COMMENTS>list</COMMENTS>} = ('<COMMENTS>misc</COMMENTS>-<COMMENTS>operators</COMMENTS>') <COMMENTS>x</COMMENTS> <COMMENTS>scalar</COMMENTS>(@<COMMENTS>list</COMMENTS>);

}

sub <CODE>make_getopt_long_names</CODE> {
    my $<CODE>class</CODE> = shift;
    my ($<CODE>rgetopt_names</CODE>) = @<CODE>_</CODE>;
    while ( my ( $<CODE>short_name</CODE>, $<CODE>name</CODE> ) = each %<CODE>short_to_long_names</CODE> ) {
        push @$<CODE>rgetopt_names</CODE>, "<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-$<CODE>name</CODE>=<LITERALS>s</LITERALS>";
        push @$<CODE>rgetopt_names</CODE>, "<LITERALS>html</LITERALS>-<LITERALS>italic</LITERALS>-$<CODE>name</CODE>!";
        push @$<CODE>rgetopt_names</CODE>, "<LITERALS>html</LITERALS>-<LITERALS>bold</LITERALS>-$<CODE>name</CODE>!";
    }
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-<LITERALS>background</LITERALS>=<LITERALS>s</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>html</LITERALS>-<LITERALS>linked</LITERALS>-<LITERALS>style</LITERALS>-<LITERALS>sheet</LITERALS>=<LITERALS>s</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>nohtml</LITERALS>-<LITERALS>style</LITERALS>-<LITERALS>sheets</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>html</LITERALS>-<LITERALS>pre</LITERALS>-<LITERALS>only</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>html</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>numbers</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>html</LITERALS>-<LITERALS>entities</LITERALS>!";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>stylesheet</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>html</LITERALS>-<LITERALS>table</LITERALS>-<LITERALS>of</LITERALS>-<LITERALS>contents</LITERALS>!";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>pod2html</LITERALS>!";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>frames</LITERALS>!";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>html</LITERALS>-<LITERALS>toc</LITERALS>-<LITERALS>extension</LITERALS>=<LITERALS>s</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>html</LITERALS>-<LITERALS>src</LITERALS>-<LITERALS>extension</LITERALS>=<LITERALS>s</LITERALS>";

    # <COMMENTS>Pod</COMMENTS>::<COMMENTS>Html</COMMENTS> <COMMENTS>parameters</COMMENTS>:
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>backlink</LITERALS>=<LITERALS>s</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>cachedir</LITERALS>=<LITERALS>s</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>htmlroot</LITERALS>=<LITERALS>s</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>libpods</LITERALS>=<LITERALS>s</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>podpath</LITERALS>=<LITERALS>s</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>podroot</LITERALS>=<LITERALS>s</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>title</LITERALS>=<LITERALS>s</LITERALS>";

    # <COMMENTS>Pod</COMMENTS>::<COMMENTS>Html</COMMENTS> <COMMENTS>parameters</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> '<COMMENTS>pod</COMMENTS>' <COMMENTS>which</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>removed</COMMENTS>
    # <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>Pod</COMMENTS>::<COMMENTS>Html</COMMENTS>
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>podquiet</LITERALS>!";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>podverbose</LITERALS>!";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>podrecurse</LITERALS>!";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>podflush</LITERALS>";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>podheader</LITERALS>!";
    push @$<CODE>rgetopt_names</CODE>, "<LITERALS>podindex</LITERALS>!";
}

sub <CODE>make_abbreviated_names</CODE> {

    # <COMMENTS>We</COMMENTS>'<COMMENTS>re</COMMENTS> <COMMENTS>appending</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>expansion</COMMENTS> <COMMENTS>list</COMMENTS>:
    #      '<COMMENTS>hcc</COMMENTS>'    => [<COMMENTS>qw</COMMENTS>(<COMMENTS>html</COMMENTS>-<COMMENTS>color</COMMENTS>-<COMMENTS>comment</COMMENTS>)],
    #      '<COMMENTS>hck</COMMENTS>'    => [<COMMENTS>qw</COMMENTS>(<COMMENTS>html</COMMENTS>-<COMMENTS>color</COMMENTS>-<COMMENTS>keyword</COMMENTS>)],
    #  <COMMENTS>etc</COMMENTS>
    my $<CODE>class</CODE> = shift;
    my ($<CODE>rexpansion</CODE>) = @<CODE>_</CODE>;

    # <COMMENTS>abbreviations</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>color</COMMENTS>/<COMMENTS>bold</COMMENTS>/<COMMENTS>italic</COMMENTS> <COMMENTS>properties</COMMENTS>
    while ( my ( $<CODE>short_name</CODE>, $<CODE>long_name</CODE> ) = each %<CODE>short_to_long_names</CODE> ) {
        ${$<CODE>rexpansion</CODE>}{"<LITERALS>hc</LITERALS>$<CODE>short_name</CODE>"}  = ["<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-$<CODE>long_name</CODE>"];
        ${$<CODE>rexpansion</CODE>}{"<LITERALS>hb</LITERALS>$<CODE>short_name</CODE>"}  = ["<LITERALS>html</LITERALS>-<LITERALS>bold</LITERALS>-$<CODE>long_name</CODE>"];
        ${$<CODE>rexpansion</CODE>}{"<LITERALS>hi</LITERALS>$<CODE>short_name</CODE>"}  = ["<LITERALS>html</LITERALS>-<LITERALS>italic</LITERALS>-$<CODE>long_name</CODE>"];
        ${$<CODE>rexpansion</CODE>}{"<LITERALS>nhb</LITERALS>$<CODE>short_name</CODE>"} = ["<LITERALS>nohtml</LITERALS>-<LITERALS>bold</LITERALS>-$<CODE>long_name</CODE>"];
        ${$<CODE>rexpansion</CODE>}{"<LITERALS>nhi</LITERALS>$<CODE>short_name</CODE>"} = ["<LITERALS>nohtml</LITERALS>-<LITERALS>italic</LITERALS>-$<CODE>long_name</CODE>"];
    }

    # <COMMENTS>abbreviations</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>options</COMMENTS>
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>hcbg</LITERALS>"}  = ["<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-<LITERALS>background</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>pre</LITERALS>"}   = ["<LITERALS>html</LITERALS>-<LITERALS>pre</LITERALS>-<LITERALS>only</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>toc</LITERALS>"}   = ["<LITERALS>html</LITERALS>-<LITERALS>table</LITERALS>-<LITERALS>of</LITERALS>-<LITERALS>contents</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>ntoc</LITERALS>"}  = ["<LITERALS>nohtml</LITERALS>-<LITERALS>table</LITERALS>-<LITERALS>of</LITERALS>-<LITERALS>contents</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>nnn</LITERALS>"}   = ["<LITERALS>html</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>numbers</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>hent</LITERALS>"}  = ["<LITERALS>html</LITERALS>-<LITERALS>entities</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>nhent</LITERALS>"} = ["<LITERALS>nohtml</LITERALS>-<LITERALS>entities</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>css</LITERALS>"}   = ["<LITERALS>html</LITERALS>-<LITERALS>linked</LITERALS>-<LITERALS>style</LITERALS>-<LITERALS>sheet</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>nss</LITERALS>"}   = ["<LITERALS>nohtml</LITERALS>-<LITERALS>style</LITERALS>-<LITERALS>sheets</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>ss</LITERALS>"}    = ["<LITERALS>stylesheet</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>pod</LITERALS>"}   = ["<LITERALS>pod2html</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>npod</LITERALS>"}  = ["<LITERALS>nopod2html</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>frm</LITERALS>"}   = ["<LITERALS>frames</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>nfrm</LITERALS>"}  = ["<LITERALS>noframes</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>text</LITERALS>"}  = ["<LITERALS>html</LITERALS>-<LITERALS>toc</LITERALS>-<LITERALS>extension</LITERALS>"];
    ${$<CODE>rexpansion</CODE>}{"<LITERALS>sext</LITERALS>"}  = ["<LITERALS>html</LITERALS>-<LITERALS>src</LITERALS>-<LITERALS>extension</LITERALS>"];
}

sub <CODE>check_options</CODE> {

    # <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>once</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>parsed</COMMENTS>
    my $<CODE>class</CODE> = shift;
    $<CODE>rOpts</CODE> = shift;

    # <COMMENTS>X11</COMMENTS> <COMMENTS>color</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>settings</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>seemed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>ok</COMMENTS>
    # (<COMMENTS>these</COMMENTS> <COMMENTS>color</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>programming</COMMENTS> <COMMENTS>clarity</COMMENTS>; <COMMENTS>the</COMMENTS> <COMMENTS>hex</COMMENTS>
    # <COMMENTS>numbers</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>actually</COMMENTS> <COMMENTS>written</COMMENTS>)
    use <CODE>constant</CODE> <LITERALS>ForestGreen</LITERALS>   => "#<LITERALS>228B22</LITERALS>";
    use <CODE>constant</CODE> <LITERALS>SaddleBrown</LITERALS>   => "#<LITERALS>8B4513</LITERALS>";
    use <CODE>constant</CODE> <LITERALS>magenta4</LITERALS>      => "#<LITERALS>8B008B</LITERALS>";
    use <CODE>constant</CODE> <LITERALS>IndianRed3</LITERALS>    => "#<LITERALS>CD5555</LITERALS>";
    use <CODE>constant</CODE> <LITERALS>DeepSkyBlue4</LITERALS>  => "#<LITERALS>00688B</LITERALS>";
    use <CODE>constant</CODE> <LITERALS>MediumOrchid3</LITERALS> => "#<LITERALS>B452CD</LITERALS>";
    use <CODE>constant</CODE> <LITERALS>black</LITERALS>         => "#<LITERALS>000000</LITERALS>";
    use <CODE>constant</CODE> <LITERALS>white</LITERALS>         => "#<LITERALS>FFFFFF</LITERALS>";
    use <CODE>constant</CODE> <LITERALS>red</LITERALS>           => "#<LITERALS>FF0000</LITERALS>";

    # <COMMENTS>set</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>color</COMMENTS>, <COMMENTS>bold</COMMENTS>, <COMMENTS>italic</COMMENTS> <COMMENTS>properties</COMMENTS>
    # <COMMENTS>anything</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>listed</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS> (<COMMENTS>punctuation</COMMENTS>) <COMMENTS>color</COMMENTS> --
    # <COMMENTS>these</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>currently</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>listed</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>default</COMMENTS>: <COMMENTS>ws</COMMENTS> <COMMENTS>pu</COMMENTS> <COMMENTS>s</COMMENTS> <COMMENTS>sc</COMMENTS> <COMMENTS>cm</COMMENTS> <COMMENTS>co</COMMENTS> <COMMENTS>p</COMMENTS>
    # <COMMENTS>When</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>NEW_TOKENS</COMMENTS>: <COMMENTS>add</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>entry</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>defaults</COMMENTS>

    # <COMMENTS>set_default_properties</COMMENTS>( <COMMENTS>$short_name</COMMENTS>, <COMMENTS>default_color</COMMENTS>, <COMMENTS>bold</COMMENTS>?, <COMMENTS>italic</COMMENTS>? );
    <CODE>set_default_properties</CODE>( '<LITERALS>c</LITERALS>',  <CODE>ForestGreen</CODE>,   0, 0 );
    <CODE>set_default_properties</CODE>( '<LITERALS>pd</LITERALS>', <CODE>ForestGreen</CODE>,   0, 1 );
    <CODE>set_default_properties</CODE>( '<LITERALS>k</LITERALS>',  <CODE>magenta4</CODE>,      1, 0 );    # <COMMENTS>was</COMMENTS> <COMMENTS>SaddleBrown</COMMENTS>
    <CODE>set_default_properties</CODE>( '<LITERALS>q</LITERALS>',  <CODE>IndianRed3</CODE>,    0, 0 );
    <CODE>set_default_properties</CODE>( '<LITERALS>hh</LITERALS>', <CODE>IndianRed3</CODE>,    0, 1 );
    <CODE>set_default_properties</CODE>( '<LITERALS>h</LITERALS>',  <CODE>IndianRed3</CODE>,    1, 0 );
    <CODE>set_default_properties</CODE>( '<LITERALS>i</LITERALS>',  <CODE>DeepSkyBlue4</CODE>,  0, 0 );
    <CODE>set_default_properties</CODE>( '<LITERALS>w</LITERALS>',  <CODE>black</CODE>,         0, 0 );
    <CODE>set_default_properties</CODE>( '<LITERALS>n</LITERALS>',  <CODE>MediumOrchid3</CODE>, 0, 0 );
    <CODE>set_default_properties</CODE>( '<LITERALS>v</LITERALS>',  <CODE>MediumOrchid3</CODE>, 0, 0 );
    <CODE>set_default_properties</CODE>( '<LITERALS>j</LITERALS>',  <CODE>IndianRed3</CODE>,    1, 0 );
    <CODE>set_default_properties</CODE>( '<LITERALS>m</LITERALS>',  <CODE>red</CODE>,           1, 0 );

    <CODE>set_default_color</CODE>( '<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-<LITERALS>background</LITERALS>',  <CODE>white</CODE> );
    <CODE>set_default_color</CODE>( '<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-<LITERALS>punctuation</LITERALS>', <CODE>black</CODE> );

    # <COMMENTS>setup</COMMENTS> <COMMENTS>property</COMMENTS> <COMMENTS>lookup</COMMENTS> <COMMENTS>tables</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>based</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>names</COMMENTS>
    # <COMMENTS>every</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>name</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>tables</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>markup</COMMENTS>
    while ( my ( $<CODE>short_name</CODE>, $<CODE>long_name</CODE> ) = each %<CODE>short_to_long_names</CODE> ) {
        $<CODE>html_color</CODE>{$<CODE>short_name</CODE>}  = $<CODE>rOpts</CODE>->{"<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-$<CODE>long_name</CODE>"};
        $<CODE>html_bold</CODE>{$<CODE>short_name</CODE>}   = $<CODE>rOpts</CODE>->{"<LITERALS>html</LITERALS>-<LITERALS>bold</LITERALS>-$<CODE>long_name</CODE>"};
        $<CODE>html_italic</CODE>{$<CODE>short_name</CODE>} = $<CODE>rOpts</CODE>->{"<LITERALS>html</LITERALS>-<LITERALS>italic</LITERALS>-$<CODE>long_name</CODE>"};
    }

    # <COMMENTS>write</COMMENTS> <COMMENTS>style</COMMENTS> <COMMENTS>sheet</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>STDOUT</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>die</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS>
    if ( defined( $<CODE>rOpts</CODE>->{'<LITERALS>stylesheet</LITERALS>'} ) ) {
        <CODE>write_style_sheet_file</CODE>('-');
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Exit</CODE> 0;
    }

    # <COMMENTS>make</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>gives</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>after</COMMENTS> -<COMMENTS>css</COMMENTS>
    if ( defined( $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>linked</LITERALS>-<LITERALS>style</LITERALS>-<LITERALS>sheet</LITERALS>'} ) ) {
        $<CODE>css_linkname</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>linked</LITERALS>-<LITERALS>style</LITERALS>-<LITERALS>sheet</LITERALS>'};
        if ( $<CODE>css_linkname</CODE> =~ /^-/ ) {
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE> "<LITERALS>You</LITERALS> <LITERALS>must</LITERALS> <LITERALS>specify</LITERALS> <LITERALS>a</LITERALS> <LITERALS>valid</LITERALS> <LITERALS>filename</LITERALS> <LITERALS>after</LITERALS> -<LITERALS>css</LITERALS>\n";
        }
    }

    # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>conflict</COMMENTS>
    if ( $<CODE>css_linkname</CODE> && $<CODE>rOpts</CODE>->{'<LITERALS>nohtml</LITERALS>-<LITERALS>style</LITERALS>-<LITERALS>sheets</LITERALS>'} ) {
        $<CODE>rOpts</CODE>->{'<LITERALS>nohtml</LITERALS>-<LITERALS>style</LITERALS>-<LITERALS>sheets</LITERALS>'} = 0;
        <CODE>warning</CODE>("<LITERALS>You</LITERALS> <LITERALS>can</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>specify</LITERALS> <LITERALS>both</LITERALS> -<LITERALS>css</LITERALS> <LITERALS>and</LITERALS> -<LITERALS>nss</LITERALS>; -<LITERALS>nss</LITERALS> <LITERALS>ignored</LITERALS>\n");
    }

    # <COMMENTS>write</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>style</COMMENTS> <COMMENTS>sheet</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
    if ($<CODE>css_linkname</CODE>) {

        # <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>selected</COMMENTS> <COMMENTS>filename</COMMENTS> <COMMENTS>exists</COMMENTS>, <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>write</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>may</COMMENTS>
        # <COMMENTS>have</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>hand</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>it</COMMENTS>; <COMMENTS>use</COMMENTS> <COMMENTS>backup</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>instead</COMMENTS>
        # <COMMENTS>Also</COMMENTS>, <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>potential</COMMENTS> <COMMENTS>disaster</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS>
        # <COMMENTS>forgets</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>specify</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>style</COMMENTS> <COMMENTS>sheet</COMMENTS>, <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
        #    <COMMENTS>perltidy</COMMENTS> -<COMMENTS>html</COMMENTS> -<COMMENTS>css</COMMENTS> <COMMENTS>myfile1</COMMENTS>.<COMMENTS>pl</COMMENTS> <COMMENTS>myfile2</COMMENTS>.<COMMENTS>pl</COMMENTS>
        # <COMMENTS>This</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>myfile1</COMMENTS>.<COMMENTS>pl</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>parsed</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>style</COMMENTS> <COMMENTS>sheet</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>GetOpts</COMMENTS>
        my $<CODE>css_filename</CODE> = $<CODE>css_linkname</CODE>;
        unless ( -e $<CODE>css_filename</CODE> ) {
            <CODE>write_style_sheet_file</CODE>($<CODE>css_filename</CODE>);
        }
    }
    $<CODE>missing_html_entities</CODE> = 1 unless $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>entities</LITERALS>'};
}

sub <CODE>write_style_sheet_file</CODE> {

    my $<CODE>css_filename</CODE> = shift;
    my $<CODE>fh</CODE>;
    unless ( $<CODE>fh</CODE> = <CODE>IO</CODE>::<CODE>File</CODE>-><CODE>new</CODE>("> $<CODE>css_filename</CODE>") ) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE> "<LITERALS>can</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>open</LITERALS> $<CODE>css_filename</CODE>: $!\n";
    }
    <CODE>write_style_sheet_data</CODE>($<CODE>fh</CODE>);
    eval { $<CODE>fh</CODE>-><CODE>close</CODE> };
}

sub <CODE>write_style_sheet_data</CODE> {

    # <COMMENTS>write</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>style</COMMENTS> <COMMENTS>sheet</COMMENTS> <COMMENTS>data</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>handle</COMMENTS>
    my $<CODE>fh</CODE> = shift;

    my $<CODE>bg_color</CODE>   = $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-<LITERALS>background</LITERALS>'};
    my $<CODE>text_color</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-<LITERALS>punctuation</LITERALS>'};

    # <COMMENTS>pre</COMMENTS>-<COMMENTS>bgcolor</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>new</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>defined</COMMENTS>
    my $<CODE>pre_bg_color</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>pre</LITERALS>-<LITERALS>color</LITERALS>-<LITERALS>background</LITERALS>'};
    $<CODE>pre_bg_color</CODE> = $<CODE>bg_color</CODE> unless $<CODE>pre_bg_color</CODE>;

    $<CODE>fh</CODE>-><CODE>print</CODE>(<<"<LITERALS>EOM</LITERALS>");
/* <LITERALS>default</LITERALS> <LITERALS>style</LITERALS> <LITERALS>sheet</LITERALS> <LITERALS>generated</LITERALS> <LITERALS>by</LITERALS> <LITERALS>perltidy</LITERALS> */
<LITERALS>body</LITERALS> {<LITERALS>background</LITERALS>: $<CODE>bg_color</CODE>; <LITERALS>color</LITERALS>: $<CODE>text_color</CODE>}
<LITERALS>pre</LITERALS> { <LITERALS>color</LITERALS>: $<CODE>text_color</CODE>;
      <LITERALS>background</LITERALS>: $<CODE>pre_bg_color</CODE>;
      <LITERALS>font</LITERALS>-<LITERALS>family</LITERALS>: <LITERALS>courier</LITERALS>;
    }

<CODE>EOM</CODE>

    foreach my $<CODE>short_name</CODE> ( sort keys %<CODE>short_to_long_names</CODE> ) {
        my $<CODE>long_name</CODE> = $<CODE>short_to_long_names</CODE>{$<CODE>short_name</CODE>};

        my $<CODE>abbrev</CODE> = '.' . $<CODE>short_name</CODE>;
        if ( length($<CODE>short_name</CODE>) == 1 ) { $<CODE>abbrev</CODE> .= ' ' }    # <COMMENTS>for</COMMENTS> <COMMENTS>alignment</COMMENTS>
        my $<CODE>color</CODE> = $<CODE>html_color</CODE>{$<CODE>short_name</CODE>};
        if ( !defined($<CODE>color</CODE>) ) { $<CODE>color</CODE> = $<CODE>text_color</CODE> }
        $<CODE>fh</CODE>-><CODE>print</CODE>("$<CODE>abbrev</CODE> \{ <LITERALS>color</LITERALS>: $<CODE>color</CODE>;");

        if ( $<CODE>html_bold</CODE>{$<CODE>short_name</CODE>} ) {
            $<CODE>fh</CODE>-><CODE>print</CODE>(" <LITERALS>font</LITERALS>-<LITERALS>weight</LITERALS>:<LITERALS>bold</LITERALS>;");
        }

        if ( $<CODE>html_italic</CODE>{$<CODE>short_name</CODE>} ) {
            $<CODE>fh</CODE>-><CODE>print</CODE>(" <LITERALS>font</LITERALS>-<LITERALS>style</LITERALS>:<LITERALS>italic</LITERALS>;");
        }
        $<CODE>fh</CODE>-><CODE>print</CODE>("} /* $<CODE>long_name</CODE> */\n");
    }
}

sub <CODE>set_default_color</CODE> {

    # <COMMENTS>make</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>$rOpts</COMMENTS>->{<COMMENTS>$key</COMMENTS>} <COMMENTS>contains</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>color</COMMENTS>
    my ( $<CODE>key</CODE>, $<CODE>color</CODE> ) = @<CODE>_</CODE>;
    if ( $<CODE>rOpts</CODE>->{$<CODE>key</CODE>} ) { $<CODE>color</CODE> = $<CODE>rOpts</CODE>->{$<CODE>key</CODE>} }
    $<CODE>rOpts</CODE>->{$<CODE>key</CODE>} = <CODE>check_RGB</CODE>($<CODE>color</CODE>);
}

sub <CODE>check_RGB</CODE> {

    # <COMMENTS>if</COMMENTS> <COMMENTS>color</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>6</COMMENTS> <COMMENTS>digit</COMMENTS> <COMMENTS>hex</COMMENTS> <COMMENTS>RGB</COMMENTS> <COMMENTS>value</COMMENTS>, <COMMENTS>prepend</COMMENTS> <COMMENTS>a</COMMENTS> #, <COMMENTS>otherwise</COMMENTS>
    # <COMMENTS>assume</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>ascii</COMMENTS> <COMMENTS>color</COMMENTS> <COMMENTS>name</COMMENTS>
    my ($<CODE>color</CODE>) = @<CODE>_</CODE>;
    if ( $<CODE>color</CODE> =~ /^[0-9a-fA-F]{6,6}$/ ) { $<CODE>color</CODE> = "#$<CODE>color</CODE>" }
    return $<CODE>color</CODE>;
}

sub <CODE>set_default_properties</CODE> {
    my ( $<CODE>short_name</CODE>, $<CODE>color</CODE>, $<CODE>bold</CODE>, $<CODE>italic</CODE> ) = @<CODE>_</CODE>;

    <CODE>set_default_color</CODE>( "<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-$<CODE>short_to_long_names</CODE>{$<CODE>short_name</CODE>}", $<CODE>color</CODE> );
    my $<CODE>key</CODE>;
    $<CODE>key</CODE> = "<LITERALS>html</LITERALS>-<LITERALS>bold</LITERALS>-$<CODE>short_to_long_names</CODE>{$<CODE>short_name</CODE>}";
    $<CODE>rOpts</CODE>->{$<CODE>key</CODE>} = ( defined $<CODE>rOpts</CODE>->{$<CODE>key</CODE>} ) ? $<CODE>rOpts</CODE>->{$<CODE>key</CODE>} : $<CODE>bold</CODE>;
    $<CODE>key</CODE> = "<LITERALS>html</LITERALS>-<LITERALS>italic</LITERALS>-$<CODE>short_to_long_names</CODE>{$<CODE>short_name</CODE>}";
    $<CODE>rOpts</CODE>->{$<CODE>key</CODE>} = ( defined $<CODE>rOpts</CODE>->{$<CODE>key</CODE>} ) ? $<CODE>rOpts</CODE>->{$<CODE>key</CODE>} : $<CODE>italic</CODE>;
}

sub <CODE>pod_to_html</CODE> {

    # <COMMENTS>Use</COMMENTS> <COMMENTS>Pod</COMMENTS>::<COMMENTS>Html</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>process</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>page</COMMENTS>
    # <COMMENTS>then</COMMENTS> <COMMENTS>merge</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>sections</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>it</COMMENTS>.
    # <COMMENTS>return</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>success</COMMENTS>, <COMMENTS>0</COMMENTS> <COMMENTS>otherwise</COMMENTS>
    my $<CODE>self</CODE> = shift;
    my ( $<CODE>pod_string</CODE>, $<CODE>css_string</CODE>, $<CODE>toc_string</CODE>, $<CODE>rpre_string_stack</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>input_file</CODE>   = $<CODE>self</CODE>->{<LITERALS>_input_file</LITERALS>};
    my $<CODE>title</CODE>        = $<CODE>self</CODE>->{<LITERALS>_title</LITERALS>};
    my $<CODE>success_flag</CODE> = 0;

    # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>pod2html</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>pod</COMMENTS>
    unless ($<CODE>pod_string</CODE>) {
        return $<CODE>success_flag</CODE>;
    }

    # <COMMENTS>Pod</COMMENTS>::<COMMENTS>Html</COMMENTS> <COMMENTS>requires</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>real</COMMENTS> <COMMENTS>temporary</COMMENTS> <COMMENTS>filename</COMMENTS>
    my ( $<CODE>fh_tmp</CODE>, $<CODE>tmpfile</CODE> ) = <CODE>File</CODE>::<CODE>Temp</CODE>::<CODE>tempfile</CODE>();
    unless ($<CODE>fh_tmp</CODE>) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE>
          "<LITERALS>unable</LITERALS> <LITERALS>to</LITERALS> <LITERALS>open</LITERALS> <LITERALS>temporary</LITERALS> <LITERALS>file</LITERALS> $<CODE>tmpfile</CODE>; <LITERALS>cannot</LITERALS> <LITERALS>use</LITERALS> <LITERALS>pod2html</LITERALS>\n";
        return $<CODE>success_flag</CODE>;
    }

    #------------------------------------------------------------------
    # <COMMENTS>Warning</COMMENTS>: <COMMENTS>a</COMMENTS> <COMMENTS>temporary</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>open</COMMENTS>; <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>clean</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>if</COMMENTS>
    # <COMMENTS>things</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>bad</COMMENTS>.  <COMMENTS>From</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>returns</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>going</COMMENTS> <COMMENTS>to</COMMENTS>
    # <COMMENTS>RETURN</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>temporary</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>gets</COMMENTS> <COMMENTS>unlinked</COMMENTS>.
    #------------------------------------------------------------------

    # <COMMENTS>write</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>temporary</COMMENTS> <COMMENTS>file</COMMENTS>
    $<CODE>fh_tmp</CODE>-><CODE>print</CODE>($<CODE>pod_string</CODE>);
    $<CODE>fh_tmp</CODE>-><CODE>close</CODE>();

    # <COMMENTS>Hand</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>pod2html</COMMENTS>.
    # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>temporary</COMMENTS> <COMMENTS>filename</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>output</COMMENTS>
    # <COMMENTS>because</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>way</COMMENTS> <COMMENTS>pod2html</COMMENTS> <COMMENTS>works</COMMENTS>.
    {

        my @<CODE>args</CODE>;
        push @<CODE>args</CODE>, "--<LITERALS>infile</LITERALS>=$<CODE>tmpfile</CODE>", "--<LITERALS>outfile</LITERALS>=$<CODE>tmpfile</CODE>", "--<LITERALS>title</LITERALS>=$<CODE>title</CODE>";
        my $<CODE>kw</CODE>;

        # <COMMENTS>Flags</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>args</COMMENTS>:
        # "<COMMENTS>backlink</COMMENTS>=<COMMENTS>s</COMMENTS>", "<COMMENTS>cachedir</COMMENTS>=<COMMENTS>s</COMMENTS>", "<COMMENTS>htmlroot</COMMENTS>=<COMMENTS>s</COMMENTS>", "<COMMENTS>libpods</COMMENTS>=<COMMENTS>s</COMMENTS>",
        # "<COMMENTS>podpath</COMMENTS>=<COMMENTS>s</COMMENTS>", "<COMMENTS>podroot</COMMENTS>=<COMMENTS>s</COMMENTS>"
        # <COMMENTS>Note</COMMENTS>: -<COMMENTS>css</COMMENTS>=<COMMENTS>s</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>itself</COMMENTS>
        foreach $<CODE>kw</CODE> (qw(<LITERALS>backlink</LITERALS> <LITERALS>cachedir</LITERALS> <LITERALS>htmlroot</LITERALS> <LITERALS>libpods</LITERALS> <LITERALS>podpath</LITERALS> <LITERALS>podroot</LITERALS>)) {
            if ( $<CODE>rOpts</CODE>->{$<CODE>kw</CODE>} ) { push @<CODE>args</CODE>, "--$<CODE>kw</CODE>=$<CODE>rOpts</CODE>->{$<CODE>kw</CODE>}" }
        }

        # <COMMENTS>Toggle</COMMENTS> <COMMENTS>switches</COMMENTS>; <COMMENTS>these</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>leading</COMMENTS> '<COMMENTS>pod</COMMENTS>'
        # "<COMMENTS>header</COMMENTS>!", "<COMMENTS>index</COMMENTS>!", "<COMMENTS>recurse</COMMENTS>!", "<COMMENTS>quiet</COMMENTS>!", "<COMMENTS>verbose</COMMENTS>!"
        foreach $<CODE>kw</CODE> (qw(<LITERALS>podheader</LITERALS> <LITERALS>podindex</LITERALS> <LITERALS>podrecurse</LITERALS> <LITERALS>podquiet</LITERALS> <LITERALS>podverbose</LITERALS>)) {
            my $<CODE>kwd</CODE> = $<CODE>kw</CODE>;    # <COMMENTS>allows</COMMENTS> <COMMENTS>us</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>strip</COMMENTS> '<COMMENTS>pod</COMMENTS>'
            if ( $<CODE>rOpts</CODE>->{$<CODE>kw</CODE>} ) { $<CODE>kwd</CODE> =~ s/^pod//; push @<CODE>args</CODE>, "--$<CODE>kwd</CODE>" }
            elsif ( defined( $<CODE>rOpts</CODE>->{$<CODE>kw</CODE>} ) ) {
                $<CODE>kwd</CODE> =~ s/^pod//;
                push @<CODE>args</CODE>, "--<LITERALS>no</LITERALS>$<CODE>kwd</CODE>";
            }
        }

        # "<COMMENTS>flush</COMMENTS>",
        $<CODE>kw</CODE> = '<LITERALS>podflush</LITERALS>';
        if ( $<CODE>rOpts</CODE>->{$<CODE>kw</CODE>} ) { $<CODE>kw</CODE> =~ s/^pod//; push @<CODE>args</CODE>, "--$<CODE>kw</CODE>" }

        # <COMMENTS>Must</COMMENTS> <COMMENTS>clean</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>pod2html</COMMENTS> <COMMENTS>dies</COMMENTS> (<COMMENTS>it</COMMENTS> <COMMENTS>can</COMMENTS>);
        # <COMMENTS>Be</COMMENTS> <COMMENTS>careful</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>overwrite</COMMENTS> <COMMENTS>callers</COMMENTS> <COMMENTS>__DIE__</COMMENTS> <COMMENTS>routine</COMMENTS>
        local $<CODE>SIG</CODE>{<LITERALS>__DIE__</LITERALS>} = sub {
            unlink $<CODE>tmpfile</CODE> if -e $<CODE>tmpfile</CODE>;
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE> $<CODE>_</CODE>[0];
        };

        <CODE>pod2html</CODE>(@<CODE>args</CODE>);
    }
    $<CODE>fh_tmp</CODE> = <CODE>IO</CODE>::<CODE>File</CODE>-><CODE>new</CODE>( $<CODE>tmpfile</CODE>, '<LITERALS>r</LITERALS>' );
    unless ($<CODE>fh_tmp</CODE>) {

        # <COMMENTS>this</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS> ... <COMMENTS>we</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>filename</COMMENTS>
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE>
          "<LITERALS>unable</LITERALS> <LITERALS>to</LITERALS> <LITERALS>open</LITERALS> <LITERALS>temporary</LITERALS> <LITERALS>file</LITERALS> $<CODE>tmpfile</CODE>; <LITERALS>cannot</LITERALS> <LITERALS>use</LITERALS> <LITERALS>pod2html</LITERALS>\n";
        goto <CODE>RETURN</CODE>;
    }

    my $<CODE>html_fh</CODE> = $<CODE>self</CODE>->{<LITERALS>_html_fh</LITERALS>};
    my @<CODE>toc</CODE>;
    my $<CODE>in_toc</CODE>;
    my $<CODE>ul_level</CODE> = 0;
    my $<CODE>no_print</CODE>;

    # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>selectively</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>store</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>toc</COMMENTS>
    my $<CODE>html_print</CODE> = sub {
        foreach (@<CODE>_</CODE>) {
            $<CODE>html_fh</CODE>-><CODE>print</CODE>($<CODE>_</CODE>) unless ($<CODE>no_print</CODE>);
            if ($<CODE>in_toc</CODE>) { push @<CODE>toc</CODE>, $<CODE>_</CODE> }
        }
    };

    # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>pod2html</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>merge</COMMENTS> <COMMENTS>in</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>sections</COMMENTS>
    my ( $<CODE>saw_body</CODE>, $<CODE>saw_index</CODE>, $<CODE>saw_body_end</CODE> );
    while ( my $<CODE>line</CODE> = $<CODE>fh_tmp</CODE>-><CODE>getline</CODE>() ) {

        if ( $<CODE>line</CODE> =~ /^\s*<html>\s*$/i ) {
            my $<CODE>date</CODE> = localtime;
            $<CODE>html_print</CODE>->("<!-- <LITERALS>Generated</LITERALS> <LITERALS>by</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>on</LITERALS> $<CODE>date</CODE> -->\n");
            $<CODE>html_print</CODE>->($<CODE>line</CODE>);
        }

        # <COMMENTS>Copy</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>css</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS>, <COMMENTS>after</COMMENTS> <<COMMENTS>body</COMMENTS>> <COMMENTS>tag</COMMENTS>
        elsif ( $<CODE>line</CODE> =~ /^\s*<body.*>\s*$/i ) {
            $<CODE>saw_body</CODE> = 1;
            $<CODE>html_print</CODE>->($<CODE>css_string</CODE>) if $<CODE>css_string</CODE>;
            $<CODE>html_print</CODE>->($<CODE>line</CODE>);

            # <COMMENTS>add</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>top</COMMENTS> <COMMENTS>anchor</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>heading</COMMENTS>
            $<CODE>html_print</CODE>->("<<LITERALS>a</LITERALS> <LITERALS>name</LITERALS>=\"-<LITERALS>top</LITERALS>-\"></<LITERALS>a</LITERALS>>\n");
            $<CODE>title</CODE> = <CODE>escape_html</CODE>($<CODE>title</CODE>);
            $<CODE>html_print</CODE>->("<<LITERALS>h1</LITERALS>>$<CODE>title</CODE></<LITERALS>h1</LITERALS>>\n");
        }

        # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>index</COMMENTS>, <COMMENTS>old</COMMENTS> <COMMENTS>pod2html</COMMENTS>
        # <COMMENTS>before</COMMENTS> <COMMENTS>Pod</COMMENTS>::<COMMENTS>Html</COMMENTS> <COMMENTS>VERSION</COMMENTS> <COMMENTS>1</COMMENTS>.<COMMENTS>15_02</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>delimited</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>as</COMMENTS>:
        #    <!-- <COMMENTS>INDEX</COMMENTS> <COMMENTS>BEGIN</COMMENTS> -->
        #    <<COMMENTS>ul</COMMENTS>>
        #     ...
        #    </<COMMENTS>ul</COMMENTS>>
        #    <!-- <COMMENTS>INDEX</COMMENTS> <COMMENTS>END</COMMENTS> -->
        #
        elsif ( $<CODE>line</CODE> =~ /^\s*<!-- INDEX BEGIN -->\s*$/i ) {
            $<CODE>in_toc</CODE> = '<LITERALS>INDEX</LITERALS>';

            # <COMMENTS>when</COMMENTS> <COMMENTS>frames</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>used</COMMENTS>, <COMMENTS>an</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>contents</COMMENTS> <COMMENTS>panel</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>confusing</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>print</COMMENTS> <COMMENTS>it</COMMENTS>
            $<CODE>no_print</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>frames</LITERALS>'}
              || !$<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>table</LITERALS>-<LITERALS>of</LITERALS>-<LITERALS>contents</LITERALS>'};
            $<CODE>html_print</CODE>->("<<LITERALS>h2</LITERALS>><LITERALS>Doc</LITERALS> <LITERALS>Index</LITERALS>:</<LITERALS>h2</LITERALS>>\n") if $<CODE>rOpts</CODE>->{'<LITERALS>frames</LITERALS>'};
            $<CODE>html_print</CODE>->($<CODE>line</CODE>);
        }

        # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>index</COMMENTS>, <COMMENTS>new</COMMENTS> <COMMENTS>pod2html</COMMENTS>
        # <COMMENTS>After</COMMENTS> <COMMENTS>Pod</COMMENTS>::<COMMENTS>Html</COMMENTS> <COMMENTS>VERSION</COMMENTS> <COMMENTS>1</COMMENTS>.<COMMENTS>15_02</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>delimited</COMMENTS> <COMMENTS>as</COMMENTS>:
        # <<COMMENTS>ul</COMMENTS> <COMMENTS>id</COMMENTS>="<COMMENTS>index</COMMENTS>">
        # ...
        # </<COMMENTS>ul</COMMENTS>>
        elsif ( $<CODE>line</CODE> =~ /^\s*<ul\s+id="index">/i ) {
            $<CODE>in_toc</CODE>   = '<LITERALS>UL</LITERALS>';
            $<CODE>ul_level</CODE> = 1;

            # <COMMENTS>when</COMMENTS> <COMMENTS>frames</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>used</COMMENTS>, <COMMENTS>an</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>contents</COMMENTS> <COMMENTS>panel</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>confusing</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>print</COMMENTS> <COMMENTS>it</COMMENTS>
            $<CODE>no_print</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>frames</LITERALS>'}
              || !$<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>table</LITERALS>-<LITERALS>of</LITERALS>-<LITERALS>contents</LITERALS>'};
            $<CODE>html_print</CODE>->("<<LITERALS>h2</LITERALS>><LITERALS>Doc</LITERALS> <LITERALS>Index</LITERALS>:</<LITERALS>h2</LITERALS>>\n") if $<CODE>rOpts</CODE>->{'<LITERALS>frames</LITERALS>'};
            $<CODE>html_print</CODE>->($<CODE>line</CODE>);
        }

        # <COMMENTS>Check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>index</COMMENTS>, <COMMENTS>old</COMMENTS> <COMMENTS>pod2html</COMMENTS>
        elsif ( $<CODE>line</CODE> =~ /^\s*<!-- INDEX END -->\s*$/i ) {
            $<CODE>saw_index</CODE> = 1;
            $<CODE>html_print</CODE>->($<CODE>line</CODE>);

            # <COMMENTS>Copy</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>toc</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS>, <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>Pod</COMMENTS>::<COMMENTS>Html</COMMENTS> <COMMENTS>toc</COMMENTS>
            if ($<CODE>toc_string</CODE>) {
                $<CODE>html_print</CODE>->("<<LITERALS>hr</LITERALS> />\n") if $<CODE>rOpts</CODE>->{'<LITERALS>frames</LITERALS>'};
                $<CODE>html_print</CODE>->("<<LITERALS>h2</LITERALS>><LITERALS>Code</LITERALS> <LITERALS>Index</LITERALS>:</<LITERALS>h2</LITERALS>>\n");
                my @<CODE>toc</CODE> = map { $<CODE>_</CODE> .= "\n" } split /\n/, $<CODE>toc_string</CODE>;
                $<CODE>html_print</CODE>->(@<CODE>toc</CODE>);
            }
            $<CODE>in_toc</CODE>   = "";
            $<CODE>no_print</CODE> = 0;
        }

        # <COMMENTS>must</COMMENTS> <COMMENTS>track</COMMENTS> <<COMMENTS>ul</COMMENTS>> <COMMENTS>depth</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>pod2html</COMMENTS>
        elsif ( $<CODE>line</CODE> =~ /\s*<ul>\s*$/i && $<CODE>in_toc</CODE> eq '<LITERALS>UL</LITERALS>' ) {
            $<CODE>ul_level</CODE>++;
            $<CODE>html_print</CODE>->($<CODE>line</CODE>);
        }

        # <COMMENTS>Check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>index</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>pod2html</COMMENTS>
        elsif ( $<CODE>line</CODE> =~ /\s*<\/ul>/i && $<CODE>in_toc</CODE> eq '<LITERALS>UL</LITERALS>' ) {
            $<CODE>ul_level</CODE>--;
            $<CODE>html_print</CODE>->($<CODE>line</CODE>);

            # <COMMENTS>Copy</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>toc</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS>, <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>Pod</COMMENTS>::<COMMENTS>Html</COMMENTS> <COMMENTS>toc</COMMENTS>
            if ( $<CODE>ul_level</CODE> <= 0 ) {
                $<CODE>saw_index</CODE> = 1;
                if ($<CODE>toc_string</CODE>) {
                    $<CODE>html_print</CODE>->("<<LITERALS>hr</LITERALS> />\n") if $<CODE>rOpts</CODE>->{'<LITERALS>frames</LITERALS>'};
                    $<CODE>html_print</CODE>->("<<LITERALS>h2</LITERALS>><LITERALS>Code</LITERALS> <LITERALS>Index</LITERALS>:</<LITERALS>h2</LITERALS>>\n");
                    my @<CODE>toc</CODE> = map { $<CODE>_</CODE> .= "\n" } split /\n/, $<CODE>toc_string</CODE>;
                    $<CODE>html_print</CODE>->(@<CODE>toc</CODE>);
                }
                $<CODE>in_toc</CODE>   = "";
                $<CODE>ul_level</CODE> = 0;
                $<CODE>no_print</CODE> = 0;
            }
        }

        # <COMMENTS>Copy</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>marker</COMMENTS>
        elsif ( $<CODE>line</CODE> =~ /^(.*)<!-- pERLTIDY sECTION -->(.*)$/ ) {
            $<CODE>line</CODE> = $<CODE>2</CODE>;
            $<CODE>html_print</CODE>->($<CODE>1</CODE>) if $<CODE>1</CODE>;

            # <COMMENTS>Intermingle</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>sections</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>saw</COMMENTS> <COMMENTS>multiple</COMMENTS> =<COMMENTS>cut</COMMENTS>'<COMMENTS>s</COMMENTS>.
            if ( $<CODE>self</CODE>->{<LITERALS>_pod_cut_count</LITERALS>} > 1 ) {
                my $<CODE>rpre_string</CODE> = shift(@$<CODE>rpre_string_stack</CODE>);
                if ($$<CODE>rpre_string</CODE>) {
                    $<CODE>html_print</CODE>->('<<LITERALS>pre</LITERALS>>');
                    $<CODE>html_print</CODE>->($$<CODE>rpre_string</CODE>);
                    $<CODE>html_print</CODE>->('</<LITERALS>pre</LITERALS>>');
                }
                else {

                    # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>: <COMMENTS>we</COMMENTS> <COMMENTS>stored</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>writing</COMMENTS>
                    # <COMMENTS>each</COMMENTS> <COMMENTS>marker</COMMENTS>.
                    <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE>
"<LITERALS>Problem</LITERALS> <LITERALS>merging</LITERALS> <LITERALS>html</LITERALS> <LITERALS>stream</LITERALS> <LITERALS>with</LITERALS> <LITERALS>pod2html</LITERALS>; <LITERALS>order</LITERALS> <LITERALS>may</LITERALS> <LITERALS>be</LITERALS> <LITERALS>wrong</LITERALS>\n";
                }
                $<CODE>html_print</CODE>->($<CODE>line</CODE>);
            }

            # <COMMENTS>If</COMMENTS> <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>multiple</COMMENTS> =<COMMENTS>cut</COMMENTS> <COMMENTS>lines</COMMENTS>, <COMMENTS>we</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>first</COMMENTS>
            # <COMMENTS>and</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>code</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>less</COMMENTS> <COMMENTS>confusing</COMMENTS>.
            else {

                # <COMMENTS>since</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>intermixing</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>pod</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>need</COMMENTS>
                # <COMMENTS>or</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>any</COMMENTS> <<COMMENTS>hr</COMMENTS>> <COMMENTS>lines</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>separated</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>code</COMMENTS>
                $<CODE>html_print</CODE>->($<CODE>line</CODE>) unless ( $<CODE>line</CODE> =~ /^\s*<hr>\s*$/i );
            }
        }

        # <COMMENTS>Copy</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>remaining</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> </<COMMENTS>body</COMMENTS>> <COMMENTS>tag</COMMENTS>
        elsif ( $<CODE>line</CODE> =~ /^\s*<\/body>\s*$/i ) {
            $<CODE>saw_body_end</CODE> = 1;
            if (@$<CODE>rpre_string_stack</CODE>) {
                unless ( $<CODE>self</CODE>->{<LITERALS>_pod_cut_count</LITERALS>} > 1 ) {
                    $<CODE>html_print</CODE>->('<<LITERALS>hr</LITERALS> />');
                }
                while ( my $<CODE>rpre_string</CODE> = shift(@$<CODE>rpre_string_stack</CODE>) ) {
                    $<CODE>html_print</CODE>->('<<LITERALS>pre</LITERALS>>');
                    $<CODE>html_print</CODE>->($$<CODE>rpre_string</CODE>);
                    $<CODE>html_print</CODE>->('</<LITERALS>pre</LITERALS>>');
                }
            }
            $<CODE>html_print</CODE>->($<CODE>line</CODE>);
        }
        else {
            $<CODE>html_print</CODE>->($<CODE>line</CODE>);
        }
    }

    $<CODE>success_flag</CODE> = 1;
    unless ($<CODE>saw_body</CODE>) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE> "<LITERALS>Did</LITERALS> <LITERALS>not</LITERALS> <LITERALS>see</LITERALS> <<LITERALS>body</LITERALS>> <LITERALS>in</LITERALS> <LITERALS>pod2html</LITERALS> <LITERALS>output</LITERALS>\n";
        $<CODE>success_flag</CODE> = 0;
    }
    unless ($<CODE>saw_body_end</CODE>) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE> "<LITERALS>Did</LITERALS> <LITERALS>not</LITERALS> <LITERALS>see</LITERALS> </<LITERALS>body</LITERALS>> <LITERALS>in</LITERALS> <LITERALS>pod2html</LITERALS> <LITERALS>output</LITERALS>\n";
        $<CODE>success_flag</CODE> = 0;
    }
    unless ($<CODE>saw_index</CODE>) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE> "<LITERALS>Did</LITERALS> <LITERALS>not</LITERALS> <LITERALS>find</LITERALS> <LITERALS>INDEX</LITERALS> <LITERALS>END</LITERALS> <LITERALS>in</LITERALS> <LITERALS>pod2html</LITERALS> <LITERALS>output</LITERALS>\n";
        $<CODE>success_flag</CODE> = 0;
    }

  <CODE>RETURN</CODE>:
    eval { $<CODE>html_fh</CODE>-><CODE>close</CODE>() };

    # <COMMENTS>note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>unlink</COMMENTS> <COMMENTS>tmpfile</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>making</COMMENTS> <COMMENTS>frames</COMMENTS>
    # <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tmpfile</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>frames</COMMENTS>
    unlink $<CODE>tmpfile</CODE> if -e $<CODE>tmpfile</CODE>;
    if ( $<CODE>success_flag</CODE> && $<CODE>rOpts</CODE>->{'<LITERALS>frames</LITERALS>'} ) {
        $<CODE>self</CODE>-><CODE>make_frame</CODE>( \@<CODE>toc</CODE> );
    }
    return $<CODE>success_flag</CODE>;
}

sub <CODE>make_frame</CODE> {

    # <COMMENTS>Make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>frame</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>panel</COMMENTS>
    # <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>panel</COMMENTS>.
    # <COMMENTS>On</COMMENTS> <COMMENTS>entry</COMMENTS>:
    #  <COMMENTS>$html_filename</COMMENTS> <COMMENTS>contains</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>no</COMMENTS>-<COMMENTS>frames</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>output</COMMENTS>
    #  <COMMENTS>$rtoc</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS>
    my $<CODE>self</CODE>          = shift;
    my ($<CODE>rtoc</CODE>)        = @<CODE>_</CODE>;
    my $<CODE>input_file</CODE>    = $<CODE>self</CODE>->{<LITERALS>_input_file</LITERALS>};
    my $<CODE>html_filename</CODE> = $<CODE>self</CODE>->{<LITERALS>_html_file</LITERALS>};
    my $<CODE>toc_filename</CODE>  = $<CODE>self</CODE>->{<LITERALS>_toc_filename</LITERALS>};
    my $<CODE>src_filename</CODE>  = $<CODE>self</CODE>->{<LITERALS>_src_filename</LITERALS>};
    my $<CODE>title</CODE>         = $<CODE>self</CODE>->{<LITERALS>_title</LITERALS>};
    $<CODE>title</CODE> = <CODE>escape_html</CODE>($<CODE>title</CODE>);

    # <COMMENTS>FUTURE</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>parameter</COMMENTS>:
    my $<CODE>top_basename</CODE> = "";

    # <COMMENTS>We</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>produce</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>files</COMMENTS>:
    # <COMMENTS>1</COMMENTS>. - <COMMENTS>the</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS>
    # <COMMENTS>2</COMMENTS>. - <COMMENTS>the</COMMENTS> <COMMENTS>contents</COMMENTS> (<COMMENTS>source</COMMENTS> <COMMENTS>code</COMMENTS>) <COMMENTS>itself</COMMENTS>
    # <COMMENTS>3</COMMENTS>. - <COMMENTS>the</COMMENTS> <COMMENTS>frame</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>contains</COMMENTS> <COMMENTS>them</COMMENTS>

    # <COMMENTS>get</COMMENTS> <COMMENTS>basenames</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>relative</COMMENTS> <COMMENTS>links</COMMENTS>
    my ( $<CODE>toc_basename</CODE>, $<CODE>toc_path</CODE> ) = <CODE>fileparse</CODE>($<CODE>toc_filename</CODE>);
    my ( $<CODE>src_basename</CODE>, $<CODE>src_path</CODE> ) = <CODE>fileparse</CODE>($<CODE>src_filename</CODE>);

    # <COMMENTS>1</COMMENTS>. <COMMENTS>Make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>panel</COMMENTS>, <COMMENTS>with</COMMENTS> <COMMENTS>appropriate</COMMENTS> <COMMENTS>changes</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>anchor</COMMENTS> <COMMENTS>names</COMMENTS>
    my $<CODE>src_frame_name</CODE> = '<LITERALS>SRC</LITERALS>';
    my $<CODE>first_anchor</CODE> =
      <CODE>write_toc_html</CODE>( $<CODE>title</CODE>, $<CODE>toc_filename</CODE>, $<CODE>src_basename</CODE>, $<CODE>rtoc</CODE>,
        $<CODE>src_frame_name</CODE> );

    # <COMMENTS>2</COMMENTS>. <COMMENTS>The</COMMENTS> <COMMENTS>current</COMMENTS> .<COMMENTS>html</COMMENTS> <COMMENTS>filename</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>renamed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>panel</COMMENTS>
    rename( $<CODE>html_filename</CODE>, $<CODE>src_filename</CODE> )
      or <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE> "<LITERALS>Cannot</LITERALS> <LITERALS>rename</LITERALS> $<CODE>html_filename</CODE> <LITERALS>to</LITERALS> $<CODE>src_filename</CODE>:$!\n";

    # <COMMENTS>3</COMMENTS>. <COMMENTS>Then</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>original</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>filename</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>frame</COMMENTS>
    <CODE>write_frame_html</CODE>(
        $<CODE>title</CODE>,        $<CODE>html_filename</CODE>, $<CODE>top_basename</CODE>,
        $<CODE>toc_basename</CODE>, $<CODE>src_basename</CODE>,  $<CODE>src_frame_name</CODE>
    );
}

sub <CODE>write_toc_html</CODE> {

    # <COMMENTS>write</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>frames</COMMENTS>
    my ( $<CODE>title</CODE>, $<CODE>toc_filename</CODE>, $<CODE>src_basename</CODE>, $<CODE>rtoc</CODE>, $<CODE>src_frame_name</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>fh</CODE> = <CODE>IO</CODE>::<CODE>File</CODE>-><CODE>new</CODE>( $<CODE>toc_filename</CODE>, '<LITERALS>w</LITERALS>' )
      or <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE> "<LITERALS>Cannot</LITERALS> <LITERALS>open</LITERALS> $<CODE>toc_filename</CODE>:$!\n";
    $<CODE>fh</CODE>-><CODE>print</CODE>(<<<LITERALS>EOM</LITERALS>);
<<LITERALS>html</LITERALS>>
<<LITERALS>head</LITERALS>>
<<LITERALS>title</LITERALS>>$<CODE>title</CODE></<LITERALS>title</LITERALS>>
</<LITERALS>head</LITERALS>>
<<LITERALS>body</LITERALS>>
<<LITERALS>h1</LITERALS>><<LITERALS>a</LITERALS> <LITERALS>href</LITERALS>=\"$<CODE>src_basename</CODE>#-<LITERALS>top</LITERALS>-" <LITERALS>target</LITERALS>="$<CODE>src_frame_name</CODE>">$<CODE>title</CODE></<LITERALS>a</LITERALS>></<LITERALS>h1</LITERALS>>
<CODE>EOM</CODE>

    my $<CODE>first_anchor</CODE> =
      <CODE>change_anchor_names</CODE>( $<CODE>rtoc</CODE>, $<CODE>src_basename</CODE>, "$<CODE>src_frame_name</CODE>" );
    $<CODE>fh</CODE>-><CODE>print</CODE>( join "", @$<CODE>rtoc</CODE> );

    $<CODE>fh</CODE>-><CODE>print</CODE>(<<<LITERALS>EOM</LITERALS>);
</<LITERALS>body</LITERALS>>
</<LITERALS>html</LITERALS>>
<CODE>EOM</CODE>

}

sub <CODE>write_frame_html</CODE> {

    # <COMMENTS>write</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>frame</COMMENTS>
    my (
        $<CODE>title</CODE>,        $<CODE>frame_filename</CODE>, $<CODE>top_basename</CODE>,
        $<CODE>toc_basename</CODE>, $<CODE>src_basename</CODE>,   $<CODE>src_frame_name</CODE>
    ) = @<CODE>_</CODE>;

    my $<CODE>fh</CODE> = <CODE>IO</CODE>::<CODE>File</CODE>-><CODE>new</CODE>( $<CODE>frame_filename</CODE>, '<LITERALS>w</LITERALS>' )
      or <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE> "<LITERALS>Cannot</LITERALS> <LITERALS>open</LITERALS> $<CODE>toc_basename</CODE>:$!\n";

    $<CODE>fh</CODE>-><CODE>print</CODE>(<<<LITERALS>EOM</LITERALS>);
<!<LITERALS>DOCTYPE</LITERALS> <LITERALS>html</LITERALS> <LITERALS>PUBLIC</LITERALS> "-//<LITERALS>W3C</LITERALS>//<LITERALS>DTD</LITERALS> <LITERALS>XHTML</LITERALS> <LITERALS>1</LITERALS>.<LITERALS>0</LITERALS> <LITERALS>Frameset</LITERALS>//<LITERALS>EN</LITERALS>"
    "<LITERALS>http</LITERALS>://<LITERALS>www</LITERALS>.<LITERALS>w3</LITERALS>.<LITERALS>org</LITERALS>/<LITERALS>TR</LITERALS>/<LITERALS>xhtml1</LITERALS>/<LITERALS>DTD</LITERALS>/<LITERALS>xhtml1</LITERALS>-<LITERALS>frameset</LITERALS>.<LITERALS>dtd</LITERALS>">
<?<LITERALS>xml</LITERALS> <LITERALS>version</LITERALS>="<LITERALS>1</LITERALS>.<LITERALS>0</LITERALS>" <LITERALS>encoding</LITERALS>="<LITERALS>iso</LITERALS>-<LITERALS>8859</LITERALS>-<LITERALS>1</LITERALS>" ?>
<<LITERALS>html</LITERALS> <LITERALS>xmlns</LITERALS>="<LITERALS>http</LITERALS>://<LITERALS>www</LITERALS>.<LITERALS>w3</LITERALS>.<LITERALS>org</LITERALS>/<LITERALS>1999</LITERALS>/<LITERALS>xhtml</LITERALS>">
<<LITERALS>head</LITERALS>>
<<LITERALS>title</LITERALS>>$<CODE>title</CODE></<LITERALS>title</LITERALS>>
</<LITERALS>head</LITERALS>>
<CODE>EOM</CODE>

    # <COMMENTS>two</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>panels</COMMENTS>, <COMMENTS>one</COMMENTS> <COMMENTS>right</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>master</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>file</COMMENTS>
    if ($<CODE>top_basename</CODE>) {
        $<CODE>fh</CODE>-><CODE>print</CODE>(<<<LITERALS>EOM</LITERALS>);
<<LITERALS>frameset</LITERALS> <LITERALS>cols</LITERALS>="<LITERALS>20</LITERALS>%,<LITERALS>80</LITERALS>%">
<<LITERALS>frameset</LITERALS> <LITERALS>rows</LITERALS>="<LITERALS>30</LITERALS>%,<LITERALS>70</LITERALS>%">
<<LITERALS>frame</LITERALS> <LITERALS>src</LITERALS> = "$<CODE>top_basename</CODE>" />
<<LITERALS>frame</LITERALS> <LITERALS>src</LITERALS> = "$<CODE>toc_basename</CODE>" />
</<LITERALS>frameset</LITERALS>>
<CODE>EOM</CODE>
    }

    # <COMMENTS>one</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>panels</COMMENTS>, <COMMENTS>one</COMMENTS> <COMMENTS>right</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>master</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>file</COMMENTS>
    else {
        $<CODE>fh</CODE>-><CODE>print</CODE>(<<<LITERALS>EOM</LITERALS>);
<<LITERALS>frameset</LITERALS> <LITERALS>cols</LITERALS>="<LITERALS>20</LITERALS>%,*">
<<LITERALS>frame</LITERALS> <LITERALS>src</LITERALS> = "$<CODE>toc_basename</CODE>" />
<CODE>EOM</CODE>
    }
    $<CODE>fh</CODE>-><CODE>print</CODE>(<<<LITERALS>EOM</LITERALS>);
<<LITERALS>frame</LITERALS> <LITERALS>src</LITERALS> = "$<CODE>src_basename</CODE>" <LITERALS>name</LITERALS> = "$<CODE>src_frame_name</CODE>" />
<<LITERALS>noframes</LITERALS>>
<<LITERALS>body</LITERALS>>
<<LITERALS>p</LITERALS>><LITERALS>If</LITERALS> <LITERALS>you</LITERALS> <LITERALS>see</LITERALS> <LITERALS>this</LITERALS> <LITERALS>message</LITERALS>, <LITERALS>you</LITERALS> <LITERALS>are</LITERALS> <LITERALS>using</LITERALS> <LITERALS>a</LITERALS> <LITERALS>non</LITERALS>-<LITERALS>frame</LITERALS>-<LITERALS>capable</LITERALS> <LITERALS>web</LITERALS> <LITERALS>client</LITERALS>.</<LITERALS>p</LITERALS>>
<<LITERALS>p</LITERALS>><LITERALS>This</LITERALS> <LITERALS>document</LITERALS> <LITERALS>contains</LITERALS>:</<LITERALS>p</LITERALS>>
<<LITERALS>ul</LITERALS>>
<<LITERALS>li</LITERALS>><<LITERALS>a</LITERALS> <LITERALS>href</LITERALS>="$<CODE>toc_basename</CODE>"><LITERALS>A</LITERALS> <LITERALS>table</LITERALS> <LITERALS>of</LITERALS> <LITERALS>contents</LITERALS></<LITERALS>a</LITERALS>></<LITERALS>li</LITERALS>>
<<LITERALS>li</LITERALS>><<LITERALS>a</LITERALS> <LITERALS>href</LITERALS>="$<CODE>src_basename</CODE>"><LITERALS>The</LITERALS> <LITERALS>source</LITERALS> <LITERALS>code</LITERALS></<LITERALS>a</LITERALS>></<LITERALS>li</LITERALS>>
</<LITERALS>ul</LITERALS>>
</<LITERALS>body</LITERALS>>
</<LITERALS>noframes</LITERALS>>
</<LITERALS>frameset</LITERALS>>
</<LITERALS>html</LITERALS>>
<CODE>EOM</CODE>
}

sub <CODE>change_anchor_names</CODE> {

    # <COMMENTS>add</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>filename</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>target</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>anchors</COMMENTS>
    # <COMMENTS>also</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>anchor</COMMENTS>
    my ( $<CODE>rlines</CODE>, $<CODE>filename</CODE>, $<CODE>target</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>first_anchor</CODE>;
    foreach my $<CODE>line</CODE> (@$<CODE>rlines</CODE>) {

        #  <COMMENTS>We</COMMENTS>'<COMMENTS>re</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
        #  <<COMMENTS>LI</COMMENTS>><<COMMENTS>A</COMMENTS> <COMMENTS>HREF</COMMENTS>="#<COMMENTS>synopsis</COMMENTS>"><COMMENTS>SYNOPSIS</COMMENTS></<COMMENTS>A</COMMENTS>></<COMMENTS>LI</COMMENTS>>
        #  ----  -       --------  -----------------
        #  <COMMENTS>$1</COMMENTS>              <COMMENTS>$4</COMMENTS>            <COMMENTS>$5</COMMENTS>
        if ( $<CODE>line</CODE> =~ /^(.*)<a(.*)href\s*=\s*"([^#]*)#([^"]+)"[^>]*>(.*)$/i ) {
            my $<CODE>pre</CODE>  = $<CODE>1</CODE>;
            my $<CODE>name</CODE> = $<CODE>4</CODE>;
            my $<CODE>post</CODE> = $<CODE>5</CODE>;
            my $<CODE>href</CODE> = "$<CODE>filename</CODE>#$<CODE>name</CODE>";
            $<CODE>line</CODE> = "$<CODE>pre</CODE><<LITERALS>a</LITERALS> <LITERALS>href</LITERALS>=\"$<CODE>href</CODE>\" <LITERALS>target</LITERALS>=\"$<CODE>target</CODE>\">$<CODE>post</CODE>\n";
            unless ($<CODE>first_anchor</CODE>) { $<CODE>first_anchor</CODE> = $<CODE>href</CODE> }
        }
    }
    return $<CODE>first_anchor</CODE>;
}

sub <CODE>close_html_file</CODE> {
    my $<CODE>self</CODE> = shift;
    return unless $<CODE>self</CODE>->{<LITERALS>_html_file_opened</LITERALS>};

    my $<CODE>html_fh</CODE>     = $<CODE>self</CODE>->{<LITERALS>_html_fh</LITERALS>};
    my $<CODE>rtoc_string</CODE> = $<CODE>self</CODE>->{<LITERALS>_rtoc_string</LITERALS>};

    # <COMMENTS>There</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>basic</COMMENTS> <COMMENTS>paths</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>output</COMMENTS>...

    # ---------------------------------
    # <COMMENTS>Path</COMMENTS> <COMMENTS>1</COMMENTS>: <COMMENTS>finish</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>in</COMMENTS> -<COMMENTS>pre</COMMENTS> <COMMENTS>mode</COMMENTS>
    # ---------------------------------
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>pre</LITERALS>-<LITERALS>only</LITERALS>'} ) {
        $<CODE>html_fh</CODE>-><CODE>print</CODE>( <<"<LITERALS>PRE_END</LITERALS>");
</<LITERALS>pre</LITERALS>>
<CODE>PRE_END</CODE>
        eval { $<CODE>html_fh</CODE>-><CODE>close</CODE>() };
        return;
    }

    # <COMMENTS>Finish</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>index</COMMENTS>
    $<CODE>self</CODE>-><CODE>add_toc_item</CODE>( '<LITERALS>EOF</LITERALS>', '<LITERALS>EOF</LITERALS>' );

    my $<CODE>rpre_string_stack</CODE> = $<CODE>self</CODE>->{<LITERALS>_rpre_string_stack</LITERALS>};

    # <COMMENTS>Patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>darken</COMMENTS> <COMMENTS>the</COMMENTS> <<COMMENTS>pre</COMMENTS>> <COMMENTS>background</COMMENTS> <COMMENTS>color</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>pod2html</COMMENTS> <COMMENTS>and</COMMENTS>
    # <COMMENTS>interleaved</COMMENTS> <COMMENTS>code</COMMENTS>/<COMMENTS>documentation</COMMENTS>.  <COMMENTS>Otherwise</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>distinction</COMMENTS>
    # <COMMENTS>between</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>documentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>blurred</COMMENTS>.
    if (   $<CODE>rOpts</CODE>->{<LITERALS>pod2html</LITERALS>}
        && $<CODE>self</CODE>->{<LITERALS>_pod_cut_count</LITERALS>} >= 1
        && $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-<LITERALS>background</LITERALS>'} eq '#<LITERALS>FFFFFF</LITERALS>' )
    {
        $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>pre</LITERALS>-<LITERALS>color</LITERALS>-<LITERALS>background</LITERALS>'} = '#<LITERALS>F0F0F0</LITERALS>';
    }

    # <COMMENTS>put</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>css</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>link</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>used</COMMENTS>
    my $<CODE>css_string</CODE>;
    my $<CODE>fh_css</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IOScalar</CODE>-><CODE>new</CODE>( \$<CODE>css_string</CODE>, '<LITERALS>w</LITERALS>' );

    # <COMMENTS>use</COMMENTS> <COMMENTS>css</COMMENTS> <COMMENTS>linked</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>file</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>linked</LITERALS>-<LITERALS>style</LITERALS>-<LITERALS>sheet</LITERALS>'} ) {
        $<CODE>fh_css</CODE>-><CODE>print</CODE>(
            qq(<<LITERALS>link</LITERALS> <LITERALS>rel</LITERALS>="<LITERALS>stylesheet</LITERALS>" <LITERALS>href</LITERALS>="$<CODE>css_linkname</CODE>" <LITERALS>type</LITERALS>="<LITERALS>text</LITERALS>/<LITERALS>css</LITERALS>" />)
        );
    }

    # <COMMENTS>use</COMMENTS> <COMMENTS>css</COMMENTS> <COMMENTS>embedded</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>file</COMMENTS>
    elsif ( !$<CODE>rOpts</CODE>->{'<LITERALS>nohtml</LITERALS>-<LITERALS>style</LITERALS>-<LITERALS>sheets</LITERALS>'} ) {
        $<CODE>fh_css</CODE>-><CODE>print</CODE>( <<'<LITERALS>ENDCSS</LITERALS>');
<<LITERALS>style</LITERALS> <LITERALS>type</LITERALS>="<LITERALS>text</LITERALS>/<LITERALS>css</LITERALS>">
<!--
<CODE>ENDCSS</CODE>
        <CODE>write_style_sheet_data</CODE>($<CODE>fh_css</CODE>);
        $<CODE>fh_css</CODE>-><CODE>print</CODE>( <<"<LITERALS>ENDCSS</LITERALS>");
-->
</<LITERALS>style</LITERALS>>
<CODE>ENDCSS</CODE>
    }

    # -----------------------------------------------------------
    # <COMMENTS>path</COMMENTS> <COMMENTS>2</COMMENTS>: <COMMENTS>use</COMMENTS> <COMMENTS>pod2html</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS>
    #         <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>fail</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>reason</COMMENTS>, <COMMENTS>continue</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>path</COMMENTS> <COMMENTS>3</COMMENTS>
    # -----------------------------------------------------------
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>pod2html</LITERALS>'} ) {
        my $<CODE>rpod_string</CODE> = $<CODE>self</CODE>->{<LITERALS>_rpod_string</LITERALS>};
        $<CODE>self</CODE>-><CODE>pod_to_html</CODE>( $$<CODE>rpod_string</CODE>, $<CODE>css_string</CODE>, $$<CODE>rtoc_string</CODE>,
            $<CODE>rpre_string_stack</CODE> )
          && return;
    }

    # --------------------------------------------------
    # <COMMENTS>path</COMMENTS> <COMMENTS>3</COMMENTS>: <COMMENTS>write</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>html</COMMENTS>, <COMMENTS>with</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>italics</COMMENTS>
    # --------------------------------------------------
    my $<CODE>input_file</CODE> = $<CODE>self</CODE>->{<LITERALS>_input_file</LITERALS>};
    my $<CODE>title</CODE>      = <CODE>escape_html</CODE>($<CODE>input_file</CODE>);
    my $<CODE>date</CODE>       = localtime;
    $<CODE>html_fh</CODE>-><CODE>print</CODE>( <<"<LITERALS>HTML_START</LITERALS>");
<!<LITERALS>DOCTYPE</LITERALS> <LITERALS>html</LITERALS> <LITERALS>PUBLIC</LITERALS> "-//<LITERALS>W3C</LITERALS>//<LITERALS>DTD</LITERALS> <LITERALS>XHTML</LITERALS> <LITERALS>1</LITERALS>.<LITERALS>0</LITERALS> <LITERALS>Transitional</LITERALS>//<LITERALS>EN</LITERALS>"
   "<LITERALS>http</LITERALS>://<LITERALS>www</LITERALS>.<LITERALS>w3</LITERALS>.<LITERALS>org</LITERALS>/<LITERALS>TR</LITERALS>/<LITERALS>xhtml1</LITERALS>/<LITERALS>DTD</LITERALS>/<LITERALS>xhtml1</LITERALS>-<LITERALS>transitional</LITERALS>.<LITERALS>dtd</LITERALS>">
<!-- <LITERALS>Generated</LITERALS> <LITERALS>by</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>on</LITERALS> $<CODE>date</CODE> -->
<<LITERALS>html</LITERALS> <LITERALS>xmlns</LITERALS>="<LITERALS>http</LITERALS>://<LITERALS>www</LITERALS>.<LITERALS>w3</LITERALS>.<LITERALS>org</LITERALS>/<LITERALS>1999</LITERALS>/<LITERALS>xhtml</LITERALS>">
<<LITERALS>head</LITERALS>>
<<LITERALS>title</LITERALS>>$<CODE>title</CODE></<LITERALS>title</LITERALS>>
<CODE>HTML_START</CODE>

    # <COMMENTS>output</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>css</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>used</COMMENTS>
    if ($<CODE>css_string</CODE>) {
        $<CODE>html_fh</CODE>-><CODE>print</CODE>($<CODE>css_string</CODE>);
        $<CODE>html_fh</CODE>-><CODE>print</CODE>( <<"<LITERALS>ENDCSS</LITERALS>");
</<LITERALS>head</LITERALS>>
<<LITERALS>body</LITERALS>>
<CODE>ENDCSS</CODE>
    }
    else {

        $<CODE>html_fh</CODE>-><CODE>print</CODE>( <<"<LITERALS>HTML_START</LITERALS>");
</<LITERALS>head</LITERALS>>
<<LITERALS>body</LITERALS> <LITERALS>bgcolor</LITERALS>=\"$<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-<LITERALS>background</LITERALS>'}\" <LITERALS>text</LITERALS>=\"$<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-<LITERALS>punctuation</LITERALS>'}\">
<CODE>HTML_START</CODE>
    }

    $<CODE>html_fh</CODE>-><CODE>print</CODE>("<<LITERALS>a</LITERALS> <LITERALS>name</LITERALS>=\"-<LITERALS>top</LITERALS>-\"></<LITERALS>a</LITERALS>>\n");
    $<CODE>html_fh</CODE>-><CODE>print</CODE>( <<"<LITERALS>EOM</LITERALS>");
<<LITERALS>h1</LITERALS>>$<CODE>title</CODE></<LITERALS>h1</LITERALS>>
<CODE>EOM</CODE>

    # <COMMENTS>copy</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>contents</COMMENTS>
    if (   $$<CODE>rtoc_string</CODE>
        && !$<CODE>rOpts</CODE>->{'<LITERALS>frames</LITERALS>'}
        && $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>table</LITERALS>-<LITERALS>of</LITERALS>-<LITERALS>contents</LITERALS>'} )
    {
        $<CODE>html_fh</CODE>-><CODE>print</CODE>($$<CODE>rtoc_string</CODE>);
    }

    # <COMMENTS>copy</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pre</COMMENTS> <COMMENTS>section</COMMENTS>(<COMMENTS>s</COMMENTS>)
    my $<CODE>fname_comment</CODE> = $<CODE>input_file</CODE>;
    $<CODE>fname_comment</CODE> =~ s/--+/-/g;    # <COMMENTS>protect</COMMENTS> <COMMENTS>HTML</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>tags</COMMENTS>
    $<CODE>html_fh</CODE>-><CODE>print</CODE>( <<"<LITERALS>END_PRE</LITERALS>");
<<LITERALS>hr</LITERALS> />
<!-- <LITERALS>contents</LITERALS> <LITERALS>of</LITERALS> <LITERALS>filename</LITERALS>: $<CODE>fname_comment</CODE> -->
<<LITERALS>pre</LITERALS>>
<CODE>END_PRE</CODE>

    foreach my $<CODE>rpre_string</CODE> (@$<CODE>rpre_string_stack</CODE>) {
        $<CODE>html_fh</CODE>-><CODE>print</CODE>($$<CODE>rpre_string</CODE>);
    }

    # <COMMENTS>and</COMMENTS> <COMMENTS>finish</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>page</COMMENTS>
    $<CODE>html_fh</CODE>-><CODE>print</CODE>( <<"<LITERALS>HTML_END</LITERALS>");
</<LITERALS>pre</LITERALS>>
</<LITERALS>body</LITERALS>>
</<LITERALS>html</LITERALS>>
<CODE>HTML_END</CODE>
    eval { $<CODE>html_fh</CODE>-><CODE>close</CODE>() };    # <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>close</COMMENTS> <COMMENTS>method</COMMENTS>

    if ( $<CODE>rOpts</CODE>->{'<LITERALS>frames</LITERALS>'} ) {
        my @<CODE>toc</CODE> = map { $<CODE>_</CODE> .= "\n" } split /\n/, $$<CODE>rtoc_string</CODE>;
        $<CODE>self</CODE>-><CODE>make_frame</CODE>( \@<CODE>toc</CODE> );
    }
}

sub <CODE>markup_tokens</CODE> {
    my $<CODE>self</CODE> = shift;
    my ( $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>, $<CODE>rlevels</CODE> ) = @<CODE>_</CODE>;
    my ( @<CODE>colored_tokens</CODE>, $<CODE>j</CODE>, $<CODE>string</CODE>, $<CODE>type</CODE>, $<CODE>token</CODE>, $<CODE>level</CODE> );
    my $<CODE>rlast_level</CODE>    = $<CODE>self</CODE>->{<LITERALS>_rlast_level</LITERALS>};
    my $<CODE>rpackage_stack</CODE> = $<CODE>self</CODE>->{<LITERALS>_rpackage_stack</LITERALS>};

    for ( $<CODE>j</CODE> = 0 ; $<CODE>j</CODE> < @$<CODE>rtoken_type</CODE> ; $<CODE>j</CODE>++ ) {
        $<CODE>type</CODE>  = $$<CODE>rtoken_type</CODE>[$<CODE>j</CODE>];
        $<CODE>token</CODE> = $$<CODE>rtokens</CODE>[$<CODE>j</CODE>];
        $<CODE>level</CODE> = $$<CODE>rlevels</CODE>[$<CODE>j</CODE>];
        $<CODE>level</CODE> = 0 if ( $<CODE>level</CODE> < 0 );

        #-------------------------------------------------------
        # <COMMENTS>Update</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>stack</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>stack</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>toc</COMMENTS> <COMMENTS>correct</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>packages</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>declared</COMMENTS> <COMMENTS>within</COMMENTS>
        # <COMMENTS>blocks</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>scope</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>leave</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>block</COMMENTS>.
        #-------------------------------------------------------
        if ( $<CODE>level</CODE> > $$<CODE>rlast_level</CODE> ) {
            unless ( $<CODE>rpackage_stack</CODE>->[ $<CODE>level</CODE> - 1 ] ) {
                $<CODE>rpackage_stack</CODE>->[ $<CODE>level</CODE> - 1 ] = '<LITERALS>main</LITERALS>';
            }
            $<CODE>rpackage_stack</CODE>->[$<CODE>level</CODE>] = $<CODE>rpackage_stack</CODE>->[ $<CODE>level</CODE> - 1 ];
        }
        elsif ( $<CODE>level</CODE> < $$<CODE>rlast_level</CODE> ) {
            my $<CODE>package</CODE> = $<CODE>rpackage_stack</CODE>->[$<CODE>level</CODE>];
            unless ($<CODE>package</CODE>) { $<CODE>package</CODE> = '<LITERALS>main</LITERALS>' }

            # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>packages</COMMENTS> <COMMENTS>due</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>change</COMMENTS>, <COMMENTS>we</COMMENTS>
            # <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>entry</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>toc</COMMENTS>
            if ( $<CODE>package</CODE> ne $<CODE>rpackage_stack</CODE>->[ $<CODE>level</CODE> + 1 ] ) {
                $<CODE>self</CODE>-><CODE>add_toc_item</CODE>( $<CODE>package</CODE>, '<LITERALS>package</LITERALS>' );
            }
        }
        $$<CODE>rlast_level</CODE> = $<CODE>level</CODE>;

        #-------------------------------------------------------
        # <COMMENTS>Intercept</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>here</COMMENTS>; <COMMENTS>split</COMMENTS> <COMMENTS>it</COMMENTS>
        # <COMMENTS>into</COMMENTS> <COMMENTS>keyword</COMMENTS> '<COMMENTS>sub</COMMENTS>' <COMMENTS>and</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>name</COMMENTS>; <COMMENTS>and</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>an</COMMENTS>
        # <COMMENTS>entry</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>toc</COMMENTS>
        #-------------------------------------------------------
        if ( $<CODE>type</CODE> eq '<LITERALS>i</LITERALS>' && $<CODE>token</CODE> =~ /^(sub\s+)(\w.*)$/ ) {
            $<CODE>token</CODE> = $<CODE>self</CODE>-><CODE>markup_html_element</CODE>( $<CODE>1</CODE>, '<LITERALS>k</LITERALS>' );
            push @<CODE>colored_tokens</CODE>, $<CODE>token</CODE>;
            $<CODE>token</CODE> = $<CODE>2</CODE>;
            $<CODE>type</CODE>  = '<LITERALS>M</LITERALS>';

            # <COMMENTS>but</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>include</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>declarations</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>toc</COMMENTS>;
            # <COMMENTS>these</COMMENTS> <COMMENTS>wlll</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> '<COMMENTS>i</COMMENTS>;'
            my $<CODE>signature</CODE> = join "", @$<CODE>rtoken_type</CODE>;
            unless ( $<CODE>signature</CODE> =~ /^i;/ ) {
                my $<CODE>subname</CODE> = $<CODE>token</CODE>;
                $<CODE>subname</CODE> =~ s/[\s\(].*$//; # <COMMENTS>remove</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>attributes</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>prototype</COMMENTS>
                $<CODE>self</CODE>-><CODE>add_toc_item</CODE>( $<CODE>subname</CODE>, '<LITERALS>sub</LITERALS>' );
            }
        }

        #-------------------------------------------------------
        # <COMMENTS>Intercept</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>here</COMMENTS>; <COMMENTS>split</COMMENTS> <COMMENTS>it</COMMENTS>
        # <COMMENTS>into</COMMENTS> <COMMENTS>keyword</COMMENTS> '<COMMENTS>package</COMMENTS>' <COMMENTS>and</COMMENTS> <COMMENTS>name</COMMENTS>; <COMMENTS>add</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>toc</COMMENTS>,
        # <COMMENTS>and</COMMENTS> <COMMENTS>update</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>stack</COMMENTS>
        #-------------------------------------------------------
        if ( $<CODE>type</CODE> eq '<LITERALS>i</LITERALS>' && $<CODE>token</CODE> =~ /^(package\s+)(\w.*)$/ ) {
            $<CODE>token</CODE> = $<CODE>self</CODE>-><CODE>markup_html_element</CODE>( $<CODE>1</CODE>, '<LITERALS>k</LITERALS>' );
            push @<CODE>colored_tokens</CODE>, $<CODE>token</CODE>;
            $<CODE>token</CODE> = $<CODE>2</CODE>;
            $<CODE>type</CODE>  = '<LITERALS>i</LITERALS>';
            $<CODE>self</CODE>-><CODE>add_toc_item</CODE>( "$<CODE>token</CODE>", '<LITERALS>package</LITERALS>' );
            $<CODE>rpackage_stack</CODE>->[$<CODE>level</CODE>] = $<CODE>token</CODE>;
        }

        $<CODE>token</CODE> = $<CODE>self</CODE>-><CODE>markup_html_element</CODE>( $<CODE>token</CODE>, $<CODE>type</CODE> );
        push @<CODE>colored_tokens</CODE>, $<CODE>token</CODE>;
    }
    return ( \@<CODE>colored_tokens</CODE> );
}

sub <CODE>markup_html_element</CODE> {
    my $<CODE>self</CODE> = shift;
    my ( $<CODE>token</CODE>, $<CODE>type</CODE> ) = @<CODE>_</CODE>;

    return $<CODE>token</CODE> if ( $<CODE>type</CODE> eq '<LITERALS>b</LITERALS>' );         # <COMMENTS>skip</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>token</COMMENTS>
    return $<CODE>token</CODE> if ( $<CODE>token</CODE> =~ /^\s*$/ );    # <COMMENTS>skip</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS>
    $<CODE>token</CODE> = <CODE>escape_html</CODE>($<CODE>token</CODE>);

    # <COMMENTS>get</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>abbreviation</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS>
    my $<CODE>short_name</CODE> = $<CODE>token_short_names</CODE>{$<CODE>type</CODE>};
    if ( !defined($<CODE>short_name</CODE>) ) {
        $<CODE>short_name</CODE> = "<LITERALS>pu</LITERALS>";                    # <COMMENTS>punctuation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>default</COMMENTS>
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>style</COMMENTS> <COMMENTS>sheets</COMMENTS>..
    if ( !$<CODE>rOpts</CODE>->{'<LITERALS>nohtml</LITERALS>-<LITERALS>style</LITERALS>-<LITERALS>sheets</LITERALS>'} ) {
        if ( $<CODE>short_name</CODE> ne '<LITERALS>pu</LITERALS>' ) {
            $<CODE>token</CODE> = qq(<<LITERALS>span</LITERALS> <LITERALS>class</LITERALS>="$<CODE>short_name</CODE>">) . $<CODE>token</CODE> . "</<LITERALS>span</LITERALS>>";
        }
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>style</COMMENTS> <COMMENTS>sheets</COMMENTS>..
    else {
        my $<CODE>color</CODE> = $<CODE>html_color</CODE>{$<CODE>short_name</CODE>};

        if ( $<CODE>color</CODE> && ( $<CODE>color</CODE> ne $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>color</LITERALS>-<LITERALS>punctuation</LITERALS>'} ) ) {
            $<CODE>token</CODE> = qq(<<LITERALS>font</LITERALS> <LITERALS>color</LITERALS>="$<CODE>color</CODE>">) . $<CODE>token</CODE> . "</<LITERALS>font</LITERALS>>";
        }
        if ( $<CODE>html_italic</CODE>{$<CODE>short_name</CODE>} ) { $<CODE>token</CODE> = "<<LITERALS>i</LITERALS>>$<CODE>token</CODE></<LITERALS>i</LITERALS>>" }
        if ( $<CODE>html_bold</CODE>{$<CODE>short_name</CODE>} )   { $<CODE>token</CODE> = "<<LITERALS>b</LITERALS>>$<CODE>token</CODE></<LITERALS>b</LITERALS>>" }
    }
    return $<CODE>token</CODE>;
}

sub <CODE>escape_html</CODE> {

    my $<CODE>token</CODE> = shift;
    if ($<CODE>missing_html_entities</CODE>) {
        $<CODE>token</CODE> =~ s/\&/&<LITERALS>amp</LITERALS>;/g;
        $<CODE>token</CODE> =~ s/\</&<LITERALS>lt</LITERALS>;/g;
        $<CODE>token</CODE> =~ s/\>/&<LITERALS>gt</LITERALS>;/g;
        $<CODE>token</CODE> =~ s/\"/&<LITERALS>quot</LITERALS>;/g;
    }
    else {
        <CODE>HTML</CODE>::<CODE>Entities</CODE>::<CODE>encode_entities</CODE>($<CODE>token</CODE>);
    }
    return $<CODE>token</CODE>;
}

sub <CODE>finish_formatting</CODE> {

    # <COMMENTS>called</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS>
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>-><CODE>close_html_file</CODE>();
    return;
}

sub <CODE>write_line</CODE> {

    my $<CODE>self</CODE> = shift;
    return unless $<CODE>self</CODE>->{<LITERALS>_html_file_opened</LITERALS>};
    my $<CODE>html_pre_fh</CODE>      = $<CODE>self</CODE>->{<LITERALS>_html_pre_fh</LITERALS>};
    my ($<CODE>line_of_tokens</CODE>) = @<CODE>_</CODE>;
    my $<CODE>line_type</CODE>        = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>};
    my $<CODE>input_line</CODE>       = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_text</LITERALS>};
    my $<CODE>line_number</CODE>      = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_number</LITERALS>};
    chomp $<CODE>input_line</CODE>;

    # <COMMENTS>markup</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS>..
    my $<CODE>html_line</CODE>;
    if ( $<CODE>line_type</CODE> eq '<LITERALS>CODE</LITERALS>' ) {
        my $<CODE>rtoken_type</CODE> = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rtoken_type</LITERALS>};
        my $<CODE>rtokens</CODE>     = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rtokens</LITERALS>};
        my $<CODE>rlevels</CODE>     = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rlevels</LITERALS>};

        if ( $<CODE>input_line</CODE> =~ /(^\s*)/ ) {
            $<CODE>html_line</CODE> = $<CODE>1</CODE>;
        }
        else {
            $<CODE>html_line</CODE> = "";
        }
        my ($<CODE>rcolored_tokens</CODE>) =
          $<CODE>self</CODE>-><CODE>markup_tokens</CODE>( $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>, $<CODE>rlevels</CODE> );
        $<CODE>html_line</CODE> .= join '', @$<CODE>rcolored_tokens</CODE>;
    }

    # <COMMENTS>markup</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>code</COMMENTS>..
    else {
        my $<CODE>line_character</CODE>;
        if    ( $<CODE>line_type</CODE> eq '<LITERALS>HERE</LITERALS>' )       { $<CODE>line_character</CODE> = '<LITERALS>H</LITERALS>' }
        elsif ( $<CODE>line_type</CODE> eq '<LITERALS>HERE_END</LITERALS>' )   { $<CODE>line_character</CODE> = '<LITERALS>h</LITERALS>' }
        elsif ( $<CODE>line_type</CODE> eq '<LITERALS>FORMAT</LITERALS>' )     { $<CODE>line_character</CODE> = '<LITERALS>H</LITERALS>' }
        elsif ( $<CODE>line_type</CODE> eq '<LITERALS>FORMAT_END</LITERALS>' ) { $<CODE>line_character</CODE> = '<LITERALS>h</LITERALS>' }
        elsif ( $<CODE>line_type</CODE> eq '<LITERALS>SYSTEM</LITERALS>' )     { $<CODE>line_character</CODE> = '<LITERALS>c</LITERALS>' }
        elsif ( $<CODE>line_type</CODE> eq '<LITERALS>END_START</LITERALS>' ) {
            $<CODE>line_character</CODE> = '<LITERALS>k</LITERALS>';
            $<CODE>self</CODE>-><CODE>add_toc_item</CODE>( '<LITERALS>__END__</LITERALS>', '<LITERALS>__END__</LITERALS>' );
        }
        elsif ( $<CODE>line_type</CODE> eq '<LITERALS>DATA_START</LITERALS>' ) {
            $<CODE>line_character</CODE> = '<LITERALS>k</LITERALS>';
            $<CODE>self</CODE>-><CODE>add_toc_item</CODE>( '<LITERALS>__DATA__</LITERALS>', '<LITERALS>__DATA__</LITERALS>' );
        }
        elsif ( $<CODE>line_type</CODE> =~ /^POD/ ) {
            $<CODE>line_character</CODE> = '<LITERALS>P</LITERALS>';
            if ( $<CODE>rOpts</CODE>->{'<LITERALS>pod2html</LITERALS>'} ) {
                my $<CODE>html_pod_fh</CODE> = $<CODE>self</CODE>->{<LITERALS>_html_pod_fh</LITERALS>};
                if ( $<CODE>line_type</CODE> eq '<LITERALS>POD_START</LITERALS>' ) {

                    my $<CODE>rpre_string_stack</CODE> = $<CODE>self</CODE>->{<LITERALS>_rpre_string_stack</LITERALS>};
                    my $<CODE>rpre_string</CODE>       = $<CODE>rpre_string_stack</CODE>->[-1];

                    # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>written</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS>
                    # <COMMENTS>current</COMMENTS> <COMMENTS>pre</COMMENTS> <COMMENTS>section</COMMENTS>, <COMMENTS>start</COMMENTS> <COMMENTS>writing</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>output</COMMENTS>
                    # <COMMENTS>string</COMMENTS>
                    if ( $$<CODE>rpre_string</CODE> =~ /\S/ ) {
                        my $<CODE>pre_string</CODE>;
                        $<CODE>html_pre_fh</CODE> =
                          <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IOScalar</CODE>-><CODE>new</CODE>( \$<CODE>pre_string</CODE>, '<LITERALS>w</LITERALS>' );
                        $<CODE>self</CODE>->{<LITERALS>_html_pre_fh</LITERALS>} = $<CODE>html_pre_fh</CODE>;
                        push @$<CODE>rpre_string_stack</CODE>, \$<CODE>pre_string</CODE>;

                        # <COMMENTS>leave</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>marker</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>stream</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>know</COMMENTS>
                        # <COMMENTS>where</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pre</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>just</COMMENTS>
                        # <COMMENTS>finished</COMMENTS>.
                        my $<CODE>for_html</CODE> = '=<LITERALS>for</LITERALS> <LITERALS>html</LITERALS>';    # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>confuse</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>utils</COMMENTS>
                        $<CODE>html_pod_fh</CODE>-><CODE>print</CODE>(<<<LITERALS>EOM</LITERALS>);

$<CODE>for_html</CODE>
<!-- <LITERALS>pERLTIDY</LITERALS> <LITERALS>sECTION</LITERALS> -->

<CODE>EOM</CODE>
                    }

                    # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>just</COMMENTS> <COMMENTS>clear</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>start</COMMENTS>
                    # <COMMENTS>over</COMMENTS>
                    else {
                        $$<CODE>rpre_string</CODE> = "";
                        $<CODE>html_pod_fh</CODE>-><CODE>print</CODE>("\n");
                    }
                }
                $<CODE>html_pod_fh</CODE>-><CODE>print</CODE>( $<CODE>input_line</CODE> . "\n" );
                if ( $<CODE>line_type</CODE> eq '<LITERALS>POD_END</LITERALS>' ) {
                    $<CODE>self</CODE>->{<LITERALS>_pod_cut_count</LITERALS>}++;
                    $<CODE>html_pod_fh</CODE>-><CODE>print</CODE>("\n");
                }
                return;
            }
        }
        else { $<CODE>line_character</CODE> = '<LITERALS>Q</LITERALS>' }
        $<CODE>html_line</CODE> = $<CODE>self</CODE>-><CODE>markup_html_element</CODE>( $<CODE>input_line</CODE>, $<CODE>line_character</CODE> );
    }

    # <COMMENTS>add</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>html</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>numbers</LITERALS>'} ) {
        my $<CODE>extra_space</CODE> .=
            ( $<CODE>line_number</CODE> < 10 )   ? "   "
          : ( $<CODE>line_number</CODE> < 100 )  ? "  "
          : ( $<CODE>line_number</CODE> < 1000 ) ? " "
          :                           "";
        $<CODE>html_line</CODE> = $<CODE>extra_space</CODE> . $<CODE>line_number</CODE> . " " . $<CODE>html_line</CODE>;
    }

    # <COMMENTS>write</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>
    $<CODE>html_pre_fh</CODE>-><CODE>print</CODE>("$<CODE>html_line</CODE>\n");
}

#####################################################################
#
# <COMMENTS>The</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Formatter</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>adds</COMMENTS> <COMMENTS>indentation</COMMENTS>, <COMMENTS>whitespace</COMMENTS>, <COMMENTS>and</COMMENTS>
# <COMMENTS>line</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>stream</COMMENTS>
#
# <COMMENTS>WARNING</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>real</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>speed</COMMENTS> <COMMENTS>reasons</COMMENTS>.  <COMMENTS>Only</COMMENTS> <COMMENTS>one</COMMENTS>
# <COMMENTS>Formatter</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS>.
#
#####################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Formatter</CODE>;

<CODE>BEGIN</CODE> {

    # <COMMENTS>Caution</COMMENTS>: <COMMENTS>these</COMMENTS> <COMMENTS>debug</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>produce</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>lot</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>output</COMMENTS>
    # <COMMENTS>They</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>0</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>debugging</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>scripts</COMMENTS>
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_RECOMBINE</LITERALS>   => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_BOND_TABLES</LITERALS> => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_BOND</LITERALS>        => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_BREAK</LITERALS>       => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_CI</LITERALS>          => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_FLUSH</LITERALS>       => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_FORCE</LITERALS>       => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_LIST</LITERALS>        => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_NOBREAK</LITERALS>     => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_OUTPUT</LITERALS>      => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_SPARSE</LITERALS>      => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_STORE</LITERALS>       => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_UNDOBP</LITERALS>      => 0;
    use <CODE>constant</CODE> <LITERALS>FORMATTER_DEBUG_FLAG_WHITE</LITERALS>       => 0;

    my $<CODE>debug_warning</CODE> = sub {
        print <CODE>STDOUT</CODE> "<LITERALS>FORMATTER_DEBUGGING</LITERALS> <LITERALS>with</LITERALS> <LITERALS>key</LITERALS> $<CODE>_</CODE>[0]\n";
    };

    <CODE>FORMATTER_DEBUG_FLAG_RECOMBINE</CODE>   && $<CODE>debug_warning</CODE>->('<LITERALS>RECOMBINE</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_BOND_TABLES</CODE> && $<CODE>debug_warning</CODE>->('<LITERALS>BOND_TABLES</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_BOND</CODE>        && $<CODE>debug_warning</CODE>->('<LITERALS>BOND</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_BREAK</CODE>       && $<CODE>debug_warning</CODE>->('<LITERALS>BREAK</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_CI</CODE>          && $<CODE>debug_warning</CODE>->('<LITERALS>CI</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_FLUSH</CODE>       && $<CODE>debug_warning</CODE>->('<LITERALS>FLUSH</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_FORCE</CODE>       && $<CODE>debug_warning</CODE>->('<LITERALS>FORCE</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_LIST</CODE>        && $<CODE>debug_warning</CODE>->('<LITERALS>LIST</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_NOBREAK</CODE>     && $<CODE>debug_warning</CODE>->('<LITERALS>NOBREAK</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_OUTPUT</CODE>      && $<CODE>debug_warning</CODE>->('<LITERALS>OUTPUT</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_SPARSE</CODE>      && $<CODE>debug_warning</CODE>->('<LITERALS>SPARSE</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_STORE</CODE>       && $<CODE>debug_warning</CODE>->('<LITERALS>STORE</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_UNDOBP</CODE>      && $<CODE>debug_warning</CODE>->('<LITERALS>UNDOBP</LITERALS>');
    <CODE>FORMATTER_DEBUG_FLAG_WHITE</CODE>       && $<CODE>debug_warning</CODE>->('<LITERALS>WHITE</LITERALS>');
}

use <CODE>Carp</CODE>;
use <CODE>vars</CODE> qw{

  @<CODE>gnu_stack</CODE>
  $<CODE>max_gnu_stack_index</CODE>
  $<CODE>gnu_position_predictor</CODE>
  $<CODE>line_start_index_to_go</CODE>
  $<CODE>last_indentation_written</CODE>
  $<CODE>last_unadjusted_indentation</CODE>
  $<CODE>last_leading_token</CODE>
  $<CODE>last_output_short_opening_token</CODE>

  $<CODE>saw_VERSION_in_this_file</CODE>
  $<CODE>saw_END_or_DATA_</CODE>

  @<CODE>gnu_item_list</CODE>
  $<CODE>max_gnu_item_index</CODE>
  $<CODE>gnu_sequence_number</CODE>
  $<CODE>last_output_indentation</CODE>
  %<CODE>last_gnu_equals</CODE>
  %<CODE>gnu_comma_count</CODE>
  %<CODE>gnu_arrow_count</CODE>

  @<CODE>block_type_to_go</CODE>
  @<CODE>type_sequence_to_go</CODE>
  @<CODE>container_environment_to_go</CODE>
  @<CODE>bond_strength_to_go</CODE>
  @<CODE>forced_breakpoint_to_go</CODE>
  @<CODE>token_lengths_to_go</CODE>
  @<CODE>summed_lengths_to_go</CODE>
  @<CODE>levels_to_go</CODE>
  @<CODE>leading_spaces_to_go</CODE>
  @<CODE>reduced_spaces_to_go</CODE>
  @<CODE>matching_token_to_go</CODE>
  @<CODE>mate_index_to_go</CODE>
  @<CODE>nesting_blocks_to_go</CODE>
  @<CODE>ci_levels_to_go</CODE>
  @<CODE>nesting_depth_to_go</CODE>
  @<CODE>nobreak_to_go</CODE>
  @<CODE>old_breakpoint_to_go</CODE>
  @<CODE>tokens_to_go</CODE>
  @<CODE>types_to_go</CODE>
  @<CODE>inext_to_go</CODE>
  @<CODE>iprev_to_go</CODE>

  %<CODE>saved_opening_indentation</CODE>

  $<CODE>max_index_to_go</CODE>
  $<CODE>comma_count_in_batch</CODE>
  $<CODE>old_line_count_in_batch</CODE>
  $<CODE>last_nonblank_index_to_go</CODE>
  $<CODE>last_nonblank_type_to_go</CODE>
  $<CODE>last_nonblank_token_to_go</CODE>
  $<CODE>last_last_nonblank_index_to_go</CODE>
  $<CODE>last_last_nonblank_type_to_go</CODE>
  $<CODE>last_last_nonblank_token_to_go</CODE>
  @<CODE>nonblank_lines_at_depth</CODE>
  $<CODE>starting_in_quote</CODE>
  $<CODE>ending_in_quote</CODE>
  @<CODE>whitespace_level_stack</CODE>
  $<CODE>whitespace_last_level</CODE>

  $<CODE>in_format_skipping_section</CODE>
  $<CODE>format_skipping_pattern_begin</CODE>
  $<CODE>format_skipping_pattern_end</CODE>

  $<CODE>forced_breakpoint_count</CODE>
  $<CODE>forced_breakpoint_undo_count</CODE>
  @<CODE>forced_breakpoint_undo_stack</CODE>
  %<CODE>postponed_breakpoint</CODE>

  $<CODE>tabbing</CODE>
  $<CODE>embedded_tab_count</CODE>
  $<CODE>first_embedded_tab_at</CODE>
  $<CODE>last_embedded_tab_at</CODE>
  $<CODE>deleted_semicolon_count</CODE>
  $<CODE>first_deleted_semicolon_at</CODE>
  $<CODE>last_deleted_semicolon_at</CODE>
  $<CODE>added_semicolon_count</CODE>
  $<CODE>first_added_semicolon_at</CODE>
  $<CODE>last_added_semicolon_at</CODE>
  $<CODE>first_tabbing_disagreement</CODE>
  $<CODE>last_tabbing_disagreement</CODE>
  $<CODE>in_tabbing_disagreement</CODE>
  $<CODE>tabbing_disagreement_count</CODE>
  $<CODE>input_line_tabbing</CODE>

  $<CODE>last_line_type</CODE>
  $<CODE>last_line_leading_type</CODE>
  $<CODE>last_line_leading_level</CODE>
  $<CODE>last_last_line_leading_level</CODE>

  %<CODE>block_leading_text</CODE>
  %<CODE>block_opening_line_number</CODE>
  $<CODE>csc_new_statement_ok</CODE>
  $<CODE>csc_last_label</CODE>
  %<CODE>csc_block_label</CODE>
  $<CODE>accumulating_text_for_block</CODE>
  $<CODE>leading_block_text</CODE>
  $<CODE>rleading_block_if_elsif_text</CODE>
  $<CODE>leading_block_text_level</CODE>
  $<CODE>leading_block_text_length_exceeded</CODE>
  $<CODE>leading_block_text_line_length</CODE>
  $<CODE>leading_block_text_line_number</CODE>
  $<CODE>closing_side_comment_prefix_pattern</CODE>
  $<CODE>closing_side_comment_list_pattern</CODE>

  $<CODE>last_nonblank_token</CODE>
  $<CODE>last_nonblank_type</CODE>
  $<CODE>last_last_nonblank_token</CODE>
  $<CODE>last_last_nonblank_type</CODE>
  $<CODE>last_nonblank_block_type</CODE>
  $<CODE>last_output_level</CODE>
  %<CODE>is_do_follower</CODE>
  %<CODE>is_if_brace_follower</CODE>
  %<CODE>space_after_keyword</CODE>
  $<CODE>rbrace_follower</CODE>
  $<CODE>looking_for_else</CODE>
  %<CODE>is_last_next_redo_return</CODE>
  %<CODE>is_other_brace_follower</CODE>
  %<CODE>is_else_brace_follower</CODE>
  %<CODE>is_anon_sub_brace_follower</CODE>
  %<CODE>is_anon_sub_1_brace_follower</CODE>
  %<CODE>is_sort_map_grep</CODE>
  %<CODE>is_sort_map_grep_eval</CODE>
  %<CODE>is_sort_map_grep_eval_do</CODE>
  %<CODE>is_block_without_semicolon</CODE>
  %<CODE>is_if_unless</CODE>
  %<CODE>is_and_or</CODE>
  %<CODE>is_assignment</CODE>
  %<CODE>is_chain_operator</CODE>
  %<CODE>is_if_unless_and_or_last_next_redo_return</CODE>
  %<CODE>ok_to_add_semicolon_for_block_type</CODE>

  @<CODE>has_broken_sublist</CODE>
  @<CODE>dont_align</CODE>
  @<CODE>want_comma_break</CODE>

  $<CODE>is_static_block_comment</CODE>
  $<CODE>index_start_one_line_block</CODE>
  $<CODE>semicolons_before_block_self_destruct</CODE>
  $<CODE>index_max_forced_break</CODE>
  $<CODE>input_line_number</CODE>
  $<CODE>diagnostics_object</CODE>
  $<CODE>vertical_aligner_object</CODE>
  $<CODE>logger_object</CODE>
  $<CODE>file_writer_object</CODE>
  $<CODE>formatter_self</CODE>
  @<CODE>ci_stack</CODE>
  $<CODE>last_line_had_side_comment</CODE>
  %<CODE>want_break_before</CODE>
  %<CODE>outdent_keyword</CODE>
  $<CODE>static_block_comment_pattern</CODE>
  $<CODE>static_side_comment_pattern</CODE>
  %<CODE>opening_vertical_tightness</CODE>
  %<CODE>closing_vertical_tightness</CODE>
  %<CODE>closing_token_indentation</CODE>
  $<CODE>some_closing_token_indentation</CODE>

  %<CODE>opening_token_right</CODE>
  %<CODE>stack_opening_token</CODE>
  %<CODE>stack_closing_token</CODE>

  $<CODE>block_brace_vertical_tightness_pattern</CODE>

  $<CODE>rOpts_add_newlines</CODE>
  $<CODE>rOpts_add_whitespace</CODE>
  $<CODE>rOpts_block_brace_tightness</CODE>
  $<CODE>rOpts_block_brace_vertical_tightness</CODE>
  $<CODE>rOpts_brace_left_and_indent</CODE>
  $<CODE>rOpts_comma_arrow_breakpoints</CODE>
  $<CODE>rOpts_break_at_old_keyword_breakpoints</CODE>
  $<CODE>rOpts_break_at_old_comma_breakpoints</CODE>
  $<CODE>rOpts_break_at_old_logical_breakpoints</CODE>
  $<CODE>rOpts_break_at_old_ternary_breakpoints</CODE>
  $<CODE>rOpts_break_at_old_attribute_breakpoints</CODE>
  $<CODE>rOpts_closing_side_comment_else_flag</CODE>
  $<CODE>rOpts_closing_side_comment_maximum_text</CODE>
  $<CODE>rOpts_continuation_indentation</CODE>
  $<CODE>rOpts_cuddled_else</CODE>
  $<CODE>rOpts_delete_old_whitespace</CODE>
  $<CODE>rOpts_fuzzy_line_length</CODE>
  $<CODE>rOpts_indent_columns</CODE>
  $<CODE>rOpts_line_up_parentheses</CODE>
  $<CODE>rOpts_maximum_fields_per_table</CODE>
  $<CODE>rOpts_maximum_line_length</CODE>
  $<CODE>rOpts_variable_maximum_line_length</CODE>
  $<CODE>rOpts_short_concatenation_item_length</CODE>
  $<CODE>rOpts_keep_old_blank_lines</CODE>
  $<CODE>rOpts_ignore_old_breakpoints</CODE>
  $<CODE>rOpts_format_skipping</CODE>
  $<CODE>rOpts_space_function_paren</CODE>
  $<CODE>rOpts_space_keyword_paren</CODE>
  $<CODE>rOpts_keep_interior_semicolons</CODE>
  $<CODE>rOpts_ignore_side_comment_lengths</CODE>
  $<CODE>rOpts_stack_closing_block_brace</CODE>
  $<CODE>rOpts_whitespace_cycle</CODE>
  $<CODE>rOpts_tight_secret_operators</CODE>

  %<CODE>is_opening_type</CODE>
  %<CODE>is_closing_type</CODE>
  %<CODE>is_keyword_returning_list</CODE>
  %<CODE>tightness</CODE>
  %<CODE>matching_token</CODE>
  $<CODE>rOpts</CODE>
  %<CODE>right_bond_strength</CODE>
  %<CODE>left_bond_strength</CODE>
  %<CODE>binary_ws_rules</CODE>
  %<CODE>want_left_space</CODE>
  %<CODE>want_right_space</CODE>
  %<CODE>is_digraph</CODE>
  %<CODE>is_trigraph</CODE>
  $<CODE>bli_pattern</CODE>
  $<CODE>bli_list_string</CODE>
  %<CODE>is_closing_type</CODE>
  %<CODE>is_opening_type</CODE>
  %<CODE>is_closing_token</CODE>
  %<CODE>is_opening_token</CODE>
};

<CODE>BEGIN</CODE> {

    # <COMMENTS>default</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>which</COMMENTS> -<COMMENTS>bli</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>apply</COMMENTS>
    $<CODE>bli_list_string</CODE> = '<LITERALS>if</LITERALS> <LITERALS>else</LITERALS> <LITERALS>elsif</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>while</LITERALS> <LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS> <LITERALS>do</LITERALS> : <LITERALS>sub</LITERALS>';

    @<CODE>_</CODE> = qw(
      .. :: << >> ** && .. || // -> => += -= .= %= &= |= ^= *= <>
      <= >= == =~ !~ != ++ -- /= <LITERALS>x</LITERALS>=
    );
    @<CODE>is_digraph</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    @<CODE>_</CODE> = qw( ... **= <<= >>= &&= ||= //= <=> );
    @<CODE>is_trigraph</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    @<CODE>_</CODE> = qw(
      = **= += *= &= <<= &&=
      -= /= |= >>= ||= //=
      .= %= ^=
      <LITERALS>x</LITERALS>=
    );
    @<CODE>is_assignment</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    @<CODE>_</CODE> = qw(
      <LITERALS>grep</LITERALS>
      <LITERALS>keys</LITERALS>
      <LITERALS>map</LITERALS>
      <LITERALS>reverse</LITERALS>
      <LITERALS>sort</LITERALS>
      <LITERALS>split</LITERALS>
    );
    @<CODE>is_keyword_returning_list</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    @<CODE>_</CODE> = qw(<LITERALS>is</LITERALS> <LITERALS>if</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>and</LITERALS> <LITERALS>or</LITERALS> <LITERALS>err</LITERALS> <LITERALS>last</LITERALS> <LITERALS>next</LITERALS> <LITERALS>redo</LITERALS> <LITERALS>return</LITERALS>);
    @<CODE>is_if_unless_and_or_last_next_redo_return</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    @<CODE>_</CODE> = qw(<LITERALS>last</LITERALS> <LITERALS>next</LITERALS> <LITERALS>redo</LITERALS> <LITERALS>return</LITERALS>);
    @<CODE>is_last_next_redo_return</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    @<CODE>_</CODE> = qw(<LITERALS>sort</LITERALS> <LITERALS>map</LITERALS> <LITERALS>grep</LITERALS>);
    @<CODE>is_sort_map_grep</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    @<CODE>_</CODE> = qw(<LITERALS>sort</LITERALS> <LITERALS>map</LITERALS> <LITERALS>grep</LITERALS> <LITERALS>eval</LITERALS>);
    @<CODE>is_sort_map_grep_eval</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    @<CODE>_</CODE> = qw(<LITERALS>sort</LITERALS> <LITERALS>map</LITERALS> <LITERALS>grep</LITERALS> <LITERALS>eval</LITERALS> <LITERALS>do</LITERALS>);
    @<CODE>is_sort_map_grep_eval_do</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    @<CODE>_</CODE> = qw(<LITERALS>if</LITERALS> <LITERALS>unless</LITERALS>);
    @<CODE>is_if_unless</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    @<CODE>_</CODE> = qw(<LITERALS>and</LITERALS> <LITERALS>or</LITERALS> <LITERALS>err</LITERALS>);
    @<CODE>is_and_or</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>Identify</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>operators</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>often</COMMENTS> <COMMENTS>occur</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>chains</COMMENTS>.
    # <COMMENTS>Note</COMMENTS>: <COMMENTS>the</COMMENTS> <COMMENTS>minus</COMMENTS> (-) <COMMENTS>causes</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>effect</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>in</COMMENTS>
    # <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS> (<COMMENTS>by</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>set_logical_padding</COMMENTS>):
    #    <COMMENTS>Checkbutton</COMMENTS> => '<COMMENTS>Transmission</COMMENTS> <COMMENTS>checked</COMMENTS>',
    #   -<COMMENTS>variable</COMMENTS>    => \<COMMENTS>$TRANS</COMMENTS>
    # <COMMENTS>This</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>improves</COMMENTS> <COMMENTS>appearance</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>ok</COMMENTS>.
    @<CODE>_</CODE> = qw(&& || <LITERALS>and</LITERALS> <LITERALS>or</LITERALS> : ? . + - * /);
    @<CODE>is_chain_operator</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>We</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>semicolons</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>preceded</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>keywords</COMMENTS>
    @<CODE>_</CODE> =
      qw(<LITERALS>BEGIN</LITERALS> <LITERALS>END</LITERALS> <LITERALS>CHECK</LITERALS> <LITERALS>INIT</LITERALS> <LITERALS>AUTOLOAD</LITERALS> <LITERALS>DESTROY</LITERALS> <LITERALS>UNITCHECK</LITERALS> <LITERALS>continue</LITERALS> <LITERALS>if</LITERALS> <LITERALS>elsif</LITERALS> <LITERALS>else</LITERALS>
      <LITERALS>unless</LITERALS> <LITERALS>while</LITERALS> <LITERALS>until</LITERALS> <LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS> <LITERALS>given</LITERALS> <LITERALS>when</LITERALS> <LITERALS>default</LITERALS>);
    @<CODE>is_block_without_semicolon</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>semicolons</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>added</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS>
    # <COMMENTS>as</COMMENTS> <COMMENTS>well</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>blocks</COMMENTS>.
    # <COMMENTS>NOTES</COMMENTS>:
    # <COMMENTS>1</COMMENTS>. <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>omitted</COMMENTS>:
    #     <COMMENTS>switch</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>sort</COMMENTS> <COMMENTS>map</COMMENTS> <COMMENTS>grep</COMMENTS>
    # <COMMENTS>2</COMMENTS>. <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>labeled</COMMENTS> <COMMENTS>block</COMMENTS>
    # <COMMENTS>3</COMMENTS>. <COMMENTS>But</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>okay</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>including</COMMENTS>:
    #     { } ; <COMMENTS>G</COMMENTS> <COMMENTS>t</COMMENTS>
    # <COMMENTS>4</COMMENTS>. <COMMENTS>Test</COMMENTS> <COMMENTS>files</COMMENTS>: <COMMENTS>blktype</COMMENTS>.<COMMENTS>t</COMMENTS>, <COMMENTS>blktype1</COMMENTS>.<COMMENTS>t</COMMENTS>, <COMMENTS>semicolon</COMMENTS>.<COMMENTS>t</COMMENTS>
    @<CODE>_</CODE> =
      qw( <LITERALS>BEGIN</LITERALS> <LITERALS>END</LITERALS> <LITERALS>CHECK</LITERALS> <LITERALS>INIT</LITERALS> <LITERALS>AUTOLOAD</LITERALS> <LITERALS>DESTROY</LITERALS> <LITERALS>UNITCHECK</LITERALS> <LITERALS>continue</LITERALS> <LITERALS>if</LITERALS> <LITERALS>elsif</LITERALS> <LITERALS>else</LITERALS>
      <LITERALS>unless</LITERALS> <LITERALS>do</LITERALS> <LITERALS>while</LITERALS> <LITERALS>until</LITERALS> <LITERALS>eval</LITERALS> <LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS> );
    @<CODE>ok_to_add_semicolon_for_block_type</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # '<COMMENTS>L</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>opening</COMMENTS> { <COMMENTS>at</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>key</COMMENTS>
    @<CODE>_</CODE> = qw" <LITERALS>L</LITERALS> { ( [ ";
    @<CODE>is_opening_type</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # '<COMMENTS>R</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>closing</COMMENTS> } <COMMENTS>at</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>key</COMMENTS>
    @<CODE>_</CODE> = qw" <LITERALS>R</LITERALS> } ) ] ";
    @<CODE>is_closing_type</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    @<CODE>_</CODE> = qw" { ( [ ";
    @<CODE>is_opening_token</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    @<CODE>_</CODE> = qw" } ) ] ";
    @<CODE>is_closing_token</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);
}

# <COMMENTS>whitespace</COMMENTS> <COMMENTS>codes</COMMENTS>
use <CODE>constant</CODE> <LITERALS>WS_YES</LITERALS>      => 1;
use <CODE>constant</CODE> <LITERALS>WS_OPTIONAL</LITERALS> => 0;
use <CODE>constant</CODE> <LITERALS>WS_NO</LITERALS>       => -1;

# <COMMENTS>Token</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS>.
use <CODE>constant</CODE> <LITERALS>NO_BREAK</LITERALS>    => 10000;
use <CODE>constant</CODE> <LITERALS>VERY_STRONG</LITERALS> => 100;
use <CODE>constant</CODE> <LITERALS>STRONG</LITERALS>      => 2.1;
use <CODE>constant</CODE> <LITERALS>NOMINAL</LITERALS>     => 1.1;
use <CODE>constant</CODE> <LITERALS>WEAK</LITERALS>        => 0.8;
use <CODE>constant</CODE> <LITERALS>VERY_WEAK</LITERALS>   => 0.55;

# <COMMENTS>values</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>testing</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>array</COMMENTS>
use <CODE>constant</CODE> <LITERALS>UNDEFINED_INDEX</LITERALS> => -1;

# <COMMENTS>Maximum</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>little</COMMENTS> <COMMENTS>messages</COMMENTS>; <COMMENTS>probably</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>changed</COMMENTS>.
use <CODE>constant</CODE> <LITERALS>MAX_NAG_MESSAGES</LITERALS> => 6;

# <COMMENTS>increment</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>type</COMMENTS>
# <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, ?: <COMMENTS>pairs</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>7</COMMENTS>,<COMMENTS>11</COMMENTS>,<COMMENTS>15</COMMENTS>,...
use <CODE>constant</CODE> <LITERALS>TYPE_SEQUENCE_INCREMENT</LITERALS> => 4;

{

    # <COMMENTS>methods</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>instances</COMMENTS>
    my $<CODE>_count</CODE> = 0;
    sub <CODE>get_count</CODE>        { $<CODE>_count</CODE>; }
    sub <CODE>_increment_count</CODE> { ++$<CODE>_count</CODE> }
    sub <CODE>_decrement_count</CODE> { --$<CODE>_count</CODE> }
}

sub <CODE>trim</CODE> {

    # <COMMENTS>trim</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS>
    $<CODE>_</CODE>[0] =~ s/\s+$//;
    $<CODE>_</CODE>[0] =~ s/^\s+//;
    return $<CODE>_</CODE>[0];
}

sub <CODE>max</CODE> {
    my $<CODE>max</CODE> = shift;
    foreach (@<CODE>_</CODE>) {
        $<CODE>max</CODE> = ( $<CODE>max</CODE> < $<CODE>_</CODE> ) ? $<CODE>_</CODE> : $<CODE>max</CODE>;
    }
    return $<CODE>max</CODE>;
}

sub <CODE>min</CODE> {
    my $<CODE>min</CODE> = shift;
    foreach (@<CODE>_</CODE>) {
        $<CODE>min</CODE> = ( $<CODE>min</CODE> > $<CODE>_</CODE> ) ? $<CODE>_</CODE> : $<CODE>min</CODE>;
    }
    return $<CODE>min</CODE>;
}

sub <CODE>split_words</CODE> {

    # <COMMENTS>given</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>containing</COMMENTS> <COMMENTS>words</COMMENTS> <COMMENTS>separated</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>whitespace</COMMENTS>,
    # <COMMENTS>return</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>words</COMMENTS>
    my ($<CODE>str</CODE>) = @<CODE>_</CODE>;
    return unless $<CODE>str</CODE>;
    $<CODE>str</CODE> =~ s/\s+$//;
    $<CODE>str</CODE> =~ s/^\s+//;
    return split( /\s+/, $<CODE>str</CODE> );
}

# <COMMENTS>interface</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Logger</COMMENTS> <COMMENTS>routines</COMMENTS>
sub <CODE>warning</CODE> {
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>warning</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>complain</CODE> {
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>complain</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>write_logfile_entry</CODE> {
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>black_box</CODE> {
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>black_box</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>report_definite_bug</CODE> {
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>report_definite_bug</CODE>();
    }
}

sub <CODE>get_saw_brace_error</CODE> {
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>get_saw_brace_error</CODE>();
    }
}

sub <CODE>we_are_at_the_last_line</CODE> {
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>we_are_at_the_last_line</CODE>();
    }
}

# <COMMENTS>interface</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Diagnostics</COMMENTS> <COMMENTS>routine</COMMENTS>
sub <CODE>write_diagnostics</CODE> {

    if ($<CODE>diagnostics_object</CODE>) {
        $<CODE>diagnostics_object</CODE>-><CODE>write_diagnostics</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>get_added_semicolon_count</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>added_semicolon_count</CODE>;
}

sub <CODE>DESTROY</CODE> {
    $<CODE>_</CODE>[0]-><CODE>_decrement_count</CODE>();
}

sub <CODE>new</CODE> {

    my $<CODE>class</CODE> = shift;

    # <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>write_line</COMMENTS>() <COMMENTS>method</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>take</COMMENTS> <COMMENTS>lines</COMMENTS>
    my %<CODE>defaults</CODE> = (
        <LITERALS>sink_object</LITERALS>        => undef,
        <LITERALS>diagnostics_object</LITERALS> => undef,
        <LITERALS>logger_object</LITERALS>      => undef,
    );
    my %<CODE>args</CODE> = ( %<CODE>defaults</CODE>, @<CODE>_</CODE> );

    $<CODE>logger_object</CODE>      = $<CODE>args</CODE>{<LITERALS>logger_object</LITERALS>};
    $<CODE>diagnostics_object</CODE> = $<CODE>args</CODE>{<LITERALS>diagnostics_object</LITERALS>};

    # <COMMENTS>we</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>get_line</COMMENTS>() <COMMENTS>and</COMMENTS> <COMMENTS>peek_ahead</COMMENTS>() <COMMENTS>method</COMMENTS>
    my $<CODE>sink_object</CODE> = $<CODE>args</CODE>{<LITERALS>sink_object</LITERALS>};
    $<CODE>file_writer_object</CODE> =
      <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>FileWriter</CODE>-><CODE>new</CODE>( $<CODE>sink_object</CODE>, $<CODE>rOpts</CODE>, $<CODE>logger_object</CODE> );

    # <COMMENTS>initialize</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>stack</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>negative</COMMENTS> <COMMENTS>levels</COMMENTS>
    # <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>never</COMMENTS> <COMMENTS>run</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>stack</COMMENTS>
    $<CODE>gnu_position_predictor</CODE> = 0;    # <COMMENTS>where</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>predicted</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS>
    $<CODE>max_gnu_stack_index</CODE>    = 0;
    $<CODE>max_gnu_item_index</CODE>     = -1;
    $<CODE>gnu_stack</CODE>[0] = <CODE>new_lp_indentation_item</CODE>( 0, -1, -1, 0, 0 );
    @<CODE>gnu_item_list</CODE>                   = ();
    $<CODE>last_output_indentation</CODE>         = 0;
    $<CODE>last_indentation_written</CODE>        = 0;
    $<CODE>last_unadjusted_indentation</CODE>     = 0;
    $<CODE>last_leading_token</CODE>              = "";
    $<CODE>last_output_short_opening_token</CODE> = 0;

    $<CODE>saw_VERSION_in_this_file</CODE> = !$<CODE>rOpts</CODE>->{'<LITERALS>pass</LITERALS>-<LITERALS>version</LITERALS>-<LITERALS>line</LITERALS>'};
    $<CODE>saw_END_or_DATA_</CODE>         = 0;

    @<CODE>block_type_to_go</CODE>            = ();
    @<CODE>type_sequence_to_go</CODE>         = ();
    @<CODE>container_environment_to_go</CODE> = ();
    @<CODE>bond_strength_to_go</CODE>         = ();
    @<CODE>forced_breakpoint_to_go</CODE>     = ();
    @<CODE>summed_lengths_to_go</CODE>        = ();    # <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>ith</COMMENTS> <COMMENTS>token</COMMENTS>
    @<CODE>token_lengths_to_go</CODE>         = ();
    @<CODE>levels_to_go</CODE>                = ();
    @<CODE>matching_token_to_go</CODE>        = ();
    @<CODE>mate_index_to_go</CODE>            = ();
    @<CODE>nesting_blocks_to_go</CODE>        = ();
    @<CODE>ci_levels_to_go</CODE>             = ();
    @<CODE>nesting_depth_to_go</CODE>         = (0);
    @<CODE>nobreak_to_go</CODE>               = ();
    @<CODE>old_breakpoint_to_go</CODE>        = ();
    @<CODE>tokens_to_go</CODE>                = ();
    @<CODE>types_to_go</CODE>                 = ();
    @<CODE>leading_spaces_to_go</CODE>        = ();
    @<CODE>reduced_spaces_to_go</CODE>        = ();
    @<CODE>inext_to_go</CODE>                 = ();
    @<CODE>iprev_to_go</CODE>                 = ();

    @<CODE>whitespace_level_stack</CODE> = ();
    $<CODE>whitespace_last_level</CODE>  = -1;

    @<CODE>dont_align</CODE>         = ();
    @<CODE>has_broken_sublist</CODE> = ();
    @<CODE>want_comma_break</CODE>   = ();

    @<CODE>ci_stack</CODE>                   = ("");
    $<CODE>first_tabbing_disagreement</CODE> = 0;
    $<CODE>last_tabbing_disagreement</CODE>  = 0;
    $<CODE>tabbing_disagreement_count</CODE> = 0;
    $<CODE>in_tabbing_disagreement</CODE>    = 0;
    $<CODE>input_line_tabbing</CODE>         = undef;

    $<CODE>last_line_type</CODE>               = "";
    $<CODE>last_last_line_leading_level</CODE> = 0;
    $<CODE>last_line_leading_level</CODE>      = 0;
    $<CODE>last_line_leading_type</CODE>       = '#';

    $<CODE>last_nonblank_token</CODE>        = ';';
    $<CODE>last_nonblank_type</CODE>         = ';';
    $<CODE>last_last_nonblank_token</CODE>   = ';';
    $<CODE>last_last_nonblank_type</CODE>    = ';';
    $<CODE>last_nonblank_block_type</CODE>   = "";
    $<CODE>last_output_level</CODE>          = 0;
    $<CODE>looking_for_else</CODE>           = 0;
    $<CODE>embedded_tab_count</CODE>         = 0;
    $<CODE>first_embedded_tab_at</CODE>      = 0;
    $<CODE>last_embedded_tab_at</CODE>       = 0;
    $<CODE>deleted_semicolon_count</CODE>    = 0;
    $<CODE>first_deleted_semicolon_at</CODE> = 0;
    $<CODE>last_deleted_semicolon_at</CODE>  = 0;
    $<CODE>added_semicolon_count</CODE>      = 0;
    $<CODE>first_added_semicolon_at</CODE>   = 0;
    $<CODE>last_added_semicolon_at</CODE>    = 0;
    $<CODE>last_line_had_side_comment</CODE> = 0;
    $<CODE>is_static_block_comment</CODE>    = 0;
    %<CODE>postponed_breakpoint</CODE>       = ();

    # <COMMENTS>variables</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>
    %<CODE>block_leading_text</CODE>        = ();
    %<CODE>block_opening_line_number</CODE> = ();
    $<CODE>csc_new_statement_ok</CODE>      = 1;
    %<CODE>csc_block_label</CODE>           = ();

    %<CODE>saved_opening_indentation</CODE>  = ();
    $<CODE>in_format_skipping_section</CODE> = 0;

    <CODE>reset_block_text_accumulator</CODE>();

    <CODE>prepare_for_new_input_lines</CODE>();

    $<CODE>vertical_aligner_object</CODE> =
      <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>-><CODE>initialize</CODE>( $<CODE>rOpts</CODE>, $<CODE>file_writer_object</CODE>,
        $<CODE>logger_object</CODE>, $<CODE>diagnostics_object</CODE> );

    if ( $<CODE>rOpts</CODE>->{'<LITERALS>entab</LITERALS>-<LITERALS>leading</LITERALS>-<LITERALS>whitespace</LITERALS>'} ) {
        <CODE>write_logfile_entry</CODE>(
"<LITERALS>Leading</LITERALS> <LITERALS>whitespace</LITERALS> <LITERALS>will</LITERALS> <LITERALS>be</LITERALS> <LITERALS>entabbed</LITERALS> <LITERALS>with</LITERALS> $<CODE>rOpts</CODE>->{'<LITERALS>entab</LITERALS>-<LITERALS>leading</LITERALS>-<LITERALS>whitespace</LITERALS>'} <LITERALS>spaces</LITERALS> <LITERALS>per</LITERALS> <LITERALS>tab</LITERALS>\n"
        );
    }
    elsif ( $<CODE>rOpts</CODE>->{'<LITERALS>tabs</LITERALS>'} ) {
        <CODE>write_logfile_entry</CODE>("<LITERALS>Indentation</LITERALS> <LITERALS>will</LITERALS> <LITERALS>be</LITERALS> <LITERALS>with</LITERALS> <LITERALS>a</LITERALS> <LITERALS>tab</LITERALS> <LITERALS>character</LITERALS>\n");
    }
    else {
        <CODE>write_logfile_entry</CODE>(
            "<LITERALS>Indentation</LITERALS> <LITERALS>will</LITERALS> <LITERALS>be</LITERALS> <LITERALS>with</LITERALS> $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>columns</LITERALS>'} <LITERALS>spaces</LITERALS>\n");
    }

    # <COMMENTS>This</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>formatter</COMMENTS> <COMMENTS>referent</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>object</COMMENTS>-<COMMENTS>oriented</COMMENTS>
    # <COMMENTS>coding</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>turned</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>slow</COMMENTS> <COMMENTS>here</COMMENTS>.
    $<CODE>formatter_self</CODE> = {};

    bless $<CODE>formatter_self</CODE>, $<CODE>class</CODE>;

    # <COMMENTS>Safety</COMMENTS> <COMMENTS>check</COMMENTS>..<COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>yet</COMMENTS>
    if ( <CODE>_increment_count</CODE>() > 1 ) {
        <CODE>confess</CODE>
"<LITERALS>Attempt</LITERALS> <LITERALS>to</LITERALS> <LITERALS>create</LITERALS> <LITERALS>more</LITERALS> <LITERALS>than</LITERALS> <LITERALS>1</LITERALS> <LITERALS>object</LITERALS> <LITERALS>in</LITERALS> $<CODE>class</CODE>, <LITERALS>which</LITERALS> <LITERALS>is</LITERALS> <LITERALS>not</LITERALS> <LITERALS>a</LITERALS> <LITERALS>true</LITERALS> <LITERALS>class</LITERALS> <LITERALS>yet</LITERALS>\n";
    }
    return $<CODE>formatter_self</CODE>;
}

sub <CODE>prepare_for_new_input_lines</CODE> {

    $<CODE>gnu_sequence_number</CODE>++;    # <COMMENTS>increment</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>batch</COMMENTS> <COMMENTS>counter</COMMENTS>
    %<CODE>last_gnu_equals</CODE>                = ();
    %<CODE>gnu_comma_count</CODE>                = ();
    %<CODE>gnu_arrow_count</CODE>                = ();
    $<CODE>line_start_index_to_go</CODE>         = 0;
    $<CODE>max_gnu_item_index</CODE>             = <CODE>UNDEFINED_INDEX</CODE>;
    $<CODE>index_max_forced_break</CODE>         = <CODE>UNDEFINED_INDEX</CODE>;
    $<CODE>max_index_to_go</CODE>                = <CODE>UNDEFINED_INDEX</CODE>;
    $<CODE>last_nonblank_index_to_go</CODE>      = <CODE>UNDEFINED_INDEX</CODE>;
    $<CODE>last_nonblank_type_to_go</CODE>       = '';
    $<CODE>last_nonblank_token_to_go</CODE>      = '';
    $<CODE>last_last_nonblank_index_to_go</CODE> = <CODE>UNDEFINED_INDEX</CODE>;
    $<CODE>last_last_nonblank_type_to_go</CODE>  = '';
    $<CODE>last_last_nonblank_token_to_go</CODE> = '';
    $<CODE>forced_breakpoint_count</CODE>        = 0;
    $<CODE>forced_breakpoint_undo_count</CODE>   = 0;
    $<CODE>rbrace_follower</CODE>                = undef;
    $<CODE>summed_lengths_to_go</CODE>[0]        = 0;
    $<CODE>old_line_count_in_batch</CODE>        = 1;
    $<CODE>comma_count_in_batch</CODE>           = 0;
    $<CODE>starting_in_quote</CODE>              = 0;

    <CODE>destroy_one_line_block</CODE>();
}

sub <CODE>write_line</CODE> {

    my $<CODE>self</CODE> = shift;
    my ($<CODE>line_of_tokens</CODE>) = @<CODE>_</CODE>;

    my $<CODE>line_type</CODE>  = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>};
    my $<CODE>input_line</CODE> = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_text</LITERALS>};

    if ( $<CODE>rOpts</CODE>->{<LITERALS>notidy</LITERALS>} ) {
        <CODE>write_unindented_line</CODE>($<CODE>input_line</CODE>);
        $<CODE>last_line_type</CODE> = $<CODE>line_type</CODE>;
        return;
    }

    # <COMMENTS>_line_type</COMMENTS> <COMMENTS>codes</COMMENTS> <COMMENTS>are</COMMENTS>:
    #   <COMMENTS>SYSTEM</COMMENTS>         - <COMMENTS>system</COMMENTS>-<COMMENTS>specific</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>hash</COMMENTS>-<COMMENTS>bang</COMMENTS> <COMMENTS>line</COMMENTS>
    #   <COMMENTS>CODE</COMMENTS>           - <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>code</COMMENTS> (<COMMENTS>including</COMMENTS> <COMMENTS>comments</COMMENTS>)
    #   <COMMENTS>POD_START</COMMENTS>      - <COMMENTS>line</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>pod</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> '=<COMMENTS>head</COMMENTS>'
    #   <COMMENTS>POD</COMMENTS>            - <COMMENTS>pod</COMMENTS> <COMMENTS>documentation</COMMENTS> <COMMENTS>text</COMMENTS>
    #   <COMMENTS>POD_END</COMMENTS>        - <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>section</COMMENTS>, '=<COMMENTS>cut</COMMENTS>'
    #   <COMMENTS>HERE</COMMENTS>           - <COMMENTS>text</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>document</COMMENTS>
    #   <COMMENTS>HERE_END</COMMENTS>       - <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS> (<COMMENTS>target</COMMENTS> <COMMENTS>word</COMMENTS>)
    #   <COMMENTS>FORMAT</COMMENTS>         - <COMMENTS>format</COMMENTS> <COMMENTS>section</COMMENTS>
    #   <COMMENTS>FORMAT_END</COMMENTS>     - <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>format</COMMENTS> <COMMENTS>section</COMMENTS>, '.'
    #   <COMMENTS>DATA_START</COMMENTS>     - <COMMENTS>__DATA__</COMMENTS> <COMMENTS>line</COMMENTS>
    #   <COMMENTS>DATA</COMMENTS>           - <COMMENTS>unidentified</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>__DATA__</COMMENTS>
    #   <COMMENTS>END_START</COMMENTS>      - <COMMENTS>__END__</COMMENTS> <COMMENTS>line</COMMENTS>
    #   <COMMENTS>END</COMMENTS>            - <COMMENTS>unidentified</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>__END__</COMMENTS>
    #   <COMMENTS>ERROR</COMMENTS>          - <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>big</COMMENTS> <COMMENTS>trouble</COMMENTS>, <COMMENTS>probably</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>script</COMMENTS>

    # <COMMENTS>put</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>an</COMMENTS> =<COMMENTS>cut</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>comes</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>__END__</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>__DATA__</COMMENTS>
    # (<COMMENTS>required</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>podchecker</COMMENTS>)
    if ( $<CODE>last_line_type</CODE> eq '<LITERALS>POD_END</LITERALS>' && !$<CODE>saw_END_or_DATA_</CODE> ) {
        $<CODE>file_writer_object</CODE>-><CODE>reset_consecutive_blank_lines</CODE>();
        if ( $<CODE>input_line</CODE> !~ /^\s*$/ ) { <CODE>want_blank_line</CODE>() }
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS>..
    if ( $<CODE>line_type</CODE> eq '<LITERALS>CODE</LITERALS>' ) {

        # <COMMENTS>let</COMMENTS> <COMMENTS>logger</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS>
        if ( $<CODE>input_line</CODE> !~ /^\s*$/ ) {
            my $<CODE>output_line_number</CODE> =
              $<CODE>vertical_aligner_object</CODE>-><CODE>get_output_line_number</CODE>();
            <CODE>black_box</CODE>( $<CODE>line_of_tokens</CODE>, $<CODE>output_line_number</CODE> );
        }
        <CODE>print_line_of_tokens</CODE>($<CODE>line_of_tokens</CODE>);
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>code</COMMENTS>..
    else {

        # <COMMENTS>set</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>flags</COMMENTS>
        my $<CODE>skip_line</CODE> = 0;
        my $<CODE>tee_line</CODE>  = 0;
        if ( $<CODE>line_type</CODE> =~ /^POD/ ) {

            # <COMMENTS>Pod</COMMENTS> <COMMENTS>docs</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>preceding</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>But</COMMENTS> <COMMENTS>stay</COMMENTS>
            # <COMMENTS>out</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>__END__</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>__DATA__</COMMENTS> <COMMENTS>sections</COMMENTS>, <COMMENTS>because</COMMENTS>
            # <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>using</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>purpose</COMMENTS> <COMMENTS>whatsoever</COMMENTS>
            if ( $<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>pod</LITERALS>'} ) { $<CODE>skip_line</CODE> = 1; }
            if ( $<CODE>rOpts</CODE>->{'<LITERALS>tee</LITERALS>-<LITERALS>pod</LITERALS>'} )    { $<CODE>tee_line</CODE>  = 1; }
            if ( $<CODE>rOpts</CODE>->{'<LITERALS>trim</LITERALS>-<LITERALS>pod</LITERALS>'} )   { $<CODE>input_line</CODE> =~ s/\s+$// }
            if (  !$<CODE>skip_line</CODE>
                && $<CODE>line_type</CODE> eq '<LITERALS>POD_START</LITERALS>'
                && !$<CODE>saw_END_or_DATA_</CODE> )
            {
                <CODE>want_blank_line</CODE>();
            }
        }

        # <COMMENTS>leave</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>counters</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>predictable</COMMENTS> <COMMENTS>state</COMMENTS>
        # <COMMENTS>after</COMMENTS> <COMMENTS>__END__</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>__DATA__</COMMENTS>
        elsif ( $<CODE>line_type</CODE> =~ /^(END_START|DATA_START)$/ ) {
            $<CODE>file_writer_object</CODE>-><CODE>reset_consecutive_blank_lines</CODE>();
            $<CODE>saw_END_or_DATA_</CODE> = 1;
        }

        # <COMMENTS>write</COMMENTS> <COMMENTS>unindented</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>code</COMMENTS> <COMMENTS>line</COMMENTS>
        if ( !$<CODE>skip_line</CODE> ) {
            if ($<CODE>tee_line</CODE>) { $<CODE>file_writer_object</CODE>-><CODE>tee_on</CODE>() }
            <CODE>write_unindented_line</CODE>($<CODE>input_line</CODE>);
            if ($<CODE>tee_line</CODE>) { $<CODE>file_writer_object</CODE>-><CODE>tee_off</CODE>() }
        }
    }
    $<CODE>last_line_type</CODE> = $<CODE>line_type</CODE>;
}

sub <CODE>create_one_line_block</CODE> {
    $<CODE>index_start_one_line_block</CODE>            = $<CODE>_</CODE>[0];
    $<CODE>semicolons_before_block_self_destruct</CODE> = $<CODE>_</CODE>[1];
}

sub <CODE>destroy_one_line_block</CODE> {
    $<CODE>index_start_one_line_block</CODE>            = <CODE>UNDEFINED_INDEX</CODE>;
    $<CODE>semicolons_before_block_self_destruct</CODE> = 0;
}

sub <CODE>leading_spaces_to_go</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>;
    # <COMMENTS>these</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>previously</COMMENTS> <COMMENTS>stored</COMMENTS> <COMMENTS>by</COMMENTS> '<COMMENTS>set_leading_whitespace</COMMENTS>'.

    my $<CODE>ii</CODE> = shift;
    if ( $<CODE>ii</CODE> < 0 ) { $<CODE>ii</CODE> = 0 }
    return <CODE>get_SPACES</CODE>( $<CODE>leading_spaces_to_go</CODE>[$<CODE>ii</CODE>] );

}

sub <CODE>get_SPACES</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>associated</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>indentation</COMMENTS>
    # <COMMENTS>variable</COMMENTS> <COMMENTS>$indentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>constant</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS>
    # <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>get_SPACES</COMMENTS> <COMMENTS>method</COMMENTS>.
    my $<CODE>indentation</CODE> = shift;
    return ref($<CODE>indentation</CODE>) ? $<CODE>indentation</CODE>-><CODE>get_SPACES</CODE>() : $<CODE>indentation</CODE>;
}

sub <CODE>get_RECOVERABLE_SPACES</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>spaces</COMMENTS> (+ <COMMENTS>means</COMMENTS> <COMMENTS>shift</COMMENTS> <COMMENTS>right</COMMENTS>, - <COMMENTS>means</COMMENTS> <COMMENTS>shift</COMMENTS> <COMMENTS>left</COMMENTS>)
    # <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>shift</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>indentation</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>parens</COMMENTS>
    my $<CODE>indentation</CODE> = shift;
    return ref($<CODE>indentation</CODE>) ? $<CODE>indentation</CODE>-><CODE>get_RECOVERABLE_SPACES</CODE>() : 0;
}

sub <CODE>get_AVAILABLE_SPACES_to_go</CODE> {

    my $<CODE>item</CODE> = $<CODE>leading_spaces_to_go</CODE>[ $<CODE>_</CODE>[0] ];

    # <COMMENTS>return</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>available</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>associated</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>an</COMMENTS>
    # <COMMENTS>indentation</COMMENTS> <COMMENTS>variable</COMMENTS>.  <COMMENTS>$indentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>constant</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS>
    # <COMMENTS>spaces</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>get_AVAILABLE_SPACES</COMMENTS> <COMMENTS>method</COMMENTS>.
    return ref($<CODE>item</CODE>) ? $<CODE>item</CODE>-><CODE>get_AVAILABLE_SPACES</CODE>() : 0;
}

sub <CODE>new_lp_indentation_item</CODE> {

    # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>interface</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>IndentationItem</COMMENTS> <COMMENTS>class</COMMENTS>
    my ( $<CODE>spaces</CODE>, $<CODE>level</CODE>, $<CODE>ci_level</CODE>, $<CODE>available_spaces</CODE>, $<CODE>align_paren</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>A</COMMENTS> <COMMENTS>negative</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>implies</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>store</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>item_list</COMMENTS>
    my $<CODE>index</CODE> = 0;
    if ( $<CODE>level</CODE> >= 0 ) { $<CODE>index</CODE> = ++$<CODE>max_gnu_item_index</CODE>; }

    my $<CODE>item</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IndentationItem</CODE>-><CODE>new</CODE>(
        $<CODE>spaces</CODE>,      $<CODE>level</CODE>,
        $<CODE>ci_level</CODE>,    $<CODE>available_spaces</CODE>,
        $<CODE>index</CODE>,       $<CODE>gnu_sequence_number</CODE>,
        $<CODE>align_paren</CODE>, $<CODE>max_gnu_stack_index</CODE>,
        $<CODE>line_start_index_to_go</CODE>,
    );

    if ( $<CODE>level</CODE> >= 0 ) {
        $<CODE>gnu_item_list</CODE>[$<CODE>max_gnu_item_index</CODE>] = $<CODE>item</CODE>;
    }

    return $<CODE>item</CODE>;
}

sub <CODE>set_leading_whitespace</CODE> {

    # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>defines</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS>
    # <COMMENTS>given</COMMENTS>: <COMMENTS>the</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>continuation_level</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>token</COMMENTS>,
    # <COMMENTS>define</COMMENTS>: <COMMENTS>space</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>apply</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS>
    # <COMMENTS>were</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>.

    my ( $<CODE>level_abs</CODE>, $<CODE>ci_level</CODE>, $<CODE>in_continued_quote</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>Adjust</COMMENTS> <COMMENTS>levels</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>recycle</COMMENTS> <COMMENTS>whitespace</COMMENTS>:
    # <COMMENTS>given</COMMENTS> <COMMENTS>$level_abs</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>absolute</COMMENTS> <COMMENTS>level</COMMENTS>
    # <COMMENTS>define</COMMENTS> <COMMENTS>$level</COMMENTS>, <COMMENTS>a</COMMENTS> <COMMENTS>possibly</COMMENTS> <COMMENTS>reduced</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>whitespace</COMMENTS>
    my $<CODE>level</CODE> = $<CODE>level_abs</CODE>;
    if ( $<CODE>rOpts_whitespace_cycle</CODE> && $<CODE>rOpts_whitespace_cycle</CODE> > 0 ) {
        if ( $<CODE>level_abs</CODE> < $<CODE>whitespace_last_level</CODE> ) {
            pop(@<CODE>whitespace_level_stack</CODE>);
        }
        if ( !@<CODE>whitespace_level_stack</CODE> ) {
            push @<CODE>whitespace_level_stack</CODE>, $<CODE>level_abs</CODE>;
        }
        elsif ( $<CODE>level_abs</CODE> > $<CODE>whitespace_last_level</CODE> ) {
            $<CODE>level</CODE> = $<CODE>whitespace_level_stack</CODE>[-1] +
              ( $<CODE>level_abs</CODE> - $<CODE>whitespace_last_level</CODE> );

            if (
                # <COMMENTS>1</COMMENTS> <COMMENTS>Try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>brace</COMMENTS>
                (
                       $<CODE>level</CODE> > $<CODE>rOpts_whitespace_cycle</CODE>
                    && $<CODE>last_nonblank_type</CODE> eq '{'
                    && $<CODE>last_nonblank_token</CODE> eq '{'
                )

                # <COMMENTS>2</COMMENTS> <COMMENTS>Then</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>bracket</COMMENTS>
                || (   $<CODE>level</CODE> > $<CODE>rOpts_whitespace_cycle</CODE> + 1
                    && $<CODE>last_nonblank_token</CODE> =~ /^[\{\[]$/ )

                # <COMMENTS>3</COMMENTS> <COMMENTS>Then</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>too</COMMENTS>
                || $<CODE>level</CODE> > $<CODE>rOpts_whitespace_cycle</CODE> + 2
              )
            {
                $<CODE>level</CODE> = 1;
            }
            push @<CODE>whitespace_level_stack</CODE>, $<CODE>level</CODE>;
        }
        $<CODE>level</CODE> = $<CODE>whitespace_level_stack</CODE>[-1];
    }
    $<CODE>whitespace_last_level</CODE> = $<CODE>level_abs</CODE>;

    # <COMMENTS>modify</COMMENTS> <COMMENTS>for</COMMENTS> -<COMMENTS>bli</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>adds</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>for</COMMENTS>
    # <COMMENTS>opening</COMMENTS> <COMMENTS>braces</COMMENTS>
    if (   $<CODE>rOpts_brace_left_and_indent</CODE>
        && $<CODE>max_index_to_go</CODE> == 0
        && $<CODE>block_type_to_go</CODE>[$<CODE>max_index_to_go</CODE>] =~ /$<CODE>bli_pattern</CODE>/o )
    {
        $<CODE>ci_level</CODE>++;
    }

    # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>trouble</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>negative</COMMENTS> <COMMENTS>indentation</COMMENTS>.
    # <COMMENTS>other</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>catch</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>error</COMMENTS>.
    if ( $<CODE>level</CODE> < 0 ) { $<CODE>level</CODE> = 0 }

    #-------------------------------------------
    # <COMMENTS>handle</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>scheme</COMMENTS>
    #-------------------------------------------
    unless ($<CODE>rOpts_line_up_parentheses</CODE>) {
        my $<CODE>space_count</CODE> =
          $<CODE>ci_level</CODE> * $<CODE>rOpts_continuation_indentation</CODE> +
          $<CODE>level</CODE> * $<CODE>rOpts_indent_columns</CODE>;
        my $<CODE>ci_spaces</CODE> =
          ( $<CODE>ci_level</CODE> == 0 ) ? 0 : $<CODE>rOpts_continuation_indentation</CODE>;

        if ($<CODE>in_continued_quote</CODE>) {
            $<CODE>space_count</CODE> = 0;
            $<CODE>ci_spaces</CODE>   = 0;
        }
        $<CODE>leading_spaces_to_go</CODE>[$<CODE>max_index_to_go</CODE>] = $<CODE>space_count</CODE>;
        $<CODE>reduced_spaces_to_go</CODE>[$<CODE>max_index_to_go</CODE>] = $<CODE>space_count</CODE> - $<CODE>ci_spaces</CODE>;
        return;
    }

    #-------------------------------------------------------------
    # <COMMENTS>handle</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>indentation</COMMENTS>..
    #-------------------------------------------------------------

    # <COMMENTS>The</COMMENTS> <COMMENTS>continued_quote</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>means</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS>
    # <COMMENTS>line</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>kind</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>multi</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>quote</COMMENTS>
    # <COMMENTS>or</COMMENTS> <COMMENTS>pattern</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>requires</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>treatment</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>no</COMMENTS>
    # <COMMENTS>added</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS>. <COMMENTS>So</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>item</COMMENTS>
    # <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>stack</COMMENTS>.
    if ($<CODE>in_continued_quote</CODE>) {
        my $<CODE>space_count</CODE>     = 0;
        my $<CODE>available_space</CODE> = 0;
        $<CODE>level</CODE> = -1;    # <COMMENTS>flag</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>storing</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>item_list</COMMENTS>
        $<CODE>leading_spaces_to_go</CODE>[$<CODE>max_index_to_go</CODE>] =
          $<CODE>reduced_spaces_to_go</CODE>[$<CODE>max_index_to_go</CODE>] =
          <CODE>new_lp_indentation_item</CODE>( $<CODE>space_count</CODE>, $<CODE>level</CODE>, $<CODE>ci_level</CODE>,
            $<CODE>available_space</CODE>, 0 );
        return;
    }

    # <COMMENTS>get</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>top</COMMENTS> <COMMENTS>state</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>stack</COMMENTS>
    my $<CODE>space_count</CODE>      = $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>get_SPACES</CODE>();
    my $<CODE>current_level</CODE>    = $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>get_LEVEL</CODE>();
    my $<CODE>current_ci_level</CODE> = $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>get_CI_LEVEL</CODE>();

    my $<CODE>type</CODE>        = $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
    my $<CODE>token</CODE>       = $<CODE>tokens_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
    my $<CODE>total_depth</CODE> = $<CODE>nesting_depth_to_go</CODE>[$<CODE>max_index_to_go</CODE>];

    if ( $<CODE>type</CODE> eq '{' || $<CODE>type</CODE> eq '(' ) {

        $<CODE>gnu_comma_count</CODE>{ $<CODE>total_depth</CODE> + 1 } = 0;
        $<CODE>gnu_arrow_count</CODE>{ $<CODE>total_depth</CODE> + 1 } = 0;

        # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>come</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>an</COMMENTS> '=' <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>type</COMMENTS>,
        # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>helpful</COMMENTS> <COMMENTS>to</COMMENTS> '<COMMENTS>break</COMMENTS>' <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> '=' <COMMENTS>to</COMMENTS> <COMMENTS>save</COMMENTS> <COMMENTS>space</COMMENTS>
        my $<CODE>last_equals</CODE> = $<CODE>last_gnu_equals</CODE>{$<CODE>total_depth</CODE>};
        if ( $<CODE>last_equals</CODE> && $<CODE>last_equals</CODE> > $<CODE>line_start_index_to_go</CODE> ) {

            # <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>position</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> '='
            my $<CODE>i_test</CODE> = $<CODE>last_equals</CODE>;
            if ( $<CODE>types_to_go</CODE>[ $<CODE>i_test</CODE> + 1 ] eq '<LITERALS>b</LITERALS>' ) { $<CODE>i_test</CODE>++ }

            # <COMMENTS>TESTING</COMMENTS>
            ##<COMMENTS>my</COMMENTS> <COMMENTS>$too_close</COMMENTS> = (<COMMENTS>$i_test</COMMENTS>==<COMMENTS>$max_index_to_go</COMMENTS>-<COMMENTS>1</COMMENTS>);

            my $<CODE>test_position</CODE> = <CODE>total_line_length</CODE>( $<CODE>i_test</CODE>, $<CODE>max_index_to_go</CODE> );
            my $<CODE>mll</CODE> = <CODE>maximum_line_length</CODE>($<CODE>i_test</CODE>);

            if (

                # <COMMENTS>the</COMMENTS> <COMMENTS>equals</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>paren</COMMENTS> (<COMMENTS>testing</COMMENTS>)
                ##!<COMMENTS>$too_close</COMMENTS> &&

                # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>beyond</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>midpoint</COMMENTS>
                $<CODE>gnu_position_predictor</CODE> > $<CODE>mll</CODE> - $<CODE>rOpts_maximum_line_length</CODE> / 2

                # <COMMENTS>or</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>beyond</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>1</COMMENTS>/<COMMENTS>4</COMMENTS> <COMMENTS>point</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>old</COMMENTS>
                # <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>equals</COMMENTS>
                || (
                    $<CODE>gnu_position_predictor</CODE> >
                    $<CODE>mll</CODE> - $<CODE>rOpts_maximum_line_length</CODE> * 3 / 4
                    && (
                        $<CODE>old_breakpoint_to_go</CODE>[$<CODE>last_equals</CODE>]
                        || (   $<CODE>last_equals</CODE> > 0
                            && $<CODE>old_breakpoint_to_go</CODE>[ $<CODE>last_equals</CODE> - 1 ] )
                        || (   $<CODE>last_equals</CODE> > 1
                            && $<CODE>types_to_go</CODE>[ $<CODE>last_equals</CODE> - 1 ] eq '<LITERALS>b</LITERALS>'
                            && $<CODE>old_breakpoint_to_go</CODE>[ $<CODE>last_equals</CODE> - 2 ] )
                    )
                )
              )
            {

                # <COMMENTS>then</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>switch</COMMENTS> -- <COMMENTS>note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>real</COMMENTS>
                # <COMMENTS>breakpoint</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>one</COMMENTS>; <COMMENTS>sub</COMMENTS>
                # <COMMENTS>scan_list</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
                $<CODE>line_start_index_to_go</CODE> = $<CODE>i_test</CODE> + 1;
                $<CODE>gnu_position_predictor</CODE> = $<CODE>test_position</CODE>;
            }
        }
    }

    my $<CODE>halfway</CODE> =
      <CODE>maximum_line_length_for_level</CODE>($<CODE>level</CODE>) - $<CODE>rOpts_maximum_line_length</CODE> / 2;

    # <COMMENTS>Check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>decreasing</COMMENTS> <COMMENTS>depth</COMMENTS> ..
    # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>decreasing</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>increasing</COMMENTS>
    # <COMMENTS>depth</COMMENTS>. <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, (<COMMENTS>level</COMMENTS>, <COMMENTS>ci</COMMENTS>) <COMMENTS>can</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>from</COMMENTS> (<COMMENTS>1</COMMENTS>,<COMMENTS>1</COMMENTS>) <COMMENTS>to</COMMENTS> (<COMMENTS>2</COMMENTS>,<COMMENTS>0</COMMENTS>).  <COMMENTS>So</COMMENTS>,
    # <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>to</COMMENTS> (<COMMENTS>1</COMMENTS>,<COMMENTS>0</COMMENTS>) <COMMENTS>then</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>to</COMMENTS> (<COMMENTS>2</COMMENTS>,<COMMENTS>0</COMMENTS>)
    # <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>call</COMMENTS>.
    if ( $<CODE>level</CODE> < $<CODE>current_level</CODE> || $<CODE>ci_level</CODE> < $<CODE>current_ci_level</CODE> ) {

        # <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>entry</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>completely</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>level</COMMENTS>
        my ( $<CODE>lev</CODE>, $<CODE>ci_lev</CODE> );
        while (1) {
            if ($<CODE>max_gnu_stack_index</CODE>) {

                # <COMMENTS>save</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>closes</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>level</COMMENTS>
                $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>set_CLOSED</CODE>($<CODE>max_index_to_go</CODE>);

                # <COMMENTS>Undo</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>saw</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>commas</COMMENTS>
                my $<CODE>available_spaces</CODE> =
                  $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>get_AVAILABLE_SPACES</CODE>();

                my $<CODE>comma_count</CODE> = 0;
                my $<CODE>arrow_count</CODE> = 0;
                if ( $<CODE>type</CODE> eq '}' || $<CODE>type</CODE> eq ')' ) {
                    $<CODE>comma_count</CODE> = $<CODE>gnu_comma_count</CODE>{$<CODE>total_depth</CODE>};
                    $<CODE>arrow_count</CODE> = $<CODE>gnu_arrow_count</CODE>{$<CODE>total_depth</CODE>};
                    $<CODE>comma_count</CODE> = 0 unless $<CODE>comma_count</CODE>;
                    $<CODE>arrow_count</CODE> = 0 unless $<CODE>arrow_count</CODE>;
                }
                $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>set_COMMA_COUNT</CODE>($<CODE>comma_count</CODE>);
                $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>set_ARROW_COUNT</CODE>($<CODE>arrow_count</CODE>);

                if ( $<CODE>available_spaces</CODE> > 0 ) {

                    if ( $<CODE>comma_count</CODE> <= 0 || $<CODE>arrow_count</CODE> > 0 ) {

                        my $<CODE>i</CODE> = $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>get_INDEX</CODE>();
                        my $<CODE>seqno</CODE> =
                          $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]
                          -><CODE>get_SEQUENCE_NUMBER</CODE>();

                        # <COMMENTS>Be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>created</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>.  <COMMENTS>This</COMMENTS>
                        # <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>true</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>delete</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>available</COMMENTS>
                        # <COMMENTS>space</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>batch</COMMENTS>.
                        if (   $<CODE>gnu_sequence_number</CODE> != $<CODE>seqno</CODE>
                            || $<CODE>i</CODE> > $<CODE>max_gnu_item_index</CODE> )
                        {
                            <CODE>warning</CODE>(
"<LITERALS>Program</LITERALS> <LITERALS>bug</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>lp</LITERALS>.  <LITERALS>seqno</LITERALS>=$<CODE>seqno</CODE> <LITERALS>should</LITERALS> <LITERALS>be</LITERALS> $<CODE>gnu_sequence_number</CODE> <LITERALS>and</LITERALS> <LITERALS>i</LITERALS>=$<CODE>i</CODE> <LITERALS>should</LITERALS> <LITERALS>be</LITERALS> <LITERALS>less</LITERALS> <LITERALS>than</LITERALS> <LITERALS>max</LITERALS>=$<CODE>max_gnu_item_index</CODE>\n"
                            );
                            <CODE>report_definite_bug</CODE>();
                        }

                        else {
                            if ( $<CODE>arrow_count</CODE> == 0 ) {
                                $<CODE>gnu_item_list</CODE>[$<CODE>i</CODE>]
                                  -><CODE>permanently_decrease_AVAILABLE_SPACES</CODE>(
                                    $<CODE>available_spaces</CODE>);
                            }
                            else {
                                $<CODE>gnu_item_list</CODE>[$<CODE>i</CODE>]
                                  -><CODE>tentatively_decrease_AVAILABLE_SPACES</CODE>(
                                    $<CODE>available_spaces</CODE>);
                            }

                            my $<CODE>j</CODE>;
                            for (
                                $<CODE>j</CODE> = $<CODE>i</CODE> + 1 ;
                                $<CODE>j</CODE> <= $<CODE>max_gnu_item_index</CODE> ;
                                $<CODE>j</CODE>++
                              )
                            {
                                $<CODE>gnu_item_list</CODE>[$<CODE>j</CODE>]
                                  -><CODE>decrease_SPACES</CODE>($<CODE>available_spaces</CODE>);
                            }
                        }
                    }
                }

                # <COMMENTS>go</COMMENTS> <COMMENTS>down</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>level</COMMENTS>
                --$<CODE>max_gnu_stack_index</CODE>;
                $<CODE>lev</CODE>    = $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>get_LEVEL</CODE>();
                $<CODE>ci_lev</CODE> = $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>get_CI_LEVEL</CODE>();

                # <COMMENTS>stop</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>reach</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>level</COMMENTS>
                if ( $<CODE>lev</CODE> <= $<CODE>level</CODE> && $<CODE>ci_lev</CODE> <= $<CODE>ci_level</CODE> ) {
                    $<CODE>space_count</CODE> =
                      $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>get_SPACES</CODE>();
                    $<CODE>current_level</CODE>    = $<CODE>lev</CODE>;
                    $<CODE>current_ci_level</CODE> = $<CODE>ci_lev</CODE>;
                    last;
                }
            }

            # <COMMENTS>reached</COMMENTS> <COMMENTS>bottom</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>stack</COMMENTS> .. <COMMENTS>should</COMMENTS> <COMMENTS>never</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>because</COMMENTS>
            # <COMMENTS>only</COMMENTS> <COMMENTS>negative</COMMENTS> <COMMENTS>levels</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>here</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>$level</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>forced</COMMENTS>
            # <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>positive</COMMENTS> <COMMENTS>above</COMMENTS>.
            else {
                <CODE>warning</CODE>(
"<LITERALS>program</LITERALS> <LITERALS>bug</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>lp</LITERALS>: <LITERALS>stack_error</LITERALS>. <LITERALS>level</LITERALS>=$<CODE>level</CODE>; <LITERALS>lev</LITERALS>=$<CODE>lev</CODE>; <LITERALS>ci_level</LITERALS>=$<CODE>ci_level</CODE>; <LITERALS>ci_lev</LITERALS>=$<CODE>ci_lev</CODE>; <LITERALS>rerun</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>nlp</LITERALS>\n"
                );
                <CODE>report_definite_bug</CODE>();
                last;
            }
        }
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>increasing</COMMENTS> <COMMENTS>depth</COMMENTS>
    if ( $<CODE>level</CODE> > $<CODE>current_level</CODE> || $<CODE>ci_level</CODE> > $<CODE>current_ci_level</CODE> ) {

        # <COMMENTS>Compute</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>incremental</COMMENTS> <COMMENTS>whitespace</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>minimum</COMMENTS> <COMMENTS>incremental</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS>.  <COMMENTS>This</COMMENTS>
        # <COMMENTS>choice</COMMENTS> <COMMENTS>results</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>smooth</COMMENTS> <COMMENTS>transition</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>gnu</COMMENTS>-<COMMENTS>style</COMMENTS>
        # <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>style</COMMENTS>.
        my $<CODE>standard_increment</CODE> =
          ( $<CODE>level</CODE> - $<CODE>current_level</CODE> ) * $<CODE>rOpts_indent_columns</CODE> +
          ( $<CODE>ci_level</CODE> - $<CODE>current_ci_level</CODE> ) * $<CODE>rOpts_continuation_indentation</CODE>;

        # <COMMENTS>Now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>define</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>much</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>incremental</COMMENTS> <COMMENTS>space</COMMENTS>
        # ("<COMMENTS>$available_space</COMMENTS>") <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS>
        # <COMMENTS>reduced</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>encountered</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>when</COMMENTS>
        # <COMMENTS>it</COMMENTS> <COMMENTS>becomes</COMMENTS> <COMMENTS>clear</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>list</COMMENTS>.
        my $<CODE>available_space</CODE> = 0;
        my $<CODE>align_paren</CODE>     = 0;
        my $<CODE>excess</CODE>          = 0;

        # <COMMENTS>initialization</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>stack</COMMENTS>..
        if ( $<CODE>max_gnu_stack_index</CODE> == 0 ) {
            $<CODE>space_count</CODE> = $<CODE>level</CODE> * $<CODE>rOpts_indent_columns</CODE>;
        }

        # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>BLOCK</COMMENTS>, <COMMENTS>add</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>increment</COMMENTS>
        elsif ($<CODE>last_nonblank_block_type</CODE>) {
            $<CODE>space_count</CODE> += $<CODE>standard_increment</CODE>;
        }

        # <COMMENTS>if</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>indentation</COMMENTS>,
        # <COMMENTS>just</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>increment</COMMENTS>
        elsif ( $<CODE>last_nonblank_type</CODE> ne '{' ) {
            $<CODE>space_count</CODE> += $<CODE>standard_increment</CODE>;
        }

        # <COMMENTS>otherwise</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>token</COMMENTS>
        else {

            $<CODE>space_count</CODE> = $<CODE>gnu_position_predictor</CODE>;

            my $<CODE>min_gnu_indentation</CODE> =
              $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>get_SPACES</CODE>();

            $<CODE>available_space</CODE> = $<CODE>space_count</CODE> - $<CODE>min_gnu_indentation</CODE>;
            if ( $<CODE>available_space</CODE> >= $<CODE>standard_increment</CODE> ) {
                $<CODE>min_gnu_indentation</CODE> += $<CODE>standard_increment</CODE>;
            }
            elsif ( $<CODE>available_space</CODE> > 1 ) {
                $<CODE>min_gnu_indentation</CODE> += $<CODE>available_space</CODE> + 1;
            }
            elsif ( $<CODE>last_nonblank_token</CODE> =~ /^[\{\[\(]$/ ) {
                if ( ( $<CODE>tightness</CODE>{$<CODE>last_nonblank_token</CODE>} < 2 ) ) {
                    $<CODE>min_gnu_indentation</CODE> += 2;
                }
                else {
                    $<CODE>min_gnu_indentation</CODE> += 1;
                }
            }
            else {
                $<CODE>min_gnu_indentation</CODE> += $<CODE>standard_increment</CODE>;
            }
            $<CODE>available_space</CODE> = $<CODE>space_count</CODE> - $<CODE>min_gnu_indentation</CODE>;

            if ( $<CODE>available_space</CODE> < 0 ) {
                $<CODE>space_count</CODE>     = $<CODE>min_gnu_indentation</CODE>;
                $<CODE>available_space</CODE> = 0;
            }
            $<CODE>align_paren</CODE> = 1;
        }

        # <COMMENTS>update</COMMENTS> <COMMENTS>state</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>token</COMMENTS>
        if ( $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>] ne '<LITERALS>b</LITERALS>' ) {

            $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]-><CODE>set_HAVE_CHILD</CODE>(1);

            ++$<CODE>max_gnu_stack_index</CODE>;
            $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>] =
              <CODE>new_lp_indentation_item</CODE>( $<CODE>space_count</CODE>, $<CODE>level</CODE>, $<CODE>ci_level</CODE>,
                $<CODE>available_space</CODE>, $<CODE>align_paren</CODE> );

            # <COMMENTS>If</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>beyond</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>half</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>, <COMMENTS>then</COMMENTS>
            # <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>minimum</COMMENTS> (<COMMENTS>standard</COMMENTS>) <COMMENTS>indentation</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS>
            # <COMMENTS>help</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>associated</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>running</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>space</COMMENTS>
            # <COMMENTS>near</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>As</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>result</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>deeply</COMMENTS> <COMMENTS>nested</COMMENTS>
            # <COMMENTS>lists</COMMENTS>, <COMMENTS>there</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>indentations</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>limited</COMMENTS>
            # <COMMENTS>to</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>minimum</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>indentation</COMMENTS>. <COMMENTS>But</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>deeply</COMMENTS>
            # <COMMENTS>nested</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>able</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>shift</COMMENTS> <COMMENTS>its</COMMENTS>
            # <COMMENTS>parameters</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>proper</COMMENTS> <COMMENTS>alignment</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>most</COMMENTS>
            # <COMMENTS>cases</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>noticeable</COMMENTS>.
            if ( $<CODE>available_space</CODE> > 0 && $<CODE>space_count</CODE> > $<CODE>halfway</CODE> ) {
                $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>]
                  -><CODE>tentatively_decrease_AVAILABLE_SPACES</CODE>($<CODE>available_space</CODE>);
            }
        }
    }

    # <COMMENTS>Count</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>list</COMMENTS> <COMMENTS>characters</COMMENTS>.  <COMMENTS>Once</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>a</COMMENTS>
    # <COMMENTS>non</COMMENTS>-<COMMENTS>list</COMMENTS> <COMMENTS>character</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>commas</COMMENTS>.
    if ( $<CODE>type</CODE> eq '=>' ) {
        $<CODE>gnu_arrow_count</CODE>{$<CODE>total_depth</CODE>}++;

        # <COMMENTS>tentatively</COMMENTS> <COMMENTS>treating</COMMENTS> '=>' <COMMENTS>like</COMMENTS> '=' <COMMENTS>for</COMMENTS> <COMMENTS>estimating</COMMENTS> <COMMENTS>breaks</COMMENTS>
        # <COMMENTS>TODO</COMMENTS>: <COMMENTS>this</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>experimentation</COMMENTS>
        $<CODE>last_gnu_equals</CODE>{$<CODE>total_depth</CODE>} = $<CODE>max_index_to_go</CODE>;
    }

    elsif ( $<CODE>type</CODE> eq ',' ) {
        $<CODE>gnu_comma_count</CODE>{$<CODE>total_depth</CODE>}++;
    }

    elsif ( $<CODE>is_assignment</CODE>{$<CODE>type</CODE>} ) {
        $<CODE>last_gnu_equals</CODE>{$<CODE>total_depth</CODE>} = $<CODE>max_index_to_go</CODE>;
    }

    # <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>
    # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS>..
    if ( $<CODE>type</CODE> ne '<LITERALS>b</LITERALS>' ) {

        # <COMMENTS>and</COMMENTS> <COMMENTS>if</COMMENTS> ..
        if (

            # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>
            $<CODE>max_index_to_go</CODE> == 1 && $<CODE>types_to_go</CODE>[0] eq '<LITERALS>b</LITERALS>'

            # <COMMENTS>or</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS>:
            || $<CODE>last_nonblank_type_to_go</CODE> =~ /^([\:\?\,f])$/

            # <COMMENTS>or</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>close</COMMENTS> <COMMENTS>it</COMMENTS>
            || ( $<CODE>last_nonblank_type_to_go</CODE> eq '{' && $<CODE>type</CODE> ne '}' )
            || ( $<CODE>last_nonblank_type_to_go</CODE> eq '(' and $<CODE>type</CODE> ne ')' )

            # <COMMENTS>or</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS>:
            || $<CODE>type</CODE> =~ /^([\.]|\|\||\&\&)$/

            # <COMMENTS>or</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>structure</COMMENTS>
            || (   $<CODE>last_nonblank_type_to_go</CODE> eq '}'
                && $<CODE>last_nonblank_token_to_go</CODE> eq $<CODE>last_nonblank_type_to_go</CODE> )

            # <COMMENTS>or</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>keyword</COMMENTS> '<COMMENTS>return</COMMENTS>'
            || ( $<CODE>last_nonblank_type_to_go</CODE> eq '<LITERALS>k</LITERALS>'
                && ( $<CODE>last_nonblank_token_to_go</CODE> eq '<LITERALS>return</LITERALS>' && $<CODE>type</CODE> ne '{' ) )

            # <COMMENTS>or</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>fine</COMMENTS>
            || (   $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>'
                && $<CODE>is_if_unless_and_or_last_next_redo_return</CODE>{$<CODE>token</CODE>} )

            # <COMMENTS>or</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>assignment</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>structure</COMMENTS>
            || (
                $<CODE>is_assignment</CODE>{$<CODE>last_nonblank_type_to_go</CODE>}
                && (
                    $<CODE>last_last_nonblank_type_to_go</CODE> =~ /^[\}\)\]]$/

                    # <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>significantly</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS>
                    || $<CODE>gnu_position_predictor</CODE> > $<CODE>halfway</CODE>
                )
            )
          )
        {
            <CODE>check_for_long_gnu_style_lines</CODE>();
            $<CODE>line_start_index_to_go</CODE> = $<CODE>max_index_to_go</CODE>;

            # <COMMENTS>back</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>type</COMMENTS>
            # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>strand</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>like</COMMENTS> '?' <COMMENTS>or</COMMENTS> ':' <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>
            if ( $<CODE>line_start_index_to_go</CODE> > 0 ) {
                if ( $<CODE>last_nonblank_type_to_go</CODE> eq '<LITERALS>k</LITERALS>' ) {

                    if ( $<CODE>want_break_before</CODE>{$<CODE>last_nonblank_token_to_go</CODE>} ) {
                        $<CODE>line_start_index_to_go</CODE>--;
                    }
                }
                elsif ( $<CODE>want_break_before</CODE>{$<CODE>last_nonblank_type_to_go</CODE>} ) {
                    $<CODE>line_start_index_to_go</CODE>--;
                }
            }
        }
    }

    # <COMMENTS>remember</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>predicted</COMMENTS> <COMMENTS>position</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>line</COMMENTS>
    if ( $<CODE>max_index_to_go</CODE> > $<CODE>line_start_index_to_go</CODE> ) {
        $<CODE>gnu_position_predictor</CODE> =
          <CODE>total_line_length</CODE>( $<CODE>line_start_index_to_go</CODE>, $<CODE>max_index_to_go</CODE> );
    }
    else {
        $<CODE>gnu_position_predictor</CODE> =
          $<CODE>space_count</CODE> + $<CODE>token_lengths_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
    }

    # <COMMENTS>store</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS>
    # <COMMENTS>this</COMMENTS> <COMMENTS>allows</COMMENTS> <COMMENTS>us</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>manipulate</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS>
    # (<COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>reduce</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>fit</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>) <COMMENTS>without</COMMENTS>
    # <COMMENTS>having</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>values</COMMENTS>
    $<CODE>leading_spaces_to_go</CODE>[$<CODE>max_index_to_go</CODE>] = $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>];
    $<CODE>reduced_spaces_to_go</CODE>[$<CODE>max_index_to_go</CODE>] =
      ( $<CODE>max_gnu_stack_index</CODE> > 0 && $<CODE>ci_level</CODE> )
      ? $<CODE>gnu_stack</CODE>[ $<CODE>max_gnu_stack_index</CODE> - 1 ]
      : $<CODE>gnu_stack</CODE>[$<CODE>max_gnu_stack_index</CODE>];
    return;
}

sub <CODE>check_for_long_gnu_style_lines</CODE> {

    # <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>estimated</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>, <COMMENTS>and</COMMENTS>
    # <COMMENTS>remove</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>exceeds</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>desired</COMMENTS> <COMMENTS>maximum</COMMENTS>

    # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> '-<COMMENTS>lp</COMMENTS>' <COMMENTS>style</COMMENTS>
    return unless ($<CODE>rOpts_line_up_parentheses</CODE>);

    # <COMMENTS>nothing</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>stack</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
    return if ( $<CODE>max_gnu_item_index</CODE> == <CODE>UNDEFINED_INDEX</CODE> );

    # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>exceeded</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>desired</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>
    # <COMMENTS>keep</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>free</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>cases</COMMENTS>
    # (<COMMENTS>result</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>trial</COMMENTS>-<COMMENTS>and</COMMENTS>-<COMMENTS>error</COMMENTS> <COMMENTS>testing</COMMENTS>)
    my $<CODE>spaces_needed</CODE> =
      $<CODE>gnu_position_predictor</CODE> - <CODE>maximum_line_length</CODE>($<CODE>max_index_to_go</CODE>) + 2;

    return if ( $<CODE>spaces_needed</CODE> <= 0 );

    # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>limit</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>requested</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS>
    # <COMMENTS>spaces</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>allowed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>remove</COMMENTS>
    # <COMMENTS>from</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>created</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>, <COMMENTS>since</COMMENTS> <COMMENTS>others</COMMENTS> <COMMENTS>have</COMMENTS>
    # <COMMENTS>already</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>cannot</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>undone</COMMENTS>.
    my @<CODE>candidates</CODE> = ();
    my $<CODE>i</CODE>;

    # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>created</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>batch</COMMENTS>
    for ( $<CODE>i</CODE> = 0 ; $<CODE>i</CODE> <= $<CODE>max_gnu_item_index</CODE> ; $<CODE>i</CODE>++ ) {
        my $<CODE>item</CODE> = $<CODE>gnu_item_list</CODE>[$<CODE>i</CODE>];

        # <COMMENTS>item</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>candidate</COMMENTS> (<COMMENTS>otherwise</COMMENTS> <COMMENTS>it</COMMENTS>
        # <COMMENTS>cannot</COMMENTS> <COMMENTS>influence</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>token</COMMENTS>)
        next if ( $<CODE>item</CODE>-><CODE>get_CLOSED</CODE>() >= 0 );

        my $<CODE>available_spaces</CODE> = $<CODE>item</CODE>-><CODE>get_AVAILABLE_SPACES</CODE>();

        if ( $<CODE>available_spaces</CODE> > 0 ) {
            push( @<CODE>candidates</CODE>, [ $<CODE>i</CODE>, $<CODE>available_spaces</CODE> ] );
        }
    }

    return unless (@<CODE>candidates</CODE>);

    # <COMMENTS>sort</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>available</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>whitespace</COMMENTS>
    # <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>available</COMMENTS> <COMMENTS>first</COMMENTS>
    @<CODE>candidates</CODE> = sort { $<CODE>b</CODE>->[1] <=> $<CODE>a</CODE>->[1] } @<CODE>candidates</CODE>;

    # <COMMENTS>keep</COMMENTS> <COMMENTS>removing</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>until</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>more</COMMENTS>
    my $<CODE>candidate</CODE>;
    foreach $<CODE>candidate</CODE> (@<CODE>candidates</CODE>) {
        my ( $<CODE>i</CODE>, $<CODE>available_spaces</CODE> ) = @{$<CODE>candidate</CODE>};
        my $<CODE>deleted_spaces</CODE> =
          ( $<CODE>available_spaces</CODE> > $<CODE>spaces_needed</CODE> )
          ? $<CODE>spaces_needed</CODE>
          : $<CODE>available_spaces</CODE>;

        # <COMMENTS>remove</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>incremental</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>item</COMMENTS>
        $<CODE>gnu_item_list</CODE>[$<CODE>i</CODE>]-><CODE>decrease_AVAILABLE_SPACES</CODE>($<CODE>deleted_spaces</CODE>);

        my $<CODE>i_debug</CODE> = $<CODE>i</CODE>;

        # <COMMENTS>update</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>items</COMMENTS>
        # <COMMENTS>that</COMMENTS> <COMMENTS>came</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>it</COMMENTS>
        for ( ; $<CODE>i</CODE> <= $<CODE>max_gnu_item_index</CODE> ; $<CODE>i</CODE>++ ) {

            my $<CODE>old_spaces</CODE> = $<CODE>gnu_item_list</CODE>[$<CODE>i</CODE>]-><CODE>get_SPACES</CODE>();
            if ( $<CODE>old_spaces</CODE> >= $<CODE>deleted_spaces</CODE> ) {
                $<CODE>gnu_item_list</CODE>[$<CODE>i</CODE>]-><CODE>decrease_SPACES</CODE>($<CODE>deleted_spaces</CODE>);
            }

            # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>bug</COMMENTS>:
            else {
                my $<CODE>level</CODE>        = $<CODE>gnu_item_list</CODE>[$<CODE>i_debug</CODE>]-><CODE>get_LEVEL</CODE>();
                my $<CODE>ci_level</CODE>     = $<CODE>gnu_item_list</CODE>[$<CODE>i_debug</CODE>]-><CODE>get_CI_LEVEL</CODE>();
                my $<CODE>old_level</CODE>    = $<CODE>gnu_item_list</CODE>[$<CODE>i</CODE>]-><CODE>get_LEVEL</CODE>();
                my $<CODE>old_ci_level</CODE> = $<CODE>gnu_item_list</CODE>[$<CODE>i</CODE>]-><CODE>get_CI_LEVEL</CODE>();
                <CODE>warning</CODE>(
"<LITERALS>program</LITERALS> <LITERALS>bug</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>lp</LITERALS>: <LITERALS>want</LITERALS> <LITERALS>to</LITERALS> <LITERALS>delete</LITERALS> $<CODE>deleted_spaces</CODE> <LITERALS>from</LITERALS> <LITERALS>item</LITERALS> $<CODE>i</CODE>, <LITERALS>but</LITERALS> <LITERALS>old</LITERALS>=$<CODE>old_spaces</CODE> <LITERALS>deleted</LITERALS>: <LITERALS>lev</LITERALS>=$<CODE>level</CODE> <LITERALS>ci</LITERALS>=$<CODE>ci_level</CODE>  <LITERALS>deleted</LITERALS>: <LITERALS>level</LITERALS>=$<CODE>old_level</CODE> <LITERALS>ci</LITERALS>=$<CODE>ci_level</CODE>\n"
                );
                <CODE>report_definite_bug</CODE>();
            }
        }
        $<CODE>gnu_position_predictor</CODE> -= $<CODE>deleted_spaces</CODE>;
        $<CODE>spaces_needed</CODE>          -= $<CODE>deleted_spaces</CODE>;
        last unless ( $<CODE>spaces_needed</CODE> > 0 );
    }
}

sub <CODE>finish_lp_batch</CODE> {

    # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>once</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS> <COMMENTS>batch</COMMENTS> <COMMENTS>is</COMMENTS>
    # <COMMENTS>finished</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>undo</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>incomplete</COMMENTS> -<COMMENTS>lp</COMMENTS>
    # <COMMENTS>indentation</COMMENTS> <COMMENTS>levels</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>risky</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>leave</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>open</COMMENTS>,
    # <COMMENTS>because</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>backtrack</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>follow</COMMENTS>.
    # <COMMENTS>This</COMMENTS> <COMMENTS>means</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>disrupt</COMMENTS> <COMMENTS>this</COMMENTS>
    # <COMMENTS>indentation</COMMENTS> <COMMENTS>style</COMMENTS>.  <COMMENTS>But</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>able</COMMENTS> <COMMENTS>to</COMMENTS>
    # <COMMENTS>get</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>.

    # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>lp</COMMENTS>' <COMMENTS>style</COMMENTS>
    return unless ($<CODE>rOpts_line_up_parentheses</CODE>);

    # <COMMENTS>nothing</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>stack</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
    return if ( $<CODE>max_gnu_item_index</CODE> == <CODE>UNDEFINED_INDEX</CODE> );

    # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>created</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>batch</COMMENTS>
    my $<CODE>i</CODE>;
    for ( $<CODE>i</CODE> = 0 ; $<CODE>i</CODE> <= $<CODE>max_gnu_item_index</CODE> ; $<CODE>i</CODE>++ ) {
        my $<CODE>item</CODE> = $<CODE>gnu_item_list</CODE>[$<CODE>i</CODE>];

        # <COMMENTS>only</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>items</COMMENTS>
        next if ( $<CODE>item</CODE>-><CODE>get_CLOSED</CODE>() >= 0 );

        # <COMMENTS>Tentatively</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>available</COMMENTS> <COMMENTS>space</COMMENTS>
        # (<COMMENTS>The</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>later</COMMENTS>)
        my $<CODE>available_spaces</CODE> = $<CODE>item</CODE>-><CODE>get_AVAILABLE_SPACES</CODE>();
        if ( $<CODE>available_spaces</CODE> > 0 ) {

            # <COMMENTS>delete</COMMENTS> <COMMENTS>incremental</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>item</COMMENTS>
            $<CODE>gnu_item_list</CODE>[$<CODE>i</CODE>]
              -><CODE>tentatively_decrease_AVAILABLE_SPACES</CODE>($<CODE>available_spaces</CODE>);

            # <COMMENTS>Reduce</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>nodes</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>follow</COMMENTS>
            # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>nodes</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>necessarily</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>dependents</COMMENTS>
            # <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>node</COMMENTS>.
            foreach ( $<CODE>i</CODE> + 1 .. $<CODE>max_gnu_item_index</CODE> ) {
                $<CODE>gnu_item_list</CODE>[$<CODE>_</CODE>]-><CODE>decrease_SPACES</CODE>($<CODE>available_spaces</CODE>);
            }
        }
    }
    return;
}

sub <CODE>reduce_lp_indentation</CODE> {

    # <COMMENTS>reduce</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>$spaces_needed</COMMENTS>
    # (<COMMENTS>a</COMMENTS> <COMMENTS>large</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>$spaces_needed</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>excess</COMMENTS> <COMMENTS>space</COMMENTS>)
    # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>scan_list</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS>
    # <COMMENTS>contained</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>parens</COMMENTS>/<COMMENTS>braces</COMMENTS>/<COMMENTS>brackets</COMMENTS>

    my ( $<CODE>i</CODE>, $<CODE>spaces_wanted</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>deleted_spaces</CODE> = 0;

    my $<CODE>item</CODE>             = $<CODE>leading_spaces_to_go</CODE>[$<CODE>i</CODE>];
    my $<CODE>available_spaces</CODE> = $<CODE>item</CODE>-><CODE>get_AVAILABLE_SPACES</CODE>();

    if (
        $<CODE>available_spaces</CODE> > 0
        && ( ( $<CODE>spaces_wanted</CODE> <= $<CODE>available_spaces</CODE> )
            || !$<CODE>item</CODE>-><CODE>get_HAVE_CHILD</CODE>() )
      )
    {

        # <COMMENTS>we</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>spaces</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>mark</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>recoverable</COMMENTS>
        $<CODE>deleted_spaces</CODE> =
          $<CODE>item</CODE>-><CODE>tentatively_decrease_AVAILABLE_SPACES</CODE>($<CODE>spaces_wanted</CODE>);
    }

    return $<CODE>deleted_spaces</CODE>;
}

sub <CODE>token_sequence_length</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> (<COMMENTS>$ibeg</COMMENTS> .. <COMMENTS>$iend</COMMENTS>) <COMMENTS>including</COMMENTS> <COMMENTS>$ibeg</COMMENTS> & <COMMENTS>$iend</COMMENTS>
    # <COMMENTS>returns</COMMENTS> <COMMENTS>0</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>$ibeg</COMMENTS> > <COMMENTS>$iend</COMMENTS> (<COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>)
    my ( $<CODE>ibeg</CODE>, $<CODE>iend</CODE> ) = @<CODE>_</CODE>;
    return 0 if ( $<CODE>iend</CODE> < 0 || $<CODE>ibeg</CODE> > $<CODE>iend</CODE> );
    return $<CODE>summed_lengths_to_go</CODE>[ $<CODE>iend</CODE> + 1 ] if ( $<CODE>ibeg</CODE> < 0 );
    return $<CODE>summed_lengths_to_go</CODE>[ $<CODE>iend</CODE> + 1 ] - $<CODE>summed_lengths_to_go</CODE>[$<CODE>ibeg</CODE>];
}

sub <CODE>total_line_length</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> (<COMMENTS>$ibeg</COMMENTS> .. <COMMENTS>$iend</COMMENTS>)
    my ( $<CODE>ibeg</CODE>, $<CODE>iend</CODE> ) = @<CODE>_</CODE>;
    return <CODE>leading_spaces_to_go</CODE>($<CODE>ibeg</CODE>) + <CODE>token_sequence_length</CODE>( $<CODE>ibeg</CODE>, $<CODE>iend</CODE> );
}

sub <CODE>maximum_line_length_for_level</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>level</COMMENTS>
    my $<CODE>maximum_line_length</CODE> = $<CODE>rOpts_maximum_line_length</CODE>;

    # <COMMENTS>Modify</COMMENTS> <COMMENTS>if</COMMENTS> -<COMMENTS>vmll</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>selected</COMMENTS>
    if ($<CODE>rOpts_variable_maximum_line_length</CODE>) {
        my $<CODE>level</CODE> = shift;
        if ( $<CODE>level</CODE> < 0 ) { $<CODE>level</CODE> = 0 }
        $<CODE>maximum_line_length</CODE> += $<CODE>level</CODE> * $<CODE>rOpts_indent_columns</CODE>;
    }
    return $<CODE>maximum_line_length</CODE>;
}

sub <CODE>maximum_line_length</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>index</COMMENTS>
    return <CODE>maximum_line_length_for_level</CODE>( $<CODE>levels_to_go</CODE>[ $<CODE>_</CODE>[0] ] );

}

sub <CODE>excess_line_length</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> (<COMMENTS>$ibeg</COMMENTS>..<COMMENTS>$iend</COMMENTS>)
    # <COMMENTS>exceeds</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>allowable</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>.
    my ( $<CODE>ibeg</CODE>, $<CODE>iend</CODE> ) = @<CODE>_</CODE>;
    return <CODE>total_line_length</CODE>( $<CODE>ibeg</CODE>, $<CODE>iend</CODE> ) - <CODE>maximum_line_length</CODE>($<CODE>ibeg</CODE>);
}

sub <CODE>finish_formatting</CODE> {

    # <COMMENTS>flush</COMMENTS> <COMMENTS>buffer</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>informative</COMMENTS> <COMMENTS>messages</COMMENTS>
    my $<CODE>self</CODE> = shift;

    <CODE>flush</CODE>();
    $<CODE>file_writer_object</CODE>-><CODE>decrement_output_line_number</CODE>()
      ;    # <COMMENTS>fix</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>since</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>incremented</COMMENTS>
    <CODE>we_are_at_the_last_line</CODE>();
    if ( $<CODE>added_semicolon_count</CODE> > 0 ) {
        my $<CODE>first</CODE> = ( $<CODE>added_semicolon_count</CODE> > 1 ) ? "<LITERALS>First</LITERALS>" : "";
        my $<CODE>what</CODE> =
          ( $<CODE>added_semicolon_count</CODE> > 1 ) ? "<LITERALS>semicolons</LITERALS> <LITERALS>were</LITERALS>" : "<LITERALS>semicolon</LITERALS> <LITERALS>was</LITERALS>";
        <CODE>write_logfile_entry</CODE>("$<CODE>added_semicolon_count</CODE> $<CODE>what</CODE> <LITERALS>added</LITERALS>:\n");
        <CODE>write_logfile_entry</CODE>(
            "  $<CODE>first</CODE> <LITERALS>at</LITERALS> <LITERALS>input</LITERALS> <LITERALS>line</LITERALS> $<CODE>first_added_semicolon_at</CODE>\n");

        if ( $<CODE>added_semicolon_count</CODE> > 1 ) {
            <CODE>write_logfile_entry</CODE>(
                "   <LITERALS>Last</LITERALS> <LITERALS>at</LITERALS> <LITERALS>input</LITERALS> <LITERALS>line</LITERALS> $<CODE>last_added_semicolon_at</CODE>\n");
        }
        <CODE>write_logfile_entry</CODE>("  (<LITERALS>Use</LITERALS> -<LITERALS>nasc</LITERALS> <LITERALS>to</LITERALS> <LITERALS>prevent</LITERALS> <LITERALS>semicolon</LITERALS> <LITERALS>addition</LITERALS>)\n");
        <CODE>write_logfile_entry</CODE>("\n");
    }

    if ( $<CODE>deleted_semicolon_count</CODE> > 0 ) {
        my $<CODE>first</CODE> = ( $<CODE>deleted_semicolon_count</CODE> > 1 ) ? "<LITERALS>First</LITERALS>" : "";
        my $<CODE>what</CODE> =
          ( $<CODE>deleted_semicolon_count</CODE> > 1 )
          ? "<LITERALS>semicolons</LITERALS> <LITERALS>were</LITERALS>"
          : "<LITERALS>semicolon</LITERALS> <LITERALS>was</LITERALS>";
        <CODE>write_logfile_entry</CODE>(
            "$<CODE>deleted_semicolon_count</CODE> <LITERALS>unnecessary</LITERALS> $<CODE>what</CODE> <LITERALS>deleted</LITERALS>:\n");
        <CODE>write_logfile_entry</CODE>(
            "  $<CODE>first</CODE> <LITERALS>at</LITERALS> <LITERALS>input</LITERALS> <LITERALS>line</LITERALS> $<CODE>first_deleted_semicolon_at</CODE>\n");

        if ( $<CODE>deleted_semicolon_count</CODE> > 1 ) {
            <CODE>write_logfile_entry</CODE>(
                "   <LITERALS>Last</LITERALS> <LITERALS>at</LITERALS> <LITERALS>input</LITERALS> <LITERALS>line</LITERALS> $<CODE>last_deleted_semicolon_at</CODE>\n");
        }
        <CODE>write_logfile_entry</CODE>("  (<LITERALS>Use</LITERALS> -<LITERALS>ndsc</LITERALS> <LITERALS>to</LITERALS> <LITERALS>prevent</LITERALS> <LITERALS>semicolon</LITERALS> <LITERALS>deletion</LITERALS>)\n");
        <CODE>write_logfile_entry</CODE>("\n");
    }

    if ( $<CODE>embedded_tab_count</CODE> > 0 ) {
        my $<CODE>first</CODE> = ( $<CODE>embedded_tab_count</CODE> > 1 ) ? "<LITERALS>First</LITERALS>" : "";
        my $<CODE>what</CODE> =
          ( $<CODE>embedded_tab_count</CODE> > 1 )
          ? "<LITERALS>quotes</LITERALS> <LITERALS>or</LITERALS> <LITERALS>patterns</LITERALS>"
          : "<LITERALS>quote</LITERALS> <LITERALS>or</LITERALS> <LITERALS>pattern</LITERALS>";
        <CODE>write_logfile_entry</CODE>("$<CODE>embedded_tab_count</CODE> $<CODE>what</CODE> <LITERALS>had</LITERALS> <LITERALS>embedded</LITERALS> <LITERALS>tabs</LITERALS>:\n");
        <CODE>write_logfile_entry</CODE>(
"<LITERALS>This</LITERALS> <LITERALS>means</LITERALS> <LITERALS>the</LITERALS> <LITERALS>display</LITERALS> <LITERALS>of</LITERALS> <LITERALS>this</LITERALS> <LITERALS>script</LITERALS> <LITERALS>could</LITERALS> <LITERALS>vary</LITERALS> <LITERALS>with</LITERALS> <LITERALS>device</LITERALS> <LITERALS>or</LITERALS> <LITERALS>software</LITERALS>\n"
        );
        <CODE>write_logfile_entry</CODE>("  $<CODE>first</CODE> <LITERALS>at</LITERALS> <LITERALS>input</LITERALS> <LITERALS>line</LITERALS> $<CODE>first_embedded_tab_at</CODE>\n");

        if ( $<CODE>embedded_tab_count</CODE> > 1 ) {
            <CODE>write_logfile_entry</CODE>(
                "   <LITERALS>Last</LITERALS> <LITERALS>at</LITERALS> <LITERALS>input</LITERALS> <LITERALS>line</LITERALS> $<CODE>last_embedded_tab_at</CODE>\n");
        }
        <CODE>write_logfile_entry</CODE>("\n");
    }

    if ($<CODE>first_tabbing_disagreement</CODE>) {
        <CODE>write_logfile_entry</CODE>(
"<LITERALS>First</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>disagreement</LITERALS> <LITERALS>seen</LITERALS> <LITERALS>at</LITERALS> <LITERALS>input</LITERALS> <LITERALS>line</LITERALS> $<CODE>first_tabbing_disagreement</CODE>\n"
        );
    }

    if ($<CODE>in_tabbing_disagreement</CODE>) {
        <CODE>write_logfile_entry</CODE>(
"<LITERALS>Ending</LITERALS> <LITERALS>with</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>disagreement</LITERALS> <LITERALS>which</LITERALS> <LITERALS>started</LITERALS> <LITERALS>at</LITERALS> <LITERALS>input</LITERALS> <LITERALS>line</LITERALS> $<CODE>in_tabbing_disagreement</CODE>\n"
        );
    }
    else {

        if ($<CODE>last_tabbing_disagreement</CODE>) {

            <CODE>write_logfile_entry</CODE>(
"<LITERALS>Last</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>disagreement</LITERALS> <LITERALS>seen</LITERALS> <LITERALS>at</LITERALS> <LITERALS>input</LITERALS> <LITERALS>line</LITERALS> $<CODE>last_tabbing_disagreement</CODE>\n"
            );
        }
        else {
            <CODE>write_logfile_entry</CODE>("<LITERALS>No</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>disagreement</LITERALS> <LITERALS>seen</LITERALS>\n");
        }
    }
    if ($<CODE>first_tabbing_disagreement</CODE>) {
        <CODE>write_logfile_entry</CODE>(
"<LITERALS>Note</LITERALS>: <LITERALS>Indentation</LITERALS> <LITERALS>disagreement</LITERALS> <LITERALS>detection</LITERALS> <LITERALS>is</LITERALS> <LITERALS>not</LITERALS> <LITERALS>accurate</LITERALS> <LITERALS>for</LITERALS> <LITERALS>outdenting</LITERALS> <LITERALS>and</LITERALS> -<LITERALS>lp</LITERALS>.\n"
        );
    }
    <CODE>write_logfile_entry</CODE>("\n");

    $<CODE>vertical_aligner_object</CODE>-><CODE>report_anything_unusual</CODE>();

    $<CODE>file_writer_object</CODE>-><CODE>report_line_length_errors</CODE>();
}

sub <CODE>check_options</CODE> {

    # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>Opts</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>defined</COMMENTS>

    ($<CODE>rOpts</CODE>) = @<CODE>_</CODE>;

    <CODE>make_static_block_comment_pattern</CODE>();
    <CODE>make_static_side_comment_pattern</CODE>();
    <CODE>make_closing_side_comment_prefix</CODE>();
    <CODE>make_closing_side_comment_list_pattern</CODE>();
    $<CODE>format_skipping_pattern_begin</CODE> =
      <CODE>make_format_skipping_pattern</CODE>( '<LITERALS>format</LITERALS>-<LITERALS>skipping</LITERALS>-<LITERALS>begin</LITERALS>', '#<<<' );
    $<CODE>format_skipping_pattern_end</CODE> =
      <CODE>make_format_skipping_pattern</CODE>( '<LITERALS>format</LITERALS>-<LITERALS>skipping</LITERALS>-<LITERALS>end</LITERALS>', '#>>>' );

    # <COMMENTS>If</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>ARE</COMMENTS> <COMMENTS>selected</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>safely</COMMENTS>
    # <COMMENTS>delete</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
    # <COMMENTS>warnings</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>requested</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>idea</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS>
    # <COMMENTS>eliminate</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>csc</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>fall</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>threshold</COMMENTS>.
    # <COMMENTS>We</COMMENTS> <COMMENTS>cannot</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>warnings</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>turned</COMMENTS> <COMMENTS>on</COMMENTS>, <COMMENTS>though</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS>
    # <COMMENTS>might</COMMENTS> <COMMENTS>delete</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>added</COMMENTS>.  <COMMENTS>So</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>must</COMMENTS>
    # <COMMENTS>be</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>created</COMMENTS>.
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>'} ) {
        if ( !$<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>warnings</LITERALS>'} ) {
            $<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>'} = 1;
        }
    }

    # <COMMENTS>If</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>ARE</COMMENTS> <COMMENTS>NOT</COMMENTS> <COMMENTS>selected</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>warnings</COMMENTS> <COMMENTS>ARE</COMMENTS>
    # <COMMENTS>selected</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>ARE</COMMENTS> <COMMENTS>DELETING</COMMENTS> <COMMENTS>csc</COMMENTS>'<COMMENTS>s</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>pretend</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>adding</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>huge</COMMENTS> <COMMENTS>interval</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>generated</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>comparison</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>comments</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>added</COMMENTS>.
    elsif ( $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>warnings</LITERALS>'} ) {
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>'} ) {
            $<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>'}  = 0;
            $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>'}         = 1;
            $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>interval</LITERALS>'} = 100000000;
        }
    }

    <CODE>make_bli_pattern</CODE>();
    <CODE>make_block_brace_vertical_tightness_pattern</CODE>();

    if ( $<CODE>rOpts</CODE>->{'<LITERALS>line</LITERALS>-<LITERALS>up</LITERALS>-<LITERALS>parentheses</LITERALS>'} ) {

        if (   $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>only</LITERALS>'}
            || !$<CODE>rOpts</CODE>->{'<LITERALS>add</LITERALS>-<LITERALS>newlines</LITERALS>'}
            || !$<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>newlines</LITERALS>'} )
        {
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE> <<<LITERALS>EOM</LITERALS>;
-----------------------------------------------------------------------
<LITERALS>Conflict</LITERALS>: -<LITERALS>lp</LITERALS>  <LITERALS>conflicts</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>io</LITERALS>, -<LITERALS>fnl</LITERALS>, -<LITERALS>nanl</LITERALS>, <LITERALS>or</LITERALS> -<LITERALS>ndnl</LITERALS>; <LITERALS>ignoring</LITERALS> -<LITERALS>lp</LITERALS>

<LITERALS>The</LITERALS> -<LITERALS>lp</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>logic</LITERALS> <LITERALS>requires</LITERALS> <LITERALS>that</LITERALS> <LITERALS>perltidy</LITERALS> <LITERALS>be</LITERALS> <LITERALS>able</LITERALS> <LITERALS>to</LITERALS> <LITERALS>coordinate</LITERALS>
<LITERALS>arbitrarily</LITERALS> <LITERALS>large</LITERALS> <LITERALS>numbers</LITERALS> <LITERALS>of</LITERALS> <LITERALS>line</LITERALS> <LITERALS>breakpoints</LITERALS>.  <LITERALS>This</LITERALS> <LITERALS>isn</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>possible</LITERALS>
<LITERALS>with</LITERALS> <LITERALS>these</LITERALS> <LITERALS>flags</LITERALS>. <LITERALS>Sometimes</LITERALS> <LITERALS>an</LITERALS> <LITERALS>acceptable</LITERALS> <LITERALS>workaround</LITERALS> <LITERALS>is</LITERALS> <LITERALS>to</LITERALS> <LITERALS>use</LITERALS> -<LITERALS>wocb</LITERALS>=<LITERALS>3</LITERALS>
-----------------------------------------------------------------------
<CODE>EOM</CODE>
            $<CODE>rOpts</CODE>->{'<LITERALS>line</LITERALS>-<LITERALS>up</LITERALS>-<LITERALS>parentheses</LITERALS>'} = 0;
        }
    }

    # <COMMENTS>At</COMMENTS> <COMMENTS>present</COMMENTS>, <COMMENTS>tabs</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>compatible</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>-<COMMENTS>up</COMMENTS>-<COMMENTS>parentheses</COMMENTS> <COMMENTS>style</COMMENTS>
    # (<COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>entab</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS>
    # <COMMENTS>just</COMMENTS> <COMMENTS>prior</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>writing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>desired</COMMENTS>).
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>line</LITERALS>-<LITERALS>up</LITERALS>-<LITERALS>parentheses</LITERALS>'} && $<CODE>rOpts</CODE>->{'<LITERALS>tabs</LITERALS>'} ) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>Conflict</LITERALS>: -<LITERALS>t</LITERALS> (<LITERALS>tabs</LITERALS>) <LITERALS>cannot</LITERALS> <LITERALS>be</LITERALS> <LITERALS>used</LITERALS> <LITERALS>with</LITERALS> <LITERALS>the</LITERALS> -<LITERALS>lp</LITERALS>  <LITERALS>option</LITERALS>; <LITERALS>ignoring</LITERALS> -<LITERALS>t</LITERALS>; <LITERALS>see</LITERALS> -<LITERALS>et</LITERALS>.
<CODE>EOM</CODE>
        $<CODE>rOpts</CODE>->{'<LITERALS>tabs</LITERALS>'} = 0;
    }

    # <COMMENTS>Likewise</COMMENTS>, <COMMENTS>tabs</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>compatible</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>outdenting</COMMENTS>..
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>outdent</LITERALS>-<LITERALS>keywords</LITERALS>'} && $<CODE>rOpts</CODE>->{'<LITERALS>tabs</LITERALS>'} ) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>Conflict</LITERALS>: -<LITERALS>t</LITERALS> (<LITERALS>tabs</LITERALS>) <LITERALS>cannot</LITERALS> <LITERALS>be</LITERALS> <LITERALS>used</LITERALS> <LITERALS>with</LITERALS> <LITERALS>the</LITERALS> -<LITERALS>okw</LITERALS> <LITERALS>options</LITERALS>; <LITERALS>ignoring</LITERALS> -<LITERALS>t</LITERALS>; <LITERALS>see</LITERALS> -<LITERALS>et</LITERALS>.
<CODE>EOM</CODE>
        $<CODE>rOpts</CODE>->{'<LITERALS>tabs</LITERALS>'} = 0;
    }

    if ( $<CODE>rOpts</CODE>->{'<LITERALS>outdent</LITERALS>-<LITERALS>labels</LITERALS>'} && $<CODE>rOpts</CODE>->{'<LITERALS>tabs</LITERALS>'} ) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>Conflict</LITERALS>: -<LITERALS>t</LITERALS> (<LITERALS>tabs</LITERALS>) <LITERALS>cannot</LITERALS> <LITERALS>be</LITERALS> <LITERALS>used</LITERALS> <LITERALS>with</LITERALS> <LITERALS>the</LITERALS> -<LITERALS>ola</LITERALS>  <LITERALS>option</LITERALS>; <LITERALS>ignoring</LITERALS> -<LITERALS>t</LITERALS>; <LITERALS>see</LITERALS> -<LITERALS>et</LITERALS>.
<CODE>EOM</CODE>
        $<CODE>rOpts</CODE>->{'<LITERALS>tabs</LITERALS>'} = 0;
    }

    if ( !$<CODE>rOpts</CODE>->{'<LITERALS>space</LITERALS>-<LITERALS>for</LITERALS>-<LITERALS>semicolon</LITERALS>'} ) {
        $<CODE>want_left_space</CODE>{'<LITERALS>f</LITERALS>'} = -1;
    }

    if ( $<CODE>rOpts</CODE>->{'<LITERALS>space</LITERALS>-<LITERALS>terminal</LITERALS>-<LITERALS>semicolon</LITERALS>'} ) {
        $<CODE>want_left_space</CODE>{';'} = 1;
    }

    # <COMMENTS>implement</COMMENTS> <COMMENTS>outdenting</COMMENTS> <COMMENTS>preferences</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>keywords</COMMENTS>
    %<CODE>outdent_keyword</CODE> = ();
    unless ( @<CODE>_</CODE> = <CODE>split_words</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>outdent</LITERALS>-<LITERALS>keyword</LITERALS>-<LITERALS>okl</LITERALS>'} ) ) {
        @<CODE>_</CODE> = qw(<LITERALS>next</LITERALS> <LITERALS>last</LITERALS> <LITERALS>redo</LITERALS> <LITERALS>goto</LITERALS> <LITERALS>return</LITERALS>);    # <COMMENTS>defaults</COMMENTS>
    }

    # <COMMENTS>FUTURE</COMMENTS>: <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>keyword</COMMENTS>, <COMMENTS>assume</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>identifier</COMMENTS>
    foreach (@<CODE>_</CODE>) {
        if ( $<CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Tokenizer</CODE>::<CODE>is_keyword</CODE>{$<CODE>_</CODE>} ) {
            $<CODE>outdent_keyword</CODE>{$<CODE>_</CODE>} = 1;
        }
        else {
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE> "<LITERALS>ignoring</LITERALS> '$<CODE>_</CODE>' <LITERALS>in</LITERALS> -<LITERALS>okwl</LITERALS> <LITERALS>list</LITERALS>; <LITERALS>not</LITERALS> <LITERALS>a</LITERALS> <LITERALS>perl</LITERALS> <LITERALS>keyword</LITERALS>";
        }
    }

    # <COMMENTS>implement</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>preferences</COMMENTS>
    if ( @<CODE>_</CODE> = <CODE>split_words</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>want</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>space</LITERALS>'} ) ) {
        @<CODE>want_left_space</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);
    }

    if ( @<CODE>_</CODE> = <CODE>split_words</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>want</LITERALS>-<LITERALS>right</LITERALS>-<LITERALS>space</LITERALS>'} ) ) {
        @<CODE>want_right_space</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);
    }

    if ( @<CODE>_</CODE> = <CODE>split_words</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>nowant</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>space</LITERALS>'} ) ) {
        @<CODE>want_left_space</CODE>{@<CODE>_</CODE>} = (-1) x scalar(@<CODE>_</CODE>);
    }

    if ( @<CODE>_</CODE> = <CODE>split_words</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>nowant</LITERALS>-<LITERALS>right</LITERALS>-<LITERALS>space</LITERALS>'} ) ) {
        @<CODE>want_right_space</CODE>{@<CODE>_</CODE>} = (-1) x scalar(@<CODE>_</CODE>);
    }
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>dump</LITERALS>-<LITERALS>want</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>space</LITERALS>'} ) {
        <CODE>dump_want_left_space</CODE>(*<CODE>STDOUT</CODE>);
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Exit</CODE> 0;
    }

    if ( $<CODE>rOpts</CODE>->{'<LITERALS>dump</LITERALS>-<LITERALS>want</LITERALS>-<LITERALS>right</LITERALS>-<LITERALS>space</LITERALS>'} ) {
        <CODE>dump_want_right_space</CODE>(*<CODE>STDOUT</CODE>);
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Exit</CODE> 0;
    }

    # <COMMENTS>default</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>introduced</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS>
    # (<COMMENTS>at</COMMENTS> <COMMENTS>present</COMMENTS>, <COMMENTS>including</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>messes</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS>)
    @<CODE>_</CODE> = qw(<LITERALS>my</LITERALS> <LITERALS>local</LITERALS> <LITERALS>our</LITERALS> <LITERALS>and</LITERALS> <LITERALS>or</LITERALS> <LITERALS>err</LITERALS> <LITERALS>eq</LITERALS> <LITERALS>ne</LITERALS> <LITERALS>if</LITERALS> <LITERALS>else</LITERALS> <LITERALS>elsif</LITERALS> <LITERALS>until</LITERALS>
      <LITERALS>unless</LITERALS> <LITERALS>while</LITERALS> <LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS> <LITERALS>return</LITERALS> <LITERALS>switch</LITERALS> <LITERALS>case</LITERALS> <LITERALS>given</LITERALS> <LITERALS>when</LITERALS>);
    @<CODE>space_after_keyword</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>first</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>desired</COMMENTS>
    if ( @<CODE>_</CODE> = <CODE>split_words</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>nospace</LITERALS>-<LITERALS>after</LITERALS>-<LITERALS>keyword</LITERALS>'} ) ) {

        # -<COMMENTS>nsak</COMMENTS>='*' <COMMENTS>selects</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>keywords</COMMENTS>
        if ( @<CODE>_</CODE> == 1 && $<CODE>_</CODE>[0] eq '*' ) { @<CODE>_</CODE> = keys(%<CODE>space_after_keyword</CODE>) }
        @<CODE>space_after_keyword</CODE>{@<CODE>_</CODE>} = (0) x scalar(@<CODE>_</CODE>);
    }

    # <COMMENTS>then</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>defaults</COMMENTS>
    if ( @<CODE>_</CODE> = <CODE>split_words</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>space</LITERALS>-<LITERALS>after</LITERALS>-<LITERALS>keyword</LITERALS>'} ) ) {
        @<CODE>space_after_keyword</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);
    }

    # <COMMENTS>implement</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>preferences</COMMENTS>
    my @<CODE>all_operators</CODE> = qw(% + - * / <LITERALS>x</LITERALS> != == >= <= =~ !~ < > | &
      = **= += *= &= <<= &&= -= /= |= >>= ||= //= .= %= ^= <LITERALS>x</LITERALS>=
      . : ? && || <LITERALS>and</LITERALS> <LITERALS>or</LITERALS> <LITERALS>err</LITERALS> <LITERALS>xor</LITERALS>
    );

    my $<CODE>break_after</CODE> = sub {
        foreach my $<CODE>tok</CODE> (@<CODE>_</CODE>) {
            if ( $<CODE>tok</CODE> eq '?' ) { $<CODE>tok</CODE> = ':' }    # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>coordinate</COMMENTS> ?/:
            my $<CODE>lbs</CODE> = $<CODE>left_bond_strength</CODE>{$<CODE>tok</CODE>};
            my $<CODE>rbs</CODE> = $<CODE>right_bond_strength</CODE>{$<CODE>tok</CODE>};
            if ( defined($<CODE>lbs</CODE>) && defined($<CODE>rbs</CODE>) && $<CODE>lbs</CODE> < $<CODE>rbs</CODE> ) {
                ( $<CODE>right_bond_strength</CODE>{$<CODE>tok</CODE>}, $<CODE>left_bond_strength</CODE>{$<CODE>tok</CODE>} ) =
                  ( $<CODE>lbs</CODE>, $<CODE>rbs</CODE> );
            }
        }
    };

    my $<CODE>break_before</CODE> = sub {
        foreach my $<CODE>tok</CODE> (@<CODE>_</CODE>) {
            my $<CODE>lbs</CODE> = $<CODE>left_bond_strength</CODE>{$<CODE>tok</CODE>};
            my $<CODE>rbs</CODE> = $<CODE>right_bond_strength</CODE>{$<CODE>tok</CODE>};
            if ( defined($<CODE>lbs</CODE>) && defined($<CODE>rbs</CODE>) && $<CODE>rbs</CODE> < $<CODE>lbs</CODE> ) {
                ( $<CODE>right_bond_strength</CODE>{$<CODE>tok</CODE>}, $<CODE>left_bond_strength</CODE>{$<CODE>tok</CODE>} ) =
                  ( $<CODE>lbs</CODE>, $<CODE>rbs</CODE> );
            }
        }
    };

    $<CODE>break_after</CODE>->(@<CODE>all_operators</CODE>) if ( $<CODE>rOpts</CODE>->{'<LITERALS>break</LITERALS>-<LITERALS>after</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>operators</LITERALS>'} );
    $<CODE>break_before</CODE>->(@<CODE>all_operators</CODE>)
      if ( $<CODE>rOpts</CODE>->{'<LITERALS>break</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>all</LITERALS>-<LITERALS>operators</LITERALS>'} );

    $<CODE>break_after</CODE>->( <CODE>split_words</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>want</LITERALS>-<LITERALS>break</LITERALS>-<LITERALS>after</LITERALS>'} ) );
    $<CODE>break_before</CODE>->( <CODE>split_words</CODE>( $<CODE>rOpts</CODE>->{'<LITERALS>want</LITERALS>-<LITERALS>break</LITERALS>-<LITERALS>before</LITERALS>'} ) );

    # <COMMENTS>make</COMMENTS> <COMMENTS>note</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>key</COMMENTS> <COMMENTS>types</COMMENTS>
    %<CODE>want_break_before</CODE> = ();
    foreach my $<CODE>tok</CODE> ( @<CODE>all_operators</CODE>, ',' ) {
        $<CODE>want_break_before</CODE>{$<CODE>tok</CODE>} =
          $<CODE>left_bond_strength</CODE>{$<CODE>tok</CODE>} < $<CODE>right_bond_strength</CODE>{$<CODE>tok</CODE>};
    }

    # <COMMENTS>Coordinate</COMMENTS> ?/: <COMMENTS>breaks</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>similar</COMMENTS>
    if ( !$<CODE>want_break_before</CODE>{':'} ) {
        $<CODE>want_break_before</CODE>{'?'}   = $<CODE>want_break_before</CODE>{':'};
        $<CODE>right_bond_strength</CODE>{'?'} = $<CODE>right_bond_strength</CODE>{':'} + 0.01;
        $<CODE>left_bond_strength</CODE>{'?'}  = <CODE>NO_BREAK</CODE>;
    }

    # <COMMENTS>Define</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>statement</COMMENTS>
    # <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS>:
    #   } <COMMENTS>while</COMMENTS> ( <COMMENTS>$something</COMMENTS>);
    @<CODE>_</CODE> = qw(<LITERALS>until</LITERALS> <LITERALS>while</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>if</LITERALS> ; : );
    push @<CODE>_</CODE>, ',';
    @<CODE>is_do_follower</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>These</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>elsif</COMMENTS> <COMMENTS>block</COMMENTS>.
    # <COMMENTS>In</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>words</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>cuddled</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>like</COMMENTS>:
    #   } <COMMENTS>elsif</COMMENTS> ( <COMMENTS>$something</COMMENTS>) {
    #   } <COMMENTS>else</COMMENTS> {
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>cuddled</LITERALS>-<LITERALS>else</LITERALS>'} ) {
        @<CODE>_</CODE> = qw(<LITERALS>else</LITERALS> <LITERALS>elsif</LITERALS>);
        @<CODE>is_if_brace_follower</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);
    }
    else {
        %<CODE>is_if_brace_follower</CODE> = ();
    }

    # <COMMENTS>nothing</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>else</COMMENTS> { } <COMMENTS>block</COMMENTS>:
    %<CODE>is_else_brace_follower</CODE> = ();

    # <COMMENTS>what</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>multi</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>definition</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>curly</COMMENTS>:
    @<CODE>_</CODE> = qw# ; : => <LITERALS>or</LITERALS> <LITERALS>and</LITERALS>  && || ~~ !~~ ) #;
    push @<CODE>_</CODE>, ',';
    @<CODE>is_anon_sub_brace_follower</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>what</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>curly</COMMENTS>:
    # <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>subs</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>have</COMMENTS> ']' <COMMENTS>here</COMMENTS>...
    # <COMMENTS>see</COMMENTS> <COMMENTS>tk3</COMMENTS>.<COMMENTS>t</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>PP</COMMENTS>.<COMMENTS>pm</COMMENTS>
    @<CODE>_</CODE> = qw#  ; : => <LITERALS>or</LITERALS> <LITERALS>and</LITERALS>  && || ) ] ~~ !~~ #;
    push @<CODE>_</CODE>, ',';
    @<CODE>is_anon_sub_1_brace_follower</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>What</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS>
    # <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>if</COMMENTS>/<COMMENTS>elsif</COMMENTS>/<COMMENTS>else</COMMENTS>/<COMMENTS>do</COMMENTS>/<COMMENTS>sort</COMMENTS>/<COMMENTS>map</COMMENTS>/<COMMENTS>grep</COMMENTS>/<COMMENTS>eval</COMMENTS>/<COMMENTS>sub</COMMENTS>
    # <COMMENTS>Testfiles</COMMENTS>: '<COMMENTS>Toolbar</COMMENTS>.<COMMENTS>pm</COMMENTS>', '<COMMENTS>Menubar</COMMENTS>.<COMMENTS>pm</COMMENTS>', <COMMENTS>bless</COMMENTS>.<COMMENTS>t</COMMENTS>, '<COMMENTS>3rules</COMMENTS>.<COMMENTS>pl</COMMENTS>'
    @<CODE>_</CODE> = qw#  ; : => <LITERALS>or</LITERALS> <LITERALS>and</LITERALS>  && || ) #;
    push @<CODE>_</CODE>, ',';

    # <COMMENTS>allow</COMMENTS> <COMMENTS>cuddled</COMMENTS> <COMMENTS>continue</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>cuddled</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>specified</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>cuddled</LITERALS>-<LITERALS>else</LITERALS>'} ) { push @<CODE>_</CODE>, '<LITERALS>continue</LITERALS>'; }

    @<CODE>is_other_brace_follower</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    $<CODE>right_bond_strength</CODE>{'{'} = <CODE>WEAK</CODE>;
    $<CODE>left_bond_strength</CODE>{'{'}  = <CODE>VERY_STRONG</CODE>;

    # <COMMENTS>make</COMMENTS> -<COMMENTS>l</COMMENTS>=<COMMENTS>0</COMMENTS>  <COMMENTS>equal</COMMENTS> <COMMENTS>to</COMMENTS> -<COMMENTS>l</COMMENTS>=<COMMENTS>infinite</COMMENTS>
    if ( !$<CODE>rOpts</CODE>->{'<LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>'} ) {
        $<CODE>rOpts</CODE>->{'<LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>'} = 1000000;
    }

    # <COMMENTS>make</COMMENTS> -<COMMENTS>lbl</COMMENTS>=<COMMENTS>0</COMMENTS>  <COMMENTS>equal</COMMENTS> <COMMENTS>to</COMMENTS> -<COMMENTS>lbl</COMMENTS>=<COMMENTS>infinite</COMMENTS>
    if ( !$<CODE>rOpts</CODE>->{'<LITERALS>long</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>count</LITERALS>'} ) {
        $<CODE>rOpts</CODE>->{'<LITERALS>long</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>count</LITERALS>'} = 1000000;
    }

    my $<CODE>enc</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>character</LITERALS>-<LITERALS>encoding</LITERALS>'};
    if ( $<CODE>enc</CODE> && $<CODE>enc</CODE> !~ /^(none|utf8)$/i ) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>Unrecognized</LITERALS> <LITERALS>character</LITERALS>-<LITERALS>encoding</LITERALS> '$<CODE>enc</CODE>'; <LITERALS>expecting</LITERALS> <LITERALS>one</LITERALS> <LITERALS>of</LITERALS>: (<LITERALS>none</LITERALS>, <LITERALS>utf8</LITERALS>)
<CODE>EOM</CODE>
    }

    my $<CODE>ole</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>output</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>ending</LITERALS>'};
    if ($<CODE>ole</CODE>) {
        my %<CODE>endings</CODE> = (
            <LITERALS>dos</LITERALS>  => "\015\012",
            <LITERALS>win</LITERALS>  => "\015\012",
            <LITERALS>mac</LITERALS>  => "\015",
            <LITERALS>unix</LITERALS> => "\012",
        );

        # <COMMENTS>Patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>RT</COMMENTS> #<COMMENTS>99514</COMMENTS>, <COMMENTS>a</COMMENTS> <COMMENTS>memoization</COMMENTS> <COMMENTS>issue</COMMENTS>.
        # <COMMENTS>Normally</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>enters</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> '<COMMENTS>dos</COMMENTS>', '<COMMENTS>win</COMMENTS>', <COMMENTS>etc</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>value</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>parameter</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>corresponding</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ending</COMMENTS>
        # <COMMENTS>character</COMMENTS>.  <COMMENTS>But</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>using</COMMENTS> <COMMENTS>memoization</COMMENTS>, <COMMENTS>on</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>passes</COMMENTS> <COMMENTS>through</COMMENTS>
        # <COMMENTS>here</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>parameter</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>desired</COMMENTS> <COMMENTS>ending</COMMENTS>
        # <COMMENTS>character</COMMENTS> <COMMENTS>rather</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>keyword</COMMENTS> '<COMMENTS>dos</COMMENTS>', '<COMMENTS>win</COMMENTS>', <COMMENTS>etc</COMMENTS>.  <COMMENTS>So</COMMENTS>
        # <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>conversion</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>and</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>so</COMMENTS>,
        # <COMMENTS>bypass</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>conversion</COMMENTS> <COMMENTS>step</COMMENTS>.
        my %<CODE>endings_inverted</CODE> = (
            "\015\012" => '<LITERALS>dos</LITERALS>',
            "\015\012" => '<LITERALS>win</LITERALS>',
            "\015"     => '<LITERALS>mac</LITERALS>',
            "\012"     => '<LITERALS>unix</LITERALS>',
        );

        if ( defined( $<CODE>endings_inverted</CODE>{$<CODE>ole</CODE>} ) ) {

            # <COMMENTS>we</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ending</COMMENTS>, <COMMENTS>nothing</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS>
        }
        else {
            $<CODE>ole</CODE> = lc $<CODE>ole</CODE>;
            unless ( $<CODE>rOpts</CODE>->{'<LITERALS>output</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>ending</LITERALS>'} = $<CODE>endings</CODE>{$<CODE>ole</CODE>} ) {
                my $<CODE>str</CODE> = join " ", keys %<CODE>endings</CODE>;
                <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>Unrecognized</LITERALS> <LITERALS>line</LITERALS> <LITERALS>ending</LITERALS> '$<CODE>ole</CODE>'; <LITERALS>expecting</LITERALS> <LITERALS>one</LITERALS> <LITERALS>of</LITERALS>: $<CODE>str</CODE>
<CODE>EOM</CODE>
            }
            if ( $<CODE>rOpts</CODE>->{'<LITERALS>preserve</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>endings</LITERALS>'} ) {
                <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE> "<LITERALS>Ignoring</LITERALS> -<LITERALS>ple</LITERALS>; <LITERALS>conflicts</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>ole</LITERALS>\n";
                $<CODE>rOpts</CODE>->{'<LITERALS>preserve</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>endings</LITERALS>'} = undef;
            }
        }
    }

    # <COMMENTS>hashes</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>simplify</COMMENTS> <COMMENTS>setting</COMMENTS> <COMMENTS>whitespace</COMMENTS>
    %<CODE>tightness</CODE> = (
        '{' => $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>tightness</LITERALS>'},
        '}' => $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>tightness</LITERALS>'},
        '(' => $<CODE>rOpts</CODE>->{'<LITERALS>paren</LITERALS>-<LITERALS>tightness</LITERALS>'},
        ')' => $<CODE>rOpts</CODE>->{'<LITERALS>paren</LITERALS>-<LITERALS>tightness</LITERALS>'},
        '[' => $<CODE>rOpts</CODE>->{'<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>tightness</LITERALS>'},
        ']' => $<CODE>rOpts</CODE>->{'<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>tightness</LITERALS>'},
    );
    %<CODE>matching_token</CODE> = (
        '{' => '}',
        '(' => ')',
        '[' => ']',
        '?' => ':',
    );

    # <COMMENTS>frequently</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>parameters</COMMENTS>
    $<CODE>rOpts_add_newlines</CODE>          = $<CODE>rOpts</CODE>->{'<LITERALS>add</LITERALS>-<LITERALS>newlines</LITERALS>'};
    $<CODE>rOpts_add_whitespace</CODE>        = $<CODE>rOpts</CODE>->{'<LITERALS>add</LITERALS>-<LITERALS>whitespace</LITERALS>'};
    $<CODE>rOpts_block_brace_tightness</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>tightness</LITERALS>'};
    $<CODE>rOpts_block_brace_vertical_tightness</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'};
    $<CODE>rOpts_brace_left_and_indent</CODE>   = $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>and</LITERALS>-<LITERALS>indent</LITERALS>'};
    $<CODE>rOpts_comma_arrow_breakpoints</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>comma</LITERALS>-<LITERALS>arrow</LITERALS>-<LITERALS>breakpoints</LITERALS>'};
    $<CODE>rOpts_break_at_old_ternary_breakpoints</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>ternary</LITERALS>-<LITERALS>breakpoints</LITERALS>'};
    $<CODE>rOpts_break_at_old_attribute_breakpoints</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>attribute</LITERALS>-<LITERALS>breakpoints</LITERALS>'};
    $<CODE>rOpts_break_at_old_comma_breakpoints</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>comma</LITERALS>-<LITERALS>breakpoints</LITERALS>'};
    $<CODE>rOpts_break_at_old_keyword_breakpoints</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>keyword</LITERALS>-<LITERALS>breakpoints</LITERALS>'};
    $<CODE>rOpts_break_at_old_logical_breakpoints</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>break</LITERALS>-<LITERALS>at</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>logical</LITERALS>-<LITERALS>breakpoints</LITERALS>'};
    $<CODE>rOpts_closing_side_comment_else_flag</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>else</LITERALS>-<LITERALS>flag</LITERALS>'};
    $<CODE>rOpts_closing_side_comment_maximum_text</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>maximum</LITERALS>-<LITERALS>text</LITERALS>'};
    $<CODE>rOpts_continuation_indentation</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>continuation</LITERALS>-<LITERALS>indentation</LITERALS>'};
    $<CODE>rOpts_cuddled_else</CODE>             = $<CODE>rOpts</CODE>->{'<LITERALS>cuddled</LITERALS>-<LITERALS>else</LITERALS>'};
    $<CODE>rOpts_delete_old_whitespace</CODE>    = $<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>whitespace</LITERALS>'};
    $<CODE>rOpts_fuzzy_line_length</CODE>        = $<CODE>rOpts</CODE>->{'<LITERALS>fuzzy</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>'};
    $<CODE>rOpts_indent_columns</CODE>           = $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>columns</LITERALS>'};
    $<CODE>rOpts_line_up_parentheses</CODE>      = $<CODE>rOpts</CODE>->{'<LITERALS>line</LITERALS>-<LITERALS>up</LITERALS>-<LITERALS>parentheses</LITERALS>'};
    $<CODE>rOpts_maximum_fields_per_table</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>maximum</LITERALS>-<LITERALS>fields</LITERALS>-<LITERALS>per</LITERALS>-<LITERALS>table</LITERALS>'};
    $<CODE>rOpts_maximum_line_length</CODE>      = $<CODE>rOpts</CODE>->{'<LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>'};
    $<CODE>rOpts_whitespace_cycle</CODE>         = $<CODE>rOpts</CODE>->{'<LITERALS>whitespace</LITERALS>-<LITERALS>cycle</LITERALS>'};

    $<CODE>rOpts_variable_maximum_line_length</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>variable</LITERALS>-<LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>'};
    $<CODE>rOpts_short_concatenation_item_length</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>short</LITERALS>-<LITERALS>concatenation</LITERALS>-<LITERALS>item</LITERALS>-<LITERALS>length</LITERALS>'};

    $<CODE>rOpts_keep_old_blank_lines</CODE>     = $<CODE>rOpts</CODE>->{'<LITERALS>keep</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>'};
    $<CODE>rOpts_ignore_old_breakpoints</CODE>   = $<CODE>rOpts</CODE>->{'<LITERALS>ignore</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>breakpoints</LITERALS>'};
    $<CODE>rOpts_format_skipping</CODE>          = $<CODE>rOpts</CODE>->{'<LITERALS>format</LITERALS>-<LITERALS>skipping</LITERALS>'};
    $<CODE>rOpts_space_function_paren</CODE>     = $<CODE>rOpts</CODE>->{'<LITERALS>space</LITERALS>-<LITERALS>function</LITERALS>-<LITERALS>paren</LITERALS>'};
    $<CODE>rOpts_space_keyword_paren</CODE>      = $<CODE>rOpts</CODE>->{'<LITERALS>space</LITERALS>-<LITERALS>keyword</LITERALS>-<LITERALS>paren</LITERALS>'};
    $<CODE>rOpts_keep_interior_semicolons</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>keep</LITERALS>-<LITERALS>interior</LITERALS>-<LITERALS>semicolons</LITERALS>'};
    $<CODE>rOpts_ignore_side_comment_lengths</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>ignore</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>lengths</LITERALS>'};

    # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>access</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS>
    # <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>types</COMMENTS>.
    %<CODE>opening_vertical_tightness</CODE> = (
        '(' => $<CODE>rOpts</CODE>->{'<LITERALS>paren</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'},
        '{' => $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'},
        '[' => $<CODE>rOpts</CODE>->{'<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'},
        ')' => $<CODE>rOpts</CODE>->{'<LITERALS>paren</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'},
        '}' => $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'},
        ']' => $<CODE>rOpts</CODE>->{'<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>'},
    );

    %<CODE>closing_vertical_tightness</CODE> = (
        '(' => $<CODE>rOpts</CODE>->{'<LITERALS>paren</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'},
        '{' => $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'},
        '[' => $<CODE>rOpts</CODE>->{'<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'},
        ')' => $<CODE>rOpts</CODE>->{'<LITERALS>paren</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'},
        '}' => $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'},
        ']' => $<CODE>rOpts</CODE>->{'<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>closing</LITERALS>'},
    );

    $<CODE>rOpts_tight_secret_operators</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>tight</LITERALS>-<LITERALS>secret</LITERALS>-<LITERALS>operators</LITERALS>'};

    # <COMMENTS>assume</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>for</COMMENTS> '>' <COMMENTS>same</COMMENTS> <COMMENTS>as</COMMENTS> ')' <COMMENTS>for</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>quotes</COMMENTS>
    %<CODE>closing_token_indentation</CODE> = (
        ')' => $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>paren</LITERALS>-<LITERALS>indentation</LITERALS>'},
        '}' => $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>indentation</LITERALS>'},
        ']' => $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>indentation</LITERALS>'},
        '>' => $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>paren</LITERALS>-<LITERALS>indentation</LITERALS>'},
    );

    # <COMMENTS>flag</COMMENTS> <COMMENTS>indicating</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>indented</COMMENTS>
    $<CODE>some_closing_token_indentation</CODE> =
         $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>paren</LITERALS>-<LITERALS>indentation</LITERALS>'}
      || $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>indentation</LITERALS>'}
      || $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>indentation</LITERALS>'}
      || $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>brace</LITERALS>'};

    %<CODE>opening_token_right</CODE> = (
        '(' => $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>paren</LITERALS>-<LITERALS>right</LITERALS>'},
        '{' => $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>hash</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>right</LITERALS>'},
        '[' => $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>-<LITERALS>right</LITERALS>'},
    );

    %<CODE>stack_opening_token</CODE> = (
        '(' => $<CODE>rOpts</CODE>->{'<LITERALS>stack</LITERALS>-<LITERALS>opening</LITERALS>-<LITERALS>paren</LITERALS>'},
        '{' => $<CODE>rOpts</CODE>->{'<LITERALS>stack</LITERALS>-<LITERALS>opening</LITERALS>-<LITERALS>hash</LITERALS>-<LITERALS>brace</LITERALS>'},
        '[' => $<CODE>rOpts</CODE>->{'<LITERALS>stack</LITERALS>-<LITERALS>opening</LITERALS>-<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>'},
    );

    %<CODE>stack_closing_token</CODE> = (
        ')' => $<CODE>rOpts</CODE>->{'<LITERALS>stack</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>paren</LITERALS>'},
        '}' => $<CODE>rOpts</CODE>->{'<LITERALS>stack</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>hash</LITERALS>-<LITERALS>brace</LITERALS>'},
        ']' => $<CODE>rOpts</CODE>->{'<LITERALS>stack</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>square</LITERALS>-<LITERALS>bracket</LITERALS>'},
    );
    $<CODE>rOpts_stack_closing_block_brace</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>stack</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>'};
}

sub <CODE>make_static_block_comment_pattern</CODE> {

    # <COMMENTS>create</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>identify</COMMENTS> <COMMENTS>static</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comments</COMMENTS>
    $<CODE>static_block_comment_pattern</CODE> = '^\<LITERALS>s</LITERALS>*##';

    # <COMMENTS>allow</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>it</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>static</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>prefix</LITERALS>'} ) {
        my $<CODE>prefix</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>static</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>prefix</LITERALS>'};
        $<CODE>prefix</CODE> =~ s/^\s*//;
        my $<CODE>pattern</CODE> = $<CODE>prefix</CODE>;

        # <COMMENTS>user</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>caret</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>matching</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>only</COMMENTS>
        if ( $<CODE>prefix</CODE> !~ /^\^#/ ) {
            if ( $<CODE>prefix</CODE> !~ /^#/ ) {
                <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE>
"<LITERALS>ERROR</LITERALS>: <LITERALS>the</LITERALS> -<LITERALS>sbcp</LITERALS> <LITERALS>prefix</LITERALS> <LITERALS>is</LITERALS> '$<CODE>prefix</CODE>' <LITERALS>but</LITERALS> <LITERALS>must</LITERALS> <LITERALS>begin</LITERALS> <LITERALS>with</LITERALS> '#' <LITERALS>or</LITERALS> '^#'\n";
            }
            $<CODE>pattern</CODE> = '^\<LITERALS>s</LITERALS>*' . $<CODE>prefix</CODE>;
        }
        eval "'##'=~/$<CODE>pattern</CODE>/";
        if ($@) {
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE>
"<LITERALS>ERROR</LITERALS>: <LITERALS>the</LITERALS> -<LITERALS>sbc</LITERALS> <LITERALS>prefix</LITERALS> '$<CODE>prefix</CODE>' <LITERALS>causes</LITERALS> <LITERALS>the</LITERALS> <LITERALS>invalid</LITERALS> <LITERALS>regex</LITERALS> '$<CODE>pattern</CODE>'\n";
        }
        $<CODE>static_block_comment_pattern</CODE> = $<CODE>pattern</CODE>;
    }
}

sub <CODE>make_format_skipping_pattern</CODE> {
    my ( $<CODE>opt_name</CODE>, $<CODE>default</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>param</CODE> = $<CODE>rOpts</CODE>->{$<CODE>opt_name</CODE>};
    unless ($<CODE>param</CODE>) { $<CODE>param</CODE> = $<CODE>default</CODE> }
    $<CODE>param</CODE> =~ s/^\s*//;
    if ( $<CODE>param</CODE> !~ /^#/ ) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE>
          "<LITERALS>ERROR</LITERALS>: <LITERALS>the</LITERALS> $<CODE>opt_name</CODE> <LITERALS>parameter</LITERALS> '$<CODE>param</CODE>' <LITERALS>must</LITERALS> <LITERALS>begin</LITERALS> <LITERALS>with</LITERALS> '#'\n";
    }
    my $<CODE>pattern</CODE> = '^' . $<CODE>param</CODE> . '\<LITERALS>s</LITERALS>';
    eval "'#'=~/$<CODE>pattern</CODE>/";
    if ($@) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE>
"<LITERALS>ERROR</LITERALS>: <LITERALS>the</LITERALS> $<CODE>opt_name</CODE> <LITERALS>parameter</LITERALS> '$<CODE>param</CODE>' <LITERALS>causes</LITERALS> <LITERALS>the</LITERALS> <LITERALS>invalid</LITERALS> <LITERALS>regex</LITERALS> '$<CODE>pattern</CODE>'\n";
    }
    return $<CODE>pattern</CODE>;
}

sub <CODE>make_closing_side_comment_list_pattern</CODE> {

    # <COMMENTS>turn</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>regex</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>recognizing</COMMENTS> <COMMENTS>selected</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS>
    $<CODE>closing_side_comment_list_pattern</CODE> = '^\<LITERALS>w</LITERALS>+';
    if ( defined( $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>list</LITERALS>'} )
        && $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>list</LITERALS>'} )
    {
        $<CODE>closing_side_comment_list_pattern</CODE> =
          <CODE>make_block_pattern</CODE>( '-<LITERALS>cscl</LITERALS>', $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>list</LITERALS>'} );
    }
}

sub <CODE>make_bli_pattern</CODE> {

    if ( defined( $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>and</LITERALS>-<LITERALS>indent</LITERALS>-<LITERALS>list</LITERALS>'} )
        && $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>and</LITERALS>-<LITERALS>indent</LITERALS>-<LITERALS>list</LITERALS>'} )
    {
        $<CODE>bli_list_string</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>brace</LITERALS>-<LITERALS>left</LITERALS>-<LITERALS>and</LITERALS>-<LITERALS>indent</LITERALS>-<LITERALS>list</LITERALS>'};
    }

    $<CODE>bli_pattern</CODE> = <CODE>make_block_pattern</CODE>( '-<LITERALS>blil</LITERALS>', $<CODE>bli_list_string</CODE> );
}

sub <CODE>make_block_brace_vertical_tightness_pattern</CODE> {

    # <COMMENTS>turn</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>regex</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>recognizing</COMMENTS> <COMMENTS>selected</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS>
    $<CODE>block_brace_vertical_tightness_pattern</CODE> =
      '^((<LITERALS>if</LITERALS>|<LITERALS>else</LITERALS>|<LITERALS>elsif</LITERALS>|<LITERALS>unless</LITERALS>|<LITERALS>while</LITERALS>|<LITERALS>for</LITERALS>|<LITERALS>foreach</LITERALS>|<LITERALS>do</LITERALS>|\<LITERALS>w</LITERALS>+:)<LITERALS>$</LITERALS>|<LITERALS>sub</LITERALS>)';
    if ( defined( $<CODE>rOpts</CODE>->{'<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>list</LITERALS>'} )
        && $<CODE>rOpts</CODE>->{'<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>list</LITERALS>'} )
    {
        $<CODE>block_brace_vertical_tightness_pattern</CODE> =
          <CODE>make_block_pattern</CODE>( '-<LITERALS>bbvtl</LITERALS>',
            $<CODE>rOpts</CODE>->{'<LITERALS>block</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>vertical</LITERALS>-<LITERALS>tightness</LITERALS>-<LITERALS>list</LITERALS>'} );
    }
}

sub <CODE>make_block_pattern</CODE> {

    #  <COMMENTS>given</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>block</COMMENTS>-<COMMENTS>type</COMMENTS> <COMMENTS>keywords</COMMENTS>, <COMMENTS>return</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>regex</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>them</COMMENTS>
    #  <COMMENTS>The</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>tricky</COMMENTS> <COMMENTS>part</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>labels</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>indicated</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> ':'
    #  <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>sub</COMMENTS>' <COMMENTS>token</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>additional</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>it</COMMENTS> (<COMMENTS>name</COMMENTS> <COMMENTS>of</COMMENTS>
    #  <COMMENTS>sub</COMMENTS>).
    #
    #  <COMMENTS>Example</COMMENTS>:
    #
    #   <COMMENTS>input</COMMENTS> <COMMENTS>string</COMMENTS>: "<COMMENTS>if</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>elsif</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>while</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>foreach</COMMENTS> <COMMENTS>do</COMMENTS> : <COMMENTS>sub</COMMENTS>";
    #   <COMMENTS>pattern</COMMENTS>:  '^((<COMMENTS>if</COMMENTS>|<COMMENTS>else</COMMENTS>|<COMMENTS>elsif</COMMENTS>|<COMMENTS>unless</COMMENTS>|<COMMENTS>while</COMMENTS>|<COMMENTS>for</COMMENTS>|<COMMENTS>foreach</COMMENTS>|<COMMENTS>do</COMMENTS>|\<COMMENTS>w</COMMENTS>+:)<COMMENTS>$</COMMENTS>|<COMMENTS>sub</COMMENTS>)';

    my ( $<CODE>abbrev</CODE>, $<CODE>string</CODE> ) = @<CODE>_</CODE>;
    my @<CODE>list</CODE>  = <CODE>split_words</CODE>($<CODE>string</CODE>);
    my @<CODE>words</CODE> = ();
    my %<CODE>seen</CODE>;
    for my $<CODE>i</CODE> (@<CODE>list</CODE>) {
        if ( $<CODE>i</CODE> eq '*' ) { my $<CODE>pattern</CODE> = '^.*'; return $<CODE>pattern</CODE> }
        next if $<CODE>seen</CODE>{$<CODE>i</CODE>};
        $<CODE>seen</CODE>{$<CODE>i</CODE>} = 1;
        if ( $<CODE>i</CODE> eq '<LITERALS>sub</LITERALS>' ) {
        }
        elsif ( $<CODE>i</CODE> eq ';' ) {
            push @<CODE>words</CODE>, ';';
        }
        elsif ( $<CODE>i</CODE> eq '{' ) {
            push @<CODE>words</CODE>, '\{';
        }
        elsif ( $<CODE>i</CODE> eq ':' ) {
            push @<CODE>words</CODE>, '\<LITERALS>w</LITERALS>+:';
        }
        elsif ( $<CODE>i</CODE> =~ /^\w/ ) {
            push @<CODE>words</CODE>, $<CODE>i</CODE>;
        }
        else {
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE>
              "<LITERALS>unrecognized</LITERALS> <LITERALS>block</LITERALS> <LITERALS>type</LITERALS> $<CODE>i</CODE> <LITERALS>after</LITERALS> $<CODE>abbrev</CODE>, <LITERALS>ignoring</LITERALS>\n";
        }
    }
    my $<CODE>pattern</CODE> = '(' . join( '|', @<CODE>words</CODE> ) . ')<LITERALS>$</LITERALS>';
    if ( $<CODE>seen</CODE>{'<LITERALS>sub</LITERALS>'} ) {
        $<CODE>pattern</CODE> = '(' . $<CODE>pattern</CODE> . '|<LITERALS>sub</LITERALS>)';
    }
    $<CODE>pattern</CODE> = '^' . $<CODE>pattern</CODE>;
    return $<CODE>pattern</CODE>;
}

sub <CODE>make_static_side_comment_pattern</CODE> {

    # <COMMENTS>create</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>identify</COMMENTS> <COMMENTS>static</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>
    $<CODE>static_side_comment_pattern</CODE> = '^##';

    # <COMMENTS>allow</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>it</COMMENTS>
    if ( $<CODE>rOpts</CODE>->{'<LITERALS>static</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>prefix</LITERALS>'} ) {
        my $<CODE>prefix</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>static</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>prefix</LITERALS>'};
        $<CODE>prefix</CODE> =~ s/^\s*//;
        my $<CODE>pattern</CODE> = '^' . $<CODE>prefix</CODE>;
        eval "'##'=~/$<CODE>pattern</CODE>/";
        if ($@) {
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE>
"<LITERALS>ERROR</LITERALS>: <LITERALS>the</LITERALS> -<LITERALS>sscp</LITERALS> <LITERALS>prefix</LITERALS> '$<CODE>prefix</CODE>' <LITERALS>causes</LITERALS> <LITERALS>the</LITERALS> <LITERALS>invalid</LITERALS> <LITERALS>regex</LITERALS> '$<CODE>pattern</CODE>'\n";
        }
        $<CODE>static_side_comment_pattern</CODE> = $<CODE>pattern</CODE>;
    }
}

sub <CODE>make_closing_side_comment_prefix</CODE> {

    # <COMMENTS>Be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>prefix</COMMENTS>
    my $<CODE>csc_prefix</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>prefix</LITERALS>'};
    my $<CODE>csc_prefix_pattern</CODE>;
    if ( !defined($<CODE>csc_prefix</CODE>) ) {
        $<CODE>csc_prefix</CODE>         = '## <LITERALS>end</LITERALS>';
        $<CODE>csc_prefix_pattern</CODE> = '^##\<LITERALS>s</LITERALS>+<LITERALS>end</LITERALS>';
    }
    else {
        my $<CODE>test_csc_prefix</CODE> = $<CODE>csc_prefix</CODE>;
        if ( $<CODE>test_csc_prefix</CODE> !~ /^#/ ) {
            $<CODE>test_csc_prefix</CODE> = '#' . $<CODE>test_csc_prefix</CODE>;
        }

        # <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>regex</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>recognize</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>prefix</COMMENTS>
        my $<CODE>test_csc_prefix_pattern</CODE> = $<CODE>test_csc_prefix</CODE>;

        # <COMMENTS>escape</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>characters</COMMENTS>
        $<CODE>test_csc_prefix_pattern</CODE> =~ s/([^#\s\w])/\\$<CODE>1</CODE>/g;

        $<CODE>test_csc_prefix_pattern</CODE> = '^' . $<CODE>test_csc_prefix_pattern</CODE>;

        # <COMMENTS>allow</COMMENTS> <COMMENTS>exact</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>intermediate</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>vary</COMMENTS>
        $<CODE>test_csc_prefix_pattern</CODE> =~ s/\s+/\\<LITERALS>s</LITERALS>\+/g;

        # <COMMENTS>make</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>pattern</COMMENTS>
        # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>fail</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>escaping</COMMENTS>
        # <COMMENTS>characters</COMMENTS>.
        eval "'##'=~/$<CODE>test_csc_prefix_pattern</CODE>/";
        if ($@) {

            # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>..<COMMENTS>must</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>screwed</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>escaping</COMMENTS>, <COMMENTS>above</COMMENTS>
            <CODE>report_definite_bug</CODE>();
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE>
"<LITERALS>Program</LITERALS> <LITERALS>Error</LITERALS>: <LITERALS>the</LITERALS> -<LITERALS>cscp</LITERALS> <LITERALS>prefix</LITERALS> '$<CODE>csc_prefix</CODE>' <LITERALS>caused</LITERALS> <LITERALS>the</LITERALS> <LITERALS>invalid</LITERALS> <LITERALS>regex</LITERALS> '$<CODE>csc_prefix_pattern</CODE>'\n";

            # <COMMENTS>just</COMMENTS> <COMMENTS>warn</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>going</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>defaults</COMMENTS>
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE> "<LITERALS>Please</LITERALS> <LITERALS>consider</LITERALS> <LITERALS>using</LITERALS> <LITERALS>a</LITERALS> <LITERALS>simpler</LITERALS> -<LITERALS>cscp</LITERALS> <LITERALS>prefix</LITERALS>\n";
            <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE>
              "<LITERALS>Using</LITERALS> <LITERALS>default</LITERALS> -<LITERALS>cscp</LITERALS> <LITERALS>instead</LITERALS>; <LITERALS>please</LITERALS> <LITERALS>check</LITERALS> <LITERALS>output</LITERALS>\n";
        }
        else {
            $<CODE>csc_prefix</CODE>         = $<CODE>test_csc_prefix</CODE>;
            $<CODE>csc_prefix_pattern</CODE> = $<CODE>test_csc_prefix_pattern</CODE>;
        }
    }
    $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>prefix</LITERALS>'} = $<CODE>csc_prefix</CODE>;
    $<CODE>closing_side_comment_prefix_pattern</CODE> = $<CODE>csc_prefix_pattern</CODE>;
}

sub <CODE>dump_want_left_space</CODE> {
    my $<CODE>fh</CODE> = shift;
    local $" = "\n";
    print $<CODE>fh</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>These</LITERALS> <LITERALS>values</LITERALS> <LITERALS>are</LITERALS> <LITERALS>the</LITERALS> <LITERALS>main</LITERALS> <LITERALS>control</LITERALS> <LITERALS>of</LITERALS> <LITERALS>whitespace</LITERALS> <LITERALS>to</LITERALS> <LITERALS>the</LITERALS> <LITERALS>left</LITERALS> <LITERALS>of</LITERALS> <LITERALS>a</LITERALS> <LITERALS>token</LITERALS> <LITERALS>type</LITERALS>;
<LITERALS>They</LITERALS> <LITERALS>may</LITERALS> <LITERALS>be</LITERALS> <LITERALS>altered</LITERALS> <LITERALS>with</LITERALS> <LITERALS>the</LITERALS> -<LITERALS>wls</LITERALS> <LITERALS>parameter</LITERALS>.
<LITERALS>For</LITERALS> <LITERALS>a</LITERALS> <LITERALS>list</LITERALS> <LITERALS>of</LITERALS> <LITERALS>token</LITERALS> <LITERALS>types</LITERALS>, <LITERALS>use</LITERALS> <LITERALS>perltidy</LITERALS> --<LITERALS>dump</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>types</LITERALS> (-<LITERALS>dtt</LITERALS>)
 <LITERALS>1</LITERALS> <LITERALS>means</LITERALS> <LITERALS>the</LITERALS> <LITERALS>token</LITERALS> <LITERALS>wants</LITERALS> <LITERALS>a</LITERALS> <LITERALS>space</LITERALS> <LITERALS>to</LITERALS> <LITERALS>its</LITERALS> <LITERALS>left</LITERALS>
-<LITERALS>1</LITERALS> <LITERALS>means</LITERALS> <LITERALS>the</LITERALS> <LITERALS>token</LITERALS> <LITERALS>does</LITERALS> <LITERALS>not</LITERALS> <LITERALS>want</LITERALS> <LITERALS>a</LITERALS> <LITERALS>space</LITERALS> <LITERALS>to</LITERALS> <LITERALS>its</LITERALS> <LITERALS>left</LITERALS>
------------------------------------------------------------------------
<CODE>EOM</CODE>
    foreach ( sort keys %<CODE>want_left_space</CODE> ) {
        print $<CODE>fh</CODE> "$<CODE>_</CODE>\t$<CODE>want_left_space</CODE>{$<CODE>_</CODE>}\n";
    }
}

sub <CODE>dump_want_right_space</CODE> {
    my $<CODE>fh</CODE> = shift;
    local $" = "\n";
    print $<CODE>fh</CODE> <<<LITERALS>EOM</LITERALS>;
<LITERALS>These</LITERALS> <LITERALS>values</LITERALS> <LITERALS>are</LITERALS> <LITERALS>the</LITERALS> <LITERALS>main</LITERALS> <LITERALS>control</LITERALS> <LITERALS>of</LITERALS> <LITERALS>whitespace</LITERALS> <LITERALS>to</LITERALS> <LITERALS>the</LITERALS> <LITERALS>right</LITERALS> <LITERALS>of</LITERALS> <LITERALS>a</LITERALS> <LITERALS>token</LITERALS> <LITERALS>type</LITERALS>;
<LITERALS>They</LITERALS> <LITERALS>may</LITERALS> <LITERALS>be</LITERALS> <LITERALS>altered</LITERALS> <LITERALS>with</LITERALS> <LITERALS>the</LITERALS> -<LITERALS>wrs</LITERALS> <LITERALS>parameter</LITERALS>.
<LITERALS>For</LITERALS> <LITERALS>a</LITERALS> <LITERALS>list</LITERALS> <LITERALS>of</LITERALS> <LITERALS>token</LITERALS> <LITERALS>types</LITERALS>, <LITERALS>use</LITERALS> <LITERALS>perltidy</LITERALS> --<LITERALS>dump</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>types</LITERALS> (-<LITERALS>dtt</LITERALS>)
 <LITERALS>1</LITERALS> <LITERALS>means</LITERALS> <LITERALS>the</LITERALS> <LITERALS>token</LITERALS> <LITERALS>wants</LITERALS> <LITERALS>a</LITERALS> <LITERALS>space</LITERALS> <LITERALS>to</LITERALS> <LITERALS>its</LITERALS> <LITERALS>right</LITERALS>
-<LITERALS>1</LITERALS> <LITERALS>means</LITERALS> <LITERALS>the</LITERALS> <LITERALS>token</LITERALS> <LITERALS>does</LITERALS> <LITERALS>not</LITERALS> <LITERALS>want</LITERALS> <LITERALS>a</LITERALS> <LITERALS>space</LITERALS> <LITERALS>to</LITERALS> <LITERALS>its</LITERALS> <LITERALS>right</LITERALS>
------------------------------------------------------------------------
<CODE>EOM</CODE>
    foreach ( sort keys %<CODE>want_right_space</CODE> ) {
        print $<CODE>fh</CODE> "$<CODE>_</CODE>\t$<CODE>want_right_space</CODE>{$<CODE>_</CODE>}\n";
    }
}

{    # <COMMENTS>begin</COMMENTS> <COMMENTS>is_essential_whitespace</COMMENTS>

    my %<CODE>is_sort_grep_map</CODE>;
    my %<CODE>is_for_foreach</CODE>;

    <CODE>BEGIN</CODE> {

        @<CODE>_</CODE> = qw(<LITERALS>sort</LITERALS> <LITERALS>grep</LITERALS> <LITERALS>map</LITERALS>);
        @<CODE>is_sort_grep_map</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

        @<CODE>_</CODE> = qw(<LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS>);
        @<CODE>is_for_foreach</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    }

    sub <CODE>is_essential_whitespace</CODE> {

        # <COMMENTS>Essential</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>means</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>cannot</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>safely</COMMENTS> <COMMENTS>deleted</COMMENTS>
        # <COMMENTS>without</COMMENTS> <COMMENTS>risking</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>introduction</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>error</COMMENTS>.
        # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>three</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>types</COMMENTS>:
        # (<COMMENTS>$tokenl</COMMENTS>, <COMMENTS>$typel</COMMENTS>) <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>question</COMMENTS>
        # (<COMMENTS>$tokenr</COMMENTS>, <COMMENTS>$typer</COMMENTS>) <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>question</COMMENTS>
        # (<COMMENTS>$tokenll</COMMENTS>, <COMMENTS>$typell</COMMENTS>) <COMMENTS>is</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>$tokenl</COMMENTS>
        #
        # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>slow</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>often</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>when</COMMENTS> -<COMMENTS>mangle</COMMENTS>
        # <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>.
        #
        # <COMMENTS>Note</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>almost</COMMENTS> <COMMENTS>never</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>changed</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS>
        # <COMMENTS>for</COMMENTS> <COMMENTS>avoiding</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>rather</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>formatting</COMMENTS>.
        my ( $<CODE>tokenll</CODE>, $<CODE>typell</CODE>, $<CODE>tokenl</CODE>, $<CODE>typel</CODE>, $<CODE>tokenr</CODE>, $<CODE>typer</CODE> ) = @<CODE>_</CODE>;

        my $<CODE>result</CODE> =

          # <COMMENTS>never</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>words</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>numbers</COMMENTS>
          # <COMMENTS>examples</COMMENTS>:  <COMMENTS>and</COMMENTS> ::<COMMENTS>ok</COMMENTS>(<COMMENTS>1</COMMENTS>)
          #            <COMMENTS>return</COMMENTS> ::<COMMENTS>spw</COMMENTS>(...)
          #            <COMMENTS>for</COMMENTS> <COMMENTS>bla</COMMENTS>::<COMMENTS>bla</COMMENTS>:: <COMMENTS>abc</COMMENTS>
          # <COMMENTS>example</COMMENTS> <COMMENTS>is</COMMENTS> "%<COMMENTS>overload</COMMENTS>:: <COMMENTS>and</COMMENTS>" <COMMENTS>in</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>Dumpvalue</COMMENTS>.<COMMENTS>pm</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>colonbug</COMMENTS>.<COMMENTS>pl</COMMENTS>
          #            <COMMENTS>$input</COMMENTS> <COMMENTS>eq</COMMENTS>"<COMMENTS>quit</COMMENTS>" <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>$inputeq</COMMENTS>"<COMMENTS>quit</COMMENTS>"
          #            <COMMENTS>my</COMMENTS> <COMMENTS>$size</COMMENTS>=-<COMMENTS>s</COMMENTS>::<COMMENTS>SINK</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>$file</COMMENTS>;  <==<COMMENTS>OK</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>won</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>it</COMMENTS>
          # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS>: <COMMENTS>for</COMMENTS> <COMMENTS>bla</COMMENTS>::<COMMENTS>bla</COMMENTS>:: <COMMENTS>abc</COMMENTS>
          # <COMMENTS>example</COMMENTS> <COMMENTS>is</COMMENTS> "%<COMMENTS>overload</COMMENTS>:: <COMMENTS>and</COMMENTS>" <COMMENTS>in</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>Dumpvalue</COMMENTS>.<COMMENTS>pm</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>colonbug</COMMENTS>.<COMMENTS>pl</COMMENTS>
          (      ( $<CODE>tokenl</CODE> =~ /([\'\w]|\:\:)$/ && $<CODE>typel</CODE> ne '<LITERALS>CORE</LITERALS>::' )
              && ( $<CODE>tokenr</CODE> =~ /^([\'\w]|\:\:)/ ) )

          # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>concatenation</COMMENTS> <COMMENTS>dot</COMMENTS>
          # <COMMENTS>example</COMMENTS>: <COMMENTS>pom</COMMENTS>.<COMMENTS>caputo</COMMENTS>:
          # <COMMENTS>$vt100_compatible</COMMENTS> ? "\<COMMENTS>e</COMMENTS>[<COMMENTS>0</COMMENTS>;<COMMENTS>0H</COMMENTS>" : ('-' <COMMENTS>x</COMMENTS> <COMMENTS>78</COMMENTS> . "\<COMMENTS>n</COMMENTS>");
          || ( ( $<CODE>typel</CODE> eq '<LITERALS>n</LITERALS>' ) && ( $<CODE>tokenr</CODE> eq '.' ) )
          || ( ( $<CODE>typer</CODE> eq '<LITERALS>n</LITERALS>' ) && ( $<CODE>tokenl</CODE> eq '.' ) )

          # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>minus</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>form</COMMENTS>
          # <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>operator</COMMENTS>.  <COMMENTS>Example</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>Complex</COMMENTS>.<COMMENTS>pm</COMMENTS>:
          # <COMMENTS>if</COMMENTS> (<COMMENTS>CORE</COMMENTS>::<COMMENTS>abs</COMMENTS>(<COMMENTS>$z</COMMENTS> - <COMMENTS>i</COMMENTS>) < <COMMENTS>$eps</COMMENTS>); "<COMMENTS>z</COMMENTS>-<COMMENTS>i</COMMENTS>" <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>taken</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>test</COMMENTS>.
          || ( ( $<CODE>tokenl</CODE> eq '-' ) && ( $<CODE>tokenr</CODE> =~ /^[_A-Za-z]$/ ) )

          # <COMMENTS>and</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>become</COMMENTS> <COMMENTS>ambiguous</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>space</COMMENTS>
          # <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> '-':
          #   <COMMENTS>use</COMMENTS> <COMMENTS>constant</COMMENTS> <COMMENTS>III</COMMENTS>=><COMMENTS>1</COMMENTS>;
          #   <COMMENTS>$a</COMMENTS> = <COMMENTS>$b</COMMENTS> - <COMMENTS>III</COMMENTS>;
          # <COMMENTS>and</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>this</COMMENTS>:
          #   <COMMENTS>$a</COMMENTS> = - <COMMENTS>III</COMMENTS>;
          || ( ( $<CODE>tokenl</CODE> eq '-' )
            && ( $<CODE>typer</CODE> =~ /^[wC]$/ && $<CODE>tokenr</CODE> =~ /^[_A-Za-z]/ ) )

          # '= -' <COMMENTS>should</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>become</COMMENTS> =- <COMMENTS>or</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>warning</COMMENTS>
          # <COMMENTS>about</COMMENTS> <COMMENTS>reversed</COMMENTS> -=
          # || (<COMMENTS>$tokenr</COMMENTS> <COMMENTS>eq</COMMENTS> '-')

          # <COMMENTS>keep</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bareword</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>the</COMMENTS>
          # <COMMENTS>bareword</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>becoming</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>modifier</COMMENTS>.
          || ( ( $<CODE>typel</CODE> eq '<LITERALS>Q</LITERALS>' ) && ( $<CODE>tokenr</CODE> =~ /^[a-zA-Z_]/ ) )

          # <COMMENTS>keep</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS> '<COMMENTS>$</COMMENTS>' <COMMENTS>and</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>word</COMMENTS>;
          # <COMMENTS>this</COMMENTS> <COMMENTS>caused</COMMENTS> <COMMENTS>trouble</COMMENTS>:  "<COMMENTS>die</COMMENTS> @<COMMENTS>$</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>$</COMMENTS>@"
          || ( ( $<CODE>typel</CODE> eq '<LITERALS>i</LITERALS>' && $<CODE>tokenl</CODE> =~ /\$$/ )
            && ( $<CODE>tokenr</CODE> =~ /^[a-zA-Z_]/ ) )

          # <COMMENTS>perl</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>fussy</COMMENTS> <COMMENTS>about</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>before</COMMENTS> <<
          || ( $<CODE>tokenr</CODE> =~ /^\<\</ )

          # <COMMENTS>avoid</COMMENTS> <COMMENTS>combining</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>meanings</COMMENTS>. <COMMENTS>Example</COMMENTS>:
          #     <COMMENTS>$a</COMMENTS>+ +<COMMENTS>$b</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>become</COMMENTS> <COMMENTS>$a</COMMENTS>++<COMMENTS>$b</COMMENTS>
          || ( $<CODE>is_digraph</CODE>{ $<CODE>tokenl</CODE> . $<CODE>tokenr</CODE> } )
          || ( $<CODE>is_trigraph</CODE>{ $<CODE>tokenl</CODE> . $<CODE>tokenr</CODE> } )

          # <COMMENTS>another</COMMENTS> <COMMENTS>example</COMMENTS>: <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>two</COMMENTS> &'<COMMENTS>s</COMMENTS>:
          #     <COMMENTS>allow_options</COMMENTS> & &<COMMENTS>OPT_EXECCGI</COMMENTS>
          || ( $<CODE>is_digraph</CODE>{ $<CODE>tokenl</CODE> . substr( $<CODE>tokenr</CODE>, 0, 1 ) } )

          # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>$$</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>$</COMMENTS># <COMMENTS>with</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>alphanumeric</COMMENTS>
          # (<COMMENTS>testfile</COMMENTS> <COMMENTS>mangle</COMMENTS>.<COMMENTS>t</COMMENTS> <COMMENTS>with</COMMENTS> --<COMMENTS>mangle</COMMENTS>)
          || ( ( $<CODE>tokenl</CODE> =~ /^\$[\$\#]$/ ) && ( $<CODE>tokenr</CODE> =~ /^\w/ ) )

          # <COMMENTS>retain</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>filehandle</COMMENTS>
          # (<COMMENTS>testfiles</COMMENTS> <COMMENTS>prnterr1</COMMENTS>.<COMMENTS>t</COMMENTS> <COMMENTS>with</COMMENTS> --<COMMENTS>extrude</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>mangle</COMMENTS>.<COMMENTS>t</COMMENTS> <COMMENTS>with</COMMENTS> --<COMMENTS>mangle</COMMENTS>)
          || ( $<CODE>typel</CODE> eq '<LITERALS>Z</LITERALS>' )

          # <COMMENTS>Perl</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>sensitive</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> + <COMMENTS>here</COMMENTS>:
          #  <COMMENTS>$b</COMMENTS> = <COMMENTS>xvals</COMMENTS> <COMMENTS>$a</COMMENTS> + <COMMENTS>0</COMMENTS>.<COMMENTS>1</COMMENTS> * <COMMENTS>yvals</COMMENTS> <COMMENTS>$a</COMMENTS>;
          || ( $<CODE>typell</CODE> eq '<LITERALS>Z</LITERALS>' && $<CODE>typel</CODE> =~ /^[\/\?\+\-\*]$/ )

          # <COMMENTS>keep</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>in</COMMENTS> '<COMMENTS>use</COMMENTS> <COMMENTS>Foo</COMMENTS>::<COMMENTS>Bar</COMMENTS> ()'
          || ( $<CODE>tokenr</CODE> eq '('
            && $<CODE>typel</CODE> eq '<LITERALS>w</LITERALS>'
            && $<CODE>typell</CODE> eq '<LITERALS>k</LITERALS>'
            && $<CODE>tokenll</CODE> eq '<LITERALS>use</LITERALS>' )

          # <COMMENTS>keep</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>filehandle</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>paren</COMMENTS>:
          # <COMMENTS>file</COMMENTS> <COMMENTS>mangle</COMMENTS>.<COMMENTS>t</COMMENTS> <COMMENTS>with</COMMENTS> --<COMMENTS>mangle</COMMENTS>:
          || ( $<CODE>typel</CODE> eq '<LITERALS>Y</LITERALS>' && $<CODE>tokenr</CODE> eq '(' )

          # <COMMENTS>retain</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>doc</COMMENTS> <COMMENTS>operator</COMMENTS> ( <COMMENTS>hereerr</COMMENTS>.<COMMENTS>t</COMMENTS>)
          || ( $<CODE>typel</CODE> eq '<LITERALS>h</LITERALS>' )

          # <COMMENTS>be</COMMENTS> <COMMENTS>careful</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>around</COMMENTS> ++ <COMMENTS>and</COMMENTS> --, <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>ambiguity</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>to</COMMENTS>
          # <COMMENTS>which</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>applies</COMMENTS>
          || ( ( $<CODE>typer</CODE> =~ /^(pp|mm)$/ )     && ( $<CODE>tokenl</CODE> !~ /^[\;\{\(\[]/ ) )
          || ( ( $<CODE>typel</CODE> =~ /^(\+\+|\-\-)$/ ) && ( $<CODE>tokenr</CODE> !~ /^[\;\}\)\]]/ ) )

          # <COMMENTS>need</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>foreach</COMMENTS> <COMMENTS>my</COMMENTS>; <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>fail</COMMENTS> <COMMENTS>in</COMMENTS>
          # <COMMENTS>older</COMMENTS> <COMMENTS>versions</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>Perl</COMMENTS>:
          # <COMMENTS>foreach</COMMENTS> <COMMENTS>my$ft</COMMENTS>(@<COMMENTS>filetypes</COMMENTS>)...
          || (
            $<CODE>tokenl</CODE> eq '<LITERALS>my</LITERALS>'

            #  /^(<COMMENTS>for</COMMENTS>|<COMMENTS>foreach</COMMENTS>)<COMMENTS>$</COMMENTS>/
            && $<CODE>is_for_foreach</CODE>{$<CODE>tokenll</CODE>}
            && $<CODE>tokenr</CODE> =~ /^\$/
          )

          # <COMMENTS>must</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>grep</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>paren</COMMENTS>; "<COMMENTS>grep</COMMENTS>(" <COMMENTS>will</COMMENTS> <COMMENTS>fail</COMMENTS>
          || ( $<CODE>tokenr</CODE> eq '(' && $<CODE>is_sort_grep_map</CODE>{$<CODE>tokenl</CODE>} )

          # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>stick</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>parens</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS>:
          #<COMMENTS>use</COMMENTS> <COMMENTS>Mail</COMMENTS>::<COMMENTS>Internet</COMMENTS> <COMMENTS>1</COMMENTS>.<COMMENTS>28</COMMENTS> (); (<COMMENTS>see</COMMENTS> <COMMENTS>Entity</COMMENTS>.<COMMENTS>pm</COMMENTS>, <COMMENTS>Head</COMMENTS>.<COMMENTS>pm</COMMENTS>, <COMMENTS>Test</COMMENTS>.<COMMENTS>pm</COMMENTS>)
          || ( ( $<CODE>typel</CODE> eq '<LITERALS>n</LITERALS>' ) && ( $<CODE>tokenr</CODE> eq '(' ) )

          # <COMMENTS>We</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>a</COMMENTS> ? <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>string</COMMENTS>
          # <COMMENTS>remains</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> ? <COMMENTS>remains</COMMENTS>.  [<COMMENTS>Loca</COMMENTS>.<COMMENTS>pm</COMMENTS>, <COMMENTS>lockarea</COMMENTS>]
          # <COMMENTS>ie</COMMENTS>,
          #    <COMMENTS>$b</COMMENTS>=<COMMENTS>join</COMMENTS> <COMMENTS>$comma</COMMENTS> ? ',' : ':', @<COMMENTS>_</COMMENTS>;  # <COMMENTS>ok</COMMENTS>
          #    <COMMENTS>$b</COMMENTS>=<COMMENTS>join</COMMENTS> <COMMENTS>$comma</COMMENTS>?',' : ':', @<COMMENTS>_</COMMENTS>;    # <COMMENTS>ok</COMMENTS>!
          #    <COMMENTS>$b</COMMENTS>=<COMMENTS>join</COMMENTS> <COMMENTS>$comma</COMMENTS> ?',' : ':', @<COMMENTS>_</COMMENTS>;   # <COMMENTS>error</COMMENTS>!
          # <COMMENTS>Not</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>required</COMMENTS>:
          ## || ( ( <COMMENTS>$typel</COMMENTS> <COMMENTS>eq</COMMENTS> '?' ) && ( <COMMENTS>$typer</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>Q</COMMENTS>' ) )

          # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>an</COMMENTS> '&' <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>because</COMMENTS>
          # <COMMENTS>it</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>turn</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>evaluation</COMMENTS>, <COMMENTS>like</COMMENTS> <COMMENTS>here</COMMENTS>
          # <COMMENTS>between</COMMENTS> '&' <COMMENTS>and</COMMENTS> '<COMMENTS>O_ACCMODE</COMMENTS>', <COMMENTS>producing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>error</COMMENTS> [<COMMENTS>File</COMMENTS>.<COMMENTS>pm</COMMENTS>]
          #    <COMMENTS>$opts</COMMENTS>{<COMMENTS>rdonly</COMMENTS>} = ((<COMMENTS>$opts</COMMENTS>{<COMMENTS>mode</COMMENTS>} & <COMMENTS>O_ACCMODE</COMMENTS>) == <COMMENTS>O_RDONLY</COMMENTS>);
          || ( ( $<CODE>typel</CODE> eq '&' ) && ( $<CODE>tokenr</CODE> =~ /^[a-zA-Z_]/ ) )

          # <COMMENTS>space</COMMENTS> <COMMENTS>stacked</COMMENTS> <COMMENTS>labels</COMMENTS>  (<COMMENTS>TODO</COMMENTS>: <COMMENTS>check</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>necessary</COMMENTS>)
          || ( $<CODE>typel</CODE> eq '<LITERALS>J</LITERALS>' && $<CODE>typer</CODE> eq '<LITERALS>J</LITERALS>' )

          ;    # <COMMENTS>the</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>result</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS>
        return $<CODE>result</CODE>;
    }
}

{
    my %<CODE>secret_operators</CODE>;
    my %<CODE>is_leading_secret_token</CODE>;

    <CODE>BEGIN</CODE> {

        # <COMMENTS>token</COMMENTS> <COMMENTS>lists</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>secret</COMMENTS> <COMMENTS>operators</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>compiled</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>Philippe</COMMENTS> <COMMENTS>Bruhat</COMMENTS>
        # <COMMENTS>at</COMMENTS>: <COMMENTS>https</COMMENTS>://<COMMENTS>metacpan</COMMENTS>.<COMMENTS>org</COMMENTS>/<COMMENTS>module</COMMENTS>/<COMMENTS>perlsecret</COMMENTS>
        %<CODE>secret_operators</CODE> = (
            '<LITERALS>Goatse</LITERALS>'            => [qw#= ( ) =#],        #=( )=
            '<LITERALS>Venus1</LITERALS>'            => [qw#<LITERALS>0</LITERALS> +#],            # <COMMENTS>0</COMMENTS>+
            '<LITERALS>Venus2</LITERALS>'            => [qw#+ <LITERALS>0</LITERALS>#],            # +<COMMENTS>0</COMMENTS>
            '<LITERALS>Enterprise</LITERALS>'        => [qw#) <LITERALS>x</LITERALS> ! !#],        # ()<COMMENTS>x</COMMENTS>!!
            '<LITERALS>Kite1</LITERALS>'             => [qw#~ ~ <>#],         # ~~<>
            '<LITERALS>Kite2</LITERALS>'             => [qw#~~ <>#],          # ~~<>
            '<LITERALS>Winking</LITERALS> <LITERALS>Fat</LITERALS> <LITERALS>Comma</LITERALS>' => [ ( ',', '=>' ) ],    # ,=>
        );

        # <COMMENTS>The</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>operators</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>constants</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>included</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>they</COMMENTS>
        # <COMMENTS>are</COMMENTS> <COMMENTS>normally</COMMENTS> <COMMENTS>kept</COMMENTS> <COMMENTS>tight</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>perltidy</COMMENTS>:
        # !!  ~~ <~>
        #

        # <COMMENTS>Make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>lookup</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>indexed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>operator</COMMENTS>:
        # <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> => [<COMMENTS>list</COMMENTS>, <COMMENTS>list</COMMENTS>, ...]
        foreach my $<CODE>value</CODE> ( values(%<CODE>secret_operators</CODE>) ) {
            my $<CODE>tok</CODE> = $<CODE>value</CODE>->[0];
            push @{ $<CODE>is_leading_secret_token</CODE>{$<CODE>tok</CODE>} }, $<CODE>value</CODE>;
        }
    }

    sub <CODE>secret_operator_whitespace</CODE> {

        my ( $<CODE>jmax</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>, $<CODE>rwhite_space_flag</CODE> ) = @<CODE>_</CODE>;

        # <COMMENTS>Loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
        my ( $<CODE>j</CODE>, $<CODE>token</CODE>, $<CODE>type</CODE> );
        for ( $<CODE>j</CODE> = 0 ; $<CODE>j</CODE> <= $<CODE>jmax</CODE> ; $<CODE>j</CODE>++ ) {

            $<CODE>token</CODE> = $$<CODE>rtokens</CODE>[$<CODE>j</CODE>];
            $<CODE>type</CODE>  = $$<CODE>rtoken_type</CODE>[$<CODE>j</CODE>];

            # <COMMENTS>Skip</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>secret</COMMENTS> <COMMENTS>operator</COMMENTS>
            next if ( $<CODE>type</CODE> eq '<LITERALS>b</LITERALS>' );
            next unless ( $<CODE>is_leading_secret_token</CODE>{$<CODE>token</CODE>} );

            #      <COMMENTS>Loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>secret</COMMENTS> <COMMENTS>operators</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>token</COMMENTS>
            foreach my $<CODE>rpattern</CODE> ( @{ $<CODE>is_leading_secret_token</CODE>{$<CODE>token</CODE>} } ) {
                my $<CODE>jend</CODE> = $<CODE>j</CODE> - 1;
                foreach my $<CODE>tok</CODE> ( @{$<CODE>rpattern</CODE>} ) {
                    $<CODE>jend</CODE>++;
                    $<CODE>jend</CODE>++

                      if ( $<CODE>jend</CODE> <= $<CODE>jmax</CODE> && $$<CODE>rtoken_type</CODE>[$<CODE>jend</CODE>] eq '<LITERALS>b</LITERALS>' );
                    if ( $<CODE>jend</CODE> > $<CODE>jmax</CODE> || $<CODE>tok</CODE> ne $$<CODE>rtokens</CODE>[$<CODE>jend</CODE>] ) {
                        $<CODE>jend</CODE> = undef;
                        last;
                    }
                }

                if ($<CODE>jend</CODE>) {

                    # <COMMENTS>set</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>operator</COMMENTS>
                    for ( my $<CODE>jj</CODE> = $<CODE>j</CODE> + 1 ; $<CODE>jj</CODE> <= $<CODE>jend</CODE> ; $<CODE>jj</CODE>++ ) {
                        $<CODE>rwhite_space_flag</CODE>->[$<CODE>jj</CODE>] = <CODE>WS_NO</CODE>;
                    }
                    $<CODE>j</CODE> = $<CODE>jend</CODE>;
                    last;
                }
            }    ##      <COMMENTS>End</COMMENTS> <COMMENTS>Loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>operators</COMMENTS>
        }    ## <COMMENTS>End</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS>
    }    # <COMMENTS>End</COMMENTS> <COMMENTS>sub</COMMENTS>
}

sub <CODE>set_white_space_flag</CODE> {

    #    <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>examines</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>pair</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS>
    #    <COMMENTS>sets</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>array</COMMENTS> @<COMMENTS>white_space_flag</COMMENTS>.
    #
    #    <COMMENTS>$white_space_flag</COMMENTS>[<COMMENTS>$j</COMMENTS>] <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>indicating</COMMENTS> <COMMENTS>whether</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>white</COMMENTS> <COMMENTS>space</COMMENTS>
    #    <COMMENTS>BEFORE</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>$j</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>needed</COMMENTS>, <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>values</COMMENTS>:
    #
    #             <COMMENTS>WS_NO</COMMENTS>      = -<COMMENTS>1</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>$j</COMMENTS>
    #             <COMMENTS>WS_OPTIONAL</COMMENTS>=  <COMMENTS>0</COMMENTS> <COMMENTS>optional</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>$j</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>whitespace</COMMENTS>
    #             <COMMENTS>WS_YES</COMMENTS>     =  <COMMENTS>1</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>$j</COMMENTS>
    #
    #
    #   <COMMENTS>The</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>based</COMMENTS>
    #   <COMMENTS>upon</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> "<COMMENTS>to_go</COMMENTS>" <COMMENTS>output</COMMENTS> <COMMENTS>array</COMMENTS>.
    #
    #   <COMMENTS>Note</COMMENTS>: <COMMENTS>retain</COMMENTS> <COMMENTS>debug</COMMENTS> <COMMENTS>print</COMMENTS> <COMMENTS>statements</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>usually</COMMENTS>
    #   <COMMENTS>required</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>.

    <CODE>BEGIN</CODE> {

        # <COMMENTS>initialize</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>global</COMMENTS> <COMMENTS>hashes</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>control</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>of</COMMENTS>
        # <COMMENTS>whitespace</COMMENTS> <COMMENTS>around</COMMENTS> <COMMENTS>tokens</COMMENTS>:
        #
        # %<COMMENTS>binary_ws_rules</COMMENTS>
        # %<COMMENTS>want_left_space</COMMENTS>
        # %<COMMENTS>want_right_space</COMMENTS>
        # %<COMMENTS>space_after_keyword</COMMENTS>
        #
        # <COMMENTS>Many</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>identical</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>themselves</COMMENTS>.
        # <COMMENTS>See</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>complete</COMMENTS> <COMMENTS>list</COMMENTS>. <COMMENTS>Here</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>types</COMMENTS>:
        #   <COMMENTS>k</COMMENTS> = <COMMENTS>perl</COMMENTS> <COMMENTS>keyword</COMMENTS>
        #   <COMMENTS>f</COMMENTS> = <COMMENTS>semicolon</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>statement</COMMENTS>
        #   <COMMENTS>m</COMMENTS> = <COMMENTS>unary</COMMENTS> <COMMENTS>minus</COMMENTS>
        #   <COMMENTS>p</COMMENTS> = <COMMENTS>unary</COMMENTS> <COMMENTS>plus</COMMENTS>
        # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> :: <COMMENTS>is</COMMENTS> <COMMENTS>excluded</COMMENTS> <COMMENTS>since</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>contained</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>identifier</COMMENTS>
        # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> '->' <COMMENTS>is</COMMENTS> <COMMENTS>excluded</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>never</COMMENTS> <COMMENTS>gets</COMMENTS> <COMMENTS>space</COMMENTS>
        # <COMMENTS>parentheses</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>brackets</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>excluded</COMMENTS> <COMMENTS>since</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>specially</COMMENTS>
        # <COMMENTS>curly</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>included</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>overridden</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>logic</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS>
        # <COMMENTS>newline</COMMENTS> <COMMENTS>logic</COMMENTS>.

        # <COMMENTS>NEW_TOKENS</COMMENTS>: <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>here</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>as</COMMENTS>
        # <COMMENTS>simple</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>your</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>letter</COMMENTS> <COMMENTS>to</COMMENTS> @<COMMENTS>spaces_both_sides</COMMENTS>, <COMMENTS>for</COMMENTS>
        # <COMMENTS>example</COMMENTS>.

        @<CODE>_</CODE> = qw" <LITERALS>L</LITERALS> { ( [ ";
        @<CODE>is_opening_type</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

        @<CODE>_</CODE> = qw" <LITERALS>R</LITERALS> } ) ] ";
        @<CODE>is_closing_type</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

        my @<CODE>spaces_both_sides</CODE> = qw"
          + - * / % ? = . : <LITERALS>x</LITERALS> < > | & ^ .. << >> ** && .. || // => += -=
          .= %= <LITERALS>x</LITERALS>= &= |= ^= *= <> <= >= == =~ !~ /= != ... <<= >>= ~~ !~~
          &&= ||= //= <=> <LITERALS>A</LITERALS> <LITERALS>k</LITERALS> <LITERALS>f</LITERALS> <LITERALS>w</LITERALS> <LITERALS>F</LITERALS> <LITERALS>n</LITERALS> <LITERALS>C</LITERALS> <LITERALS>Y</LITERALS> <LITERALS>U</LITERALS> <LITERALS>G</LITERALS> <LITERALS>v</LITERALS>
          ";

        my @<CODE>spaces_left_side</CODE> = qw"
          <LITERALS>t</LITERALS> ! ~ <LITERALS>m</LITERALS> <LITERALS>p</LITERALS> { \ <LITERALS>h</LITERALS> <LITERALS>pp</LITERALS> <LITERALS>mm</LITERALS> <LITERALS>Z</LITERALS> <LITERALS>j</LITERALS>
          ";
        push( @<CODE>spaces_left_side</CODE>, '#' );    # <COMMENTS>avoids</COMMENTS> <COMMENTS>warning</COMMENTS> <COMMENTS>message</COMMENTS>

        my @<CODE>spaces_right_side</CODE> = qw"
          ; } ) ] <LITERALS>R</LITERALS> <LITERALS>J</LITERALS> ++ -- **=
          ";
        push( @<CODE>spaces_right_side</CODE>, ',' );    # <COMMENTS>avoids</COMMENTS> <COMMENTS>warning</COMMENTS> <COMMENTS>message</COMMENTS>

        # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>BEGIN</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>here</COMMENTS>.  <COMMENTS>Later</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>processing</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>of</COMMENTS> %<COMMENTS>want_left_space</COMMENTS> <COMMENTS>and</COMMENTS>  %<COMMENTS>want_right_space</COMMENTS>
        # <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>overridden</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>settings</COMMENTS> <COMMENTS>specified</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS>
        # -<COMMENTS>wls</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>wrs</COMMENTS> <COMMENTS>parameters</COMMENTS>.  <COMMENTS>However</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>binary_whitespace_rules</COMMENTS>
        # <COMMENTS>are</COMMENTS> <COMMENTS>hardwired</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>priority</COMMENTS>.
        @<CODE>want_left_space</CODE>{@<CODE>spaces_both_sides</CODE>} = (1) x scalar(@<CODE>spaces_both_sides</CODE>);
        @<CODE>want_right_space</CODE>{@<CODE>spaces_both_sides</CODE>} =
          (1) x scalar(@<CODE>spaces_both_sides</CODE>);
        @<CODE>want_left_space</CODE>{@<CODE>spaces_left_side</CODE>}  = (1) x scalar(@<CODE>spaces_left_side</CODE>);
        @<CODE>want_right_space</CODE>{@<CODE>spaces_left_side</CODE>} = (-1) x scalar(@<CODE>spaces_left_side</CODE>);
        @<CODE>want_left_space</CODE>{@<CODE>spaces_right_side</CODE>} =
          (-1) x scalar(@<CODE>spaces_right_side</CODE>);
        @<CODE>want_right_space</CODE>{@<CODE>spaces_right_side</CODE>} =
          (1) x scalar(@<CODE>spaces_right_side</CODE>);
        $<CODE>want_left_space</CODE>{'->'}      = <CODE>WS_NO</CODE>;
        $<CODE>want_right_space</CODE>{'->'}     = <CODE>WS_NO</CODE>;
        $<CODE>want_left_space</CODE>{'**'}      = <CODE>WS_NO</CODE>;
        $<CODE>want_right_space</CODE>{'**'}     = <CODE>WS_NO</CODE>;
        $<CODE>want_right_space</CODE>{'<LITERALS>CORE</LITERALS>::'} = <CODE>WS_NO</CODE>;

        # <COMMENTS>These</COMMENTS> <COMMENTS>binary_ws_rules</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>hardwired</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>priority</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS>
        # <COMMENTS>settings</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>nice</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>adjustment</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS>,
        # <COMMENTS>but</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>complicated</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>specify</COMMENTS>.
        #
        # <COMMENTS>hash</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>information</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>stay</COMMENTS> <COMMENTS>tightly</COMMENTS> <COMMENTS>bound</COMMENTS>
        # <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS> :  <COMMENTS>$</COMMENTS>{<COMMENTS>xxxx</COMMENTS>}
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>i</LITERALS>'}{'<LITERALS>L</LITERALS>'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>i</LITERALS>'}{'{'} = <CODE>WS_YES</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>k</LITERALS>'}{'{'} = <CODE>WS_YES</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>U</LITERALS>'}{'{'} = <CODE>WS_YES</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>i</LITERALS>'}{'['} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>R</LITERALS>'}{'<LITERALS>L</LITERALS>'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>R</LITERALS>'}{'{'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>t</LITERALS>'}{'<LITERALS>L</LITERALS>'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>t</LITERALS>'}{'{'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'}'}{'<LITERALS>L</LITERALS>'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'}'}{'{'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>$</LITERALS>'}{'<LITERALS>L</LITERALS>'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>$</LITERALS>'}{'{'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'@'}{'<LITERALS>L</LITERALS>'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'@'}{'{'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'='}{'<LITERALS>L</LITERALS>'} = <CODE>WS_YES</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>J</LITERALS>'}{'<LITERALS>J</LITERALS>'} = <CODE>WS_YES</CODE>;

        # <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>includes</COMMENTS> ') {'
        # <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS> :    <COMMENTS>if</COMMENTS> ( <COMMENTS>xxx</COMMENTS> ) { <COMMENTS>yyy</COMMENTS> }
        $<CODE>binary_ws_rules</CODE>{']'}{'<LITERALS>L</LITERALS>'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{']'}{'{'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{')'}{'{'} = <CODE>WS_YES</CODE>;
        $<CODE>binary_ws_rules</CODE>{')'}{'['} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{']'}{'['} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{']'}{'{'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'}'}{'['} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>R</LITERALS>'}{'['} = <CODE>WS_NO</CODE>;

        $<CODE>binary_ws_rules</CODE>{']'}{'++'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{']'}{'--'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{')'}{'++'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{')'}{'--'} = <CODE>WS_NO</CODE>;

        $<CODE>binary_ws_rules</CODE>{'<LITERALS>R</LITERALS>'}{'++'} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>R</LITERALS>'}{'--'} = <CODE>WS_NO</CODE>;

        $<CODE>binary_ws_rules</CODE>{'<LITERALS>i</LITERALS>'}{'<LITERALS>Q</LITERALS>'} = <CODE>WS_YES</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>n</LITERALS>'}{'('} = <CODE>WS_YES</CODE>;    # <COMMENTS>occurs</COMMENTS> <COMMENTS>in</COMMENTS> '<COMMENTS>use</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>n</COMMENTS> ()'

        # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>we</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>split</COMMENTS> '<COMMENTS>i</COMMENTS>' <COMMENTS>into</COMMENTS> <COMMENTS>variables</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>functions</COMMENTS>
        # <COMMENTS>and</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>functions</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>variables</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>now</COMMENTS>,
        # <COMMENTS>I</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>below</COMMENTS>
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>i</LITERALS>'}{'('} = <CODE>WS_NO</CODE>;

        $<CODE>binary_ws_rules</CODE>{'<LITERALS>w</LITERALS>'}{'('} = <CODE>WS_NO</CODE>;
        $<CODE>binary_ws_rules</CODE>{'<LITERALS>w</LITERALS>'}{'{'} = <CODE>WS_YES</CODE>;
    } ## <COMMENTS>end</COMMENTS> <COMMENTS>BEGIN</COMMENTS> <COMMENTS>block</COMMENTS>

    my ( $<CODE>jmax</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>, $<CODE>rblock_type</CODE> ) = @<CODE>_</CODE>;
    my ( $<CODE>last_token</CODE>, $<CODE>last_type</CODE>, $<CODE>last_block_type</CODE>, $<CODE>token</CODE>, $<CODE>type</CODE>,
        $<CODE>block_type</CODE> );
    my (@<CODE>white_space_flag</CODE>);
    my $<CODE>j_tight_closing_paren</CODE> = -1;

    if ( $<CODE>max_index_to_go</CODE> >= 0 ) {
        $<CODE>token</CODE>      = $<CODE>tokens_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
        $<CODE>type</CODE>       = $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
        $<CODE>block_type</CODE> = $<CODE>block_type_to_go</CODE>[$<CODE>max_index_to_go</CODE>];

        #---------------------------------------------------------------
        # <COMMENTS>Patch</COMMENTS> <COMMENTS>due</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>splitting</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> ->
        #---------------------------------------------------------------
        #
        # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>dealing</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>raw</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS>,
        # <COMMENTS>but</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>started</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>needs</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>will</COMMENTS>
        # <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>stored</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>_to_go</COMMENTS>' <COMMENTS>arrays</COMMENTS>.
        #
        # <COMMENTS>This</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>avoids</COMMENTS> <COMMENTS>requiring</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>iterations</COMMENTS> <COMMENTS>to</COMMENTS>
        # <COMMENTS>converge</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>cases</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>, <COMMENTS>where</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>paren</COMMENTS>
        # <COMMENTS>comes</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>variable</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>arrow</COMMENTS>:
        #     <COMMENTS>$self</COMMENTS>->{<COMMENTS>main</COMMENTS>}-><COMMENTS>add_content_defer_opening</COMMENTS>
        #                         (<COMMENTS>$name</COMMENTS>, <COMMENTS>$wmkf</COMMENTS>, <COMMENTS>$self</COMMENTS>->{<COMMENTS>attrs</COMMENTS>}, <COMMENTS>$self</COMMENTS>);
        # <COMMENTS>In</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS>
        # <COMMENTS>to</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>had</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>arrow</COMMENTS>,
        # <COMMENTS>but</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>split</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>back</COMMENTS>
        # <COMMENTS>in</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>getting</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>paren</COMMENTS>.
        if ( $<CODE>type</CODE> =~ /^[wi]$/ ) {
            my $<CODE>im</CODE> = $<CODE>iprev_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
            my $<CODE>tm</CODE> = ( $<CODE>im</CODE> >= 0 ) ? $<CODE>types_to_go</CODE>[$<CODE>im</CODE>] : "";
            if ( $<CODE>tm</CODE> eq '->' ) { $<CODE>token</CODE> = $<CODE>tm</CODE> . $<CODE>token</CODE> }
        }

        #---------------------------------------------------------------
        # <COMMENTS>End</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>due</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>splitting</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> ->
        #---------------------------------------------------------------
    }
    else {
        $<CODE>token</CODE>      = ' ';
        $<CODE>type</CODE>       = '<LITERALS>b</LITERALS>';
        $<CODE>block_type</CODE> = '';
    }

    my ( $<CODE>j</CODE>, $<CODE>ws</CODE> );

    # <COMMENTS>main</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>define</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>flags</COMMENTS>
    for ( $<CODE>j</CODE> = 0 ; $<CODE>j</CODE> <= $<CODE>jmax</CODE> ; $<CODE>j</CODE>++ ) {

        if ( $$<CODE>rtoken_type</CODE>[$<CODE>j</CODE>] eq '<LITERALS>b</LITERALS>' ) {
            $<CODE>white_space_flag</CODE>[$<CODE>j</CODE>] = <CODE>WS_OPTIONAL</CODE>;
            next;
        }

        # <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>value</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>changed</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>needed</COMMENTS>
        $<CODE>ws</CODE>              = undef;
        $<CODE>last_token</CODE>      = $<CODE>token</CODE>;
        $<CODE>last_type</CODE>       = $<CODE>type</CODE>;
        $<CODE>last_block_type</CODE> = $<CODE>block_type</CODE>;
        $<CODE>token</CODE>           = $$<CODE>rtokens</CODE>[$<CODE>j</CODE>];
        $<CODE>type</CODE>            = $$<CODE>rtoken_type</CODE>[$<CODE>j</CODE>];
        $<CODE>block_type</CODE>      = $$<CODE>rblock_type</CODE>[$<CODE>j</CODE>];

        #---------------------------------------------------------------
        # <COMMENTS>Whitespace</COMMENTS> <COMMENTS>Rules</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>1</COMMENTS>:
        # <COMMENTS>Handle</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>inside</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>braces</COMMENTS>.
        #---------------------------------------------------------------

        #    /^[<COMMENTS>L</COMMENTS>\{\(\[]<COMMENTS>$</COMMENTS>/
        if ( $<CODE>is_opening_type</CODE>{$<CODE>last_type</CODE>} ) {

            $<CODE>j_tight_closing_paren</CODE> = -1;

            # <COMMENTS>let</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>matched</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>together</COMMENTS>: () {} []
            # <COMMENTS>except</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>BLOCKS</COMMENTS>
            if ( $<CODE>token</CODE> eq $<CODE>matching_token</CODE>{$<CODE>last_token</CODE>} ) {
                if ($<CODE>block_type</CODE>) {
                    $<CODE>ws</CODE> = <CODE>WS_YES</CODE>;
                }
                else {
                    $<CODE>ws</CODE> = <CODE>WS_NO</CODE>;
                }
            }
            else {

                # <COMMENTS>we</COMMENTS>'<COMMENTS>re</COMMENTS> <COMMENTS>considering</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS>
                # <COMMENTS>tightness</COMMENTS> = <COMMENTS>0</COMMENTS> <COMMENTS>means</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>inside</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>space</COMMENTS>
                # <COMMENTS>tightness</COMMENTS> = <COMMENTS>1</COMMENTS> <COMMENTS>means</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>inside</COMMENTS> <COMMENTS>if</COMMENTS> "<COMMENTS>complex</COMMENTS>"
                # <COMMENTS>tightness</COMMENTS> = <COMMENTS>2</COMMENTS> <COMMENTS>means</COMMENTS> <COMMENTS>never</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>inside</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>space</COMMENTS>

                my $<CODE>tightness</CODE>;
                if (   $<CODE>last_type</CODE> eq '{'
                    && $<CODE>last_token</CODE> eq '{'
                    && $<CODE>last_block_type</CODE> )
                {
                    $<CODE>tightness</CODE> = $<CODE>rOpts_block_brace_tightness</CODE>;
                }
                else { $<CODE>tightness</CODE> = $<CODE>tightness</CODE>{$<CODE>last_token</CODE>} }

               #=============================================================
               # <COMMENTS>Patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>fabrice_bug</COMMENTS>.<COMMENTS>pl</COMMENTS>
               # <COMMENTS>We</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>around</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>beginning</COMMENTS>
               # <COMMENTS>with</COMMENTS> ^ <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS>:
               #    <COMMENTS>my</COMMENTS> <COMMENTS>$before</COMMENTS> = <COMMENTS>$</COMMENTS>{^<COMMENTS>PREMATCH</COMMENTS>};
               # <COMMENTS>Because</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>perl</COMMENTS>:
               #    <COMMENTS>my</COMMENTS> <COMMENTS>$before</COMMENTS> = <COMMENTS>$</COMMENTS>{ ^<COMMENTS>PREMATCH</COMMENTS> };
               #    <COMMENTS>my</COMMENTS> <COMMENTS>$before</COMMENTS> = <COMMENTS>$</COMMENTS>{ ^<COMMENTS>PREMATCH</COMMENTS>};
               #    <COMMENTS>my</COMMENTS> <COMMENTS>$before</COMMENTS> = <COMMENTS>$</COMMENTS>{^<COMMENTS>PREMATCH</COMMENTS> };
               # <COMMENTS>So</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>tightness</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>is</COMMENTS> -<COMMENTS>bt</COMMENTS>=<COMMENTS>0</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>temporarily</COMMENTS> <COMMENTS>reset</COMMENTS>
               # <COMMENTS>to</COMMENTS> <COMMENTS>bt</COMMENTS>=<COMMENTS>1</COMMENTS>.  <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>tightness</COMMENTS>=<COMMENTS>1</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>so</COMMENTS>
               # <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>space</COMMENTS>
               # <COMMENTS>is</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>avoided</COMMENTS> (<COMMENTS>via</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>$j_tight_closing_paren</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>coding</COMMENTS>)
                if ( $<CODE>type</CODE> eq '<LITERALS>w</LITERALS>' && $<CODE>token</CODE> =~ /^\^/ ) { $<CODE>tightness</CODE> = 1 }

                #=============================================================

                if ( $<CODE>tightness</CODE> <= 0 ) {
                    $<CODE>ws</CODE> = <CODE>WS_YES</CODE>;
                }
                elsif ( $<CODE>tightness</CODE> > 1 ) {
                    $<CODE>ws</CODE> = <CODE>WS_NO</CODE>;
                }
                else {

                    # <COMMENTS>Patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>count</COMMENTS> '-<COMMENTS>foo</COMMENTS>' <COMMENTS>as</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS>
                    # <COMMENTS>each</COMMENTS> <COMMENTS>of</COMMENTS>  <COMMENTS>$a</COMMENTS>{-<COMMENTS>foo</COMMENTS>} <COMMENTS>and</COMMENTS> <COMMENTS>$a</COMMENTS>{<COMMENTS>foo</COMMENTS>} <COMMENTS>and</COMMENTS> <COMMENTS>$a</COMMENTS>{'<COMMENTS>foo</COMMENTS>'} <COMMENTS>do</COMMENTS>
                    # <COMMENTS>not</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>formatting</COMMENTS>.
                    my $<CODE>j_here</CODE> = $<CODE>j</CODE>;
                    ++$<CODE>j_here</CODE>
                      if ( $<CODE>token</CODE> eq '-'
                        && $<CODE>last_token</CODE> eq '{'
                        && $$<CODE>rtoken_type</CODE>[ $<CODE>j</CODE> + 1 ] eq '<LITERALS>w</LITERALS>' );

                    # <COMMENTS>$j_next</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>if</COMMENTS>
                    # <COMMENTS>the</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>token</COMMENTS>
                    my $<CODE>j_next</CODE> =
                      ( $$<CODE>rtoken_type</CODE>[ $<CODE>j_here</CODE> + 1 ] eq '<LITERALS>b</LITERALS>' )
                      ? $<CODE>j_here</CODE> + 2
                      : $<CODE>j_here</CODE> + 1;
                    my $<CODE>tok_next</CODE>  = $$<CODE>rtokens</CODE>[$<CODE>j_next</CODE>];
                    my $<CODE>type_next</CODE> = $$<CODE>rtoken_type</CODE>[$<CODE>j_next</CODE>];

                    # <COMMENTS>for</COMMENTS> <COMMENTS>tightness</COMMENTS> = <COMMENTS>1</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>token</COMMENTS>
                    # <COMMENTS>within</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>matching</COMMENTS> <COMMENTS>pair</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>tight</COMMENTS>
                    if (
                        $<CODE>tok_next</CODE> eq $<CODE>matching_token</CODE>{$<CODE>last_token</CODE>}

                        # <COMMENTS>but</COMMENTS> <COMMENTS>watch</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS>: [ [ ]    (<COMMENTS>misc</COMMENTS>.<COMMENTS>t</COMMENTS>)
                        && $<CODE>last_token</CODE> ne $<CODE>token</CODE>
                      )
                    {

                        # <COMMENTS>remember</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>paren</COMMENTS>
                        $<CODE>j_tight_closing_paren</CODE> = $<CODE>j_next</CODE>;
                        $<CODE>ws</CODE>                    = <CODE>WS_NO</CODE>;
                    }
                    else {
                        $<CODE>ws</CODE> = <CODE>WS_YES</CODE>;
                    }
                }
            }
        }    # <COMMENTS>end</COMMENTS> <COMMENTS>setting</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>inside</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>tokens</COMMENTS>
        my $<CODE>ws_1</CODE> = $<CODE>ws</CODE>
          if <CODE>FORMATTER_DEBUG_FLAG_WHITE</CODE>;

        #---------------------------------------------------------------
        # <COMMENTS>Whitespace</COMMENTS> <COMMENTS>Rules</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>2</COMMENTS>:
        # <COMMENTS>Handle</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>inside</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>pairs</COMMENTS>.
        #---------------------------------------------------------------

        #   /[\}\)\]<COMMENTS>R</COMMENTS>]/
        if ( $<CODE>is_closing_type</CODE>{$<CODE>type</CODE>} ) {

            if ( $<CODE>j</CODE> == $<CODE>j_tight_closing_paren</CODE> ) {

                $<CODE>j_tight_closing_paren</CODE> = -1;
                $<CODE>ws</CODE>                    = <CODE>WS_NO</CODE>;
            }
            else {

                if ( !defined($<CODE>ws</CODE>) ) {

                    my $<CODE>tightness</CODE>;
                    if ( $<CODE>type</CODE> eq '}' && $<CODE>token</CODE> eq '}' && $<CODE>block_type</CODE> ) {
                        $<CODE>tightness</CODE> = $<CODE>rOpts_block_brace_tightness</CODE>;
                    }
                    else { $<CODE>tightness</CODE> = $<CODE>tightness</CODE>{$<CODE>token</CODE>} }

                    $<CODE>ws</CODE> = ( $<CODE>tightness</CODE> > 1 ) ? <CODE>WS_NO</CODE> : <CODE>WS_YES</CODE>;
                }
            }
        }    # <COMMENTS>end</COMMENTS> <COMMENTS>setting</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>inside</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS>

        my $<CODE>ws_2</CODE> = $<CODE>ws</CODE>
          if <CODE>FORMATTER_DEBUG_FLAG_WHITE</CODE>;

        #---------------------------------------------------------------
        # <COMMENTS>Whitespace</COMMENTS> <COMMENTS>Rules</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>3</COMMENTS>:
        # <COMMENTS>Use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>binary</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>table</COMMENTS>.
        #---------------------------------------------------------------
        if ( !defined($<CODE>ws</CODE>) ) {
            $<CODE>ws</CODE> = $<CODE>binary_ws_rules</CODE>{$<CODE>last_type</CODE>}{$<CODE>type</CODE>};
        }
        my $<CODE>ws_3</CODE> = $<CODE>ws</CODE>
          if <CODE>FORMATTER_DEBUG_FLAG_WHITE</CODE>;

        #---------------------------------------------------------------
        # <COMMENTS>Whitespace</COMMENTS> <COMMENTS>Rules</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>4</COMMENTS>:
        # <COMMENTS>Handle</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>cases</COMMENTS>.
        #---------------------------------------------------------------
        if ( $<CODE>token</CODE> eq '(' ) {

            # <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>tweaked</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>tokenization</COMMENTS> <COMMENTS>changes</COMMENTS>.
            # <COMMENTS>We</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>at</COMMENTS> '} (', <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>:
            #     <COMMENTS>map</COMMENTS> { <COMMENTS>1</COMMENTS> * <COMMENTS>$_</COMMENTS>; } ( <COMMENTS>$y</COMMENTS>, <COMMENTS>$M</COMMENTS>, <COMMENTS>$w</COMMENTS>, <COMMENTS>$d</COMMENTS>, <COMMENTS>$h</COMMENTS>, <COMMENTS>$m</COMMENTS>, <COMMENTS>$s</COMMENTS> );
            #
            # <COMMENTS>But</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>others</COMMENTS>:
            #     &{ <COMMENTS>$_</COMMENTS>->[<COMMENTS>1</COMMENTS>] }( <COMMENTS>delete</COMMENTS> <COMMENTS>$_</COMMENTS>[<COMMENTS>$</COMMENTS>#<COMMENTS>_</COMMENTS>]{ <COMMENTS>$_</COMMENTS>->[<COMMENTS>0</COMMENTS>] } );
            # <COMMENTS>At</COMMENTS> <COMMENTS>present</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> & <COMMENTS>block</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>marked</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>L</COMMENTS>/<COMMENTS>R</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>case</COMMENTS>
            # <COMMENTS>won</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>here</COMMENTS>.
            if ( $<CODE>last_type</CODE> eq '}' ) { $<CODE>ws</CODE> = <CODE>WS_YES</CODE> }

            # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>some</COMMENTS> <COMMENTS>older</COMMENTS> <COMMENTS>versions</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>Perl</COMMENTS> <COMMENTS>had</COMMENTS> <COMMENTS>occasional</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>if</COMMENTS>
            # <COMMENTS>spaces</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>introduced</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>functions</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>opening</COMMENTS>
            # <COMMENTS>parens</COMMENTS>.  <COMMENTS>So</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>certain</COMMENTS>
            # <COMMENTS>cases</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>Perl</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>tolerate</COMMENTS> <COMMENTS>spaces</COMMENTS>.

            # <COMMENTS>Space</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>and</COMMENTS> '('
            elsif ( $<CODE>last_type</CODE> eq '<LITERALS>k</LITERALS>' ) {
                $<CODE>ws</CODE> = <CODE>WS_NO</CODE>
                  unless ( $<CODE>rOpts_space_keyword_paren</CODE>
                    || $<CODE>space_after_keyword</CODE>{$<CODE>last_token</CODE>} );
            }

            # <COMMENTS>Space</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>and</COMMENTS> '('
            # -----------------------------------------------------
            # '<COMMENTS>w</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>i</COMMENTS>' <COMMENTS>checks</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS>:
            #   <COMMENTS>myfun</COMMENTS>(    &<COMMENTS>myfun</COMMENTS>(   -><COMMENTS>myfun</COMMENTS>(
            # -----------------------------------------------------
            elsif (( $<CODE>last_type</CODE> =~ /^[wUG]$/ )
                || ( $<CODE>last_type</CODE> =~ /^[wi]$/ && $<CODE>last_token</CODE> =~ /^(\&|->)/ ) )
            {
                $<CODE>ws</CODE> = <CODE>WS_NO</CODE> unless ($<CODE>rOpts_space_function_paren</CODE>);
            }

            # <COMMENTS>space</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>and</COMMENTS> ( <COMMENTS>in</COMMENTS>
            # <COMMENTS>for</COMMENTS> <COMMENTS>$i</COMMENTS> ( <COMMENTS>0</COMMENTS> .. <COMMENTS>20</COMMENTS> ) {
            # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>eventually</COMMENTS>, <COMMENTS>type</COMMENTS> '<COMMENTS>i</COMMENTS>' <COMMENTS>needs</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>split</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>multiple</COMMENTS>
            # <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hardwired</COMMENTS> <COMMENTS>rule</COMMENTS>.
            elsif ( $<CODE>last_type</CODE> eq '<LITERALS>i</LITERALS>' && $<CODE>last_token</CODE> =~ /^[\$\%\@]/ ) {
                $<CODE>ws</CODE> = <CODE>WS_YES</CODE>;
            }

            # <COMMENTS>allow</COMMENTS> <COMMENTS>constant</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> '()' <COMMENTS>to</COMMENTS> <COMMENTS>retain</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>space</COMMENTS>
            elsif ( $<CODE>last_type</CODE> eq '<LITERALS>C</LITERALS>' && $$<CODE>rtokens</CODE>[ $<CODE>j</CODE> + 1 ] eq ')' ) {
                $<CODE>ws</CODE> = <CODE>WS_NO</CODE>;
            }
        }

        # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS>: <COMMENTS>make</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>at</COMMENTS> ']{' <COMMENTS>optional</COMMENTS>
        # <COMMENTS>since</COMMENTS> <COMMENTS>the</COMMENTS> '{' <COMMENTS>might</COMMENTS> <COMMENTS>begin</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>block</COMMENTS>
        elsif ( ( $<CODE>token</CODE> eq '{' && $<CODE>type</CODE> ne '<LITERALS>L</LITERALS>' ) && $<CODE>last_token</CODE> eq ']' ) {
            $<CODE>ws</CODE> = <CODE>WS_OPTIONAL</CODE>;
        }

        # <COMMENTS>keep</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>between</COMMENTS> '<COMMENTS>sub</COMMENTS>' <COMMENTS>and</COMMENTS> '{' <COMMENTS>for</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>definition</COMMENTS>
        if ( $<CODE>type</CODE> eq '{' ) {
            if ( $<CODE>last_token</CODE> eq '<LITERALS>sub</LITERALS>' ) {
                $<CODE>ws</CODE> = <CODE>WS_YES</CODE>;
            }

            # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>in</COMMENTS> '){'
            if ( $<CODE>last_token</CODE> eq ')' && $<CODE>token</CODE> eq '{' ) { $<CODE>ws</CODE> = <CODE>WS_YES</CODE> }

            # <COMMENTS>avoid</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>bracket</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS>
            #  @<COMMENTS>opts</COMMENTS>{'<COMMENTS>a</COMMENTS>','<COMMENTS>b</COMMENTS>',...}
            if ( $<CODE>last_type</CODE> eq '<LITERALS>i</LITERALS>' && $<CODE>last_token</CODE> =~ /^\@/ ) {
                $<CODE>ws</CODE> = <CODE>WS_NO</CODE>;
            }
        }

        elsif ( $<CODE>type</CODE> eq '<LITERALS>i</LITERALS>' ) {

            # <COMMENTS>never</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>before</COMMENTS> ->
            if ( $<CODE>token</CODE> =~ /^\-\>/ ) {
                $<CODE>ws</CODE> = <CODE>WS_NO</CODE>;
            }
        }

        # <COMMENTS>retain</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>between</COMMENTS> '-' <COMMENTS>and</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS>
        elsif ( $<CODE>type</CODE> eq '<LITERALS>w</LITERALS>' || $<CODE>type</CODE> eq '<LITERALS>C</LITERALS>' ) {
            $<CODE>ws</CODE> = <CODE>WS_OPTIONAL</CODE> if $<CODE>last_type</CODE> eq '-';

            # <COMMENTS>never</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>before</COMMENTS> ->
            if ( $<CODE>token</CODE> =~ /^\-\>/ ) {
                $<CODE>ws</CODE> = <CODE>WS_NO</CODE>;
            }
        }

        # <COMMENTS>retain</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>between</COMMENTS> '-' <COMMENTS>and</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS>
        # <COMMENTS>example</COMMENTS>: <COMMENTS>avoid</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>between</COMMENTS> '<COMMENTS>USER</COMMENTS>' <COMMENTS>and</COMMENTS> '-' <COMMENTS>here</COMMENTS>:
        #   <COMMENTS>$myhash</COMMENTS>{<COMMENTS>USER</COMMENTS>-<COMMENTS>NAME</COMMENTS>}='<COMMENTS>steve</COMMENTS>';
        elsif ( $<CODE>type</CODE> eq '<LITERALS>m</LITERALS>' || $<CODE>type</CODE> eq '-' ) {
            $<CODE>ws</CODE> = <CODE>WS_OPTIONAL</CODE> if ( $<CODE>last_type</CODE> eq '<LITERALS>w</LITERALS>' );
        }

        # <COMMENTS>always</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
        elsif ( $<CODE>type</CODE> eq '#' ) { $<CODE>ws</CODE> = <CODE>WS_YES</CODE> if $<CODE>j</CODE> > 0 }

        # <COMMENTS>always</COMMENTS> <COMMENTS>preserver</COMMENTS> <COMMENTS>whatever</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>possible</COMMENTS>
        # <COMMENTS>filehandle</COMMENTS> (<COMMENTS>except</COMMENTS> <COMMENTS>_</COMMENTS>) <COMMENTS>or</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>doc</COMMENTS> <COMMENTS>operator</COMMENTS>
        if (
            $<CODE>type</CODE> ne '#'
            && ( ( $<CODE>last_type</CODE> eq '<LITERALS>Z</LITERALS>' && $<CODE>last_token</CODE> ne '<LITERALS>_</LITERALS>' )
                || $<CODE>last_type</CODE> eq '<LITERALS>h</LITERALS>' )
          )
        {
            $<CODE>ws</CODE> = <CODE>WS_OPTIONAL</CODE>;
        }

        my $<CODE>ws_4</CODE> = $<CODE>ws</CODE>
          if <CODE>FORMATTER_DEBUG_FLAG_WHITE</CODE>;

        #---------------------------------------------------------------
        # <COMMENTS>Whitespace</COMMENTS> <COMMENTS>Rules</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>5</COMMENTS>:
        # <COMMENTS>Apply</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>covered</COMMENTS> <COMMENTS>above</COMMENTS>.
        #---------------------------------------------------------------

        # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>fall</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>here</COMMENTS>, <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>defined</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>tables</COMMENTS> <COMMENTS>for</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>and</COMMENTS>:
        #  <COMMENTS>if</COMMENTS> (<COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>equal</COMMENTS>) <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>value</COMMENTS>
        #  <COMMENTS>if</COMMENTS> (<COMMENTS>either</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>zero</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>undef</COMMENTS>) <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>other</COMMENTS>
        #  <COMMENTS>if</COMMENTS> (<COMMENTS>either</COMMENTS> <COMMENTS>is</COMMENTS> -<COMMENTS>1</COMMENTS>) <COMMENTS>use</COMMENTS> <COMMENTS>it</COMMENTS>
        # <COMMENTS>That</COMMENTS> <COMMENTS>is</COMMENTS>,
        # <COMMENTS>left</COMMENTS>  <COMMENTS>vs</COMMENTS> <COMMENTS>right</COMMENTS>
        #  <COMMENTS>1</COMMENTS>    <COMMENTS>vs</COMMENTS>    <COMMENTS>1</COMMENTS>     -->  <COMMENTS>1</COMMENTS>
        #  <COMMENTS>0</COMMENTS>    <COMMENTS>vs</COMMENTS>    <COMMENTS>0</COMMENTS>     -->  <COMMENTS>0</COMMENTS>
        # -<COMMENTS>1</COMMENTS>    <COMMENTS>vs</COMMENTS>   -<COMMENTS>1</COMMENTS>     --> -<COMMENTS>1</COMMENTS>
        #
        #  <COMMENTS>0</COMMENTS>    <COMMENTS>vs</COMMENTS>   -<COMMENTS>1</COMMENTS>     --> -<COMMENTS>1</COMMENTS>
        #  <COMMENTS>0</COMMENTS>    <COMMENTS>vs</COMMENTS>    <COMMENTS>1</COMMENTS>     -->  <COMMENTS>1</COMMENTS>
        #  <COMMENTS>1</COMMENTS>    <COMMENTS>vs</COMMENTS>    <COMMENTS>0</COMMENTS>     -->  <COMMENTS>1</COMMENTS>
        # -<COMMENTS>1</COMMENTS>    <COMMENTS>vs</COMMENTS>    <COMMENTS>0</COMMENTS>     --> -<COMMENTS>1</COMMENTS>
        #
        # -<COMMENTS>1</COMMENTS>    <COMMENTS>vs</COMMENTS>    <COMMENTS>1</COMMENTS>     --> -<COMMENTS>1</COMMENTS>
        #  <COMMENTS>1</COMMENTS>    <COMMENTS>vs</COMMENTS>   -<COMMENTS>1</COMMENTS>     --> -<COMMENTS>1</COMMENTS>
        if ( !defined($<CODE>ws</CODE>) ) {
            my $<CODE>wl</CODE> = $<CODE>want_left_space</CODE>{$<CODE>type</CODE>};
            my $<CODE>wr</CODE> = $<CODE>want_right_space</CODE>{$<CODE>last_type</CODE>};
            if ( !defined($<CODE>wl</CODE>) ) { $<CODE>wl</CODE> = 0 }
            if ( !defined($<CODE>wr</CODE>) ) { $<CODE>wr</CODE> = 0 }
            $<CODE>ws</CODE> = ( ( $<CODE>wl</CODE> == $<CODE>wr</CODE> ) || ( $<CODE>wl</CODE> == -1 ) || !$<CODE>wr</CODE> ) ? $<CODE>wl</CODE> : $<CODE>wr</CODE>;
        }

        if ( !defined($<CODE>ws</CODE>) ) {
            $<CODE>ws</CODE> = 0;
            <CODE>write_diagnostics</CODE>(
                "<LITERALS>WS</LITERALS> <LITERALS>flag</LITERALS> <LITERALS>is</LITERALS> <LITERALS>undefined</LITERALS> <LITERALS>for</LITERALS> <LITERALS>tokens</LITERALS> $<CODE>last_token</CODE> $<CODE>token</CODE>\n");
        }

        # <COMMENTS>Treat</COMMENTS> <COMMENTS>newline</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>whitespace</COMMENTS>. <COMMENTS>Otherwise</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>combine</COMMENTS>
        # '<COMMENTS>Send</COMMENTS>' <COMMENTS>and</COMMENTS> '-<COMMENTS>recipients</COMMENTS>' <COMMENTS>here</COMMENTS> <COMMENTS>according</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>rules</COMMENTS>:
        #    <COMMENTS>my</COMMENTS> <COMMENTS>$msg</COMMENTS> = <COMMENTS>new</COMMENTS> <COMMENTS>Fax</COMMENTS>::<COMMENTS>Send</COMMENTS>
        #      -<COMMENTS>recipients</COMMENTS> => <COMMENTS>$to</COMMENTS>,
        #      -<COMMENTS>data</COMMENTS> => <COMMENTS>$data</COMMENTS>;
        if ( $<CODE>ws</CODE> == 0 && $<CODE>j</CODE> == 0 ) { $<CODE>ws</CODE> = 1 }

        if (   ( $<CODE>ws</CODE> == 0 )
            && $<CODE>j</CODE> > 0
            && $<CODE>j</CODE> < $<CODE>jmax</CODE>
            && ( $<CODE>last_type</CODE> !~ /^[Zh]$/ ) )
        {

            # <COMMENTS>If</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>happens</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>fatal</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>undesirable</COMMENTS>
            # <COMMENTS>hole</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>patched</COMMENTS>.
            <CODE>write_diagnostics</CODE>(
                "<LITERALS>WS</LITERALS> <LITERALS>flag</LITERALS> <LITERALS>is</LITERALS> <LITERALS>zero</LITERALS> <LITERALS>for</LITERALS> <LITERALS>tokens</LITERALS> $<CODE>last_token</CODE> $<CODE>token</CODE>\n");
        }
        $<CODE>white_space_flag</CODE>[$<CODE>j</CODE>] = $<CODE>ws</CODE>;

        <CODE>FORMATTER_DEBUG_FLAG_WHITE</CODE> && do {
            my $<CODE>str</CODE> = substr( $<CODE>last_token</CODE>, 0, 15 );
            $<CODE>str</CODE> .= ' ' x ( 16 - length($<CODE>str</CODE>) );
            if ( !defined($<CODE>ws_1</CODE>) ) { $<CODE>ws_1</CODE> = "*" }
            if ( !defined($<CODE>ws_2</CODE>) ) { $<CODE>ws_2</CODE> = "*" }
            if ( !defined($<CODE>ws_3</CODE>) ) { $<CODE>ws_3</CODE> = "*" }
            if ( !defined($<CODE>ws_4</CODE>) ) { $<CODE>ws_4</CODE> = "*" }
            print <CODE>STDOUT</CODE>
"<LITERALS>WHITE</LITERALS>:  <LITERALS>i</LITERALS>=$<CODE>j</CODE> $<CODE>str</CODE> $<CODE>last_type</CODE> $<CODE>type</CODE> $<CODE>ws_1</CODE> : $<CODE>ws_2</CODE> : $<CODE>ws_3</CODE> : $<CODE>ws_4</CODE> : $<CODE>ws</CODE> \n";
        };
    } ## <COMMENTS>end</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>loop</COMMENTS>

    if ($<CODE>rOpts_tight_secret_operators</CODE>) {
        <CODE>secret_operator_whitespace</CODE>( $<CODE>jmax</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>,
            \@<CODE>white_space_flag</CODE> );
    }

    return \@<CODE>white_space_flag</CODE>;
} ## <COMMENTS>end</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>set_white_space_flag</COMMENTS>

{    # <COMMENTS>begin</COMMENTS> <COMMENTS>print_line_of_tokens</COMMENTS>

    my $<CODE>rtoken_type</CODE>;
    my $<CODE>rtokens</CODE>;
    my $<CODE>rlevels</CODE>;
    my $<CODE>rslevels</CODE>;
    my $<CODE>rblock_type</CODE>;
    my $<CODE>rcontainer_type</CODE>;
    my $<CODE>rcontainer_environment</CODE>;
    my $<CODE>rtype_sequence</CODE>;
    my $<CODE>input_line</CODE>;
    my $<CODE>rnesting_tokens</CODE>;
    my $<CODE>rci_levels</CODE>;
    my $<CODE>rnesting_blocks</CODE>;

    my $<CODE>in_quote</CODE>;
    my $<CODE>guessed_indentation_level</CODE>;

    # <COMMENTS>These</COMMENTS> <COMMENTS>local</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>variables</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>stored</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>store_token_to_go</COMMENTS>:
    my $<CODE>block_type</CODE>;
    my $<CODE>ci_level</CODE>;
    my $<CODE>container_environment</CODE>;
    my $<CODE>container_type</CODE>;
    my $<CODE>in_continued_quote</CODE>;
    my $<CODE>level</CODE>;
    my $<CODE>nesting_blocks</CODE>;
    my $<CODE>no_internal_newlines</CODE>;
    my $<CODE>slevel</CODE>;
    my $<CODE>token</CODE>;
    my $<CODE>type</CODE>;
    my $<CODE>type_sequence</CODE>;

    # <COMMENTS>routine</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>pull</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>jth</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS>
    sub <CODE>extract_token</CODE> {
        my $<CODE>j</CODE> = shift;
        $<CODE>token</CODE>                 = $$<CODE>rtokens</CODE>[$<CODE>j</CODE>];
        $<CODE>type</CODE>                  = $$<CODE>rtoken_type</CODE>[$<CODE>j</CODE>];
        $<CODE>block_type</CODE>            = $$<CODE>rblock_type</CODE>[$<CODE>j</CODE>];
        $<CODE>container_type</CODE>        = $$<CODE>rcontainer_type</CODE>[$<CODE>j</CODE>];
        $<CODE>container_environment</CODE> = $$<CODE>rcontainer_environment</CODE>[$<CODE>j</CODE>];
        $<CODE>type_sequence</CODE>         = $$<CODE>rtype_sequence</CODE>[$<CODE>j</CODE>];
        $<CODE>level</CODE>                 = $$<CODE>rlevels</CODE>[$<CODE>j</CODE>];
        $<CODE>slevel</CODE>                = $$<CODE>rslevels</CODE>[$<CODE>j</CODE>];
        $<CODE>nesting_blocks</CODE>        = $$<CODE>rnesting_blocks</CODE>[$<CODE>j</CODE>];
        $<CODE>ci_level</CODE>              = $$<CODE>rci_levels</CODE>[$<CODE>j</CODE>];
    }

    {
        my @<CODE>saved_token</CODE>;

        sub <CODE>save_current_token</CODE> {

            @<CODE>saved_token</CODE> = (
                $<CODE>block_type</CODE>,            $<CODE>ci_level</CODE>,
                $<CODE>container_environment</CODE>, $<CODE>container_type</CODE>,
                $<CODE>in_continued_quote</CODE>,    $<CODE>level</CODE>,
                $<CODE>nesting_blocks</CODE>,        $<CODE>no_internal_newlines</CODE>,
                $<CODE>slevel</CODE>,                $<CODE>token</CODE>,
                $<CODE>type</CODE>,                  $<CODE>type_sequence</CODE>,
            );
        }

        sub <CODE>restore_current_token</CODE> {
            (
                $<CODE>block_type</CODE>,            $<CODE>ci_level</CODE>,
                $<CODE>container_environment</CODE>, $<CODE>container_type</CODE>,
                $<CODE>in_continued_quote</CODE>,    $<CODE>level</CODE>,
                $<CODE>nesting_blocks</CODE>,        $<CODE>no_internal_newlines</CODE>,
                $<CODE>slevel</CODE>,                $<CODE>token</CODE>,
                $<CODE>type</CODE>,                  $<CODE>type_sequence</CODE>,
            ) = @<CODE>saved_token</CODE>;
        }
    }

    sub <CODE>token_length</CODE> {

        # <COMMENTS>Returns</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>given</COMMENTS>:
        #  <COMMENTS>$token</COMMENTS>=<COMMENTS>text</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS>
        #  <COMMENTS>$type</COMMENTS> = <COMMENTS>type</COMMENTS>
        #  <COMMENTS>$not_first_token</COMMENTS> = <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>TRUE</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS>
        #   <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>array</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS>
        #   <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>vs</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comment</COMMENTS>.
        # <COMMENTS>Note</COMMENTS>: <COMMENTS>Eventually</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>determining</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>length</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>package</COMMENTS>.
        my ( $<CODE>token</CODE>, $<CODE>type</CODE>, $<CODE>not_first_token</CODE> ) = @<CODE>_</CODE>;
        my $<CODE>token_length</CODE> = length($<CODE>token</CODE>);

        # <COMMENTS>We</COMMENTS> <COMMENTS>mark</COMMENTS> <COMMENTS>lengths</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS>
        # <COMMENTS>ignoring</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>lengths</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>setting</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>breaks</COMMENTS>.
        $<CODE>token_length</CODE> = 1
          if ( $<CODE>rOpts_ignore_side_comment_lengths</CODE>
            && $<CODE>not_first_token</CODE>
            && $<CODE>type</CODE> eq '#' );
        return $<CODE>token_length</CODE>;
    }

    sub <CODE>rtoken_length</CODE> {

        # <COMMENTS>return</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>ith</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> @{<COMMENTS>$rtokens</COMMENTS>}
        my ($<CODE>i</CODE>) = @<CODE>_</CODE>;
        return <CODE>token_length</CODE>( $$<CODE>rtokens</CODE>[$<CODE>i</CODE>], $$<CODE>rtoken_type</CODE>[$<CODE>i</CODE>], $<CODE>i</CODE> );
    }

    # <COMMENTS>Routine</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>place</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>.
    # <COMMENTS>Called</COMMENTS> <COMMENTS>once</COMMENTS> <COMMENTS>per</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>token</COMMENTS>.
    sub <CODE>store_token_to_go</CODE> {

        my $<CODE>flag</CODE> = $<CODE>no_internal_newlines</CODE>;
        if ( $<CODE>_</CODE>[0] ) { $<CODE>flag</CODE> = 1 }

        $<CODE>tokens_to_go</CODE>[ ++$<CODE>max_index_to_go</CODE> ]            = $<CODE>token</CODE>;
        $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>]                 = $<CODE>type</CODE>;
        $<CODE>nobreak_to_go</CODE>[$<CODE>max_index_to_go</CODE>]               = $<CODE>flag</CODE>;
        $<CODE>old_breakpoint_to_go</CODE>[$<CODE>max_index_to_go</CODE>]        = 0;
        $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>max_index_to_go</CODE>]     = 0;
        $<CODE>block_type_to_go</CODE>[$<CODE>max_index_to_go</CODE>]            = $<CODE>block_type</CODE>;
        $<CODE>type_sequence_to_go</CODE>[$<CODE>max_index_to_go</CODE>]         = $<CODE>type_sequence</CODE>;
        $<CODE>container_environment_to_go</CODE>[$<CODE>max_index_to_go</CODE>] = $<CODE>container_environment</CODE>;
        $<CODE>nesting_blocks_to_go</CODE>[$<CODE>max_index_to_go</CODE>]        = $<CODE>nesting_blocks</CODE>;
        $<CODE>ci_levels_to_go</CODE>[$<CODE>max_index_to_go</CODE>]             = $<CODE>ci_level</CODE>;
        $<CODE>mate_index_to_go</CODE>[$<CODE>max_index_to_go</CODE>]            = -1;
        $<CODE>matching_token_to_go</CODE>[$<CODE>max_index_to_go</CODE>]        = '';
        $<CODE>bond_strength_to_go</CODE>[$<CODE>max_index_to_go</CODE>]         = 0;

        # <COMMENTS>Note</COMMENTS>: <COMMENTS>negative</COMMENTS> <COMMENTS>levels</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>currently</COMMENTS> <COMMENTS>retained</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>diagnostic</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS>
        # <COMMENTS>the</COMMENTS> '<COMMENTS>final</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>correctly</COMMENTS> <COMMENTS>reported</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>scripts</COMMENTS>.
        # <COMMENTS>But</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>means</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>every</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>$level</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>checked</COMMENTS>.
        # <COMMENTS>If</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>becomes</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>much</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>problem</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>clip</COMMENTS>
        # <COMMENTS>them</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>zero</COMMENTS>.
        ## <COMMENTS>$levels_to_go</COMMENTS>[<COMMENTS>$max_index_to_go</COMMENTS>] = ( <COMMENTS>$level</COMMENTS> > <COMMENTS>0</COMMENTS> ) ? <COMMENTS>$level</COMMENTS> : <COMMENTS>0</COMMENTS>;
        $<CODE>levels_to_go</CODE>[$<CODE>max_index_to_go</CODE>] = $<CODE>level</CODE>;
        $<CODE>nesting_depth_to_go</CODE>[$<CODE>max_index_to_go</CODE>] = ( $<CODE>slevel</CODE> >= 0 ) ? $<CODE>slevel</CODE> : 0;

        # <COMMENTS>link</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS> <COMMENTS>tokens</COMMENTS>
        my $<CODE>iprev</CODE> = $<CODE>max_index_to_go</CODE> - 1;
        $<CODE>iprev</CODE>-- if ( $<CODE>iprev</CODE> >= 0 && $<CODE>types_to_go</CODE>[$<CODE>iprev</CODE>] eq '<LITERALS>b</LITERALS>' );
        $<CODE>iprev_to_go</CODE>[$<CODE>max_index_to_go</CODE>] = $<CODE>iprev</CODE>;
        $<CODE>inext_to_go</CODE>[$<CODE>iprev</CODE>]           = $<CODE>max_index_to_go</CODE>
          if ( $<CODE>iprev</CODE> >= 0 && $<CODE>type</CODE> ne '<LITERALS>b</LITERALS>' );
        $<CODE>inext_to_go</CODE>[$<CODE>max_index_to_go</CODE>] = $<CODE>max_index_to_go</CODE> + 1;

        $<CODE>token_lengths_to_go</CODE>[$<CODE>max_index_to_go</CODE>] =
          <CODE>token_length</CODE>( $<CODE>token</CODE>, $<CODE>type</CODE>, $<CODE>max_index_to_go</CODE> );

        # <COMMENTS>We</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>running</COMMENTS> <COMMENTS>sum</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>lengths</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>:
        #   <COMMENTS>summed_lengths_to_go</COMMENTS>[<COMMENTS>$i</COMMENTS>]   = <COMMENTS>total</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>$i</COMMENTS>
        #   <COMMENTS>summed_lengths_to_go</COMMENTS>[<COMMENTS>$i</COMMENTS>+<COMMENTS>1</COMMENTS>] = <COMMENTS>total</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>$i</COMMENTS>
        $<CODE>summed_lengths_to_go</CODE>[ $<CODE>max_index_to_go</CODE> + 1 ] =
          $<CODE>summed_lengths_to_go</CODE>[$<CODE>max_index_to_go</CODE>] +
          $<CODE>token_lengths_to_go</CODE>[$<CODE>max_index_to_go</CODE>];

        # <COMMENTS>Define</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>started</COMMENTS>
        # <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>now</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>this</COMMENTS>
        # <COMMENTS>when</COMMENTS> <COMMENTS>considering</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS>.
        <CODE>set_leading_whitespace</CODE>( $<CODE>level</CODE>, $<CODE>ci_level</CODE>, $<CODE>in_continued_quote</CODE> );

        # <COMMENTS>remember</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>seen</COMMENTS>
        if ( $<CODE>type</CODE> ne '<LITERALS>b</LITERALS>' ) {
            $<CODE>last_last_nonblank_index_to_go</CODE> = $<CODE>last_nonblank_index_to_go</CODE>;
            $<CODE>last_last_nonblank_type_to_go</CODE>  = $<CODE>last_nonblank_type_to_go</CODE>;
            $<CODE>last_last_nonblank_token_to_go</CODE> = $<CODE>last_nonblank_token_to_go</CODE>;
            $<CODE>last_nonblank_index_to_go</CODE>      = $<CODE>max_index_to_go</CODE>;
            $<CODE>last_nonblank_type_to_go</CODE>       = $<CODE>type</CODE>;
            $<CODE>last_nonblank_token_to_go</CODE>      = $<CODE>token</CODE>;
            if ( $<CODE>type</CODE> eq ',' ) {
                $<CODE>comma_count_in_batch</CODE>++;
            }
        }

        <CODE>FORMATTER_DEBUG_FLAG_STORE</CODE> && do {
            my ( $<CODE>a</CODE>, $<CODE>b</CODE>, $<CODE>c</CODE> ) = caller();
            print <CODE>STDOUT</CODE>
"<LITERALS>STORE</LITERALS>: <LITERALS>from</LITERALS> $<CODE>a</CODE> $<CODE>c</CODE>: <LITERALS>storing</LITERALS> <LITERALS>token</LITERALS> $<CODE>token</CODE> <LITERALS>type</LITERALS> $<CODE>type</CODE> <LITERALS>lev</LITERALS>=$<CODE>level</CODE> <LITERALS>slev</LITERALS>=$<CODE>slevel</CODE> <LITERALS>at</LITERALS> $<CODE>max_index_to_go</CODE>\n";
        };
    }

    sub <CODE>insert_new_token_to_go</CODE> {

        # <COMMENTS>insert</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>.  <COMMENTS>use</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>as</COMMENTS>
        # <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS>; <COMMENTS>assumes</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>max_index_to_go</COMMENTS>.
        <CODE>save_current_token</CODE>();
        ( $<CODE>token</CODE>, $<CODE>type</CODE>, $<CODE>slevel</CODE>, $<CODE>no_internal_newlines</CODE> ) = @<CODE>_</CODE>;

        if ( $<CODE>max_index_to_go</CODE> == <CODE>UNDEFINED_INDEX</CODE> ) {
            <CODE>warning</CODE>("<LITERALS>code</LITERALS> <LITERALS>bug</LITERALS>: <LITERALS>bad</LITERALS> <LITERALS>call</LITERALS> <LITERALS>to</LITERALS> <LITERALS>insert_new_token_to_go</LITERALS>\n");
        }
        $<CODE>level</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>max_index_to_go</CODE>];

        # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>it</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS>, <COMMENTS>rather</COMMENTS> <COMMENTS>than</COMMENTS>
        # <COMMENTS>previous</COMMENTS>, <COMMENTS>value</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>variable</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>creating</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>blank</COMMENTS> (<COMMENTS>align</COMMENTS>.<COMMENTS>t</COMMENTS>)
        #<COMMENTS>my</COMMENTS> <COMMENTS>$slevel</COMMENTS>         = <COMMENTS>$nesting_depth_to_go</COMMENTS>[<COMMENTS>$max_index_to_go</COMMENTS>];
        $<CODE>nesting_blocks</CODE>        = $<CODE>nesting_blocks_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
        $<CODE>ci_level</CODE>              = $<CODE>ci_levels_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
        $<CODE>container_environment</CODE> = $<CODE>container_environment_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
        $<CODE>in_continued_quote</CODE>    = 0;
        $<CODE>block_type</CODE>            = "";
        $<CODE>type_sequence</CODE>         = "";
        <CODE>store_token_to_go</CODE>();
        <CODE>restore_current_token</CODE>();
        return;
    }

    sub <CODE>print_line_of_tokens</CODE> {

        my $<CODE>line_of_tokens</CODE> = shift;

        # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>once</COMMENTS> <COMMENTS>per</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>process</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>of</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>stage</COMMENTS> <COMMENTS>of</COMMENTS>
        # <COMMENTS>beautification</COMMENTS>.
        #
        # <COMMENTS>Full</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>processed</COMMENTS> <COMMENTS>immediately</COMMENTS>.
        #
        # <COMMENTS>For</COMMENTS> <COMMENTS>normal</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>stored</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>by</COMMENTS>-<COMMENTS>one</COMMENTS>,
        # <COMMENTS>via</COMMENTS> <COMMENTS>calls</COMMENTS> <COMMENTS>to</COMMENTS> '<COMMENTS>sub</COMMENTS> <COMMENTS>store_token_to_go</COMMENTS>', <COMMENTS>until</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>known</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>break</COMMENTS>
        # <COMMENTS>point</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>reached</COMMENTS>.  <COMMENTS>Then</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>batch</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>collected</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>is</COMMENTS>
        # <COMMENTS>passed</COMMENTS> <COMMENTS>along</COMMENTS> <COMMENTS>to</COMMENTS> '<COMMENTS>sub</COMMENTS> <COMMENTS>output_line_to_go</COMMENTS>' <COMMENTS>for</COMMENTS> <COMMENTS>further</COMMENTS>
        # <COMMENTS>processing</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>decides</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS>
        # <COMMENTS>whitespace</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>pair</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>white</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>later</COMMENTS>
        # <COMMENTS>routines</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>additional</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>breaks</COMMENTS>.
        # <COMMENTS>Any</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>initially</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>character</COMMENTS>.  <COMMENTS>Later</COMMENTS>,
        # <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>expand</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>space</COMMENTS>
        # <COMMENTS>characters</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>alignment</COMMENTS>.

        # <COMMENTS>extract</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>messages</COMMENTS>
        $<CODE>input_line_number</CODE> = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_number</LITERALS>};

        $<CODE>rtoken_type</CODE>            = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rtoken_type</LITERALS>};
        $<CODE>rtokens</CODE>                = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rtokens</LITERALS>};
        $<CODE>rlevels</CODE>                = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rlevels</LITERALS>};
        $<CODE>rslevels</CODE>               = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rslevels</LITERALS>};
        $<CODE>rblock_type</CODE>            = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rblock_type</LITERALS>};
        $<CODE>rcontainer_type</CODE>        = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rcontainer_type</LITERALS>};
        $<CODE>rcontainer_environment</CODE> = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rcontainer_environment</LITERALS>};
        $<CODE>rtype_sequence</CODE>         = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rtype_sequence</LITERALS>};
        $<CODE>input_line</CODE>             = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_text</LITERALS>};
        $<CODE>rnesting_tokens</CODE>        = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rnesting_tokens</LITERALS>};
        $<CODE>rci_levels</CODE>             = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rci_levels</LITERALS>};
        $<CODE>rnesting_blocks</CODE>        = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rnesting_blocks</LITERALS>};

        $<CODE>in_continued_quote</CODE> = $<CODE>starting_in_quote</CODE> =
          $<CODE>line_of_tokens</CODE>->{<LITERALS>_starting_in_quote</LITERALS>};
        $<CODE>in_quote</CODE>        = $<CODE>line_of_tokens</CODE>->{<LITERALS>_ending_in_quote</LITERALS>};
        $<CODE>ending_in_quote</CODE> = $<CODE>in_quote</CODE>;
        $<CODE>guessed_indentation_level</CODE> =
          $<CODE>line_of_tokens</CODE>->{<LITERALS>_guessed_indentation_level</LITERALS>};

        my $<CODE>j</CODE>;
        my $<CODE>j_next</CODE>;
        my $<CODE>jmax</CODE>;
        my $<CODE>next_nonblank_token</CODE>;
        my $<CODE>next_nonblank_token_type</CODE>;
        my $<CODE>rwhite_space_flag</CODE>;

        $<CODE>jmax</CODE>                    = @$<CODE>rtokens</CODE> - 1;
        $<CODE>block_type</CODE>              = "";
        $<CODE>container_type</CODE>          = "";
        $<CODE>container_environment</CODE>   = "";
        $<CODE>type_sequence</CODE>           = "";
        $<CODE>no_internal_newlines</CODE>    = 1 - $<CODE>rOpts_add_newlines</CODE>;
        $<CODE>is_static_block_comment</CODE> = 0;

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>continued</COMMENTS> <COMMENTS>quote</COMMENTS>..
        if ($<CODE>in_continued_quote</CODE>) {

            # <COMMENTS>A</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>entirely</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>out</COMMENTS>
            # <COMMENTS>verbatim</COMMENTS>.  <COMMENTS>Note</COMMENTS>: <COMMENTS>the</COMMENTS> \<COMMENTS>n</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>contained</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>$input_line</COMMENTS>.
            if ( $<CODE>jmax</CODE> <= 0 ) {
                if ( ( $<CODE>input_line</CODE> =~ "\t" ) ) {
                    <CODE>note_embedded_tab</CODE>();
                }
                <CODE>write_unindented_line</CODE>("$<CODE>input_line</CODE>");
                $<CODE>last_line_had_side_comment</CODE> = 0;
                return;
            }
        }

        # <COMMENTS>Write</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>verbatim</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>formatting</COMMENTS> <COMMENTS>skip</COMMENTS> <COMMENTS>section</COMMENTS>
        if ($<CODE>in_format_skipping_section</CODE>) {
            <CODE>write_unindented_line</CODE>("$<CODE>input_line</CODE>");
            $<CODE>last_line_had_side_comment</CODE> = 0;

            # <COMMENTS>Note</COMMENTS>: <COMMENTS>extra</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>appended</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>simplifies</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>matching</COMMENTS>
            if (   $<CODE>jmax</CODE> == 0
                && $$<CODE>rtoken_type</CODE>[0] eq '#'
                && ( $$<CODE>rtokens</CODE>[0] . " " ) =~ /$<CODE>format_skipping_pattern_end</CODE>/o )
            {
                $<CODE>in_format_skipping_section</CODE> = 0;
                <CODE>write_logfile_entry</CODE>("<LITERALS>Exiting</LITERALS> <LITERALS>formatting</LITERALS> <LITERALS>skip</LITERALS> <LITERALS>section</LITERALS>\n");
                $<CODE>file_writer_object</CODE>-><CODE>reset_consecutive_blank_lines</CODE>();
            }
            return;
        }

        # <COMMENTS>See</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>entering</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>formatting</COMMENTS> <COMMENTS>skip</COMMENTS> <COMMENTS>section</COMMENTS>
        if (   $<CODE>rOpts_format_skipping</CODE>
            && $<CODE>jmax</CODE> == 0
            && $$<CODE>rtoken_type</CODE>[0] eq '#'
            && ( $$<CODE>rtokens</CODE>[0] . " " ) =~ /$<CODE>format_skipping_pattern_begin</CODE>/o )
        {
            <CODE>flush</CODE>();
            $<CODE>in_format_skipping_section</CODE> = 1;
            <CODE>write_logfile_entry</CODE>("<LITERALS>Entering</LITERALS> <LITERALS>formatting</LITERALS> <LITERALS>skip</LITERALS> <LITERALS>section</LITERALS>\n");
            <CODE>write_unindented_line</CODE>("$<CODE>input_line</CODE>");
            $<CODE>last_line_had_side_comment</CODE> = 0;
            return;
        }

        # <COMMENTS>delete</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>tokens</COMMENTS>
        if ( $<CODE>jmax</CODE> > 0 && $$<CODE>rtoken_type</CODE>[$<CODE>jmax</CODE>] eq '<LITERALS>b</LITERALS>' ) { $<CODE>jmax</CODE>-- }

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS>..
        if ( $<CODE>jmax</CODE> < 0 ) {

            # <COMMENTS>If</COMMENTS> <COMMENTS>keep</COMMENTS>-<COMMENTS>old</COMMENTS>-<COMMENTS>blank</COMMENTS>-<COMMENTS>lines</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>zero</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>delete</COMMENTS> <COMMENTS>all</COMMENTS>
            # <COMMENTS>old</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>generate</COMMENTS> <COMMENTS>any</COMMENTS>
            # <COMMENTS>needed</COMMENTS> <COMMENTS>blanks</COMMENTS>.
            if ($<CODE>rOpts_keep_old_blank_lines</CODE>) {
                <CODE>flush</CODE>();
                $<CODE>file_writer_object</CODE>-><CODE>write_blank_code_line</CODE>(
                    $<CODE>rOpts_keep_old_blank_lines</CODE> == 2 );
                $<CODE>last_line_leading_type</CODE> = '<LITERALS>b</LITERALS>';
            }
            $<CODE>last_line_had_side_comment</CODE> = 0;
            return;
        }

        # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>static</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comment</COMMENTS> (<COMMENTS>starts</COMMENTS> <COMMENTS>with</COMMENTS> ## <COMMENTS>by</COMMENTS> <COMMENTS>default</COMMENTS>)
        my $<CODE>is_static_block_comment_without_leading_space</CODE> = 0;
        if (   $<CODE>jmax</CODE> == 0
            && $$<CODE>rtoken_type</CODE>[0] eq '#'
            && $<CODE>rOpts</CODE>->{'<LITERALS>static</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>'}
            && $<CODE>input_line</CODE> =~ /$<CODE>static_block_comment_pattern</CODE>/o )
        {
            $<CODE>is_static_block_comment</CODE> = 1;
            $<CODE>is_static_block_comment_without_leading_space</CODE> =
              substr( $<CODE>input_line</CODE>, 0, 1 ) eq '#';
        }

        # <COMMENTS>Check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>directives</COMMENTS>
        # <COMMENTS>Treat</COMMENTS> <COMMENTS>exactly</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>static</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>space</COMMENTS>
        # <COMMENTS>reference</COMMENTS>: <COMMENTS>perlsyn</COMMENTS>, <COMMENTS>near</COMMENTS> <COMMENTS>end</COMMENTS>, <COMMENTS>section</COMMENTS> <COMMENTS>Plain</COMMENTS> <COMMENTS>Old</COMMENTS> <COMMENTS>Comments</COMMENTS> (<COMMENTS>Not</COMMENTS>!)
        # <COMMENTS>example</COMMENTS>: '# <COMMENTS>line</COMMENTS> <COMMENTS>42</COMMENTS> "<COMMENTS>new_filename</COMMENTS>.<COMMENTS>plx</COMMENTS>"'
        if (
               $<CODE>jmax</CODE> == 0
            && $$<CODE>rtoken_type</CODE>[0] eq '#'
            && $<CODE>input_line</CODE> =~ /^\#   \s*
                               line \s+ (\d+)   \s*
                               (?:\s("?)([^"]+)\2)? \s*
                               $/x
          )
        {
            $<CODE>is_static_block_comment</CODE>                       = 1;
            $<CODE>is_static_block_comment_without_leading_space</CODE> = 1;
        }

        # <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hanging</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>appropriate</COMMENTS>
        my $<CODE>is_hanging_side_comment</CODE>;
        if (
               $<CODE>jmax</CODE> == 0
            && $$<CODE>rtoken_type</CODE>[0] eq '#'      # <COMMENTS>only</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comment</COMMENTS>
            && $<CODE>last_line_had_side_comment</CODE>  # <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>had</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
            && $<CODE>input_line</CODE> =~ /^\s/         # <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>space</COMMENTS>
            && !$<CODE>is_static_block_comment</CODE>    # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>static</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>hanging</COMMENTS>
            && $<CODE>rOpts</CODE>->{'<LITERALS>hanging</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>'}    # <COMMENTS>user</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>allowing</COMMENTS>
                                                    # <COMMENTS>hanging</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>
                                                    # <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>
          )
        {

            # <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>insert</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>list</COMMENTS>
            # <COMMENTS>to</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>. <COMMENTS>The</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS>
            # <COMMENTS>should</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>.
            $<CODE>is_hanging_side_comment</CODE> = 1;
            unshift @$<CODE>rtoken_type</CODE>,            '<LITERALS>q</LITERALS>';
            unshift @$<CODE>rtokens</CODE>,                '';
            unshift @$<CODE>rlevels</CODE>,                $$<CODE>rlevels</CODE>[0];
            unshift @$<CODE>rslevels</CODE>,               $$<CODE>rslevels</CODE>[0];
            unshift @$<CODE>rblock_type</CODE>,            '';
            unshift @$<CODE>rcontainer_type</CODE>,        '';
            unshift @$<CODE>rcontainer_environment</CODE>, '';
            unshift @$<CODE>rtype_sequence</CODE>,         '';
            unshift @$<CODE>rnesting_tokens</CODE>,        $$<CODE>rnesting_tokens</CODE>[0];
            unshift @$<CODE>rci_levels</CODE>,             $$<CODE>rci_levels</CODE>[0];
            unshift @$<CODE>rnesting_blocks</CODE>,        $$<CODE>rnesting_blocks</CODE>[0];
            $<CODE>jmax</CODE> = 1;
        }

        # <COMMENTS>remember</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
        $<CODE>last_line_had_side_comment</CODE> =
          ( $<CODE>jmax</CODE> > 0 && $$<CODE>rtoken_type</CODE>[$<CODE>jmax</CODE>] eq '#' );

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> (<COMMENTS>full</COMMENTS>-<COMMENTS>line</COMMENTS>) <COMMENTS>comment</COMMENTS>..
        if ( ( $<CODE>jmax</CODE> == 0 ) && ( $$<CODE>rtoken_type</CODE>[0] eq '#' ) ) {

            if ( $<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>'} ) { return }

            if ( $<CODE>rOpts</CODE>->{'<LITERALS>tee</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>'} ) {
                $<CODE>file_writer_object</CODE>-><CODE>tee_on</CODE>();
            }

            <CODE>destroy_one_line_block</CODE>();
            <CODE>output_line_to_go</CODE>();

            # <COMMENTS>output</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comments</COMMENTS>
            if (
                # <COMMENTS>unless</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>line</COMMENTS>
                $<CODE>last_line_leading_type</CODE> !~ /^[#b]$/

                # <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>allowed</COMMENTS>
                && $<CODE>rOpts</CODE>->{'<LITERALS>blanks</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>comments</LITERALS>'}

                # <COMMENTS>not</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>line</COMMENTS>
                && $$<CODE>rtokens</CODE>[0] ne '#'

                # <COMMENTS>not</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
                # <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>comment</COMMENTS>.
                # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>block</COMMENTS>, <COMMENTS>after</COMMENTS>
                # <COMMENTS>the</COMMENTS> '<COMMENTS>if</COMMENTS> (', <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS>.
                && !$<CODE>last_output_short_opening_token</CODE>

                # <COMMENTS>never</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>static</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comments</COMMENTS>
                && !$<CODE>is_static_block_comment</CODE>
              )
            {
                <CODE>flush</CODE>();    # <COMMENTS>switching</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>
                $<CODE>file_writer_object</CODE>-><CODE>write_blank_code_line</CODE>();
                $<CODE>last_line_leading_type</CODE> = '<LITERALS>b</LITERALS>';
            }

            # <COMMENTS>TRIM</COMMENTS> <COMMENTS>COMMENTS</COMMENTS> -- <COMMENTS>This</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>turned</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>option</COMMENTS>
            $$<CODE>rtokens</CODE>[0] =~ s/\s*$//;    # <COMMENTS>trim</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>end</COMMENTS>

            if (
                $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>'}
                && (  !$<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>spaced</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>'}
                    || $<CODE>input_line</CODE> =~ /^\s+/ )
                && !$<CODE>is_static_block_comment_without_leading_space</CODE>
              )
            {
                <CODE>extract_token</CODE>(0);
                <CODE>store_token_to_go</CODE>();
                <CODE>output_line_to_go</CODE>();
            }
            else {
                <CODE>flush</CODE>();    # <COMMENTS>switching</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>
                $<CODE>file_writer_object</CODE>-><CODE>write_code_line</CODE>( $$<CODE>rtokens</CODE>[0] . "\n" );
                $<CODE>last_line_leading_type</CODE> = '#';
            }
            if ( $<CODE>rOpts</CODE>->{'<LITERALS>tee</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>'} ) {
                $<CODE>file_writer_object</CODE>-><CODE>tee_off</CODE>();
            }
            return;
        }

        # <COMMENTS>compare</COMMENTS> <COMMENTS>input</COMMENTS>/<COMMENTS>output</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>lines</COMMENTS>
        # (<COMMENTS>because</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>unknown</COMMENTS> <COMMENTS>amount</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>initial</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>space</COMMENTS>)
        # <COMMENTS>and</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>quotes</COMMENTS> (<COMMENTS>because</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>outdented</COMMENTS>)
        # <COMMENTS>Note</COMMENTS>: <COMMENTS>this</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>placed</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>flag</COMMENTS>
        # <COMMENTS>at</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>point</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>allows</COMMENTS> <COMMENTS>us</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>meaningful</COMMENTS> <COMMENTS>checks</COMMENTS>.
        my $<CODE>structural_indentation_level</CODE> = $$<CODE>rlevels</CODE>[0];
        <CODE>compare_indentation_levels</CODE>( $<CODE>guessed_indentation_level</CODE>,
            $<CODE>structural_indentation_level</CODE> )
          unless ( $<CODE>is_hanging_side_comment</CODE>
            || $$<CODE>rci_levels</CODE>[0] > 0
            || $<CODE>guessed_indentation_level</CODE> == 0 && $$<CODE>rtoken_type</CODE>[0] eq '<LITERALS>Q</LITERALS>' );

        #   <COMMENTS>Patch</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>MakeMaker</COMMENTS>.  <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>statement</COMMENTS>
        #   <COMMENTS>in</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>$VERSION</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>calculated</COMMENTS>.  <COMMENTS>See</COMMENTS> <COMMENTS>MakeMaker</COMMENTS>.<COMMENTS>pm</COMMENTS>;
        #   <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>based</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>it</COMMENTS>.
        #   <COMMENTS>The</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>matches</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>eval</COMMENTS>'<COMMENTS>d</COMMENTS>:
        #       /([\<COMMENTS>$</COMMENTS>*])(([\<COMMENTS>w</COMMENTS>\:\']*)\<COMMENTS>bVERSION</COMMENTS>)\<COMMENTS>b</COMMENTS>.*\=/
        #   <COMMENTS>Examples</COMMENTS>:
        #     *<COMMENTS>VERSION</COMMENTS> = \'<COMMENTS>1</COMMENTS>.<COMMENTS>01</COMMENTS>';
        #     ( <COMMENTS>$VERSION</COMMENTS> ) = '<COMMENTS>$Revision</COMMENTS>: <COMMENTS>1</COMMENTS>.<COMMENTS>74</COMMENTS> <COMMENTS>$</COMMENTS> ' =~ /\<COMMENTS>$Revision</COMMENTS>:\<COMMENTS>s</COMMENTS>+([^\<COMMENTS>s</COMMENTS>]+)/;
        #   <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>pass</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>straight</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>breaking</COMMENTS>
        #   <COMMENTS>it</COMMENTS> <COMMENTS>unless</COMMENTS> -<COMMENTS>npvl</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>.

        #   <COMMENTS>Patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>reported</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>RT</COMMENTS> #<COMMENTS>81866</COMMENTS>, <COMMENTS>where</COMMENTS> <COMMENTS>files</COMMENTS>
        #   <COMMENTS>had</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>flattened</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>couldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>be</COMMENTS>
        #   <COMMENTS>tidied</COMMENTS> <COMMENTS>without</COMMENTS> -<COMMENTS>npvl</COMMENTS>.  <COMMENTS>There</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>parts</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>patch</COMMENTS>:
        #   <COMMENTS>First</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>line</COMMENTS> (<COMMENTS>80</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>now</COMMENTS>).
        #   <COMMENTS>Second</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>semicolon</COMMENTS>
        #   <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>VERSION</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>semicolon</COMMENTS>
        #   <COMMENTS>for</COMMENTS> <COMMENTS>statements</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
        #      <COMMENTS>require</COMMENTS> <COMMENTS>Exporter</COMMENTS>;  <COMMENTS>our</COMMENTS> <COMMENTS>$VERSION</COMMENTS> = <COMMENTS>$Exporter</COMMENTS>::<COMMENTS>VERSION</COMMENTS>;
        #   <COMMENTS>where</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>statements</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>MakeMaker</COMMENTS>

        my $<CODE>is_VERSION_statement</CODE> = 0;
        if (  !$<CODE>saw_VERSION_in_this_file</CODE>
            && $<CODE>jmax</CODE> < 80
            && $<CODE>input_line</CODE> =~
            /^[^;]*;?[^;]*([\$*])(([\w\:\']*)\bVERSION)\b.*\=/ )
        {
            $<CODE>saw_VERSION_in_this_file</CODE> = 1;
            $<CODE>is_VERSION_statement</CODE>     = 1;
            <CODE>write_logfile_entry</CODE>("<LITERALS>passing</LITERALS> <LITERALS>VERSION</LITERALS> <LITERALS>line</LITERALS>; -<LITERALS>npvl</LITERALS> <LITERALS>deactivates</LITERALS>\n");
            $<CODE>no_internal_newlines</CODE> = 1;
        }

        # <COMMENTS>take</COMMENTS> <COMMENTS>care</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>indentation</COMMENTS>-<COMMENTS>only</COMMENTS>
        # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>In</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>versions</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>sent</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>immediately</COMMENTS> <COMMENTS>here</COMMENTS>.
        # <COMMENTS>No</COMMENTS> <COMMENTS>longer</COMMENTS> <COMMENTS>doing</COMMENTS> <COMMENTS>this</COMMENTS>: <COMMENTS>also</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>entirely</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>qw</COMMENTS>' <COMMENTS>list</COMMENTS>
        # <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>stacking</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS>.  <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>interior</COMMENTS>
        # <COMMENTS>qw</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS>.
        if ( $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>only</LITERALS>'} ) {
            <CODE>flush</CODE>();
            my $<CODE>line</CODE> = $<CODE>input_line</CODE>;

            # <COMMENTS>delete</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>io</COMMENTS>, <COMMENTS>but</COMMENTS>
            # <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>deleting</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>io</COMMENTS>
            # <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>complex</COMMENTS>
            if (   $<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>'}
                && $<CODE>rtoken_type</CODE>->[$<CODE>jmax</CODE>] eq '#' )
            {
                $<CODE>line</CODE> = join "", @{$<CODE>rtokens</CODE>}[ 0 .. $<CODE>jmax</CODE> - 1 ];
            }
            <CODE>trim</CODE>($<CODE>line</CODE>);

            <CODE>extract_token</CODE>(0);
            $<CODE>token</CODE>                 = $<CODE>line</CODE>;
            $<CODE>type</CODE>                  = '<LITERALS>q</LITERALS>';
            $<CODE>block_type</CODE>            = "";
            $<CODE>container_type</CODE>        = "";
            $<CODE>container_environment</CODE> = "";
            $<CODE>type_sequence</CODE>         = "";
            <CODE>store_token_to_go</CODE>();
            <CODE>output_line_to_go</CODE>();
            return;
        }

        push( @$<CODE>rtokens</CODE>,     ' ', ' ' );   # <COMMENTS>making</COMMENTS> <COMMENTS>$j</COMMENTS>+<COMMENTS>2</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>simplifies</COMMENTS> <COMMENTS>coding</COMMENTS>
        push( @$<CODE>rtoken_type</CODE>, '<LITERALS>b</LITERALS>', '<LITERALS>b</LITERALS>' );
        ($<CODE>rwhite_space_flag</CODE>) =
          <CODE>set_white_space_flag</CODE>( $<CODE>jmax</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>, $<CODE>rblock_type</CODE> );

        # <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>buffer</COMMENTS> <COMMENTS>hasn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>flushed</COMMENTS>, <COMMENTS>add</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>if</COMMENTS>
        # <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>essential</COMMENTS> <COMMENTS>whitespace</COMMENTS>. <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>only</COMMENTS>
        # <COMMENTS>necessary</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>squeezing</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>ws</COMMENTS>.
        if ( $<CODE>max_index_to_go</CODE> >= 0 ) {

            $<CODE>old_line_count_in_batch</CODE>++;

            if (
                <CODE>is_essential_whitespace</CODE>(
                    $<CODE>last_last_nonblank_token</CODE>,
                    $<CODE>last_last_nonblank_type</CODE>,
                    $<CODE>tokens_to_go</CODE>[$<CODE>max_index_to_go</CODE>],
                    $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>],
                    $$<CODE>rtokens</CODE>[0],
                    $$<CODE>rtoken_type</CODE>[0]
                )
              )
            {
                my $<CODE>slevel</CODE> = $$<CODE>rslevels</CODE>[0];
                <CODE>insert_new_token_to_go</CODE>( ' ', '<LITERALS>b</LITERALS>', $<CODE>slevel</CODE>,
                    $<CODE>no_internal_newlines</CODE> );
            }
        }

        # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>saw</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>elsif</COMMENTS> <COMMENTS>block</COMMENTS>, <COMMENTS>write</COMMENTS> <COMMENTS>nag</COMMENTS> <COMMENTS>message</COMMENTS>
        # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>elseif</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>else</COMMENTS>.
        if ($<CODE>looking_for_else</CODE>) {

            unless ( $$<CODE>rtokens</CODE>[0] =~ /^(elsif|else)$/ ) {
                <CODE>write_logfile_entry</CODE>("(<LITERALS>No</LITERALS> <LITERALS>else</LITERALS> <LITERALS>block</LITERALS>)\n");
            }
            $<CODE>looking_for_else</CODE> = 0;
        }

        # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>place</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>kill</COMMENTS> <COMMENTS>incomplete</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS>
        if (
            (
                   ( $<CODE>semicolons_before_block_self_destruct</CODE> == 0 )
                && ( $<CODE>max_index_to_go</CODE> >= 0 )
                && ( $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>] eq ';' )
                && ( $$<CODE>rtokens</CODE>[0] ne '}' )
            )

            # <COMMENTS>Patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>RT</COMMENTS> #<COMMENTS>98902</COMMENTS>. <COMMENTS>Honor</COMMENTS> <COMMENTS>request</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>commas</COMMENTS>.
            || (   $<CODE>rOpts_break_at_old_comma_breakpoints</CODE>
                && $<CODE>max_index_to_go</CODE> >= 0
                && $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>] eq ',' )
          )
        {
            $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>max_index_to_go</CODE>] = 1
              if ($<CODE>rOpts_break_at_old_comma_breakpoints</CODE>);
            <CODE>destroy_one_line_block</CODE>();
            <CODE>output_line_to_go</CODE>();
        }

        # <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>process</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>by</COMMENTS>-<COMMENTS>one</COMMENTS>
        $<CODE>type</CODE>  = '<LITERALS>b</LITERALS>';
        $<CODE>token</CODE> = "";

        foreach $<CODE>j</CODE> ( 0 .. $<CODE>jmax</CODE> ) {

            # <COMMENTS>pull</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>local</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS>
            <CODE>extract_token</CODE>($<CODE>j</CODE>);

            if ( $<CODE>type</CODE> eq '#' ) {

                # <COMMENTS>trim</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>whitespace</COMMENTS>
                # (<COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>present</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>this</COMMENTS>)
                $<CODE>token</CODE> =~ s/\s*$//;

                if (
                    $<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>'}

                    # <COMMENTS>delete</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
                    || (   $<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>'}
                        && $<CODE>token</CODE> =~ /$<CODE>closing_side_comment_prefix_pattern</CODE>/o
                        && $<CODE>last_nonblank_block_type</CODE> =~
                        /$<CODE>closing_side_comment_list_pattern</CODE>/o )
                  )
                {
                    if ( $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>] eq '<LITERALS>b</LITERALS>' ) {
                        <CODE>unstore_token_to_go</CODE>();
                    }
                    last;
                }
            }

            # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>continuing</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>seeing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>brace</COMMENTS>, <COMMENTS>flush</COMMENTS>
            # <COMMENTS>buffer</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS>
            #   } <COMMENTS>else</COMMENTS> ...
            if ( $<CODE>rbrace_follower</CODE> && $<CODE>type</CODE> ne '<LITERALS>b</LITERALS>' ) {

                unless ( $<CODE>rbrace_follower</CODE>->{$<CODE>token</CODE>} ) {
                    <CODE>output_line_to_go</CODE>();
                }
                $<CODE>rbrace_follower</CODE> = undef;
            }

            $<CODE>j_next</CODE> = ( $$<CODE>rtoken_type</CODE>[ $<CODE>j</CODE> + 1 ] eq '<LITERALS>b</LITERALS>' ) ? $<CODE>j</CODE> + 2 : $<CODE>j</CODE> + 1;
            $<CODE>next_nonblank_token</CODE>      = $$<CODE>rtokens</CODE>[$<CODE>j_next</CODE>];
            $<CODE>next_nonblank_token_type</CODE> = $$<CODE>rtoken_type</CODE>[$<CODE>j_next</CODE>];

            #--------------------------------------------------------
            # <COMMENTS>Start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>text</COMMENTS>
            #--------------------------------------------------------

            # <COMMENTS>Modify</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>whitespace</COMMENTS>
            # <COMMENTS>The</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>yet</COMMENTS> <COMMENTS>done</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS>:
            #   <COMMENTS>sub</COMMENTS> (<COMMENTS>x</COMMENTS> <COMMENTS>x</COMMENTS> <COMMENTS>x</COMMENTS>)
            if ( $<CODE>type</CODE> =~ /^[wit]$/ ) {

                # <COMMENTS>Examples</COMMENTS>:
                # <COMMENTS>change</COMMENTS> '<COMMENTS>$</COMMENTS>  <COMMENTS>var</COMMENTS>'  <COMMENTS>to</COMMENTS> '<COMMENTS>$var</COMMENTS>' <COMMENTS>etc</COMMENTS>
                #        '-> <COMMENTS>new</COMMENTS>'  <COMMENTS>to</COMMENTS> '-><COMMENTS>new</COMMENTS>'
                if ( $<CODE>token</CODE> =~ /^([\$\&\%\*\@]|\-\>)\s/ ) {
                    $<CODE>token</CODE> =~ s/\s*//g;
                }

                # <COMMENTS>Split</COMMENTS> <COMMENTS>identifiers</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>arrows</COMMENTS>, <COMMENTS>inserting</COMMENTS> <COMMENTS>blanks</COMMENTS> <COMMENTS>if</COMMENTS>
                # <COMMENTS>necessary</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>easier</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>safer</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS>
                # <COMMENTS>tokenizer</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS> '-><COMMENTS>new</COMMENTS>' <COMMENTS>becomes</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>tokens</COMMENTS>, '->' <COMMENTS>and</COMMENTS>
                # '<COMMENTS>new</COMMENTS>' <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>between</COMMENTS>.
                #
                # <COMMENTS>Note</COMMENTS>: <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>related</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>set_white_space_flag</COMMENTS>
                if ( $<CODE>token</CODE> =~ /^\-\>(.*)$/ && $<CODE>1</CODE> ) {
                    my $<CODE>token_save</CODE> = $<CODE>1</CODE>;
                    my $<CODE>type_save</CODE>  = $<CODE>type</CODE>;

                    # <COMMENTS>store</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>arrow</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
                    if (   $<CODE>max_index_to_go</CODE> >= 0
                        && $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>] ne '<LITERALS>b</LITERALS>'
                        && $<CODE>want_left_space</CODE>{'->'} == <CODE>WS_YES</CODE> )
                    {
                        <CODE>insert_new_token_to_go</CODE>( ' ', '<LITERALS>b</LITERALS>', $<CODE>slevel</CODE>,
                            $<CODE>no_internal_newlines</CODE> );
                    }

                    # <COMMENTS>then</COMMENTS> <COMMENTS>store</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>arrow</COMMENTS>
                    $<CODE>token</CODE> = '->';
                    $<CODE>type</CODE>  = $<CODE>token</CODE>;
                    <CODE>store_token_to_go</CODE>();

                    # <COMMENTS>then</COMMENTS> <COMMENTS>reset</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>remainder</COMMENTS>,
                    # <COMMENTS>and</COMMENTS> <COMMENTS>reset</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>according</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>arrow</COMMENTS>
                    $$<CODE>rwhite_space_flag</CODE>[$<CODE>j</CODE>] = $<CODE>want_right_space</CODE>{'->'};
                    $<CODE>token</CODE>                  = $<CODE>token_save</CODE>;
                    $<CODE>type</CODE>                   = $<CODE>type_save</CODE>;
                }

                if ( $<CODE>token</CODE> =~ /^sub/ ) { $<CODE>token</CODE> =~ s/\s+/ /g }

                # <COMMENTS>trim</COMMENTS> <COMMENTS>identifiers</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>blanks</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>occur</COMMENTS>
                # <COMMENTS>under</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>unusual</COMMENTS> <COMMENTS>circumstances</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS>
                # <COMMENTS>identifier</COMMENTS> '<COMMENTS>witch</COMMENTS>' <COMMENTS>has</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>blanks</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>here</COMMENTS>:
                #
                # <COMMENTS>sub</COMMENTS>
                # <COMMENTS>witch</COMMENTS>
                # ()   # <COMMENTS>prototype</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS> ...
                # ...
                if ( $<CODE>type</CODE> eq '<LITERALS>i</LITERALS>' ) { $<CODE>token</CODE> =~ s/\s+$//g }
            }

            # <COMMENTS>change</COMMENTS> '<COMMENTS>LABEL</COMMENTS>   :'   <COMMENTS>to</COMMENTS> '<COMMENTS>LABEL</COMMENTS>:'
            elsif ( $<CODE>type</CODE> eq '<LITERALS>J</LITERALS>' ) { $<CODE>token</CODE> =~ s/\s+//g }

            # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> "<COMMENTS>x10</COMMENTS>"
            # <COMMENTS>This</COMMENTS> <COMMENTS>avoids</COMMENTS> <COMMENTS>having</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>split</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>tokenizer</COMMENTS>
            elsif ( $<CODE>type</CODE> eq '<LITERALS>n</LITERALS>' ) {
                if ( $<CODE>token</CODE> =~ /^x\d+/ ) { $<CODE>token</CODE> =~ s/x/<LITERALS>x</LITERALS> / }
            }

            elsif ( $<CODE>type</CODE> eq '<LITERALS>Q</LITERALS>' ) {
                <CODE>note_embedded_tab</CODE>() if ( $<CODE>token</CODE> =~ "\t" );

                # <COMMENTS>make</COMMENTS> <COMMENTS>note</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> '<COMMENTS>$var</COMMENTS> = <COMMENTS>s</COMMENTS>/<COMMENTS>xxx</COMMENTS>/<COMMENTS>yyy</COMMENTS>/;'
                # <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> '<COMMENTS>$var</COMMENTS> =~ <COMMENTS>s</COMMENTS>/<COMMENTS>xxx</COMMENTS>/<COMMENTS>yyy</COMMENTS>/;'
                if (
                       $<CODE>token</CODE> =~ /^(s|tr|y|m|\/)/
                    && $<CODE>last_nonblank_token</CODE> =~ /^(=|==|!=)$/

                    # <COMMENTS>preceded</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>scalar</COMMENTS>
                    && $<CODE>last_last_nonblank_type</CODE> eq '<LITERALS>i</LITERALS>'
                    && $<CODE>last_last_nonblank_token</CODE> =~ /^\$/

                    # <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>kind</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>termination</COMMENTS>
                    # (<COMMENTS>but</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>complaint</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>far</COMMENTS> <COMMENTS>enough</COMMENTS> <COMMENTS>ahead</COMMENTS>)
                    && $<CODE>next_nonblank_token</CODE> =~ /^[; \)\}]$/

                    # <COMMENTS>scalar</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>declared</COMMENTS>
                    && !(
                           $<CODE>types_to_go</CODE>[0] eq '<LITERALS>k</LITERALS>'
                        && $<CODE>tokens_to_go</CODE>[0] =~ /^(my|our|local)$/
                    )
                  )
                {
                    my $<CODE>guess</CODE> = substr( $<CODE>last_nonblank_token</CODE>, 0, 1 ) . '~';
                    <CODE>complain</CODE>(
"<LITERALS>Note</LITERALS>: <LITERALS>be</LITERALS> <LITERALS>sure</LITERALS> <LITERALS>you</LITERALS> <LITERALS>want</LITERALS> '$<CODE>last_nonblank_token</CODE>' <LITERALS>instead</LITERALS> <LITERALS>of</LITERALS> '$<CODE>guess</CODE>' <LITERALS>here</LITERALS>\n"
                    );
                }
            }

           # <COMMENTS>trim</COMMENTS> <COMMENTS>blanks</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>quotes</COMMENTS>
           # (<COMMENTS>To</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>trimming</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>quotes</COMMENTS> <COMMENTS>use</COMMENTS> -<COMMENTS>ntqw</COMMENTS>; <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>handles</COMMENTS> <COMMENTS>this</COMMENTS>)
            elsif ( $<CODE>type</CODE> eq '<LITERALS>q</LITERALS>' ) {
                $<CODE>token</CODE> =~ s/\s*$//;
                <CODE>note_embedded_tab</CODE>() if ( $<CODE>token</CODE> =~ "\t" );
            }

            #--------------------------------------------------------
            # <COMMENTS>End</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>text</COMMENTS>
            #--------------------------------------------------------

            # <COMMENTS>insert</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>whitespace</COMMENTS>
            if (   ( $<CODE>type</CODE> ne '<LITERALS>b</LITERALS>' )
                && ( $<CODE>max_index_to_go</CODE> >= 0 )
                && ( $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>] ne '<LITERALS>b</LITERALS>' )
                && $<CODE>rOpts_add_whitespace</CODE> )
            {
                my $<CODE>ws</CODE> = $$<CODE>rwhite_space_flag</CODE>[$<CODE>j</CODE>];

                if ( $<CODE>ws</CODE> == 1 ) {
                    <CODE>insert_new_token_to_go</CODE>( ' ', '<LITERALS>b</LITERALS>', $<CODE>slevel</CODE>,
                        $<CODE>no_internal_newlines</CODE> );
                }
            }

            # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>promote</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS>
            # <COMMENTS>block</COMMENTS> <COMMENTS>comment</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>order</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS>
            # <COMMENTS>or</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>BLOCK</COMMENTS>, <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>, <COMMENTS>those</COMMENTS> <COMMENTS>sections</COMMENTS>
            # <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>separately</COMMENTS>.
            my $<CODE>side_comment_follows</CODE> = ( $<CODE>next_nonblank_token_type</CODE> eq '#' );
            my $<CODE>is_opening_BLOCK</CODE> =
              (      $<CODE>type</CODE> eq '{'
                  && $<CODE>token</CODE> eq '{'
                  && $<CODE>block_type</CODE>
                  && $<CODE>block_type</CODE> ne '<LITERALS>t</LITERALS>' );
            my $<CODE>is_closing_BLOCK</CODE> =
              (      $<CODE>type</CODE> eq '}'
                  && $<CODE>token</CODE> eq '}'
                  && $<CODE>block_type</CODE>
                  && $<CODE>block_type</CODE> ne '<LITERALS>t</LITERALS>' );

            if (   $<CODE>side_comment_follows</CODE>
                && !$<CODE>is_opening_BLOCK</CODE>
                && !$<CODE>is_closing_BLOCK</CODE> )
            {
                $<CODE>no_internal_newlines</CODE> = 1;
            }

            # <COMMENTS>We</COMMENTS>'<COMMENTS>re</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>going</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>breaking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>BLOCKS</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>this</COMMENTS>
            # (<COMMENTS>top</COMMENTS>) <COMMENTS>level</COMMENTS>.  <COMMENTS>Other</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>by</COMMENTS>
            # <COMMENTS>sub</COMMENTS> <COMMENTS>scan_list</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>better</COMMENTS> <COMMENTS>suited</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>dealing</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>them</COMMENTS>.
            if ($<CODE>is_opening_BLOCK</CODE>) {

                # <COMMENTS>Tentatively</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>required</COMMENTS> <COMMENTS>before</COMMENTS>
                # <COMMENTS>calling</COMMENTS> <COMMENTS>starting_one_line_block</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>unstore</COMMENTS>
                # <COMMENTS>it</COMMENTS>, <COMMENTS>though</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>it</COMMENTS>.
                <CODE>store_token_to_go</CODE>($<CODE>side_comment_follows</CODE>);

                # <COMMENTS>Look</COMMENTS> <COMMENTS>ahead</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>form</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS>
                my $<CODE>too_long</CODE> =
                  <CODE>starting_one_line_block</CODE>( $<CODE>j</CODE>, $<CODE>jmax</CODE>, $<CODE>level</CODE>, $<CODE>slevel</CODE>,
                    $<CODE>ci_level</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>, $<CODE>rblock_type</CODE> );
                <CODE>clear_breakpoint_undo_stack</CODE>();

                # <COMMENTS>to</COMMENTS> <COMMENTS>simplify</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>below</COMMENTS>, <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>indicate</COMMENTS> <COMMENTS>if</COMMENTS>
                # <COMMENTS>this</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>far</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>introduces</COMMENTS> <COMMENTS>it</COMMENTS>
                my $<CODE>keyword_on_same_line</CODE> = 1;
                if (   ( $<CODE>max_index_to_go</CODE> >= 0 )
                    && ( $<CODE>last_nonblank_type</CODE> eq ')' ) )
                {
                    if (   $<CODE>block_type</CODE> =~ /^(if|else|elsif)$/
                        && ( $<CODE>tokens_to_go</CODE>[0] eq '}' )
                        && $<CODE>rOpts_cuddled_else</CODE> )
                    {
                        $<CODE>keyword_on_same_line</CODE> = 1;
                    }
                    elsif ( ( $<CODE>slevel</CODE> < $<CODE>nesting_depth_to_go</CODE>[0] ) || $<CODE>too_long</CODE> )
                    {
                        $<CODE>keyword_on_same_line</CODE> = 0;
                    }
                }

                # <COMMENTS>decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>requested</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> '{'
                my $<CODE>want_break</CODE> =

                  # <COMMENTS>use</COMMENTS> -<COMMENTS>bl</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>type</COMMENTS>
                  $<CODE>block_type</CODE> !~ /^sub/
                  ? $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>'}

                  # <COMMENTS>use</COMMENTS> -<COMMENTS>sbl</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>named</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>block</COMMENTS>
                  : $<CODE>block_type</CODE> !~ /^sub\W*$/
                  ? $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>sub</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>'}

                  # <COMMENTS>use</COMMENTS> -<COMMENTS>asbl</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>block</COMMENTS>
                  : $<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>anonymous</LITERALS>-<LITERALS>sub</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>new</LITERALS>-<LITERALS>line</LITERALS>'};

                # <COMMENTS>Break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> '{' ...
                if (

                    # <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS>
                    $<CODE>want_break</CODE>

                    # <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>unable</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS>,
                    && $<CODE>index_start_one_line_block</CODE> == <CODE>UNDEFINED_INDEX</CODE>

                    # <COMMENTS>or</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>keyword</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS>
                    # <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>outdented</COMMENTS> (<COMMENTS>eval</COMMENTS>.<COMMENTS>t</COMMENTS>, <COMMENTS>overload</COMMENTS>.<COMMENTS>t</COMMENTS>), <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS>
                    # <COMMENTS>has</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>insisted</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>keeping</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS>
                    || (   !$<CODE>keyword_on_same_line</CODE>
                        && !$<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>always</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>right</LITERALS>'} )

                  )
                {

                    # <COMMENTS>but</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>allowed</COMMENTS>
                    unless ($<CODE>no_internal_newlines</CODE>) {

                        # <COMMENTS>since</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>stored</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>unstore</COMMENTS> <COMMENTS>it</COMMENTS>
                        <CODE>unstore_token_to_go</CODE>();

                        # <COMMENTS>then</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>
                        <CODE>output_line_to_go</CODE>();

                        # <COMMENTS>and</COMMENTS> <COMMENTS>now</COMMENTS> <COMMENTS>store</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>
                        <CODE>store_token_to_go</CODE>($<CODE>side_comment_follows</CODE>);
                    }
                }

                # <COMMENTS>Now</COMMENTS> <COMMENTS>update</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
                if ($<CODE>side_comment_follows</CODE>) { $<CODE>no_internal_newlines</CODE> = 1 }

                # <COMMENTS>now</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
                unless ($<CODE>no_internal_newlines</CODE>) {
                    <CODE>output_line_to_go</CODE>();
                }
            }

            elsif ($<CODE>is_closing_BLOCK</CODE>) {

                # <COMMENTS>If</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pending</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS> ..
                if ( $<CODE>index_start_one_line_block</CODE> != <CODE>UNDEFINED_INDEX</CODE> ) {

                    # <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>terminate</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>if</COMMENTS>..
                    if (

                    # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>long</COMMENTS> (<COMMENTS>final</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>from</COMMENTS>
                    # <COMMENTS>initial</COMMENTS> <COMMENTS>estimate</COMMENTS>). <COMMENTS>note</COMMENTS>: <COMMENTS>must</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS>
                        <CODE>excess_line_length</CODE>( $<CODE>index_start_one_line_block</CODE>,
                            $<CODE>max_index_to_go</CODE> ) >= 0

                        # <COMMENTS>or</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>semicolons</COMMENTS>
                        || (   $<CODE>semicolons_before_block_self_destruct</CODE> == 0
                            && $<CODE>last_nonblank_type</CODE> ne ';' )
                      )
                    {
                        <CODE>destroy_one_line_block</CODE>();
                    }
                }

                # <COMMENTS>put</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>appropriate</COMMENTS>
                unless ( $<CODE>no_internal_newlines</CODE>
                    || $<CODE>index_start_one_line_block</CODE> != <CODE>UNDEFINED_INDEX</CODE> )
                {

                    # <COMMENTS>add</COMMENTS> <COMMENTS>missing</COMMENTS> <COMMENTS>semicolon</COMMENTS> <COMMENTS>if</COMMENTS> ...
                    # <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>tokens</COMMENTS>
                    if (
                        ( $<CODE>max_index_to_go</CODE> > 0 )

                        # <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>one</COMMENTS>
                        && ( $<CODE>last_nonblank_type</CODE> ne ';' )

                        # <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>allowed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>so</COMMENTS>.
                        && $<CODE>rOpts</CODE>->{'<LITERALS>add</LITERALS>-<LITERALS>semicolons</LITERALS>'}

                        # <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>allowed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>type</COMMENTS>
                        && (   $<CODE>ok_to_add_semicolon_for_block_type</CODE>{$<CODE>block_type</CODE>}
                            || $<CODE>block_type</CODE> =~ /^(sub|package)/
                            || $<CODE>block_type</CODE> =~ /^\w+\:$/ )

                      )
                    {

                        <CODE>save_current_token</CODE>();
                        $<CODE>token</CODE>  = ';';
                        $<CODE>type</CODE>   = ';';
                        $<CODE>level</CODE>  = $<CODE>levels_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
                        $<CODE>slevel</CODE> = $<CODE>nesting_depth_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
                        $<CODE>nesting_blocks</CODE> =
                          $<CODE>nesting_blocks_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
                        $<CODE>ci_level</CODE>       = $<CODE>ci_levels_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
                        $<CODE>block_type</CODE>     = "";
                        $<CODE>container_type</CODE> = "";
                        $<CODE>container_environment</CODE> = "";
                        $<CODE>type_sequence</CODE>         = "";

                        # <COMMENTS>Note</COMMENTS> - <COMMENTS>we</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>AFTER</COMMENTS> <COMMENTS>extracting</COMMENTS> <COMMENTS>its</COMMENTS>
                        # <COMMENTS>parameters</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>level</COMMENTS>, <COMMENTS>etc</COMMENTS>, <COMMENTS>above</COMMENTS>
                        if ( $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>] eq '<LITERALS>b</LITERALS>' ) {
                            <CODE>unstore_token_to_go</CODE>();
                        }
                        <CODE>store_token_to_go</CODE>();

                        <CODE>note_added_semicolon</CODE>();
                        <CODE>restore_current_token</CODE>();
                    }

                    # <COMMENTS>then</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>everything</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>brace</COMMENTS>
                    <CODE>output_line_to_go</CODE>();

                }

                # <COMMENTS>Now</COMMENTS> <COMMENTS>update</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
                if ($<CODE>side_comment_follows</CODE>) { $<CODE>no_internal_newlines</CODE> = 1 }

                # <COMMENTS>store</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>brace</COMMENTS>
                <CODE>store_token_to_go</CODE>();

                # <COMMENTS>ok</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>stored</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>brace</COMMENTS>.  <COMMENTS>Often</COMMENTS>, <COMMENTS>but</COMMENTS>
                # <COMMENTS>not</COMMENTS> <COMMENTS>always</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>immediately</COMMENTS>.
                # <COMMENTS>So</COMMENTS> <COMMENTS>now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>cases</COMMENTS>.

                # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> '}' <COMMENTS>successfully</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS>..
                my $<CODE>is_one_line_block</CODE> = 0;
                my $<CODE>keep_going</CODE>        = 0;
                if ( $<CODE>index_start_one_line_block</CODE> != <CODE>UNDEFINED_INDEX</CODE> ) {

                    # <COMMENTS>Remember</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS>
                    # <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>general</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS>
                    # <COMMENTS>a</COMMENTS> <COMMENTS>stack</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS>.
                    $<CODE>is_one_line_block</CODE> =
                      $<CODE>types_to_go</CODE>[$<CODE>index_start_one_line_block</CODE>];

                    # <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>actually</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>removing</COMMENTS> <COMMENTS>tentative</COMMENTS>
                    # <COMMENTS>breaks</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>it</COMMENTS>
                    <CODE>undo_forced_breakpoint_stack</CODE>(0);
                    <CODE>set_nobreaks</CODE>( $<CODE>index_start_one_line_block</CODE>,
                        $<CODE>max_index_to_go</CODE> - 1 );

                    # <COMMENTS>then</COMMENTS> <COMMENTS>re</COMMENTS>-<COMMENTS>initialize</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS>
                    <CODE>destroy_one_line_block</CODE>();

                    # <COMMENTS>then</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> '}' ..
                    # <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>going</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>followers</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS>:
                    #   <COMMENTS>do</COMMENTS> { <COMMENTS>$ifclosed</COMMENTS> = <COMMENTS>1</COMMENTS>; <COMMENTS>last</COMMENTS> } <COMMENTS>unless</COMMENTS> <COMMENTS>$losing</COMMENTS>;
                    #
                    # <COMMENTS>But</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>a</COMMENTS>
                    # <COMMENTS>significant</COMMENTS> <COMMENTS>block</COMMENTS>:
                    if (
                        (
                            $<CODE>is_block_without_semicolon</CODE>{$<CODE>block_type</CODE>}

                            # <COMMENTS>Follow</COMMENTS> <COMMENTS>users</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>point</COMMENTS> <COMMENTS>for</COMMENTS>
                            # <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>U</COMMENTS> & <COMMENTS>G</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>try</COMMENTS>' <COMMENTS>block</COMMENTS>
                            || $<CODE>is_one_line_block</CODE> =~ /^[UG]$/ && $<CODE>j</CODE> == $<CODE>jmax</CODE>
                        )

                        # <COMMENTS>if</COMMENTS> <COMMENTS>needless</COMMENTS> <COMMENTS>semicolon</COMMENTS> <COMMENTS>follows</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>later</COMMENTS>
                        && $<CODE>next_nonblank_token</CODE> ne ';'
                      )
                    {
                        <CODE>output_line_to_go</CODE>() unless ($<CODE>no_internal_newlines</CODE>);
                    }
                }

                # <COMMENTS>set</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>indicating</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>follower</COMMENTS>
                # <COMMENTS>tokens</COMMENTS>
                if ( $<CODE>block_type</CODE> eq '<LITERALS>do</LITERALS>' ) {
                    $<CODE>rbrace_follower</CODE> = \%<CODE>is_do_follower</CODE>;
                }
                elsif ( $<CODE>block_type</CODE> =~ /^(if|elsif|unless)$/ ) {
                    $<CODE>rbrace_follower</CODE> = \%<CODE>is_if_brace_follower</CODE>;
                }
                elsif ( $<CODE>block_type</CODE> eq '<LITERALS>else</LITERALS>' ) {
                    $<CODE>rbrace_follower</CODE> = \%<CODE>is_else_brace_follower</CODE>;
                }

                # <COMMENTS>added</COMMENTS> <COMMENTS>eval</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>borris</COMMENTS>.<COMMENTS>t</COMMENTS>
                elsif ($<CODE>is_sort_map_grep_eval</CODE>{$<CODE>block_type</CODE>}
                    || $<CODE>is_one_line_block</CODE> eq '<LITERALS>G</LITERALS>' )
                {
                    $<CODE>rbrace_follower</CODE> = undef;
                    $<CODE>keep_going</CODE>      = 1;
                }

                # <COMMENTS>anonymous</COMMENTS> <COMMENTS>sub</COMMENTS>
                elsif ( $<CODE>block_type</CODE> =~ /^sub\W*$/ ) {

                    if ($<CODE>is_one_line_block</CODE>) {
                        $<CODE>rbrace_follower</CODE> = \%<CODE>is_anon_sub_1_brace_follower</CODE>;
                    }
                    else {
                        $<CODE>rbrace_follower</CODE> = \%<CODE>is_anon_sub_brace_follower</CODE>;
                    }
                }

                # <COMMENTS>None</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS>: <COMMENTS>specify</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS>
                # <COMMENTS>brace</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>an</COMMENTS>
                # <COMMENTS>if</COMMENTS>/<COMMENTS>elsif</COMMENTS>/<COMMENTS>else</COMMENTS>/<COMMENTS>do</COMMENTS>/<COMMENTS>sort</COMMENTS>/<COMMENTS>map</COMMENTS>/<COMMENTS>grep</COMMENTS>/<COMMENTS>eval</COMMENTS>
                # <COMMENTS>Testfiles</COMMENTS>:
                # '<COMMENTS>Toolbar</COMMENTS>.<COMMENTS>pm</COMMENTS>', '<COMMENTS>Menubar</COMMENTS>.<COMMENTS>pm</COMMENTS>', <COMMENTS>bless</COMMENTS>.<COMMENTS>t</COMMENTS>, '<COMMENTS>3rules</COMMENTS>.<COMMENTS>pl</COMMENTS>', '<COMMENTS>break1</COMMENTS>.<COMMENTS>t</COMMENTS>
                else {
                    $<CODE>rbrace_follower</CODE> = \%<CODE>is_other_brace_follower</CODE>;
                }

                # <COMMENTS>See</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>elsif</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>elsif</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>else</COMMENTS>;
                # <COMMENTS>complain</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS>.
                if ( $<CODE>block_type</CODE> eq '<LITERALS>elsif</LITERALS>' ) {

                    if ( $<CODE>next_nonblank_token_type</CODE> eq '<LITERALS>b</LITERALS>' ) {    # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS>?
                        $<CODE>looking_for_else</CODE> = 1;    # <COMMENTS>ok</COMMENTS>, <COMMENTS>check</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS>
                    }
                    else {

                        unless ( $<CODE>next_nonblank_token</CODE> =~ /^(elsif|else)$/ ) {
                            <CODE>write_logfile_entry</CODE>("<LITERALS>No</LITERALS> <LITERALS>else</LITERALS> <LITERALS>block</LITERALS> :(\n");
                        }
                    }
                }

                # <COMMENTS>keep</COMMENTS> <COMMENTS>going</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS> (<COMMENTS>map</COMMENTS>,<COMMENTS>sort</COMMENTS>,<COMMENTS>grep</COMMENTS>,<COMMENTS>eval</COMMENTS>)
                # <COMMENTS>added</COMMENTS> <COMMENTS>eval</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>borris</COMMENTS>.<COMMENTS>t</COMMENTS>
                if ($<CODE>keep_going</CODE>) {

                    # <COMMENTS>keep</COMMENTS> <COMMENTS>going</COMMENTS>
                }

                # <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>postpone</COMMENTS> <COMMENTS>decision</COMMENTS> <COMMENTS>until</COMMENTS> <COMMENTS>re</COMMENTS>-<COMMENTS>entring</COMMENTS>
                elsif ( ( $<CODE>next_nonblank_token_type</CODE> eq '<LITERALS>b</LITERALS>' )
                    && $<CODE>rOpts_add_newlines</CODE> )
                {
                    unless ($<CODE>rbrace_follower</CODE>) {
                        <CODE>output_line_to_go</CODE>() unless ($<CODE>no_internal_newlines</CODE>);
                    }
                }

                elsif ($<CODE>rbrace_follower</CODE>) {

                    unless ( $<CODE>rbrace_follower</CODE>->{$<CODE>next_nonblank_token</CODE>} ) {
                        <CODE>output_line_to_go</CODE>() unless ($<CODE>no_internal_newlines</CODE>);
                    }
                    $<CODE>rbrace_follower</CODE> = undef;
                }

                else {
                    <CODE>output_line_to_go</CODE>() unless ($<CODE>no_internal_newlines</CODE>);
                }

            }    # <COMMENTS>end</COMMENTS> <COMMENTS>treatment</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>token</COMMENTS>

            # <COMMENTS>handle</COMMENTS> <COMMENTS>semicolon</COMMENTS>
            elsif ( $<CODE>type</CODE> eq ';' ) {

                # <COMMENTS>kill</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>semicolons</COMMENTS>
                $<CODE>semicolons_before_block_self_destruct</CODE>--;
                if (
                    ( $<CODE>semicolons_before_block_self_destruct</CODE> < 0 )
                    || (   $<CODE>semicolons_before_block_self_destruct</CODE> == 0
                        && $<CODE>next_nonblank_token_type</CODE> !~ /^[b\}]$/ )
                  )
                {
                    <CODE>destroy_one_line_block</CODE>();
                }

                # <COMMENTS>Remove</COMMENTS> <COMMENTS>unnecessary</COMMENTS> <COMMENTS>semicolons</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>bare</COMMENTS>
                # <COMMENTS>blocks</COMMENTS>, <COMMENTS>where</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>unsafe</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>is</COMMENTS>
                # <COMMENTS>mistokenized</COMMENTS>.
                if (
                    (
                        $<CODE>last_nonblank_token</CODE> eq '}'
                        && (
                            $<CODE>is_block_without_semicolon</CODE>{
                                $<CODE>last_nonblank_block_type</CODE>}
                            || $<CODE>last_nonblank_block_type</CODE> =~ /^sub\s+\w/
                            || $<CODE>last_nonblank_block_type</CODE> =~ /^\w+:$/ )
                    )
                    || $<CODE>last_nonblank_type</CODE> eq ';'
                  )
                {

                    if (
                        $<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>semicolons</LITERALS>'}

                        # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>delete</COMMENTS> ; <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> # <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>promote</COMMENTS> <COMMENTS>it</COMMENTS>
                        # <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comment</COMMENTS>
                        && ( $<CODE>next_nonblank_token_type</CODE> ne '#' )
                      )
                    {
                        <CODE>note_deleted_semicolon</CODE>();
                        <CODE>output_line_to_go</CODE>()
                          unless ( $<CODE>no_internal_newlines</CODE>
                            || $<CODE>index_start_one_line_block</CODE> != <CODE>UNDEFINED_INDEX</CODE> );
                        next;
                    }
                    else {
                        <CODE>write_logfile_entry</CODE>("<LITERALS>Extra</LITERALS> ';'\n");
                    }
                }
                <CODE>store_token_to_go</CODE>();

                <CODE>output_line_to_go</CODE>()
                  unless ( $<CODE>no_internal_newlines</CODE>
                    || ( $<CODE>rOpts_keep_interior_semicolons</CODE> && $<CODE>j</CODE> < $<CODE>jmax</CODE> )
                    || ( $<CODE>next_nonblank_token</CODE> eq '}' ) );

            }

            # <COMMENTS>handle</COMMENTS> <COMMENTS>here_doc</COMMENTS> <COMMENTS>target</COMMENTS> <COMMENTS>string</COMMENTS>
            elsif ( $<CODE>type</CODE> eq '<LITERALS>h</LITERALS>' ) {
                $<CODE>no_internal_newlines</CODE> =
                  1;    # <COMMENTS>no</COMMENTS> <COMMENTS>newlines</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>seeing</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>target</COMMENTS>
                <CODE>destroy_one_line_block</CODE>();
                <CODE>store_token_to_go</CODE>();
            }

            # <COMMENTS>handle</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>
            else {

                # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS>...
                if ( $<CODE>type</CODE> eq '<LITERALS>b</LITERALS>' ) {

                    # <COMMENTS>make</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>character</COMMENTS>
                    $<CODE>token</CODE> = ' ' if $<CODE>rOpts_add_whitespace</CODE>;

                    # <COMMENTS>delete</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>rules</COMMENTS>
                    # <COMMENTS>or</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>deleting</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>whitespace</COMMENTS>
                    my $<CODE>ws</CODE> = $$<CODE>rwhite_space_flag</CODE>[ $<CODE>j</CODE> + 1 ];
                    if ( ( defined($<CODE>ws</CODE>) && $<CODE>ws</CODE> == -1 )
                        || $<CODE>rOpts_delete_old_whitespace</CODE> )
                    {

                        # <COMMENTS>unless</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>error</COMMENTS>
                        next
                          unless <CODE>is_essential_whitespace</CODE>(
                            $<CODE>last_last_nonblank_token</CODE>,
                            $<CODE>last_last_nonblank_type</CODE>,
                            $<CODE>tokens_to_go</CODE>[$<CODE>max_index_to_go</CODE>],
                            $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>],
                            $$<CODE>rtokens</CODE>[ $<CODE>j</CODE> + 1 ],
                            $$<CODE>rtoken_type</CODE>[ $<CODE>j</CODE> + 1 ]
                          );
                    }
                }
                <CODE>store_token_to_go</CODE>();
            }

            # <COMMENTS>remember</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>OUTPUT</COMMENTS> <COMMENTS>tokens</COMMENTS>
            if ( $<CODE>type</CODE> ne '#' && $<CODE>type</CODE> ne '<LITERALS>b</LITERALS>' ) {
                $<CODE>last_last_nonblank_token</CODE> = $<CODE>last_nonblank_token</CODE>;
                $<CODE>last_last_nonblank_type</CODE>  = $<CODE>last_nonblank_type</CODE>;
                $<CODE>last_nonblank_token</CODE>      = $<CODE>token</CODE>;
                $<CODE>last_nonblank_type</CODE>       = $<CODE>type</CODE>;
                $<CODE>last_nonblank_block_type</CODE> = $<CODE>block_type</CODE>;
            }

            # <COMMENTS>unset</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>continued</COMMENTS>-<COMMENTS>quote</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>since</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>applies</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>resume</COMMENTS> <COMMENTS>normal</COMMENTS> <COMMENTS>formatting</COMMENTS> <COMMENTS>if</COMMENTS>
            # <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>additional</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>
            $<CODE>in_continued_quote</CODE> = 0;

        }    # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> '<COMMENTS>line_of_tokens</COMMENTS>'

        # <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>flush</COMMENTS> ..
        if (

            # <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
            ( ( $<CODE>type</CODE> eq '#' ) && !$<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>'} )

            # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS>
            # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>critically</COMMENTS> <COMMENTS>important</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>insuring</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>lines</COMMENTS>
            # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>processed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>like</COMMENTS> -<COMMENTS>sot</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>sct</COMMENTS>
            || $<CODE>in_quote</CODE>

            # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>VERSION</COMMENTS> <COMMENTS>statement</COMMENTS>
            || $<CODE>is_VERSION_statement</CODE>

            # <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>label</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>
            || $<CODE>type</CODE> eq '<LITERALS>J</LITERALS>'

            # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>instructed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>breaks</COMMENTS>
            || !$<CODE>rOpts</CODE>->{'<LITERALS>delete</LITERALS>-<LITERALS>old</LITERALS>-<LITERALS>newlines</LITERALS>'}
          )
        {
            <CODE>destroy_one_line_block</CODE>();
            <CODE>output_line_to_go</CODE>();
        }

        # <COMMENTS>mark</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>
        if ( $<CODE>max_index_to_go</CODE> >= 0 && !$<CODE>rOpts_ignore_old_breakpoints</CODE> ) {
            $<CODE>old_breakpoint_to_go</CODE>[$<CODE>max_index_to_go</CODE>] = 1;
        }
    } ## <COMMENTS>end</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>print_line_of_tokens</COMMENTS>
} ## <COMMENTS>end</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>print_line_of_tokens</COMMENTS>

# <COMMENTS>sub</COMMENTS> <COMMENTS>output_line_to_go</COMMENTS> <COMMENTS>sends</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>down</COMMENTS> <COMMENTS>the</COMMENTS>
# <COMMENTS>pipeline</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>VerticalAligner</COMMENTS> <COMMENTS>package</COMMENTS>, <COMMENTS>breaking</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>continuation</COMMENTS>
# <COMMENTS>lines</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>necessary</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>ready</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> "<COMMENTS>to_go</COMMENTS>"
# <COMMENTS>arrays</COMMENTS>.
sub <CODE>output_line_to_go</CODE> {

    # <COMMENTS>debug</COMMENTS> <COMMENTS>stuff</COMMENTS>; <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>points</COMMENTS>
    <CODE>FORMATTER_DEBUG_FLAG_OUTPUT</CODE> && do {
        my ( $<CODE>a</CODE>, $<CODE>b</CODE>, $<CODE>c</CODE> ) = caller;
        <CODE>write_diagnostics</CODE>(
"<LITERALS>OUTPUT</LITERALS>: <LITERALS>output_line_to_go</LITERALS> <LITERALS>called</LITERALS>: $<CODE>a</CODE> $<CODE>c</CODE> $<CODE>last_nonblank_type</CODE> $<CODE>last_nonblank_token</CODE>, <LITERALS>one_line</LITERALS>=$<CODE>index_start_one_line_block</CODE>, <LITERALS>tokens</LITERALS> <LITERALS>to</LITERALS> <LITERALS>write</LITERALS>=$<CODE>max_index_to_go</CODE>\n"
        );
        my $<CODE>output_str</CODE> = join "", @<CODE>tokens_to_go</CODE>[ 0 .. $<CODE>max_index_to_go</CODE> ];
        <CODE>write_diagnostics</CODE>("$<CODE>output_str</CODE>\n");
    };

    # <COMMENTS>just</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>tentative</COMMENTS> <COMMENTS>breakpoint</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS>
    if ( $<CODE>index_start_one_line_block</CODE> != <CODE>UNDEFINED_INDEX</CODE> ) {
        <CODE>set_forced_breakpoint</CODE>($<CODE>max_index_to_go</CODE>);
        return;
    }

    my $<CODE>cscw_block_comment</CODE>;
    $<CODE>cscw_block_comment</CODE> = <CODE>add_closing_side_comment</CODE>()
      if ( $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>'} && $<CODE>max_index_to_go</CODE> >= 0 );

    my $<CODE>comma_arrow_count_contained</CODE> = <CODE>match_opening_and_closing_tokens</CODE>();

    # <COMMENTS>tell</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>outputting</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>batch</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>close</COMMENTS>
    # <COMMENTS>any</COMMENTS> <COMMENTS>unfinished</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>stack</COMMENTS>
    <CODE>finish_lp_batch</CODE>();

    # <COMMENTS>If</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>brace</COMMENTS>, <COMMENTS>set</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>any</COMMENTS>
    # <COMMENTS>previous</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>breakup</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS>
    # <COMMENTS>blocks</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>rare</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>for</COMMENTS>
    # <COMMENTS>user</COMMENTS>-<COMMENTS>defined</COMMENTS> <COMMENTS>subs</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>this</COMMENTS>:
    #  <COMMENTS>BOOL</COMMENTS> { <COMMENTS>$server_data</COMMENTS>{<COMMENTS>uptime</COMMENTS>} > <COMMENTS>0</COMMENTS>; } <COMMENTS>NUM</COMMENTS> { <COMMENTS>$server_data</COMMENTS>{<COMMENTS>load</COMMENTS>}; } <COMMENTS>STR</COMMENTS> {
    my $<CODE>saw_good_break</CODE> = 0;    # <COMMENTS>flag</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>line</COMMENTS>
    if (

        # <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>brace</COMMENTS>
        $<CODE>block_type_to_go</CODE>[$<CODE>max_index_to_go</CODE>]

        # <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>never</COMMENTS> <COMMENTS>duplicated</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>:
        # <COMMENTS>until</COMMENTS>|<COMMENTS>while</COMMENTS>|<COMMENTS>for</COMMENTS>|<COMMENTS>if</COMMENTS>|<COMMENTS>elsif</COMMENTS>|<COMMENTS>else</COMMENTS>
        && !$<CODE>is_block_without_semicolon</CODE>{ $<CODE>block_type_to_go</CODE>[$<CODE>max_index_to_go</CODE>] }
      )
    {
        my $<CODE>lev</CODE> = $<CODE>nesting_depth_to_go</CODE>[$<CODE>max_index_to_go</CODE>];

        # <COMMENTS>Walk</COMMENTS> <COMMENTS>backwards</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>and</COMMENTS>
        # <COMMENTS>set</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>level</COMMENTS>.
        # <COMMENTS>But</COMMENTS> <COMMENTS>quit</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>blocks</COMMENTS>.
        for ( my $<CODE>i</CODE> = $<CODE>max_index_to_go</CODE> - 1 ; $<CODE>i</CODE> >= 0 ; $<CODE>i</CODE>-- ) {
            last if ( $<CODE>levels_to_go</CODE>[$<CODE>i</CODE>] < $<CODE>lev</CODE> );    # <COMMENTS>stop</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>lower</COMMENTS> <COMMENTS>level</COMMENTS>
            next if ( $<CODE>levels_to_go</CODE>[$<CODE>i</CODE>] > $<CODE>lev</CODE> );    # <COMMENTS>skip</COMMENTS> <COMMENTS>past</COMMENTS> <COMMENTS>higher</COMMENTS> <COMMENTS>level</COMMENTS>

            if ( $<CODE>block_type_to_go</CODE>[$<CODE>i</CODE>] ) {
                if ( $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>] eq '}' ) {
                    <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>);
                    $<CODE>saw_good_break</CODE> = 1;
                }
            }

            # <COMMENTS>quit</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>anything</COMMENTS> <COMMENTS>besides</COMMENTS> <COMMENTS>words</COMMENTS>, <COMMENTS>function</COMMENTS>, <COMMENTS>blanks</COMMENTS>
            # <COMMENTS>at</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>level</COMMENTS>
            elsif ( $<CODE>types_to_go</CODE>[$<CODE>i</CODE>] !~ /^[\(\)Gwib]$/ ) { last }
        }
    }

    my $<CODE>imin</CODE> = 0;
    my $<CODE>imax</CODE> = $<CODE>max_index_to_go</CODE>;

    # <COMMENTS>trim</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>tokens</COMMENTS>
    if ( $<CODE>max_index_to_go</CODE> >= 0 ) {
        if ( $<CODE>types_to_go</CODE>[$<CODE>imin</CODE>] eq '<LITERALS>b</LITERALS>' ) { $<CODE>imin</CODE>++ }
        if ( $<CODE>types_to_go</CODE>[$<CODE>imax</CODE>] eq '<LITERALS>b</LITERALS>' ) { $<CODE>imax</CODE>-- }
    }

    # <COMMENTS>anything</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>write</COMMENTS>?
    if ( $<CODE>imin</CODE> <= $<CODE>imax</CODE> ) {

        # <COMMENTS>add</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>key</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comment</COMMENTS>
        if ( $<CODE>last_line_leading_type</CODE> !~ /^[#]/ ) {
            my $<CODE>want_blank</CODE>    = 0;
            my $<CODE>leading_token</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>imin</CODE>];
            my $<CODE>leading_type</CODE>  = $<CODE>types_to_go</CODE>[$<CODE>imin</CODE>];

            # <COMMENTS>blank</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>subs</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>declarations</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>liners</COMMENTS>
            # <COMMENTS>MCONVERSION</COMMENTS> <COMMENTS>LOCATION</COMMENTS> - <COMMENTS>for</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>tokenization</COMMENTS> <COMMENTS>change</COMMENTS>
            if ( $<CODE>leading_token</CODE> =~ /^(sub\s)/ && $<CODE>leading_type</CODE> eq '<LITERALS>i</LITERALS>' ) {
                $<CODE>want_blank</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>'}
                  if (
                    <CODE>terminal_type</CODE>( \@<CODE>types_to_go</CODE>, \@<CODE>block_type_to_go</CODE>, $<CODE>imin</CODE>,
                        $<CODE>imax</CODE> ) !~ /^[\;\}]$/
                  );
            }

            # <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>declarations</COMMENTS>
            # <COMMENTS>MCONVERSION</COMMENTS> <COMMENTS>LOCATION</COMMENTS> - <COMMENTS>for</COMMENTS> <COMMENTS>tokenizaton</COMMENTS> <COMMENTS>change</COMMENTS>
            elsif ($<CODE>leading_token</CODE> =~ /^(package\s)/
                && $<CODE>leading_type</CODE> eq '<LITERALS>i</LITERALS>' )
            {
                $<CODE>want_blank</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>packages</LITERALS>'};
            }

            # <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>key</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>liners</COMMENTS>
            if ( $<CODE>leading_token</CODE> =~ /^(BEGIN|END)$/ && $<CODE>leading_type</CODE> eq '<LITERALS>k</LITERALS>' ) {
                $<CODE>want_blank</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>subs</LITERALS>'}
                  if (
                    <CODE>terminal_type</CODE>( \@<CODE>types_to_go</CODE>, \@<CODE>block_type_to_go</CODE>, $<CODE>imin</CODE>,
                        $<CODE>imax</CODE> ) ne '}'
                  );
            }

            # <COMMENTS>Break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>haven</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>had</COMMENTS> <COMMENTS>a</COMMENTS>
            # <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>while</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>difficult</COMMENTS> <COMMENTS>decision</COMMENTS>..
            elsif ($<CODE>leading_type</CODE> eq '<LITERALS>k</LITERALS>'
                && $<CODE>last_line_leading_type</CODE> ne '<LITERALS>b</LITERALS>'
                && $<CODE>leading_token</CODE> =~ /^(unless|if|while|until|for|foreach)$/ )
            {
                my $<CODE>lc</CODE> = $<CODE>nonblank_lines_at_depth</CODE>[$<CODE>last_line_leading_level</CODE>];
                if ( !defined($<CODE>lc</CODE>) ) { $<CODE>lc</CODE> = 0 }

                $<CODE>want_blank</CODE> =
                     $<CODE>rOpts</CODE>->{'<LITERALS>blanks</LITERALS>-<LITERALS>before</LITERALS>-<LITERALS>blocks</LITERALS>'}
                  && $<CODE>lc</CODE> >= $<CODE>rOpts</CODE>->{'<LITERALS>long</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>count</LITERALS>'}
                  && $<CODE>file_writer_object</CODE>-><CODE>get_consecutive_nonblank_lines</CODE>() >=
                  $<CODE>rOpts</CODE>->{'<LITERALS>long</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>count</LITERALS>'}
                  && (
                    <CODE>terminal_type</CODE>( \@<CODE>types_to_go</CODE>, \@<CODE>block_type_to_go</CODE>, $<CODE>imin</CODE>,
                        $<CODE>imax</CODE> ) ne '}'
                  );
            }

            if ($<CODE>want_blank</CODE>) {

                # <COMMENTS>future</COMMENTS>: <COMMENTS>send</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>down</COMMENTS> <COMMENTS>normal</COMMENTS> <COMMENTS>path</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>VerticalAligner</COMMENTS>
                <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>::<CODE>flush</CODE>();
                $<CODE>file_writer_object</CODE>-><CODE>require_blank_code_lines</CODE>($<CODE>want_blank</CODE>);
            }
        }

        # <COMMENTS>update</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>variables</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>consecutive</COMMENTS>
        # <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS>, <COMMENTS>non</COMMENTS>-<COMMENTS>comment</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>level</COMMENTS>
        $<CODE>last_last_line_leading_level</CODE> = $<CODE>last_line_leading_level</CODE>;
        $<CODE>last_line_leading_level</CODE>      = $<CODE>levels_to_go</CODE>[$<CODE>imin</CODE>];
        if ( $<CODE>last_line_leading_level</CODE> < 0 ) { $<CODE>last_line_leading_level</CODE> = 0 }
        $<CODE>last_line_leading_type</CODE> = $<CODE>types_to_go</CODE>[$<CODE>imin</CODE>];
        if (   $<CODE>last_line_leading_level</CODE> == $<CODE>last_last_line_leading_level</CODE>
            && $<CODE>last_line_leading_type</CODE> ne '<LITERALS>b</LITERALS>'
            && $<CODE>last_line_leading_type</CODE> ne '#'
            && defined( $<CODE>nonblank_lines_at_depth</CODE>[$<CODE>last_line_leading_level</CODE>] ) )
        {
            $<CODE>nonblank_lines_at_depth</CODE>[$<CODE>last_line_leading_level</CODE>]++;
        }
        else {
            $<CODE>nonblank_lines_at_depth</CODE>[$<CODE>last_line_leading_level</CODE>] = 1;
        }

        <CODE>FORMATTER_DEBUG_FLAG_FLUSH</CODE> && do {
            my ( $<CODE>package</CODE>, $<CODE>file</CODE>, $<CODE>line</CODE> ) = caller;
            print <CODE>STDOUT</CODE>
"<LITERALS>FLUSH</LITERALS>: <LITERALS>flushing</LITERALS> <LITERALS>from</LITERALS> $<CODE>package</CODE> $<CODE>file</CODE> $<CODE>line</CODE>, <LITERALS>types</LITERALS>= $<CODE>types_to_go</CODE>[$<CODE>imin</CODE>] <LITERALS>to</LITERALS> $<CODE>types_to_go</CODE>[$<CODE>imax</CODE>]\n";
        };

        # <COMMENTS>add</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>couple</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>tokens</COMMENTS>
        <CODE>pad_array_to_go</CODE>();

        # <COMMENTS>set</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>forced</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>formatting</COMMENTS>
        my $<CODE>is_long_line</CODE> = <CODE>excess_line_length</CODE>( $<CODE>imin</CODE>, $<CODE>max_index_to_go</CODE> ) > 0;

        if (
               $<CODE>is_long_line</CODE>
            || $<CODE>old_line_count_in_batch</CODE> > 1

            # <COMMENTS>must</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>scan_list</COMMENTS>() <COMMENTS>with</COMMENTS> <COMMENTS>unbalanced</COMMENTS> <COMMENTS>batches</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS>
            # <COMMENTS>is</COMMENTS> <COMMENTS>maintaining</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>stacks</COMMENTS>
            || <CODE>is_unbalanced_batch</CODE>()

            # <COMMENTS>call</COMMENTS> <COMMENTS>scan_list</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>commas</COMMENTS>
            || (
                $<CODE>comma_count_in_batch</CODE>
                && (   $<CODE>rOpts_maximum_fields_per_table</CODE> > 0
                    || $<CODE>rOpts_comma_arrow_breakpoints</CODE> == 0 )
            )

            # <COMMENTS>call</COMMENTS> <COMMENTS>scan_list</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS>
            # <COMMENTS>hash</COMMENTS> <COMMENTS>references</COMMENTS>
            || (   $<CODE>comma_arrow_count_contained</CODE>
                && $<CODE>rOpts_comma_arrow_breakpoints</CODE> != 3 )
          )
        {
            ## <COMMENTS>This</COMMENTS> <COMMENTS>caused</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>unknown</COMMENTS> <COMMENTS>reasons</COMMENTS>:
            ## <COMMENTS>$saw_good_break</COMMENTS> ||= <COMMENTS>scan_list</COMMENTS>();
            my $<CODE>sgb</CODE> = <CODE>scan_list</CODE>();
            $<CODE>saw_good_break</CODE> ||= $<CODE>sgb</CODE>;
        }

        # <COMMENTS>let</COMMENTS> <COMMENTS>$ri_first</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>$ri_last</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>references</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>lists</COMMENTS> <COMMENTS>of</COMMENTS>
        # <COMMENTS>first</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>fragments</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>output</COMMENTS>..
        my ( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> );

        # <COMMENTS>write</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>if</COMMENTS>..
        if (

            # <COMMENTS>we</COMMENTS> <COMMENTS>aren</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>allowed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>newlines</COMMENTS>
            !$<CODE>rOpts_add_newlines</CODE>

            # <COMMENTS>or</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>interior</COMMENTS> <COMMENTS>breakpoint</COMMENTS>
            # <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>breakpoint</COMMENTS>
            || (
                   !$<CODE>forced_breakpoint_count</CODE>
                && !$<CODE>saw_good_break</CODE>

                # <COMMENTS>and</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> '<COMMENTS>short</COMMENTS>'
                && !$<CODE>is_long_line</CODE>
            )
          )
        {
            @$<CODE>ri_first</CODE> = ($<CODE>imin</CODE>);
            @$<CODE>ri_last</CODE>  = ($<CODE>imax</CODE>);
        }

        # <COMMENTS>otherwise</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>lines</COMMENTS>
        else {

            ( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>, my $<CODE>colon_count</CODE> ) =
              <CODE>set_continuation_breaks</CODE>($<CODE>saw_good_break</CODE>);

            <CODE>break_all_chain_tokens</CODE>( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> );

            <CODE>break_equals</CODE>( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> );

            # <COMMENTS>now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>correction</COMMENTS> <COMMENTS>step</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>clean</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bit</COMMENTS>
            # (<COMMENTS>The</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>time</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>debugging</COMMENTS>)
            if ( $<CODE>rOpts</CODE>->{'<LITERALS>recombine</LITERALS>'} ) {
                ( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> ) =
                  <CODE>recombine_breakpoints</CODE>( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> );
            }

            <CODE>insert_final_breaks</CODE>( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> ) if $<CODE>colon_count</CODE>;
        }

        # <COMMENTS>do</COMMENTS> <COMMENTS>corrector</COMMENTS> <COMMENTS>step</COMMENTS> <COMMENTS>if</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>
        my $<CODE>do_not_pad</CODE> = 0;
        if ($<CODE>rOpts_line_up_parentheses</CODE>) {
            $<CODE>do_not_pad</CODE> = <CODE>correct_lp_indentation</CODE>( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> );
        }
        <CODE>send_lines_to_vertical_aligner</CODE>( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>, $<CODE>do_not_pad</CODE> );
    }
    <CODE>prepare_for_new_input_lines</CODE>();

    # <COMMENTS>output</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>new</COMMENTS> -<COMMENTS>cscw</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comment</COMMENTS>
    if ($<CODE>cscw_block_comment</CODE>) {
        <CODE>flush</CODE>();
        $<CODE>file_writer_object</CODE>-><CODE>write_code_line</CODE>( $<CODE>cscw_block_comment</CODE> . "\n" );
    }
}

sub <CODE>note_added_semicolon</CODE> {
    $<CODE>last_added_semicolon_at</CODE> = $<CODE>input_line_number</CODE>;
    if ( $<CODE>added_semicolon_count</CODE> == 0 ) {
        $<CODE>first_added_semicolon_at</CODE> = $<CODE>last_added_semicolon_at</CODE>;
    }
    $<CODE>added_semicolon_count</CODE>++;
    <CODE>write_logfile_entry</CODE>("<LITERALS>Added</LITERALS> ';' <LITERALS>here</LITERALS>\n");
}

sub <CODE>note_deleted_semicolon</CODE> {
    $<CODE>last_deleted_semicolon_at</CODE> = $<CODE>input_line_number</CODE>;
    if ( $<CODE>deleted_semicolon_count</CODE> == 0 ) {
        $<CODE>first_deleted_semicolon_at</CODE> = $<CODE>last_deleted_semicolon_at</CODE>;
    }
    $<CODE>deleted_semicolon_count</CODE>++;
    <CODE>write_logfile_entry</CODE>("<LITERALS>Deleted</LITERALS> <LITERALS>unnecessary</LITERALS> ';'\n");    # <COMMENTS>i</COMMENTS> <COMMENTS>hope</COMMENTS> ;)
}

sub <CODE>note_embedded_tab</CODE> {
    $<CODE>embedded_tab_count</CODE>++;
    $<CODE>last_embedded_tab_at</CODE> = $<CODE>input_line_number</CODE>;
    if ( !$<CODE>first_embedded_tab_at</CODE> ) {
        $<CODE>first_embedded_tab_at</CODE> = $<CODE>last_embedded_tab_at</CODE>;
    }

    if ( $<CODE>embedded_tab_count</CODE> <= <CODE>MAX_NAG_MESSAGES</CODE> ) {
        <CODE>write_logfile_entry</CODE>("<LITERALS>Embedded</LITERALS> <LITERALS>tabs</LITERALS> <LITERALS>in</LITERALS> <LITERALS>quote</LITERALS> <LITERALS>or</LITERALS> <LITERALS>pattern</LITERALS>\n");
    }
}

sub <CODE>starting_one_line_block</CODE> {

    # <COMMENTS>after</COMMENTS> <COMMENTS>seeing</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>brace</COMMENTS>, <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>brace</COMMENTS>
    # <COMMENTS>and</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>entire</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>fit</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>is</COMMENTS>
    # <COMMENTS>not</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>uses</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>whitespace</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>check</COMMENTS>
    # <COMMENTS>is</COMMENTS> <COMMENTS>made</COMMENTS> <COMMENTS>later</COMMENTS> (<COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>brace</COMMENTS>) <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>really</COMMENTS>
    # <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>preliminary</COMMENTS> <COMMENTS>check</COMMENTS>,
    # <COMMENTS>though</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>otherwise</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>semicolon</COMMENTS>
    # <COMMENTS>within</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>contains</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>statements</COMMENTS>.

    my ( $<CODE>j</CODE>, $<CODE>jmax</CODE>, $<CODE>level</CODE>, $<CODE>slevel</CODE>, $<CODE>ci_level</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>,
        $<CODE>rblock_type</CODE> )
      = @<CODE>_</CODE>;

    # <COMMENTS>kill</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>block</COMMENTS> - <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>deep</COMMENTS>
    <CODE>destroy_one_line_block</CODE>();

    # <COMMENTS>return</COMMENTS> <COMMENTS>value</COMMENTS>:
    #  <COMMENTS>1</COMMENTS>=<COMMENTS>distance</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>exceeds</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>
    #  <COMMENTS>0</COMMENTS>=<COMMENTS>otherwise</COMMENTS>

    my $<CODE>i_start</CODE> = 0;

    # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>: <COMMENTS>there</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>prior</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>to</COMMENTS>
    # <COMMENTS>store_token_to_go</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>
    if ( $<CODE>max_index_to_go</CODE> < 0 ) {
        <CODE>warning</CODE>("<LITERALS>program</LITERALS> <LITERALS>bug</LITERALS>: <LITERALS>store_token_to_go</LITERALS> <LITERALS>called</LITERALS> <LITERALS>incorrectly</LITERALS>\n");
        <CODE>report_definite_bug</CODE>();
    }
    else {

        # <COMMENTS>cannot</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>cuddled</COMMENTS> <COMMENTS>else</COMMENTS>/<COMMENTS>elsif</COMMENTS> <COMMENTS>lines</COMMENTS>
        if ( ( $<CODE>tokens_to_go</CODE>[0] eq '}' ) && $<CODE>rOpts_cuddled_else</CODE> ) {
            return 0;
        }
    }

    my $<CODE>block_type</CODE> = $$<CODE>rblock_type</CODE>[$<CODE>j</CODE>];

    # <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>block</COMMENTS> (<COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> '<COMMENTS>if</COMMENTS>', '<COMMENTS>else</COMMENTS>', ...)

    if ( $<CODE>block_type</CODE> =~ /^[\{\}\;\:]$/ || $<CODE>block_type</CODE> =~ /^package/ ) {
        $<CODE>i_start</CODE> = $<CODE>max_index_to_go</CODE>;
    }

    # <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS>
    elsif (( $<CODE>last_last_nonblank_token_to_go</CODE> eq $<CODE>block_type</CODE> )
        || ( $<CODE>block_type</CODE> =~ /^sub/ )
        || $<CODE>block_type</CODE> =~ /\(\)/ )
    {
        $<CODE>i_start</CODE> = $<CODE>last_last_nonblank_index_to_go</CODE>;

        # <COMMENTS>Patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>signatures</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>extended</COMMENTS> <COMMENTS>syntax</COMMENTS> ...
        # <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>walk</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>to</COMMENTS>
        # <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>keyword</COMMENTS> (<COMMENTS>sub</COMMENTS>). <COMMENTS>Otherwise</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>form</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS>,
        # <COMMENTS>which</COMMENTS> <COMMENTS>stays</COMMENTS> <COMMENTS>intact</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>parenthesized</COMMENTS> <COMMENTS>expression</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS>
        # <COMMENTS>open</COMMENTS>.  <COMMENTS>That</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>bad</COMMENTS>.
        if ( $<CODE>tokens_to_go</CODE>[$<CODE>i_start</CODE>] eq ')' ) {

            # <COMMENTS>walk</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>level</COMMENTS>
            # <COMMENTS>it</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS>...
            my $<CODE>lev_want</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>i_start</CODE>];
            for ( $<CODE>i_start</CODE>-- ; $<CODE>i_start</CODE> >= 0 ; $<CODE>i_start</CODE>-- ) {
                if ( $<CODE>i_start</CODE> <= 0 ) { return 0 }
                my $<CODE>lev</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>i_start</CODE>];
                if ( $<CODE>lev</CODE> <= $<CODE>lev_want</CODE> ) {

                    # <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>error</COMMENTS>
                    if ( $<CODE>tokens_to_go</CODE>[$<CODE>i_start</CODE>] ne '(' ) { return 0 }

                    # <COMMENTS>now</COMMENTS> <COMMENTS>step</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>keyword</COMMENTS> (<COMMENTS>sub</COMMENTS>)
                    $<CODE>i_start</CODE>--;
                    if ( $<CODE>i_start</CODE> > 0 && $<CODE>types_to_go</CODE>[$<CODE>i_start</CODE>] eq '<LITERALS>b</LITERALS>' ) {
                        $<CODE>i_start</CODE>--;
                    }
                }
            }
        }
    }

    elsif ( $<CODE>last_last_nonblank_token_to_go</CODE> eq ')' ) {

        # <COMMENTS>For</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> "<COMMENTS>if</COMMENTS> (<COMMENTS>xxx</COMMENTS>) {", <COMMENTS>the</COMMENTS> <COMMENTS>keyword</COMMENTS> "<COMMENTS>if</COMMENTS>" <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS>
        # <COMMENTS>just</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>recent</COMMENTS> <COMMENTS>break</COMMENTS>. <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>0</COMMENTS> <COMMENTS>unless</COMMENTS>
        # <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>killed</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>another</COMMENTS>.
        # (<COMMENTS>doif</COMMENTS>.<COMMENTS>t</COMMENTS>)
        # <COMMENTS>Note</COMMENTS>: <COMMENTS>cannot</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>inext_index_to_go</COMMENTS>[] <COMMENTS>here</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>array</COMMENTS>
        # <COMMENTS>is</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>constructed</COMMENTS>.
        $<CODE>i_start</CODE> = $<CODE>index_max_forced_break</CODE> + 1;
        if ( $<CODE>types_to_go</CODE>[$<CODE>i_start</CODE>] eq '<LITERALS>b</LITERALS>' ) {
            $<CODE>i_start</CODE>++;
        }

        # <COMMENTS>Patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>breaking</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>extended_syntax</COMMENTS>:
        # <COMMENTS>Strip</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>trailing</COMMENTS> () <COMMENTS>which</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>added</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>parser</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>mark</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>keyword</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>
        #    <COMMENTS>create</COMMENTS>( <COMMENTS>TypeFoo</COMMENTS> <COMMENTS>$e</COMMENTS>) {<COMMENTS>$bubba</COMMENTS>}
        # <COMMENTS>the</COMMENTS> <COMMENTS>blocktype</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>marked</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>create</COMMENTS>()
        my $<CODE>stripped_block_type</CODE> = $<CODE>block_type</CODE>;
        $<CODE>stripped_block_type</CODE> =~ s/\(\)$//;

        unless ( $<CODE>tokens_to_go</CODE>[$<CODE>i_start</CODE>] eq $<CODE>stripped_block_type</CODE> ) {
            return 0;
        }
    }

    # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>retain</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>case</COMMENTS>/<COMMENTS>when</COMMENTS> <COMMENTS>blocks</COMMENTS>
    elsif ( $<CODE>block_type</CODE> eq '<LITERALS>case</LITERALS>' || $<CODE>block_type</CODE> eq '<LITERALS>when</LITERALS>' ) {

        # <COMMENTS>Note</COMMENTS>: <COMMENTS>cannot</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>inext_index_to_go</COMMENTS>[] <COMMENTS>here</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>array</COMMENTS>
        # <COMMENTS>is</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>constructed</COMMENTS>.
        $<CODE>i_start</CODE> = $<CODE>index_max_forced_break</CODE> + 1;
        if ( $<CODE>types_to_go</CODE>[$<CODE>i_start</CODE>] eq '<LITERALS>b</LITERALS>' ) {
            $<CODE>i_start</CODE>++;
        }
        unless ( $<CODE>tokens_to_go</CODE>[$<CODE>i_start</CODE>] eq $<CODE>block_type</CODE> ) {
            return 0;
        }
    }

    else {
        return 1;
    }

    my $<CODE>pos</CODE> = <CODE>total_line_length</CODE>( $<CODE>i_start</CODE>, $<CODE>max_index_to_go</CODE> ) - 1;

    my $<CODE>i</CODE>;

    # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>start</COMMENTS>
    if ( $<CODE>pos</CODE> > <CODE>maximum_line_length</CODE>($<CODE>i_start</CODE>) ) {
        return 1;
    }

    for ( $<CODE>i</CODE> = $<CODE>j</CODE> + 1 ; $<CODE>i</CODE> <= $<CODE>jmax</CODE> ; $<CODE>i</CODE>++ ) {

        # <COMMENTS>old</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>arbitrarily</COMMENTS> <COMMENTS>large</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>it</COMMENTS>
        if   ( $$<CODE>rtoken_type</CODE>[$<CODE>i</CODE>] eq '<LITERALS>b</LITERALS>' ) { $<CODE>pos</CODE> += 1 }
        else                              { $<CODE>pos</CODE> += <CODE>rtoken_length</CODE>($<CODE>i</CODE>) }

        # <COMMENTS>Return</COMMENTS> <COMMENTS>false</COMMENTS> <COMMENTS>result</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>exceed</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>,
        if ( $<CODE>pos</CODE> > <CODE>maximum_line_length</CODE>($<CODE>i_start</CODE>) ) {
            return 0;
        }

        # <COMMENTS>or</COMMENTS> <COMMENTS>encounter</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>finding</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>brace</COMMENTS>.
        elsif ($$<CODE>rtokens</CODE>[$<CODE>i</CODE>] eq '{'
            && $$<CODE>rtoken_type</CODE>[$<CODE>i</CODE>] eq '{'
            && $$<CODE>rblock_type</CODE>[$<CODE>i</CODE>] )
        {
            return 0;
        }

        # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>our</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>brace</COMMENTS>..
        elsif ($$<CODE>rtokens</CODE>[$<CODE>i</CODE>] eq '}'
            && $$<CODE>rtoken_type</CODE>[$<CODE>i</CODE>] eq '}'
            && $$<CODE>rblock_type</CODE>[$<CODE>i</CODE>] )
        {

            # <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>fits</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>
            my $<CODE>i_nonblank</CODE> =
              ( $$<CODE>rtoken_type</CODE>[ $<CODE>i</CODE> + 1 ] eq '<LITERALS>b</LITERALS>' ) ? $<CODE>i</CODE> + 2 : $<CODE>i</CODE> + 1;

            # <COMMENTS>Patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>sort</COMMENTS>/<COMMENTS>map</COMMENTS>/<COMMENTS>grep</COMMENTS>/<COMMENTS>eval</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>:
            # <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>ignore</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>sort</COMMENTS>/<COMMENTS>map</COMMENTS>/<COMMENTS>grep</COMMENTS>/<COMMENTS>eval</COMMENTS>
            # <COMMENTS>because</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>lead</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>statements</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>every</COMMENTS> <COMMENTS>time</COMMENTS>
            # <COMMENTS>perltidy</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>run</COMMENTS>.  <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>Denis</COMMENTS> <COMMENTS>Moskowitz</COMMENTS> <COMMENTS>which</COMMENTS>
            # <COMMENTS>oscillates</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>states</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>patch</COMMENTS>:

## --------
## <COMMENTS>grep</COMMENTS> { <COMMENTS>$_</COMMENTS>-><COMMENTS>foo</COMMENTS> <COMMENTS>ne</COMMENTS> '<COMMENTS>bar</COMMENTS>' } # <COMMENTS>asdfa</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS>
##  @<COMMENTS>baz</COMMENTS>;
##
## <COMMENTS>grep</COMMENTS> {
##     <COMMENTS>$_</COMMENTS>-><COMMENTS>foo</COMMENTS> <COMMENTS>ne</COMMENTS> '<COMMENTS>bar</COMMENTS>'
##   }    # <COMMENTS>asdfa</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS> <COMMENTS>asdf</COMMENTS>
##   @<COMMENTS>baz</COMMENTS>;
## --------

            # <COMMENTS>When</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>gets</COMMENTS> <COMMENTS>broken</COMMENTS> <COMMENTS>apart</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>main</COMMENTS>
            # <COMMENTS>line</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>print_line_of_tokens</COMMENTS>.
            # <COMMENTS>When</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>gets</COMMENTS> <COMMENTS>recombined</COMMENTS> <COMMENTS>by</COMMENTS>
            # <COMMENTS>print_line_of_tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>passed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>routines</COMMENTS>.  <COMMENTS>The</COMMENTS>
            # <COMMENTS>output</COMMENTS> <COMMENTS>routines</COMMENTS> (<COMMENTS>set_continuation_breaks</COMMENTS>) <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>apart</COMMENTS>
            # <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>highest</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>value</COMMENTS>
            # <COMMENTS>for</COMMENTS> <COMMENTS>grep</COMMENTS>/<COMMENTS>map</COMMENTS>/<COMMENTS>eval</COMMENTS>/<COMMENTS>sort</COMMENTS> <COMMENTS>blocks</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>gets</COMMENTS> <COMMENTS>output</COMMENTS>.
            # <COMMENTS>It</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>fix</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>changing</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS>,
            # <COMMENTS>but</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>high</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>errors</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>older</COMMENTS> <COMMENTS>versions</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS>.

            if ( $$<CODE>rtoken_type</CODE>[$<CODE>i_nonblank</CODE>] eq '#'
                && !$<CODE>is_sort_map_grep</CODE>{$<CODE>block_type</CODE>} )
            {

                $<CODE>pos</CODE> += <CODE>rtoken_length</CODE>($<CODE>i_nonblank</CODE>);

                if ( $<CODE>i_nonblank</CODE> > $<CODE>i</CODE> + 1 ) {

                    # <COMMENTS>source</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>anything</COMMENTS>, <COMMENTS>assume</COMMENTS>
                    # <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>output</COMMENTS>
                    if ( $$<CODE>rtoken_type</CODE>[ $<CODE>i</CODE> + 1 ] eq '<LITERALS>b</LITERALS>' ) { $<CODE>pos</CODE> += 1 }
                    else { $<CODE>pos</CODE> += <CODE>rtoken_length</CODE>( $<CODE>i</CODE> + 1 ) }
                }

                if ( $<CODE>pos</CODE> >= <CODE>maximum_line_length</CODE>($<CODE>i_start</CODE>) ) {
                    return 0;
                }
            }

            # <COMMENTS>ok</COMMENTS>, <COMMENTS>it</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS>
            <CODE>create_one_line_block</CODE>( $<CODE>i_start</CODE>, 20 );
            return 0;
        }

        # <COMMENTS>just</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>going</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>characters</COMMENTS>
        else {
        }
    }

    # <COMMENTS>Allow</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>form</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>joining</COMMENTS>
    # <COMMENTS>input</COMMENTS> <COMMENTS>lines</COMMENTS>.  <COMMENTS>These</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>safely</COMMENTS> <COMMENTS>done</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS>,
    # <COMMENTS>we</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>form</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>ones</COMMENTS>. <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS>
    # <COMMENTS>always</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>idea</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>possible</COMMENTS>,
    # <COMMENTS>so</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>done</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>use</COMMENTS> -<COMMENTS>mangle</COMMENTS>.
    if ( $<CODE>is_sort_map_grep_eval</CODE>{$<CODE>block_type</CODE>} ) {
        <CODE>create_one_line_block</CODE>( $<CODE>i_start</CODE>, 1 );
    }

    return 0;
}

sub <CODE>unstore_token_to_go</CODE> {

    # <COMMENTS>remove</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>recent</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>stream</COMMENTS>
    if ( $<CODE>max_index_to_go</CODE> > 0 ) {
        $<CODE>max_index_to_go</CODE>--;
    }
    else {
        $<CODE>max_index_to_go</CODE> = <CODE>UNDEFINED_INDEX</CODE>;
    }

}

sub <CODE>want_blank_line</CODE> {
    <CODE>flush</CODE>();
    $<CODE>file_writer_object</CODE>-><CODE>want_blank_line</CODE>() unless $<CODE>in_format_skipping_section</CODE>;
}

sub <CODE>write_unindented_line</CODE> {
    <CODE>flush</CODE>();
    $<CODE>file_writer_object</CODE>-><CODE>write_line</CODE>( $<CODE>_</CODE>[0] );
}

sub <CODE>undo_ci</CODE> {

    # <COMMENTS>Undo</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>sequences</COMMENTS>
    # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>undo</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>sort</COMMENTS>/<COMMENTS>map</COMMENTS>/<COMMENTS>grep</COMMENTS> <COMMENTS>chains</COMMENTS>
    #    <COMMENTS>my</COMMENTS> <COMMENTS>$dat1</COMMENTS> = <COMMENTS>pack</COMMENTS>( "<COMMENTS>n</COMMENTS>*",
    #        <COMMENTS>map</COMMENTS> { <COMMENTS>$_</COMMENTS>, <COMMENTS>$lookup</COMMENTS>->{<COMMENTS>$_</COMMENTS>} }
    #          <COMMENTS>sort</COMMENTS> { <COMMENTS>$a</COMMENTS> <=> <COMMENTS>$b</COMMENTS> }
    #          <COMMENTS>grep</COMMENTS> { <COMMENTS>$lookup</COMMENTS>->{<COMMENTS>$_</COMMENTS>} <COMMENTS>ne</COMMENTS> <COMMENTS>$default</COMMENTS> } <COMMENTS>keys</COMMENTS> %<COMMENTS>$lookup</COMMENTS> );
    # <COMMENTS>To</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>map</COMMENTS>/<COMMENTS>sort</COMMENTS>/<COMMENTS>grep</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
    #    <COMMENTS>my</COMMENTS> <COMMENTS>$dat1</COMMENTS> = <COMMENTS>pack</COMMENTS>( "<COMMENTS>n</COMMENTS>*",
    #        <COMMENTS>map</COMMENTS> { <COMMENTS>$_</COMMENTS>, <COMMENTS>$lookup</COMMENTS>->{<COMMENTS>$_</COMMENTS>} }
    #        <COMMENTS>sort</COMMENTS> { <COMMENTS>$a</COMMENTS> <=> <COMMENTS>$b</COMMENTS> }
    #        <COMMENTS>grep</COMMENTS> { <COMMENTS>$lookup</COMMENTS>->{<COMMENTS>$_</COMMENTS>} <COMMENTS>ne</COMMENTS> <COMMENTS>$default</COMMENTS> } <COMMENTS>keys</COMMENTS> %<COMMENTS>$lookup</COMMENTS> );
    my ( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> ) = @<CODE>_</CODE>;
    my ( $<CODE>line_1</CODE>, $<CODE>line_2</CODE>, $<CODE>lev_last</CODE> );
    my $<CODE>this_line_is_semicolon_terminated</CODE>;
    my $<CODE>max_line</CODE> = @$<CODE>ri_first</CODE> - 1;

    # <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>..
    # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sequence</COMMENTS>
    # <COMMENTS>all</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>higher</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>enclosing</COMMENTS> <COMMENTS>lines</COMMENTS>.
    foreach my $<CODE>line</CODE> ( 0 .. $<CODE>max_line</CODE> ) {

        my $<CODE>ibeg</CODE> = $$<CODE>ri_first</CODE>[$<CODE>line</CODE>];
        my $<CODE>lev</CODE>  = $<CODE>levels_to_go</CODE>[$<CODE>ibeg</CODE>];
        if ( $<CODE>line</CODE> > 0 ) {

            # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>started</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>chain</COMMENTS>..
            if ($<CODE>line_1</CODE>) {

                # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>continues</COMMENTS>..
                if ( $<CODE>lev</CODE> == $<CODE>lev_last</CODE> ) {
                    if (   $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq '<LITERALS>k</LITERALS>'
                        && $<CODE>is_sort_map_grep</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>ibeg</CODE>] } )
                    {

                        # <COMMENTS>chain</COMMENTS> <COMMENTS>continues</COMMENTS>...
                        # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>statement</COMMENTS>
                        if ( $<CODE>line</CODE> == $<CODE>max_line</CODE> ) {

                            # <COMMENTS>see</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>statement</COMMENTS>
                            my $<CODE>iend</CODE> = $$<CODE>ri_last</CODE>[$<CODE>line</CODE>];
                            $<CODE>this_line_is_semicolon_terminated</CODE> =
                              $<CODE>types_to_go</CODE>[$<CODE>iend</CODE>] eq ';'

                              # <COMMENTS>with</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
                              || ( $<CODE>types_to_go</CODE>[$<CODE>iend</CODE>] eq '#'
                                && $<CODE>iend</CODE> - $<CODE>ibeg</CODE> >= 2
                                && $<CODE>types_to_go</CODE>[ $<CODE>iend</CODE> - 2 ] eq ';'
                                && $<CODE>types_to_go</CODE>[ $<CODE>iend</CODE> - 1 ] eq '<LITERALS>b</LITERALS>' );
                        }
                        $<CODE>line_2</CODE> = $<CODE>line</CODE> if ($<CODE>this_line_is_semicolon_terminated</CODE>);
                    }
                    else {

                        # <COMMENTS>kill</COMMENTS> <COMMENTS>chain</COMMENTS>
                        $<CODE>line_1</CODE> = undef;
                    }
                }
                elsif ( $<CODE>lev</CODE> < $<CODE>lev_last</CODE> ) {

                    # <COMMENTS>chain</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS>
                    $<CODE>line_2</CODE> = $<CODE>line</CODE> - 1;
                }
                elsif ( $<CODE>lev</CODE> > $<CODE>lev_last</CODE> ) {

                    # <COMMENTS>kill</COMMENTS> <COMMENTS>chain</COMMENTS>
                    $<CODE>line_1</CODE> = undef;
                }

                # <COMMENTS>undo</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>ends</COMMENTS>
                if ( defined($<CODE>line_2</CODE>) && defined($<CODE>line_1</CODE>) ) {
                    my $<CODE>continuation_line_count</CODE> = $<CODE>line_2</CODE> - $<CODE>line_1</CODE> + 1;
                    @<CODE>ci_levels_to_go</CODE>[ @$<CODE>ri_first</CODE>[ $<CODE>line_1</CODE> .. $<CODE>line_2</CODE> ] ] =
                      (0) x ($<CODE>continuation_line_count</CODE>);
                    @<CODE>leading_spaces_to_go</CODE>[ @$<CODE>ri_first</CODE>[ $<CODE>line_1</CODE> .. $<CODE>line_2</CODE> ] ] =
                      @<CODE>reduced_spaces_to_go</CODE>[ @$<CODE>ri_first</CODE>[ $<CODE>line_1</CODE> .. $<CODE>line_2</CODE> ] ];
                    $<CODE>line_1</CODE> = undef;
                }
            }

            # <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>yet</COMMENTS>..
            else {

                # <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>sort</COMMENTS>/<COMMENTS>map</COMMENTS>/<COMMENTS>grep</COMMENTS> <COMMENTS>chain</COMMENTS>
                if ( $<CODE>lev</CODE> > $<CODE>lev_last</CODE> ) {
                    if (   $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq '<LITERALS>k</LITERALS>'
                        && $<CODE>is_sort_map_grep</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>ibeg</CODE>] } )
                    {
                        $<CODE>line_1</CODE> = $<CODE>line</CODE>;
                    }
                }
            }
        }
        $<CODE>lev_last</CODE> = $<CODE>lev</CODE>;
    }
}

sub <CODE>undo_lp_ci</CODE> {

    # <COMMENTS>If</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS>, <COMMENTS>long</COMMENTS> <COMMENTS>parameter</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>parens</COMMENTS>, <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
    #
    #  <COMMENTS>$self</COMMENTS>-><COMMENTS>command</COMMENTS>( "/<COMMENTS>msg</COMMENTS> "
    #        . <COMMENTS>$infoline</COMMENTS>-><COMMENTS>chan</COMMENTS>
    #        . " <COMMENTS>You</COMMENTS> <COMMENTS>said</COMMENTS> <COMMENTS>$1</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>did</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>it</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>square</COMMENTS> <COMMENTS>was</COMMENTS> "
    #        . <COMMENTS>$1</COMMENTS> * <COMMENTS>$1</COMMENTS> . " ?" );
    #
    # <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>2nd</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>higher</COMMENTS> <COMMENTS>lines</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>achieve</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>effect</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>pleasing</COMMENTS>:
    #
    #  <COMMENTS>$self</COMMENTS>-><COMMENTS>command</COMMENTS>("/<COMMENTS>msg</COMMENTS> "
    #                 . <COMMENTS>$infoline</COMMENTS>-><COMMENTS>chan</COMMENTS>
    #                 . " <COMMENTS>You</COMMENTS> <COMMENTS>said</COMMENTS> <COMMENTS>$1</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>did</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>it</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>square</COMMENTS> <COMMENTS>was</COMMENTS> "
    #                 . <COMMENTS>$1</COMMENTS> * <COMMENTS>$1</COMMENTS> . " ?");

    my ( $<CODE>line_open</CODE>, $<CODE>i_start</CODE>, $<CODE>closing_index</CODE>, $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>max_line</CODE> = @$<CODE>ri_first</CODE> - 1;

    # <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>lines</COMMENTS>
    return unless $<CODE>max_line</CODE> > $<CODE>line_open</CODE>;

    my $<CODE>lev_start</CODE>     = $<CODE>levels_to_go</CODE>[$<CODE>i_start</CODE>];
    my $<CODE>ci_start_plus</CODE> = 1 + $<CODE>ci_levels_to_go</CODE>[$<CODE>i_start</CODE>];

    # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>additional</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>continuation</COMMENTS>
    # <COMMENTS>indentation</COMMENTS>
    my $<CODE>n</CODE>;
    my $<CODE>line_1</CODE> = 1 + $<CODE>line_open</CODE>;
    for ( $<CODE>n</CODE> = $<CODE>line_1</CODE> ; $<CODE>n</CODE> <= $<CODE>max_line</CODE> ; ++$<CODE>n</CODE> ) {
        my $<CODE>ibeg</CODE> = $$<CODE>ri_first</CODE>[$<CODE>n</CODE>];
        my $<CODE>iend</CODE> = $$<CODE>ri_last</CODE>[$<CODE>n</CODE>];
        if ( $<CODE>ibeg</CODE> eq $<CODE>closing_index</CODE> ) { $<CODE>n</CODE>--; last }
        return if ( $<CODE>lev_start</CODE> != $<CODE>levels_to_go</CODE>[$<CODE>ibeg</CODE>] );
        return if ( $<CODE>ci_start_plus</CODE> != $<CODE>ci_levels_to_go</CODE>[$<CODE>ibeg</CODE>] );
        last   if ( $<CODE>closing_index</CODE> <= $<CODE>iend</CODE> );
    }

    # <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>reduce</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>lines</COMMENTS>
    my $<CODE>continuation_line_count</CODE> = $<CODE>n</CODE> - $<CODE>line_open</CODE>;
    @<CODE>ci_levels_to_go</CODE>[ @$<CODE>ri_first</CODE>[ $<CODE>line_1</CODE> .. $<CODE>n</CODE> ] ] =
      (0) x ($<CODE>continuation_line_count</CODE>);
    @<CODE>leading_spaces_to_go</CODE>[ @$<CODE>ri_first</CODE>[ $<CODE>line_1</CODE> .. $<CODE>n</CODE> ] ] =
      @<CODE>reduced_spaces_to_go</CODE>[ @$<CODE>ri_first</CODE>[ $<CODE>line_1</CODE> .. $<CODE>n</CODE> ] ];
}

sub <CODE>pad_token</CODE> {

    # <COMMENTS>insert</COMMENTS> <COMMENTS>$pad_spaces</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>$ipad</COMMENTS>
    my ( $<CODE>ipad</CODE>, $<CODE>pad_spaces</CODE> ) = @<CODE>_</CODE>;
    if ( $<CODE>pad_spaces</CODE> > 0 ) {
        $<CODE>tokens_to_go</CODE>[$<CODE>ipad</CODE>] = ' ' x $<CODE>pad_spaces</CODE> . $<CODE>tokens_to_go</CODE>[$<CODE>ipad</CODE>];
    }
    elsif ( $<CODE>pad_spaces</CODE> == -1 && $<CODE>tokens_to_go</CODE>[$<CODE>ipad</CODE>] eq ' ' ) {
        $<CODE>tokens_to_go</CODE>[$<CODE>ipad</CODE>] = "";
    }
    else {

        # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>
        return;
    }

    $<CODE>token_lengths_to_go</CODE>[$<CODE>ipad</CODE>] += $<CODE>pad_spaces</CODE>;
    for ( my $<CODE>i</CODE> = $<CODE>ipad</CODE> ; $<CODE>i</CODE> <= $<CODE>max_index_to_go</CODE> ; $<CODE>i</CODE>++ ) {
        $<CODE>summed_lengths_to_go</CODE>[ $<CODE>i</CODE> + 1 ] += $<CODE>pad_spaces</CODE>;
    }
}

{
    my %<CODE>is_math_op</CODE>;

    <CODE>BEGIN</CODE> {

        @<CODE>_</CODE> = qw( + - * / );
        @<CODE>is_math_op</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);
    }

    sub <CODE>set_logical_padding</CODE> {

        # <COMMENTS>Look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>batch</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>improve</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>alignment</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>operators</COMMENTS>. <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS>
        # <COMMENTS>example</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>introduced</COMMENTS> <COMMENTS>before</COMMENTS>
        # '( <COMMENTS>$year</COMMENTS>' <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>subsequent</COMMENTS> <COMMENTS>lines</COMMENTS>:
        #
        #       <COMMENTS>if</COMMENTS> (   ( <COMMENTS>$Year</COMMENTS> < <COMMENTS>1601</COMMENTS> )
        #           || ( <COMMENTS>$Year</COMMENTS> > <COMMENTS>2899</COMMENTS> )
        #           || ( <COMMENTS>$EndYear</COMMENTS> < <COMMENTS>1601</COMMENTS> )
        #           || ( <COMMENTS>$EndYear</COMMENTS> > <COMMENTS>2899</COMMENTS> ) )
        #       {
        #           &<COMMENTS>Error_OutOfRange</COMMENTS>;
        #       }
        #
        my ( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> ) = @<CODE>_</CODE>;
        my $<CODE>max_line</CODE> = @$<CODE>ri_first</CODE> - 1;

        my ( $<CODE>ibeg</CODE>, $<CODE>ibeg_next</CODE>, $<CODE>ibegm</CODE>, $<CODE>iend</CODE>, $<CODE>iendm</CODE>, $<CODE>ipad</CODE>, $<CODE>line</CODE>,
            $<CODE>pad_spaces</CODE>,
            $<CODE>tok_next</CODE>, $<CODE>type_next</CODE>, $<CODE>has_leading_op_next</CODE>, $<CODE>has_leading_op</CODE> );

        # <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>..
        foreach $<CODE>line</CODE> ( 0 .. $<CODE>max_line</CODE> - 1 ) {

            # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>begins</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>operator</COMMENTS>
            $<CODE>ibeg</CODE>      = $$<CODE>ri_first</CODE>[$<CODE>line</CODE>];
            $<CODE>iend</CODE>      = $$<CODE>ri_last</CODE>[$<CODE>line</CODE>];
            $<CODE>ibeg_next</CODE> = $$<CODE>ri_first</CODE>[ $<CODE>line</CODE> + 1 ];
            $<CODE>tok_next</CODE>  = $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_next</CODE>];
            $<CODE>type_next</CODE> = $<CODE>types_to_go</CODE>[$<CODE>ibeg_next</CODE>];

            $<CODE>has_leading_op_next</CODE> = ( $<CODE>tok_next</CODE> =~ /^\w/ )
              ? $<CODE>is_chain_operator</CODE>{$<CODE>tok_next</CODE>}      # + - * / : ? && ||
              : $<CODE>is_chain_operator</CODE>{$<CODE>type_next</CODE>};    # <COMMENTS>and</COMMENTS>, <COMMENTS>or</COMMENTS>

            next unless ($<CODE>has_leading_op_next</CODE>);

            # <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>lesser</COMMENTS> <COMMENTS>depth</COMMENTS>
            next
              if ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg</CODE>] >
                $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg_next</CODE>] );

            # <COMMENTS>identify</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>padded</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS>
            $<CODE>ipad</CODE> = undef;

            # <COMMENTS>handle</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>depth</COMMENTS>...
            if ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg</CODE>] ==
                $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg_next</CODE>] )
            {

                # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>batch</COMMENTS> ...
                if ( $<CODE>line</CODE> > 0 ) {

                    # <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>operator</COMMENTS>..
                    next if $<CODE>has_leading_op</CODE>;

                    # <COMMENTS>Introduce</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>if</COMMENTS>..
                    # <COMMENTS>1</COMMENTS>. <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>lesser</COMMENTS> <COMMENTS>depth</COMMENTS>, <COMMENTS>or</COMMENTS>
                    # <COMMENTS>2</COMMENTS>. <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>assignment</COMMENTS>
                    # <COMMENTS>3</COMMENTS>. <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>return</COMMENTS>'
                    # <COMMENTS>4</COMMENTS>. <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>
                    # <COMMENTS>Example</COMMENTS> <COMMENTS>1</COMMENTS>: <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>lesser</COMMENTS> <COMMENTS>depth</COMMENTS>
                    #       <COMMENTS>if</COMMENTS> (   ( <COMMENTS>$Year</COMMENTS> < <COMMENTS>1601</COMMENTS> )      # <- <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>but</COMMENTS>
                    #           || ( <COMMENTS>$Year</COMMENTS> > <COMMENTS>2899</COMMENTS> )      #  <COMMENTS>list</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>yet</COMMENTS>
                    #           || ( <COMMENTS>$EndYear</COMMENTS> < <COMMENTS>1601</COMMENTS> )   # <COMMENTS>collapsed</COMMENTS> <COMMENTS>vertically</COMMENTS>
                    #           || ( <COMMENTS>$EndYear</COMMENTS> > <COMMENTS>2899</COMMENTS> ) )
                    #       {
                    #
                    # <COMMENTS>Example</COMMENTS> <COMMENTS>2</COMMENTS>: <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>assignment</COMMENTS>:
                    #    <COMMENTS>$leapyear</COMMENTS> =
                    #        <COMMENTS>$year</COMMENTS> % <COMMENTS>4</COMMENTS>   ? <COMMENTS>0</COMMENTS>     # <- <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>here</COMMENTS>
                    #      : <COMMENTS>$year</COMMENTS> % <COMMENTS>100</COMMENTS> ? <COMMENTS>1</COMMENTS>
                    #      : <COMMENTS>$year</COMMENTS> % <COMMENTS>400</COMMENTS> ? <COMMENTS>0</COMMENTS>
                    #      : <COMMENTS>1</COMMENTS>;
                    #
                    # <COMMENTS>Example</COMMENTS> <COMMENTS>3</COMMENTS>: <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>comma</COMMENTS>:
                    #    <COMMENTS>push</COMMENTS> @<COMMENTS>expr</COMMENTS>,
                    #        /<COMMENTS>test</COMMENTS>/   ? <COMMENTS>undef</COMMENTS>
                    #      : <COMMENTS>eval</COMMENTS>(<COMMENTS>$_</COMMENTS>) ? <COMMENTS>1</COMMENTS>
                    #      : <COMMENTS>eval</COMMENTS>(<COMMENTS>$_</COMMENTS>) ? <COMMENTS>1</COMMENTS>
                    #      :            <COMMENTS>0</COMMENTS>;

                   # <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>levels</COMMENTS> <COMMENTS>agree</COMMENTS> (<COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>indent</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>indented</COMMENTS> '<COMMENTS>if</COMMENTS>')
                    next
                      if ( $<CODE>levels_to_go</CODE>[$<CODE>ibeg</CODE>] ne $<CODE>levels_to_go</CODE>[$<CODE>ibeg_next</CODE>] );

                    # <COMMENTS>allow</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS>:
                    # (<COMMENTS>1</COMMENTS>) <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>and</COMMENTS>
                    # (<COMMENTS>2</COMMENTS>) <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>three</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>and</COMMENTS>
                    # (<COMMENTS>3</COMMENTS>) <COMMENTS>lines</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>4</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>operator</COMMENTS>
                    # <COMMENTS>These</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS>
                    # <COMMENTS>comma</COMMENTS>-<COMMENTS>separated</COMMENTS> <COMMENTS>list</COMMENTS>.
                    my $<CODE>ok_comma</CODE>;
                    if (   $<CODE>types_to_go</CODE>[$<CODE>iendm</CODE>] eq ','
                        && $<CODE>line</CODE> == 1
                        && $<CODE>max_line</CODE> > 2 )
                    {
                        my $<CODE>ibeg_next_next</CODE> = $$<CODE>ri_first</CODE>[ $<CODE>line</CODE> + 2 ];
                        my $<CODE>tok_next_next</CODE>  = $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_next_next</CODE>];
                        $<CODE>ok_comma</CODE> = $<CODE>tok_next_next</CODE> eq $<CODE>tok_next</CODE>;
                    }

                    next
                      unless (
                           $<CODE>is_assignment</CODE>{ $<CODE>types_to_go</CODE>[$<CODE>iendm</CODE>] }
                        || $<CODE>ok_comma</CODE>
                        || ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibegm</CODE>] <
                            $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg</CODE>] )
                        || (   $<CODE>types_to_go</CODE>[$<CODE>iendm</CODE>] eq '<LITERALS>k</LITERALS>'
                            && $<CODE>tokens_to_go</CODE>[$<CODE>iendm</CODE>] eq '<LITERALS>return</LITERALS>' )
                      );

                    # <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS>
                    $<CODE>ipad</CODE> = $<CODE>ibeg</CODE>;
                }

                # <COMMENTS>for</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>batch</COMMENTS>..
                else {

                    # <COMMENTS>WARNING</COMMENTS>: <COMMENTS>Never</COMMENTS> <COMMENTS>indent</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS>
                    # <COMMENTS>continued</COMMENTS> <COMMENTS>quote</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>quote</COMMENTS>.
                    next if $<CODE>starting_in_quote</CODE>;

                    # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>closing</COMMENTS> '}'
                    # <COMMENTS>then</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>interior</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>pad</COMMENTS>
                    if ( $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq '}' ) {

                    }

                    # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>good</COMMENTS>
                    else {

                        # <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>$ibeg</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>it</COMMENTS>
                        # <COMMENTS>is</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS>.
                        next
                          if ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg</CODE>] !=
                            $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg_next</CODE>] );

                        # <COMMENTS>We</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>3</COMMENTS>
                        # <COMMENTS>lines</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>aligned</COMMENTS>. <COMMENTS>Otherwise</COMMENTS>, <COMMENTS>it</COMMENTS>
                        # <COMMENTS>can</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>confusing</COMMENTS>.

                 # <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>careful</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>few</COMMENTS>
                 # <COMMENTS>lines</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>is</COMMENTS>:
                 # (<COMMENTS>1</COMMENTS>) <COMMENTS>in</COMMENTS> <COMMENTS>general</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>require</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>consecutive</COMMENTS> <COMMENTS>lines</COMMENTS>
                 # <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>token</COMMENTS>,
                 # (<COMMENTS>2</COMMENTS>) <COMMENTS>but</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>exception</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>require</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS>
                 # <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>colons</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>lines</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>,
                 # <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>snippet</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>padding</COMMENTS>
                 # <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>rule</COMMENTS>:
                 #
                 #   <COMMENTS>$i</COMMENTS> == <COMMENTS>1</COMMENTS> ? ( "<COMMENTS>First</COMMENTS>", "<COMMENTS>Color</COMMENTS>" )
                 # : <COMMENTS>$i</COMMENTS> == <COMMENTS>2</COMMENTS> ? ( "<COMMENTS>Then</COMMENTS>",  "<COMMENTS>Rarity</COMMENTS>" )
                 # :           ( "<COMMENTS>Then</COMMENTS>",  "<COMMENTS>Name</COMMENTS>" );

                        if ( $<CODE>max_line</CODE> > 1 ) {
                            my $<CODE>leading_token</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_next</CODE>];
                            my $<CODE>tokens_differ</CODE>;

                            # <COMMENTS>never</COMMENTS> <COMMENTS>indent</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> '.' <COMMENTS>series</COMMENTS> <COMMENTS>because</COMMENTS>
                            # <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>likely</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>level</COMMENTS>.
                            # <COMMENTS>TODO</COMMENTS>: <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leasing_spaces</COMMENTS>
                            # <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>skip</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>same</COMMENTS>
                            # <COMMENTS>as</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>.
                            next if ( $<CODE>leading_token</CODE> eq '.' );

                            my $<CODE>count</CODE> = 1;
                            foreach my $<CODE>l</CODE> ( 2 .. 3 ) {
                                last if ( $<CODE>line</CODE> + $<CODE>l</CODE> > $<CODE>max_line</CODE> );
                                my $<CODE>ibeg_next_next</CODE> = $$<CODE>ri_first</CODE>[ $<CODE>line</CODE> + $<CODE>l</CODE> ];
                                if ( $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_next_next</CODE>] ne
                                    $<CODE>leading_token</CODE> )
                                {
                                    $<CODE>tokens_differ</CODE> = 1;
                                    last;
                                }
                                $<CODE>count</CODE>++;
                            }
                            next if ($<CODE>tokens_differ</CODE>);
                            next if ( $<CODE>count</CODE> < 3 && $<CODE>leading_token</CODE> ne ':' );
                            $<CODE>ipad</CODE> = $<CODE>ibeg</CODE>;
                        }
                        else {
                            next;
                        }
                    }
                }
            }

            # <COMMENTS>find</COMMENTS> <COMMENTS>interior</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
            if ( !defined($<CODE>ipad</CODE>) ) {

                for ( my $<CODE>i</CODE> = $<CODE>ibeg</CODE> ; ( $<CODE>i</CODE> < $<CODE>iend</CODE> ) && !$<CODE>ipad</CODE> ; $<CODE>i</CODE>++ ) {

                    # <COMMENTS>find</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>unclosed</COMMENTS> <COMMENTS>container</COMMENTS>
                    next
                      unless ( $<CODE>type_sequence_to_go</CODE>[$<CODE>i</CODE>]
                        && $<CODE>mate_index_to_go</CODE>[$<CODE>i</CODE>] > $<CODE>iend</CODE> );

                    # <COMMENTS>find</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>pad</COMMENTS>
                    $<CODE>ipad</CODE> = $<CODE>inext_to_go</CODE>[$<CODE>i</CODE>];
                    last if ( $<CODE>ipad</CODE> > $<CODE>iend</CODE> );
                }
                last unless $<CODE>ipad</CODE>;
            }

            # <COMMENTS>We</COMMENTS> <COMMENTS>cannot</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>lowest</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>because</COMMENTS>
            # <COMMENTS>it</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bug</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>indentation</COMMENTS>
            # <COMMENTS>level</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>guessed</COMMENTS> <COMMENTS>incorrectly</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>time</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>run</COMMENTS>
            # <COMMENTS>though</COMMENTS> <COMMENTS>perltidy</COMMENTS>, <COMMENTS>thus</COMMENTS> <COMMENTS>causing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>march</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>to</COMMENTS>
            # <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>snippet</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>have</COMMENTS>
            # <COMMENTS>this</COMMENTS> <COMMENTS>problem</COMMENTS>:

##     <COMMENTS>ov_method</COMMENTS> <COMMENTS>mycan</COMMENTS>( <COMMENTS>$package</COMMENTS>, '(""' ),       <COMMENTS>$package</COMMENTS>
##  <COMMENTS>or</COMMENTS> <COMMENTS>ov_method</COMMENTS> <COMMENTS>mycan</COMMENTS>( <COMMENTS>$package</COMMENTS>, '(<COMMENTS>0</COMMENTS>+' ),       <COMMENTS>$package</COMMENTS>
##  <COMMENTS>or</COMMENTS> <COMMENTS>ov_method</COMMENTS> <COMMENTS>mycan</COMMENTS>( <COMMENTS>$package</COMMENTS>, '(<COMMENTS>bool</COMMENTS>' ),     <COMMENTS>$package</COMMENTS>
##  <COMMENTS>or</COMMENTS> <COMMENTS>ov_method</COMMENTS> <COMMENTS>mycan</COMMENTS>( <COMMENTS>$package</COMMENTS>, '(<COMMENTS>nomethod</COMMENTS>' ), <COMMENTS>$package</COMMENTS>;

            # <COMMENTS>If</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>snippet</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>won</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>
            # <COMMENTS>unless</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>processes</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>snippet</COMMENTS> <COMMENTS>alone</COMMENTS> <COMMENTS>within</COMMENTS>
            # <COMMENTS>an</COMMENTS> <COMMENTS>editor</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>and</COMMENTS>
            # <COMMENTS>fix</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>corrected</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>time</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>entire</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>processed</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>perltidy</COMMENTS>.
            next if ( $<CODE>ipad</CODE> == 0 && $<CODE>levels_to_go</CODE>[$<CODE>ipad</CODE>] == 0 );

## <COMMENTS>THIS</COMMENTS> <COMMENTS>PATCH</COMMENTS> <COMMENTS>REMOVES</COMMENTS> <COMMENTS>THE</COMMENTS> <COMMENTS>FOLLOWING</COMMENTS> <COMMENTS>POOR</COMMENTS> <COMMENTS>PADDING</COMMENTS> (<COMMENTS>math</COMMENTS>.<COMMENTS>t</COMMENTS>) <COMMENTS>with</COMMENTS> -<COMMENTS>pbp</COMMENTS>, <COMMENTS>BUT</COMMENTS>
## <COMMENTS>IT</COMMENTS> <COMMENTS>DID</COMMENTS> <COMMENTS>MORE</COMMENTS> <COMMENTS>HARM</COMMENTS> <COMMENTS>THAN</COMMENTS> <COMMENTS>GOOD</COMMENTS>
##            <COMMENTS>ceil</COMMENTS>(
##                      <COMMENTS>$font</COMMENTS>->{'<COMMENTS>loca</COMMENTS>'}->{'<COMMENTS>glyphs</COMMENTS>'}[<COMMENTS>$x</COMMENTS>]-><COMMENTS>read</COMMENTS>->{'<COMMENTS>xMin</COMMENTS>'} * <COMMENTS>1000</COMMENTS>
##                    / <COMMENTS>$upem</COMMENTS>
##            ),
##?            # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>math</COMMENTS>
##?            <COMMENTS>if</COMMENTS> (   <COMMENTS>$ipad</COMMENTS> == <COMMENTS>$ibeg</COMMENTS>
##?                && <COMMENTS>$line</COMMENTS> > <COMMENTS>0</COMMENTS>
##?                && <COMMENTS>$levels_to_go</COMMENTS>[<COMMENTS>$ipad</COMMENTS>] > <COMMENTS>$levels_to_go</COMMENTS>[ <COMMENTS>$ipad</COMMENTS> - <COMMENTS>1</COMMENTS> ]
##?                && <COMMENTS>$is_math_op</COMMENTS>{<COMMENTS>$type_next</COMMENTS>}
##?                && <COMMENTS>$line</COMMENTS> + <COMMENTS>2</COMMENTS> <= <COMMENTS>$max_line</COMMENTS> )
##?            {
##?                <COMMENTS>my</COMMENTS> <COMMENTS>$ibeg_next_next</COMMENTS> = <COMMENTS>$$ri_first</COMMENTS>[ <COMMENTS>$line</COMMENTS> + <COMMENTS>2</COMMENTS> ];
##?                <COMMENTS>my</COMMENTS> <COMMENTS>$type_next_next</COMMENTS> = <COMMENTS>$types_to_go</COMMENTS>[<COMMENTS>$ibeg_next_next</COMMENTS>];
##?                <COMMENTS>next</COMMENTS> <COMMENTS>if</COMMENTS> !<COMMENTS>$is_math_op</COMMENTS>{<COMMENTS>$type_next_next</COMMENTS>};
##?            }

            # <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>greater</COMMENTS> <COMMENTS>depth</COMMENTS>
            my $<CODE>iend_next</CODE> = $$<CODE>ri_last</CODE>[ $<CODE>line</CODE> + 1 ];
            next
              if ( $<CODE>nesting_depth_to_go</CODE>[ $<CODE>iend_next</CODE> + 1 ] >
                $<CODE>nesting_depth_to_go</CODE>[$<CODE>ipad</CODE>] );

            # <COMMENTS>lines</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>somewhat</COMMENTS> <COMMENTS>similar</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>padded</COMMENTS>..
            my $<CODE>inext_next</CODE> = $<CODE>inext_to_go</CODE>[$<CODE>ibeg_next</CODE>];
            my $<CODE>type</CODE>       = $<CODE>types_to_go</CODE>[$<CODE>ipad</CODE>];
            my $<CODE>type_next</CODE>  = $<CODE>types_to_go</CODE>[ $<CODE>ipad</CODE> + 1 ];

            # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>lines</COMMENTS>
            my $<CODE>logical_continuation_lines</CODE> = 1;
            if ( $<CODE>line</CODE> + 2 <= $<CODE>max_line</CODE> ) {
                my $<CODE>leading_token</CODE>  = $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_next</CODE>];
                my $<CODE>ibeg_next_next</CODE> = $$<CODE>ri_first</CODE>[ $<CODE>line</CODE> + 2 ];
                if (   $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_next_next</CODE>] eq $<CODE>leading_token</CODE>
                    && $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg_next</CODE>] eq
                    $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg_next_next</CODE>] )
                {
                    $<CODE>logical_continuation_lines</CODE>++;
                }
            }

            # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>match</COMMENTS>
            my $<CODE>types_match</CODE> = $<CODE>types_to_go</CODE>[$<CODE>inext_next</CODE>] eq $<CODE>type</CODE>;
            my $<CODE>matches_without_bang</CODE>;

            # <COMMENTS>if</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>leading</COMMENTS> ! <COMMENTS>then</COMMENTS> <COMMENTS>compare</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>token</COMMENTS>
            if ( !$<CODE>types_match</CODE> && $<CODE>type</CODE> eq '!' ) {
                $<CODE>types_match</CODE> = $<CODE>matches_without_bang</CODE> =
                  $<CODE>types_to_go</CODE>[$<CODE>inext_next</CODE>] eq $<CODE>types_to_go</CODE>[ $<CODE>ipad</CODE> + 1 ];
            }

            if (

                # <COMMENTS>either</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>follow</COMMENTS>
                # <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS>
                ( $<CODE>logical_continuation_lines</CODE> > 1 && $<CODE>ipad</CODE> > 0 )

                # <COMMENTS>or</COMMENTS>..
                || (

                    # <COMMENTS>types</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>match</COMMENTS>
                    $<CODE>types_match</CODE>

                    # <COMMENTS>and</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>keyword</COMMENTS>
                    && !(
                           $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>'
                        && $<CODE>tokens_to_go</CODE>[$<CODE>ipad</CODE>] ne $<CODE>tokens_to_go</CODE>[$<CODE>inext_next</CODE>]
                    )
                )
              )
            {

                #----------------------<COMMENTS>begin</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>checks</COMMENTS>--------------
                #
                # <COMMENTS>SPECIAL</COMMENTS> <COMMENTS>CHECK</COMMENTS> <COMMENTS>1</COMMENTS>:
                # <COMMENTS>A</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pad</COMMENTS>.
                # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>items</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>each</COMMENTS>
                # <COMMENTS>item</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>stand</COMMENTS> <COMMENTS>out</COMMENTS>.  <COMMENTS>So</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>the</COMMENTS>
                # <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>beginning</COMMENTS> <COMMENTS>with</COMMENTS> '<COMMENTS>$casefold</COMMENTS>->' <COMMENTS>would</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>good</COMMENTS>
                # <COMMENTS>padded</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>it</COMMENTS>
                # <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>indented</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS>
                # <COMMENTS>won</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>it</COMMENTS>.
                #
                #  <COMMENTS>ok</COMMENTS>(
                #      <COMMENTS>$casefold</COMMENTS>->{<COMMENTS>code</COMMENTS>}         <COMMENTS>eq</COMMENTS> '<COMMENTS>0041</COMMENTS>'
                #        && <COMMENTS>$casefold</COMMENTS>->{<COMMENTS>status</COMMENTS>}  <COMMENTS>eq</COMMENTS> '<COMMENTS>C</COMMENTS>'
                #        && <COMMENTS>$casefold</COMMENTS>->{<COMMENTS>mapping</COMMENTS>} <COMMENTS>eq</COMMENTS> '<COMMENTS>0061</COMMENTS>',
                #      '<COMMENTS>casefold</COMMENTS> <COMMENTS>0x41</COMMENTS>'
                #  );
                #
                # <COMMENTS>Note</COMMENTS>:
                # <COMMENTS>It</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>faster</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>almost</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>good</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>
                # <COMMENTS>count</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>comma_count</COMMENTS> > <COMMENTS>1</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS>
                # <COMMENTS>line</COMMENTS> <COMMENTS>did</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>.
                #
                my $<CODE>ok_to_pad</CODE> = 1;

                my $<CODE>ibg</CODE>   = $$<CODE>ri_first</CODE>[ $<CODE>line</CODE> + 1 ];
                my $<CODE>depth</CODE> = $<CODE>nesting_depth_to_go</CODE>[ $<CODE>ibg</CODE> + 1 ];

                # <COMMENTS>just</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>simplified</COMMENTS> <COMMENTS>formula</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS>
                # <COMMENTS>needless</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>calls</COMMENTS>
                my $<CODE>lsp</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>ibg</CODE>] + $<CODE>ci_levels_to_go</CODE>[$<CODE>ibg</CODE>];

                # <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>beyond</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> ..
                my $<CODE>l</CODE> = $<CODE>line</CODE> + 1;
                foreach $<CODE>l</CODE> ( $<CODE>line</CODE> + 2 .. $<CODE>max_line</CODE> ) {
                    my $<CODE>ibg</CODE> = $$<CODE>ri_first</CODE>[$<CODE>l</CODE>];

                    # <COMMENTS>quit</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>container</COMMENTS>
                    last
                      if ( $<CODE>nesting_depth_to_go</CODE>[ $<CODE>ibg</CODE> + 1 ] < $<CODE>depth</CODE> )
                      || ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibg</CODE>] < $<CODE>depth</CODE> );

                    # <COMMENTS>cannot</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS>
                    # <COMMENTS>outdented</COMMENTS> <COMMENTS>more</COMMENTS>
                    if ( $<CODE>levels_to_go</CODE>[$<CODE>ibg</CODE>] + $<CODE>ci_levels_to_go</CODE>[$<CODE>ibg</CODE>] < $<CODE>lsp</CODE> ) {
                        $<CODE>ok_to_pad</CODE> = 0;
                        last;
                    }
                }

                # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>broken</COMMENTS> <COMMENTS>list</COMMENTS>
                if ( $<CODE>l</CODE> == $<CODE>max_line</CODE> ) {
                    my $<CODE>i2</CODE> = $$<CODE>ri_last</CODE>[$<CODE>l</CODE>];
                    if ( $<CODE>types_to_go</CODE>[$<CODE>i2</CODE>] eq '#' ) {
                        my $<CODE>i1</CODE> = $$<CODE>ri_first</CODE>[$<CODE>l</CODE>];
                        next
                          if (
                            <CODE>terminal_type</CODE>( \@<CODE>types_to_go</CODE>, \@<CODE>block_type_to_go</CODE>,
                                $<CODE>i1</CODE>, $<CODE>i2</CODE> ) eq ','
                          );
                    }
                }

                # <COMMENTS>SPECIAL</COMMENTS> <COMMENTS>CHECK</COMMENTS> <COMMENTS>2</COMMENTS>:
                # <COMMENTS>a</COMMENTS> <COMMENTS>minus</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>introduce</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>variable</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS>
                # <COMMENTS>add</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>begins</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS>,
                # <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>word</COMMENTS> '<COMMENTS>Button</COMMENTS>' <COMMENTS>here</COMMENTS>:
                #    [
                #         <COMMENTS>Button</COMMENTS>      => "<COMMENTS>Print</COMMENTS> <COMMENTS>letter</COMMENTS> \"~<COMMENTS>$_</COMMENTS>\"",
                #        -<COMMENTS>command</COMMENTS>     => [ <COMMENTS>sub</COMMENTS> { <COMMENTS>print</COMMENTS> "<COMMENTS>$_</COMMENTS>[<COMMENTS>0</COMMENTS>]\<COMMENTS>n</COMMENTS>" }, <COMMENTS>$_</COMMENTS> ],
                #        -<COMMENTS>accelerator</COMMENTS> => "<COMMENTS>Meta</COMMENTS>+<COMMENTS>$_</COMMENTS>"
                #    ];
                #
                #  <COMMENTS>On</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>hand</COMMENTS>, <COMMENTS>if</COMMENTS> '<COMMENTS>Button</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>quoted</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>best</COMMENTS>
                #  <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>pad</COMMENTS>:
                #    [
                #        '<COMMENTS>Button</COMMENTS>'     => "<COMMENTS>Print</COMMENTS> <COMMENTS>letter</COMMENTS> \"~<COMMENTS>$_</COMMENTS>\"",
                #        -<COMMENTS>command</COMMENTS>     => [ <COMMENTS>sub</COMMENTS> { <COMMENTS>print</COMMENTS> "<COMMENTS>$_</COMMENTS>[<COMMENTS>0</COMMENTS>]\<COMMENTS>n</COMMENTS>" }, <COMMENTS>$_</COMMENTS> ],
                #        -<COMMENTS>accelerator</COMMENTS> => "<COMMENTS>Meta</COMMENTS>+<COMMENTS>$_</COMMENTS>"
                #    ];
                if ( $<CODE>types_to_go</CODE>[$<CODE>ibeg_next</CODE>] eq '<LITERALS>m</LITERALS>' ) {
                    $<CODE>ok_to_pad</CODE> = 0 if $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq '<LITERALS>Q</LITERALS>';
                }

                next unless $<CODE>ok_to_pad</CODE>;

                #----------------------<COMMENTS>end</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>check</COMMENTS>---------------

                my $<CODE>length_1</CODE> = <CODE>total_line_length</CODE>( $<CODE>ibeg</CODE>,      $<CODE>ipad</CODE> - 1 );
                my $<CODE>length_2</CODE> = <CODE>total_line_length</CODE>( $<CODE>ibeg_next</CODE>, $<CODE>inext_next</CODE> - 1 );
                $<CODE>pad_spaces</CODE> = $<CODE>length_2</CODE> - $<CODE>length_1</CODE>;

                # <COMMENTS>If</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS> ! <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>does</COMMENTS>
                # <COMMENTS>not</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS>
                # <COMMENTS>leading</COMMENTS> <COMMENTS>characters</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>often</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>:
                #  <COMMENTS>if</COMMENTS> (  !<COMMENTS>$ts</COMMENTS>
                #      || <COMMENTS>$ts</COMMENTS> == <COMMENTS>$self</COMMENTS>-><COMMENTS>Holder</COMMENTS>
                #      || <COMMENTS>$self</COMMENTS>-><COMMENTS>Holder</COMMENTS>-><COMMENTS>Type</COMMENTS> <COMMENTS>eq</COMMENTS> "<COMMENTS>Arena</COMMENTS>" )
                #
                # <COMMENTS>This</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>helps</COMMENTS> <COMMENTS>readability</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>subsequent</COMMENTS>
                # ! <COMMENTS>operators</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>messed</COMMENTS> <COMMENTS>up</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>:
                #
                #  <COMMENTS>if</COMMENTS> (  !<COMMENTS>exists</COMMENTS> <COMMENTS>$Net</COMMENTS>::<COMMENTS>DNS</COMMENTS>::<COMMENTS>typesbyname</COMMENTS>{<COMMENTS>$qtype</COMMENTS>}
                #      && <COMMENTS>exists</COMMENTS> <COMMENTS>$Net</COMMENTS>::<COMMENTS>DNS</COMMENTS>::<COMMENTS>classesbyname</COMMENTS>{<COMMENTS>$qtype</COMMENTS>}
                #      && !<COMMENTS>exists</COMMENTS> <COMMENTS>$Net</COMMENTS>::<COMMENTS>DNS</COMMENTS>::<COMMENTS>classesbyname</COMMENTS>{<COMMENTS>$qclass</COMMENTS>}
                #      && <COMMENTS>exists</COMMENTS> <COMMENTS>$Net</COMMENTS>::<COMMENTS>DNS</COMMENTS>::<COMMENTS>typesbyname</COMMENTS>{<COMMENTS>$qclass</COMMENTS>} )
                # <COMMENTS>We</COMMENTS> <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>fix</COMMENTS> <COMMENTS>that</COMMENTS>.
                if ($<CODE>matches_without_bang</CODE>) { $<CODE>pad_spaces</CODE>-- }

                # <COMMENTS>make</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>won</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>if</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>
                my $<CODE>indentation_1</CODE> = $<CODE>leading_spaces_to_go</CODE>[$<CODE>ibeg</CODE>];
                if ( ref($<CODE>indentation_1</CODE>) ) {
                    if ( $<CODE>indentation_1</CODE>-><CODE>get_RECOVERABLE_SPACES</CODE>() == 0 ) {
                        my $<CODE>indentation_2</CODE> = $<CODE>leading_spaces_to_go</CODE>[$<CODE>ibeg_next</CODE>];
                        unless ( $<CODE>indentation_2</CODE>-><CODE>get_RECOVERABLE_SPACES</CODE>() == 0 )
                        {
                            $<CODE>pad_spaces</CODE> = 0;
                        }
                    }
                }

                # <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>able</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pad</COMMENTS> <COMMENTS>of</COMMENTS> -<COMMENTS>1</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>removing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS>
                # <COMMENTS>token</COMMENTS>
                if ( $<CODE>pad_spaces</CODE> < 0 ) {

                    if ( $<CODE>pad_spaces</CODE> == -1 ) {
                        if ( $<CODE>ipad</CODE> > $<CODE>ibeg</CODE> && $<CODE>types_to_go</CODE>[ $<CODE>ipad</CODE> - 1 ] eq '<LITERALS>b</LITERALS>' )
                        {
                            <CODE>pad_token</CODE>( $<CODE>ipad</CODE> - 1, $<CODE>pad_spaces</CODE> );
                        }
                    }
                    $<CODE>pad_spaces</CODE> = 0;
                }

                # <COMMENTS>now</COMMENTS> <COMMENTS>apply</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>alignment</COMMENTS>
                if ( $<CODE>ipad</CODE> >= 0 && $<CODE>pad_spaces</CODE> ) {

                    my $<CODE>length_t</CODE> = <CODE>total_line_length</CODE>( $<CODE>ibeg</CODE>, $<CODE>iend</CODE> );
                    if ( $<CODE>pad_spaces</CODE> + $<CODE>length_t</CODE> <= <CODE>maximum_line_length</CODE>($<CODE>ibeg</CODE>) )
                    {
                        <CODE>pad_token</CODE>( $<CODE>ipad</CODE>, $<CODE>pad_spaces</CODE> );
                    }
                }
            }
        }
        continue {
            $<CODE>iendm</CODE>          = $<CODE>iend</CODE>;
            $<CODE>ibegm</CODE>          = $<CODE>ibeg</CODE>;
            $<CODE>has_leading_op</CODE> = $<CODE>has_leading_op_next</CODE>;
        }    # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>lines</COMMENTS>
        return;
    }
}

sub <CODE>correct_lp_indentation</CODE> {

    # <COMMENTS>When</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>pass</COMMENTS> <COMMENTS>through</COMMENTS>
    # <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>correct</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>positions</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>differ</COMMENTS>
    # <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>predictions</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>uses</COMMENTS> <COMMENTS>a</COMMENTS>
    # <COMMENTS>predictor</COMMENTS>/<COMMENTS>corrector</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>aligning</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>parens</COMMENTS>.  <COMMENTS>The</COMMENTS>
    # <COMMENTS>predictor</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>good</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>sometimes</COMMENTS> <COMMENTS>stumbles</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>corrector</COMMENTS>
    # <COMMENTS>tries</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>once</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>locations</COMMENTS>
    # <COMMENTS>are</COMMENTS> <COMMENTS>known</COMMENTS>.
    my ( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>do_not_pad</CODE> = 0;

    #  <COMMENTS>Note</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>flag</COMMENTS> '<COMMENTS>$do_not_pad</COMMENTS>':
    #  <COMMENTS>We</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>situation</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>, <COMMENTS>where</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>aligner</COMMENTS> <COMMENTS>inserts</COMMENTS>
    #  <COMMENTS>whitespace</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> '=' <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>previous</COMMENTS> '=', <COMMENTS>because</COMMENTS>
    #  <COMMENTS>otherwise</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>become</COMMENTS> <COMMENTS>mis</COMMENTS>-<COMMENTS>aligned</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>situation</COMMENTS> <COMMENTS>like</COMMENTS>
    #  <COMMENTS>this</COMMENTS>, <COMMENTS>where</COMMENTS> <COMMENTS>the</COMMENTS> '=' <COMMENTS>has</COMMENTS> <COMMENTS>become</COMMENTS> <COMMENTS>aligned</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS>,
    #  <COMMENTS>pushing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> '(' <COMMENTS>forward</COMMENTS> <COMMENTS>beyond</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>it</COMMENTS>.
    #
    #  <COMMENTS>$mkFloor</COMMENTS>::<COMMENTS>currentRoom</COMMENTS> = '';
    #  <COMMENTS>$mkFloor</COMMENTS>::<COMMENTS>c_entry</COMMENTS>     = <COMMENTS>$c</COMMENTS>-><COMMENTS>Entry</COMMENTS>(
    #                                 -<COMMENTS>width</COMMENTS>        => '<COMMENTS>10</COMMENTS>',
    #                                 -<COMMENTS>relief</COMMENTS>       => '<COMMENTS>sunken</COMMENTS>',
    #                                 ...
    #                                 );
    #
    #  <COMMENTS>We</COMMENTS> <COMMENTS>leave</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>aligner</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS>.

    # <COMMENTS>first</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>appropriate</COMMENTS>
    my $<CODE>max_line</CODE> = @$<CODE>ri_first</CODE> - 1;

    # <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>..
    my ( $<CODE>ibeg</CODE>, $<CODE>iend</CODE> );
    my $<CODE>line</CODE>;
    foreach $<CODE>line</CODE> ( 0 .. $<CODE>max_line</CODE> ) {
        $<CODE>ibeg</CODE> = $$<CODE>ri_first</CODE>[$<CODE>line</CODE>];
        $<CODE>iend</CODE> = $$<CODE>ri_last</CODE>[$<CODE>line</CODE>];

        # <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>line</COMMENTS>..
        my $<CODE>i</CODE>;
        foreach $<CODE>i</CODE> ( $<CODE>ibeg</CODE> .. $<CODE>iend</CODE> ) {

            # <COMMENTS>How</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>place</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS>
            # <COMMENTS>for</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>alignment</COMMENTS>.  <COMMENTS>Actual</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>continue</COMMENTS> <COMMENTS>block</COMMENTS>.

            # <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>unvisited</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>item</COMMENTS>
            my $<CODE>indentation</CODE> = $<CODE>leading_spaces_to_go</CODE>[$<CODE>i</CODE>];
            if ( !$<CODE>indentation</CODE>-><CODE>get_MARKED</CODE>() ) {
                $<CODE>indentation</CODE>-><CODE>set_MARKED</CODE>(1);

                # <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>aligning</COMMENTS>
                # <COMMENTS>with</COMMENTS> <COMMENTS>parens</COMMENTS>, <COMMENTS>braces</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>brackets</COMMENTS>
                next unless ( $<CODE>indentation</CODE>-><CODE>get_ALIGN_PAREN</CODE>() );

                # <COMMENTS>skip</COMMENTS> <COMMENTS>closed</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
                if ( $<CODE>i</CODE> > $<CODE>ibeg</CODE> ) {
                    my $<CODE>im</CODE> = <CODE>max</CODE>( $<CODE>ibeg</CODE>, $<CODE>iprev_to_go</CODE>[$<CODE>i</CODE>] );
                    if (   $<CODE>type_sequence_to_go</CODE>[$<CODE>im</CODE>]
                        && $<CODE>mate_index_to_go</CODE>[$<CODE>im</CODE>] <= $<CODE>iend</CODE> )
                    {
                        next;
                    }
                }

                if ( $<CODE>line</CODE> == 1 && $<CODE>i</CODE> == $<CODE>ibeg</CODE> ) {
                    $<CODE>do_not_pad</CODE> = 1;
                }

                # <COMMENTS>Ok</COMMENTS>, <COMMENTS>let</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>fix</COMMENTS> <COMMENTS>it</COMMENTS>
                my $<CODE>actual_pos</CODE>;
                my $<CODE>predicted_pos</CODE> = $<CODE>indentation</CODE>-><CODE>get_SPACES</CODE>();
                if ( $<CODE>i</CODE> > $<CODE>ibeg</CODE> ) {

                    # <COMMENTS>token</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>mid</COMMENTS>-<COMMENTS>line</COMMENTS> - <COMMENTS>use</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS>
                    $<CODE>actual_pos</CODE> = <CODE>total_line_length</CODE>( $<CODE>ibeg</CODE>, $<CODE>i</CODE> - 1 );

                    # <COMMENTS>for</COMMENTS> <COMMENTS>mid</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>all</COMMENTS>
                    # <COMMENTS>additional</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS>,
                    # <COMMENTS>and</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>so</COMMENTS>.  <COMMENTS>Otherwise</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>get</COMMENTS>
                    # <COMMENTS>good</COMMENTS> <COMMENTS>alignment</COMMENTS>.
                    my $<CODE>closing_index</CODE> = $<CODE>indentation</CODE>-><CODE>get_CLOSED</CODE>();
                    if ( $<CODE>closing_index</CODE> > $<CODE>iend</CODE> ) {
                        my $<CODE>ibeg_next</CODE> = $$<CODE>ri_first</CODE>[ $<CODE>line</CODE> + 1 ];
                        if ( $<CODE>ci_levels_to_go</CODE>[$<CODE>ibeg_next</CODE>] > 0 ) {
                            <CODE>undo_lp_ci</CODE>( $<CODE>line</CODE>, $<CODE>i</CODE>, $<CODE>closing_index</CODE>, $<CODE>ri_first</CODE>,
                                $<CODE>ri_last</CODE> );
                        }
                    }
                }
                elsif ( $<CODE>line</CODE> > 0 ) {

                    # <COMMENTS>handle</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>starts</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>;
                    # <COMMENTS>use</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS>
                    my $<CODE>ibegm</CODE> = $$<CODE>ri_first</CODE>[ $<CODE>line</CODE> - 1 ];
                    my $<CODE>iendm</CODE> = $$<CODE>ri_last</CODE>[ $<CODE>line</CODE> - 1 ];
                    $<CODE>actual_pos</CODE> = <CODE>total_line_length</CODE>( $<CODE>ibegm</CODE>, $<CODE>iendm</CODE> );

                    # <COMMENTS>follow</COMMENTS> -<COMMENTS>pt</COMMENTS> <COMMENTS>style</COMMENTS>
                    ++$<CODE>actual_pos</CODE>
                      if ( $<CODE>types_to_go</CODE>[ $<CODE>iendm</CODE> + 1 ] eq '<LITERALS>b</LITERALS>' );
                }
                else {

                    # <COMMENTS>token</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>batch</COMMENTS>
                    $<CODE>actual_pos</CODE> = $<CODE>predicted_pos</CODE>;
                }

                my $<CODE>move_right</CODE> = $<CODE>actual_pos</CODE> - $<CODE>predicted_pos</CODE>;

                # <COMMENTS>done</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>correct</COMMENTS> (<COMMENTS>gnu2</COMMENTS>.<COMMENTS>t</COMMENTS>)
                if ( $<CODE>move_right</CODE> == 0 ) {
                    $<CODE>indentation</CODE>-><CODE>set_RECOVERABLE_SPACES</CODE>($<CODE>move_right</CODE>);
                    next;
                }

                # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>seen</COMMENTS> <COMMENTS>closure</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>in</COMMENTS>
                # <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>pass</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>request</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS>
                # <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS>
                my $<CODE>closing_index</CODE> = $<CODE>indentation</CODE>-><CODE>get_CLOSED</CODE>();

                if ( $<CODE>closing_index</CODE> < 0 ) {
                    $<CODE>indentation</CODE>-><CODE>set_RECOVERABLE_SPACES</CODE>($<CODE>move_right</CODE>);
                    next;
                }

                # <COMMENTS>If</COMMENTS> <COMMENTS>necessary</COMMENTS>, <COMMENTS>look</COMMENTS> <COMMENTS>ahead</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>any</COMMENTS>
                # <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>dependent</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>whitespace</COMMENTS>, <COMMENTS>and</COMMENTS>
                # <COMMENTS>also</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>longest</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>using</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>whitespace</COMMENTS>.
                # <COMMENTS>Since</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>safe</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>move</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>no</COMMENTS>
                # <COMMENTS>dependents</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS>
                # <COMMENTS>dependent</COMMENTS> <COMMENTS>nodes</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>move</COMMENTS> <COMMENTS>right</COMMENTS>.

                my $<CODE>right_margin</CODE> = 0;
                my $<CODE>have_child</CODE>   = $<CODE>indentation</CODE>-><CODE>get_HAVE_CHILD</CODE>();

                my %<CODE>saw_indentation</CODE>;
                my $<CODE>line_count</CODE> = 1;
                $<CODE>saw_indentation</CODE>{$<CODE>indentation</CODE>} = $<CODE>indentation</CODE>;

                if ( $<CODE>have_child</CODE> || $<CODE>move_right</CODE> > 0 ) {
                    $<CODE>have_child</CODE> = 0;
                    my $<CODE>max_length</CODE> = 0;
                    if ( $<CODE>i</CODE> == $<CODE>ibeg</CODE> ) {
                        $<CODE>max_length</CODE> = <CODE>total_line_length</CODE>( $<CODE>ibeg</CODE>, $<CODE>iend</CODE> );
                    }

                    # <COMMENTS>look</COMMENTS> <COMMENTS>ahead</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>rest</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>..
                    my $<CODE>line_t</CODE>;
                    foreach $<CODE>line_t</CODE> ( $<CODE>line</CODE> + 1 .. $<CODE>max_line</CODE> ) {
                        my $<CODE>ibeg_t</CODE> = $$<CODE>ri_first</CODE>[$<CODE>line_t</CODE>];
                        my $<CODE>iend_t</CODE> = $$<CODE>ri_last</CODE>[$<CODE>line_t</CODE>];
                        last if ( $<CODE>closing_index</CODE> <= $<CODE>ibeg_t</CODE> );

                        # <COMMENTS>remember</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>objects</COMMENTS>
                        my $<CODE>indentation_t</CODE> = $<CODE>leading_spaces_to_go</CODE>[$<CODE>ibeg_t</CODE>];
                        $<CODE>saw_indentation</CODE>{$<CODE>indentation_t</CODE>} = $<CODE>indentation_t</CODE>;
                        $<CODE>line_count</CODE>++;

                        # <COMMENTS>remember</COMMENTS> <COMMENTS>longest</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>group</COMMENTS>
                        my $<CODE>length_t</CODE> = <CODE>total_line_length</CODE>( $<CODE>ibeg_t</CODE>, $<CODE>iend_t</CODE> );
                        if ( $<CODE>length_t</CODE> > $<CODE>max_length</CODE> ) {
                            $<CODE>max_length</CODE> = $<CODE>length_t</CODE>;
                        }
                    }
                    $<CODE>right_margin</CODE> = <CODE>maximum_line_length</CODE>($<CODE>ibeg</CODE>) - $<CODE>max_length</CODE>;
                    if ( $<CODE>right_margin</CODE> < 0 ) { $<CODE>right_margin</CODE> = 0 }
                }

                my $<CODE>first_line_comma_count</CODE> =
                  grep { $<CODE>_</CODE> eq ',' } @<CODE>types_to_go</CODE>[ $<CODE>ibeg</CODE> .. $<CODE>iend</CODE> ];
                my $<CODE>comma_count</CODE> = $<CODE>indentation</CODE>-><CODE>get_COMMA_COUNT</CODE>();
                my $<CODE>arrow_count</CODE> = $<CODE>indentation</CODE>-><CODE>get_ARROW_COUNT</CODE>();

                # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>approximate</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS>:
                # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>broke</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS>, <COMMENTS>brace</COMMENTS>, <COMMENTS>bracket</COMMENTS>,
                # <COMMENTS>and</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS>,
                # <COMMENTS>and</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>no</COMMENTS> '=>'<COMMENTS>s</COMMENTS>,
                # <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>vertically</COMMENTS> <COMMENTS>aligned</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>set</COMMENTS>
                # <COMMENTS>an</COMMENTS> <COMMENTS>exact</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>scan_list</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>good</COMMENTS>
                # <COMMENTS>enough</COMMENTS>.
                my $<CODE>indentation_count</CODE> = keys %<CODE>saw_indentation</CODE>;
                my $<CODE>is_vertically_aligned</CODE> =
                  (      $<CODE>i</CODE> == $<CODE>ibeg</CODE>
                      && $<CODE>first_line_comma_count</CODE> > 1
                      && $<CODE>indentation_count</CODE> == 1
                      && ( $<CODE>arrow_count</CODE> == 0 || $<CODE>arrow_count</CODE> == $<CODE>line_count</CODE> ) );

                # <COMMENTS>Make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>move</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>possible</COMMENTS> ..
                if (

                    # <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>move</COMMENTS> <COMMENTS>left</COMMENTS>
                    $<CODE>move_right</CODE> < 0

                    # <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>move</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS>
                    # <COMMENTS>not</COMMENTS> <COMMENTS>spoil</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS>
                    || ( $<CODE>comma_count</CODE> == 0 )
                    || ( $<CODE>comma_count</CODE> > 0 && !$<CODE>is_vertically_aligned</CODE> )
                  )
                {
                    my $<CODE>move</CODE> =
                      ( $<CODE>move_right</CODE> <= $<CODE>right_margin</CODE> )
                      ? $<CODE>move_right</CODE>
                      : $<CODE>right_margin</CODE>;

                    foreach ( keys %<CODE>saw_indentation</CODE> ) {
                        $<CODE>saw_indentation</CODE>{$<CODE>_</CODE>}
                          -><CODE>permanently_decrease_AVAILABLE_SPACES</CODE>( -$<CODE>move</CODE> );
                    }
                }

                # <COMMENTS>Otherwise</COMMENTS>, <COMMENTS>record</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS>
                # <COMMENTS>will</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>recover</COMMENTS> <COMMENTS>it</COMMENTS>.
                else {
                    $<CODE>indentation</CODE>-><CODE>set_RECOVERABLE_SPACES</CODE>($<CODE>move_right</CODE>);
                }
            }
        }
    }
    return $<CODE>do_not_pad</CODE>;
}

# <COMMENTS>flush</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pipeline</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS>
# <COMMENTS>an</COMMENTS> <COMMENTS>alternate</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>written</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>correct</COMMENTS> <COMMENTS>order</COMMENTS>

sub <CODE>flush</CODE> {
    <CODE>destroy_one_line_block</CODE>();
    <CODE>output_line_to_go</CODE>();
    <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>::<CODE>flush</CODE>();
}

sub <CODE>reset_block_text_accumulator</CODE> {

    # <COMMENTS>save</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>after</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>elsif</COMMENTS>' <COMMENTS>to</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>after</COMMENTS> '<COMMENTS>else</COMMENTS>'
    if ($<CODE>accumulating_text_for_block</CODE>) {

        if ( $<CODE>accumulating_text_for_block</CODE> =~ /^(if|elsif)$/ ) {
            push @{$<CODE>rleading_block_if_elsif_text</CODE>}, $<CODE>leading_block_text</CODE>;
        }
    }
    $<CODE>accumulating_text_for_block</CODE>        = "";
    $<CODE>leading_block_text</CODE>                 = "";
    $<CODE>leading_block_text_level</CODE>           = 0;
    $<CODE>leading_block_text_length_exceeded</CODE> = 0;
    $<CODE>leading_block_text_line_number</CODE>     = 0;
    $<CODE>leading_block_text_line_length</CODE>     = 0;
}

sub <CODE>set_block_text_accumulator</CODE> {
    my $<CODE>i</CODE> = shift;
    $<CODE>accumulating_text_for_block</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>];
    if ( $<CODE>accumulating_text_for_block</CODE> !~ /^els/ ) {
        $<CODE>rleading_block_if_elsif_text</CODE> = [];
    }
    $<CODE>leading_block_text</CODE>       = "";
    $<CODE>leading_block_text_level</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>i</CODE>];
    $<CODE>leading_block_text_line_number</CODE> =
      $<CODE>vertical_aligner_object</CODE>-><CODE>get_output_line_number</CODE>();
    $<CODE>leading_block_text_length_exceeded</CODE> = 0;

    # <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>contain</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>character</COMMENTS>
    # <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
    $<CODE>leading_block_text_line_length</CODE> =
      length($<CODE>csc_last_label</CODE>) +
      length($<CODE>accumulating_text_for_block</CODE>) +
      length( $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>prefix</LITERALS>'} ) +
      $<CODE>leading_block_text_level</CODE> * $<CODE>rOpts_indent_columns</CODE> + 3;
}

sub <CODE>accumulate_block_text</CODE> {
    my $<CODE>i</CODE> = shift;

    # <COMMENTS>accumulate</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>for</COMMENTS> -<COMMENTS>csc</COMMENTS>, <COMMENTS>ignoring</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>
    if (   $<CODE>accumulating_text_for_block</CODE>
        && !$<CODE>leading_block_text_length_exceeded</CODE>
        && $<CODE>types_to_go</CODE>[$<CODE>i</CODE>] ne '#' )
    {

        my $<CODE>added_length</CODE> = $<CODE>token_lengths_to_go</CODE>[$<CODE>i</CODE>];
        $<CODE>added_length</CODE> += 1 if $<CODE>i</CODE> == 0;
        my $<CODE>new_line_length</CODE> = $<CODE>leading_block_text_line_length</CODE> + $<CODE>added_length</CODE>;

        # <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>exceed</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>limits</COMMENTS>..
        if (

            # <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>exceeded</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>limit</COMMENTS>
            length($<CODE>leading_block_text</CODE>) <
            $<CODE>rOpts_closing_side_comment_maximum_text</CODE>

            # <COMMENTS>and</COMMENTS> <COMMENTS>either</COMMENTS>:
            # <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>limit</COMMENTS>
            # <COMMENTS>or</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>limit</COMMENTS>
            # (<COMMENTS>ie</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>exceed</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>limit</COMMENTS>)
            && (
                $<CODE>new_line_length</CODE> <
                <CODE>maximum_line_length_for_level</CODE>($<CODE>leading_block_text_level</CODE>)

                || length($<CODE>leading_block_text</CODE>) + $<CODE>added_length</CODE> <
                $<CODE>rOpts_closing_side_comment_maximum_text</CODE>
            )

            # <COMMENTS>UNLESS</COMMENTS>: <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>seek</COMMENTS>.
            # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>attempt</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>situations</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>the</COMMENTS> ... <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS>
            # <COMMENTS>added</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>longer</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>omitted</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>paren</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS>:

            #   <COMMENTS>foreach</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>$item</COMMENTS> (@<COMMENTS>a_rather_long_variable_name_here</COMMENTS>) {
            #      &<COMMENTS>whatever</COMMENTS>;
            #   } ## <COMMENTS>end</COMMENTS> <COMMENTS>foreach</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>$item</COMMENTS> (@<COMMENTS>a_rather_long_variable_name_here</COMMENTS>...

            || (
                $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>] eq ')'
                && (
                    (
                           $<CODE>i</CODE> + 1 <= $<CODE>max_index_to_go</CODE>
                        && $<CODE>block_type_to_go</CODE>[ $<CODE>i</CODE> + 1 ] eq
                        $<CODE>accumulating_text_for_block</CODE>
                    )
                    || (   $<CODE>i</CODE> + 2 <= $<CODE>max_index_to_go</CODE>
                        && $<CODE>block_type_to_go</CODE>[ $<CODE>i</CODE> + 2 ] eq
                        $<CODE>accumulating_text_for_block</CODE> )
                )
            )
          )
        {

            # <COMMENTS>add</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>newline</COMMENTS>
            if ( $<CODE>i</CODE> == 0 ) { $<CODE>leading_block_text</CODE> .= ' ' }

            # <COMMENTS>add</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>text</COMMENTS>
            $<CODE>leading_block_text</CODE> .= $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>];
            $<CODE>leading_block_text_line_length</CODE> = $<CODE>new_line_length</CODE>;
        }

        # <COMMENTS>show</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>truncated</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
        elsif ( $<CODE>types_to_go</CODE>[$<CODE>i</CODE>] ne '<LITERALS>b</LITERALS>' ) {
            $<CODE>leading_block_text_length_exceeded</CODE> = 1;
## <COMMENTS>Please</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>perltidy</COMMENTS>.<COMMENTS>ERR</COMMENTS>
            $<CODE>leading_block_text</CODE> .= '...';
        }
    }
}

{
    my %<CODE>is_if_elsif_else_unless_while_until_for_foreach</CODE>;

    <CODE>BEGIN</CODE> {

        # <COMMENTS>These</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>opening</COMMENTS>
        # <COMMENTS>curly</COMMENTS>.  <COMMENTS>Note</COMMENTS>: '<COMMENTS>else</COMMENTS>' <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>included</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>trailing</COMMENTS>
        # <COMMENTS>if</COMMENTS>/<COMMENTS>elsif</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>appended</COMMENTS>.
        # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS>: <COMMENTS>added</COMMENTS> '<COMMENTS>case</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>when</COMMENTS>'
        @<CODE>_</CODE> = qw(<LITERALS>if</LITERALS> <LITERALS>elsif</LITERALS> <LITERALS>else</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>while</LITERALS> <LITERALS>until</LITERALS> <LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS> <LITERALS>case</LITERALS> <LITERALS>when</LITERALS>);
        @<CODE>is_if_elsif_else_unless_while_until_for_foreach</CODE>{@<CODE>_</CODE>} =
          (1) x scalar(@<CODE>_</CODE>);
    }

    sub <CODE>accumulate_csc_text</CODE> {

        # <COMMENTS>called</COMMENTS> <COMMENTS>once</COMMENTS> <COMMENTS>per</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>buffer</COMMENTS> <COMMENTS>when</COMMENTS> -<COMMENTS>csc</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>. <COMMENTS>Accumulates</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>placed</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>braces</COMMENTS>.
        # <COMMENTS>Defines</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>returns</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>buffer</COMMENTS>:

        my $<CODE>block_leading_text</CODE> = "";    # <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> '}'
        my $<CODE>rblock_leading_if_elsif_text</CODE>;
        my $<CODE>i_block_leading_text</CODE> =
          -1;    # <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>owning</COMMENTS> <COMMENTS>block_leading_text</COMMENTS>
        my $<CODE>block_line_count</CODE>    = 100;    # <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>spans</COMMENTS>
        my $<CODE>terminal_type</CODE>       = '<LITERALS>b</LITERALS>';    # <COMMENTS>type</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>token</COMMENTS>
        my $<CODE>i_terminal</CODE>          = 0;      # <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>token</COMMENTS>
        my $<CODE>terminal_block_type</CODE> = "";

        # <COMMENTS>update</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>recent</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>label</COMMENTS>
        $<CODE>csc_last_label</CODE> = "" unless ($<CODE>csc_last_label</CODE>);
        if ( $<CODE>types_to_go</CODE>[0] eq '<LITERALS>J</LITERALS>' ) { $<CODE>csc_last_label</CODE> = $<CODE>tokens_to_go</CODE>[0] }
        my $<CODE>block_label</CODE> = $<CODE>csc_last_label</CODE>;

        # <COMMENTS>Loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
        for my $<CODE>i</CODE> ( 0 .. $<CODE>max_index_to_go</CODE> ) {
            my $<CODE>type</CODE>       = $<CODE>types_to_go</CODE>[$<CODE>i</CODE>];
            my $<CODE>block_type</CODE> = $<CODE>block_type_to_go</CODE>[$<CODE>i</CODE>];
            my $<CODE>token</CODE>      = $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>];

            # <COMMENTS>remember</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS>
            if ( $<CODE>type</CODE> ne '#' && $<CODE>type</CODE> ne '<LITERALS>b</LITERALS>' ) {
                $<CODE>terminal_type</CODE>       = $<CODE>type</CODE>;
                $<CODE>terminal_block_type</CODE> = $<CODE>block_type</CODE>;
                $<CODE>i_terminal</CODE>          = $<CODE>i</CODE>;
            }

            my $<CODE>type_sequence</CODE> = $<CODE>type_sequence_to_go</CODE>[$<CODE>i</CODE>];
            if ( $<CODE>block_type</CODE> && $<CODE>type_sequence</CODE> ) {

                if ( $<CODE>token</CODE> eq '}' ) {

                    # <COMMENTS>restore</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>saved</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>entered</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>block</COMMENTS>
                    if ( defined( $<CODE>block_leading_text</CODE>{$<CODE>type_sequence</CODE>} ) ) {
                        ( $<CODE>block_leading_text</CODE>, $<CODE>rblock_leading_if_elsif_text</CODE> )
                          = @{ $<CODE>block_leading_text</CODE>{$<CODE>type_sequence</CODE>} };
                        $<CODE>i_block_leading_text</CODE> = $<CODE>i</CODE>;
                        delete $<CODE>block_leading_text</CODE>{$<CODE>type_sequence</CODE>};
                        $<CODE>rleading_block_if_elsif_text</CODE> =
                          $<CODE>rblock_leading_if_elsif_text</CODE>;
                    }

                    if ( defined( $<CODE>csc_block_label</CODE>{$<CODE>type_sequence</CODE>} ) ) {
                        $<CODE>block_label</CODE> = $<CODE>csc_block_label</CODE>{$<CODE>type_sequence</CODE>};
                        delete $<CODE>csc_block_label</CODE>{$<CODE>type_sequence</CODE>};
                    }

                    # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>run</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>a</COMMENTS> '}' <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>started</COMMENTS> <COMMENTS>accumulating</COMMENTS>
                    # <COMMENTS>at</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>trailing</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>clause</COMMENTS>..<COMMENTS>no</COMMENTS> <COMMENTS>harm</COMMENTS> <COMMENTS>done</COMMENTS>.
                    if (   $<CODE>accumulating_text_for_block</CODE>
                        && $<CODE>levels_to_go</CODE>[$<CODE>i</CODE>] <= $<CODE>leading_block_text_level</CODE> )
                    {
                        my $<CODE>lev</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>i</CODE>];
                        <CODE>reset_block_text_accumulator</CODE>();
                    }

                    if ( defined( $<CODE>block_opening_line_number</CODE>{$<CODE>type_sequence</CODE>} ) )
                    {
                        my $<CODE>output_line_number</CODE> =
                          $<CODE>vertical_aligner_object</CODE>-><CODE>get_output_line_number</CODE>();
                        $<CODE>block_line_count</CODE> =
                          $<CODE>output_line_number</CODE> -
                          $<CODE>block_opening_line_number</CODE>{$<CODE>type_sequence</CODE>} + 1;
                        delete $<CODE>block_opening_line_number</CODE>{$<CODE>type_sequence</CODE>};
                    }
                    else {

                        # <COMMENTS>Error</COMMENTS>: <COMMENTS>block</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>undefined</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>..
                        # <COMMENTS>This</COMMENTS> <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>possible</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS>
                        # <COMMENTS>significant</COMMENTS> <COMMENTS>problem</COMMENTS>.
                    }
                }

                elsif ( $<CODE>token</CODE> eq '{' ) {

                    my $<CODE>line_number</CODE> =
                      $<CODE>vertical_aligner_object</CODE>-><CODE>get_output_line_number</CODE>();
                    $<CODE>block_opening_line_number</CODE>{$<CODE>type_sequence</CODE>} = $<CODE>line_number</CODE>;

                    # <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>label</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>block</COMMENTS>, <COMMENTS>except</COMMENTS> <COMMENTS>for</COMMENTS>
                    # <COMMENTS>a</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>label</COMMENTS>
                    # <COMMENTS>A</COMMENTS> <COMMENTS>label</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> {
                    if ( $<CODE>block_type</CODE> =~ /:$/ ) { $<CODE>csc_last_label</CODE> = "" }
                    $<CODE>csc_block_label</CODE>{$<CODE>type_sequence</CODE>} = $<CODE>csc_last_label</CODE>;
                    $<CODE>csc_last_label</CODE> = "";

                    if (   $<CODE>accumulating_text_for_block</CODE>
                        && $<CODE>levels_to_go</CODE>[$<CODE>i</CODE>] == $<CODE>leading_block_text_level</CODE> )
                    {

                        if ( $<CODE>accumulating_text_for_block</CODE> eq $<CODE>block_type</CODE> ) {

                            # <COMMENTS>save</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>enter</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>block</COMMENTS>
                            $<CODE>block_leading_text</CODE>{$<CODE>type_sequence</CODE>} = [
                                $<CODE>leading_block_text</CODE>,
                                $<CODE>rleading_block_if_elsif_text</CODE>
                            ];
                            $<CODE>block_opening_line_number</CODE>{$<CODE>type_sequence</CODE>} =
                              $<CODE>leading_block_text_line_number</CODE>;
                            <CODE>reset_block_text_accumulator</CODE>();
                        }
                        else {

                            # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>serious</COMMENTS> <COMMENTS>error</COMMENTS>.
                            # <COMMENTS>We</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>accumulating</COMMENTS> -<COMMENTS>csc</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>type</COMMENTS>
                            # <COMMENTS>$accumulating_text_for_block</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>unexpectedly</COMMENTS>
                            # <COMMENTS>encountered</COMMENTS> <COMMENTS>a</COMMENTS> '{' <COMMENTS>for</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>$block_type</COMMENTS>.
                        }
                    }
                }
            }

            if (   $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>'
                && $<CODE>csc_new_statement_ok</CODE>
                && $<CODE>is_if_elsif_else_unless_while_until_for_foreach</CODE>{$<CODE>token</CODE>}
                && $<CODE>token</CODE> =~ /$<CODE>closing_side_comment_list_pattern</CODE>/o )
            {
                <CODE>set_block_text_accumulator</CODE>($<CODE>i</CODE>);
            }
            else {

                # <COMMENTS>note</COMMENTS>: <COMMENTS>ignoring</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>q</COMMENTS>' <COMMENTS>because</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tricks</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>played</COMMENTS>
                # <COMMENTS>with</COMMENTS> '<COMMENTS>q</COMMENTS>' <COMMENTS>for</COMMENTS> <COMMENTS>hanging</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>
                if ( $<CODE>type</CODE> ne '<LITERALS>b</LITERALS>' && $<CODE>type</CODE> ne '#' && $<CODE>type</CODE> ne '<LITERALS>q</LITERALS>' ) {
                    $<CODE>csc_new_statement_ok</CODE> =
                      ( $<CODE>block_type</CODE> || $<CODE>type</CODE> eq '<LITERALS>J</LITERALS>' || $<CODE>type</CODE> eq ';' );
                }
                if (   $<CODE>type</CODE> eq ';'
                    && $<CODE>accumulating_text_for_block</CODE>
                    && $<CODE>levels_to_go</CODE>[$<CODE>i</CODE>] == $<CODE>leading_block_text_level</CODE> )
                {
                    <CODE>reset_block_text_accumulator</CODE>();
                }
                else {
                    <CODE>accumulate_block_text</CODE>($<CODE>i</CODE>);
                }
            }
        }

        # <COMMENTS>Treat</COMMENTS> <COMMENTS>an</COMMENTS> '<COMMENTS>else</COMMENTS>' <COMMENTS>block</COMMENTS> <COMMENTS>specially</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>preceding</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>and</COMMENTS>
        # '<COMMENTS>elsif</COMMENTS>' <COMMENTS>text</COMMENTS>.  <COMMENTS>Otherwise</COMMENTS>, <COMMENTS>the</COMMENTS> '<COMMENTS>end</COMMENTS> <COMMENTS>else</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>helpful</COMMENTS>,
        # <COMMENTS>especially</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>cuddled</COMMENTS>-<COMMENTS>else</COMMENTS> <COMMENTS>formatting</COMMENTS>.
        if ( $<CODE>terminal_block_type</CODE> =~ /^els/ && $<CODE>rblock_leading_if_elsif_text</CODE> ) {
            $<CODE>block_leading_text</CODE> =
              <CODE>make_else_csc_text</CODE>( $<CODE>i_terminal</CODE>, $<CODE>terminal_block_type</CODE>,
                $<CODE>block_leading_text</CODE>, $<CODE>rblock_leading_if_elsif_text</CODE> );
        }

        # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>label</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>remember</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>pass</COMMENTS>
        $<CODE>csc_last_label</CODE> = "";
        if ( $<CODE>terminal_type</CODE> eq '<LITERALS>J</LITERALS>' ) {
            $<CODE>csc_last_label</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>i_terminal</CODE>];
        }

        return ( $<CODE>terminal_type</CODE>, $<CODE>i_terminal</CODE>, $<CODE>i_block_leading_text</CODE>,
            $<CODE>block_leading_text</CODE>, $<CODE>block_line_count</CODE>, $<CODE>block_label</CODE> );
    }
}

sub <CODE>make_else_csc_text</CODE> {

    # <COMMENTS>create</COMMENTS> <COMMENTS>additional</COMMENTS> -<COMMENTS>csc</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>an</COMMENTS> '<COMMENTS>else</COMMENTS>' <COMMENTS>and</COMMENTS> <COMMENTS>optionally</COMMENTS> '<COMMENTS>elsif</COMMENTS>',
    # <COMMENTS>depending</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>switch</COMMENTS>
    # <COMMENTS>$rOpts_closing_side_comment_else_flag</COMMENTS>:
    #
    #  = <COMMENTS>0</COMMENTS> <COMMENTS>add</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>text</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>else</COMMENTS>
    #  = <COMMENTS>1</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>0</COMMENTS> <COMMENTS>plus</COMMENTS>:
    #      <COMMENTS>add</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>to</COMMENTS> '<COMMENTS>elsif</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>fit</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>
    #      <COMMENTS>add</COMMENTS> <COMMENTS>last</COMMENTS> '<COMMENTS>elsif</COMMENTS>' <COMMENTS>to</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>fit</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS>
    #  = <COMMENTS>2</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>exceed</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>
    #
    # <COMMENTS>$rif_elsif_text</COMMENTS> = <COMMENTS>a</COMMENTS> <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>closing</COMMENTS>
    # <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>created</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>block</COMMENTS>
    #
    my ( $<CODE>i_terminal</CODE>, $<CODE>block_type</CODE>, $<CODE>block_leading_text</CODE>, $<CODE>rif_elsif_text</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>csc_text</CODE> = $<CODE>block_leading_text</CODE>;

    if (   $<CODE>block_type</CODE> eq '<LITERALS>elsif</LITERALS>'
        && $<CODE>rOpts_closing_side_comment_else_flag</CODE> == 0 )
    {
        return $<CODE>csc_text</CODE>;
    }

    my $<CODE>count</CODE> = @{$<CODE>rif_elsif_text</CODE>};
    return $<CODE>csc_text</CODE> unless ($<CODE>count</CODE>);

    my $<CODE>if_text</CODE> = '[ <LITERALS>if</LITERALS>' . $<CODE>rif_elsif_text</CODE>->[0];

    # <COMMENTS>always</COMMENTS> <COMMENTS>show</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>text</COMMENTS> <COMMENTS>on</COMMENTS> '<COMMENTS>else</COMMENTS>'
    if ( $<CODE>block_type</CODE> eq '<LITERALS>else</LITERALS>' ) {
        $<CODE>csc_text</CODE> .= $<CODE>if_text</CODE>;
    }

    # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>that</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>all</COMMENTS>
    if ( $<CODE>rOpts_closing_side_comment_else_flag</CODE> == 0 ) {
        return $<CODE>csc_text</CODE>;
    }

    my $<CODE>last_elsif_text</CODE> = "";
    if ( $<CODE>count</CODE> > 1 ) {
        $<CODE>last_elsif_text</CODE> = ' [<LITERALS>elsif</LITERALS>' . $<CODE>rif_elsif_text</CODE>->[ $<CODE>count</CODE> - 1 ];
        if ( $<CODE>count</CODE> > 2 ) { $<CODE>last_elsif_text</CODE> = ' [...' . $<CODE>last_elsif_text</CODE>; }
    }

    # <COMMENTS>tentatively</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>item</COMMENTS>
    my $<CODE>saved_text</CODE> = $<CODE>csc_text</CODE>;
    if ( $<CODE>block_type</CODE> eq '<LITERALS>else</LITERALS>' ) {
        $<CODE>csc_text</CODE> .= $<CODE>last_elsif_text</CODE>;
    }
    else {
        $<CODE>csc_text</CODE> .= ' ' . $<CODE>if_text</CODE>;
    }

    # <COMMENTS>all</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>checks</COMMENTS> <COMMENTS>requested</COMMENTS>
    if ( $<CODE>rOpts_closing_side_comment_else_flag</CODE> == 2 ) {
        return $<CODE>csc_text</CODE>;
    }

    # <COMMENTS>undo</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>exceeded</COMMENTS>
    my $<CODE>length</CODE> =
      length($<CODE>csc_text</CODE>) +
      length($<CODE>block_type</CODE>) +
      length( $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>prefix</LITERALS>'} ) +
      $<CODE>levels_to_go</CODE>[$<CODE>i_terminal</CODE>] * $<CODE>rOpts_indent_columns</CODE> + 3;
    if ( $<CODE>length</CODE> > <CODE>maximum_line_length_for_level</CODE>($<CODE>leading_block_text_level</CODE>) ) {
        $<CODE>csc_text</CODE> = $<CODE>saved_text</CODE>;
    }
    return $<CODE>csc_text</CODE>;
}

{    # <COMMENTS>sub</COMMENTS> <COMMENTS>balance_csc_text</COMMENTS>

    my %<CODE>matching_char</CODE>;

    <CODE>BEGIN</CODE> {
        %<CODE>matching_char</CODE> = (
            '{' => '}',
            '(' => ')',
            '[' => ']',
            '}' => '{',
            ')' => '(',
            ']' => '[',
        );
    }

    sub <CODE>balance_csc_text</CODE> {

        # <COMMENTS>Append</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>balance</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>editors</COMMENTS>
        # <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>vim</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>correctly</COMMENTS> <COMMENTS>jump</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>code</COMMENTS>.
        # <COMMENTS>Simple</COMMENTS> <COMMENTS>Example</COMMENTS>:
        #  <COMMENTS>input</COMMENTS>  = ## <COMMENTS>end</COMMENTS> <COMMENTS>foreach</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>$foo</COMMENTS> ( <COMMENTS>sort</COMMENTS> { <COMMENTS>$b</COMMENTS>  ...
        #  <COMMENTS>output</COMMENTS> = ## <COMMENTS>end</COMMENTS> <COMMENTS>foreach</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>$foo</COMMENTS> ( <COMMENTS>sort</COMMENTS> { <COMMENTS>$b</COMMENTS>  ...})

        # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>currently</COMMENTS> <COMMENTS>filter</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>structures</COMMENTS> <COMMENTS>within</COMMENTS>
        # <COMMENTS>quoted</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>bounce</COMMENTS> <COMMENTS>algorithms</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>editors</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS>
        # <COMMENTS>necessarily</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>either</COMMENTS> (<COMMENTS>a</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>vim</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>checked</COMMENTS> <COMMENTS>and</COMMENTS>
        # <COMMENTS>did</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS>).

        # <COMMENTS>Some</COMMENTS> <COMMENTS>complex</COMMENTS> <COMMENTS>examples</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>trouble</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>editors</COMMENTS>:
        #  <COMMENTS>while</COMMENTS> ( <COMMENTS>$mask_string</COMMENTS> =~ /\{[^{]*?\}/<COMMENTS>g</COMMENTS> ) {
        #  <COMMENTS>if</COMMENTS> ( <COMMENTS>$mask_str</COMMENTS> =~ /\}\<COMMENTS>s</COMMENTS>*<COMMENTS>els</COMMENTS>[^\{\}]+\{<COMMENTS>$</COMMENTS>/ ) {
        #  <COMMENTS>if</COMMENTS> ( <COMMENTS>$1</COMMENTS> <COMMENTS>eq</COMMENTS> '{' ) {
        # <COMMENTS>test</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>test1</COMMENTS>/<COMMENTS>braces</COMMENTS>.<COMMENTS>pl</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>examples</COMMENTS>.

        my ($<CODE>csc</CODE>) = @<CODE>_</CODE>;

        # <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>examine</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>by</COMMENTS>-<COMMENTS>one</COMMENTS>, <COMMENTS>RIGHT</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>LEFT</COMMENTS> <COMMENTS>and</COMMENTS>
        # <COMMENTS>build</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>balancing</COMMENTS> <COMMENTS>ending</COMMENTS>, <COMMENTS>LEFT</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>RIGHT</COMMENTS>.
        for ( my $<CODE>pos</CODE> = length($<CODE>csc</CODE>) - 1 ; $<CODE>pos</CODE> >= 0 ; $<CODE>pos</CODE>-- ) {

            my $<CODE>char</CODE> = substr( $<CODE>csc</CODE>, $<CODE>pos</CODE>, 1 );

            # <COMMENTS>ignore</COMMENTS> <COMMENTS>everything</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>characters</COMMENTS>
            next unless ( $<CODE>matching_char</CODE>{$<CODE>char</CODE>} );

            # <COMMENTS>pop</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>recently</COMMENTS> <COMMENTS>appended</COMMENTS> <COMMENTS>character</COMMENTS>
            my $<CODE>top</CODE> = chop($<CODE>csc</CODE>);

            # <COMMENTS>push</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>plus</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>mate</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>newest</COMMENTS> <COMMENTS>character</COMMENTS>
            # <COMMENTS>unless</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>balance</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>other</COMMENTS>.
            $<CODE>csc</CODE> = $<CODE>csc</CODE> . $<CODE>top</CODE> . $<CODE>matching_char</CODE>{$<CODE>char</CODE>} unless $<CODE>top</CODE> eq $<CODE>char</CODE>;
        }

        # <COMMENTS>return</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>balanced</COMMENTS> <COMMENTS>string</COMMENTS>
        return $<CODE>csc</CODE>;
    }
}

sub <CODE>add_closing_side_comment</CODE> {

    # <COMMENTS>add</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>if</COMMENTS> -<COMMENTS>csc</COMMENTS> <COMMENTS>used</COMMENTS>
    my $<CODE>cscw_block_comment</CODE>;

    #---------------------------------------------------------------
    # <COMMENTS>Step</COMMENTS> <COMMENTS>1</COMMENTS>: <COMMENTS>loop</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>accumulate</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>. <COMMENTS>Also</COMMENTS> <COMMENTS>see</COMMENTS>
    # <COMMENTS>how</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS>.
    #---------------------------------------------------------------

    my ( $<CODE>terminal_type</CODE>, $<CODE>i_terminal</CODE>, $<CODE>i_block_leading_text</CODE>,
        $<CODE>block_leading_text</CODE>, $<CODE>block_line_count</CODE>, $<CODE>block_label</CODE> )
      = <CODE>accumulate_csc_text</CODE>();

    #---------------------------------------------------------------
    # <COMMENTS>Step</COMMENTS> <COMMENTS>2</COMMENTS>: <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS>
    #---------------------------------------------------------------
    my $<CODE>have_side_comment</CODE> = $<CODE>i_terminal</CODE> != $<CODE>max_index_to_go</CODE>;

    # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>closure</COMMENTS>..
    if (
        $<CODE>terminal_type</CODE> eq '}'

        # ..<COMMENTS>and</COMMENTS> <COMMENTS>either</COMMENTS>
        && (

            # <COMMENTS>the</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>enough</COMMENTS>
            ( $<CODE>block_line_count</CODE> >= $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>interval</LITERALS>'} )

            # <COMMENTS>or</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>existing</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS>
            || (   $<CODE>have_side_comment</CODE>
                && $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>warnings</LITERALS>'} )
        )

        # .. <COMMENTS>and</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>interest</COMMENTS>
        && $<CODE>block_type_to_go</CODE>[$<CODE>i_terminal</CODE>] =~
        /$<CODE>closing_side_comment_list_pattern</CODE>/o

        # .. <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>sub</COMMENTS>
        # <COMMENTS>These</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>normally</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>interest</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>are</COMMENTS>
        # <COMMENTS>often</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>semicolons</COMMENTS> <COMMENTS>anyway</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>avoids</COMMENTS>
        # <COMMENTS>possible</COMMENTS> <COMMENTS>erratic</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>due</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>numbering</COMMENTS> <COMMENTS>inconsistencies</COMMENTS>
        # <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>cases</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>terminate</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>.
        && $<CODE>block_type_to_go</CODE>[$<CODE>i_terminal</CODE>] ne '<LITERALS>sub</LITERALS>'

        # ..<COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>corresponding</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
        # (<COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>tag</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS>, <COMMENTS>although</COMMENTS> <COMMENTS>this</COMMENTS>
        # <COMMENTS>should</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>caught</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>positive</COMMENTS> -<COMMENTS>csci</COMMENTS> <COMMENTS>value</COMMENTS>)
        && $<CODE>mate_index_to_go</CODE>[$<CODE>i_terminal</CODE>] < 0

        # ..<COMMENTS>and</COMMENTS> <COMMENTS>either</COMMENTS>
        && (

            # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS> (<COMMENTS>line</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>)
            !$<CODE>have_side_comment</CODE>

            # <COMMENTS>or</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
            || $<CODE>tokens_to_go</CODE>[$<CODE>max_index_to_go</CODE>] =~
            /$<CODE>closing_side_comment_prefix_pattern</CODE>/o
        )
      )
    {

        # <COMMENTS>then</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>text</COMMENTS>
        if ($<CODE>block_label</CODE>) { $<CODE>block_label</CODE> .= " " }
        my $<CODE>token</CODE> =
"$<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>prefix</LITERALS>'} $<CODE>block_label</CODE>$<CODE>block_type_to_go</CODE>[$<CODE>i_terminal</CODE>]";

        # <COMMENTS>append</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>descriptive</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>collected</COMMENTS> <COMMENTS>above</COMMENTS>
        if ( $<CODE>i_block_leading_text</CODE> == $<CODE>i_terminal</CODE> ) {
            $<CODE>token</CODE> .= $<CODE>block_leading_text</CODE>;
        }

        $<CODE>token</CODE> = <CODE>balance_csc_text</CODE>($<CODE>token</CODE>)
          if $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>-<LITERALS>balanced</LITERALS>'};

        $<CODE>token</CODE> =~ s/\s*$//;    # <COMMENTS>trim</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>whitespace</COMMENTS>

        # <COMMENTS>handle</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>existing</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
        if ($<CODE>have_side_comment</CODE>) {

            # <COMMENTS>warn</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>differ</COMMENTS> <COMMENTS>significantly</COMMENTS>
            if ( $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>warnings</LITERALS>'} ) {
                my $<CODE>old_csc</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
                my $<CODE>new_csc</CODE> = $<CODE>token</CODE>;
                $<CODE>new_csc</CODE> =~ s/\s+//g;            # <COMMENTS>trim</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>whitespace</COMMENTS>
                $<CODE>old_csc</CODE> =~ s/\s+//g;            # <COMMENTS>trim</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>whitespace</COMMENTS>
                $<CODE>new_csc</CODE> =~ s/[\]\)\}\s]*$//;    # <COMMENTS>trim</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>structures</COMMENTS>
                $<CODE>old_csc</CODE> =~ s/[\]\)\}\s]*$//;    # <COMMENTS>trim</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>structures</COMMENTS>
                $<CODE>new_csc</CODE> =~ s/(\.\.\.)$//;       # <COMMENTS>trim</COMMENTS> <COMMENTS>trailing</COMMENTS> '...'
                my $<CODE>new_trailing_dots</CODE> = $<CODE>1</CODE>;
                $<CODE>old_csc</CODE> =~ s/(\.\.\.)\s*$//;    # <COMMENTS>trim</COMMENTS> <COMMENTS>trailing</COMMENTS> '...'

                # <COMMENTS>Patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>at</COMMENTS>
                # <COMMENTS>else</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>elsif</COMMENTS>'<COMMENTS>s</COMMENTS>.  <COMMENTS>These</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>become</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>complicated</COMMENTS>
                # <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>indication</COMMENTS> <COMMENTS>of</COMMENTS>
                # '[ <COMMENTS>if</COMMENTS>' <COMMENTS>or</COMMENTS> '[ # <COMMENTS>elsif</COMMENTS>', <COMMENTS>then</COMMENTS> <COMMENTS>assume</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>made</COMMENTS>
                # <COMMENTS>by</COMMENTS> <COMMENTS>perltidy</COMMENTS>.
                if ( $<CODE>block_type_to_go</CODE>[$<CODE>i_terminal</CODE>] eq '<LITERALS>else</LITERALS>' ) {
                    if ( $<CODE>old_csc</CODE> =~ /\[\s*elsif/ ) { $<CODE>old_csc</CODE> = $<CODE>new_csc</CODE> }
                }
                elsif ( $<CODE>block_type_to_go</CODE>[$<CODE>i_terminal</CODE>] eq '<LITERALS>elsif</LITERALS>' ) {
                    if ( $<CODE>old_csc</CODE> =~ /\[\s*if/ ) { $<CODE>old_csc</CODE> = $<CODE>new_csc</CODE> }
                }

                # <COMMENTS>if</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>contained</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>comment</COMMENTS>,
                # <COMMENTS>only</COMMENTS> <COMMENTS>compare</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>part</COMMENTS>.
                if ( length($<CODE>new_csc</CODE>) > length($<CODE>old_csc</CODE>) ) {
                    $<CODE>new_csc</CODE> = substr( $<CODE>new_csc</CODE>, 0, length($<CODE>old_csc</CODE>) );
                }

                # <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>shorter</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>limited</COMMENTS>,
                # <COMMENTS>only</COMMENTS> <COMMENTS>compare</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>part</COMMENTS>.
                if ( length($<CODE>new_csc</CODE>) < length($<CODE>old_csc</CODE>)
                    && $<CODE>new_trailing_dots</CODE> )
                {
                    $<CODE>old_csc</CODE> = substr( $<CODE>old_csc</CODE>, 0, length($<CODE>new_csc</CODE>) );
                }

                # <COMMENTS>any</COMMENTS> <COMMENTS>remaining</COMMENTS> <COMMENTS>difference</COMMENTS>?
                if ( $<CODE>new_csc</CODE> ne $<CODE>old_csc</CODE> ) {

                    # <COMMENTS>just</COMMENTS> <COMMENTS>leave</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>threshold</COMMENTS>
                    # <COMMENTS>for</COMMENTS> <COMMENTS>creating</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>
                    if ( $<CODE>block_line_count</CODE> <
                        $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>interval</LITERALS>'} )
                    {
                        $<CODE>token</CODE> = undef;
                    }

                    # <COMMENTS>otherwise</COMMENTS> <COMMENTS>we</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>note</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>it</COMMENTS>
                    else {

                        <CODE>warning</CODE>(
"<LITERALS>perltidy</LITERALS> -<LITERALS>cscw</LITERALS> <LITERALS>replaced</LITERALS>: $<CODE>tokens_to_go</CODE>[$<CODE>max_index_to_go</CODE>]\n"
                        );

                     # <COMMENTS>save</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comment</COMMENTS>
                        my ( $<CODE>day</CODE>, $<CODE>month</CODE>, $<CODE>year</CODE> ) = (localtime)[ 3, 4, 5 ];
                        $<CODE>year</CODE>  += 1900;
                        $<CODE>month</CODE> += 1;
                        $<CODE>cscw_block_comment</CODE> =
"## <LITERALS>perltidy</LITERALS> -<LITERALS>cscw</LITERALS> $<CODE>year</CODE>-$<CODE>month</CODE>-$<CODE>day</CODE>: $<CODE>tokens_to_go</CODE>[$<CODE>max_index_to_go</CODE>]";
                    }
                }
                else {

                    # <COMMENTS>No</COMMENTS> <COMMENTS>differences</COMMENTS>.. <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>safely</COMMENTS> <COMMENTS>delete</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS>
                    # <COMMENTS>are</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>threshold</COMMENTS>
                    if ( $<CODE>block_line_count</CODE> <
                        $<CODE>rOpts</CODE>->{'<LITERALS>closing</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>-<LITERALS>interval</LITERALS>'} )
                    {
                        $<CODE>token</CODE> = undef;
                        <CODE>unstore_token_to_go</CODE>()
                          if ( $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>] eq '#' );
                        <CODE>unstore_token_to_go</CODE>()
                          if ( $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>] eq '<LITERALS>b</LITERALS>' );
                    }
                }
            }

            # <COMMENTS>switch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>csc</COMMENTS> (<COMMENTS>unless</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>deleted</COMMENTS> <COMMENTS>it</COMMENTS>!)
            $<CODE>tokens_to_go</CODE>[$<CODE>max_index_to_go</CODE>] = $<CODE>token</CODE> if $<CODE>token</CODE>;
        }

        # <COMMENTS>handle</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>NO</COMMENTS> <COMMENTS>existing</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
        else {

            # <COMMENTS>insert</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>stream</COMMENTS>
            my $<CODE>type</CODE>          = '#';
            my $<CODE>block_type</CODE>    = '';
            my $<CODE>type_sequence</CODE> = '';
            my $<CODE>container_environment</CODE> =
              $<CODE>container_environment_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
            my $<CODE>level</CODE>                = $<CODE>levels_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
            my $<CODE>slevel</CODE>               = $<CODE>nesting_depth_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
            my $<CODE>no_internal_newlines</CODE> = 0;

            my $<CODE>nesting_blocks</CODE>     = $<CODE>nesting_blocks_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
            my $<CODE>ci_level</CODE>           = $<CODE>ci_levels_to_go</CODE>[$<CODE>max_index_to_go</CODE>];
            my $<CODE>in_continued_quote</CODE> = 0;

            # <COMMENTS>first</COMMENTS> <COMMENTS>insert</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>token</COMMENTS>
            <CODE>insert_new_token_to_go</CODE>( ' ', '<LITERALS>b</LITERALS>', $<CODE>slevel</CODE>, $<CODE>no_internal_newlines</CODE> );

            # <COMMENTS>then</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
            <CODE>insert_new_token_to_go</CODE>( $<CODE>token</CODE>, $<CODE>type</CODE>, $<CODE>slevel</CODE>,
                $<CODE>no_internal_newlines</CODE> );
        }
    }
    return $<CODE>cscw_block_comment</CODE>;
}

sub <CODE>previous_nonblank_token</CODE> {
    my ($<CODE>i</CODE>)  = @<CODE>_</CODE>;
    my $<CODE>name</CODE> = "";
    my $<CODE>im</CODE>   = $<CODE>i</CODE> - 1;
    return "" if ( $<CODE>im</CODE> < 0 );
    if ( $<CODE>types_to_go</CODE>[$<CODE>im</CODE>] eq '<LITERALS>b</LITERALS>' ) { $<CODE>im</CODE>--; }
    return "" if ( $<CODE>im</CODE> < 0 );
    $<CODE>name</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>im</CODE>];

    # <COMMENTS>prepend</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>isolated</COMMENTS> -> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>alignments</COMMENTS>
    # [<COMMENTS>test</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>test8</COMMENTS>/<COMMENTS>penco</COMMENTS>.<COMMENTS>pl</COMMENTS>]
    if ( $<CODE>name</CODE> eq '->' ) {
        $<CODE>im</CODE>--;
        if ( $<CODE>im</CODE> >= 0 && $<CODE>types_to_go</CODE>[$<CODE>im</CODE>] ne '<LITERALS>b</LITERALS>' ) {
            $<CODE>name</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>im</CODE>] . $<CODE>name</CODE>;
        }
    }
    return $<CODE>name</CODE>;
}

sub <CODE>send_lines_to_vertical_aligner</CODE> {

    my ( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>, $<CODE>do_not_pad</CODE> ) = @<CODE>_</CODE>;

    my $<CODE>rindentation_list</CODE> = [0];    # <COMMENTS>ref</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>indentations</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS>

    # <COMMENTS>define</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>array</COMMENTS> @<COMMENTS>matching_token_to_go</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>tokens</COMMENTS>
    # <COMMENTS>which</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>token</COMMENTS> (<COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> =>)
    # <COMMENTS>for</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>required</COMMENTS>.
    <CODE>set_vertical_alignment_markers</CODE>( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> );

    # <COMMENTS>flush</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>alignment</COMMENTS>
    my $<CODE>must_flush</CODE> = 0;
    if ( @$<CODE>ri_first</CODE> > 1 ) {

        # <COMMENTS>flush</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>statement</COMMENTS>
        if ( $<CODE>types_to_go</CODE>[0] eq '<LITERALS>k</LITERALS>' && $<CODE>tokens_to_go</CODE>[0] =~ /^(if|unless)$/ ) {
            $<CODE>must_flush</CODE> = 1;
        }
    }
    if ($<CODE>must_flush</CODE>) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>::<CODE>flush</CODE>();
    }

    <CODE>undo_ci</CODE>( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> );

    <CODE>set_logical_padding</CODE>( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> );

    # <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prepare</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>shipment</COMMENTS>
    my $<CODE>n_last_line</CODE> = @$<CODE>ri_first</CODE> - 1;
    my $<CODE>in_comma_list</CODE>;
    for my $<CODE>n</CODE> ( 0 .. $<CODE>n_last_line</CODE> ) {
        my $<CODE>ibeg</CODE> = $$<CODE>ri_first</CODE>[$<CODE>n</CODE>];
        my $<CODE>iend</CODE> = $$<CODE>ri_last</CODE>[$<CODE>n</CODE>];

        my ( $<CODE>rtokens</CODE>, $<CODE>rfields</CODE>, $<CODE>rpatterns</CODE> ) =
          <CODE>make_alignment_patterns</CODE>( $<CODE>ibeg</CODE>, $<CODE>iend</CODE> );

        # <COMMENTS>Set</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>show</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>much</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>changes</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
        # <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>it</COMMENTS>.
        my $<CODE>ljump</CODE> = 0;
        if ( $<CODE>n</CODE> < $<CODE>n_last_line</CODE> ) {
            my $<CODE>ibegp</CODE> = $$<CODE>ri_first</CODE>[ $<CODE>n</CODE> + 1 ];
            $<CODE>ljump</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>ibegp</CODE>] - $<CODE>levels_to_go</CODE>[$<CODE>iend</CODE>];
        }

        my ( $<CODE>indentation</CODE>, $<CODE>lev</CODE>, $<CODE>level_end</CODE>, $<CODE>terminal_type</CODE>,
            $<CODE>is_semicolon_terminated</CODE>, $<CODE>is_outdented_line</CODE> )
          = <CODE>set_adjusted_indentation</CODE>( $<CODE>ibeg</CODE>, $<CODE>iend</CODE>, $<CODE>rfields</CODE>, $<CODE>rpatterns</CODE>,
            $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>, $<CODE>rindentation_list</CODE>, $<CODE>ljump</CODE> );

        # <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>outdenting</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>lines</COMMENTS>..
        my $<CODE>outdent_long_lines</CODE> = (

            # <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>quotes</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>allowed</COMMENTS>
            ( $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq '<LITERALS>Q</LITERALS>' && $<CODE>rOpts</CODE>->{'<LITERALS>outdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>quotes</LITERALS>'} )

            # <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comments</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>allowed</COMMENTS>
              || (
                   $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq '#'
                && $<CODE>rOpts</CODE>->{'<LITERALS>outdent</LITERALS>-<LITERALS>long</LITERALS>-<LITERALS>comments</LITERALS>'}

                # <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>static</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comment</COMMENTS>
                && !$<CODE>is_static_block_comment</CODE>
              )
        );

        my $<CODE>level_jump</CODE> =
          $<CODE>nesting_depth_to_go</CODE>[ $<CODE>iend</CODE> + 1 ] - $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg</CODE>];

        my $<CODE>rvertical_tightness_flags</CODE> =
          <CODE>set_vertical_tightness_flags</CODE>( $<CODE>n</CODE>, $<CODE>n_last_line</CODE>, $<CODE>ibeg</CODE>, $<CODE>iend</CODE>,
            $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> );

        # <COMMENTS>flush</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>outdented</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS>
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>::<CODE>flush</CODE>() if ($<CODE>is_outdented_line</CODE>);

        # <COMMENTS>Set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>final</COMMENTS> ':' <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>ternary</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>request</COMMENTS>
        # <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>final</COMMENTS> <COMMENTS>term</COMMENTS>.  <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS>
        # <COMMENTS>slightly</COMMENTS> <COMMENTS>complex</COMMENTS> <COMMENTS>example</COMMENTS>:
        #
        # <COMMENTS>$self</COMMENTS>->{<COMMENTS>_text</COMMENTS>} = (
        #    !<COMMENTS>$section</COMMENTS>        ? ''
        #   : <COMMENTS>$type</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>item</COMMENTS>' ? "<COMMENTS>the</COMMENTS> <COMMENTS>$section</COMMENTS> <COMMENTS>entry</COMMENTS>"
        #   :                   "<COMMENTS>the</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>$section</COMMENTS>"
        # )
        # . (
        #   <COMMENTS>$page</COMMENTS>
        #   ? ( <COMMENTS>$section</COMMENTS> ? ' <COMMENTS>in</COMMENTS> ' : '' ) . "<COMMENTS>the</COMMENTS> <COMMENTS>$page$page_ext</COMMENTS> <COMMENTS>manpage</COMMENTS>"
        #   : ' <COMMENTS>elsewhere</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>document</COMMENTS>'
        # );
        #
        my $<CODE>is_terminal_ternary</CODE> = 0;
        if (   $<CODE>tokens_to_go</CODE>[$<CODE>ibeg</CODE>] eq ':'
            || $<CODE>n</CODE> > 0 && $<CODE>tokens_to_go</CODE>[ $$<CODE>ri_last</CODE>[ $<CODE>n</CODE> - 1 ] ] eq ':' )
        {
            my $<CODE>last_leading_type</CODE> = ":";
            if ( $<CODE>n</CODE> > 0 ) {
                my $<CODE>iprev</CODE> = $$<CODE>ri_first</CODE>[ $<CODE>n</CODE> - 1 ];
                $<CODE>last_leading_type</CODE> = $<CODE>types_to_go</CODE>[$<CODE>iprev</CODE>];
            }
            if (   $<CODE>terminal_type</CODE> ne ';'
                && $<CODE>n_last_line</CODE> > $<CODE>n</CODE>
                && $<CODE>level_end</CODE> == $<CODE>lev</CODE> )
            {
                my $<CODE>inext</CODE> = $$<CODE>ri_first</CODE>[ $<CODE>n</CODE> + 1 ];
                $<CODE>level_end</CODE>     = $<CODE>levels_to_go</CODE>[$<CODE>inext</CODE>];
                $<CODE>terminal_type</CODE> = $<CODE>types_to_go</CODE>[$<CODE>inext</CODE>];
            }

            $<CODE>is_terminal_ternary</CODE> = $<CODE>last_leading_type</CODE> eq ':'
              && ( ( $<CODE>terminal_type</CODE> eq ';' && $<CODE>level_end</CODE> <= $<CODE>lev</CODE> )
                || ( $<CODE>terminal_type</CODE> ne ':' && $<CODE>level_end</CODE> < $<CODE>lev</CODE> ) )

              # <COMMENTS>the</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>contain</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>ternary</COMMENTS> <COMMENTS>terms</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS>
              # <COMMENTS>my</COMMENTS> <COMMENTS>$ECHO</COMMENTS> = (
              #       <COMMENTS>$Is_MSWin32</COMMENTS> ? ".\\<COMMENTS>echo$$</COMMENTS>"
              #     : <COMMENTS>$Is_MacOS</COMMENTS>   ? ":<COMMENTS>echo$$</COMMENTS>"
              #     : ( <COMMENTS>$Is_NetWare</COMMENTS> ? "<COMMENTS>echo$$</COMMENTS>" : "./<COMMENTS>echo$$</COMMENTS>" )
              # );
              && !grep /^[\?\:]$/, @<CODE>types_to_go</CODE>[ $<CODE>ibeg</CODE> + 1 .. $<CODE>iend</CODE> ];
        }

        # <COMMENTS>send</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>down</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pipe</COMMENTS>
        my $<CODE>forced_breakpoint</CODE> = $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend</CODE>];
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>::<CODE>valign_input</CODE>(
            $<CODE>lev</CODE>,
            $<CODE>level_end</CODE>,
            $<CODE>indentation</CODE>,
            $<CODE>rfields</CODE>,
            $<CODE>rtokens</CODE>,
            $<CODE>rpatterns</CODE>,
            $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend</CODE>] || $<CODE>in_comma_list</CODE>,
            $<CODE>outdent_long_lines</CODE>,
            $<CODE>is_terminal_ternary</CODE>,
            $<CODE>is_semicolon_terminated</CODE>,
            $<CODE>do_not_pad</CODE>,
            $<CODE>rvertical_tightness_flags</CODE>,
            $<CODE>level_jump</CODE>,
        );
        $<CODE>in_comma_list</CODE> =
          $<CODE>tokens_to_go</CODE>[$<CODE>iend</CODE>] eq ',' && $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend</CODE>];

        # <COMMENTS>flush</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>outdented</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS>
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>::<CODE>flush</CODE>() if ($<CODE>is_outdented_line</CODE>);

        $<CODE>do_not_pad</CODE> = 0;

        # <COMMENTS>Set</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>indicating</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS>
        # <COMMENTS>token</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>short</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS>
        # <COMMENTS>needed</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>subsequent</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comment</COMMENTS>.
        # <COMMENTS>Examples</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS>:
        #   {
        #   && (
        #   <COMMENTS>BEGIN</COMMENTS> {
        #   <COMMENTS>default</COMMENTS> {
        #   <COMMENTS>sub</COMMENTS> {
        $<CODE>last_output_short_opening_token</CODE>

          # <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
          = $<CODE>types_to_go</CODE>[$<CODE>iend</CODE>] =~ /^[\{\(\[L]$/

          # <COMMENTS>and</COMMENTS> <COMMENTS>either</COMMENTS>
          && (
            # <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
            $<CODE>iend</CODE> == $<CODE>ibeg</CODE>

            # <COMMENTS>or</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>.
            # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>identifiers</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>blanks</COMMENTS> <COMMENTS>like</COMMENTS> '<COMMENTS>sub</COMMENTS> <COMMENTS>doit</COMMENTS>'
            || ( $<CODE>iend</CODE> - $<CODE>ibeg</CODE> <= 2 && $<CODE>tokens_to_go</CODE>[$<CODE>ibeg</CODE>] !~ /\s+/ )
          )

          # <COMMENTS>and</COMMENTS> <COMMENTS>limit</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>10</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>widths</COMMENTS>
          && <CODE>token_sequence_length</CODE>( $<CODE>ibeg</CODE>, $<CODE>iend</CODE> ) <= 10;

    }    # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS>

    # <COMMENTS>remember</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>containing</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>containers</COMMENTS> <COMMENTS>for</COMMENTS>
    # <COMMENTS>later</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>set_adjusted_indentation</COMMENTS>
    <CODE>save_opening_indentation</CODE>( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>, $<CODE>rindentation_list</CODE> );
}

{    # <COMMENTS>begin</COMMENTS> <COMMENTS>make_alignment_patterns</COMMENTS>

    my %<CODE>block_type_map</CODE>;
    my %<CODE>keyword_map</CODE>;

    <CODE>BEGIN</CODE> {

        # <COMMENTS>map</COMMENTS> <COMMENTS>related</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>to</COMMENTS>
        # <COMMENTS>allow</COMMENTS> <COMMENTS>alignment</COMMENTS>
        %<CODE>block_type_map</CODE> = (
            '<LITERALS>unless</LITERALS>'  => '<LITERALS>if</LITERALS>',
            '<LITERALS>else</LITERALS>'    => '<LITERALS>if</LITERALS>',
            '<LITERALS>elsif</LITERALS>'   => '<LITERALS>if</LITERALS>',
            '<LITERALS>when</LITERALS>'    => '<LITERALS>if</LITERALS>',
            '<LITERALS>default</LITERALS>' => '<LITERALS>if</LITERALS>',
            '<LITERALS>case</LITERALS>'    => '<LITERALS>if</LITERALS>',
            '<LITERALS>sort</LITERALS>'    => '<LITERALS>map</LITERALS>',
            '<LITERALS>grep</LITERALS>'    => '<LITERALS>map</LITERALS>',
        );

        # <COMMENTS>map</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>class</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS>
        # <COMMENTS>long</COMMENTS> <COMMENTS>if</COMMENTS>/<COMMENTS>elsif</COMMENTS> <COMMENTS>sequences</COMMENTS>. [<COMMENTS>elsif</COMMENTS>.<COMMENTS>pl</COMMENTS>]
        %<CODE>keyword_map</CODE> = (
            '<LITERALS>unless</LITERALS>'  => '<LITERALS>if</LITERALS>',
            '<LITERALS>else</LITERALS>'    => '<LITERALS>if</LITERALS>',
            '<LITERALS>elsif</LITERALS>'   => '<LITERALS>if</LITERALS>',
            '<LITERALS>when</LITERALS>'    => '<LITERALS>given</LITERALS>',
            '<LITERALS>default</LITERALS>' => '<LITERALS>given</LITERALS>',
            '<LITERALS>case</LITERALS>'    => '<LITERALS>switch</LITERALS>',

            # <COMMENTS>treat</COMMENTS> <COMMENTS>an</COMMENTS> '<COMMENTS>undef</COMMENTS>' <COMMENTS>similar</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>quotes</COMMENTS>
            '<LITERALS>undef</LITERALS>' => '<LITERALS>Q</LITERALS>',
        );
    }

    sub <CODE>make_alignment_patterns</CODE> {

        # <COMMENTS>Here</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>important</COMMENTS> <COMMENTS>preliminary</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>three</COMMENTS> <COMMENTS>arrays</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS>
        # <COMMENTS>output</COMMENTS> <COMMENTS>line</COMMENTS>. <COMMENTS>These</COMMENTS> <COMMENTS>arrays</COMMENTS> <COMMENTS>contain</COMMENTS> <COMMENTS>strings</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>can</COMMENTS>
        # <COMMENTS>be</COMMENTS> <COMMENTS>tested</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS>
        # <COMMENTS>consecutive</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>aligned</COMMENTS> <COMMENTS>vertically</COMMENTS>.
        #
        # <COMMENTS>The</COMMENTS> <COMMENTS>three</COMMENTS> <COMMENTS>arrays</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>indexed</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS>
        # <COMMENTS>alignment</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>are</COMMENTS>:
        # @<COMMENTS>tokens</COMMENTS> - <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>.
        #   <COMMENTS>These</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> '=' '&&' '#' <COMMENTS>etc</COMMENTS> <COMMENTS>which</COMMENTS>
        #   <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>vertically</COMMENTS>.  <COMMENTS>These</COMMENTS> <COMMENTS>are</COMMENTS>
        #   <COMMENTS>decorated</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>various</COMMENTS> <COMMENTS>information</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS>
        #   <COMMENTS>nesting</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>vertical</COMMENTS>
        #   <COMMENTS>alignment</COMMENTS> <COMMENTS>matches</COMMENTS>.
        # @<COMMENTS>fields</COMMENTS> - <COMMENTS>the</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS>
        #   <COMMENTS>tokens</COMMENTS>.
        # @<COMMENTS>patterns</COMMENTS> - <COMMENTS>a</COMMENTS> <COMMENTS>modified</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>, <COMMENTS>one</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>alignment</COMMENTS>
        #   <COMMENTS>field</COMMENTS>.  <COMMENTS>These</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>normally</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>is</COMMENTS>
        #   <COMMENTS>allowed</COMMENTS>, <COMMENTS>even</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>match</COMMENTS>.
        my ( $<CODE>ibeg</CODE>, $<CODE>iend</CODE> ) = @<CODE>_</CODE>;
        my @<CODE>tokens</CODE>   = ();
        my @<CODE>fields</CODE>   = ();
        my @<CODE>patterns</CODE> = ();
        my $<CODE>i_start</CODE>  = $<CODE>ibeg</CODE>;
        my $<CODE>i</CODE>;

        my $<CODE>depth</CODE>                 = 0;
        my @<CODE>container_name</CODE>        = ("");
        my @<CODE>multiple_comma_arrows</CODE> = (undef);

        my $<CODE>j</CODE> = 0;    # <COMMENTS>field</COMMENTS> <COMMENTS>index</COMMENTS>

        $<CODE>patterns</CODE>[0] = "";
        for $<CODE>i</CODE> ( $<CODE>ibeg</CODE> .. $<CODE>iend</CODE> ) {

            # <COMMENTS>Keep</COMMENTS> <COMMENTS>track</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>containers</COMMENTS> <COMMENTS>balanced</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>only</COMMENTS>.
            # <COMMENTS>These</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>cross</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>alignments</COMMENTS>.
            # <COMMENTS>Unbalanced</COMMENTS> <COMMENTS>containers</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>aligning</COMMENTS> <COMMENTS>across</COMMENTS>
            # <COMMENTS>container</COMMENTS> <COMMENTS>boundaries</COMMENTS>.
            if ( $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>] eq '(' ) {

                # <COMMENTS>if</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>balanced</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>...
                my $<CODE>i_mate</CODE> = $<CODE>mate_index_to_go</CODE>[$<CODE>i</CODE>];
                if ( $<CODE>i_mate</CODE> > $<CODE>i</CODE> && $<CODE>i_mate</CODE> <= $<CODE>iend</CODE> ) {
                    $<CODE>depth</CODE>++;
                    my $<CODE>seqno</CODE> = $<CODE>type_sequence_to_go</CODE>[$<CODE>i</CODE>];
                    my $<CODE>count</CODE> = <CODE>comma_arrow_count</CODE>($<CODE>seqno</CODE>);
                    $<CODE>multiple_comma_arrows</CODE>[$<CODE>depth</CODE>] = $<CODE>count</CODE> && $<CODE>count</CODE> > 1;

                    # <COMMENTS>Append</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>name</COMMENTS>
                    # <COMMENTS>more</COMMENTS> <COMMENTS>unique</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>commas</COMMENTS>
                    # <COMMENTS>within</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>container</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>helps</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>undesirable</COMMENTS>
                    # <COMMENTS>alignments</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>containers</COMMENTS>.
                    my $<CODE>name</CODE> = <CODE>previous_nonblank_token</CODE>($<CODE>i</CODE>);
                    $<CODE>name</CODE> =~ s/^->//;
                    $<CODE>container_name</CODE>[$<CODE>depth</CODE>] = "+" . $<CODE>name</CODE>;

                    # <COMMENTS>Make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>unique</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>.
                    # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>vertically</COMMENTS> <COMMENTS>aligning</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS>,
                    # <COMMENTS>append</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>because</COMMENTS>
                    # <COMMENTS>it</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>containers</COMMENTS>
                    # <COMMENTS>for</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>align</COMMENTS>.  <COMMENTS>Here</COMMENTS>
                    # <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>BAD</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>commas</COMMENTS> (<COMMENTS>because</COMMENTS>
                    # <COMMENTS>the</COMMENTS> <COMMENTS>atan2</COMMENTS> <COMMENTS>functions</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>aligned</COMMENTS>):
                    #    <COMMENTS>$XY</COMMENTS> =
                    #      <COMMENTS>$X</COMMENTS> * <COMMENTS>$RTYSQP1</COMMENTS> * <COMMENTS>atan2</COMMENTS>( <COMMENTS>$X</COMMENTS>, <COMMENTS>$RTYSQP1</COMMENTS> ) +
                    #      <COMMENTS>$Y</COMMENTS> * <COMMENTS>$RTXSQP1</COMMENTS> * <COMMENTS>atan2</COMMENTS>( <COMMENTS>$Y</COMMENTS>, <COMMENTS>$RTXSQP1</COMMENTS> ) -
                    #      <COMMENTS>$X</COMMENTS> * <COMMENTS>atan2</COMMENTS>( <COMMENTS>$X</COMMENTS>,            <COMMENTS>1</COMMENTS> ) -
                    #      <COMMENTS>$Y</COMMENTS> * <COMMENTS>atan2</COMMENTS>( <COMMENTS>$Y</COMMENTS>,            <COMMENTS>1</COMMENTS> );
                    #
                    # <COMMENTS>On</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>hand</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>okay</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>if</COMMENTS>
                    # <COMMENTS>opening</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>align</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS>:
                    #    <COMMENTS>glVertex3d</COMMENTS>( <COMMENTS>$cx</COMMENTS> + <COMMENTS>$s</COMMENTS> * <COMMENTS>$xs</COMMENTS>, <COMMENTS>$cy</COMMENTS>,            <COMMENTS>$z</COMMENTS> );
                    #    <COMMENTS>glVertex3d</COMMENTS>( <COMMENTS>$cx</COMMENTS>,            <COMMENTS>$cy</COMMENTS> + <COMMENTS>$s</COMMENTS> * <COMMENTS>$ys</COMMENTS>, <COMMENTS>$z</COMMENTS> );
                    #    <COMMENTS>glVertex3d</COMMENTS>( <COMMENTS>$cx</COMMENTS> - <COMMENTS>$s</COMMENTS> * <COMMENTS>$xs</COMMENTS>, <COMMENTS>$cy</COMMENTS>,            <COMMENTS>$z</COMMENTS> );
                    #    <COMMENTS>glVertex3d</COMMENTS>( <COMMENTS>$cx</COMMENTS>,            <COMMENTS>$cy</COMMENTS> - <COMMENTS>$s</COMMENTS> * <COMMENTS>$ys</COMMENTS>, <COMMENTS>$z</COMMENTS> );
                    #
                    # <COMMENTS>To</COMMENTS> <COMMENTS>distinguish</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>situations</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS>
                    # <COMMENTS>append</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>matching</COMMENTS>
                    # <COMMENTS>token</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>beginning</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>name</COMMENTS>.  <COMMENTS>This</COMMENTS>
                    # <COMMENTS>will</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>reject</COMMENTS> <COMMENTS>undesirable</COMMENTS>
                    # <COMMENTS>matches</COMMENTS>.

                    # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>aligning</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>paren</COMMENTS>...
                    if ( $<CODE>matching_token_to_go</CODE>[$<CODE>i</CODE>] eq '' ) {

                        # <COMMENTS>Sum</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>alignment</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS>.
                        my $<CODE>len</CODE> =
                          ( $<CODE>i_start</CODE> == $<CODE>ibeg</CODE> )
                          ? <CODE>total_line_length</CODE>( $<CODE>i_start</CODE>, $<CODE>i</CODE> - 1 )
                          : <CODE>token_sequence_length</CODE>( $<CODE>i_start</CODE>, $<CODE>i</CODE> - 1 );

                        # <COMMENTS>tack</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>onto</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>unique</COMMENTS>
                        $<CODE>container_name</CODE>[$<CODE>depth</CODE>] .= "-" . $<CODE>len</CODE>;
                    }
                }
            }
            elsif ( $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>] eq ')' ) {
                $<CODE>depth</CODE>-- if $<CODE>depth</CODE> > 0;
            }

            # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>synchronization</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>with</COMMENTS>
            # <COMMENTS>a</COMMENTS> <COMMENTS>field</COMMENTS>
            if ( $<CODE>i</CODE> > $<CODE>i_start</CODE> && $<CODE>matching_token_to_go</CODE>[$<CODE>i</CODE>] ne '' ) {

                my $<CODE>tok</CODE> = my $<CODE>raw_tok</CODE> = $<CODE>matching_token_to_go</CODE>[$<CODE>i</CODE>];

                # <COMMENTS>make</COMMENTS> <COMMENTS>separators</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depths</COMMENTS> <COMMENTS>unique</COMMENTS>
                # <COMMENTS>by</COMMENTS> <COMMENTS>appending</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>digit</COMMENTS>.
                if ( $<CODE>raw_tok</CODE> ne '#' ) {
                    $<CODE>tok</CODE> .= "$<CODE>nesting_depth_to_go</CODE>[$<CODE>i</CODE>]";
                }

                # <COMMENTS>also</COMMENTS> <COMMENTS>decorate</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS>
                # <COMMENTS>unwanted</COMMENTS> <COMMENTS>cross</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>alignments</COMMENTS>.
                if ( $<CODE>raw_tok</CODE> eq ',' || $<CODE>raw_tok</CODE> eq '=>' ) {
                    if ( $<CODE>container_name</CODE>[$<CODE>depth</CODE>] ) {
                        $<CODE>tok</CODE> .= $<CODE>container_name</CODE>[$<CODE>depth</CODE>];
                    }
                }

                # <COMMENTS>Patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>aligning</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>if</COMMENTS>, <COMMENTS>unless</COMMENTS>.
                # <COMMENTS>Mark</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>if</COMMENTS>, <COMMENTS>unless</COMMENTS> <COMMENTS>statements</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>names</COMMENTS>.
                # <COMMENTS>This</COMMENTS> <COMMENTS>makes</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>if</COMMENTS>, <COMMENTS>unless</COMMENTS> <COMMENTS>which</COMMENTS>
                # <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>marked</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>present</COMMENTS>.  <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>ever</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>name</COMMENTS>
                # <COMMENTS>them</COMMENTS> <COMMENTS>too</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>ci</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>distinguish</COMMENTS> <COMMENTS>them</COMMENTS>.
                # <COMMENTS>Example</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS>:
                #    <COMMENTS>return</COMMENTS> ( <COMMENTS>2</COMMENTS>, "<COMMENTS>DBERROR</COMMENTS>" )
                #      <COMMENTS>if</COMMENTS> ( <COMMENTS>$retval</COMMENTS> == <COMMENTS>2</COMMENTS> );
                #    <COMMENTS>if</COMMENTS>   ( <COMMENTS>scalar</COMMENTS> @<COMMENTS>_</COMMENTS> ) {
                #        <COMMENTS>my</COMMENTS> ( <COMMENTS>$a</COMMENTS>, <COMMENTS>$b</COMMENTS>, <COMMENTS>$c</COMMENTS>, <COMMENTS>$d</COMMENTS>, <COMMENTS>$e</COMMENTS>, <COMMENTS>$f</COMMENTS> ) = @<COMMENTS>_</COMMENTS>;
                #    }
                if ( $<CODE>raw_tok</CODE> eq '(' ) {
                    my $<CODE>ci</CODE> = $<CODE>ci_levels_to_go</CODE>[$<CODE>ibeg</CODE>];
                    if (   $<CODE>container_name</CODE>[$<CODE>depth</CODE>] =~ /^\+(if|unless)/
                        && $<CODE>ci</CODE> )
                    {
                        $<CODE>tok</CODE> .= $<CODE>container_name</CODE>[$<CODE>depth</CODE>];
                    }
                }

                # <COMMENTS>Decorate</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS>
                # <COMMENTS>unwanted</COMMENTS> <COMMENTS>alignments</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>:
                # <COMMENTS>foreach</COMMENTS> ( @{<COMMENTS>$routput_array</COMMENTS>} ) { <COMMENTS>$fh</COMMENTS>-><COMMENTS>print</COMMENTS>(<COMMENTS>$_</COMMENTS>) }
                # <COMMENTS>eval</COMMENTS>                          { <COMMENTS>$fh</COMMENTS>-><COMMENTS>close</COMMENTS>() };
                if ( $<CODE>raw_tok</CODE> eq '{' && $<CODE>block_type_to_go</CODE>[$<CODE>i</CODE>] ) {
                    my $<CODE>block_type</CODE> = $<CODE>block_type_to_go</CODE>[$<CODE>i</CODE>];

                    # <COMMENTS>map</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>related</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS>
                    # <COMMENTS>else</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS>
                    $<CODE>block_type</CODE> = $<CODE>block_type_map</CODE>{$<CODE>block_type</CODE>}
                      if ( defined( $<CODE>block_type_map</CODE>{$<CODE>block_type</CODE>} ) );

                    # <COMMENTS>remove</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS>
                    # <COMMENTS>regardless</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>name</COMMENTS>
                    if ( $<CODE>block_type</CODE> =~ /^sub / ) { $<CODE>block_type</CODE> = '<LITERALS>sub</LITERALS>' }

                    # <COMMENTS>allow</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>control</COMMENTS>-<COMMENTS>type</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS>
                    if ( $<CODE>block_type</CODE> =~ /^[A-Z]+$/ ) { $<CODE>block_type</CODE> = '<LITERALS>BEGIN</LITERALS>' }

                    $<CODE>tok</CODE> .= $<CODE>block_type</CODE>;
                }

                # <COMMENTS>concatenate</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>consecutive</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>form</COMMENTS>
                # <COMMENTS>the</COMMENTS> <COMMENTS>field</COMMENTS>
                push( @<CODE>fields</CODE>,
                    join( '', @<CODE>tokens_to_go</CODE>[ $<CODE>i_start</CODE> .. $<CODE>i</CODE> - 1 ] ) );

                # <COMMENTS>store</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>field</COMMENTS>
                push( @<CODE>tokens</CODE>, $<CODE>tok</CODE> );

                # <COMMENTS>get</COMMENTS> <COMMENTS>ready</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>batch</COMMENTS>
                $<CODE>i_start</CODE> = $<CODE>i</CODE>;
                $<CODE>j</CODE>++;
                $<CODE>patterns</CODE>[$<CODE>j</CODE>] = "";
            }

            # <COMMENTS>continue</COMMENTS> <COMMENTS>accumulating</COMMENTS> <COMMENTS>tokens</COMMENTS>
            # <COMMENTS>handle</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>keywords</COMMENTS>..
            if ( $<CODE>types_to_go</CODE>[$<CODE>i</CODE>] ne '<LITERALS>k</LITERALS>' ) {
                my $<CODE>type</CODE> = $<CODE>types_to_go</CODE>[$<CODE>i</CODE>];

                # <COMMENTS>Mark</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>arrows</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>to</COMMENTS>
                # <COMMENTS>get</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS>. <COMMENTS>Testfile</COMMENTS>: <COMMENTS>mixed</COMMENTS>.<COMMENTS>pl</COMMENTS>.
                if ( ( $<CODE>i</CODE> < $<CODE>iend</CODE> - 1 ) && ( $<CODE>type</CODE> =~ /^[wnC]$/ ) ) {
                    my $<CODE>next_type</CODE> = $<CODE>types_to_go</CODE>[ $<CODE>i</CODE> + 1 ];
                    my $<CODE>i_next_nonblank</CODE> =
                      ( ( $<CODE>next_type</CODE> eq '<LITERALS>b</LITERALS>' ) ? $<CODE>i</CODE> + 2 : $<CODE>i</CODE> + 1 );

                    if ( $<CODE>types_to_go</CODE>[$<CODE>i_next_nonblank</CODE>] eq '=>' ) {
                        $<CODE>type</CODE> = '<LITERALS>Q</LITERALS>';

                        # <COMMENTS>Patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>ignore</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>minus</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>words</COMMENTS>,
                        # <COMMENTS>by</COMMENTS> <COMMENTS>changing</COMMENTS> <COMMENTS>pattern</COMMENTS> '<COMMENTS>mQ</COMMENTS>' <COMMENTS>into</COMMENTS> <COMMENTS>just</COMMENTS> '<COMMENTS>Q</COMMENTS>',
                        # <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
                        #  <COMMENTS>Button</COMMENTS>   => "<COMMENTS>Print</COMMENTS> <COMMENTS>letter</COMMENTS> \"~<COMMENTS>$_</COMMENTS>\"",
                        #  -<COMMENTS>command</COMMENTS> => [ <COMMENTS>sub</COMMENTS> { <COMMENTS>print</COMMENTS> "<COMMENTS>$_</COMMENTS>[<COMMENTS>0</COMMENTS>]\<COMMENTS>n</COMMENTS>" }, <COMMENTS>$_</COMMENTS> ],
                        if ( $<CODE>patterns</CODE>[$<CODE>j</CODE>] eq '<LITERALS>m</LITERALS>' ) { $<CODE>patterns</CODE>[$<CODE>j</CODE>] = "" }
                    }
                }

                # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>quotes</COMMENTS> <COMMENTS>align</COMMENTS>
                if ( $<CODE>type</CODE> eq '<LITERALS>n</LITERALS>' ) { $<CODE>type</CODE> = '<LITERALS>Q</LITERALS>' }

                # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>ignore</COMMENTS> <COMMENTS>any</COMMENTS> ! <COMMENTS>in</COMMENTS> <COMMENTS>patterns</COMMENTS>
                if ( $<CODE>type</CODE> eq '!' ) { $<CODE>type</CODE> = '' }

                $<CODE>patterns</CODE>[$<CODE>j</CODE>] .= $<CODE>type</CODE>;
            }

            # <COMMENTS>for</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>text</COMMENTS>
            else {

                my $<CODE>tok</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>];

                # <COMMENTS>but</COMMENTS> <COMMENTS>map</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS>
                # <COMMENTS>alignment</COMMENTS>.
                $<CODE>tok</CODE> = $<CODE>keyword_map</CODE>{$<CODE>tok</CODE>}
                  if ( defined( $<CODE>keyword_map</CODE>{$<CODE>tok</CODE>} ) );
                $<CODE>patterns</CODE>[$<CODE>j</CODE>] .= $<CODE>tok</CODE>;
            }
        }

        # <COMMENTS>done</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> .. <COMMENTS>join</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>field</COMMENTS>
        push( @<CODE>fields</CODE>, join( '', @<CODE>tokens_to_go</CODE>[ $<CODE>i_start</CODE> .. $<CODE>iend</CODE> ] ) );
        return ( \@<CODE>tokens</CODE>, \@<CODE>fields</CODE>, \@<CODE>patterns</CODE> );
    }

}    # <COMMENTS>end</COMMENTS> <COMMENTS>make_alignment_patterns</COMMENTS>

{    # <COMMENTS>begin</COMMENTS> <COMMENTS>unmatched_indexes</COMMENTS>

    # <COMMENTS>closure</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>track</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>unbalanced</COMMENTS> <COMMENTS>containers</COMMENTS>.
    # <COMMENTS>arrays</COMMENTS> <COMMENTS>shared</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>routines</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>block</COMMENTS>:
    my @<CODE>unmatched_opening_indexes_in_this_batch</CODE>;
    my @<CODE>unmatched_closing_indexes_in_this_batch</CODE>;
    my %<CODE>comma_arrow_count</CODE>;

    sub <CODE>is_unbalanced_batch</CODE> {
        @<CODE>unmatched_opening_indexes_in_this_batch</CODE> +
          @<CODE>unmatched_closing_indexes_in_this_batch</CODE>;
    }

    sub <CODE>comma_arrow_count</CODE> {
        my $<CODE>seqno</CODE> = $<CODE>_</CODE>[0];
        return $<CODE>comma_arrow_count</CODE>{$<CODE>seqno</CODE>};
    }

    sub <CODE>match_opening_and_closing_tokens</CODE> {

        # <COMMENTS>Match</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>braces</COMMENTS>, <COMMENTS>etc</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>.
        # <COMMENTS>This</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>stored</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>unstoring</COMMENTS>
        # <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>otherwise</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>trouble</COMMENTS>.

        @<CODE>unmatched_opening_indexes_in_this_batch</CODE> = ();
        @<CODE>unmatched_closing_indexes_in_this_batch</CODE> = ();
        %<CODE>comma_arrow_count</CODE>                       = ();
        my $<CODE>comma_arrow_count_contained</CODE> = 0;

        my ( $<CODE>i</CODE>, $<CODE>i_mate</CODE>, $<CODE>token</CODE> );
        foreach $<CODE>i</CODE> ( 0 .. $<CODE>max_index_to_go</CODE> ) {
            if ( $<CODE>type_sequence_to_go</CODE>[$<CODE>i</CODE>] ) {
                $<CODE>token</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>];
                if ( $<CODE>token</CODE> =~ /^[\(\[\{\?]$/ ) {
                    push @<CODE>unmatched_opening_indexes_in_this_batch</CODE>, $<CODE>i</CODE>;
                }
                elsif ( $<CODE>token</CODE> =~ /^[\)\]\}\:]$/ ) {

                    $<CODE>i_mate</CODE> = pop @<CODE>unmatched_opening_indexes_in_this_batch</CODE>;
                    if ( defined($<CODE>i_mate</CODE>) && $<CODE>i_mate</CODE> >= 0 ) {
                        if ( $<CODE>type_sequence_to_go</CODE>[$<CODE>i_mate</CODE>] ==
                            $<CODE>type_sequence_to_go</CODE>[$<CODE>i</CODE>] )
                        {
                            $<CODE>mate_index_to_go</CODE>[$<CODE>i</CODE>]      = $<CODE>i_mate</CODE>;
                            $<CODE>mate_index_to_go</CODE>[$<CODE>i_mate</CODE>] = $<CODE>i</CODE>;
                            my $<CODE>seqno</CODE> = $<CODE>type_sequence_to_go</CODE>[$<CODE>i</CODE>];
                            if ( $<CODE>comma_arrow_count</CODE>{$<CODE>seqno</CODE>} ) {
                                $<CODE>comma_arrow_count_contained</CODE> +=
                                  $<CODE>comma_arrow_count</CODE>{$<CODE>seqno</CODE>};
                            }
                        }
                        else {
                            push @<CODE>unmatched_opening_indexes_in_this_batch</CODE>,
                              $<CODE>i_mate</CODE>;
                            push @<CODE>unmatched_closing_indexes_in_this_batch</CODE>, $<CODE>i</CODE>;
                        }
                    }
                    else {
                        push @<CODE>unmatched_closing_indexes_in_this_batch</CODE>, $<CODE>i</CODE>;
                    }
                }
            }
            elsif ( $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>] eq '=>' ) {
                if (@<CODE>unmatched_opening_indexes_in_this_batch</CODE>) {
                    my $<CODE>j</CODE>     = $<CODE>unmatched_opening_indexes_in_this_batch</CODE>[-1];
                    my $<CODE>seqno</CODE> = $<CODE>type_sequence_to_go</CODE>[$<CODE>j</CODE>];
                    $<CODE>comma_arrow_count</CODE>{$<CODE>seqno</CODE>}++;
                }
            }
        }
        return $<CODE>comma_arrow_count_contained</CODE>;
    }

    sub <CODE>save_opening_indentation</CODE> {

        # <COMMENTS>This</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>batch</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>output</COMMENTS>. <COMMENTS>It</COMMENTS>
        # <COMMENTS>saves</COMMENTS> <COMMENTS>indentations</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>unmatched</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>tokens</COMMENTS>.
        # <COMMENTS>These</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>get_opening_indentation</COMMENTS>.

        my ( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>, $<CODE>rindentation_list</CODE> ) = @<CODE>_</CODE>;

        # <COMMENTS>we</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>longer</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>indentations</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>saved</COMMENTS> <COMMENTS>indentations</COMMENTS> <COMMENTS>which</COMMENTS>
        # <COMMENTS>are</COMMENTS> <COMMENTS>unmatched</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS>
        # <COMMENTS>never</COMMENTS> <COMMENTS>encounter</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>again</COMMENTS>.  <COMMENTS>So</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>delete</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>size</COMMENTS> <COMMENTS>down</COMMENTS>.
        foreach (@<CODE>unmatched_closing_indexes_in_this_batch</CODE>) {
            my $<CODE>seqno</CODE> = $<CODE>type_sequence_to_go</CODE>[$<CODE>_</CODE>];
            delete $<CODE>saved_opening_indentation</CODE>{$<CODE>seqno</CODE>};
        }

        # <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>save</COMMENTS> <COMMENTS>indentations</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>unmatched</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>tokens</COMMENTS>
        # <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>subsequent</COMMENTS> <COMMENTS>batch</COMMENTS>.
        foreach (@<CODE>unmatched_opening_indexes_in_this_batch</CODE>) {
            my $<CODE>seqno</CODE> = $<CODE>type_sequence_to_go</CODE>[$<CODE>_</CODE>];
            $<CODE>saved_opening_indentation</CODE>{$<CODE>seqno</CODE>} = [
                <CODE>lookup_opening_indentation</CODE>(
                    $<CODE>_</CODE>, $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>, $<CODE>rindentation_list</CODE>
                )
            ];
        }
    }
}    # <COMMENTS>end</COMMENTS> <COMMENTS>unmatched_indexes</COMMENTS>

sub <CODE>get_opening_indentation</CODE> {

    # <COMMENTS>get</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
    # <COMMENTS>corresponding</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>batch</COMMENTS>.
    #
    # <COMMENTS>given</COMMENTS>:
    # <COMMENTS>$i_closing</COMMENTS> - <COMMENTS>index</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> ')' '}' <COMMENTS>or</COMMENTS> ']'
    #
    # <COMMENTS>$ri_first</COMMENTS> - <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>output</COMMENTS>
    #               <COMMENTS>line</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
    # <COMMENTS>$ri_last</COMMENTS> - <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>line</COMMENTS>
    #              <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
    # <COMMENTS>$rindentation_list</COMMENTS> - <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>containing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS>
    #            <COMMENTS>used</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS>.
    #
    # <COMMENTS>return</COMMENTS>:
    #   -<COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>contained</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
    #    <COMMENTS>which</COMMENTS> <COMMENTS>matches</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>$i_opening</COMMENTS>
    #   -<COMMENTS>and</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>offset</COMMENTS> (<COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>columns</COMMENTS>) <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>
    #
    my ( $<CODE>i_closing</CODE>, $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>, $<CODE>rindentation_list</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>first</COMMENTS>, <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>batch</COMMENTS>
    my $<CODE>i_opening</CODE> = $<CODE>mate_index_to_go</CODE>[$<CODE>i_closing</CODE>];
    my ( $<CODE>indent</CODE>, $<CODE>offset</CODE>, $<CODE>is_leading</CODE>, $<CODE>exists</CODE> );
    $<CODE>exists</CODE> = 1;
    if ( $<CODE>i_opening</CODE> >= 0 ) {

        # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS>..<COMMENTS>look</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS>
        ( $<CODE>indent</CODE>, $<CODE>offset</CODE>, $<CODE>is_leading</CODE> ) =
          <CODE>lookup_opening_indentation</CODE>( $<CODE>i_opening</CODE>, $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>,
            $<CODE>rindentation_list</CODE> );
    }

    # <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>stored</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>batch</COMMENTS>
    else {
        my $<CODE>seqno</CODE> = $<CODE>type_sequence_to_go</CODE>[$<CODE>i_closing</CODE>];
        if ($<CODE>seqno</CODE>) {
            if ( $<CODE>saved_opening_indentation</CODE>{$<CODE>seqno</CODE>} ) {
                ( $<CODE>indent</CODE>, $<CODE>offset</CODE>, $<CODE>is_leading</CODE> ) =
                  @{ $<CODE>saved_opening_indentation</CODE>{$<CODE>seqno</CODE>} };
            }

            # <COMMENTS>some</COMMENTS> <COMMENTS>kind</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>serious</COMMENTS> <COMMENTS>error</COMMENTS>
            # (<COMMENTS>example</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>badfile</COMMENTS>.<COMMENTS>t</COMMENTS>)
            else {
                $<CODE>indent</CODE>     = 0;
                $<CODE>offset</CODE>     = 0;
                $<CODE>is_leading</CODE> = 0;
                $<CODE>exists</CODE>     = 0;
            }
        }

        # <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>unbalanced</COMMENTS> <COMMENTS>container</COMMENTS>
        else {
            $<CODE>indent</CODE>     = 0;
            $<CODE>offset</CODE>     = 0;
            $<CODE>is_leading</CODE> = 0;
            $<CODE>exists</CODE>     = 0;
        }
    }
    return ( $<CODE>indent</CODE>, $<CODE>offset</CODE>, $<CODE>is_leading</CODE>, $<CODE>exists</CODE> );
}

sub <CODE>lookup_opening_indentation</CODE> {

    # <COMMENTS>get</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>batch</COMMENTS>
    # <COMMENTS>which</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>selected</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
    #
    # <COMMENTS>given</COMMENTS>:
    #   <COMMENTS>$i_opening</COMMENTS> - <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>batch</COMMENTS>
    #                <COMMENTS>whose</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS>
    #   <COMMENTS>$ri_first</COMMENTS> - <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>output</COMMENTS>
    #               <COMMENTS>line</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
    #   <COMMENTS>$ri_last</COMMENTS> - <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>line</COMMENTS>
    #              <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
    #   <COMMENTS>$rindentation_list</COMMENTS> - <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>containing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS>
    #            <COMMENTS>used</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS>.  (<COMMENTS>NOTE</COMMENTS>: <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>slot</COMMENTS> <COMMENTS>in</COMMENTS>
    #            <COMMENTS>this</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>returned</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS>
    #            <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>indentations</COMMENTS>).
    #
    # <COMMENTS>return</COMMENTS>
    #   -<COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>contained</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>$i_opening</COMMENTS>
    #   -<COMMENTS>and</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>offset</COMMENTS> (<COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>columns</COMMENTS>) <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>

    my ( $<CODE>i_opening</CODE>, $<CODE>ri_start</CODE>, $<CODE>ri_last</CODE>, $<CODE>rindentation_list</CODE> ) = @<CODE>_</CODE>;

    my $<CODE>nline</CODE> = $<CODE>rindentation_list</CODE>->[0];    # <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>lookup</COMMENTS>

    # <COMMENTS>reset</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>location</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
    $<CODE>nline</CODE> = 0 if ( $<CODE>i_opening</CODE> < $<CODE>ri_start</CODE>->[$<CODE>nline</CODE>] );

    # <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>correct</COMMENTS> <COMMENTS>line</COMMENTS>
    unless ( $<CODE>i_opening</CODE> > $<CODE>ri_last</CODE>->[-1] ) {
        while ( $<CODE>i_opening</CODE> > $<CODE>ri_last</CODE>->[$<CODE>nline</CODE>] ) { $<CODE>nline</CODE>++; }
    }

    # <COMMENTS>error</COMMENTS> - <COMMENTS>token</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>bounds</COMMENTS> - <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>
    else {
        <CODE>warning</CODE>(
"<LITERALS>non</LITERALS>-<LITERALS>fatal</LITERALS> <LITERALS>program</LITERALS> <LITERALS>bug</LITERALS> <LITERALS>in</LITERALS> <LITERALS>lookup_opening_indentation</LITERALS> - <LITERALS>index</LITERALS> <LITERALS>out</LITERALS> <LITERALS>of</LITERALS> <LITERALS>range</LITERALS>\n"
        );
        <CODE>report_definite_bug</CODE>();
        $<CODE>nline</CODE> = $#{$<CODE>ri_last</CODE>};
    }

    $<CODE>rindentation_list</CODE>->[0] =
      $<CODE>nline</CODE>;    # <COMMENTS>save</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>call</COMMENTS>
    my $<CODE>ibeg</CODE>       = $<CODE>ri_start</CODE>->[$<CODE>nline</CODE>];
    my $<CODE>offset</CODE>     = <CODE>token_sequence_length</CODE>( $<CODE>ibeg</CODE>, $<CODE>i_opening</CODE> ) - 1;
    my $<CODE>is_leading</CODE> = ( $<CODE>ibeg</CODE> == $<CODE>i_opening</CODE> );
    return ( $<CODE>rindentation_list</CODE>->[ $<CODE>nline</CODE> + 1 ], $<CODE>offset</CODE>, $<CODE>is_leading</CODE> );
}

{
    my %<CODE>is_if_elsif_else_unless_while_until_for_foreach</CODE>;

    <CODE>BEGIN</CODE> {

        # <COMMENTS>These</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>opening</COMMENTS>
        # <COMMENTS>curly</COMMENTS>.  <COMMENTS>Note</COMMENTS>: '<COMMENTS>else</COMMENTS>' <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>included</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>trailing</COMMENTS>
        # <COMMENTS>if</COMMENTS>/<COMMENTS>elsif</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>appended</COMMENTS>.
        # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS>: <COMMENTS>added</COMMENTS> '<COMMENTS>case</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>when</COMMENTS>'
        @<CODE>_</CODE> = qw(<LITERALS>if</LITERALS> <LITERALS>elsif</LITERALS> <LITERALS>else</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>while</LITERALS> <LITERALS>until</LITERALS> <LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS> <LITERALS>case</LITERALS> <LITERALS>when</LITERALS>);
        @<CODE>is_if_elsif_else_unless_while_until_for_foreach</CODE>{@<CODE>_</CODE>} =
          (1) x scalar(@<CODE>_</CODE>);
    }

    sub <CODE>set_adjusted_indentation</CODE> {

        # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>final</COMMENTS> <COMMENTS>say</COMMENTS> <COMMENTS>regarding</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS>
        # <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>starts</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>basic</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS>
        # <COMMENTS>defined</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>takes</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>account</COMMENTS> <COMMENTS>any</COMMENTS>
        # <COMMENTS>options</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>regarding</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>indenting</COMMENTS> <COMMENTS>and</COMMENTS>
        # <COMMENTS>outdenting</COMMENTS>.

        my ( $<CODE>ibeg</CODE>, $<CODE>iend</CODE>, $<CODE>rfields</CODE>, $<CODE>rpatterns</CODE>, $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>,
            $<CODE>rindentation_list</CODE>, $<CODE>level_jump</CODE> )
          = @<CODE>_</CODE>;

        # <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
        my ( $<CODE>terminal_type</CODE>, $<CODE>i_terminal</CODE> ) =
          <CODE>terminal_type</CODE>( \@<CODE>types_to_go</CODE>, \@<CODE>block_type_to_go</CODE>, $<CODE>ibeg</CODE>, $<CODE>iend</CODE> );

        my $<CODE>is_outdented_line</CODE> = 0;

        my $<CODE>is_semicolon_terminated</CODE> = $<CODE>terminal_type</CODE> eq ';'
          && $<CODE>nesting_depth_to_go</CODE>[$<CODE>iend</CODE>] < $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg</CODE>];

        ##########################################################
        # <COMMENTS>Section</COMMENTS> <COMMENTS>1</COMMENTS>: <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>indentation</COMMENTS>
        #
        # <COMMENTS>Most</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>indented</COMMENTS> <COMMENTS>according</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>initial</COMMENTS> <COMMENTS>token</COMMENTS>.
        # <COMMENTS>But</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>outdent</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>terminal</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>cases</COMMENTS>...
        # <COMMENTS>adjust_indentation</COMMENTS> <COMMENTS>flag</COMMENTS>:
        #       <COMMENTS>0</COMMENTS> - <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>adjust</COMMENTS>
        #       <COMMENTS>1</COMMENTS> - <COMMENTS>outdent</COMMENTS>
        #       <COMMENTS>2</COMMENTS> - <COMMENTS>vertically</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
        #       <COMMENTS>3</COMMENTS> - <COMMENTS>indent</COMMENTS>
        ##########################################################
        my $<CODE>adjust_indentation</CODE>         = 0;
        my $<CODE>default_adjust_indentation</CODE> = $<CODE>adjust_indentation</CODE>;

        my (
            $<CODE>opening_indentation</CODE>, $<CODE>opening_offset</CODE>,
            $<CODE>is_leading</CODE>,          $<CODE>opening_exists</CODE>
        );

        # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>type</COMMENTS>..
        if ( $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] =~ /^[\)\}\]R]$/ ) {

            # <COMMENTS>get</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>containing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>corresponding</COMMENTS>
            # <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
            (
                $<CODE>opening_indentation</CODE>, $<CODE>opening_offset</CODE>,
                $<CODE>is_leading</CODE>,          $<CODE>opening_exists</CODE>
              )
              = <CODE>get_opening_indentation</CODE>( $<CODE>ibeg</CODE>, $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>,
                $<CODE>rindentation_list</CODE> );

            # <COMMENTS>First</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>behavior</COMMENTS>:
            if (

                # <COMMENTS>default</COMMENTS> <COMMENTS>behavior</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>outdent</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>lines</COMMENTS>
                # <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>form</COMMENTS>:   ");  };  ];  )-><COMMENTS>xxx</COMMENTS>;"
                $<CODE>is_semicolon_terminated</CODE>

                # <COMMENTS>and</COMMENTS> '<COMMENTS>cuddled</COMMENTS> <COMMENTS>parens</COMMENTS>' <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>form</COMMENTS>:   ")-><COMMENTS>pack</COMMENTS>("
                || (
                       $<CODE>terminal_type</CODE> eq '('
                    && $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq ')'
                    && ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>iend</CODE>] + 1 ==
                        $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg</CODE>] )
                )

                # <COMMENTS>and</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>lower</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS>
                # <COMMENTS>PATCH</COMMENTS>: <COMMENTS>and</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>style</COMMENTS> <COMMENTS>allows</COMMENTS> <COMMENTS>undoing</COMMENTS> <COMMENTS>continuation</COMMENTS>
                # <COMMENTS>for</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>. <COMMENTS>We</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>wait</COMMENTS> <COMMENTS>until</COMMENTS>
                # <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>known</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>make</COMMENTS>
                # <COMMENTS>a</COMMENTS> <COMMENTS>decision</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>require</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>pass</COMMENTS>.
                || ( $<CODE>level_jump</CODE> < 0 && !$<CODE>some_closing_token_indentation</CODE> )
              )
            {
                $<CODE>adjust_indentation</CODE> = 1;
            }

            # <COMMENTS>outdent</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> '),'
            if (
                $<CODE>terminal_type</CODE> eq ','

                # <COMMENTS>allow</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>comma</COMMENTS>
                && $<CODE>i_terminal</CODE> == $<CODE>ibeg</CODE> + 1

                # <COMMENTS>require</COMMENTS> <COMMENTS>LIST</COMMENTS> <COMMENTS>environment</COMMENTS>; <COMMENTS>otherwise</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>outdent</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>much</COMMENTS> -
                # <COMMENTS>this</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>calls</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>parentheses</COMMENTS> (<COMMENTS>overload</COMMENTS>.<COMMENTS>t</COMMENTS>);
                && $<CODE>container_environment_to_go</CODE>[$<CODE>i_terminal</CODE>] eq '<LITERALS>LIST</LITERALS>'
              )
            {
                $<CODE>adjust_indentation</CODE> = 1;
            }

            # <COMMENTS>undo</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>if</COMMENTS>
            # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>decrease</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>allow</COMMENTS>
            # <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>counterpart</COMMENTS>, <COMMENTS>and</COMMENTS>
            # <COMMENTS>avoids</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>jump</COMMENTS> <COMMENTS>larger</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>level</COMMENTS>.
            if (   $<CODE>types_to_go</CODE>[$<CODE>i_terminal</CODE>] =~ /^[\}\]\)R]$/
                && $<CODE>i_terminal</CODE> == $<CODE>ibeg</CODE> )
            {
                my $<CODE>ci</CODE>        = $<CODE>ci_levels_to_go</CODE>[$<CODE>ibeg</CODE>];
                my $<CODE>lev</CODE>       = $<CODE>levels_to_go</CODE>[$<CODE>ibeg</CODE>];
                my $<CODE>next_type</CODE> = $<CODE>types_to_go</CODE>[ $<CODE>ibeg</CODE> + 1 ];
                my $<CODE>i_next_nonblank</CODE> =
                  ( ( $<CODE>next_type</CODE> eq '<LITERALS>b</LITERALS>' ) ? $<CODE>ibeg</CODE> + 2 : $<CODE>ibeg</CODE> + 1 );
                if (   $<CODE>i_next_nonblank</CODE> <= $<CODE>max_index_to_go</CODE>
                    && $<CODE>levels_to_go</CODE>[$<CODE>i_next_nonblank</CODE>] < $<CODE>lev</CODE> )
                {
                    $<CODE>adjust_indentation</CODE> = 1;
                }

                # <COMMENTS>Patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>RT</COMMENTS> #<COMMENTS>96101</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>subs</COMMENTS>
                # <COMMENTS>was</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>outdented</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>ahead</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS>
                # <COMMENTS>a</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>decrease</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>token</COMMENTS> (<COMMENTS>i</COMMENTS>.<COMMENTS>e</COMMENTS>., <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS>),
                # <COMMENTS>but</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>information</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>now</COMMENTS>
                # <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>works</COMMENTS> <COMMENTS>well</COMMENTS>.
                # <COMMENTS>See</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>files</COMMENTS> '<COMMENTS>sub</COMMENTS>*.<COMMENTS>t</COMMENTS>' <COMMENTS>for</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>cases</COMMENTS>.
                if (   $<CODE>block_type_to_go</CODE>[$<CODE>ibeg</CODE>] =~ /^sub\s*\(?/
                    && $<CODE>container_environment_to_go</CODE>[$<CODE>i_terminal</CODE>] eq '<LITERALS>LIST</LITERALS>'
                    && !$<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>brace</LITERALS>'} )
                {
                    (
                        $<CODE>opening_indentation</CODE>, $<CODE>opening_offset</CODE>,
                        $<CODE>is_leading</CODE>,          $<CODE>opening_exists</CODE>
                      )
                      = <CODE>get_opening_indentation</CODE>( $<CODE>ibeg</CODE>, $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>,
                        $<CODE>rindentation_list</CODE> );
                    my $<CODE>indentation</CODE> = $<CODE>leading_spaces_to_go</CODE>[$<CODE>ibeg</CODE>];
                    if ( defined($<CODE>opening_indentation</CODE>)
                        && <CODE>get_SPACES</CODE>($<CODE>indentation</CODE>) >
                        <CODE>get_SPACES</CODE>($<CODE>opening_indentation</CODE>) )
                    {
                        $<CODE>adjust_indentation</CODE> = 1;
                    }
                }
            }

            # <COMMENTS>YVES</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>2</COMMENTS>:
            # <COMMENTS>Undo</COMMENTS> <COMMENTS>ci</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>eval</COMMENTS> <COMMENTS>brace</COMMENTS>,
            # <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>beyond</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indention</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS>
            # <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS>.
            if (   $<CODE>block_type_to_go</CODE>[$<CODE>ibeg</CODE>] eq '<LITERALS>eval</LITERALS>'
                && !$<CODE>rOpts</CODE>->{'<LITERALS>line</LITERALS>-<LITERALS>up</LITERALS>-<LITERALS>parentheses</LITERALS>'}
                && !$<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>brace</LITERALS>'} )
            {
                (
                    $<CODE>opening_indentation</CODE>, $<CODE>opening_offset</CODE>,
                    $<CODE>is_leading</CODE>,          $<CODE>opening_exists</CODE>
                  )
                  = <CODE>get_opening_indentation</CODE>( $<CODE>ibeg</CODE>, $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>,
                    $<CODE>rindentation_list</CODE> );
                my $<CODE>indentation</CODE> = $<CODE>leading_spaces_to_go</CODE>[$<CODE>ibeg</CODE>];
                if ( defined($<CODE>opening_indentation</CODE>)
                    && <CODE>get_SPACES</CODE>($<CODE>indentation</CODE>) >
                    <CODE>get_SPACES</CODE>($<CODE>opening_indentation</CODE>) )
                {
                    $<CODE>adjust_indentation</CODE> = 1;
                }
            }

            $<CODE>default_adjust_indentation</CODE> = $<CODE>adjust_indentation</CODE>;

            # <COMMENTS>Now</COMMENTS> <COMMENTS>modify</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>behavior</COMMENTS> <COMMENTS>according</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>request</COMMENTS>:
            # <COMMENTS>handle</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>indent</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blocks</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>form</COMMENTS> );  };  ];
            # <COMMENTS>But</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> ')-><COMMENTS>pack</COMMENTS>('
            if ( !$<CODE>block_type_to_go</CODE>[$<CODE>ibeg</CODE>] ) {
                my $<CODE>cti</CODE> = $<CODE>closing_token_indentation</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>ibeg</CODE>] };
                if ( $<CODE>cti</CODE> == 1 ) {
                    if (   $<CODE>i_terminal</CODE> <= $<CODE>ibeg</CODE> + 1
                        || $<CODE>is_semicolon_terminated</CODE> )
                    {
                        $<CODE>adjust_indentation</CODE> = 2;
                    }
                    else {
                        $<CODE>adjust_indentation</CODE> = 0;
                    }
                }
                elsif ( $<CODE>cti</CODE> == 2 ) {
                    if ($<CODE>is_semicolon_terminated</CODE>) {
                        $<CODE>adjust_indentation</CODE> = 3;
                    }
                    else {
                        $<CODE>adjust_indentation</CODE> = 0;
                    }
                }
                elsif ( $<CODE>cti</CODE> == 3 ) {
                    $<CODE>adjust_indentation</CODE> = 3;
                }
            }

            # <COMMENTS>handle</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>indent</COMMENTS> <COMMENTS>blocks</COMMENTS>
            else {
                if (
                    $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>brace</LITERALS>'}
                    && (
                        $<CODE>i_terminal</CODE> == $<CODE>ibeg</CODE>    #  <COMMENTS>isolated</COMMENTS> <COMMENTS>terminal</COMMENTS> '}'
                        || $<CODE>is_semicolon_terminated</CODE>
                    )
                  )                             #  } <COMMENTS>xxxx</COMMENTS> ;
                {
                    $<CODE>adjust_indentation</CODE> = 3;
                }
            }
        }

        # <COMMENTS>if</COMMENTS> <COMMENTS>at</COMMENTS> ');', '};', '>;', <COMMENTS>and</COMMENTS> '];' <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>quote</COMMENTS>
        elsif ($$<CODE>rpatterns</CODE>[0] =~ /^qb*;$/
            && $$<CODE>rfields</CODE>[0] =~ /^([\)\}\]\>]);$/ )
        {
            if ( $<CODE>closing_token_indentation</CODE>{$<CODE>1</CODE>} == 0 ) {
                $<CODE>adjust_indentation</CODE> = 1;
            }
            else {
                $<CODE>adjust_indentation</CODE> = 3;
            }
        }

        # <COMMENTS>if</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>begins</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> ':', <COMMENTS>align</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>any</COMMENTS>
        # <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>corresponding</COMMENTS> ?
        elsif ( $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq ':' ) {
            (
                $<CODE>opening_indentation</CODE>, $<CODE>opening_offset</CODE>,
                $<CODE>is_leading</CODE>,          $<CODE>opening_exists</CODE>
              )
              = <CODE>get_opening_indentation</CODE>( $<CODE>ibeg</CODE>, $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE>,
                $<CODE>rindentation_list</CODE> );
            if ($<CODE>is_leading</CODE>) { $<CODE>adjust_indentation</CODE> = 2; }
        }

        ##########################################################
        # <COMMENTS>Section</COMMENTS> <COMMENTS>2</COMMENTS>: <COMMENTS>set</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>according</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>above</COMMENTS>
        #
        # <COMMENTS>Select</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>define</COMMENTS> <COMMENTS>leading</COMMENTS>
        # <COMMENTS>whitespace</COMMENTS>.  <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>outdenting</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> '} } );'
        # <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS>
        # (<COMMENTS>$i_terminal</COMMENTS>) <COMMENTS>in</COMMENTS> <COMMENTS>order</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>fully</COMMENTS> <COMMENTS>outdent</COMMENTS> <COMMENTS>through</COMMENTS>
        # <COMMENTS>all</COMMENTS> <COMMENTS>levels</COMMENTS>.
        ##########################################################
        my $<CODE>indentation</CODE>;
        my $<CODE>lev</CODE>;
        my $<CODE>level_end</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>iend</CODE>];

        if ( $<CODE>adjust_indentation</CODE> == 0 ) {
            $<CODE>indentation</CODE> = $<CODE>leading_spaces_to_go</CODE>[$<CODE>ibeg</CODE>];
            $<CODE>lev</CODE>         = $<CODE>levels_to_go</CODE>[$<CODE>ibeg</CODE>];
        }
        elsif ( $<CODE>adjust_indentation</CODE> == 1 ) {
            $<CODE>indentation</CODE> = $<CODE>reduced_spaces_to_go</CODE>[$<CODE>i_terminal</CODE>];
            $<CODE>lev</CODE>         = $<CODE>levels_to_go</CODE>[$<CODE>i_terminal</CODE>];
        }

        # <COMMENTS>handle</COMMENTS> <COMMENTS>indented</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>aligns</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
        elsif ( $<CODE>adjust_indentation</CODE> == 2 ) {

            # <COMMENTS>handle</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
            $<CODE>lev</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>ibeg</CODE>];

            # <COMMENTS>calculate</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
            my $<CODE>space_count</CODE> =
              <CODE>get_SPACES</CODE>($<CODE>opening_indentation</CODE>) + $<CODE>opening_offset</CODE>;

            # <COMMENTS>Indent</COMMENTS> <COMMENTS>less</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS>.
            #
            # <COMMENTS>Problem</COMMENTS>: <COMMENTS>For</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>exactly</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS>
            # <COMMENTS>were</COMMENTS> <COMMENTS>recoverable</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>sent</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>aligner</COMMENTS>.  <COMMENTS>A</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>solution</COMMENTS>
            # <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flush</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>buffer</COMMENTS>, <COMMENTS>so</COMMENTS>
            # <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>know</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>now</COMMENTS>, <COMMENTS>this</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>for</COMMENTS> -<COMMENTS>lp</COMMENTS>:
            #
            # <COMMENTS>When</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>did</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS>
            # <COMMENTS>be</COMMENTS> <COMMENTS>optimistic</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>aligner</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>recover</COMMENTS> <COMMENTS>everything</COMMENTS> <COMMENTS>wanted</COMMENTS>.
            #
            # <COMMENTS>This</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>us</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>breaking</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hierarchy</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>closing</COMMENTS>
            # <COMMENTS>tokens</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>worst</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>leave</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>far</COMMENTS>
            # <COMMENTS>indented</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>better</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>frequently</COMMENTS> <COMMENTS>leaving</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>not</COMMENTS>
            # <COMMENTS>indented</COMMENTS> <COMMENTS>enough</COMMENTS>.
            my $<CODE>last_spaces</CODE> = <CODE>get_SPACES</CODE>($<CODE>last_indentation_written</CODE>);
            if ( $<CODE>last_leading_token</CODE> !~ /^[\}\]\)]$/ ) {
                $<CODE>last_spaces</CODE> +=
                  <CODE>get_RECOVERABLE_SPACES</CODE>($<CODE>last_indentation_written</CODE>);
            }

            # <COMMENTS>reset</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>works</COMMENTS>
            # <COMMENTS>only</COMMENTS> <COMMENTS>options</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>none</COMMENTS>: <COMMENTS>nothing</COMMENTS> <COMMENTS>in</COMMENTS>-<COMMENTS>between</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>good</COMMENTS>
            $<CODE>lev</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>ibeg</CODE>];
            if ( $<CODE>space_count</CODE> < $<CODE>last_spaces</CODE> ) {
                if ($<CODE>rOpts_line_up_parentheses</CODE>) {
                    my $<CODE>lev</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>ibeg</CODE>];
                    $<CODE>indentation</CODE> =
                      <CODE>new_lp_indentation_item</CODE>( $<CODE>space_count</CODE>, $<CODE>lev</CODE>, 0, 0, 0 );
                }
                else {
                    $<CODE>indentation</CODE> = $<CODE>space_count</CODE>;
                }
            }

            # <COMMENTS>revert</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS>
            else {
                $<CODE>space_count</CODE> = <CODE>leading_spaces_to_go</CODE>($<CODE>ibeg</CODE>);
                if ( $<CODE>default_adjust_indentation</CODE> == 0 ) {
                    $<CODE>indentation</CODE> = $<CODE>leading_spaces_to_go</CODE>[$<CODE>ibeg</CODE>];
                }
                elsif ( $<CODE>default_adjust_indentation</CODE> == 1 ) {
                    $<CODE>indentation</CODE> = $<CODE>reduced_spaces_to_go</CODE>[$<CODE>i_terminal</CODE>];
                    $<CODE>lev</CODE>         = $<CODE>levels_to_go</CODE>[$<CODE>i_terminal</CODE>];
                }
            }
        }

        # <COMMENTS>Full</COMMENTS> <COMMENTS>indentaion</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS> (-<COMMENTS>icb</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>icp</COMMENTS> <COMMENTS>or</COMMENTS> -<COMMENTS>cti</COMMENTS>=<COMMENTS>2</COMMENTS>)
        else {

            # <COMMENTS>handle</COMMENTS> -<COMMENTS>icb</COMMENTS> (<COMMENTS>indented</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>braces</COMMENTS>)
            # <COMMENTS>Updated</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>indented</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>braces</COMMENTS>: <COMMENTS>indent</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>full</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>if</COMMENTS>
            # <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>occur</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>major</COMMENTS>
            # <COMMENTS>structures</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>sub</COMMENTS>, <COMMENTS>if</COMMENTS>, <COMMENTS>else</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>map</COMMENTS>
            # <COMMENTS>blocks</COMMENTS>.
            #
            # <COMMENTS>Note</COMMENTS>: <COMMENTS>only</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>are</COMMENTS>
            # <COMMENTS>handled</COMMENTS> <COMMENTS>here</COMMENTS> (<COMMENTS>if</COMMENTS>, <COMMENTS>else</COMMENTS>, <COMMENTS>unless</COMMENTS>, ..). <COMMENTS>In</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>snippet</COMMENTS>,
            # <COMMENTS>the</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>sort</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>continuation</COMMENTS>
            # <COMMENTS>indentation</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>shown</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>coding</COMMENTS>
            # <COMMENTS>here</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>undo</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS>
            # <COMMENTS>this</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>is</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>future</COMMENTS>
            # <COMMENTS>update</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>semicolon</COMMENTS> <COMMENTS>terminated</COMMENTS> <COMMENTS>lines</COMMENTS>.
            #
            #     <COMMENTS>if</COMMENTS> (<COMMENTS>$sortby</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>date</COMMENTS>' <COMMENTS>or</COMMENTS> <COMMENTS>$sortby</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>size</COMMENTS>') {
            #         @<COMMENTS>files</COMMENTS> = <COMMENTS>sort</COMMENTS> {
            #             <COMMENTS>$file_data</COMMENTS>{<COMMENTS>$a</COMMENTS>}{<COMMENTS>$sortby</COMMENTS>} <=> <COMMENTS>$file_data</COMMENTS>{<COMMENTS>$b</COMMENTS>}{<COMMENTS>$sortby</COMMENTS>}
            #                 <COMMENTS>or</COMMENTS> <COMMENTS>$a</COMMENTS> <COMMENTS>cmp</COMMENTS> <COMMENTS>$b</COMMENTS>
            #                 } @<COMMENTS>files</COMMENTS>;
            #         }
            #
            if (   $<CODE>block_type_to_go</CODE>[$<CODE>ibeg</CODE>]
                && $<CODE>ci_levels_to_go</CODE>[$<CODE>i_terminal</CODE>] == 0 )
            {
                my $<CODE>spaces</CODE> = <CODE>get_SPACES</CODE>( $<CODE>leading_spaces_to_go</CODE>[$<CODE>i_terminal</CODE>] );
                $<CODE>indentation</CODE> = $<CODE>spaces</CODE> + $<CODE>rOpts_indent_columns</CODE>;

                # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>for</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>object</COMMENTS>, <COMMENTS>but</COMMENTS>
                # <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>it</COMMENTS>
            }

            # <COMMENTS>handle</COMMENTS> -<COMMENTS>icp</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>any</COMMENTS> -<COMMENTS>icb</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>fall</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>above</COMMENTS>
            # <COMMENTS>test</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>sort</COMMENTS>' <COMMENTS>block</COMMENTS> <COMMENTS>mentioned</COMMENTS> <COMMENTS>above</COMMENTS>.
            else {

                # <COMMENTS>There</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>currently</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>ways</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>handle</COMMENTS> -<COMMENTS>icp</COMMENTS>...
                # <COMMENTS>One</COMMENTS> <COMMENTS>way</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS>:
                # <COMMENTS>$indentation</COMMENTS> = <COMMENTS>$last_indentation_written</COMMENTS>;

                # <COMMENTS>The</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>way</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS>
                # <COMMENTS>would</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>had</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>hadn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>adjusted</COMMENTS>:
                $<CODE>indentation</CODE> = $<CODE>last_unadjusted_indentation</CODE>;

                # <COMMENTS>Current</COMMENTS> <COMMENTS>method</COMMENTS>: <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>minimum</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>two</COMMENTS>. <COMMENTS>This</COMMENTS> <COMMENTS>avoids</COMMENTS>
                # <COMMENTS>inconsistent</COMMENTS> <COMMENTS>indentation</COMMENTS>.
                if ( <CODE>get_SPACES</CODE>($<CODE>last_indentation_written</CODE>) <
                    <CODE>get_SPACES</CODE>($<CODE>indentation</CODE>) )
                {
                    $<CODE>indentation</CODE> = $<CODE>last_indentation_written</CODE>;
                }
            }

            # <COMMENTS>use</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>own</COMMENTS> <COMMENTS>level</COMMENTS>
            # <COMMENTS>to</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>flushed</COMMENTS> <COMMENTS>properly</COMMENTS>
            $<CODE>lev</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>ibeg</CODE>];
        }

        # <COMMENTS>remember</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>multi</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>quotes</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>get</COMMENTS>
        # <COMMENTS>no</COMMENTS> <COMMENTS>indentation</COMMENTS>
        unless ( $<CODE>ibeg</CODE> == 0 && $<CODE>starting_in_quote</CODE> ) {
            $<CODE>last_indentation_written</CODE>    = $<CODE>indentation</CODE>;
            $<CODE>last_unadjusted_indentation</CODE> = $<CODE>leading_spaces_to_go</CODE>[$<CODE>ibeg</CODE>];
            $<CODE>last_leading_token</CODE>          = $<CODE>tokens_to_go</CODE>[$<CODE>ibeg</CODE>];
        }

        # <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>outdented</COMMENTS> <COMMENTS>more</COMMENTS>
        # <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>contained</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>corresponding</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>.

        #############################################################
        # <COMMENTS>updated</COMMENTS> <COMMENTS>per</COMMENTS> <COMMENTS>bug</COMMENTS> <COMMENTS>report</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>alex_bug</COMMENTS>.<COMMENTS>pl</COMMENTS>: <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>not</COMMENTS>
        # <COMMENTS>mess</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>so</COMMENTS>
        # <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>treat</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> '} <COMMENTS>else</COMMENTS> {' <COMMENTS>as</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>were</COMMENTS>
        # <COMMENTS>an</COMMENTS> <COMMENTS>isolated</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>$is_isolated_block_brace</COMMENTS> = (
        # <COMMENTS>$iend</COMMENTS> == <COMMENTS>$ibeg</COMMENTS> ) && <COMMENTS>$block_type_to_go</COMMENTS>[<COMMENTS>$ibeg</COMMENTS>];
        #############################################################
        my $<CODE>is_isolated_block_brace</CODE> = $<CODE>block_type_to_go</CODE>[$<CODE>ibeg</CODE>]
          && ( $<CODE>iend</CODE> == $<CODE>ibeg</CODE>
            || $<CODE>is_if_elsif_else_unless_while_until_for_foreach</CODE>{
                $<CODE>block_type_to_go</CODE>[$<CODE>ibeg</CODE>]
            } );

        # <COMMENTS>only</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> ':; <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>aligned</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>leading</COMMENTS> '?'
        my $<CODE>is_unaligned_colon</CODE> = $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq ':' && !$<CODE>is_leading</CODE>;
        if (   defined($<CODE>opening_indentation</CODE>)
            && !$<CODE>is_isolated_block_brace</CODE>
            && !$<CODE>is_unaligned_colon</CODE> )
        {
            if ( <CODE>get_SPACES</CODE>($<CODE>opening_indentation</CODE>) > <CODE>get_SPACES</CODE>($<CODE>indentation</CODE>) ) {
                $<CODE>indentation</CODE> = $<CODE>opening_indentation</CODE>;
            }
        }

        # <COMMENTS>remember</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
        push @{$<CODE>rindentation_list</CODE>}, $<CODE>indentation</CODE>;

        # <COMMENTS>outdent</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>tokens</COMMENTS>...
        if (

            # <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
            $<CODE>ibeg</CODE> == 0

            # <COMMENTS>and</COMMENTS> ...
            && (

                # <COMMENTS>certain</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS>
                (
                       $<CODE>rOpts</CODE>->{'<LITERALS>outdent</LITERALS>-<LITERALS>keywords</LITERALS>'}
                    && $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq '<LITERALS>k</LITERALS>'
                    && $<CODE>outdent_keyword</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>ibeg</CODE>] }
                )

                # <COMMENTS>or</COMMENTS> <COMMENTS>labels</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS>
                || ( $<CODE>rOpts</CODE>->{'<LITERALS>outdent</LITERALS>-<LITERALS>labels</LITERALS>'} && $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq '<LITERALS>J</LITERALS>' )

                # <COMMENTS>or</COMMENTS> <COMMENTS>static</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS>
                || (   $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq '#'
                    && $<CODE>rOpts</CODE>->{'<LITERALS>outdent</LITERALS>-<LITERALS>static</LITERALS>-<LITERALS>block</LITERALS>-<LITERALS>comments</LITERALS>'}
                    && $<CODE>is_static_block_comment</CODE> )
            )
          )

        {
            my $<CODE>space_count</CODE> = <CODE>leading_spaces_to_go</CODE>($<CODE>ibeg</CODE>);
            if ( $<CODE>space_count</CODE> > 0 ) {
                $<CODE>space_count</CODE> -= $<CODE>rOpts_continuation_indentation</CODE>;
                $<CODE>is_outdented_line</CODE> = 1;
                if ( $<CODE>space_count</CODE> < 0 ) { $<CODE>space_count</CODE> = 0 }

                # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>promote</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>spaced</COMMENTS> <COMMENTS>static</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>spaced</COMMENTS>;
                # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>normally</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>some</COMMENTS>
                # <COMMENTS>unusual</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>inputs</COMMENTS> (<COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> -<COMMENTS>ci</COMMENTS> = -<COMMENTS>i</COMMENTS>)
                if ( $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] eq '#' && $<CODE>space_count</CODE> == 0 ) {
                    $<CODE>space_count</CODE> = 1;
                }

                if ($<CODE>rOpts_line_up_parentheses</CODE>) {
                    $<CODE>indentation</CODE> =
                      <CODE>new_lp_indentation_item</CODE>( $<CODE>space_count</CODE>, $<CODE>lev</CODE>, 0, 0, 0 );
                }
                else {
                    $<CODE>indentation</CODE> = $<CODE>space_count</CODE>;
                }
            }
        }

        return ( $<CODE>indentation</CODE>, $<CODE>lev</CODE>, $<CODE>level_end</CODE>, $<CODE>terminal_type</CODE>,
            $<CODE>is_semicolon_terminated</CODE>, $<CODE>is_outdented_line</CODE> );
    }
}

sub <CODE>set_vertical_tightness_flags</CODE> {

    my ( $<CODE>n</CODE>, $<CODE>n_last_line</CODE>, $<CODE>ibeg</CODE>, $<CODE>iend</CODE>, $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>Define</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>tightness</COMMENTS> <COMMENTS>controls</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>nth</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>batch</COMMENTS>.
    # <COMMENTS>We</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>parameters</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>tell</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS>
    # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>achieve</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>desired</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>tightness</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>parameters</COMMENTS> <COMMENTS>contains</COMMENTS>:
    #
    #   [<COMMENTS>0</COMMENTS>] <COMMENTS>type</COMMENTS>: <COMMENTS>1</COMMENTS>=<COMMENTS>opening</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>block</COMMENTS>    <COMMENTS>2</COMMENTS>=<COMMENTS>closing</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>block</COMMENTS>
    #             <COMMENTS>3</COMMENTS>=<COMMENTS>opening</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>brace</COMMENTS>  <COMMENTS>4</COMMENTS>=<COMMENTS>closing</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>brace</COMMENTS>
    #
    #   [<COMMENTS>1</COMMENTS>] <COMMENTS>flag</COMMENTS>: <COMMENTS>if</COMMENTS> <COMMENTS>opening</COMMENTS>: <COMMENTS>1</COMMENTS>=<COMMENTS>no</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>steps</COMMENTS>, <COMMENTS>2</COMMENTS>=<COMMENTS>multiple</COMMENTS> <COMMENTS>steps</COMMENTS> <COMMENTS>ok</COMMENTS>
    #             <COMMENTS>if</COMMENTS> <COMMENTS>closing</COMMENTS>: <COMMENTS>spaces</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS>
    #   [<COMMENTS>2</COMMENTS>] <COMMENTS>sequence</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>container</COMMENTS>
    #   [<COMMENTS>3</COMMENTS>] <COMMENTS>valid</COMMENTS> <COMMENTS>flag</COMMENTS>: <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>false</COMMENTS>. <COMMENTS>Will</COMMENTS> <COMMENTS>be</COMMENTS>
    #       <COMMENTS>true</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>appropriate</COMMENTS> -<COMMENTS>vt</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>set</COMMENTS>.  <COMMENTS>Otherwise</COMMENTS>, <COMMENTS>Will</COMMENTS> <COMMENTS>be</COMMENTS>
    #       <COMMENTS>made</COMMENTS> <COMMENTS>true</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>lp</COMMENTS>
    #
    # <COMMENTS>These</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>set_leading_whitespace</COMMENTS> <COMMENTS>in</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS>

    my $<CODE>rvertical_tightness_flags</CODE> = [ 0, 0, 0, 0, 0, 0 ];

    #--------------------------------------------------------------
    # <COMMENTS>Vertical</COMMENTS> <COMMENTS>Tightness</COMMENTS> <COMMENTS>Flags</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>1</COMMENTS>:
    # <COMMENTS>Handle</COMMENTS> <COMMENTS>Lines</COMMENTS> <COMMENTS>1</COMMENTS> .. <COMMENTS>n</COMMENTS>-<COMMENTS>1</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS>
    # <COMMENTS>For</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>BLOCK</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>examine</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS>
    # <COMMENTS>too</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>won</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>consider</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS>.
    #--------------------------------------------------------------
    if ( $<CODE>n</CODE> < $<CODE>n_last_line</CODE> ) {

        #--------------------------------------------------------------
        # <COMMENTS>Vertical</COMMENTS> <COMMENTS>Tightness</COMMENTS> <COMMENTS>Flags</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>1a</COMMENTS>:
        # <COMMENTS>Look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>Type</COMMENTS> <COMMENTS>1</COMMENTS>, <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>block</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
        #--------------------------------------------------------------
        my $<CODE>ibeg_next</CODE> = $$<CODE>ri_first</CODE>[ $<CODE>n</CODE> + 1 ];
        my $<CODE>token_end</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>iend</CODE>];
        my $<CODE>iend_next</CODE> = $$<CODE>ri_last</CODE>[ $<CODE>n</CODE> + 1 ];
        if (
               $<CODE>type_sequence_to_go</CODE>[$<CODE>iend</CODE>]
            && !$<CODE>block_type_to_go</CODE>[$<CODE>iend</CODE>]
            && $<CODE>is_opening_token</CODE>{$<CODE>token_end</CODE>}
            && (
                $<CODE>opening_vertical_tightness</CODE>{$<CODE>token_end</CODE>} > 0

                # <COMMENTS>allow</COMMENTS> <COMMENTS>2</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>closed</COMMENTS> <COMMENTS>up</COMMENTS>
                || (   $<CODE>rOpts_line_up_parentheses</CODE>
                    && $<CODE>token_end</CODE> eq '('
                    && $<CODE>iend</CODE> > $<CODE>ibeg</CODE>
                    && $<CODE>types_to_go</CODE>[ $<CODE>iend</CODE> - 1 ] ne '<LITERALS>b</LITERALS>' )
            )
          )
        {

            # <COMMENTS>avoid</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>jumps</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>if</COMMENTS>
            # <COMMENTS>requested</COMMENTS>
            my $<CODE>ovt</CODE>       = $<CODE>opening_vertical_tightness</CODE>{$<CODE>token_end</CODE>};
            my $<CODE>iend_next</CODE> = $$<CODE>ri_last</CODE>[ $<CODE>n</CODE> + 1 ];
            unless (
                $<CODE>ovt</CODE> < 2
                && ( $<CODE>nesting_depth_to_go</CODE>[ $<CODE>iend_next</CODE> + 1 ] !=
                    $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg_next</CODE>] )
              )
            {

                # <COMMENTS>If</COMMENTS> -<COMMENTS>vt</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>set</COMMENTS>, <COMMENTS>mark</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>invalid</COMMENTS>
                # <COMMENTS>and</COMMENTS> <COMMENTS>aligner</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>validate</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>sees</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>paren</COMMENTS>
                # <COMMENTS>within</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>lines</COMMENTS>.
                my $<CODE>valid_flag</CODE> = $<CODE>ovt</CODE>;
                @{$<CODE>rvertical_tightness_flags</CODE>} =
                  ( 1, $<CODE>ovt</CODE>, $<CODE>type_sequence_to_go</CODE>[$<CODE>iend</CODE>], $<CODE>valid_flag</CODE> );
            }
        }

        #--------------------------------------------------------------
        # <COMMENTS>Vertical</COMMENTS> <COMMENTS>Tightness</COMMENTS> <COMMENTS>Flags</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>1b</COMMENTS>:
        # <COMMENTS>Look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>Type</COMMENTS> <COMMENTS>2</COMMENTS>, <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>block</COMMENTS> <COMMENTS>closing</COMMENTS>
        # <COMMENTS>token</COMMENTS> .. <COMMENTS>and</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
        #--------------------------------------------------------------
        my $<CODE>token_next</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_next</CODE>];
        if (   $<CODE>type_sequence_to_go</CODE>[$<CODE>ibeg_next</CODE>]
            && !$<CODE>block_type_to_go</CODE>[$<CODE>ibeg_next</CODE>]
            && $<CODE>is_closing_token</CODE>{$<CODE>token_next</CODE>}
            && $<CODE>types_to_go</CODE>[$<CODE>iend</CODE>] !~ '#' )    # <COMMENTS>for</COMMENTS> <COMMENTS>safety</COMMENTS>, <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>!
        {
            my $<CODE>ovt</CODE> = $<CODE>opening_vertical_tightness</CODE>{$<CODE>token_next</CODE>};
            my $<CODE>cvt</CODE> = $<CODE>closing_vertical_tightness</CODE>{$<CODE>token_next</CODE>};
            if (

                # <COMMENTS>never</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>like</COMMENTS>   )-><COMMENTS>pack</COMMENTS>(
                # <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>throw</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>alignment</COMMENTS>
                (
                    $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg_next</CODE>] ==
                    $<CODE>nesting_depth_to_go</CODE>[ $<CODE>iend_next</CODE> + 1 ] + 1
                )
                && (
                    $<CODE>cvt</CODE> == 2
                    || (
                        $<CODE>container_environment_to_go</CODE>[$<CODE>ibeg_next</CODE>] ne '<LITERALS>LIST</LITERALS>'
                        && (
                            $<CODE>cvt</CODE> == 1

                            # <COMMENTS>allow</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>2</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>calls</COMMENTS>
                            || (   $<CODE>rOpts_line_up_parentheses</CODE>
                                && $<CODE>token_next</CODE> eq ')' )
                        )
                    )
                )
              )
            {

                # <COMMENTS>decide</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>append</COMMENTS>..
                my $<CODE>ok</CODE> = 0;
                if ( $<CODE>cvt</CODE> == 2 || $<CODE>iend_next</CODE> == $<CODE>ibeg_next</CODE> ) { $<CODE>ok</CODE> = 1 }
                else {
                    my $<CODE>str</CODE> = join( '',
                        @<CODE>types_to_go</CODE>[ $<CODE>ibeg_next</CODE> + 1 .. $<CODE>ibeg_next</CODE> + 2 ] );

                    # <COMMENTS>append</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>or</COMMENTS> ';'
                    if ( $<CODE>str</CODE> =~ /^b?[#;]/ ) { $<CODE>ok</CODE> = 1 }
                }

                if ($<CODE>ok</CODE>) {
                    my $<CODE>valid_flag</CODE> = $<CODE>cvt</CODE>;
                    @{$<CODE>rvertical_tightness_flags</CODE>} = (
                        2,
                        $<CODE>tightness</CODE>{$<CODE>token_next</CODE>} == 2 ? 0 : 1,
                        $<CODE>type_sequence_to_go</CODE>[$<CODE>ibeg_next</CODE>], $<CODE>valid_flag</CODE>,
                    );
                }
            }
        }

        #--------------------------------------------------------------
        # <COMMENTS>Vertical</COMMENTS> <COMMENTS>Tightness</COMMENTS> <COMMENTS>Flags</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>1c</COMMENTS>:
        # <COMMENTS>Implement</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>Opening</COMMENTS> <COMMENTS>Token</COMMENTS> <COMMENTS>Right</COMMENTS> <COMMENTS>flag</COMMENTS> (<COMMENTS>Type</COMMENTS> <COMMENTS>2</COMMENTS>)..
        # <COMMENTS>If</COMMENTS> <COMMENTS>requested</COMMENTS>, <COMMENTS>move</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>isolated</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>ended</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS>
        # <COMMENTS>in</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>recombine_breakpoints</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>problems</COMMENTS>
        # <COMMENTS>with</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>formatting</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>will</COMMENTS>
        # <COMMENTS>quickly</COMMENTS> <COMMENTS>move</COMMENTS> <COMMENTS>far</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>nested</COMMENTS> <COMMENTS>expressions</COMMENTS>.  <COMMENTS>By</COMMENTS>
        # <COMMENTS>doing</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>set</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>changes</COMMENTS>
        # <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS>.  <COMMENTS>Actual</COMMENTS> <COMMENTS>movement</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>takes</COMMENTS> <COMMENTS>place</COMMENTS>
        # <COMMENTS>in</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>valign_output_step_B</COMMENTS>.
        #--------------------------------------------------------------
        if (
            $<CODE>opening_token_right</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_next</CODE>] }

            # <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>opening</COMMENTS>
            # (<COMMENTS>use</COMMENTS> -<COMMENTS>sot</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>it</COMMENTS>)
            && !$<CODE>is_opening_token</CODE>{$<CODE>token_end</CODE>}

            # <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ended</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS>
            # (<COMMENTS>add</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>cases</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>; '=>' <COMMENTS>and</COMMENTS> '.' <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>necessary</COMMENTS>
            && !$<CODE>block_type_to_go</CODE>[$<CODE>ibeg_next</CODE>]

            # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
            && (   $<CODE>iend_next</CODE> == $<CODE>ibeg_next</CODE>
                || $<CODE>iend_next</CODE> == $<CODE>ibeg_next</CODE> + 2
                && $<CODE>types_to_go</CODE>[$<CODE>iend_next</CODE>] eq '#' )

            # <COMMENTS>looks</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>vertically</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>wrong</COMMENTS> <COMMENTS>container</COMMENTS>
            && $<CODE>tokens_to_go</CODE>[$<CODE>ibeg</CODE>] ne $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_next</CODE>]
          )
        {
            my $<CODE>valid_flag</CODE> = 1;
            my $<CODE>spaces</CODE> = ( $<CODE>types_to_go</CODE>[ $<CODE>ibeg_next</CODE> - 1 ] eq '<LITERALS>b</LITERALS>' ) ? 1 : 0;
            @{$<CODE>rvertical_tightness_flags</CODE>} =
              ( 2, $<CODE>spaces</CODE>, $<CODE>type_sequence_to_go</CODE>[$<CODE>ibeg_next</CODE>], $<CODE>valid_flag</CODE>, );
        }

        #--------------------------------------------------------------
        # <COMMENTS>Vertical</COMMENTS> <COMMENTS>Tightness</COMMENTS> <COMMENTS>Flags</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>1d</COMMENTS>:
        # <COMMENTS>Stacking</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS> (<COMMENTS>Type</COMMENTS> <COMMENTS>2</COMMENTS>)
        #--------------------------------------------------------------
        my $<CODE>stackable</CODE>;
        my $<CODE>token_beg_next</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_next</CODE>];

        # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> '<COMMENTS>qw</COMMENTS>(' <COMMENTS>behave</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS>
        # (<COMMENTS>aran</COMMENTS>.<COMMENTS>t</COMMENTS>)
        if ( $<CODE>types_to_go</CODE>[$<CODE>ibeg_next</CODE>] eq '<LITERALS>q</LITERALS>' ) {
            if ( $<CODE>token_beg_next</CODE> =~ /^qw\s*([\[\(\{])$/ ) {
                $<CODE>token_beg_next</CODE> = $<CODE>1</CODE>;
            }
        }

        if (   $<CODE>is_closing_token</CODE>{$<CODE>token_end</CODE>}
            && $<CODE>is_closing_token</CODE>{$<CODE>token_beg_next</CODE>} )
        {
            $<CODE>stackable</CODE> = $<CODE>stack_closing_token</CODE>{$<CODE>token_beg_next</CODE>}
              unless ( $<CODE>block_type_to_go</CODE>[$<CODE>ibeg_next</CODE>] )
              ;    # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>; <COMMENTS>just</COMMENTS> <COMMENTS>checking</COMMENTS>
        }
        elsif ($<CODE>is_opening_token</CODE>{$<CODE>token_end</CODE>}
            && $<CODE>is_opening_token</CODE>{$<CODE>token_beg_next</CODE>} )
        {
            $<CODE>stackable</CODE> = $<CODE>stack_opening_token</CODE>{$<CODE>token_beg_next</CODE>}
              unless ( $<CODE>block_type_to_go</CODE>[$<CODE>ibeg_next</CODE>] )
              ;    # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>; <COMMENTS>just</COMMENTS> <COMMENTS>checking</COMMENTS>
        }

        if ($<CODE>stackable</CODE>) {

            my $<CODE>is_semicolon_terminated</CODE>;
            if ( $<CODE>n</CODE> + 1 == $<CODE>n_last_line</CODE> ) {
                my ( $<CODE>terminal_type</CODE>, $<CODE>i_terminal</CODE> ) = <CODE>terminal_type</CODE>(
                    \@<CODE>types_to_go</CODE>, \@<CODE>block_type_to_go</CODE>,
                    $<CODE>ibeg_next</CODE>,    $<CODE>iend_next</CODE>
                );
                $<CODE>is_semicolon_terminated</CODE> = $<CODE>terminal_type</CODE> eq ';'
                  && $<CODE>nesting_depth_to_go</CODE>[$<CODE>iend_next</CODE>] <
                  $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg_next</CODE>];
            }

            # <COMMENTS>this</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
            # <COMMENTS>or</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>semicolon</COMMENTS>
            if (
                $<CODE>is_semicolon_terminated</CODE>
                || (   $<CODE>iend_next</CODE> == $<CODE>ibeg_next</CODE>
                    || $<CODE>iend_next</CODE> == $<CODE>ibeg_next</CODE> + 2
                    && $<CODE>types_to_go</CODE>[$<CODE>iend_next</CODE>] eq '#' )
              )
            {
                my $<CODE>valid_flag</CODE> = 1;
                my $<CODE>spaces</CODE> = ( $<CODE>types_to_go</CODE>[ $<CODE>ibeg_next</CODE> - 1 ] eq '<LITERALS>b</LITERALS>' ) ? 1 : 0;
                @{$<CODE>rvertical_tightness_flags</CODE>} =
                  ( 2, $<CODE>spaces</CODE>, $<CODE>type_sequence_to_go</CODE>[$<CODE>ibeg_next</CODE>], $<CODE>valid_flag</CODE>,
                  );
            }
        }
    }

    #--------------------------------------------------------------
    # <COMMENTS>Vertical</COMMENTS> <COMMENTS>Tightness</COMMENTS> <COMMENTS>Flags</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>2</COMMENTS>:
    # <COMMENTS>Handle</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>3</COMMENTS>, <COMMENTS>opening</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>batch</COMMENTS>
    # <COMMENTS>Check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>isolated</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>BLOCK</COMMENTS> <COMMENTS>curly</COMMENTS>
    #--------------------------------------------------------------
    elsif ($<CODE>rOpts_block_brace_vertical_tightness</CODE>
        && $<CODE>ibeg</CODE> eq $<CODE>iend</CODE>
        && $<CODE>types_to_go</CODE>[$<CODE>iend</CODE>] eq '{'
        && $<CODE>block_type_to_go</CODE>[$<CODE>iend</CODE>] =~
        /$<CODE>block_brace_vertical_tightness_pattern</CODE>/o )
    {
        @{$<CODE>rvertical_tightness_flags</CODE>} =
          ( 3, $<CODE>rOpts_block_brace_vertical_tightness</CODE>, 0, 1 );
    }

    #--------------------------------------------------------------
    # <COMMENTS>Vertical</COMMENTS> <COMMENTS>Tightness</COMMENTS> <COMMENTS>Flags</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>3</COMMENTS>:
    # <COMMENTS>Handle</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>4</COMMENTS>, <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>batch</COMMENTS> <COMMENTS>Check</COMMENTS>
    # <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>isolated</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>BLOCK</COMMENTS> <COMMENTS>curly</COMMENTS>
    #--------------------------------------------------------------
    elsif ($<CODE>rOpts_stack_closing_block_brace</CODE>
        && $<CODE>ibeg</CODE> eq $<CODE>iend</CODE>
        && $<CODE>block_type_to_go</CODE>[$<CODE>iend</CODE>]
        && $<CODE>types_to_go</CODE>[$<CODE>iend</CODE>] eq '}' )
    {
        my $<CODE>spaces</CODE> = $<CODE>rOpts_block_brace_tightness</CODE> == 2 ? 0 : 1;
        @{$<CODE>rvertical_tightness_flags</CODE>} =
          ( 4, $<CODE>spaces</CODE>, $<CODE>type_sequence_to_go</CODE>[$<CODE>iend</CODE>], 1 );
    }

    # <COMMENTS>pack</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
    $<CODE>rvertical_tightness_flags</CODE>->[4] = <CODE>get_seqno</CODE>($<CODE>ibeg</CODE>);
    $<CODE>rvertical_tightness_flags</CODE>->[5] = <CODE>get_seqno</CODE>($<CODE>iend</CODE>);
    return $<CODE>rvertical_tightness_flags</CODE>;
}

sub <CODE>get_seqno</CODE> {

    # <COMMENTS>get</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS>
    # <COMMENTS>aligner</COMMENTS>.  <COMMENTS>Assign</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>quotes</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>treated</COMMENTS> <COMMENTS>somewhat</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>stacking</COMMENTS>
    # <COMMENTS>tokens</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS>.
    my ($<CODE>ii</CODE>) = @<CODE>_</CODE>;
    my $<CODE>seqno</CODE> = $<CODE>type_sequence_to_go</CODE>[$<CODE>ii</CODE>];
    if ( $<CODE>types_to_go</CODE>[$<CODE>ii</CODE>] eq '<LITERALS>q</LITERALS>' ) {
        my $<CODE>SEQ_QW</CODE> = -1;
        if ( $<CODE>ii</CODE> > 0 ) {
            $<CODE>seqno</CODE> = $<CODE>SEQ_QW</CODE> if ( $<CODE>tokens_to_go</CODE>[$<CODE>ii</CODE>] =~ /^qw\s*[\(\{\[]/ );
        }
        else {
            if ( !$<CODE>ending_in_quote</CODE> ) {
                $<CODE>seqno</CODE> = $<CODE>SEQ_QW</CODE> if ( $<CODE>tokens_to_go</CODE>[$<CODE>ii</CODE>] =~ /[\)\}\]]$/ );
            }
        }
    }
    return ($<CODE>seqno</CODE>);
}

{
    my %<CODE>is_vertical_alignment_type</CODE>;
    my %<CODE>is_vertical_alignment_keyword</CODE>;
    my %<CODE>is_terminal_alignment_type</CODE>;

    <CODE>BEGIN</CODE> {

        # <COMMENTS>Removed</COMMENTS> =~ <COMMENTS>from</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>improve</COMMENTS> <COMMENTS>chances</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>alignment</COMMENTS>
        @<CODE>_</CODE> = qw#
          = **= += *= &= <<= &&= -= /= |= >>= ||= //= .= %= ^= <LITERALS>x</LITERALS>=
          { ? : => && || // ~~ !~~
          #;
        @<CODE>is_vertical_alignment_type</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

        # <COMMENTS>only</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS>
        @<CODE>_</CODE> = qw(&& ||);
        @<CODE>is_terminal_alignment_type</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

        # <COMMENTS>eq</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>ne</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>removed</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>improve</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>chances</COMMENTS>
        @<CODE>_</CODE> = qw(<LITERALS>if</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>and</LITERALS> <LITERALS>or</LITERALS> <LITERALS>err</LITERALS> <LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS> <LITERALS>while</LITERALS> <LITERALS>until</LITERALS>);
        @<CODE>is_vertical_alignment_keyword</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);
    }

    sub <CODE>set_vertical_alignment_markers</CODE> {

        # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>takes</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>step</COMMENTS> <COMMENTS>toward</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>lines</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>text</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>serve</COMMENTS> <COMMENTS>as</COMMENTS>
        # <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>markers</COMMENTS> (<COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>an</COMMENTS> '=').
        #
        # <COMMENTS>Method</COMMENTS>: <COMMENTS>We</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>batch</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>set</COMMENTS>
        # <COMMENTS>$matching_token_to_go</COMMENTS>[<COMMENTS>$i</COMMENTS>] <COMMENTS>equal</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>those</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS>
        # <COMMENTS>accept</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS>.

        # <COMMENTS>nothing</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>aren</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>allowed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>whitespace</COMMENTS>
        if ( !$<CODE>rOpts_add_whitespace</CODE> ) {
            for my $<CODE>i</CODE> ( 0 .. $<CODE>max_index_to_go</CODE> ) {
                $<CODE>matching_token_to_go</CODE>[$<CODE>i</CODE>] = '';
            }
            return;
        }

        my ( $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> ) = @<CODE>_</CODE>;

        # <COMMENTS>remember</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>sidecomment</COMMENTS>
        my $<CODE>i_terminal</CODE> = $<CODE>max_index_to_go</CODE>;
        if ( $<CODE>types_to_go</CODE>[$<CODE>i_terminal</CODE>] eq '#' ) {
            if ( $<CODE>i_terminal</CODE> > 0 && $<CODE>types_to_go</CODE>[ --$<CODE>i_terminal</CODE> ] eq '<LITERALS>b</LITERALS>' ) {
                if ( $<CODE>i_terminal</CODE> > 0 ) { --$<CODE>i_terminal</CODE> }
            }
        }

        # <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>..
        my $<CODE>last_vertical_alignment_before_index</CODE>;
        my $<CODE>vert_last_nonblank_type</CODE>;
        my $<CODE>vert_last_nonblank_token</CODE>;
        my $<CODE>vert_last_nonblank_block_type</CODE>;
        my $<CODE>max_line</CODE> = @$<CODE>ri_first</CODE> - 1;
        my ( $<CODE>i</CODE>, $<CODE>type</CODE>, $<CODE>token</CODE>, $<CODE>block_type</CODE>, $<CODE>alignment_type</CODE> );
        my ( $<CODE>ibeg</CODE>, $<CODE>iend</CODE>, $<CODE>line</CODE> );

        foreach $<CODE>line</CODE> ( 0 .. $<CODE>max_line</CODE> ) {
            $<CODE>ibeg</CODE>                                 = $$<CODE>ri_first</CODE>[$<CODE>line</CODE>];
            $<CODE>iend</CODE>                                 = $$<CODE>ri_last</CODE>[$<CODE>line</CODE>];
            $<CODE>last_vertical_alignment_before_index</CODE> = -1;
            $<CODE>vert_last_nonblank_type</CODE>              = '';
            $<CODE>vert_last_nonblank_token</CODE>             = '';
            $<CODE>vert_last_nonblank_block_type</CODE>        = '';

            # <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>line</COMMENTS>..
            foreach $<CODE>i</CODE> ( $<CODE>ibeg</CODE> .. $<CODE>iend</CODE> ) {
                $<CODE>alignment_type</CODE> = '';
                $<CODE>type</CODE>           = $<CODE>types_to_go</CODE>[$<CODE>i</CODE>];
                $<CODE>block_type</CODE>     = $<CODE>block_type_to_go</CODE>[$<CODE>i</CODE>];
                $<CODE>token</CODE>          = $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>];

                # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>indicating</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>align</COMMENTS>
                # <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS>
                if ( $<CODE>matching_token_to_go</CODE>[$<CODE>i</CODE>] ) {
                    $<CODE>matching_token_to_go</CODE>[$<CODE>i</CODE>] = '';
                    next;
                }

                #--------------------------------------------------------
                # <COMMENTS>First</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>BEFORE</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS>
                #--------------------------------------------------------

                # <COMMENTS>The</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>before</COMMENTS>
                # <COMMENTS>is</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>because</COMMENTS>: <COMMENTS>1</COMMENTS>) <COMMENTS>it</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>normally</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>sense</COMMENTS> <COMMENTS>to</COMMENTS>
                # <COMMENTS>align</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>2</COMMENTS>) <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS>
                # <COMMENTS>token</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>before</COMMENTS>
                # <COMMENTS>the</COMMENTS> <COMMENTS>third</COMMENTS>
                if ( $<CODE>i</CODE> < $<CODE>ibeg</CODE> + 2 ) { }

                # <COMMENTS>must</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>token</COMMENTS>
                elsif ( $<CODE>types_to_go</CODE>[ $<CODE>i</CODE> - 1 ] ne '<LITERALS>b</LITERALS>' ) { }

                # <COMMENTS>align</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> --
                elsif ( $<CODE>type</CODE> eq '#' ) {

                    unless (

                        # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>static</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
                        (
                               $<CODE>rOpts</CODE>->{'<LITERALS>static</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comments</LITERALS>'}
                            && $<CODE>token</CODE> =~ /$<CODE>static_side_comment_pattern</CODE>/o
                        )

                        # <COMMENTS>or</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
                        || (   $<CODE>vert_last_nonblank_block_type</CODE>
                            && $<CODE>token</CODE> =~
                            /$<CODE>closing_side_comment_prefix_pattern</CODE>/o )
                      )
                    {
                        $<CODE>alignment_type</CODE> = $<CODE>type</CODE>;
                    }    ## <COMMENTS>Example</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>static</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
                }

                # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>row</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS>
                # <COMMENTS>blank</COMMENTS> <COMMENTS>field</COMMENTS>
                elsif ( $<CODE>last_vertical_alignment_before_index</CODE> == $<CODE>i</CODE> - 2 ) { }

                # <COMMENTS>align</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>keywords</COMMENTS>
                # (<COMMENTS>within</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>since</COMMENTS> <COMMENTS>$i</COMMENTS>><COMMENTS>1</COMMENTS>)
                elsif ( $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>' ) {

                    #  /^(<COMMENTS>if</COMMENTS>|<COMMENTS>unless</COMMENTS>|<COMMENTS>and</COMMENTS>|<COMMENTS>or</COMMENTS>|<COMMENTS>eq</COMMENTS>|<COMMENTS>ne</COMMENTS>)<COMMENTS>$</COMMENTS>/
                    if ( $<CODE>is_vertical_alignment_keyword</CODE>{$<CODE>token</CODE>} ) {
                        $<CODE>alignment_type</CODE> = $<CODE>token</CODE>;
                    }
                }

                # <COMMENTS>align</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>types</COMMENTS>..
                # <COMMENTS>Note</COMMENTS>: <COMMENTS>add</COMMENTS> '.' <COMMENTS>after</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>operational</COMMENTS>
                elsif ( $<CODE>is_vertical_alignment_type</CODE>{$<CODE>type</CODE>} ) {
                    $<CODE>alignment_type</CODE> = $<CODE>token</CODE>;

                    # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>token</COMMENTS>.  <COMMENTS>Although</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>might</COMMENTS>
                    # <COMMENTS>occasionally</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS>, <COMMENTS>this</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>found</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS>
                    # <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>general</COMMENTS> <COMMENTS>rule</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>are</COMMENTS>:
                    # (<COMMENTS>1</COMMENTS>) <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>token</COMMENTS> (<COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>an</COMMENTS> = <COMMENTS>or</COMMENTS> :) <COMMENTS>might</COMMENTS> <COMMENTS>get</COMMENTS>
                    # <COMMENTS>moved</COMMENTS> <COMMENTS>far</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>hard</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>because</COMMENTS>
                    # <COMMENTS>nothing</COMMENTS> <COMMENTS>follows</COMMENTS> <COMMENTS>it</COMMENTS>, <COMMENTS>and</COMMENTS>
                    # (<COMMENTS>2</COMMENTS>) <COMMENTS>doing</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>alignments</COMMENTS>.
                    # <COMMENTS>Current</COMMENTS> <COMMENTS>exceptions</COMMENTS> <COMMENTS>are</COMMENTS> && <COMMENTS>and</COMMENTS> ||
                    if ( $<CODE>i</CODE> == $<CODE>iend</CODE> || $<CODE>i</CODE> >= $<CODE>i_terminal</CODE> ) {
                        $<CODE>alignment_type</CODE> = ""
                          unless ( $<CODE>is_terminal_alignment_type</CODE>{$<CODE>type</CODE>} );
                    }

                    # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>leading</COMMENTS> ': (' <COMMENTS>or</COMMENTS> '. ('.  <COMMENTS>This</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>prevent</COMMENTS>
                    # <COMMENTS>alignment</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>:
                    #   <COMMENTS>$extra_space</COMMENTS> .=
                    #       ( <COMMENTS>$input_line_number</COMMENTS> < <COMMENTS>10</COMMENTS> )  ? "  "
                    #     : ( <COMMENTS>$input_line_number</COMMENTS> < <COMMENTS>100</COMMENTS> ) ? " "
                    #     :                                "";
                    # <COMMENTS>or</COMMENTS>
                    #  <COMMENTS>$code</COMMENTS> =
                    #      ( <COMMENTS>$case_matters</COMMENTS> ? <COMMENTS>$accessor</COMMENTS> : " <COMMENTS>lc</COMMENTS>(<COMMENTS>$accessor</COMMENTS>) " )
                    #    . ( <COMMENTS>$yesno</COMMENTS>        ? " <COMMENTS>eq</COMMENTS> "       : " <COMMENTS>ne</COMMENTS> " )
                    if (   $<CODE>i</CODE> == $<CODE>ibeg</CODE> + 2
                        && $<CODE>types_to_go</CODE>[$<CODE>ibeg</CODE>] =~ /^[\.\:]$/
                        && $<CODE>types_to_go</CODE>[ $<CODE>i</CODE> - 1 ] eq '<LITERALS>b</LITERALS>' )
                    {
                        $<CODE>alignment_type</CODE> = "";
                    }

                    # <COMMENTS>For</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>keyword</COMMENTS>, <COMMENTS>only</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
                    #    <COMMENTS>if</COMMENTS>    ( <COMMENTS>$a</COMMENTS> ) { &<COMMENTS>a</COMMENTS> }
                    #    <COMMENTS>elsif</COMMENTS> ( <COMMENTS>$b</COMMENTS> ) { &<COMMENTS>b</COMMENTS> }
                    if ( $<CODE>token</CODE> eq '(' && $<CODE>vert_last_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>' ) {
                        $<CODE>alignment_type</CODE> = ""
                          unless $<CODE>vert_last_nonblank_token</CODE> =~
                          /^(if|unless|elsif)$/;
                    }

                    # <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>unique</COMMENTS>
                    # <COMMENTS>This</COMMENTS> <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>well</COMMENTS>: <COMMENTS>reason</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>determined</COMMENTS>
                    # <COMMENTS>if</COMMENTS> (<COMMENTS>$token</COMMENTS> <COMMENTS>ne</COMMENTS> <COMMENTS>$type</COMMENTS>) {<COMMENTS>$alignment_type</COMMENTS> .= <COMMENTS>$type</COMMENTS>}
                }

                # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>deactivated</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>causes</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS>
                # <COMMENTS>if</COMMENTS>/<COMMENTS>elsif</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>fail</COMMENTS>
                #<COMMENTS>elsif</COMMENTS> ( <COMMENTS>$type</COMMENTS> <COMMENTS>eq</COMMENTS> '}' && <COMMENTS>$token</COMMENTS> <COMMENTS>eq</COMMENTS> '}' && <COMMENTS>$block_type_to_go</COMMENTS>[<COMMENTS>$i</COMMENTS>])
                #{ <COMMENTS>$alignment_type</COMMENTS> = <COMMENTS>$type</COMMENTS>; }

                if ($<CODE>alignment_type</CODE>) {
                    $<CODE>last_vertical_alignment_before_index</CODE> = $<CODE>i</CODE>;
                }

                #--------------------------------------------------------
                # <COMMENTS>Next</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>AFTER</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>nonblank</COMMENTS>
                #--------------------------------------------------------

                # <COMMENTS>We</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS> ',' <COMMENTS>and</COMMENTS> <COMMENTS>interior</COMMENTS> ';' <COMMENTS>tokens</COMMENTS>, <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>added</COMMENTS>
                # <COMMENTS>space</COMMENTS> <COMMENTS>AFTER</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>tokens</COMMENTS>.  (<COMMENTS>Note</COMMENTS>: <COMMENTS>interior</COMMENTS> ';' <COMMENTS>is</COMMENTS> <COMMENTS>included</COMMENTS>
                # <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>occur</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>blocks</COMMENTS>).
                if (

                    # <COMMENTS>we</COMMENTS> <COMMENTS>haven</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>it</COMMENTS>
                    !$<CODE>alignment_type</CODE>

                    # <COMMENTS>and</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>
                    && ( $<CODE>i</CODE> > $<CODE>ibeg</CODE> )

                    # <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>follows</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS>
                    && $<CODE>types_to_go</CODE>[ $<CODE>i</CODE> - 1 ] eq '<LITERALS>b</LITERALS>'

                    # <COMMENTS>and</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>IS</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS>:
                    && ( $<CODE>vert_last_nonblank_type</CODE> =~ /^[\,\;]$/ )

                    # <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>NOT</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS>
                    && ( $<CODE>type</CODE> !~ /^[b\#\)\]\}]$/ )

                    # <COMMENTS>then</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>ahead</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>align</COMMENTS>
                  )

                {
                    $<CODE>alignment_type</CODE> = $<CODE>vert_last_nonblank_type</CODE>;
                }

                #--------------------------------------------------------
                # <COMMENTS>then</COMMENTS> <COMMENTS>store</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>value</COMMENTS>
                #--------------------------------------------------------
                $<CODE>matching_token_to_go</CODE>[$<CODE>i</CODE>] = $<CODE>alignment_type</CODE>;
                if ( $<CODE>type</CODE> ne '<LITERALS>b</LITERALS>' ) {
                    $<CODE>vert_last_nonblank_type</CODE>       = $<CODE>type</CODE>;
                    $<CODE>vert_last_nonblank_token</CODE>      = $<CODE>token</CODE>;
                    $<CODE>vert_last_nonblank_block_type</CODE> = $<CODE>block_type</CODE>;
                }
            }
        }
    }
}

sub <CODE>terminal_type</CODE> {

    #    <COMMENTS>returns</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> (<COMMENTS>terminal</COMMENTS> <COMMENTS>token</COMMENTS>), <COMMENTS>as</COMMENTS> <COMMENTS>follows</COMMENTS>:
    #    <COMMENTS>returns</COMMENTS> # <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>full</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>comment</COMMENTS>
    #    <COMMENTS>returns</COMMENTS> ' ' <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS>
    #    <COMMENTS>otherwise</COMMENTS> <COMMENTS>returns</COMMENTS> <COMMENTS>final</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS>

    my ( $<CODE>rtype</CODE>, $<CODE>rblock_type</CODE>, $<CODE>ibeg</CODE>, $<CODE>iend</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>full</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>comment</COMMENTS>..
    if ( $$<CODE>rtype</CODE>[$<CODE>ibeg</CODE>] eq '#' ) {
        return wantarray ? ( $$<CODE>rtype</CODE>[$<CODE>ibeg</CODE>], $<CODE>ibeg</CODE> ) : $$<CODE>rtype</CODE>[$<CODE>ibeg</CODE>];
    }
    else {

        # <COMMENTS>start</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>walk</COMMENTS> <COMMENTS>backwards</COMMENTS>..
        for ( my $<CODE>i</CODE> = $<CODE>iend</CODE> ; $<CODE>i</CODE> >= $<CODE>ibeg</CODE> ; $<CODE>i</CODE>-- ) {

            # <COMMENTS>skip</COMMENTS> <COMMENTS>past</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>blanks</COMMENTS>
            next if ( $$<CODE>rtype</CODE>[$<CODE>i</CODE>] eq '<LITERALS>b</LITERALS>' );
            next if ( $$<CODE>rtype</CODE>[$<CODE>i</CODE>] eq '#' );

            # <COMMENTS>found</COMMENTS> <COMMENTS>it</COMMENTS>..<COMMENTS>make</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>BLOCK</COMMENTS> <COMMENTS>termination</COMMENTS>,
            # <COMMENTS>but</COMMENTS> <COMMENTS>hide</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>terminal</COMMENTS> } <COMMENTS>after</COMMENTS> <COMMENTS>sort</COMMENTS>/<COMMENTS>grep</COMMENTS>/<COMMENTS>map</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS>
            # <COMMENTS>necessarily</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>.  (<COMMENTS>terminal</COMMENTS>.<COMMENTS>t</COMMENTS>)
            my $<CODE>terminal_type</CODE> = $$<CODE>rtype</CODE>[$<CODE>i</CODE>];
            if (
                $<CODE>terminal_type</CODE> eq '}'
                && ( !$$<CODE>rblock_type</CODE>[$<CODE>i</CODE>]
                    || ( $<CODE>is_sort_map_grep_eval_do</CODE>{ $$<CODE>rblock_type</CODE>[$<CODE>i</CODE>] } ) )
              )
            {
                $<CODE>terminal_type</CODE> = '<LITERALS>b</LITERALS>';
            }
            return wantarray ? ( $<CODE>terminal_type</CODE>, $<CODE>i</CODE> ) : $<CODE>terminal_type</CODE>;
        }

        # <COMMENTS>empty</COMMENTS> <COMMENTS>line</COMMENTS>
        return wantarray ? ( ' ', $<CODE>ibeg</CODE> ) : ' ';
    }
}

{    # <COMMENTS>set_bond_strengths</COMMENTS>

    my %<CODE>is_good_keyword_breakpoint</CODE>;
    my %<CODE>is_lt_gt_le_ge</CODE>;

    my %<CODE>binary_bond_strength</CODE>;
    my %<CODE>nobreak_lhs</CODE>;
    my %<CODE>nobreak_rhs</CODE>;

    my @<CODE>bias_tokens</CODE>;
    my $<CODE>delta_bias</CODE>;

    sub <CODE>bias_table_key</CODE> {
        my ( $<CODE>type</CODE>, $<CODE>token</CODE> ) = @<CODE>_</CODE>;
        my $<CODE>bias_table_key</CODE> = $<CODE>type</CODE>;
        if ( $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>' ) {
            $<CODE>bias_table_key</CODE> = $<CODE>token</CODE>;
            if ( $<CODE>token</CODE> eq '<LITERALS>err</LITERALS>' ) { $<CODE>bias_table_key</CODE> = '<LITERALS>or</LITERALS>' }
        }
        return $<CODE>bias_table_key</CODE>;
    }

    sub <CODE>set_bond_strengths</CODE> {

        <CODE>BEGIN</CODE> {

            @<CODE>_</CODE> = qw(<LITERALS>if</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>while</LITERALS> <LITERALS>until</LITERALS> <LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS>);
            @<CODE>is_good_keyword_breakpoint</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

            @<CODE>_</CODE> = qw(<LITERALS>lt</LITERALS> <LITERALS>gt</LITERALS> <LITERALS>le</LITERALS> <LITERALS>ge</LITERALS>);
            @<CODE>is_lt_gt_le_ge</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);
            #
            # <COMMENTS>The</COMMENTS> <COMMENTS>decision</COMMENTS> <COMMENTS>about</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>depends</COMMENTS> <COMMENTS>upon</COMMENTS> <COMMENTS>a</COMMENTS> "<COMMENTS>bond</COMMENTS>
            # <COMMENTS>strength</COMMENTS>" <COMMENTS>between</COMMENTS> <COMMENTS>tokens</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>LOWER</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>MORE</COMMENTS>
            # <COMMENTS>likely</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS>.  <COMMENTS>A</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>simplify</COMMENTS>
            # <COMMENTS>things</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>several</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>defined</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>levels</COMMENTS>:

            #    <COMMENTS>NO_BREAK</COMMENTS>    => <COMMENTS>10000</COMMENTS>;
            #    <COMMENTS>VERY_STRONG</COMMENTS> => <COMMENTS>100</COMMENTS>;
            #    <COMMENTS>STRONG</COMMENTS>      => <COMMENTS>2</COMMENTS>.<COMMENTS>1</COMMENTS>;
            #    <COMMENTS>NOMINAL</COMMENTS>     => <COMMENTS>1</COMMENTS>.<COMMENTS>1</COMMENTS>;
            #    <COMMENTS>WEAK</COMMENTS>        => <COMMENTS>0</COMMENTS>.<COMMENTS>8</COMMENTS>;
            #    <COMMENTS>VERY_WEAK</COMMENTS>   => <COMMENTS>0</COMMENTS>.<COMMENTS>55</COMMENTS>;

            # <COMMENTS>The</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>based</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>trial</COMMENTS>-<COMMENTS>and</COMMENTS>-<COMMENTS>error</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS>
            # <COMMENTS>tweaked</COMMENTS> <COMMENTS>occasionally</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>desired</COMMENTS> <COMMENTS>results</COMMENTS>.  <COMMENTS>Some</COMMENTS> <COMMENTS>comments</COMMENTS>:
            #
            #   <COMMENTS>1</COMMENTS>. <COMMENTS>Only</COMMENTS> <COMMENTS>relative</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>important</COMMENTS>.  <COMMENTS>small</COMMENTS> <COMMENTS>differences</COMMENTS>
            #      <COMMENTS>in</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>big</COMMENTS> <COMMENTS>formatting</COMMENTS> <COMMENTS>differences</COMMENTS>.
            #   <COMMENTS>2</COMMENTS>. <COMMENTS>Each</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>adds</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>unit</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS>.
            #   <COMMENTS>3</COMMENTS>. <COMMENTS>A</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>NO_BREAK</COMMENTS> <COMMENTS>makes</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>unbreakable</COMMENTS> <COMMENTS>bond</COMMENTS>
            #   <COMMENTS>4</COMMENTS>. <COMMENTS>A</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>VERY_WEAK</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> ','
            #   <COMMENTS>5</COMMENTS>. <COMMENTS>Values</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>NOMINAL</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>considered</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>points</COMMENTS>.
            #   <COMMENTS>6</COMMENTS>. <COMMENTS>Values</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>NOMINAL</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>considered</COMMENTS> <COMMENTS>poor</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>points</COMMENTS>.
            #
            # <COMMENTS>The</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>roughly</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>precedence</COMMENTS> <COMMENTS>order</COMMENTS> <COMMENTS>where</COMMENTS>
            # <COMMENTS>possible</COMMENTS>.  <COMMENTS>If</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>changes</COMMENTS>, <COMMENTS>please</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>results</COMMENTS> <COMMENTS>very</COMMENTS>
            # <COMMENTS>carefully</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>variety</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>scripts</COMMENTS>.  <COMMENTS>Testing</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>extrude</COMMENTS>
            # <COMMENTS>options</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>particularly</COMMENTS> <COMMENTS>helpful</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>exercising</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>rules</COMMENTS>.

            # <COMMENTS>Wherever</COMMENTS> <COMMENTS>possible</COMMENTS>, <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>
            # <COMMENTS>tables</COMMENTS>.  <COMMENTS>There</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>stages</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>setting</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>and</COMMENTS>
            # <COMMENTS>two</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tables</COMMENTS>:
            #
            # <COMMENTS>The</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>stage</COMMENTS> <COMMENTS>involves</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>individually</COMMENTS> <COMMENTS>and</COMMENTS>
            # <COMMENTS>defining</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS>, <COMMENTS>according</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS>
            # <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>side</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>point</COMMENTS> <COMMENTS>it</COMMENTS>
            # <COMMENTS>is</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>like</COMMENTS> =, ||, && <COMMENTS>make</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>points</COMMENTS> <COMMENTS>and</COMMENTS>
            # <COMMENTS>will</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>low</COMMENTS> <COMMENTS>strengths</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>either</COMMENTS>
            # <COMMENTS>side</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>beginning</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS>.
            #
            # <COMMENTS>The</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>stage</COMMENTS> <COMMENTS>involves</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>pairs</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS>
            # <COMMENTS>defining</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>particular</COMMENTS> <COMMENTS>pair</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>second</COMMENTS>
            # <COMMENTS>stage</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>priority</COMMENTS>.

            #---------------------------------------------------------------
            # <COMMENTS>Bond</COMMENTS> <COMMENTS>Strength</COMMENTS> <COMMENTS>BEGIN</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>1</COMMENTS>.
            # <COMMENTS>Set</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>individual</COMMENTS> <COMMENTS>tokens</COMMENTS>.
            #---------------------------------------------------------------

            # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>NO_BREAK</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>HINTS</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>will</COMMENTS>
            # <COMMENTS>probably</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>honored</COMMENTS>. <COMMENTS>Essential</COMMENTS> <COMMENTS>NO_BREAKS</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>in</COMMENTS>
            # <COMMENTS>BEGIN</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>hardwired</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>NO_BREAK</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>near</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS>
            # <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>subroutine</COMMENTS>.

            # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>setting</COMMENTS> <COMMENTS>defaults</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>section</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>user</COMMENTS>
            # <COMMENTS>cannot</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>right</COMMENTS>
            # <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>swapped</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>of</COMMENTS>
            # <COMMENTS>the</COMMENTS> -<COMMENTS>wba</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>wbb</COMMENTS> <COMMENTS>flags</COMMENTS>. <COMMENTS>In</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>way</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>determine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS>
            # <COMMENTS>breakpoint</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>appear</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>beginning</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS>.

            # <COMMENTS>The</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>keys</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>, <COMMENTS>plus</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>of</COMMENTS>
            # <COMMENTS>certain</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>like</COMMENTS> '<COMMENTS>or</COMMENTS>', '<COMMENTS>and</COMMENTS>'.

            # <COMMENTS>no</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>around</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>filehandle</COMMENTS>
            $<CODE>left_bond_strength</CODE>{'<LITERALS>Z</LITERALS>'}  = <CODE>NO_BREAK</CODE>;
            $<CODE>right_bond_strength</CODE>{'<LITERALS>Z</LITERALS>'} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>never</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>:
            # <COMMENTS>example</COMMENTS> <COMMENTS>print</COMMENTS> (<COMMENTS>STDERR</COMMENTS>, "<COMMENTS>bla</COMMENTS>"); <COMMENTS>will</COMMENTS> <COMMENTS>fail</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> (
            $<CODE>left_bond_strength</CODE>{'<LITERALS>w</LITERALS>'} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>blanks</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>infinite</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>after</COMMENTS>
            # <COMMENTS>real</COMMENTS> <COMMENTS>tokens</COMMENTS>
            $<CODE>right_bond_strength</CODE>{'<LITERALS>b</LITERALS>'} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>try</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>exponentation</COMMENTS>
            @<CODE>_</CODE>                       = qw" ** .. ... <=> ";
            @<CODE>left_bond_strength</CODE>{@<CODE>_</CODE>}  = (<CODE>STRONG</CODE>) x scalar(@<CODE>_</CODE>);
            @<CODE>right_bond_strength</CODE>{@<CODE>_</CODE>} = (<CODE>STRONG</CODE>) x scalar(@<CODE>_</CODE>);

            # <COMMENTS>The</COMMENTS> <COMMENTS>comma</COMMENTS>-<COMMENTS>arrow</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>low</COMMENTS> <COMMENTS>precedence</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>point</COMMENTS>
            $<CODE>left_bond_strength</CODE>{'=>'}  = <CODE>NO_BREAK</CODE>;
            $<CODE>right_bond_strength</CODE>{'=>'} = <CODE>NOMINAL</CODE>;

            # <COMMENTS>ok</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>label</COMMENTS>
            $<CODE>left_bond_strength</CODE>{'<LITERALS>J</LITERALS>'}  = <CODE>NO_BREAK</CODE>;
            $<CODE>right_bond_strength</CODE>{'<LITERALS>J</LITERALS>'} = <CODE>NOMINAL</CODE>;
            $<CODE>left_bond_strength</CODE>{'<LITERALS>j</LITERALS>'}  = <CODE>STRONG</CODE>;
            $<CODE>right_bond_strength</CODE>{'<LITERALS>j</LITERALS>'} = <CODE>STRONG</CODE>;
            $<CODE>left_bond_strength</CODE>{'<LITERALS>A</LITERALS>'}  = <CODE>STRONG</CODE>;
            $<CODE>right_bond_strength</CODE>{'<LITERALS>A</LITERALS>'} = <CODE>STRONG</CODE>;

            $<CODE>left_bond_strength</CODE>{'->'}  = <CODE>STRONG</CODE>;
            $<CODE>right_bond_strength</CODE>{'->'} = <CODE>VERY_STRONG</CODE>;

            $<CODE>left_bond_strength</CODE>{'<LITERALS>CORE</LITERALS>::'}  = <CODE>NOMINAL</CODE>;
            $<CODE>right_bond_strength</CODE>{'<LITERALS>CORE</LITERALS>::'} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>breaking</COMMENTS> <COMMENTS>AFTER</COMMENTS> <COMMENTS>modulus</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>ok</COMMENTS>:
            @<CODE>_</CODE> = qw" % ";
            @<CODE>left_bond_strength</CODE>{@<CODE>_</CODE>} = (<CODE>STRONG</CODE>) x scalar(@<CODE>_</CODE>);
            @<CODE>right_bond_strength</CODE>{@<CODE>_</CODE>} =
              ( 0.1 * <CODE>NOMINAL</CODE> + 0.9 * <CODE>STRONG</CODE> ) x scalar(@<CODE>_</CODE>);

            # <COMMENTS>Break</COMMENTS> <COMMENTS>AFTER</COMMENTS> <COMMENTS>math</COMMENTS> <COMMENTS>operators</COMMENTS> * <COMMENTS>and</COMMENTS> /
            @<CODE>_</CODE>                       = qw" * / <LITERALS>x</LITERALS>  ";
            @<CODE>left_bond_strength</CODE>{@<CODE>_</CODE>}  = (<CODE>STRONG</CODE>) x scalar(@<CODE>_</CODE>);
            @<CODE>right_bond_strength</CODE>{@<CODE>_</CODE>} = (<CODE>NOMINAL</CODE>) x scalar(@<CODE>_</CODE>);

            # <COMMENTS>Break</COMMENTS> <COMMENTS>AFTER</COMMENTS> <COMMENTS>weakest</COMMENTS> <COMMENTS>math</COMMENTS> <COMMENTS>operators</COMMENTS> + <COMMENTS>and</COMMENTS> -
            # <COMMENTS>Make</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>weaker</COMMENTS> <COMMENTS>than</COMMENTS> * <COMMENTS>but</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bit</COMMENTS> <COMMENTS>stronger</COMMENTS> <COMMENTS>than</COMMENTS> '.'
            @<CODE>_</CODE> = qw" + - ";
            @<CODE>left_bond_strength</CODE>{@<CODE>_</CODE>} = (<CODE>STRONG</CODE>) x scalar(@<CODE>_</CODE>);
            @<CODE>right_bond_strength</CODE>{@<CODE>_</CODE>} =
              ( 0.91 * <CODE>NOMINAL</CODE> + 0.09 * <CODE>WEAK</CODE> ) x scalar(@<CODE>_</CODE>);

            # <COMMENTS>breaking</COMMENTS> <COMMENTS>BEFORE</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>ok</COMMENTS>:
            @<CODE>_</CODE>                       = qw" >> << ";
            @<CODE>right_bond_strength</CODE>{@<CODE>_</CODE>} = (<CODE>STRONG</CODE>) x scalar(@<CODE>_</CODE>);
            @<CODE>left_bond_strength</CODE>{@<CODE>_</CODE>}  = (<CODE>NOMINAL</CODE>) x scalar(@<CODE>_</CODE>);

            # <COMMENTS>breaking</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>concatenation</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>best</COMMENTS>
            # <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>hard</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>
            $<CODE>right_bond_strength</CODE>{'.'} = <CODE>STRONG</CODE>;
            $<CODE>left_bond_strength</CODE>{'.'}  = 0.9 * <CODE>NOMINAL</CODE> + 0.1 * <CODE>WEAK</CODE>;

            @<CODE>_</CODE>                       = qw"} ] ) <LITERALS>R</LITERALS>";
            @<CODE>left_bond_strength</CODE>{@<CODE>_</CODE>}  = (<CODE>STRONG</CODE>) x scalar(@<CODE>_</CODE>);
            @<CODE>right_bond_strength</CODE>{@<CODE>_</CODE>} = (<CODE>NOMINAL</CODE>) x scalar(@<CODE>_</CODE>);

            # <COMMENTS>make</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>little</COMMENTS> <COMMENTS>weaker</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>nominal</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>get</COMMENTS>
            # <COMMENTS>favored</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>end</COMMENTS>-<COMMENTS>of</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>characters</COMMENTS>
            @<CODE>_</CODE> = qw"!= == =~ !~ ~~ !~~";
            @<CODE>left_bond_strength</CODE>{@<CODE>_</CODE>} = (<CODE>STRONG</CODE>) x scalar(@<CODE>_</CODE>);
            @<CODE>right_bond_strength</CODE>{@<CODE>_</CODE>} =
              ( 0.9 * <CODE>NOMINAL</CODE> + 0.1 * <CODE>WEAK</CODE> ) x scalar(@<CODE>_</CODE>);

            # <COMMENTS>break</COMMENTS> <COMMENTS>AFTER</COMMENTS> <COMMENTS>these</COMMENTS>
            @<CODE>_</CODE> = qw" < >  | & >= <=";
            @<CODE>left_bond_strength</CODE>{@<CODE>_</CODE>} = (<CODE>VERY_STRONG</CODE>) x scalar(@<CODE>_</CODE>);
            @<CODE>right_bond_strength</CODE>{@<CODE>_</CODE>} =
              ( 0.8 * <CODE>NOMINAL</CODE> + 0.2 * <CODE>WEAK</CODE> ) x scalar(@<CODE>_</CODE>);

            # <COMMENTS>breaking</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>ok</COMMENTS>
            # <COMMENTS>but</COMMENTS> <COMMENTS>bias</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>breaking</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS>
            $<CODE>left_bond_strength</CODE>{'<LITERALS>Q</LITERALS>'}  = <CODE>NOMINAL</CODE>;
            $<CODE>right_bond_strength</CODE>{'<LITERALS>Q</LITERALS>'} = <CODE>NOMINAL</CODE> + 0.02;
            $<CODE>left_bond_strength</CODE>{'<LITERALS>q</LITERALS>'}  = <CODE>NOMINAL</CODE>;
            $<CODE>right_bond_strength</CODE>{'<LITERALS>q</LITERALS>'} = <CODE>NOMINAL</CODE>;

            # <COMMENTS>starting</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>ok</COMMENTS>
            $<CODE>left_bond_strength</CODE>{'<LITERALS>k</LITERALS>'} = <CODE>NOMINAL</CODE>;

            # <COMMENTS>we</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>strongly</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>immediately</COMMENTS>
            # <COMMENTS>follows</COMMENTS>, <COMMENTS>rather</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>leaving</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>stranded</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>
            $<CODE>right_bond_strength</CODE>{'<LITERALS>k</LITERALS>'} = <CODE>STRONG</CODE>;

            $<CODE>left_bond_strength</CODE>{'<LITERALS>G</LITERALS>'}  = <CODE>NOMINAL</CODE>;
            $<CODE>right_bond_strength</CODE>{'<LITERALS>G</LITERALS>'} = <CODE>STRONG</CODE>;

            # <COMMENTS>assignment</COMMENTS> <COMMENTS>operators</COMMENTS>
            @<CODE>_</CODE> = qw(
              = **= += *= &= <<= &&=
              -= /= |= >>= ||= //=
              .= %= ^=
              <LITERALS>x</LITERALS>=
            );

            # <COMMENTS>Default</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>AFTER</COMMENTS> <COMMENTS>various</COMMENTS> <COMMENTS>assignment</COMMENTS> <COMMENTS>operators</COMMENTS>
            @<CODE>left_bond_strength</CODE>{@<CODE>_</CODE>} = (<CODE>STRONG</CODE>) x scalar(@<CODE>_</CODE>);
            @<CODE>right_bond_strength</CODE>{@<CODE>_</CODE>} =
              ( 0.4 * <CODE>WEAK</CODE> + 0.6 * <CODE>VERY_WEAK</CODE> ) x scalar(@<CODE>_</CODE>);

            # <COMMENTS>Default</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>BEFORE</COMMENTS> '&&' <COMMENTS>and</COMMENTS> '||' <COMMENTS>and</COMMENTS> '//'
            # <COMMENTS>set</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>of</COMMENTS> '||' <COMMENTS>to</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>as</COMMENTS> '=' <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>chains</COMMENTS> <COMMENTS>like</COMMENTS>
            # <COMMENTS>$a</COMMENTS> = <COMMENTS>$b</COMMENTS> || <COMMENTS>$c</COMMENTS> || <COMMENTS>$d</COMMENTS>   <COMMENTS>will</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> '||'
            $<CODE>right_bond_strength</CODE>{'||'} = <CODE>NOMINAL</CODE>;
            $<CODE>left_bond_strength</CODE>{'||'}  = $<CODE>right_bond_strength</CODE>{'='};

            # <COMMENTS>same</COMMENTS> <COMMENTS>thing</COMMENTS> <COMMENTS>for</COMMENTS> '//'
            $<CODE>right_bond_strength</CODE>{'//'} = <CODE>NOMINAL</CODE>;
            $<CODE>left_bond_strength</CODE>{'//'}  = $<CODE>right_bond_strength</CODE>{'='};

            # <COMMENTS>set</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>of</COMMENTS> && <COMMENTS>a</COMMENTS> <COMMENTS>little</COMMENTS> <COMMENTS>higher</COMMENTS> <COMMENTS>than</COMMENTS> ||
            $<CODE>right_bond_strength</CODE>{'&&'} = <CODE>NOMINAL</CODE>;
            $<CODE>left_bond_strength</CODE>{'&&'}  = $<CODE>left_bond_strength</CODE>{'||'} + 0.1;

            $<CODE>left_bond_strength</CODE>{';'}  = <CODE>VERY_STRONG</CODE>;
            $<CODE>right_bond_strength</CODE>{';'} = <CODE>VERY_WEAK</CODE>;
            $<CODE>left_bond_strength</CODE>{'<LITERALS>f</LITERALS>'}  = <CODE>VERY_STRONG</CODE>;

            # <COMMENTS>make</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>for</COMMENTS> ';' <COMMENTS>a</COMMENTS> <COMMENTS>little</COMMENTS> <COMMENTS>less</COMMENTS> <COMMENTS>than</COMMENTS> '='
            # <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>contents</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> ';' <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>this</COMMENTS>:
            #   <COMMENTS>for</COMMENTS> ( <COMMENTS>$j</COMMENTS> = <COMMENTS>$number_of_fields</COMMENTS> - <COMMENTS>1</COMMENTS> ; <COMMENTS>$j</COMMENTS> < <COMMENTS>$item_count</COMMENTS> ; <COMMENTS>$j</COMMENTS> +=
            #     <COMMENTS>$number_of_fields</COMMENTS> )
            # <COMMENTS>and</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>weaker</COMMENTS> <COMMENTS>than</COMMENTS> ',' <COMMENTS>and</COMMENTS> '<COMMENTS>and</COMMENTS>' <COMMENTS>too</COMMENTS>
            $<CODE>right_bond_strength</CODE>{'<LITERALS>f</LITERALS>'} = <CODE>VERY_WEAK</CODE> - 0.03;

            # <COMMENTS>The</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>of</COMMENTS> ?/: <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>somewhere</COMMENTS> <COMMENTS>between</COMMENTS>
            # <COMMENTS>an</COMMENTS> '=' <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS> (<COMMENTS>NOMINAL</COMMENTS>),
            # <COMMENTS>make</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>of</COMMENTS> ':' <COMMENTS>slightly</COMMENTS> <COMMENTS>less</COMMENTS> <COMMENTS>than</COMMENTS> '?' <COMMENTS>to</COMMENTS> <COMMENTS>help</COMMENTS>
            # <COMMENTS>break</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>chains</COMMENTS> <COMMENTS>of</COMMENTS> ? : <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>colons</COMMENTS>
            $<CODE>left_bond_strength</CODE>{':'}  = 0.4 * <CODE>WEAK</CODE> + 0.6 * <CODE>NOMINAL</CODE>;
            $<CODE>right_bond_strength</CODE>{':'} = <CODE>NO_BREAK</CODE>;
            $<CODE>left_bond_strength</CODE>{'?'}  = $<CODE>left_bond_strength</CODE>{':'} + 0.01;
            $<CODE>right_bond_strength</CODE>{'?'} = <CODE>NO_BREAK</CODE>;

            $<CODE>left_bond_strength</CODE>{','}  = <CODE>VERY_STRONG</CODE>;
            $<CODE>right_bond_strength</CODE>{','} = <CODE>VERY_WEAK</CODE>;

            # <COMMENTS>remaining</COMMENTS> <COMMENTS>digraphs</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>trigraphs</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>above</COMMENTS>
            @<CODE>_</CODE>                       = qw( :: <> ++ --);
            @<CODE>left_bond_strength</CODE>{@<CODE>_</CODE>}  = (<CODE>WEAK</CODE>) x scalar(@<CODE>_</CODE>);
            @<CODE>right_bond_strength</CODE>{@<CODE>_</CODE>} = (<CODE>STRONG</CODE>) x scalar(@<CODE>_</CODE>);

            # <COMMENTS>Set</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>keywords</COMMENTS>
            # <COMMENTS>make</COMMENTS> '<COMMENTS>or</COMMENTS>', '<COMMENTS>err</COMMENTS>', '<COMMENTS>and</COMMENTS>' <COMMENTS>slightly</COMMENTS> <COMMENTS>weaker</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>a</COMMENTS> ','
            $<CODE>left_bond_strength</CODE>{'<LITERALS>and</LITERALS>'}  = <CODE>VERY_WEAK</CODE> - 0.01;
            $<CODE>left_bond_strength</CODE>{'<LITERALS>or</LITERALS>'}   = <CODE>VERY_WEAK</CODE> - 0.02;
            $<CODE>left_bond_strength</CODE>{'<LITERALS>err</LITERALS>'}  = <CODE>VERY_WEAK</CODE> - 0.02;
            $<CODE>left_bond_strength</CODE>{'<LITERALS>xor</LITERALS>'}  = <CODE>NOMINAL</CODE>;
            $<CODE>right_bond_strength</CODE>{'<LITERALS>and</LITERALS>'} = <CODE>NOMINAL</CODE>;
            $<CODE>right_bond_strength</CODE>{'<LITERALS>or</LITERALS>'}  = <CODE>NOMINAL</CODE>;
            $<CODE>right_bond_strength</CODE>{'<LITERALS>err</LITERALS>'} = <CODE>NOMINAL</CODE>;
            $<CODE>right_bond_strength</CODE>{'<LITERALS>xor</LITERALS>'} = <CODE>STRONG</CODE>;

            #---------------------------------------------------------------
            # <COMMENTS>Bond</COMMENTS> <COMMENTS>Strength</COMMENTS> <COMMENTS>BEGIN</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>2</COMMENTS>.
            # <COMMENTS>Set</COMMENTS> <COMMENTS>binary</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>.
            #---------------------------------------------------------------

            #  <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>little</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>making</COMMENTS> <COMMENTS>tables</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>apply</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS>
            #  <COMMENTS>container</COMMENTS> <COMMENTS>tokens</COMMENTS>.  <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS>
            #  <COMMENTS>their</COMMENTS> <COMMENTS>types</COMMENTS>:
            #
            #   <COMMENTS>type</COMMENTS>    <COMMENTS>tokens</COMMENTS> // <COMMENTS>meaning</COMMENTS>
            #      {    {, [, ( // <COMMENTS>indent</COMMENTS>
            #      }    }, ], ) // <COMMENTS>outdent</COMMENTS>
            #      [    [ // <COMMENTS>left</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS> [ (<COMMENTS>enclosing</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>index</COMMENTS>)
            #      ]    ] // <COMMENTS>right</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS> <COMMENTS>square</COMMENTS> <COMMENTS>bracket</COMMENTS>
            #      (    ( // <COMMENTS>left</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS> <COMMENTS>paren</COMMENTS>
            #      )    ) // <COMMENTS>right</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS> <COMMENTS>paren</COMMENTS>
            #      <COMMENTS>L</COMMENTS>    { // <COMMENTS>left</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>brace</COMMENTS> (<COMMENTS>enclosing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>key</COMMENTS>)
            #      <COMMENTS>R</COMMENTS>    } // <COMMENTS>right</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>brace</COMMENTS>
            #
            #  <COMMENTS>Some</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>apply</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS>
            #  <COMMENTS>itself</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>solve</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>combining</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>a</COMMENTS>
            #  <COMMENTS>new</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>key</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>types</COMMENTS>.
            #
            #  <COMMENTS>If</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>applies</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>token</COMMENTS> '<COMMENTS>type</COMMENTS>' <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>rules</COMMENTS>
            #  <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> '<COMMENTS>type</COMMENTS>.<COMMENTS>token</COMMENTS>' <COMMENTS>combinations</COMMENTS>:
            #  <COMMENTS>Type</COMMENTS>    <COMMENTS>Type</COMMENTS>.<COMMENTS>Token</COMMENTS>
            #  {       {{, {[, {(
            #  [       [[
            #  (       ((
            #  <COMMENTS>L</COMMENTS>       <COMMENTS>L</COMMENTS>{
            #  }       }}, }], })
            #  ]       ]]
            #  )       ))
            #  <COMMENTS>R</COMMENTS>       <COMMENTS>R</COMMENTS>}
            #
            #  <COMMENTS>If</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>applies</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>for</COMMENTS>
            #  <COMMENTS>these</COMMENTS> '<COMMENTS>type</COMMENTS>.<COMMENTS>token</COMMENTS>' <COMMENTS>combinations</COMMENTS>:
            #  <COMMENTS>Token</COMMENTS>   <COMMENTS>Type</COMMENTS>.<COMMENTS>Token</COMMENTS>
            #  {       {{, <COMMENTS>L</COMMENTS>{
            #  [       {[, [[
            #  (       {(, ((
            #  }       }}, <COMMENTS>R</COMMENTS>}
            #  ]       }], ]]
            #  )       }), ))

            # <COMMENTS>allow</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>final</COMMENTS> { <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>statement</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS>:
            #    <COMMENTS>if</COMMENTS> (..........
            #      ..........)
            #    {
            #
            # <COMMENTS>Otherwise</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> { <COMMENTS>tends</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>short</COMMENTS>.

            $<CODE>binary_bond_strength</CODE>{'))'}{'{{'} = <CODE>VERY_WEAK</CODE> + 0.03;
            $<CODE>binary_bond_strength</CODE>{'(('}{'{{'} = <CODE>NOMINAL</CODE>;

            # <COMMENTS>break</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> '} (', <COMMENTS>but</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>stronger</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>a</COMMENTS> ','
            # <COMMENTS>example</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>in</COMMENTS> '<COMMENTS>howe</COMMENTS>.<COMMENTS>pl</COMMENTS>'
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>R</LITERALS>}'}{'(('} = 0.8 * <CODE>VERY_WEAK</CODE> + 0.2 * <CODE>WEAK</CODE>;
            $<CODE>binary_bond_strength</CODE>{'}}'}{'(('} = 0.8 * <CODE>VERY_WEAK</CODE> + 0.2 * <CODE>WEAK</CODE>;

            # <COMMENTS>keep</COMMENTS> <COMMENTS>matrix</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>indices</COMMENTS> <COMMENTS>together</COMMENTS>
            # <COMMENTS>but</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>little</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>STRONG</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>breaking</COMMENTS> <COMMENTS>open</COMMENTS>
            # <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> {'<COMMENTS>some</COMMENTS>-<COMMENTS>word</COMMENTS>'}{'<COMMENTS>some</COMMENTS>-<COMMENTS>very</COMMENTS>-<COMMENTS>long</COMMENTS>-<COMMENTS>word</COMMENTS>'} <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> }{
            # (<COMMENTS>bracebrk</COMMENTS>.<COMMENTS>t</COMMENTS>)
            $<CODE>binary_bond_strength</CODE>{']]'}{'[['} = 0.9 * <CODE>STRONG</CODE> + 0.1 * <CODE>NOMINAL</CODE>;
            $<CODE>binary_bond_strength</CODE>{']]'}{'<LITERALS>L</LITERALS>{'} = 0.9 * <CODE>STRONG</CODE> + 0.1 * <CODE>NOMINAL</CODE>;
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>R</LITERALS>}'}{'[['} = 0.9 * <CODE>STRONG</CODE> + 0.1 * <CODE>NOMINAL</CODE>;
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>R</LITERALS>}'}{'<LITERALS>L</LITERALS>{'} = 0.9 * <CODE>STRONG</CODE> + 0.1 * <CODE>NOMINAL</CODE>;

            # <COMMENTS>increase</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>point</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>
            # <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>rather</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>arrow</COMMENTS>:
            #    <COMMENTS>$a</COMMENTS>-><COMMENTS>$b</COMMENTS>(<COMMENTS>$c</COMMENTS>);
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>i</LITERALS>'}{'->'} = 1.45 * <CODE>STRONG</CODE>;

            $<CODE>binary_bond_strength</CODE>{'))'}{'->'} = 0.1 * <CODE>STRONG</CODE> + 0.9 * <CODE>NOMINAL</CODE>;
            $<CODE>binary_bond_strength</CODE>{']]'}{'->'} = 0.1 * <CODE>STRONG</CODE> + 0.9 * <CODE>NOMINAL</CODE>;
            $<CODE>binary_bond_strength</CODE>{'})'}{'->'} = 0.1 * <CODE>STRONG</CODE> + 0.9 * <CODE>NOMINAL</CODE>;
            $<CODE>binary_bond_strength</CODE>{'}]'}{'->'} = 0.1 * <CODE>STRONG</CODE> + 0.9 * <CODE>NOMINAL</CODE>;
            $<CODE>binary_bond_strength</CODE>{'}}'}{'->'} = 0.1 * <CODE>STRONG</CODE> + 0.9 * <CODE>NOMINAL</CODE>;
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>R</LITERALS>}'}{'->'} = 0.1 * <CODE>STRONG</CODE> + 0.9 * <CODE>NOMINAL</CODE>;

            $<CODE>binary_bond_strength</CODE>{'))'}{'[['} = 0.2 * <CODE>STRONG</CODE> + 0.8 * <CODE>NOMINAL</CODE>;
            $<CODE>binary_bond_strength</CODE>{'})'}{'[['} = 0.2 * <CODE>STRONG</CODE> + 0.8 * <CODE>NOMINAL</CODE>;
            $<CODE>binary_bond_strength</CODE>{'))'}{'{['} = 0.2 * <CODE>STRONG</CODE> + 0.8 * <CODE>NOMINAL</CODE>;
            $<CODE>binary_bond_strength</CODE>{'})'}{'{['} = 0.2 * <CODE>STRONG</CODE> + 0.8 * <CODE>NOMINAL</CODE>;

            #---------------------------------------------------------------
            # <COMMENTS>Binary</COMMENTS> <COMMENTS>NO_BREAK</COMMENTS> <COMMENTS>rules</COMMENTS>
            #---------------------------------------------------------------

            # <COMMENTS>use</COMMENTS> <COMMENTS>strict</COMMENTS> <COMMENTS>requires</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>and</COMMENTS> => <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>separated</COMMENTS>
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>C</LITERALS>'}{'=>'} = <CODE>NO_BREAK</CODE>;
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>U</LITERALS>'}{'=>'} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>Never</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bareword</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>because</COMMENTS>
            # <COMMENTS>perl</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>placed</COMMENTS>
            # <COMMENTS>between</COMMENTS> '<COMMENTS>to_filehandle</COMMENTS>' <COMMENTS>and</COMMENTS> <COMMENTS>its</COMMENTS> '(' <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>will</COMMENTS>
            # <COMMENTS>give</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>error</COMMENTS> [<COMMENTS>Carp</COMMENTS>.<COMMENTS>pm</COMMENTS>]: <COMMENTS>my</COMMENTS>( <COMMENTS>$no</COMMENTS>) =<COMMENTS>fileno</COMMENTS>(
            # <COMMENTS>to_filehandle</COMMENTS>( <COMMENTS>$in</COMMENTS>)) ;
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>C</LITERALS>'}{'(('} = <CODE>NO_BREAK</CODE>;
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>C</LITERALS>'}{'{('} = <CODE>NO_BREAK</CODE>;
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>U</LITERALS>'}{'(('} = <CODE>NO_BREAK</CODE>;
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>U</LITERALS>'}{'{('} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>use</COMMENTS> <COMMENTS>strict</COMMENTS> <COMMENTS>requires</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>new</COMMENTS>
            # <COMMENTS>line</COMMENTS>
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>L</LITERALS>{'}{'<LITERALS>w</LITERALS>'} = <CODE>NO_BREAK</CODE>;

            $<CODE>binary_bond_strength</CODE>{'<LITERALS>w</LITERALS>'}{'<LITERALS>R</LITERALS>}'} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>use</COMMENTS> <COMMENTS>strict</COMMENTS> <COMMENTS>requires</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>and</COMMENTS> => <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>separated</COMMENTS>
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>w</LITERALS>'}{'=>'} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>use</COMMENTS> <COMMENTS>strict</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>separating</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>info</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>trailing</COMMENTS> { }
            # <COMMENTS>testfile</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>readmail</COMMENTS>.<COMMENTS>pl</COMMENTS>
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>t</LITERALS>'}{'<LITERALS>L</LITERALS>{'} = <CODE>NO_BREAK</CODE>;
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>i</LITERALS>'}{'<LITERALS>L</LITERALS>{'} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>As</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>defensive</COMMENTS> <COMMENTS>measure</COMMENTS>, <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>a</COMMENTS> '(' <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS>
            # <COMMENTS>filehandle</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>cases</COMMENTS>, <COMMENTS>this</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS>.  <COMMENTS>For</COMMENTS>
            # <COMMENTS>example</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>program</COMMENTS> <COMMENTS>works</COMMENTS>:
            #    <COMMENTS>my</COMMENTS> <COMMENTS>$msg</COMMENTS>="<COMMENTS>hi</COMMENTS>!\<COMMENTS>n</COMMENTS>";
            #    <COMMENTS>print</COMMENTS>
            #    ( <COMMENTS>STDOUT</COMMENTS>
            #    <COMMENTS>$msg</COMMENTS>
            #    );
            #
            # <COMMENTS>But</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>program</COMMENTS> <COMMENTS>fails</COMMENTS>:
            #    <COMMENTS>my</COMMENTS> <COMMENTS>$msg</COMMENTS>="<COMMENTS>hi</COMMENTS>!\<COMMENTS>n</COMMENTS>";
            #    <COMMENTS>print</COMMENTS>
            #    (
            #    <COMMENTS>STDOUT</COMMENTS>
            #    <COMMENTS>$msg</COMMENTS>
            #    );
            #
            # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>normally</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>extrude</COMMENTS>' <COMMENTS>option</COMMENTS>
            $<CODE>binary_bond_strength</CODE>{'(('}{'<LITERALS>Y</LITERALS>'} = <CODE>NO_BREAK</CODE>;
            $<CODE>binary_bond_strength</CODE>{'{('}{'<LITERALS>Y</LITERALS>'} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>never</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS>
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>w</LITERALS>'}{'(('} = <CODE>NO_BREAK</CODE>;
            $<CODE>binary_bond_strength</CODE>{'<LITERALS>w</LITERALS>'}{'{('} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>keep</COMMENTS> '}' <COMMENTS>together</COMMENTS> <COMMENTS>with</COMMENTS> ';'
            $<CODE>binary_bond_strength</CODE>{'}}'}{';'} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>Breaking</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> ++ <COMMENTS>can</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>guess</COMMENTS> <COMMENTS>wrong</COMMENTS>. <COMMENTS>For</COMMENTS>
            # <COMMENTS>example</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>error</COMMENTS>
            # <COMMENTS>with</COMMENTS> -<COMMENTS>extrude</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>between</COMMENTS> '<COMMENTS>$i</COMMENTS>' <COMMENTS>and</COMMENTS> '++' [<COMMENTS>fixstyle2</COMMENTS>]
            #   <COMMENTS>print</COMMENTS>( ( <COMMENTS>$i</COMMENTS>++ & <COMMENTS>1</COMMENTS> ) ? <COMMENTS>$_</COMMENTS> : ( <COMMENTS>$change</COMMENTS>{<COMMENTS>$_</COMMENTS>} || <COMMENTS>$_</COMMENTS> ) );
            $<CODE>nobreak_lhs</CODE>{'++'} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>handle</COMMENTS>
            $<CODE>nobreak_lhs</CODE>{'<LITERALS>Z</LITERALS>'} = <CODE>NO_BREAK</CODE>;

            # <COMMENTS>use</COMMENTS> <COMMENTS>strict</COMMENTS> <COMMENTS>hates</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>words</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>For</COMMENTS>
            # <COMMENTS>example</COMMENTS>, <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>underscore</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>provokes</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>wrath</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>strict</COMMENTS>:
            # <COMMENTS>if</COMMENTS> ( -<COMMENTS>r</COMMENTS> <COMMENTS>$fn</COMMENTS> && ( -<COMMENTS>s</COMMENTS> <COMMENTS>_</COMMENTS> || <COMMENTS>$AllowZeroFilesize</COMMENTS>)) {
            $<CODE>nobreak_rhs</CODE>{'<LITERALS>F</LITERALS>'}      = <CODE>NO_BREAK</CODE>;
            $<CODE>nobreak_rhs</CODE>{'<LITERALS>CORE</LITERALS>::'} = <CODE>NO_BREAK</CODE>;

            #---------------------------------------------------------------
            # <COMMENTS>Bond</COMMENTS> <COMMENTS>Strength</COMMENTS> <COMMENTS>BEGIN</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>3</COMMENTS>.
            # <COMMENTS>Define</COMMENTS> <COMMENTS>tables</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>applying</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>bias</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS>
            # <COMMENTS>values</COMMENTS>.
            #---------------------------------------------------------------
            # <COMMENTS>Adding</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>small</COMMENTS> '<COMMENTS>bias</COMMENTS>' <COMMENTS>to</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>way</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>
            # <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>identical</COMMENTS> <COMMENTS>terms</COMMENTS>.  <COMMENTS>For</COMMENTS>
            # <COMMENTS>example</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>conditional</COMMENTS> <COMMENTS>operators</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS>
            # <COMMENTS>with</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> ':', <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>each</COMMENTS> ':' (<COMMENTS>colon</COMMENTS>.<COMMENTS>t</COMMENTS>)
            @<CODE>bias_tokens</CODE> = qw( : && || <LITERALS>f</LITERALS> <LITERALS>and</LITERALS> <LITERALS>or</LITERALS> . );    # <COMMENTS>tokens</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>bias</COMMENTS>
            $<CODE>delta_bias</CODE> = 0.0001;    # <COMMENTS>a</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>level</COMMENTS>

        } ## <COMMENTS>end</COMMENTS> <COMMENTS>BEGIN</COMMENTS>

        # <COMMENTS>patch</COMMENTS>-<COMMENTS>its</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS>
        $<CODE>nobreak_to_go</CODE>[$<CODE>max_index_to_go</CODE>] = 0;

        # <COMMENTS>we</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>bias</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS>
        my %<CODE>bias</CODE>;
        @<CODE>bias</CODE>{@<CODE>bias_tokens</CODE>} = (0) x scalar(@<CODE>bias_tokens</CODE>);
        my $<CODE>code_bias</CODE> = -.01;        # <COMMENTS>bias</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>braces</COMMENTS>

        my $<CODE>type</CODE>  = '<LITERALS>b</LITERALS>';
        my $<CODE>token</CODE> = ' ';
        my $<CODE>last_type</CODE>;
        my $<CODE>last_nonblank_type</CODE>  = $<CODE>type</CODE>;
        my $<CODE>last_nonblank_token</CODE> = $<CODE>token</CODE>;
        my $<CODE>list_str</CODE>            = $<CODE>left_bond_strength</CODE>{'?'};

        my ( $<CODE>block_type</CODE>, $<CODE>i_next</CODE>, $<CODE>i_next_nonblank</CODE>, $<CODE>next_nonblank_token</CODE>,
            $<CODE>next_nonblank_type</CODE>, $<CODE>next_token</CODE>, $<CODE>next_type</CODE>, $<CODE>total_nesting_depth</CODE>,
        );

        # <COMMENTS>main</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>compute</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>pair</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS>
        for ( my $<CODE>i</CODE> = 0 ; $<CODE>i</CODE> <= $<CODE>max_index_to_go</CODE> ; $<CODE>i</CODE>++ ) {
            $<CODE>last_type</CODE> = $<CODE>type</CODE>;
            if ( $<CODE>type</CODE> ne '<LITERALS>b</LITERALS>' ) {
                $<CODE>last_nonblank_type</CODE>  = $<CODE>type</CODE>;
                $<CODE>last_nonblank_token</CODE> = $<CODE>token</CODE>;
            }
            $<CODE>type</CODE> = $<CODE>types_to_go</CODE>[$<CODE>i</CODE>];

            # <COMMENTS>strength</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>sides</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS>
            if ( $<CODE>type</CODE> eq '<LITERALS>b</LITERALS>' && $<CODE>last_type</CODE> ne '<LITERALS>b</LITERALS>' ) {
                $<CODE>bond_strength_to_go</CODE>[$<CODE>i</CODE>] = $<CODE>bond_strength_to_go</CODE>[ $<CODE>i</CODE> - 1 ];
                next;
            }

            $<CODE>token</CODE>               = $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>];
            $<CODE>block_type</CODE>          = $<CODE>block_type_to_go</CODE>[$<CODE>i</CODE>];
            $<CODE>i_next</CODE>              = $<CODE>i</CODE> + 1;
            $<CODE>next_type</CODE>           = $<CODE>types_to_go</CODE>[$<CODE>i_next</CODE>];
            $<CODE>next_token</CODE>          = $<CODE>tokens_to_go</CODE>[$<CODE>i_next</CODE>];
            $<CODE>total_nesting_depth</CODE> = $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_next</CODE>];
            $<CODE>i_next_nonblank</CODE>     = ( ( $<CODE>next_type</CODE> eq '<LITERALS>b</LITERALS>' ) ? $<CODE>i</CODE> + 2 : $<CODE>i</CODE> + 1 );
            $<CODE>next_nonblank_type</CODE>  = $<CODE>types_to_go</CODE>[$<CODE>i_next_nonblank</CODE>];
            $<CODE>next_nonblank_token</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>i_next_nonblank</CODE>];

            # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>computing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS>
            # <COMMENTS>token</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>NEXT</COMMENTS> <COMMENTS>token</COMMENTS>.

            #---------------------------------------------------------------
            # <COMMENTS>Bond</COMMENTS> <COMMENTS>Strength</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>1</COMMENTS>:
            # <COMMENTS>First</COMMENTS> <COMMENTS>Approximation</COMMENTS>.
            # <COMMENTS>Use</COMMENTS> <COMMENTS>minimum</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>individual</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>tabulated</COMMENTS> <COMMENTS>bond</COMMENTS>
            # <COMMENTS>strengths</COMMENTS>.
            #---------------------------------------------------------------
            my $<CODE>bsr</CODE> = $<CODE>right_bond_strength</CODE>{$<CODE>type</CODE>};
            my $<CODE>bsl</CODE> = $<CODE>left_bond_strength</CODE>{$<CODE>next_nonblank_type</CODE>};

            # <COMMENTS>define</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>keywords</COMMENTS>
            if ( $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>' && defined( $<CODE>right_bond_strength</CODE>{$<CODE>token</CODE>} ) ) {
                $<CODE>bsr</CODE> = $<CODE>right_bond_strength</CODE>{$<CODE>token</CODE>};
            }
            elsif ( $<CODE>token</CODE> eq '<LITERALS>ne</LITERALS>' or $<CODE>token</CODE> eq '<LITERALS>eq</LITERALS>' ) {
                $<CODE>bsr</CODE> = <CODE>NOMINAL</CODE>;
            }

            # <COMMENTS>set</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>nominal</COMMENTS> <COMMENTS>value</COMMENTS>
            # <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>preceding</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>retained</COMMENTS>
            if ( $<CODE>i_next_nonblank</CODE> > $<CODE>max_index_to_go</CODE> ) {
                $<CODE>bsl</CODE> = <CODE>NOMINAL</CODE>;
            }

            # <COMMENTS>define</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>keywords</COMMENTS>
            if ( $<CODE>next_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>'
                && defined( $<CODE>left_bond_strength</CODE>{$<CODE>next_nonblank_token</CODE>} ) )
            {
                $<CODE>bsl</CODE> = $<CODE>left_bond_strength</CODE>{$<CODE>next_nonblank_token</CODE>};
            }
            elsif ($<CODE>next_nonblank_token</CODE> eq '<LITERALS>ne</LITERALS>'
                or $<CODE>next_nonblank_token</CODE> eq '<LITERALS>eq</LITERALS>' )
            {
                $<CODE>bsl</CODE> = <CODE>NOMINAL</CODE>;
            }
            elsif ( $<CODE>is_lt_gt_le_ge</CODE>{$<CODE>next_nonblank_token</CODE>} ) {
                $<CODE>bsl</CODE> = 0.9 * <CODE>NOMINAL</CODE> + 0.1 * <CODE>STRONG</CODE>;
            }

            # <COMMENTS>Use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>minimum</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>strengths</COMMENTS>.  <COMMENTS>Note</COMMENTS>: <COMMENTS>it</COMMENTS> <COMMENTS>might</COMMENTS>
            # <COMMENTS>seem</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>NO_BREAK</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>has</COMMENTS>
            # <COMMENTS>this</COMMENTS> <COMMENTS>value</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>arrow</COMMENTS>
            # <COMMENTS>list</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>prevents</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>separating</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>
            # <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS> (<COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>arrow</COMMENTS>).  <COMMENTS>So</COMMENTS> <COMMENTS>necessary</COMMENTS>
            # <COMMENTS>NO_BREAK</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>cases</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>final</COMMENTS>
            # <COMMENTS>section</COMMENTS>.
            if ( !defined($<CODE>bsr</CODE>) ) { $<CODE>bsr</CODE> = <CODE>VERY_STRONG</CODE> }
            if ( !defined($<CODE>bsl</CODE>) ) { $<CODE>bsl</CODE> = <CODE>VERY_STRONG</CODE> }
            my $<CODE>bond_str</CODE> = ( $<CODE>bsr</CODE> < $<CODE>bsl</CODE> ) ? $<CODE>bsr</CODE> : $<CODE>bsl</CODE>;
            my $<CODE>bond_str_1</CODE> = $<CODE>bond_str</CODE>;

            #---------------------------------------------------------------
            # <COMMENTS>Bond</COMMENTS> <COMMENTS>Strength</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>2</COMMENTS>:
            # <COMMENTS>Apply</COMMENTS> <COMMENTS>hardwired</COMMENTS> <COMMENTS>rules</COMMENTS>..
            #---------------------------------------------------------------

            # <COMMENTS>Patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>clauses</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>: <COMMENTS>Weaken</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>bond</COMMENTS>
            # <COMMENTS>at</COMMENTS> <COMMENTS>an</COMMENTS> || <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>die</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>similar</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>terminal</COMMENTS>
            # <COMMENTS>or</COMMENTS> <COMMENTS>clause</COMMENTS> <COMMENTS>fall</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
            #
            #   <COMMENTS>my</COMMENTS> <COMMENTS>$class</COMMENTS> = <COMMENTS>shift</COMMENTS>
            #     || <COMMENTS>die</COMMENTS> "<COMMENTS>Cannot</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>broadcast</COMMENTS>:  <COMMENTS>No</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>identifier</COMMENTS> <COMMENTS>found</COMMENTS>";
            #
            # <COMMENTS>Otherwise</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> '=' <COMMENTS>since</COMMENTS> <COMMENTS>the</COMMENTS> || <COMMENTS>and</COMMENTS>
            # = <COMMENTS>have</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>biased</COMMENTS>, <COMMENTS>like</COMMENTS>
            # <COMMENTS>this</COMMENTS>:
            #
            # <COMMENTS>my</COMMENTS> <COMMENTS>$class</COMMENTS> =
            #   <COMMENTS>shift</COMMENTS> || <COMMENTS>die</COMMENTS> "<COMMENTS>Cannot</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>broadcast</COMMENTS>:  <COMMENTS>No</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>identifier</COMMENTS> <COMMENTS>found</COMMENTS>";
            #
            # <COMMENTS>In</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>places</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>the</COMMENTS> = <COMMENTS>or</COMMENTS> <COMMENTS>the</COMMENTS> ||
            # <COMMENTS>it</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>remain</COMMENTS> <COMMENTS>there</COMMENTS>.
            if ( $<CODE>type</CODE> eq '||' || $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>' && $<CODE>token</CODE> eq '<LITERALS>or</LITERALS>' ) {
                if ( $<CODE>next_nonblank_token</CODE> =~ /^(die|confess|croak|warn)$/ ) {
                    if ( $<CODE>want_break_before</CODE>{$<CODE>token</CODE>} && $<CODE>i</CODE> > 0 ) {
                        $<CODE>bond_strength_to_go</CODE>[ $<CODE>i</CODE> - 1 ] -= $<CODE>delta_bias</CODE>;
                    }
                    else {
                        $<CODE>bond_str</CODE> -= $<CODE>delta_bias</CODE>;
                    }
                }
            }

            # <COMMENTS>good</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>blocks</COMMENTS>
            if ( $<CODE>type</CODE> eq '}' && $<CODE>block_type</CODE> && $<CODE>next_nonblank_type</CODE> ne ';' ) {

                $<CODE>bond_str</CODE> = 0.5 * <CODE>WEAK</CODE> + 0.5 * <CODE>VERY_WEAK</CODE> + $<CODE>code_bias</CODE>;
                $<CODE>code_bias</CODE> += $<CODE>delta_bias</CODE>;
            }

            if ( $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>' ) {

                # <COMMENTS>allow</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>control</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>stand</COMMENTS> <COMMENTS>out</COMMENTS>
                if (   $<CODE>next_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>'
                    && $<CODE>is_last_next_redo_return</CODE>{$<CODE>token</CODE>} )
                {
                    $<CODE>bond_str</CODE> = 0.45 * <CODE>WEAK</CODE> + 0.55 * <CODE>VERY_WEAK</CODE>;
                }

                # <COMMENTS>Don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>my</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quick</COMMENTS> <COMMENTS>fix</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS>
                # <COMMENTS>rare</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>perl</COMMENTS>. <COMMENTS>An</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>file</COMMENTS>
                # <COMMENTS>Container</COMMENTS>.<COMMENTS>pm</COMMENTS>:

                # <COMMENTS>foreach</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>$question</COMMENTS>( <COMMENTS>Debian</COMMENTS>::<COMMENTS>DebConf</COMMENTS>::<COMMENTS>ConfigDb</COMMENTS>::<COMMENTS>gettree</COMMENTS>(
                # <COMMENTS>$this</COMMENTS>->{'<COMMENTS>question</COMMENTS>'} ) )

                if ( $<CODE>token</CODE> eq '<LITERALS>my</LITERALS>' ) {
                    $<CODE>bond_str</CODE> = <CODE>NO_BREAK</CODE>;
                }

            }

            # <COMMENTS>good</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> '<COMMENTS>if</COMMENTS>', '<COMMENTS>unless</COMMENTS>', <COMMENTS>etc</COMMENTS>
            if ( $<CODE>is_if_brace_follower</CODE>{$<CODE>next_nonblank_token</CODE>} ) {
                $<CODE>bond_str</CODE> = <CODE>VERY_WEAK</CODE>;
            }

            if ( $<CODE>next_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>' && $<CODE>type</CODE> ne '<LITERALS>CORE</LITERALS>::' ) {

                # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>needs</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>testing</COMMENTS>
                if ( $<CODE>is_keyword_returning_list</CODE>{$<CODE>next_nonblank_token</CODE>} ) {
                    $<CODE>bond_str</CODE> = $<CODE>list_str</CODE> if ( $<CODE>bond_str</CODE> > $<CODE>list_str</CODE> );
                }

                # <COMMENTS>keywords</COMMENTS> <COMMENTS>like</COMMENTS> '<COMMENTS>unless</COMMENTS>', '<COMMENTS>if</COMMENTS>', <COMMENTS>etc</COMMENTS>, <COMMENTS>within</COMMENTS> <COMMENTS>statements</COMMENTS>
                # <COMMENTS>make</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>breaks</COMMENTS>
                if ( $<CODE>is_good_keyword_breakpoint</CODE>{$<CODE>next_nonblank_token</CODE>} ) {
                    $<CODE>bond_str</CODE> = <CODE>VERY_WEAK</CODE> / 1.05;
                }
            }

            # <COMMENTS>try</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>-<COMMENTS>arrow</COMMENTS>
            elsif ( $<CODE>next_nonblank_type</CODE> eq '=>' ) {
                if ( $<CODE>bond_str</CODE> < <CODE>STRONG</CODE> ) { $<CODE>bond_str</CODE> = <CODE>STRONG</CODE> }
            }

            #---------------------------------------------------------------
            # <COMMENTS>Additional</COMMENTS> <COMMENTS>hardwired</COMMENTS> <COMMENTS>NOBREAK</COMMENTS> <COMMENTS>rules</COMMENTS>
            #---------------------------------------------------------------

            # <COMMENTS>map1</COMMENTS>.<COMMENTS>t</COMMENTS> -- <COMMENTS>correct</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quirk</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>perl</COMMENTS>
            if (   $<CODE>token</CODE> eq '('
                && $<CODE>next_nonblank_type</CODE> eq '<LITERALS>i</LITERALS>'
                && $<CODE>last_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>'
                && $<CODE>is_sort_map_grep</CODE>{$<CODE>last_nonblank_token</CODE>} )

              #     /^(<COMMENTS>sort</COMMENTS>|<COMMENTS>map</COMMENTS>|<COMMENTS>grep</COMMENTS>)<COMMENTS>$</COMMENTS>/ )
            {
                $<CODE>bond_str</CODE> = <CODE>NO_BREAK</CODE>;
            }

            # <COMMENTS>extrude</COMMENTS>.<COMMENTS>t</COMMENTS>: <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>at</COMMENTS>:
            #    -<COMMENTS>l</COMMENTS> <COMMENTS>pid_filename</COMMENTS>(
            if ( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>F</LITERALS>' && $<CODE>next_nonblank_token</CODE> eq '(' ) {
                $<CODE>bond_str</CODE> = <CODE>NO_BREAK</CODE>;
            }

            # <COMMENTS>in</COMMENTS> <COMMENTS>older</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS>, <COMMENTS>use</COMMENTS> <COMMENTS>strict</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>with</COMMENTS>
            # <COMMENTS>breaks</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>words</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>parens</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>,
            # <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>fail</COMMENTS> <COMMENTS>under</COMMENTS> <COMMENTS>older</COMMENTS> <COMMENTS>versions</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>made</COMMENTS> <COMMENTS>between</COMMENTS>
            # '(' <COMMENTS>and</COMMENTS> '<COMMENTS>MAIL</COMMENTS>': <COMMENTS>use</COMMENTS> <COMMENTS>strict</COMMENTS>; <COMMENTS>open</COMMENTS>( <COMMENTS>MAIL</COMMENTS>, "<COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>filename</COMMENTS> <COMMENTS>or</COMMENTS>
            # <COMMENTS>command</COMMENTS>"); <COMMENTS>close</COMMENTS> <COMMENTS>MAIL</COMMENTS>;
            if ( $<CODE>type</CODE> eq '{' ) {

                if ( $<CODE>token</CODE> eq '(' && $<CODE>next_nonblank_type</CODE> eq '<LITERALS>w</LITERALS>' ) {

                    # <COMMENTS>but</COMMENTS> <COMMENTS>it</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>fine</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> '=>'
                    # <COMMENTS>or</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>obviously</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>call</COMMENTS>
                    my $<CODE>i_next_next_nonblank</CODE> = $<CODE>i_next_nonblank</CODE> + 1;
                    my $<CODE>next_next_type</CODE> = $<CODE>types_to_go</CODE>[$<CODE>i_next_next_nonblank</CODE>];
                    if (   $<CODE>next_next_type</CODE> eq '<LITERALS>b</LITERALS>'
                        && $<CODE>i_next_nonblank</CODE> < $<CODE>max_index_to_go</CODE> )
                    {
                        $<CODE>i_next_next_nonblank</CODE>++;
                        $<CODE>next_next_type</CODE> = $<CODE>types_to_go</CODE>[$<CODE>i_next_next_nonblank</CODE>];
                    }

                    # <COMMENTS>We</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>breakpoint</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS>
                    # <COMMENTS>bareword</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>way</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS>.
                    # <COMMENTS>Presumably</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>way</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>the</COMMENTS>
                    # <COMMENTS>following</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>remain</COMMENTS> <COMMENTS>unchanged</COMMENTS>:
                    #
                    # @<COMMENTS>months</COMMENTS> = (
                    #   <COMMENTS>January</COMMENTS>,   <COMMENTS>February</COMMENTS>, <COMMENTS>March</COMMENTS>,    <COMMENTS>April</COMMENTS>,
                    #   <COMMENTS>May</COMMENTS>,       <COMMENTS>June</COMMENTS>,     <COMMENTS>July</COMMENTS>,     <COMMENTS>August</COMMENTS>,
                    #   <COMMENTS>September</COMMENTS>, <COMMENTS>October</COMMENTS>,  <COMMENTS>November</COMMENTS>, <COMMENTS>December</COMMENTS>,
                    # );
                    #
                    # <COMMENTS>This</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sufficient</COMMENTS>:
                    if (
                        !$<CODE>old_breakpoint_to_go</CODE>[$<CODE>i</CODE>]
                        && (   $<CODE>next_next_type</CODE> eq ','
                            || $<CODE>next_next_type</CODE> eq '}' )
                      )
                    {
                        $<CODE>bond_str</CODE> = <CODE>NO_BREAK</CODE>;
                    }
                }
            }

            # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>filehandle</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> ? <COMMENTS>or</COMMENTS> / <COMMENTS>and</COMMENTS> <COMMENTS>do</COMMENTS>
            # <COMMENTS>not</COMMENTS> <COMMENTS>introduce</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>blank</COMMENTS>
            # (<COMMENTS>extrude</COMMENTS>.<COMMENTS>t</COMMENTS>)
            elsif ( $<CODE>type</CODE> eq '<LITERALS>Z</LITERALS>' ) {

                # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>break</COMMENTS>..
                if (

                    # <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>one</COMMENTS>. <COMMENTS>Examples</COMMENTS>:
                    #    <COMMENTS>print</COMMENTS> <COMMENTS>$x</COMMENTS>++    # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>$x</COMMENTS>
                    #    <COMMENTS>print</COMMENTS> <COMMENTS>HTML</COMMENTS>"<COMMENTS>HELLO</COMMENTS>"   # <COMMENTS>break</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>HTML</COMMENTS>
                    (
                           $<CODE>next_type</CODE> ne '<LITERALS>b</LITERALS>'
                        && defined( $<CODE>want_left_space</CODE>{$<CODE>next_type</CODE>} )
                        && $<CODE>want_left_space</CODE>{$<CODE>next_type</CODE>} == <CODE>WS_NO</CODE>
                    )

                    # <COMMENTS>or</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS>
                    || $<CODE>next_nonblank_type</CODE> =~ /^[\/\?]$/
                  )
                {
                    $<CODE>bond_str</CODE> = <CODE>NO_BREAK</CODE>;
                }
            }

            # <COMMENTS>Breaking</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> ? <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>trouble</COMMENTS> <COMMENTS>if</COMMENTS>
            # <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>separated</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS>.
            # <COMMENTS>Example</COMMENTS>: <COMMENTS>a</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>occurs</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> ? <COMMENTS>here</COMMENTS>
            #  <COMMENTS>my$logic</COMMENTS>=<COMMENTS>join$all</COMMENTS>?' && ':' || ',@<COMMENTS>regexps</COMMENTS>;
            # <COMMENTS>From</COMMENTS>: <COMMENTS>Professional_Perl_Programming_Code</COMMENTS>/<COMMENTS>multifind</COMMENTS>.<COMMENTS>pl</COMMENTS>
            if ( $<CODE>next_nonblank_type</CODE> eq '?' ) {
                $<CODE>bond_str</CODE> = <CODE>NO_BREAK</CODE>
                  if ( $<CODE>types_to_go</CODE>[ $<CODE>i_next_nonblank</CODE> + 1 ] eq '<LITERALS>Q</LITERALS>' );
            }

            # <COMMENTS>Breaking</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> . <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>number</COMMENTS>
            # <COMMENTS>can</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>trouble</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>intervening</COMMENTS> <COMMENTS>space</COMMENTS>
            # <COMMENTS>Example</COMMENTS>: <COMMENTS>a</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>occurs</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> .<COMMENTS>2</COMMENTS> <COMMENTS>here</COMMENTS>
            #  <COMMENTS>$str</COMMENTS> .= <COMMENTS>pack</COMMENTS>(<COMMENTS>$endian</COMMENTS>.<COMMENTS>2</COMMENTS>, <COMMENTS>ensurrogate</COMMENTS>(<COMMENTS>$ord</COMMENTS>));
            # <COMMENTS>From</COMMENTS>: <COMMENTS>perl58</COMMENTS>/<COMMENTS>Unicode</COMMENTS>.<COMMENTS>pm</COMMENTS>
            elsif ( $<CODE>next_nonblank_type</CODE> eq '.' ) {
                $<CODE>bond_str</CODE> = <CODE>NO_BREAK</CODE>
                  if ( $<CODE>types_to_go</CODE>[ $<CODE>i_next_nonblank</CODE> + 1 ] eq '<LITERALS>n</LITERALS>' );
            }

            # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>cuddled</COMMENTS> <COMMENTS>elses</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>together</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>multiple</COMMENTS>
            # <COMMENTS>lines</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS>: } \<COMMENTS>n</COMMENTS> <COMMENTS>else</COMMENTS> \<COMMENTS>n</COMMENTS> { \<COMMENTS>n</COMMENTS>
            if ($<CODE>rOpts_cuddled_else</CODE>) {

                if (   ( $<CODE>token</CODE> eq '<LITERALS>else</LITERALS>' ) && ( $<CODE>next_nonblank_type</CODE> eq '{' )
                    || ( $<CODE>type</CODE> eq '}' ) && ( $<CODE>next_nonblank_token</CODE> eq '<LITERALS>else</LITERALS>' ) )
                {
                    $<CODE>bond_str</CODE> = <CODE>NO_BREAK</CODE>;
                }
            }
            my $<CODE>bond_str_2</CODE> = $<CODE>bond_str</CODE>;

            #---------------------------------------------------------------
            # <COMMENTS>End</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>hardwired</COMMENTS> <COMMENTS>rules</COMMENTS>
            #---------------------------------------------------------------

            #---------------------------------------------------------------
            # <COMMENTS>Bond</COMMENTS> <COMMENTS>Strength</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>3</COMMENTS>:
            # <COMMENTS>Apply</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>rules</COMMENTS>. <COMMENTS>These</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>priority</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS>
            # <COMMENTS>hardwired</COMMENTS> <COMMENTS>rules</COMMENTS>.
            #---------------------------------------------------------------

            my $<CODE>tabulated_bond_str</CODE>;
            my $<CODE>ltype</CODE> = $<CODE>type</CODE>;
            my $<CODE>rtype</CODE> = $<CODE>next_nonblank_type</CODE>;
            if ( $<CODE>token</CODE> =~ /^[\(\[\{\)\]\}]/ ) { $<CODE>ltype</CODE> = $<CODE>type</CODE> . $<CODE>token</CODE> }
            if ( $<CODE>next_nonblank_token</CODE> =~ /^[\(\[\{\)\]\}]/ ) {
                $<CODE>rtype</CODE> = $<CODE>next_nonblank_type</CODE> . $<CODE>next_nonblank_token</CODE>;
            }

            if ( $<CODE>binary_bond_strength</CODE>{$<CODE>ltype</CODE>}{$<CODE>rtype</CODE>} ) {
                $<CODE>bond_str</CODE>           = $<CODE>binary_bond_strength</CODE>{$<CODE>ltype</CODE>}{$<CODE>rtype</CODE>};
                $<CODE>tabulated_bond_str</CODE> = $<CODE>bond_str</CODE>;
            }

            if ( $<CODE>nobreak_rhs</CODE>{$<CODE>ltype</CODE>} || $<CODE>nobreak_lhs</CODE>{$<CODE>rtype</CODE>} ) {
                $<CODE>bond_str</CODE>           = <CODE>NO_BREAK</CODE>;
                $<CODE>tabulated_bond_str</CODE> = $<CODE>bond_str</CODE>;
            }
            my $<CODE>bond_str_3</CODE> = $<CODE>bond_str</CODE>;

            # <COMMENTS>If</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>hardwired</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>conflict</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tabulated</COMMENTS> <COMMENTS>bond</COMMENTS>
            # <COMMENTS>strength</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>inconsistency</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>fixed</COMMENTS>
            <CODE>FORMATTER_DEBUG_FLAG_BOND_TABLES</CODE>
              && $<CODE>tabulated_bond_str</CODE>
              && $<CODE>bond_str_1</CODE>
              && $<CODE>bond_str_1</CODE> != $<CODE>bond_str_2</CODE>
              && $<CODE>bond_str_2</CODE> != $<CODE>tabulated_bond_str</CODE>
              && do {
                print <CODE>STDERR</CODE>
"<LITERALS>BOND_TABLES</LITERALS>: <LITERALS>ltype</LITERALS>=$<CODE>ltype</CODE> <LITERALS>rtype</LITERALS>=$<CODE>rtype</CODE> $<CODE>bond_str_1</CODE>->$<CODE>bond_str_2</CODE>->$<CODE>bond_str_3</CODE>\n";
              };

           #-----------------------------------------------------------------
           # <COMMENTS>Bond</COMMENTS> <COMMENTS>Strength</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>4</COMMENTS>:
           # <COMMENTS>Modify</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>often</COMMENTS> <COMMENTS>occur</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>sequence</COMMENTS>
           # <COMMENTS>by</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>bias</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>turn</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>breaks</COMMENTS>
           # <COMMENTS>occur</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>right</COMMENTS>.
           #
           # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>changing</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>amounts</COMMENTS> <COMMENTS>here</COMMENTS>,
           # <COMMENTS>and</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>increasing</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>altering</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>NO_BREAKs</COMMENTS>.
           # <COMMENTS>Other</COMMENTS> <COMMENTS>routines</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>NO_BREAKs</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>tolerance</COMMENTS>
           # <COMMENTS>of</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>problem</COMMENTS>.
           #-----------------------------------------------------------------

            # <COMMENTS>The</COMMENTS> <COMMENTS>bias</COMMENTS> <COMMENTS>tables</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>keys</COMMENTS>
            my $<CODE>left_key</CODE> = <CODE>bias_table_key</CODE>( $<CODE>type</CODE>, $<CODE>token</CODE> );
            my $<CODE>right_key</CODE> =
              <CODE>bias_table_key</CODE>( $<CODE>next_nonblank_type</CODE>, $<CODE>next_nonblank_token</CODE> );

            # <COMMENTS>add</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>bias</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>scan_list</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>points</COMMENTS>.
            if ( $<CODE>type</CODE> eq ',' ) { $<CODE>bond_str</CODE> += $<CODE>bond_strength_to_go</CODE>[$<CODE>i</CODE>] }

            # <COMMENTS>bias</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>token</COMMENTS>
            elsif ( defined( $<CODE>bias</CODE>{$<CODE>left_key</CODE>} ) ) {
                if ( !$<CODE>want_break_before</CODE>{$<CODE>left_key</CODE>} ) {
                    $<CODE>bias</CODE>{$<CODE>left_key</CODE>} += $<CODE>delta_bias</CODE>;
                    $<CODE>bond_str</CODE> += $<CODE>bias</CODE>{$<CODE>left_key</CODE>};
                }
            }

            # <COMMENTS>bias</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>token</COMMENTS>
            if ( defined( $<CODE>bias</CODE>{$<CODE>right_key</CODE>} ) ) {
                if ( $<CODE>want_break_before</CODE>{$<CODE>right_key</CODE>} ) {

                    # <COMMENTS>for</COMMENTS> <COMMENTS>leading</COMMENTS> '.' <COMMENTS>align</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>but</COMMENTS> '<COMMENTS>short</COMMENTS>' <COMMENTS>quotes</COMMENTS>; <COMMENTS>the</COMMENTS> <COMMENTS>idea</COMMENTS>
                    # <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>place</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> "\<COMMENTS>n</COMMENTS>" <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>line</COMMENTS>.
                    if ( $<CODE>right_key</CODE> eq '.' ) {
                        unless (
                            $<CODE>last_nonblank_type</CODE> eq '.'
                            && (
                                length($<CODE>token</CODE>) <=
                                $<CODE>rOpts_short_concatenation_item_length</CODE> )
                            && ( $<CODE>token</CODE> !~ /^[\)\]\}]$/ )
                          )
                        {
                            $<CODE>bias</CODE>{$<CODE>right_key</CODE>} += $<CODE>delta_bias</CODE>;
                        }
                    }
                    else {
                        $<CODE>bias</CODE>{$<CODE>right_key</CODE>} += $<CODE>delta_bias</CODE>;
                    }
                    $<CODE>bond_str</CODE> += $<CODE>bias</CODE>{$<CODE>right_key</CODE>};
                }
            }
            my $<CODE>bond_str_4</CODE> = $<CODE>bond_str</CODE>;

            #---------------------------------------------------------------
            # <COMMENTS>Bond</COMMENTS> <COMMENTS>Strength</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>5</COMMENTS>:
            # <COMMENTS>Fifth</COMMENTS> <COMMENTS>Approximation</COMMENTS>.
            # <COMMENTS>Take</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>account</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depth</COMMENTS>
            # <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS>.
            #---------------------------------------------------------------
            my $<CODE>strength</CODE>;

            if ( defined($<CODE>bond_str</CODE>) && !$<CODE>nobreak_to_go</CODE>[$<CODE>i</CODE>] ) {
                if ( $<CODE>total_nesting_depth</CODE> > 0 ) {
                    $<CODE>strength</CODE> = $<CODE>bond_str</CODE> + $<CODE>total_nesting_depth</CODE>;
                }
                else {
                    $<CODE>strength</CODE> = $<CODE>bond_str</CODE>;
                }
            }
            else {
                $<CODE>strength</CODE> = <CODE>NO_BREAK</CODE>;
            }

            # <COMMENTS>always</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
            if ( $<CODE>type</CODE> eq '#' ) { $<CODE>strength</CODE> = 0 }

            $<CODE>bond_strength_to_go</CODE>[$<CODE>i</CODE>] = $<CODE>strength</CODE>;

            <CODE>FORMATTER_DEBUG_FLAG_BOND</CODE> && do {
                my $<CODE>str</CODE> = substr( $<CODE>token</CODE>, 0, 15 );
                $<CODE>str</CODE> .= ' ' x ( 16 - length($<CODE>str</CODE>) );
                print <CODE>STDOUT</CODE>
"<LITERALS>BOND</LITERALS>:  <LITERALS>i</LITERALS>=$<CODE>i</CODE> $<CODE>str</CODE> $<CODE>type</CODE> $<CODE>next_nonblank_type</CODE> <LITERALS>depth</LITERALS>=$<CODE>total_nesting_depth</CODE> <LITERALS>strength</LITERALS>=$<CODE>bond_str_1</CODE> -> $<CODE>bond_str_2</CODE> -> $<CODE>bond_str_3</CODE> -> $<CODE>bond_str_4</CODE> $<CODE>bond_str</CODE> -> $<CODE>strength</CODE> \n";
            };
        } ## <COMMENTS>end</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>loop</COMMENTS>
    } ## <COMMENTS>end</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>set_bond_strengths</COMMENTS>
}

sub <CODE>pad_array_to_go</CODE> {

    # <COMMENTS>to</COMMENTS> <COMMENTS>simplify</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>scan_list</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>set_bond_strengths</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>helps</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>arrays</COMMENTS>
    $<CODE>tokens_to_go</CODE>[ $<CODE>max_index_to_go</CODE> + 1 ] = '';
    $<CODE>tokens_to_go</CODE>[ $<CODE>max_index_to_go</CODE> + 2 ] = '';
    $<CODE>types_to_go</CODE>[ $<CODE>max_index_to_go</CODE> + 1 ]  = '<LITERALS>b</LITERALS>';
    $<CODE>types_to_go</CODE>[ $<CODE>max_index_to_go</CODE> + 2 ]  = '<LITERALS>b</LITERALS>';
    $<CODE>nesting_depth_to_go</CODE>[ $<CODE>max_index_to_go</CODE> + 1 ] =
      $<CODE>nesting_depth_to_go</CODE>[$<CODE>max_index_to_go</CODE>];

    #    /^[<COMMENTS>R</COMMENTS>\}\)\]]<COMMENTS>$</COMMENTS>/
    if ( $<CODE>is_closing_type</CODE>{ $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>] } ) {
        if ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>max_index_to_go</CODE>] <= 0 ) {

            # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>:
            unless ( <CODE>get_saw_brace_error</CODE>() ) {
                <CODE>warning</CODE>(
"<LITERALS>Program</LITERALS> <LITERALS>bug</LITERALS> <LITERALS>in</LITERALS> <LITERALS>scan_list</LITERALS>: <LITERALS>hit</LITERALS> <LITERALS>nesting</LITERALS> <LITERALS>error</LITERALS> <LITERALS>which</LITERALS> <LITERALS>should</LITERALS> <LITERALS>have</LITERALS> <LITERALS>been</LITERALS> <LITERALS>caught</LITERALS>\n"
                );
                <CODE>report_definite_bug</CODE>();
            }
        }
        else {
            $<CODE>nesting_depth_to_go</CODE>[ $<CODE>max_index_to_go</CODE> + 1 ] -= 1;
        }
    }

    #       /^[<COMMENTS>L</COMMENTS>\{\(\[]<COMMENTS>$</COMMENTS>/
    elsif ( $<CODE>is_opening_type</CODE>{ $<CODE>types_to_go</CODE>[$<CODE>max_index_to_go</CODE>] } ) {
        $<CODE>nesting_depth_to_go</CODE>[ $<CODE>max_index_to_go</CODE> + 1 ] += 1;
    }
}

{    # <COMMENTS>begin</COMMENTS> <COMMENTS>scan_list</COMMENTS>

    my (
        $<CODE>block_type</CODE>,               $<CODE>current_depth</CODE>,
        $<CODE>depth</CODE>,                    $<CODE>i</CODE>,
        $<CODE>i_last_nonblank_token</CODE>,    $<CODE>last_colon_sequence_number</CODE>,
        $<CODE>last_nonblank_token</CODE>,      $<CODE>last_nonblank_type</CODE>,
        $<CODE>last_nonblank_block_type</CODE>, $<CODE>last_old_breakpoint_count</CODE>,
        $<CODE>minimum_depth</CODE>,            $<CODE>next_nonblank_block_type</CODE>,
        $<CODE>next_nonblank_token</CODE>,      $<CODE>next_nonblank_type</CODE>,
        $<CODE>old_breakpoint_count</CODE>,     $<CODE>starting_breakpoint_count</CODE>,
        $<CODE>starting_depth</CODE>,           $<CODE>token</CODE>,
        $<CODE>type</CODE>,                     $<CODE>type_sequence</CODE>,
    );

    my (
        @<CODE>breakpoint_stack</CODE>,              @<CODE>breakpoint_undo_stack</CODE>,
        @<CODE>comma_index</CODE>,                   @<CODE>container_type</CODE>,
        @<CODE>identifier_count_stack</CODE>,        @<CODE>index_before_arrow</CODE>,
        @<CODE>interrupted_list</CODE>,              @<CODE>item_count_stack</CODE>,
        @<CODE>last_comma_index</CODE>,              @<CODE>last_dot_index</CODE>,
        @<CODE>last_nonblank_type</CODE>,            @<CODE>old_breakpoint_count_stack</CODE>,
        @<CODE>opening_structure_index_stack</CODE>, @<CODE>rfor_semicolon_list</CODE>,
        @<CODE>has_old_logical_breakpoints</CODE>,   @<CODE>rand_or_list</CODE>,
        @<CODE>i_equals</CODE>,
    );

    # <COMMENTS>routine</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>define</COMMENTS> <COMMENTS>essential</COMMENTS> <COMMENTS>variables</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>go</COMMENTS> '<COMMENTS>up</COMMENTS>' <COMMENTS>to</COMMENTS>
    # <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>depth</COMMENTS>
    sub <CODE>check_for_new_minimum_depth</CODE> {
        my $<CODE>depth</CODE> = shift;
        if ( $<CODE>depth</CODE> < $<CODE>minimum_depth</CODE> ) {

            $<CODE>minimum_depth</CODE> = $<CODE>depth</CODE>;

            # <COMMENTS>these</COMMENTS> <COMMENTS>arrays</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>retain</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>calls</COMMENTS>
            $<CODE>breakpoint_stack</CODE>[$<CODE>depth</CODE>]              = $<CODE>starting_breakpoint_count</CODE>;
            $<CODE>container_type</CODE>[$<CODE>depth</CODE>]                = "";
            $<CODE>identifier_count_stack</CODE>[$<CODE>depth</CODE>]        = 0;
            $<CODE>index_before_arrow</CODE>[$<CODE>depth</CODE>]            = -1;
            $<CODE>interrupted_list</CODE>[$<CODE>depth</CODE>]              = 1;
            $<CODE>item_count_stack</CODE>[$<CODE>depth</CODE>]              = 0;
            $<CODE>last_nonblank_type</CODE>[$<CODE>depth</CODE>]            = "";
            $<CODE>opening_structure_index_stack</CODE>[$<CODE>depth</CODE>] = -1;

            $<CODE>breakpoint_undo_stack</CODE>[$<CODE>depth</CODE>]       = undef;
            $<CODE>comma_index</CODE>[$<CODE>depth</CODE>]                 = undef;
            $<CODE>last_comma_index</CODE>[$<CODE>depth</CODE>]            = undef;
            $<CODE>last_dot_index</CODE>[$<CODE>depth</CODE>]              = undef;
            $<CODE>old_breakpoint_count_stack</CODE>[$<CODE>depth</CODE>]  = undef;
            $<CODE>has_old_logical_breakpoints</CODE>[$<CODE>depth</CODE>] = 0;
            $<CODE>rand_or_list</CODE>[$<CODE>depth</CODE>]                = [];
            $<CODE>rfor_semicolon_list</CODE>[$<CODE>depth</CODE>]         = [];
            $<CODE>i_equals</CODE>[$<CODE>depth</CODE>]                    = -1;

            # <COMMENTS>these</COMMENTS> <COMMENTS>arrays</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>retain</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>calls</COMMENTS>
            if ( !defined( $<CODE>has_broken_sublist</CODE>[$<CODE>depth</CODE>] ) ) {
                $<CODE>dont_align</CODE>[$<CODE>depth</CODE>]         = 0;
                $<CODE>has_broken_sublist</CODE>[$<CODE>depth</CODE>] = 0;
                $<CODE>want_comma_break</CODE>[$<CODE>depth</CODE>]   = 0;
            }
        }
    }

    # <COMMENTS>routine</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>container</COMMENTS>;
    # <COMMENTS>returns</COMMENTS>:
    #   <COMMENTS>$bp_count</COMMENTS> = <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>set</COMMENTS>
    #   <COMMENTS>$do_not_break_apart</COMMENTS> = <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>indicating</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>not</COMMENTS>
    #     <COMMENTS>be</COMMENTS> <COMMENTS>broken</COMMENTS> <COMMENTS>open</COMMENTS>
    sub <CODE>set_comma_breakpoints</CODE> {

        my $<CODE>dd</CODE>                 = shift;
        my $<CODE>bp_count</CODE>           = 0;
        my $<CODE>do_not_break_apart</CODE> = 0;

        # <COMMENTS>anything</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS>?
        if ( $<CODE>item_count_stack</CODE>[$<CODE>dd</CODE>] ) {

            # <COMMENTS>handle</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>containers</COMMENTS>...
            if ( $<CODE>dont_align</CODE>[$<CODE>dd</CODE>] ) {
                <CODE>do_uncontained_comma_breaks</CODE>($<CODE>dd</CODE>);
            }

            # <COMMENTS>handle</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>containers</COMMENTS>...
            else {
                my $<CODE>fbc</CODE> = $<CODE>forced_breakpoint_count</CODE>;

                # <COMMENTS>always</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>lists</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>preceded</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>keywords</COMMENTS>,
                # <COMMENTS>barewords</COMMENTS>, <COMMENTS>identifiers</COMMENTS> (<COMMENTS>that</COMMENTS> <COMMENTS>is</COMMENTS>, <COMMENTS>anything</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS>
                # <COMMENTS>look</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>call</COMMENTS>)
                my $<CODE>must_break_open</CODE> = $<CODE>last_nonblank_type</CODE>[$<CODE>dd</CODE>] !~ /^[kwiU]$/;

                <CODE>set_comma_breakpoints_do</CODE>(
                    $<CODE>dd</CODE>,
                    $<CODE>opening_structure_index_stack</CODE>[$<CODE>dd</CODE>],
                    $<CODE>i</CODE>,
                    $<CODE>item_count_stack</CODE>[$<CODE>dd</CODE>],
                    $<CODE>identifier_count_stack</CODE>[$<CODE>dd</CODE>],
                    $<CODE>comma_index</CODE>[$<CODE>dd</CODE>],
                    $<CODE>next_nonblank_type</CODE>,
                    $<CODE>container_type</CODE>[$<CODE>dd</CODE>],
                    $<CODE>interrupted_list</CODE>[$<CODE>dd</CODE>],
                    \$<CODE>do_not_break_apart</CODE>,
                    $<CODE>must_break_open</CODE>,
                );
                $<CODE>bp_count</CODE> = $<CODE>forced_breakpoint_count</CODE> - $<CODE>fbc</CODE>;
                $<CODE>do_not_break_apart</CODE> = 0 if $<CODE>must_break_open</CODE>;
            }
        }
        return ( $<CODE>bp_count</CODE>, $<CODE>do_not_break_apart</CODE> );
    }

    sub <CODE>do_uncontained_comma_breaks</CODE> {

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>containers</COMMENTS>...
        # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>catch</COMMENTS>-<COMMENTS>all</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS>
        # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>fall</COMMENTS>
        # <COMMENTS>within</COMMENTS> <COMMENTS>containers</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>bias</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS>
        # <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>ended</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS>
        # <COMMENTS>file</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>works</COMMENTS> <COMMENTS>better</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>trying</COMMENTS>
        # <COMMENTS>to</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>possible</COMMENTS>.  <COMMENTS>A</COMMENTS>
        # <COMMENTS>downside</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>garbage</COMMENTS> <COMMENTS>it</COMMENTS>
        # <COMMENTS>won</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>well</COMMENTS>. <COMMENTS>However</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>always</COMMENTS>
        # <COMMENTS>prevent</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS>
        # -<COMMENTS>iob</COMMENTS> <COMMENTS>flag</COMMENTS>.
        my $<CODE>dd</CODE>                    = shift;
        my $<CODE>bias</CODE>                  = -.01;
        my $<CODE>old_comma_break_count</CODE> = 0;
        foreach my $<CODE>ii</CODE> ( @{ $<CODE>comma_index</CODE>[$<CODE>dd</CODE>] } ) {
            if ( $<CODE>old_breakpoint_to_go</CODE>[$<CODE>ii</CODE>] ) {
                $<CODE>old_comma_break_count</CODE>++;
                $<CODE>bond_strength_to_go</CODE>[$<CODE>ii</CODE>] = $<CODE>bias</CODE>;

                # <COMMENTS>reduce</COMMENTS> <COMMENTS>bias</COMMENTS> <COMMENTS>magnitude</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>order</COMMENTS>
                $<CODE>bias</CODE> *= 0.99;
            }
        }

        # <COMMENTS>Also</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>if</COMMENTS>
        # (<COMMENTS>1</COMMENTS>) <COMMENTS>there</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS>, <COMMENTS>and</COMMENTS>
        # (<COMMENTS>2</COMMENTS>) <COMMENTS>there</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>exactly</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>break</COMMENTS>
        # (<COMMENTS>3</COMMENTS>) <COMMENTS>OLD</COMMENTS>: <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>breaks</COMMENTS>
        # (<COMMENTS>3</COMMENTS>) <COMMENTS>NEW</COMMENTS>: <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>breaks</COMMENTS> (<COMMENTS>see</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>example</COMMENTS>)
        #
        # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS>
        # '<COMMENTS>print</COMMENTS>' <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>snippet</COMMENTS>:
        #    <COMMENTS>print</COMMENTS>
        #      "<COMMENTS>conformability</COMMENTS> (<COMMENTS>Not</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>dimension</COMMENTS>)\<COMMENTS>n</COMMENTS>",
        #      "\<COMMENTS>t</COMMENTS>", <COMMENTS>$have</COMMENTS>, " <COMMENTS>is</COMMENTS> ", <COMMENTS>text_unit</COMMENTS>(<COMMENTS>$hu</COMMENTS>), "\<COMMENTS>n</COMMENTS>",
        #      "\<COMMENTS>t</COMMENTS>", <COMMENTS>$want</COMMENTS>, " <COMMENTS>is</COMMENTS> ", <COMMENTS>text_unit</COMMENTS>(<COMMENTS>$wu</COMMENTS>), "\<COMMENTS>n</COMMENTS>",
        #      ;
        #
        # <COMMENTS>Another</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>just</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>comma</COMMENTS>, <COMMENTS>where</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>return</COMMENTS>:
        #  <COMMENTS>return</COMMENTS>
        #    <COMMENTS>$x</COMMENTS> * <COMMENTS>cos</COMMENTS>(<COMMENTS>$a</COMMENTS>) - <COMMENTS>$y</COMMENTS> * <COMMENTS>sin</COMMENTS>(<COMMENTS>$a</COMMENTS>),
        #    <COMMENTS>$x</COMMENTS> * <COMMENTS>sin</COMMENTS>(<COMMENTS>$a</COMMENTS>) + <COMMENTS>$y</COMMENTS> * <COMMENTS>cos</COMMENTS>(<COMMENTS>$a</COMMENTS>);

        # <COMMENTS>Breaking</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>print</COMMENTS> <COMMENTS>statement</COMMENTS>:
        # <COMMENTS>print</COMMENTS> <COMMENTS>SAVEOUT</COMMENTS>
        #   ( <COMMENTS>$</COMMENTS>? & <COMMENTS>127</COMMENTS> ) ? " (<COMMENTS>SIG</COMMENTS>#" . ( <COMMENTS>$</COMMENTS>? & <COMMENTS>127</COMMENTS> ) . ")" : "",
        #   ( <COMMENTS>$</COMMENTS>? & <COMMENTS>128</COMMENTS> ) ? " -- <COMMENTS>core</COMMENTS> <COMMENTS>dumped</COMMENTS>" : "", "\<COMMENTS>n</COMMENTS>";
        #
        #  <COMMENTS>But</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>here</COMMENTS>
        #  (<COMMENTS>causes</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blinker</COMMENTS>):
        #        <COMMENTS>$heap</COMMENTS>->{<COMMENTS>stream</COMMENTS>}-><COMMENTS>set_output_filter</COMMENTS>(
        #            <COMMENTS>poe</COMMENTS>::<COMMENTS>filter</COMMENTS>::<COMMENTS>reference</COMMENTS>-><COMMENTS>new</COMMENTS>('<COMMENTS>myotherfreezer</COMMENTS>') ),
        #          ;
        #
        my $<CODE>i_first_comma</CODE> = $<CODE>comma_index</CODE>[$<CODE>dd</CODE>]->[0];
        if ( $<CODE>old_breakpoint_to_go</CODE>[$<CODE>i_first_comma</CODE>] ) {
            my $<CODE>level_comma</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>i_first_comma</CODE>];
            my $<CODE>ibreak</CODE>      = -1;
            my $<CODE>obp_count</CODE>   = 0;
            for ( my $<CODE>ii</CODE> = $<CODE>i_first_comma</CODE> - 1 ; $<CODE>ii</CODE> >= 0 ; $<CODE>ii</CODE> -= 1 ) {
                if ( $<CODE>old_breakpoint_to_go</CODE>[$<CODE>ii</CODE>] ) {
                    $<CODE>obp_count</CODE>++;
                    last if ( $<CODE>obp_count</CODE> > 1 );
                    $<CODE>ibreak</CODE> = $<CODE>ii</CODE>
                      if ( $<CODE>levels_to_go</CODE>[$<CODE>ii</CODE>] == $<CODE>level_comma</CODE> );
                }
            }

            # <COMMENTS>Changed</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>here</COMMENTS>:
            if ( $<CODE>ibreak</CODE> >= 0 && $<CODE>obp_count</CODE> == 1 && $<CODE>old_comma_break_count</CODE> > 0 )
            {
                # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>because</COMMENTS>
                # <COMMENTS>it</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>lead</COMMENTS> <COMMENTS>to</COMMENTS> "<COMMENTS>blinkers</COMMENTS>".
                my $<CODE>ibreakm</CODE> = $<CODE>ibreak</CODE>;
                $<CODE>ibreakm</CODE>-- if ( $<CODE>types_to_go</CODE>[$<CODE>ibreakm</CODE>] eq '<LITERALS>b</LITERALS>' );
                if ( $<CODE>ibreakm</CODE> >= 0 && $<CODE>types_to_go</CODE>[$<CODE>ibreakm</CODE>] !~ /^[\(\{\[L]$/ )
                {
                    <CODE>set_forced_breakpoint</CODE>($<CODE>ibreak</CODE>);
                }
            }
        }
    }

    my %<CODE>is_logical_container</CODE>;

    <CODE>BEGIN</CODE> {
        @<CODE>_</CODE> = qw# <LITERALS>if</LITERALS> <LITERALS>elsif</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>while</LITERALS> <LITERALS>and</LITERALS> <LITERALS>or</LITERALS> <LITERALS>err</LITERALS> <LITERALS>not</LITERALS> && | || ? : ! #;
        @<CODE>is_logical_container</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);
    }

    sub <CODE>set_for_semicolon_breakpoints</CODE> {
        my $<CODE>dd</CODE> = shift;
        foreach ( @{ $<CODE>rfor_semicolon_list</CODE>[$<CODE>dd</CODE>] } ) {
            <CODE>set_forced_breakpoint</CODE>($<CODE>_</CODE>);
        }
    }

    sub <CODE>set_logical_breakpoints</CODE> {
        my $<CODE>dd</CODE> = shift;
        if (
               $<CODE>item_count_stack</CODE>[$<CODE>dd</CODE>] == 0
            && $<CODE>is_logical_container</CODE>{ $<CODE>container_type</CODE>[$<CODE>dd</CODE>] }

            || $<CODE>has_old_logical_breakpoints</CODE>[$<CODE>dd</CODE>]
          )
        {

            # <COMMENTS>Look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>order</COMMENTS>:
            # <COMMENTS>0</COMMENTS>   <COMMENTS>1</COMMENTS>    <COMMENTS>2</COMMENTS>   <COMMENTS>3</COMMENTS>
            # <COMMENTS>or</COMMENTS>  <COMMENTS>and</COMMENTS>  ||  &&
            foreach my $<CODE>i</CODE> ( 0 .. 3 ) {
                if ( $<CODE>rand_or_list</CODE>[$<CODE>dd</CODE>][$<CODE>i</CODE>] ) {
                    foreach ( @{ $<CODE>rand_or_list</CODE>[$<CODE>dd</CODE>][$<CODE>i</CODE>] } ) {
                        <CODE>set_forced_breakpoint</CODE>($<CODE>_</CODE>);
                    }

                    # <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>any</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>unless</COMMENTS>' <COMMENTS>too</COMMENTS>
                    foreach ( @{ $<CODE>rand_or_list</CODE>[$<CODE>dd</CODE>][4] } ) {
                        <CODE>set_forced_breakpoint</CODE>($<CODE>_</CODE>);
                    }
                    $<CODE>rand_or_list</CODE>[$<CODE>dd</CODE>] = [];
                    last;
                }
            }
        }
    }

    sub <CODE>is_unbreakable_container</CODE> {

        # <COMMENTS>never</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>types</COMMENTS>
        # <COMMENTS>because</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>happen</COMMENTS> (<COMMENTS>map1</COMMENTS>.<COMMENTS>t</COMMENTS>)
        my $<CODE>dd</CODE> = shift;
        $<CODE>is_sort_map_grep</CODE>{ $<CODE>container_type</CODE>[$<CODE>dd</CODE>] };
    }

    sub <CODE>scan_list</CODE> {

        # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>responsible</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>setting</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>lists</COMMENTS>,
        # <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>hierarchical</COMMENTS> <COMMENTS>structure</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>displayed</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>list</COMMENTS>
        # <COMMENTS>items</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>vertically</COMMENTS> <COMMENTS>aligned</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>is</COMMENTS>
        # <COMMENTS>stored</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>array</COMMENTS> @<COMMENTS>forced_breakpoint_to_go</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>set</COMMENTS>
        # <COMMENTS>final</COMMENTS> <COMMENTS>breakpoints</COMMENTS>.

        $<CODE>starting_depth</CODE> = $<CODE>nesting_depth_to_go</CODE>[0];

        $<CODE>block_type</CODE>                 = ' ';
        $<CODE>current_depth</CODE>              = $<CODE>starting_depth</CODE>;
        $<CODE>i</CODE>                          = -1;
        $<CODE>last_colon_sequence_number</CODE> = -1;
        $<CODE>last_nonblank_token</CODE>        = ';';
        $<CODE>last_nonblank_type</CODE>         = ';';
        $<CODE>last_nonblank_block_type</CODE>   = ' ';
        $<CODE>last_old_breakpoint_count</CODE>  = 0;
        $<CODE>minimum_depth</CODE> = $<CODE>current_depth</CODE> + 1;    # <COMMENTS>forces</COMMENTS> <COMMENTS>update</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>below</COMMENTS>
        $<CODE>old_breakpoint_count</CODE>      = 0;
        $<CODE>starting_breakpoint_count</CODE> = $<CODE>forced_breakpoint_count</CODE>;
        $<CODE>token</CODE>                     = ';';
        $<CODE>type</CODE>                      = ';';
        $<CODE>type_sequence</CODE>             = '';

        my $<CODE>total_depth_variation</CODE> = 0;
        my $<CODE>i_old_assignment_break</CODE>;
        my $<CODE>depth_last</CODE> = $<CODE>starting_depth</CODE>;

        <CODE>check_for_new_minimum_depth</CODE>($<CODE>current_depth</CODE>);

        my $<CODE>is_long_line</CODE> = <CODE>excess_line_length</CODE>( 0, $<CODE>max_index_to_go</CODE> ) > 0;
        my $<CODE>want_previous_breakpoint</CODE> = -1;

        my $<CODE>saw_good_breakpoint</CODE>;
        my $<CODE>i_line_end</CODE>   = -1;
        my $<CODE>i_line_start</CODE> = -1;

        # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
        while ( ++$<CODE>i</CODE> <= $<CODE>max_index_to_go</CODE> ) {
            if ( $<CODE>type</CODE> ne '<LITERALS>b</LITERALS>' ) {
                $<CODE>i_last_nonblank_token</CODE>    = $<CODE>i</CODE> - 1;
                $<CODE>last_nonblank_type</CODE>       = $<CODE>type</CODE>;
                $<CODE>last_nonblank_token</CODE>      = $<CODE>token</CODE>;
                $<CODE>last_nonblank_block_type</CODE> = $<CODE>block_type</CODE>;
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$type</COMMENTS> <COMMENTS>ne</COMMENTS> '<COMMENTS>b</COMMENTS>' )
            $<CODE>type</CODE>          = $<CODE>types_to_go</CODE>[$<CODE>i</CODE>];
            $<CODE>block_type</CODE>    = $<CODE>block_type_to_go</CODE>[$<CODE>i</CODE>];
            $<CODE>token</CODE>         = $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>];
            $<CODE>type_sequence</CODE> = $<CODE>type_sequence_to_go</CODE>[$<CODE>i</CODE>];
            my $<CODE>next_type</CODE>       = $<CODE>types_to_go</CODE>[ $<CODE>i</CODE> + 1 ];
            my $<CODE>next_token</CODE>      = $<CODE>tokens_to_go</CODE>[ $<CODE>i</CODE> + 1 ];
            my $<CODE>i_next_nonblank</CODE> = ( ( $<CODE>next_type</CODE> eq '<LITERALS>b</LITERALS>' ) ? $<CODE>i</CODE> + 2 : $<CODE>i</CODE> + 1 );
            $<CODE>next_nonblank_type</CODE>       = $<CODE>types_to_go</CODE>[$<CODE>i_next_nonblank</CODE>];
            $<CODE>next_nonblank_token</CODE>      = $<CODE>tokens_to_go</CODE>[$<CODE>i_next_nonblank</CODE>];
            $<CODE>next_nonblank_block_type</CODE> = $<CODE>block_type_to_go</CODE>[$<CODE>i_next_nonblank</CODE>];

            # <COMMENTS>set</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>set</COMMENTS>
            if ( $<CODE>want_previous_breakpoint</CODE> >= 0 ) {
                <CODE>set_forced_breakpoint</CODE>($<CODE>want_previous_breakpoint</CODE>);
                $<CODE>want_previous_breakpoint</CODE> = -1;
            }

            $<CODE>last_old_breakpoint_count</CODE> = $<CODE>old_breakpoint_count</CODE>;
            if ( $<CODE>old_breakpoint_to_go</CODE>[$<CODE>i</CODE>] ) {
                $<CODE>i_line_end</CODE>   = $<CODE>i</CODE>;
                $<CODE>i_line_start</CODE> = $<CODE>i_next_nonblank</CODE>;

                $<CODE>old_breakpoint_count</CODE>++;

                # <COMMENTS>Break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>broke</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>and</COMMENTS>
                # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>safe</COMMENTS>' <COMMENTS>break</COMMENTS> <COMMENTS>point</COMMENTS>. <COMMENTS>The</COMMENTS> <COMMENTS>idea</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>retain</COMMENTS>
                # <COMMENTS>any</COMMENTS> <COMMENTS>preferred</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>sequential</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>operations</COMMENTS>,
                # <COMMENTS>like</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>schwartzian</COMMENTS> <COMMENTS>transform</COMMENTS>.
                if ($<CODE>rOpts_break_at_old_keyword_breakpoints</CODE>) {
                    if (
                           $<CODE>next_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>'
                        && $<CODE>is_keyword_returning_list</CODE>{$<CODE>next_nonblank_token</CODE>}
                        && (   $<CODE>type</CODE> =~ /^[=\)\]\}Riw]$/
                            || $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>'
                            && $<CODE>is_keyword_returning_list</CODE>{$<CODE>token</CODE>} )
                      )
                    {

                        # <COMMENTS>we</COMMENTS> <COMMENTS>actually</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>time</COMMENTS> <COMMENTS>through</COMMENTS>
                        # <COMMENTS>the</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> (<COMMENTS>such</COMMENTS>
                        # <COMMENTS>as</COMMENTS> '}') <COMMENTS>which</COMMENTS> <COMMENTS>forms</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS>, <COMMENTS>this</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>might</COMMENTS>
                        # <COMMENTS>get</COMMENTS> <COMMENTS>undone</COMMENTS>.
                        $<CODE>want_previous_breakpoint</CODE> = $<CODE>i</CODE>;
                    } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$next_nonblank_type</COMMENTS>...)
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> (<COMMENTS>$rOpts_break_at_old_keyword_breakpoints</COMMENTS>)

                # <COMMENTS>Break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>attributes</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>broke</COMMENTS> <COMMENTS>there</COMMENTS>
                if ($<CODE>rOpts_break_at_old_attribute_breakpoints</CODE>) {
                    if ( $<CODE>next_nonblank_type</CODE> eq '<LITERALS>A</LITERALS>' ) {
                        $<CODE>want_previous_breakpoint</CODE> = $<CODE>i</CODE>;
                    }
                }

                # <COMMENTS>remember</COMMENTS> <COMMENTS>an</COMMENTS> = <COMMENTS>break</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>point</COMMENTS>
                if ( $<CODE>is_assignment</CODE>{$<CODE>type</CODE>} ) {
                    $<CODE>i_old_assignment_break</CODE> = $<CODE>i</CODE>;
                }
                elsif ( $<CODE>is_assignment</CODE>{$<CODE>next_nonblank_type</CODE>} ) {
                    $<CODE>i_old_assignment_break</CODE> = $<CODE>i_next_nonblank</CODE>;
                }
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$old_breakpoint_to_go</COMMENTS>...)
            next if ( $<CODE>type</CODE> eq '<LITERALS>b</LITERALS>' );
            $<CODE>depth</CODE> = $<CODE>nesting_depth_to_go</CODE>[ $<CODE>i</CODE> + 1 ];

            $<CODE>total_depth_variation</CODE> += abs( $<CODE>depth</CODE> - $<CODE>depth_last</CODE> );
            $<CODE>depth_last</CODE> = $<CODE>depth</CODE>;

            # <COMMENTS>safety</COMMENTS> <COMMENTS>check</COMMENTS> - <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comment</COMMENTS>
            # <COMMENTS>Shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS> .. <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>means</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>nobreak</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>did</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>turned</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>correctly</COMMENTS> <COMMENTS>during</COMMENTS>
            # <COMMENTS>formatting</COMMENTS>.
            if ( $<CODE>type</CODE> eq '#' ) {
                if ( $<CODE>i</CODE> != $<CODE>max_index_to_go</CODE> ) {
                    <CODE>warning</CODE>(
"<LITERALS>Non</LITERALS>-<LITERALS>fatal</LITERALS> <LITERALS>program</LITERALS> <LITERALS>bug</LITERALS>: <LITERALS>backup</LITERALS> <LITERALS>logic</LITERALS> <LITERALS>needed</LITERALS> <LITERALS>to</LITERALS> <LITERALS>break</LITERALS> <LITERALS>after</LITERALS> <LITERALS>a</LITERALS> <LITERALS>comment</LITERALS>\n"
                    );
                    <CODE>report_definite_bug</CODE>();
                    $<CODE>nobreak_to_go</CODE>[$<CODE>i</CODE>] = 0;
                    <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>);
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$i</COMMENTS> != <COMMENTS>$max_index_to_go</COMMENTS>)
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$type</COMMENTS> <COMMENTS>eq</COMMENTS> '#' )

            # <COMMENTS>Force</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>lines</COMMENTS>.
            # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>undone</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>tokens</COMMENTS>
            # <COMMENTS>are</COMMENTS> <COMMENTS>fully</COMMENTS> <COMMENTS>contained</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>.
            if (

                # <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>
                $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>'
                && $<CODE>i</CODE> > 0

                # <COMMENTS>if</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>keywords</COMMENTS>:
                && $<CODE>token</CODE> =~ /^(if|unless|while|until|for)$/

                # <COMMENTS>but</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> '<COMMENTS>1</COMMENTS> <COMMENTS>while</COMMENTS>'
                && ( $<CODE>last_nonblank_type</CODE> ne '<LITERALS>n</LITERALS>' || $<CODE>i</CODE> > 2 )

                # <COMMENTS>and</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> '<COMMENTS>do</COMMENTS>' <COMMENTS>brace</COMMENTS>
                && $<CODE>last_nonblank_block_type</CODE> ne '<LITERALS>do</LITERALS>'

                && (
                    $<CODE>is_long_line</CODE>

                    # <COMMENTS>or</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>broken</COMMENTS> (<COMMENTS>by</COMMENTS> <COMMENTS>side</COMMENTS>-<COMMENTS>comment</COMMENTS>, <COMMENTS>etc</COMMENTS>)
                    || (   $<CODE>next_nonblank_token</CODE> eq '('
                        && $<CODE>mate_index_to_go</CODE>[$<CODE>i_next_nonblank</CODE>] < $<CODE>i</CODE> )
                )
              )
            {
                <CODE>set_forced_breakpoint</CODE>( $<CODE>i</CODE> - 1 );
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$type</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>k</COMMENTS>' && <COMMENTS>$i</COMMENTS>...)

            # <COMMENTS>remember</COMMENTS> <COMMENTS>locations</COMMENTS> <COMMENTS>of</COMMENTS> '||'  <COMMENTS>and</COMMENTS> '&&' <COMMENTS>for</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS>
            # <COMMENTS>decide</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>expression</COMMENTS>.
            if ( $<CODE>type</CODE> eq '||' ) {
                push @{ $<CODE>rand_or_list</CODE>[$<CODE>depth</CODE>][2] }, $<CODE>i</CODE>;
                ++$<CODE>has_old_logical_breakpoints</CODE>[$<CODE>depth</CODE>]
                  if ( ( $<CODE>i</CODE> == $<CODE>i_line_start</CODE> || $<CODE>i</CODE> == $<CODE>i_line_end</CODE> )
                    && $<CODE>rOpts_break_at_old_logical_breakpoints</CODE> );
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$type</COMMENTS> <COMMENTS>eq</COMMENTS> '||' )
            elsif ( $<CODE>type</CODE> eq '&&' ) {
                push @{ $<CODE>rand_or_list</CODE>[$<CODE>depth</CODE>][3] }, $<CODE>i</CODE>;
                ++$<CODE>has_old_logical_breakpoints</CODE>[$<CODE>depth</CODE>]
                  if ( ( $<CODE>i</CODE> == $<CODE>i_line_start</CODE> || $<CODE>i</CODE> == $<CODE>i_line_end</CODE> )
                    && $<CODE>rOpts_break_at_old_logical_breakpoints</CODE> );
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>elsif</COMMENTS> ( <COMMENTS>$type</COMMENTS> <COMMENTS>eq</COMMENTS> '&&' )
            elsif ( $<CODE>type</CODE> eq '<LITERALS>f</LITERALS>' ) {
                push @{ $<CODE>rfor_semicolon_list</CODE>[$<CODE>depth</CODE>] }, $<CODE>i</CODE>;
            }
            elsif ( $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>' ) {
                if ( $<CODE>token</CODE> eq '<LITERALS>and</LITERALS>' ) {
                    push @{ $<CODE>rand_or_list</CODE>[$<CODE>depth</CODE>][1] }, $<CODE>i</CODE>;
                    ++$<CODE>has_old_logical_breakpoints</CODE>[$<CODE>depth</CODE>]
                      if ( ( $<CODE>i</CODE> == $<CODE>i_line_start</CODE> || $<CODE>i</CODE> == $<CODE>i_line_end</CODE> )
                        && $<CODE>rOpts_break_at_old_logical_breakpoints</CODE> );
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$token</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>and</COMMENTS>' )

                # <COMMENTS>break</COMMENTS> <COMMENTS>immediately</COMMENTS> <COMMENTS>at</COMMENTS> '<COMMENTS>or</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>logical</COMMENTS>
                # <COMMENTS>block</COMMENTS> -- <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS>
                # <COMMENTS>they</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>forced_breakpoint_count</COMMENTS>
                elsif ( $<CODE>token</CODE> eq '<LITERALS>or</LITERALS>' ) {
                    push @{ $<CODE>rand_or_list</CODE>[$<CODE>depth</CODE>][0] }, $<CODE>i</CODE>;
                    ++$<CODE>has_old_logical_breakpoints</CODE>[$<CODE>depth</CODE>]
                      if ( ( $<CODE>i</CODE> == $<CODE>i_line_start</CODE> || $<CODE>i</CODE> == $<CODE>i_line_end</CODE> )
                        && $<CODE>rOpts_break_at_old_logical_breakpoints</CODE> );
                    if ( $<CODE>is_logical_container</CODE>{ $<CODE>container_type</CODE>[$<CODE>depth</CODE>] } ) {
                    }
                    else {
                        if ($<CODE>is_long_line</CODE>) { <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>) }
                        elsif ( ( $<CODE>i</CODE> == $<CODE>i_line_start</CODE> || $<CODE>i</CODE> == $<CODE>i_line_end</CODE> )
                            && $<CODE>rOpts_break_at_old_logical_breakpoints</CODE> )
                        {
                            $<CODE>saw_good_breakpoint</CODE> = 1;
                        }
                    } ## <COMMENTS>end</COMMENTS> <COMMENTS>else</COMMENTS> [ <COMMENTS>if</COMMENTS> ( <COMMENTS>$is_logical_container</COMMENTS>...)]
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>elsif</COMMENTS> ( <COMMENTS>$token</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>or</COMMENTS>' )
                elsif ( $<CODE>token</CODE> eq '<LITERALS>if</LITERALS>' || $<CODE>token</CODE> eq '<LITERALS>unless</LITERALS>' ) {
                    push @{ $<CODE>rand_or_list</CODE>[$<CODE>depth</CODE>][4] }, $<CODE>i</CODE>;
                    if ( ( $<CODE>i</CODE> == $<CODE>i_line_start</CODE> || $<CODE>i</CODE> == $<CODE>i_line_end</CODE> )
                        && $<CODE>rOpts_break_at_old_logical_breakpoints</CODE> )
                    {
                        <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>);
                    }
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>elsif</COMMENTS> ( <COMMENTS>$token</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>if</COMMENTS>' ||...)
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>elsif</COMMENTS> ( <COMMENTS>$type</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>k</COMMENTS>' )
            elsif ( $<CODE>is_assignment</CODE>{$<CODE>type</CODE>} ) {
                $<CODE>i_equals</CODE>[$<CODE>depth</CODE>] = $<CODE>i</CODE>;
            }

            if ($<CODE>type_sequence</CODE>) {

                # <COMMENTS>handle</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>postponed</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>breakpoints</COMMENTS>
                if ( $<CODE>token</CODE> =~ /^[\)\]\}\:]$/ ) {
                    if ( $<CODE>type</CODE> eq ':' ) {
                        $<CODE>last_colon_sequence_number</CODE> = $<CODE>type_sequence</CODE>;

                        # <COMMENTS>retain</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> ':' <COMMENTS>line</COMMENTS> <COMMENTS>break</COMMENTS>
                        if ( ( $<CODE>i</CODE> == $<CODE>i_line_start</CODE> || $<CODE>i</CODE> == $<CODE>i_line_end</CODE> )
                            && $<CODE>rOpts_break_at_old_ternary_breakpoints</CODE> )
                        {

                            <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>);

                            # <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>previous</COMMENTS> '='
                            if ( $<CODE>i_equals</CODE>[$<CODE>depth</CODE>] > 0 ) {
                                <CODE>set_forced_breakpoint</CODE>( $<CODE>i_equals</CODE>[$<CODE>depth</CODE>] );
                                $<CODE>i_equals</CODE>[$<CODE>depth</CODE>] = -1;
                            }
                        } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( ( <COMMENTS>$i</COMMENTS> == <COMMENTS>$i_line_start</COMMENTS>...))
                    } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$type</COMMENTS> <COMMENTS>eq</COMMENTS> ':' )
                    if ( defined( $<CODE>postponed_breakpoint</CODE>{$<CODE>type_sequence</CODE>} ) ) {
                        my $<CODE>inc</CODE> = ( $<CODE>type</CODE> eq ':' ) ? 0 : 1;
                        <CODE>set_forced_breakpoint</CODE>( $<CODE>i</CODE> - $<CODE>inc</CODE> );
                        delete $<CODE>postponed_breakpoint</CODE>{$<CODE>type_sequence</CODE>};
                    }
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$token</COMMENTS> =~ /^[\)\]\}\:]<COMMENTS>$</COMMENTS>/[{[(])

                # <COMMENTS>set</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>at</COMMENTS> ?/: <COMMENTS>if</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>separated</COMMENTS> (<COMMENTS>and</COMMENTS> <COMMENTS>are</COMMENTS>
                # <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> ?/: <COMMENTS>chain</COMMENTS>), <COMMENTS>or</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> '?' <COMMENTS>is</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS>
                # <COMMENTS>line</COMMENTS>
                elsif ( $<CODE>token</CODE> eq '?' ) {
                    my $<CODE>i_colon</CODE> = $<CODE>mate_index_to_go</CODE>[$<CODE>i</CODE>];
                    if (
                        $<CODE>i_colon</CODE> <= 0  # <COMMENTS>the</COMMENTS> ':' <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
                        || $<CODE>i</CODE> == 0     # <COMMENTS>this</COMMENTS> '?' <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>
                        || $<CODE>i</CODE> ==
                        $<CODE>max_index_to_go</CODE>    # <COMMENTS>or</COMMENTS> <COMMENTS>this</COMMENTS> '?' <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS>
                      )
                    {

                        # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> '?' <COMMENTS>if</COMMENTS> <COMMENTS>preceded</COMMENTS> <COMMENTS>by</COMMENTS> ':' <COMMENTS>on</COMMENTS>
                        # <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>previous</COMMENTS> ?/: <COMMENTS>pair</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>.
                        # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>attempt</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>preserve</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>of</COMMENTS> ?/:
                        # <COMMENTS>expressions</COMMENTS> (<COMMENTS>elsif2</COMMENTS>.<COMMENTS>t</COMMENTS>).  <COMMENTS>And</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>if</COMMENTS>
                        # <COMMENTS>this</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>.
                        <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>)
                          unless (
                            $<CODE>type_sequence</CODE> == (
                                $<CODE>last_colon_sequence_number</CODE> +
                                  <CODE>TYPE_SEQUENCE_INCREMENT</CODE>
                            )
                            || $<CODE>tokens_to_go</CODE>[$<CODE>max_index_to_go</CODE>] eq '#'
                          );
                        <CODE>set_closing_breakpoint</CODE>($<CODE>i</CODE>);
                    } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$i_colon</COMMENTS> <= <COMMENTS>0</COMMENTS>  ||...)
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>elsif</COMMENTS> ( <COMMENTS>$token</COMMENTS> <COMMENTS>eq</COMMENTS> '?' )
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> (<COMMENTS>$type_sequence</COMMENTS>)

#<COMMENTS>print</COMMENTS> "<COMMENTS>LISTX</COMMENTS> <COMMENTS>sees</COMMENTS>: <COMMENTS>i</COMMENTS>=<COMMENTS>$i</COMMENTS> <COMMENTS>type</COMMENTS>=<COMMENTS>$type</COMMENTS>  <COMMENTS>tok</COMMENTS>=<COMMENTS>$token</COMMENTS>  <COMMENTS>block</COMMENTS>=<COMMENTS>$block_type</COMMENTS> <COMMENTS>depth</COMMENTS>=<COMMENTS>$depth</COMMENTS>\<COMMENTS>n</COMMENTS>";

            #------------------------------------------------------------
            # <COMMENTS>Handle</COMMENTS> <COMMENTS>Increasing</COMMENTS> <COMMENTS>Depth</COMMENTS>..
            #
            # <COMMENTS>prepare</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>increases</COMMENTS>
            # <COMMENTS>token</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> '(','{', <COMMENTS>or</COMMENTS> '['
            #------------------------------------------------------------
            if ( $<CODE>depth</CODE> > $<CODE>current_depth</CODE> ) {

                $<CODE>breakpoint_stack</CODE>[$<CODE>depth</CODE>]       = $<CODE>forced_breakpoint_count</CODE>;
                $<CODE>breakpoint_undo_stack</CODE>[$<CODE>depth</CODE>]  = $<CODE>forced_breakpoint_undo_count</CODE>;
                $<CODE>has_broken_sublist</CODE>[$<CODE>depth</CODE>]     = 0;
                $<CODE>identifier_count_stack</CODE>[$<CODE>depth</CODE>] = 0;
                $<CODE>index_before_arrow</CODE>[$<CODE>depth</CODE>]     = -1;
                $<CODE>interrupted_list</CODE>[$<CODE>depth</CODE>]       = 0;
                $<CODE>item_count_stack</CODE>[$<CODE>depth</CODE>]       = 0;
                $<CODE>last_comma_index</CODE>[$<CODE>depth</CODE>]       = undef;
                $<CODE>last_dot_index</CODE>[$<CODE>depth</CODE>]         = undef;
                $<CODE>last_nonblank_type</CODE>[$<CODE>depth</CODE>]     = $<CODE>last_nonblank_type</CODE>;
                $<CODE>old_breakpoint_count_stack</CODE>[$<CODE>depth</CODE>]    = $<CODE>old_breakpoint_count</CODE>;
                $<CODE>opening_structure_index_stack</CODE>[$<CODE>depth</CODE>] = $<CODE>i</CODE>;
                $<CODE>rand_or_list</CODE>[$<CODE>depth</CODE>]                  = [];
                $<CODE>rfor_semicolon_list</CODE>[$<CODE>depth</CODE>]           = [];
                $<CODE>i_equals</CODE>[$<CODE>depth</CODE>]                      = -1;
                $<CODE>want_comma_break</CODE>[$<CODE>depth</CODE>]              = 0;
                $<CODE>container_type</CODE>[$<CODE>depth</CODE>] =
                  ( $<CODE>last_nonblank_type</CODE> =~ /^(k|=>|&&|\|\||\?|\:|\.)$/ )
                  ? $<CODE>last_nonblank_token</CODE>
                  : "";
                $<CODE>has_old_logical_breakpoints</CODE>[$<CODE>depth</CODE>] = 0;

                # <COMMENTS>if</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>signal</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS>
                if ( $<CODE>next_nonblank_type</CODE> eq '<LITERALS>b</LITERALS>' || $<CODE>next_nonblank_type</CODE> eq '#' )
                {
                    <CODE>set_closing_breakpoint</CODE>($<CODE>i</CODE>);
                }

                # <COMMENTS>Not</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>lists</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>vertically</COMMENTS> <COMMENTS>aligned</COMMENTS>..
                $<CODE>dont_align</CODE>[$<CODE>depth</CODE>] =

                  # <COMMENTS>code</COMMENTS> <COMMENTS>BLOCKS</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>higher</COMMENTS> <COMMENTS>level</COMMENTS>
                  ( $<CODE>block_type</CODE> ne "" )

                  # <COMMENTS>certain</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>lists</COMMENTS>
                  || ( $<CODE>type</CODE> eq '(' ) && (

                    # <COMMENTS>it</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS>
                    # <COMMENTS>identifiers</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>parameter</COMMENTS> <COMMENTS>list</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS>:
                    #    <COMMENTS>my</COMMENTS>(<COMMENTS>$var1</COMMENTS>, <COMMENTS>$var2</COMMENTS>, ...)
                    # (<COMMENTS>This</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>refined</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>now</COMMENTS> <COMMENTS>I</COMMENTS>'<COMMENTS>m</COMMENTS> <COMMENTS>just</COMMENTS>
                    # <COMMENTS>testing</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>keyword</COMMENTS>)
                    ( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>' )

                    # <COMMENTS>a</COMMENTS> <COMMENTS>trailing</COMMENTS> '(' <COMMENTS>usually</COMMENTS> <COMMENTS>indicates</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>list</COMMENTS>
                    || ( $<CODE>next_nonblank_type</CODE> eq '(' )
                  );

                # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>outdent</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>if</COMMENTS>/<COMMENTS>for</COMMENTS>/..
                # <COMMENTS>statements</COMMENTS> (<COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>one</COMMENTS>).  <COMMENTS>See</COMMENTS> <COMMENTS>similar</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>in</COMMENTS>
                # <COMMENTS>set_continuation</COMMENTS> <COMMENTS>breaks</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>catch</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>for</COMMENTS>
                # <COMMENTS>short</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>fragments</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>otherwise</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>through</COMMENTS>
                # <COMMENTS>set_continuation_breaks</COMMENTS>.
                if (
                    $<CODE>block_type</CODE>

                    # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>the</COMMENTS> ')' <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>its</COMMENTS> '(' <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>..
                    && ( $<CODE>last_nonblank_token</CODE> eq ')' )
                    && $<CODE>mate_index_to_go</CODE>[$<CODE>i_last_nonblank_token</CODE>] < 0

                    # <COMMENTS>and</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>wants</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>left</COMMENTS>
                    && !$<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>always</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>right</LITERALS>'}

                    && ( $<CODE>type</CODE> eq '{' )     # <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>true</COMMENTS>
                    && ( $<CODE>token</CODE> eq '{' )    # <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>true</COMMENTS>
                  )
                {
                    <CODE>set_forced_breakpoint</CODE>( $<CODE>i</CODE> - 1 );
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$block_type</COMMENTS> && ( ...))
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$depth</COMMENTS> > <COMMENTS>$current_depth</COMMENTS>)

            #------------------------------------------------------------
            # <COMMENTS>Handle</COMMENTS> <COMMENTS>Decreasing</COMMENTS> <COMMENTS>Depth</COMMENTS>..
            #
            # <COMMENTS>finish</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>decreases</COMMENTS>
            # <COMMENTS>token</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> ')','}', <COMMENTS>or</COMMENTS> ']'
            #------------------------------------------------------------
            elsif ( $<CODE>depth</CODE> < $<CODE>current_depth</CODE> ) {

                <CODE>check_for_new_minimum_depth</CODE>($<CODE>depth</CODE>);

                # <COMMENTS>force</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>outer</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>containers</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>on</COMMENTS>
                # <COMMENTS>old</COMMENTS> <COMMENTS>breakpoint</COMMENTS>
                $<CODE>has_old_logical_breakpoints</CODE>[$<CODE>depth</CODE>] ||=
                  $<CODE>has_old_logical_breakpoints</CODE>[$<CODE>current_depth</CODE>];

                # <COMMENTS>Patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>between</COMMENTS> ') {' <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>broken</COMMENTS>.
                # <COMMENTS>There</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>similar</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>set_continuation_breaks</COMMENTS> <COMMENTS>for</COMMENTS>
                # <COMMENTS>non</COMMENTS>-<COMMENTS>broken</COMMENTS> <COMMENTS>lists</COMMENTS>.
                if (   $<CODE>token</CODE> eq ')'
                    && $<CODE>next_nonblank_block_type</CODE>
                    && $<CODE>interrupted_list</CODE>[$<CODE>current_depth</CODE>]
                    && $<CODE>next_nonblank_type</CODE> eq '{'
                    && !$<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>always</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>right</LITERALS>'} )
                {
                    <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>);
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$token</COMMENTS> <COMMENTS>eq</COMMENTS> ')' && ...

#<COMMENTS>print</COMMENTS> "<COMMENTS>LISTY</COMMENTS> <COMMENTS>sees</COMMENTS>: <COMMENTS>i</COMMENTS>=<COMMENTS>$i</COMMENTS> <COMMENTS>type</COMMENTS>=<COMMENTS>$type</COMMENTS>  <COMMENTS>tok</COMMENTS>=<COMMENTS>$token</COMMENTS>  <COMMENTS>block</COMMENTS>=<COMMENTS>$block_type</COMMENTS> <COMMENTS>depth</COMMENTS>=<COMMENTS>$depth</COMMENTS> <COMMENTS>next</COMMENTS>=<COMMENTS>$next_nonblank_type</COMMENTS> <COMMENTS>next_block</COMMENTS>=<COMMENTS>$next_nonblank_block_type</COMMENTS> <COMMENTS>inter</COMMENTS>=<COMMENTS>$interrupted_list</COMMENTS>[<COMMENTS>$current_depth</COMMENTS>]\<COMMENTS>n</COMMENTS>";

                # <COMMENTS>set</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
                my ( $<CODE>bp_count</CODE>, $<CODE>do_not_break_apart</CODE> ) =
                  <CODE>set_comma_breakpoints</CODE>($<CODE>current_depth</CODE>);

                my $<CODE>i_opening</CODE> = $<CODE>opening_structure_index_stack</CODE>[$<CODE>current_depth</CODE>];
                my $<CODE>saw_opening_structure</CODE> = ( $<CODE>i_opening</CODE> >= 0 );

                # <COMMENTS>this</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>had</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>interior</COMMENTS> <COMMENTS>commas</COMMENTS>..
                my $<CODE>is_long_term</CODE> = $<CODE>bp_count</CODE> > 0;

                # <COMMENTS>If</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>arrows</COMMENTS>,
                # <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>mark</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS>.
                # <COMMENTS>$rOpts_comma_arrow_breakpoints</COMMENTS> =
                #    <COMMENTS>0</COMMENTS> - <COMMENTS>open</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>precedes</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>brace</COMMENTS>
                #    <COMMENTS>1</COMMENTS> - <COMMENTS>stable</COMMENTS>: <COMMENTS>except</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS>
                #    <COMMENTS>2</COMMENTS> - <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>form</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS>
                #    <COMMENTS>3</COMMENTS> - <COMMENTS>ignore</COMMENTS> =>
                #    <COMMENTS>4</COMMENTS> - <COMMENTS>always</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>vt</COMMENTS>=<COMMENTS>0</COMMENTS>
                #    <COMMENTS>5</COMMENTS> - <COMMENTS>stable</COMMENTS>: <COMMENTS>even</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>vt</COMMENTS>=<COMMENTS>0</COMMENTS>
                if (  !$<CODE>is_long_term</CODE>
                    && $<CODE>tokens_to_go</CODE>[$<CODE>i_opening</CODE>] =~ /^[\(\{\[]$/
                    && $<CODE>index_before_arrow</CODE>[ $<CODE>depth</CODE> + 1 ] > 0
                    && !$<CODE>opening_vertical_tightness</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>i_opening</CODE>] }
                  )
                {
                    $<CODE>is_long_term</CODE> = $<CODE>rOpts_comma_arrow_breakpoints</CODE> == 4
                      || ( $<CODE>rOpts_comma_arrow_breakpoints</CODE> == 0
                        && $<CODE>last_nonblank_token</CODE> eq ',' )
                      || ( $<CODE>rOpts_comma_arrow_breakpoints</CODE> == 5
                        && $<CODE>old_breakpoint_to_go</CODE>[$<CODE>i_opening</CODE>] );
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( !<COMMENTS>$is_long_term</COMMENTS> &&...)

                # <COMMENTS>mark</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS>
                # <COMMENTS>parens</COMMENTS> <COMMENTS>exceeds</COMMENTS> <COMMENTS>allowed</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>
                if ( !$<CODE>is_long_term</CODE> && $<CODE>saw_opening_structure</CODE> ) {
                    my $<CODE>i_opening_minus</CODE> = <CODE>find_token_starting_list</CODE>($<CODE>i_opening</CODE>);

                    # <COMMENTS>Note</COMMENTS>: <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS>
                    # <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>strand</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>or</COMMENTS>
                    # <COMMENTS>semicolon</COMMENTS>, <COMMENTS>hence</COMMENTS> <COMMENTS>the</COMMENTS> '>=' <COMMENTS>here</COMMENTS> (<COMMENTS>oneline</COMMENTS>.<COMMENTS>t</COMMENTS>)
                    $<CODE>is_long_term</CODE> =
                      <CODE>excess_line_length</CODE>( $<CODE>i_opening_minus</CODE>, $<CODE>i</CODE> ) >= 0;
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( !<COMMENTS>$is_long_term</COMMENTS> &&...)

                # <COMMENTS>We</COMMENTS>'<COMMENTS>ve</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>comma</COMMENTS>-<COMMENTS>arrows</COMMENTS>.  <COMMENTS>Now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS>
                # <COMMENTS>undo</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS>
                # (<COMMENTS>the</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>due</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>comma</COMMENTS>-<COMMENTS>arrows</COMMENTS>)
                if (

                    # <COMMENTS>user</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>require</COMMENTS> <COMMENTS>breaking</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>comma</COMMENTS>-<COMMENTS>arrows</COMMENTS>
                    ( $<CODE>rOpts_comma_arrow_breakpoints</CODE> != 0 )
                    && ( $<CODE>rOpts_comma_arrow_breakpoints</CODE> != 4 )

                    # <COMMENTS>and</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>structure</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
                    && $<CODE>saw_opening_structure</CODE>

                    # <COMMENTS>and</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>line</COMMENTS>
                    && (
                        $<CODE>old_breakpoint_count_stack</CODE>[$<CODE>current_depth</CODE>] ==
                        $<CODE>last_old_breakpoint_count</CODE>

                        # <COMMENTS>or</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>wants</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>form</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>arrows</COMMENTS>
                        || $<CODE>rOpts_comma_arrow_breakpoints</CODE> == 2
                    )

                  # <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>made</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS>
                    && ( $<CODE>breakpoint_undo_stack</CODE>[$<CODE>current_depth</CODE>] <
                        $<CODE>forced_breakpoint_undo_count</CODE> )

                    # <COMMENTS>and</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>enough</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>fit</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS>
                    # <COMMENTS>Note</COMMENTS>: <COMMENTS>use</COMMENTS> < <COMMENTS>because</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>comma</COMMENTS>
                    && !$<CODE>is_long_term</CODE>

                  )
                {
                    <CODE>undo_forced_breakpoint_stack</CODE>(
                        $<CODE>breakpoint_undo_stack</CODE>[$<CODE>current_depth</CODE>] );
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( ( <COMMENTS>$rOpts_comma_arrow_breakpoints</COMMENTS>...))

                # <COMMENTS>now</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>left</COMMENTS>
                my $<CODE>has_comma_breakpoints</CODE> =
                  ( $<CODE>breakpoint_stack</CODE>[$<CODE>current_depth</CODE>] !=
                      $<CODE>forced_breakpoint_count</CODE> );

                # <COMMENTS>update</COMMENTS> <COMMENTS>broken</COMMENTS>-<COMMENTS>sublist</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>outer</COMMENTS> <COMMENTS>container</COMMENTS>
                $<CODE>has_broken_sublist</CODE>[$<CODE>depth</CODE>] =
                     $<CODE>has_broken_sublist</CODE>[$<CODE>depth</CODE>]
                  || $<CODE>has_broken_sublist</CODE>[$<CODE>current_depth</CODE>]
                  || $<CODE>is_long_term</CODE>
                  || $<CODE>has_comma_breakpoints</CODE>;

# <COMMENTS>Having</COMMENTS> <COMMENTS>come</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> ')', '}', <COMMENTS>or</COMMENTS> ']', <COMMENTS>now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS>
# <COMMENTS>should</COMMENTS> '<COMMENTS>open</COMMENTS> <COMMENTS>up</COMMENTS>' <COMMENTS>the</COMMENTS> <COMMENTS>structure</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>placing</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS>
# <COMMENTS>closing</COMMENTS> <COMMENTS>containers</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>tricky</COMMENTS> <COMMENTS>decision</COMMENTS>.  <COMMENTS>Here</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS>
# <COMMENTS>basic</COMMENTS> <COMMENTS>considerations</COMMENTS>:
#
# -<COMMENTS>If</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>BLOCK</COMMENTS> <COMMENTS>container</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>already</COMMENTS>
# <COMMENTS>been</COMMENTS> <COMMENTS>set</COMMENTS> (<COMMENTS>and</COMMENTS> <COMMENTS>according</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>preferences</COMMENTS>), <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>nothing</COMMENTS> <COMMENTS>here</COMMENTS>.
#
# -<COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>-<COMMENTS>separated</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>items</COMMENTS>,
# <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>otherwise</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>aligner</COMMENTS> <COMMENTS>cannot</COMMENTS>
# <COMMENTS>currently</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>alignment</COMMENTS>.
#
# -<COMMENTS>If</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>itself</COMMENTS> <COMMENTS>contain</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>broken</COMMENTS>
# <COMMENTS>open</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>broken</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>properly</COMMENTS> <COMMENTS>show</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>structure</COMMENTS>.
#
# -<COMMENTS>If</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>nothing</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>reason</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>apart</COMMENTS>,
# <COMMENTS>then</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>it</COMMENTS>.
#
# <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>but</COMMENTS> '<COMMENTS>simple</COMMENTS>' <COMMENTS>logical</COMMENTS> <COMMENTS>expression</COMMENTS>.
# <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>:
#
# <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>expression</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>formatting</COMMENTS>:
#
#     <COMMENTS>if</COMMENTS> ( <COMMENTS>$bigwasteofspace1</COMMENTS> && <COMMENTS>$bigwasteofspace2</COMMENTS>
#         || <COMMENTS>$bigwasteofspace3</COMMENTS> && <COMMENTS>$bigwasteofspace4</COMMENTS> )
#
# <COMMENTS>Most</COMMENTS> <COMMENTS>people</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>prefer</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>spacey</COMMENTS>' <COMMENTS>version</COMMENTS>:
#
#     <COMMENTS>if</COMMENTS> (
#         <COMMENTS>$bigwasteofspace1</COMMENTS> && <COMMENTS>$bigwasteofspace2</COMMENTS>
#         || <COMMENTS>$bigwasteofspace3</COMMENTS> && <COMMENTS>$bigwasteofspace4</COMMENTS>
#     )
#
# <COMMENTS>To</COMMENTS> <COMMENTS>illustrate</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>breaking</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>expressions</COMMENTS>, <COMMENTS>consider</COMMENTS>:
#
#             <COMMENTS>FULLY</COMMENTS> <COMMENTS>DENSE</COMMENTS>:
#             <COMMENTS>if</COMMENTS> ( <COMMENTS>$opt_excl</COMMENTS>
#                 <COMMENTS>and</COMMENTS> ( <COMMENTS>exists</COMMENTS> <COMMENTS>$ids_excl_uc</COMMENTS>{<COMMENTS>$id_uc</COMMENTS>}
#                     <COMMENTS>or</COMMENTS> <COMMENTS>grep</COMMENTS> <COMMENTS>$id_uc</COMMENTS> =~ /<COMMENTS>$_</COMMENTS>/, @<COMMENTS>ids_excl_uc</COMMENTS> ))
#
# <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>verge</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>difficult</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>read</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS>
# <COMMENTS>open</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
#
#             <COMMENTS>DEFAULT</COMMENTS>:
#             <COMMENTS>if</COMMENTS> (
#                 <COMMENTS>$opt_excl</COMMENTS>
#                 <COMMENTS>and</COMMENTS> ( <COMMENTS>exists</COMMENTS> <COMMENTS>$ids_excl_uc</COMMENTS>{<COMMENTS>$id_uc</COMMENTS>}
#                     <COMMENTS>or</COMMENTS> <COMMENTS>grep</COMMENTS> <COMMENTS>$id_uc</COMMENTS> =~ /<COMMENTS>$_</COMMENTS>/, @<COMMENTS>ids_excl_uc</COMMENTS> )
#               )
#
# <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>compromise</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>tries</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>dense</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>spacey</COMMENTS>.
# <COMMENTS>A</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>spaced</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS>:
#
#             <COMMENTS>SPACEY</COMMENTS>:
#             <COMMENTS>if</COMMENTS> (
#                 <COMMENTS>$opt_excl</COMMENTS>
#                 <COMMENTS>and</COMMENTS> (
#                     <COMMENTS>exists</COMMENTS> <COMMENTS>$ids_excl_uc</COMMENTS>{<COMMENTS>$id_uc</COMMENTS>}
#                     <COMMENTS>or</COMMENTS> <COMMENTS>grep</COMMENTS> <COMMENTS>$id_uc</COMMENTS> =~ /<COMMENTS>$_</COMMENTS>/, @<COMMENTS>ids_excl_uc</COMMENTS>
#                 )
#               )
#
# <COMMENTS>Some</COMMENTS> <COMMENTS>people</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>prefer</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>spacey</COMMENTS> <COMMENTS>version</COMMENTS> -- <COMMENTS>an</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>added</COMMENTS>.  <COMMENTS>The</COMMENTS>
# <COMMENTS>innermost</COMMENTS> <COMMENTS>expression</COMMENTS> <COMMENTS>contains</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>block</COMMENTS> '( <COMMENTS>exists</COMMENTS> <COMMENTS>$ids_</COMMENTS>...  ')'.
#
# <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>goes</COMMENTS>: <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>or</COMMENTS>' <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS>
# <COMMENTS>innermost</COMMENTS> <COMMENTS>expression</COMMENTS> <COMMENTS>contains</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>apart</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS>
# <COMMENTS>closing</COMMENTS> <COMMENTS>containers</COMMENTS> <COMMENTS>because</COMMENTS> (<COMMENTS>1</COMMENTS>) <COMMENTS>it</COMMENTS> <COMMENTS>contains</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>multi</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>sub</COMMENTS>-<COMMENTS>containers</COMMENTS> <COMMENTS>itself</COMMENTS>,
# <COMMENTS>and</COMMENTS> (<COMMENTS>2</COMMENTS>) <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>gained</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>breaking</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>
#
#             <COMMENTS>and</COMMENTS> (
#                 <COMMENTS>exists</COMMENTS> <COMMENTS>$ids_excl_uc</COMMENTS>{<COMMENTS>$id_uc</COMMENTS>}
#                 <COMMENTS>or</COMMENTS> <COMMENTS>grep</COMMENTS> <COMMENTS>$id_uc</COMMENTS> =~ /<COMMENTS>$_</COMMENTS>/, @<COMMENTS>ids_excl_uc</COMMENTS>
#             )
#
# (<COMMENTS>although</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>perfectly</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>expressions</COMMENTS>).  <COMMENTS>The</COMMENTS>
# <COMMENTS>outer</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>container</COMMENTS>, <COMMENTS>though</COMMENTS>, <COMMENTS>contains</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>broken</COMMENTS> <COMMENTS>sub</COMMENTS>-<COMMENTS>container</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS>
# <COMMENTS>broken</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>much</COMMENTS> <COMMENTS>density</COMMENTS>.  <COMMENTS>Also</COMMENTS>, <COMMENTS>since</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>contains</COMMENTS> <COMMENTS>no</COMMENTS> '<COMMENTS>or</COMMENTS>'<COMMENTS>s</COMMENTS>, <COMMENTS>there</COMMENTS>
# <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>forced</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>its</COMMENTS> '<COMMENTS>and</COMMENTS>'.

                # <COMMENTS>set</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>telling</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>about</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>container</COMMENTS>..
                my $<CODE>is_simple_logical_expression</CODE> = 0;
                if (   $<CODE>item_count_stack</CODE>[$<CODE>current_depth</CODE>] == 0
                    && $<CODE>saw_opening_structure</CODE>
                    && $<CODE>tokens_to_go</CODE>[$<CODE>i_opening</CODE>] eq '('
                    && $<CODE>is_logical_container</CODE>{ $<CODE>container_type</CODE>[$<CODE>current_depth</CODE>] }
                  )
                {

                    # <COMMENTS>This</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>expression</COMMENTS> <COMMENTS>with</COMMENTS>
                    # <COMMENTS>no</COMMENTS> <COMMENTS>existing</COMMENTS> <COMMENTS>breakpoints</COMMENTS>.  <COMMENTS>Set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prevent</COMMENTS>
                    # <COMMENTS>opening</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>up</COMMENTS>.
                    if ( !$<CODE>has_comma_breakpoints</CODE> ) {
                        $<CODE>is_simple_logical_expression</CODE> = 1;
                    }

                    # <COMMENTS>This</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>expression</COMMENTS> <COMMENTS>with</COMMENTS>
                    # <COMMENTS>breakpoints</COMMENTS> (<COMMENTS>broken</COMMENTS> <COMMENTS>sublists</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>).  <COMMENTS>Break</COMMENTS>
                    # <COMMENTS>at</COMMENTS> <COMMENTS>all</COMMENTS> '<COMMENTS>or</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>and</COMMENTS> '||'<COMMENTS>s</COMMENTS>.
                    else {
                        <CODE>set_logical_breakpoints</CODE>($<CODE>current_depth</CODE>);
                    }
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$item_count_stack</COMMENTS>...)

                if ( $<CODE>is_long_term</CODE>
                    && @{ $<CODE>rfor_semicolon_list</CODE>[$<CODE>current_depth</CODE>] } )
                {
                    <CODE>set_for_semicolon_breakpoints</CODE>($<CODE>current_depth</CODE>);

                    # <COMMENTS>open</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> '<COMMENTS>for</COMMENTS>' <COMMENTS>or</COMMENTS> '<COMMENTS>foreach</COMMENTS>' <COMMENTS>container</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS>
                    # <COMMENTS>leading</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>unless</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>.
                    $<CODE>has_comma_breakpoints</CODE> = 1
                      unless $<CODE>rOpts_line_up_parentheses</CODE>;
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$is_long_term</COMMENTS> && ...)

                if (

                    # <COMMENTS>breaks</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>BLOCKS</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>higher</COMMENTS> <COMMENTS>level</COMMENTS>
                    !$<CODE>block_type</CODE>

                    # <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>top</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> '<COMMENTS>if</COMMENTS>'
                    # <COMMENTS>type</COMMENTS> <COMMENTS>expression</COMMENTS>
                    && !$<CODE>is_simple_logical_expression</CODE>

                    ## <COMMENTS>modification</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> ': (' <COMMENTS>containers</COMMENTS> <COMMENTS>vertically</COMMENTS> <COMMENTS>tight</COMMENTS>;
                    ## <COMMENTS>but</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>better</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>set</COMMENTS> -<COMMENTS>vt</COMMENTS>=<COMMENTS>1</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS>
                    ## <COMMENTS>inconsistency</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>types</COMMENTS>
                    ## && (<COMMENTS>$container_type</COMMENTS>[<COMMENTS>$current_depth</COMMENTS>] <COMMENTS>ne</COMMENTS> ':')

                    # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>require</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>reasons</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>breaking</COMMENTS>:
                    && (

                        # - <COMMENTS>this</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>forced</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>breaks</COMMENTS>
                        $<CODE>has_comma_breakpoints</CODE>

                       # - <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>separated</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
                       #   <COMMENTS>for</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>reason</COMMENTS> (<COMMENTS>comment</COMMENTS>, <COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>)
                       # - <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>paren</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>spanning</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>lines</COMMENTS>
                        || !$<CODE>saw_opening_structure</CODE>

                        # - <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>contained</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>breakable</COMMENTS>
                        #   <COMMENTS>container</COMMENTS>
                        || (   $<CODE>is_long_term</CODE>
                            && $<CODE>container_environment_to_go</CODE>[$<CODE>i_opening</CODE>] ne
                            '<LITERALS>BLOCK</LITERALS>' )
                    )
                  )
                {

                    # <COMMENTS>For</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>option</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>breakpoint</COMMENTS> <COMMENTS>before</COMMENTS>
                    # <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>identified</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>starting</COMMENTS>
                    # <COMMENTS>this</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>for</COMMENTS>
                    # <COMMENTS>proper</COMMENTS> <COMMENTS>alignment</COMMENTS>.
                    if ( $<CODE>rOpts_line_up_parentheses</CODE> && $<CODE>saw_opening_structure</CODE> )
                    {
                        my $<CODE>item</CODE> = $<CODE>leading_spaces_to_go</CODE>[ $<CODE>i_opening</CODE> + 1 ];
                        if (   $<CODE>i_opening</CODE> + 1 < $<CODE>max_index_to_go</CODE>
                            && $<CODE>types_to_go</CODE>[ $<CODE>i_opening</CODE> + 1 ] eq '<LITERALS>b</LITERALS>' )
                        {
                            $<CODE>item</CODE> = $<CODE>leading_spaces_to_go</CODE>[ $<CODE>i_opening</CODE> + 2 ];
                        }
                        if ( defined($<CODE>item</CODE>) ) {
                            my $<CODE>i_start_2</CODE> = $<CODE>item</CODE>-><CODE>get_STARTING_INDEX</CODE>();
                            if (
                                defined($<CODE>i_start_2</CODE>)

                                # <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>breaking</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS>, <COMMENTS>paren</COMMENTS>,
                                # <COMMENTS>so</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>too</COMMENTS>
                                && $<CODE>i_start_2</CODE> ne $<CODE>i_opening</CODE>
                              )
                            {

                                # <COMMENTS>Only</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS>
                                # <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS>
                                my $<CODE>test1</CODE> = $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_opening</CODE>];
                                my $<CODE>test2</CODE> = $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_start_2</CODE>];
                                if ( $<CODE>test2</CODE> == $<CODE>test1</CODE> ) {
                                    <CODE>set_forced_breakpoint</CODE>( $<CODE>i_start_2</CODE> - 1 );
                                }
                            } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>defined</COMMENTS>(<COMMENTS>$i_start_2</COMMENTS>...))
                        } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>defined</COMMENTS>(<COMMENTS>$item</COMMENTS>) )
                    } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$rOpts_line_up_parentheses</COMMENTS>...)

                    # <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>structure</COMMENTS>.
                    # <COMMENTS>note</COMMENTS>: <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>structure</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>automatic</COMMENTS>
                    if ( $<CODE>minimum_depth</CODE> <= $<CODE>current_depth</CODE> ) {

                        <CODE>set_forced_breakpoint</CODE>($<CODE>i_opening</CODE>)
                          unless ( $<CODE>do_not_break_apart</CODE>
                            || <CODE>is_unbreakable_container</CODE>($<CODE>current_depth</CODE>) );

                        # <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> ',' <COMMENTS>of</COMMENTS> <COMMENTS>lower</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
                        if ( $<CODE>last_comma_index</CODE>[$<CODE>depth</CODE>] ) {
                            <CODE>set_forced_breakpoint</CODE>( $<CODE>last_comma_index</CODE>[$<CODE>depth</CODE>] );
                        }

                        # <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> '.' <COMMENTS>of</COMMENTS> <COMMENTS>lower</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS>
                        if ( $<CODE>last_dot_index</CODE>[$<CODE>depth</CODE>] ) {
                            <CODE>set_forced_breakpoint</CODE>( $<CODE>last_dot_index</CODE>[$<CODE>depth</CODE>] );
                        }

                        # <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>structure</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>preceded</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>another</COMMENTS>
                        # <COMMENTS>closing</COMMENTS> <COMMENTS>structure</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>normally</COMMENTS>
                        # <COMMENTS>done</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>brace</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS>
                        # <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>block</COMMENTS>.
                        if ( $<CODE>i_opening</CODE> > 2 ) {
                            my $<CODE>i_prev</CODE> =
                              ( $<CODE>types_to_go</CODE>[ $<CODE>i_opening</CODE> - 1 ] eq '<LITERALS>b</LITERALS>' )
                              ? $<CODE>i_opening</CODE> - 2
                              : $<CODE>i_opening</CODE> - 1;

                            if (   $<CODE>types_to_go</CODE>[$<CODE>i_prev</CODE>] eq ','
                                && $<CODE>types_to_go</CODE>[ $<CODE>i_prev</CODE> - 1 ] =~ /^[\)\}]$/ )
                            {
                                <CODE>set_forced_breakpoint</CODE>($<CODE>i_prev</CODE>);
                            }

                            # <COMMENTS>also</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> ':('  <COMMENTS>or</COMMENTS> '?('
                            # <COMMENTS>if</COMMENTS> <COMMENTS>appropriate</COMMENTS>.
                            elsif (
                                $<CODE>types_to_go</CODE>[$<CODE>i_prev</CODE>] =~ /^([k\:\?]|&&|\|\|)$/ )
                            {
                                my $<CODE>token_prev</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>i_prev</CODE>];
                                if ( $<CODE>want_break_before</CODE>{$<CODE>token_prev</CODE>} ) {
                                    <CODE>set_forced_breakpoint</CODE>($<CODE>i_prev</CODE>);
                                }
                            } ## <COMMENTS>end</COMMENTS> <COMMENTS>elsif</COMMENTS> ( <COMMENTS>$types_to_go</COMMENTS>[<COMMENTS>$i_prev</COMMENTS>...])
                        } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$i_opening</COMMENTS> > <COMMENTS>2</COMMENTS> )
                    } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$minimum_depth</COMMENTS> <=...)

                    # <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>structure</COMMENTS>
                    if ( $<CODE>next_type</CODE> eq ',' ) {
                        <CODE>set_forced_breakpoint</CODE>( $<CODE>i</CODE> + 1 );
                    }

                    # <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>an</COMMENTS> '=' <COMMENTS>following</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>structure</COMMENTS>
                    if (
                        $<CODE>is_assignment</CODE>{$<CODE>next_nonblank_type</CODE>}
                        && ( $<CODE>breakpoint_stack</CODE>[$<CODE>current_depth</CODE>] !=
                            $<CODE>forced_breakpoint_count</CODE> )
                      )
                    {
                        <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>);
                    } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$is_assignment</COMMENTS>{<COMMENTS>$next_nonblank_type</COMMENTS>...})

                    # <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>structure</COMMENTS> <COMMENTS>Added</COMMENTS>
                    # <COMMENTS>for</COMMENTS> -<COMMENTS>lp</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>general</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>isn</COMMENTS>'<COMMENTS>t</COMMENTS>
                    # <COMMENTS>obvious</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>far</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>look</COMMENTS>; <COMMENTS>the</COMMENTS> '<COMMENTS>5</COMMENTS>' <COMMENTS>below</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>to</COMMENTS>
                    # <COMMENTS>work</COMMENTS> <COMMENTS>well</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>catch</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS>
                    #  <COMMENTS>push</COMMENTS> @<COMMENTS>list</COMMENTS>, <COMMENTS>myfunc</COMMENTS>( <COMMENTS>$param</COMMENTS>, <COMMENTS>$param</COMMENTS>, ..

                    my $<CODE>icomma</CODE> = $<CODE>last_comma_index</CODE>[$<CODE>depth</CODE>];
                    if ( defined($<CODE>icomma</CODE>) && ( $<CODE>i_opening</CODE> - $<CODE>icomma</CODE> ) < 5 ) {
                        unless ( $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>icomma</CODE>] ) {
                            <CODE>set_forced_breakpoint</CODE>($<CODE>icomma</CODE>);
                        }
                    }
                }    # <COMMENTS>end</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>container</COMMENTS>

                # <COMMENTS>Break</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>open</COMMENTS>
                elsif ($<CODE>is_simple_logical_expression</CODE>
                    && $<CODE>has_old_logical_breakpoints</CODE>[$<CODE>current_depth</CODE>] )
                {
                    <CODE>set_logical_breakpoints</CODE>($<CODE>current_depth</CODE>);
                }

                # <COMMENTS>Handle</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>opened</COMMENTS> <COMMENTS>up</COMMENTS>
                elsif ($<CODE>is_long_term</CODE>) {

                    # <COMMENTS>must</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>fake</COMMENTS> <COMMENTS>breakpoint</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>alert</COMMENTS> <COMMENTS>outer</COMMENTS> <COMMENTS>containers</COMMENTS> <COMMENTS>that</COMMENTS>
                    # <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>complex</COMMENTS>
                    <CODE>set_fake_breakpoint</CODE>();
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>elsif</COMMENTS> (<COMMENTS>$is_long_term</COMMENTS>)

            } ## <COMMENTS>end</COMMENTS> <COMMENTS>elsif</COMMENTS> ( <COMMENTS>$depth</COMMENTS> < <COMMENTS>$current_depth</COMMENTS>)

            #------------------------------------------------------------
            # <COMMENTS>Handle</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS>
            #------------------------------------------------------------

            $<CODE>current_depth</CODE> = $<CODE>depth</CODE>;

            # <COMMENTS>handle</COMMENTS> <COMMENTS>comma</COMMENTS>-<COMMENTS>arrow</COMMENTS>
            if ( $<CODE>type</CODE> eq '=>' ) {
                next if ( $<CODE>last_nonblank_type</CODE> eq '=>' );
                next if $<CODE>rOpts_break_at_old_comma_breakpoints</CODE>;
                next if $<CODE>rOpts_comma_arrow_breakpoints</CODE> == 3;
                $<CODE>want_comma_break</CODE>[$<CODE>depth</CODE>]   = 1;
                $<CODE>index_before_arrow</CODE>[$<CODE>depth</CODE>] = $<CODE>i_last_nonblank_token</CODE>;
                next;
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$type</COMMENTS> <COMMENTS>eq</COMMENTS> '=>' )

            elsif ( $<CODE>type</CODE> eq '.' ) {
                $<CODE>last_dot_index</CODE>[$<CODE>depth</CODE>] = $<CODE>i</CODE>;
            }

            # <COMMENTS>Turn</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS>
            # <COMMENTS>environment</COMMENTS>.  <COMMENTS>To</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>safe</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>certain</COMMENTS>
            # <COMMENTS>non</COMMENTS>-<COMMENTS>list</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> ';', <COMMENTS>and</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>environment</COMMENTS> <COMMENTS>is</COMMENTS>
            # <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS>.  <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> '=' <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> = <COMMENTS>operators</COMMENTS>
            # (<COMMENTS>lextest</COMMENTS>.<COMMENTS>t</COMMENTS>). <COMMENTS>We</COMMENTS> <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>reported</COMMENTS> <COMMENTS>environment</COMMENTS>
            # <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>incorrect</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>cases</COMMENTS>.
            elsif ( ( $<CODE>type</CODE> =~ /^[\;\<\>\~]$/ || $<CODE>is_assignment</CODE>{$<CODE>type</CODE>} )
                && $<CODE>container_environment_to_go</CODE>[$<CODE>i</CODE>] ne '<LITERALS>LIST</LITERALS>' )
            {
                $<CODE>dont_align</CODE>[$<CODE>depth</CODE>]         = 1;
                $<CODE>want_comma_break</CODE>[$<CODE>depth</CODE>]   = 0;
                $<CODE>index_before_arrow</CODE>[$<CODE>depth</CODE>] = -1;
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>elsif</COMMENTS> ( ( <COMMENTS>$type</COMMENTS> =~ /^[\;\<\>\~]<COMMENTS>$</COMMENTS>/...))

            # <COMMENTS>now</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>commas</COMMENTS>
            next unless ( $<CODE>type</CODE> eq ',' );

            $<CODE>last_dot_index</CODE>[$<CODE>depth</CODE>]   = undef;
            $<CODE>last_comma_index</CODE>[$<CODE>depth</CODE>] = $<CODE>i</CODE>;

            # <COMMENTS>break</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>follows</COMMENTS> <COMMENTS>a</COMMENTS> '=>'
            # <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>comma</COMMENTS>
            if ( $<CODE>want_comma_break</CODE>[$<CODE>depth</CODE>] ) {

                if ( $<CODE>next_nonblank_type</CODE> =~ /^[\)\}\]R]$/ ) {
                    if ($<CODE>rOpts_comma_arrow_breakpoints</CODE>) {
                        $<CODE>want_comma_break</CODE>[$<CODE>depth</CODE>] = 0;
                        ##<COMMENTS>$index_before_arrow</COMMENTS>[<COMMENTS>$depth</COMMENTS>] = -<COMMENTS>1</COMMENTS>;
                        next;
                    }
                }

                <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>) unless ( $<CODE>next_nonblank_type</CODE> eq '#' );

                # <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>safe</COMMENTS>
                # <COMMENTS>Example</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS>:
                #   <COMMENTS>DBI</COMMENTS>::<COMMENTS>SQL_SMALLINT</COMMENTS>() => <COMMENTS>$ado_consts</COMMENTS>->{<COMMENTS>adSmallInt</COMMENTS>},
                # <COMMENTS>Also</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>binary</COMMENTS> <COMMENTS>operator</COMMENTS> (<COMMENTS>like</COMMENTS> +):
                # <COMMENTS>$c</COMMENTS>-><COMMENTS>createOval</COMMENTS>(
                #    <COMMENTS>$x</COMMENTS> + <COMMENTS>$R</COMMENTS>, <COMMENTS>$y</COMMENTS> +
                #    <COMMENTS>$R</COMMENTS> => <COMMENTS>$x</COMMENTS> - <COMMENTS>$R</COMMENTS>,
                #    <COMMENTS>$y</COMMENTS> - <COMMENTS>$R</COMMENTS>, -<COMMENTS>fill</COMMENTS>   => '<COMMENTS>black</COMMENTS>',
                # );
                my $<CODE>ibreak</CODE> = $<CODE>index_before_arrow</CODE>[$<CODE>depth</CODE>] - 1;
                if (   $<CODE>ibreak</CODE> > 0
                    && $<CODE>tokens_to_go</CODE>[ $<CODE>ibreak</CODE> + 1 ] !~ /^[\)\}\]]$/ )
                {
                    if ( $<CODE>tokens_to_go</CODE>[$<CODE>ibreak</CODE>] eq '-' ) { $<CODE>ibreak</CODE>-- }
                    if ( $<CODE>types_to_go</CODE>[$<CODE>ibreak</CODE>] eq '<LITERALS>b</LITERALS>' )  { $<CODE>ibreak</CODE>-- }
                    if ( $<CODE>types_to_go</CODE>[$<CODE>ibreak</CODE>] =~ /^[,wiZCUG\(\{\[]$/ ) {

                        # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>pointer</COMMENTS> <COMMENTS>calls</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>:
                        #  <COMMENTS>File</COMMENTS>::<COMMENTS>Spec</COMMENTS>-><COMMENTS>curdir</COMMENTS>  => <COMMENTS>1</COMMENTS>,
                        # (<COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>tokenized</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>adjacent</COMMENTS> '<COMMENTS>w</COMMENTS>' <COMMENTS>tokens</COMMENTS>)
                        ##<COMMENTS>if</COMMENTS> ( <COMMENTS>$tokens_to_go</COMMENTS>[ <COMMENTS>$ibreak</COMMENTS> + <COMMENTS>1</COMMENTS> ] !~ /^->/ ) {

                        # <COMMENTS>And</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>:
                        # ( <COMMENTS>LONGER_THAN</COMMENTS>,=> <COMMENTS>1</COMMENTS>,
                        #    <COMMENTS>EIGHTY_CHARACTERS</COMMENTS>,=> <COMMENTS>2</COMMENTS>,
                        #    <COMMENTS>CAUSES_FORMATTING</COMMENTS>,=> <COMMENTS>3</COMMENTS>,
                        #    <COMMENTS>LIKE_THIS</COMMENTS>,=> <COMMENTS>4</COMMENTS>,
                        # );
                        # <COMMENTS>This</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>for</COMMENTS> -<COMMENTS>tso</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>general</COMMENTS> <COMMENTS>rule</COMMENTS>
                        if (   $<CODE>tokens_to_go</CODE>[ $<CODE>ibreak</CODE> + 1 ] ne '->'
                            && $<CODE>tokens_to_go</CODE>[ $<CODE>ibreak</CODE> + 1 ] ne ',' )
                        {
                            <CODE>set_forced_breakpoint</CODE>($<CODE>ibreak</CODE>);
                        }
                    } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$types_to_go</COMMENTS>[<COMMENTS>$ibreak</COMMENTS>...])
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$ibreak</COMMENTS> > <COMMENTS>0</COMMENTS> && <COMMENTS>$tokens_to_go</COMMENTS>...)

                $<CODE>want_comma_break</CODE>[$<CODE>depth</CODE>]   = 0;
                $<CODE>index_before_arrow</CODE>[$<CODE>depth</CODE>] = -1;

                # <COMMENTS>handle</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>mixes</COMMENTS> '=>'<COMMENTS>s</COMMENTS> <COMMENTS>and</COMMENTS> ','<COMMENTS>s</COMMENTS>:
                # <COMMENTS>treat</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>far</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>interrupted</COMMENTS> <COMMENTS>list</COMMENTS>
                $<CODE>interrupted_list</CODE>[$<CODE>depth</CODE>] = 1;
                next;
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$want_comma_break</COMMENTS>...)

            # <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>depth</COMMENTS>
            if ( $<CODE>depth</CODE> < $<CODE>starting_depth</CODE> && !$<CODE>dont_align</CODE>[$<CODE>depth</CODE>] ) {
                <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>) unless ( $<CODE>next_nonblank_type</CODE> eq '#' );
                next;
            }

            # <COMMENTS>add</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS>..
            my $<CODE>item_count</CODE> = $<CODE>item_count_stack</CODE>[$<CODE>depth</CODE>];
            if ( $<CODE>item_count</CODE> == 0 ) {

                # <COMMENTS>but</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>form</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>structure</COMMENTS>
                # <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>:

                #            <COMMENTS>open</COMMENTS> <COMMENTS>INFILE_COPY</COMMENTS>, "><COMMENTS>$input_file_copy</COMMENTS>"
                #              <COMMENTS>or</COMMENTS> <COMMENTS>die</COMMENTS> ("<COMMENTS>very</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>message</COMMENTS>");

                if ( ( $<CODE>opening_structure_index_stack</CODE>[$<CODE>depth</CODE>] < 0 )
                    && $<CODE>container_environment_to_go</CODE>[$<CODE>i</CODE>] eq '<LITERALS>BLOCK</LITERALS>' )
                {
                    $<CODE>dont_align</CODE>[$<CODE>depth</CODE>] = 1;
                }
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$item_count</COMMENTS> == <COMMENTS>0</COMMENTS> )

            $<CODE>comma_index</CODE>[$<CODE>depth</CODE>][$<CODE>item_count</CODE>] = $<CODE>i</CODE>;
            ++$<CODE>item_count_stack</CODE>[$<CODE>depth</CODE>];
            if ( $<CODE>last_nonblank_type</CODE> =~ /^[iR\]]$/ ) {
                $<CODE>identifier_count_stack</CODE>[$<CODE>depth</CODE>]++;
            }
        } ## <COMMENTS>end</COMMENTS> <COMMENTS>while</COMMENTS> ( ++<COMMENTS>$i</COMMENTS> <= <COMMENTS>$max_index_to_go</COMMENTS>)

        #-------------------------------------------
        # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
        #-------------------------------------------

        # <COMMENTS>set</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>unfinished</COMMENTS> <COMMENTS>lists</COMMENTS> ..
        for ( my $<CODE>dd</CODE> = $<CODE>current_depth</CODE> ; $<CODE>dd</CODE> >= $<CODE>minimum_depth</CODE> ; $<CODE>dd</CODE>-- ) {

            $<CODE>interrupted_list</CODE>[$<CODE>dd</CODE>] = 1;
            $<CODE>has_broken_sublist</CODE>[$<CODE>dd</CODE>] = 1 if ( $<CODE>dd</CODE> < $<CODE>current_depth</CODE> );
            <CODE>set_comma_breakpoints</CODE>($<CODE>dd</CODE>);
            <CODE>set_logical_breakpoints</CODE>($<CODE>dd</CODE>)
              if ( $<CODE>has_old_logical_breakpoints</CODE>[$<CODE>dd</CODE>] );
            <CODE>set_for_semicolon_breakpoints</CODE>($<CODE>dd</CODE>);

            # <COMMENTS>break</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>container</COMMENTS>...
            my $<CODE>i_opening</CODE> = $<CODE>opening_structure_index_stack</CODE>[$<CODE>dd</CODE>];
            <CODE>set_forced_breakpoint</CODE>($<CODE>i_opening</CODE>)
              unless (
                <CODE>is_unbreakable_container</CODE>($<CODE>dd</CODE>)

                # <COMMENTS>Avoid</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>place</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>isolated</COMMENTS> ' <COMMENTS>or</COMMENTS> "
                # <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>
                || (   $<CODE>type</CODE> eq '<LITERALS>Q</LITERALS>'
                    && $<CODE>i_opening</CODE> >= $<CODE>max_index_to_go</CODE> - 2
                    && $<CODE>token</CODE> =~ /^['"]$/ )
              );
        } ## <COMMENTS>end</COMMENTS> <COMMENTS>for</COMMENTS> ( <COMMENTS>my</COMMENTS> <COMMENTS>$dd</COMMENTS> = <COMMENTS>$current_depth</COMMENTS>...)

        # <COMMENTS>Return</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>indicating</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>had</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>breakpoints</COMMENTS>.
        # <COMMENTS>This</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>shorter</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>allowed</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>.
        if ( $<CODE>has_old_logical_breakpoints</CODE>[$<CODE>current_depth</CODE>] ) {
            $<CODE>saw_good_breakpoint</CODE> = 1;
        }

        # <COMMENTS>A</COMMENTS> <COMMENTS>complex</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>an</COMMENTS> = <COMMENTS>has</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>breakpoint</COMMENTS>.
        # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>complex</COMMENTS> (<COMMENTS>$total_depth_variation</COMMENTS>=<COMMENTS>0</COMMENTS>):
        # <COMMENTS>$res1</COMMENTS>
        #   = <COMMENTS>10</COMMENTS>;
        #
        # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>complex</COMMENTS> (<COMMENTS>$total_depth_variation</COMMENTS>=<COMMENTS>6</COMMENTS>):
        # <COMMENTS>$res2</COMMENTS> =
        #  (<COMMENTS>is_boundp</COMMENTS>("<COMMENTS>a</COMMENTS>", '<COMMENTS>self</COMMENTS>-<COMMENTS>insert</COMMENTS>') && <COMMENTS>is_boundp</COMMENTS>("<COMMENTS>b</COMMENTS>", '<COMMENTS>self</COMMENTS>-<COMMENTS>insert</COMMENTS>'));
        elsif ($<CODE>i_old_assignment_break</CODE>
            && $<CODE>total_depth_variation</CODE> > 4
            && $<CODE>old_breakpoint_count</CODE> == 1 )
        {
            $<CODE>saw_good_breakpoint</CODE> = 1;
        } ## <COMMENTS>end</COMMENTS> <COMMENTS>elsif</COMMENTS> ( <COMMENTS>$i_old_assignment_break</COMMENTS>...)

        return $<CODE>saw_good_breakpoint</CODE>;
    } ## <COMMENTS>end</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>scan_list</COMMENTS>
}    # <COMMENTS>end</COMMENTS> <COMMENTS>scan_list</COMMENTS>

sub <CODE>find_token_starting_list</CODE> {

    # <COMMENTS>When</COMMENTS> <COMMENTS>testing</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>fit</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>some</COMMENTS>
    # <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS>(<COMMENTS>s</COMMENTS>) <COMMENTS>may</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>; <COMMENTS>particularly</COMMENTS>
    # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>call</COMMENTS>.  <COMMENTS>So</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>one</COMMENTS>
    # <COMMENTS>token</COMMENTS>. <COMMENTS>NOTE</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>isn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>perfect</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>critical</COMMENTS>, <COMMENTS>because</COMMENTS>
    # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>mis</COMMENTS>-<COMMENTS>identify</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>wrapped</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>therefore</COMMENTS>
    # <COMMENTS>fixed</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>time</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>formatted</COMMENTS>.
    my $<CODE>i_opening_paren</CODE> = shift;
    my $<CODE>i_opening_minus</CODE> = $<CODE>i_opening_paren</CODE>;
    my $<CODE>im1</CODE>             = $<CODE>i_opening_paren</CODE> - 1;
    my $<CODE>im2</CODE>             = $<CODE>i_opening_paren</CODE> - 2;
    my $<CODE>im3</CODE>             = $<CODE>i_opening_paren</CODE> - 3;
    my $<CODE>typem1</CODE>          = $<CODE>types_to_go</CODE>[$<CODE>im1</CODE>];
    my $<CODE>typem2</CODE>          = $<CODE>im2</CODE> >= 0 ? $<CODE>types_to_go</CODE>[$<CODE>im2</CODE>] : '<LITERALS>b</LITERALS>';
    if ( $<CODE>typem1</CODE> eq ',' || ( $<CODE>typem1</CODE> eq '<LITERALS>b</LITERALS>' && $<CODE>typem2</CODE> eq ',' ) ) {
        $<CODE>i_opening_minus</CODE> = $<CODE>i_opening_paren</CODE>;
    }
    elsif ( $<CODE>tokens_to_go</CODE>[$<CODE>i_opening_paren</CODE>] eq '(' ) {
        $<CODE>i_opening_minus</CODE> = $<CODE>im1</CODE> if $<CODE>im1</CODE> >= 0;

        # <COMMENTS>walk</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>improve</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>estimate</COMMENTS>
        for ( my $<CODE>j</CODE> = $<CODE>im1</CODE> ; $<CODE>j</CODE> >= 0 ; $<CODE>j</CODE>-- ) {
            last if ( $<CODE>types_to_go</CODE>[$<CODE>j</CODE>] =~ /^[\(\[\{L\}\]\)Rb,]$/ );
            $<CODE>i_opening_minus</CODE> = $<CODE>j</CODE>;
        }
        if ( $<CODE>types_to_go</CODE>[$<CODE>i_opening_minus</CODE>] eq '<LITERALS>b</LITERALS>' ) { $<CODE>i_opening_minus</CODE>++ }
    }
    elsif ( $<CODE>typem1</CODE> eq '<LITERALS>k</LITERALS>' ) { $<CODE>i_opening_minus</CODE> = $<CODE>im1</CODE> }
    elsif ( $<CODE>typem1</CODE> eq '<LITERALS>b</LITERALS>' && $<CODE>im2</CODE> >= 0 && $<CODE>types_to_go</CODE>[$<CODE>im2</CODE>] eq '<LITERALS>k</LITERALS>' ) {
        $<CODE>i_opening_minus</CODE> = $<CODE>im2</CODE>;
    }
    return $<CODE>i_opening_minus</CODE>;
}

{    # <COMMENTS>begin</COMMENTS> <COMMENTS>set_comma_breakpoints_do</COMMENTS>

    my %<CODE>is_keyword_with_special_leading_term</CODE>;

    <CODE>BEGIN</CODE> {

        # <COMMENTS>These</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>prototypes</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>item</COMMENTS>
        # <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS>
        @<CODE>_</CODE> =
          qw(<LITERALS>formline</LITERALS> <LITERALS>grep</LITERALS> <LITERALS>kill</LITERALS> <LITERALS>map</LITERALS> <LITERALS>printf</LITERALS> <LITERALS>sprintf</LITERALS> <LITERALS>push</LITERALS> <LITERALS>chmod</LITERALS> <LITERALS>join</LITERALS> <LITERALS>pack</LITERALS> <LITERALS>unshift</LITERALS>);
        @<CODE>is_keyword_with_special_leading_term</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);
    }

    sub <CODE>set_comma_breakpoints_do</CODE> {

        # <COMMENTS>Given</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>commas</COMMENTS>, <COMMENTS>set</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>commas</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>easy</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>read</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>is</COMMENTS>
        # <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS>:
        my (
            $<CODE>depth</CODE>,               $<CODE>i_opening_paren</CODE>,  $<CODE>i_closing_paren</CODE>,
            $<CODE>item_count</CODE>,          $<CODE>identifier_count</CODE>, $<CODE>rcomma_index</CODE>,
            $<CODE>next_nonblank_type</CODE>,  $<CODE>list_type</CODE>,        $<CODE>interrupted</CODE>,
            $<CODE>rdo_not_break_apart</CODE>, $<CODE>must_break_open</CODE>,
        ) = @<CODE>_</CODE>;

        # <COMMENTS>nothing</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>seen</COMMENTS>
        return if ( $<CODE>item_count</CODE> < 1 );
        my $<CODE>i_first_comma</CODE>     = $$<CODE>rcomma_index</CODE>[0];
        my $<CODE>i_true_last_comma</CODE> = $$<CODE>rcomma_index</CODE>[ $<CODE>item_count</CODE> - 1 ];
        my $<CODE>i_last_comma</CODE>      = $<CODE>i_true_last_comma</CODE>;
        if ( $<CODE>i_last_comma</CODE> >= $<CODE>max_index_to_go</CODE> ) {
            $<CODE>i_last_comma</CODE> = $$<CODE>rcomma_index</CODE>[ --$<CODE>item_count</CODE> - 1 ];
            return if ( $<CODE>item_count</CODE> < 1 );
        }

        #---------------------------------------------------------------
        # <COMMENTS>find</COMMENTS> <COMMENTS>lengths</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>calculate</COMMENTS> <COMMENTS>page</COMMENTS> <COMMENTS>layout</COMMENTS>
        #---------------------------------------------------------------
        my $<CODE>comma_count</CODE> = $<CODE>item_count</CODE>;
        my @<CODE>item_lengths</CODE>;
        my @<CODE>i_term_begin</CODE>;
        my @<CODE>i_term_end</CODE>;
        my @<CODE>i_term_comma</CODE>;
        my $<CODE>i_prev_plus</CODE>;
        my @<CODE>max_length</CODE> = ( 0, 0 );
        my $<CODE>first_term_length</CODE>;
        my $<CODE>i</CODE>      = $<CODE>i_opening_paren</CODE>;
        my $<CODE>is_odd</CODE> = 1;

        for ( my $<CODE>j</CODE> = 0 ; $<CODE>j</CODE> < $<CODE>comma_count</CODE> ; $<CODE>j</CODE>++ ) {
            $<CODE>is_odd</CODE>      = 1 - $<CODE>is_odd</CODE>;
            $<CODE>i_prev_plus</CODE> = $<CODE>i</CODE> + 1;
            $<CODE>i</CODE>           = $$<CODE>rcomma_index</CODE>[$<CODE>j</CODE>];

            my $<CODE>i_term_end</CODE> =
              ( $<CODE>types_to_go</CODE>[ $<CODE>i</CODE> - 1 ] eq '<LITERALS>b</LITERALS>' ) ? $<CODE>i</CODE> - 2 : $<CODE>i</CODE> - 1;
            my $<CODE>i_term_begin</CODE> =
              ( $<CODE>types_to_go</CODE>[$<CODE>i_prev_plus</CODE>] eq '<LITERALS>b</LITERALS>' )
              ? $<CODE>i_prev_plus</CODE> + 1
              : $<CODE>i_prev_plus</CODE>;
            push @<CODE>i_term_begin</CODE>, $<CODE>i_term_begin</CODE>;
            push @<CODE>i_term_end</CODE>,   $<CODE>i_term_end</CODE>;
            push @<CODE>i_term_comma</CODE>, $<CODE>i</CODE>;

            # <COMMENTS>note</COMMENTS>: <COMMENTS>currently</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>lengths</COMMENTS> (<COMMENTS>for</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>space</COMMENTS>)
            my $<CODE>length</CODE> =
              2 + <CODE>token_sequence_length</CODE>( $<CODE>i_term_begin</CODE>, $<CODE>i_term_end</CODE> );
            push @<CODE>item_lengths</CODE>, $<CODE>length</CODE>;

            if ( $<CODE>j</CODE> == 0 ) {
                $<CODE>first_term_length</CODE> = $<CODE>length</CODE>;
            }
            else {

                if ( $<CODE>length</CODE> > $<CODE>max_length</CODE>[$<CODE>is_odd</CODE>] ) {
                    $<CODE>max_length</CODE>[$<CODE>is_odd</CODE>] = $<CODE>length</CODE>;
                }
            }
        }

        # <COMMENTS>now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>distinction</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>item</COMMENTS>
        # <COMMENTS>count</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>greater</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>comma</COMMENTS>
        # <COMMENTS>count</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>terminated</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>
        my $<CODE>i_b</CODE> =
          ( $<CODE>types_to_go</CODE>[ $<CODE>i_last_comma</CODE> + 1 ] eq '<LITERALS>b</LITERALS>' )
          ? $<CODE>i_last_comma</CODE> + 1
          : $<CODE>i_last_comma</CODE>;
        my $<CODE>i_e</CODE> =
          ( $<CODE>types_to_go</CODE>[ $<CODE>i_closing_paren</CODE> - 1 ] eq '<LITERALS>b</LITERALS>' )
          ? $<CODE>i_closing_paren</CODE> - 2
          : $<CODE>i_closing_paren</CODE> - 1;
        my $<CODE>i_effective_last_comma</CODE> = $<CODE>i_last_comma</CODE>;

        my $<CODE>last_item_length</CODE> = <CODE>token_sequence_length</CODE>( $<CODE>i_b</CODE> + 1, $<CODE>i_e</CODE> );

        if ( $<CODE>last_item_length</CODE> > 0 ) {

            # <COMMENTS>add</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>lengths</COMMENTS> <COMMENTS>include</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS>
            $<CODE>last_item_length</CODE> += 2;
            push @<CODE>item_lengths</CODE>, $<CODE>last_item_length</CODE>;
            push @<CODE>i_term_begin</CODE>, $<CODE>i_b</CODE> + 1;
            push @<CODE>i_term_end</CODE>,   $<CODE>i_e</CODE>;
            push @<CODE>i_term_comma</CODE>, undef;

            my $<CODE>i_odd</CODE> = $<CODE>item_count</CODE> % 2;

            if ( $<CODE>last_item_length</CODE> > $<CODE>max_length</CODE>[$<CODE>i_odd</CODE>] ) {
                $<CODE>max_length</CODE>[$<CODE>i_odd</CODE>] = $<CODE>last_item_length</CODE>;
            }

            $<CODE>item_count</CODE>++;
            $<CODE>i_effective_last_comma</CODE> = $<CODE>i_e</CODE> + 1;

            if ( $<CODE>types_to_go</CODE>[ $<CODE>i_b</CODE> + 1 ] =~ /^[iR\]]$/ ) {
                $<CODE>identifier_count</CODE>++;
            }
        }

        #---------------------------------------------------------------
        # <COMMENTS>End</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>calculations</COMMENTS>
        #---------------------------------------------------------------

        #---------------------------------------------------------------
        # <COMMENTS>Compound</COMMENTS> <COMMENTS>List</COMMENTS> <COMMENTS>Rule</COMMENTS> <COMMENTS>1</COMMENTS>:
        # <COMMENTS>Break</COMMENTS> <COMMENTS>at</COMMENTS> (<COMMENTS>almost</COMMENTS>) <COMMENTS>every</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>containing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>broken</COMMENTS>
        # <COMMENTS>sublist</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>higher</COMMENTS> <COMMENTS>priority</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>Interrupted</COMMENTS> <COMMENTS>List</COMMENTS>
        # <COMMENTS>Rule</COMMENTS>.
        #---------------------------------------------------------------
        if ( $<CODE>has_broken_sublist</CODE>[$<CODE>depth</CODE>] ) {

            # <COMMENTS>Break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>every</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>two</COMMENTS>
            # <COMMENTS>simple</COMMENTS>, <COMMENTS>small</COMMENTS> <COMMENTS>terms</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>prevents</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>vertical</COMMENTS>
            # <COMMENTS>columns</COMMENTS> <COMMENTS>of</COMMENTS>, <COMMENTS>say</COMMENTS>, <COMMENTS>just</COMMENTS> <COMMENTS>0</COMMENTS>'<COMMENTS>s</COMMENTS>.
            my $<CODE>small_length</CODE> = 10;    # <COMMENTS>2</COMMENTS> + <COMMENTS>actual</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>wanted</COMMENTS>

            # <COMMENTS>We</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>insert</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>runs</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>terms</COMMENTS> <COMMENTS>to</COMMENTS>
            # <COMMENTS>allow</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>uniform</COMMENTS> <COMMENTS>tables</COMMENTS>.
            my $<CODE>skipped_count</CODE> = 0;
            my $<CODE>columns</CODE>       = <CODE>table_columns_available</CODE>($<CODE>i_first_comma</CODE>);
            my $<CODE>fields</CODE>        = int( $<CODE>columns</CODE> / $<CODE>small_length</CODE> );
            if (   $<CODE>rOpts_maximum_fields_per_table</CODE>
                && $<CODE>fields</CODE> > $<CODE>rOpts_maximum_fields_per_table</CODE> )
            {
                $<CODE>fields</CODE> = $<CODE>rOpts_maximum_fields_per_table</CODE>;
            }
            my $<CODE>max_skipped_count</CODE> = $<CODE>fields</CODE> - 1;

            my $<CODE>is_simple_last_term</CODE> = 0;
            my $<CODE>is_simple_next_term</CODE> = 0;
            foreach my $<CODE>j</CODE> ( 0 .. $<CODE>item_count</CODE> ) {
                $<CODE>is_simple_last_term</CODE> = $<CODE>is_simple_next_term</CODE>;
                $<CODE>is_simple_next_term</CODE> = 0;
                if (   $<CODE>j</CODE> < $<CODE>item_count</CODE>
                    && $<CODE>i_term_end</CODE>[$<CODE>j</CODE>] == $<CODE>i_term_begin</CODE>[$<CODE>j</CODE>]
                    && $<CODE>item_lengths</CODE>[$<CODE>j</CODE>] <= $<CODE>small_length</CODE> )
                {
                    $<CODE>is_simple_next_term</CODE> = 1;
                }
                next if $<CODE>j</CODE> == 0;
                if (   $<CODE>is_simple_last_term</CODE>
                    && $<CODE>is_simple_next_term</CODE>
                    && $<CODE>skipped_count</CODE> < $<CODE>max_skipped_count</CODE> )
                {
                    $<CODE>skipped_count</CODE>++;
                }
                else {
                    $<CODE>skipped_count</CODE> = 0;
                    my $<CODE>i</CODE> = $<CODE>i_term_comma</CODE>[ $<CODE>j</CODE> - 1 ];
                    last unless defined $<CODE>i</CODE>;
                    <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>);
                }
            }

            # <COMMENTS>always</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>is</COMMENTS>
            # <COMMENTS>interrupted</COMMENTS>; <COMMENTS>we</COMMENTS> <COMMENTS>wouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>leave</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>terminal</COMMENTS> '{', <COMMENTS>for</COMMENTS>
            # <COMMENTS>example</COMMENTS>.
            if ($<CODE>interrupted</CODE>) { <CODE>set_forced_breakpoint</CODE>($<CODE>i_true_last_comma</CODE>) }
            return;
        }

#<COMMENTS>my</COMMENTS> ( <COMMENTS>$a</COMMENTS>, <COMMENTS>$b</COMMENTS>, <COMMENTS>$c</COMMENTS> ) = <COMMENTS>caller</COMMENTS>();
#<COMMENTS>print</COMMENTS> "<COMMENTS>LISTX</COMMENTS>: <COMMENTS>in</COMMENTS> <COMMENTS>set_list</COMMENTS> <COMMENTS>$a</COMMENTS> <COMMENTS>$c</COMMENTS> <COMMENTS>interrupt</COMMENTS>=<COMMENTS>$interrupted</COMMENTS> <COMMENTS>count</COMMENTS>=<COMMENTS>$item_count</COMMENTS>
#<COMMENTS>i_first</COMMENTS> = <COMMENTS>$i_first_comma</COMMENTS>  <COMMENTS>i_last</COMMENTS>=<COMMENTS>$i_last_comma</COMMENTS> <COMMENTS>max</COMMENTS>=<COMMENTS>$max_index_to_go</COMMENTS>\<COMMENTS>n</COMMENTS>";
#<COMMENTS>print</COMMENTS> "<COMMENTS>depth</COMMENTS>=<COMMENTS>$depth</COMMENTS> <COMMENTS>has_broken</COMMENTS>=<COMMENTS>$has_broken_sublist</COMMENTS>[<COMMENTS>$depth</COMMENTS>] <COMMENTS>is_multi</COMMENTS>=<COMMENTS>$is_multiline</COMMENTS> <COMMENTS>opening_paren</COMMENTS>=(<COMMENTS>$i_opening_paren</COMMENTS>) \<COMMENTS>n</COMMENTS>";

        #---------------------------------------------------------------
        # <COMMENTS>Interrupted</COMMENTS> <COMMENTS>List</COMMENTS> <COMMENTS>Rule</COMMENTS>:
        # <COMMENTS>A</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>forced</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>interrupted</COMMENTS>
        # <COMMENTS>by</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>lines</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>requested</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>user</COMMENTS>.
        #---------------------------------------------------------------
        if (   $<CODE>rOpts_break_at_old_comma_breakpoints</CODE>
            || $<CODE>interrupted</CODE>
            || $<CODE>i_opening_paren</CODE> < 0 )
        {
            <CODE>copy_old_breakpoints</CODE>( $<CODE>i_first_comma</CODE>, $<CODE>i_true_last_comma</CODE> );
            return;
        }

        #---------------------------------------------------------------
        # <COMMENTS>Looks</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>items</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>size</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>up</COMMENTS>.
        #---------------------------------------------------------------

        my $<CODE>opening_token</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>i_opening_paren</CODE>];
        my $<CODE>opening_environment</CODE> =
          $<CODE>container_environment_to_go</CODE>[$<CODE>i_opening_paren</CODE>];

        #-------------------------------------------------------------------
        # <COMMENTS>Return</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>fit</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS>
        #-------------------------------------------------------------------

        my $<CODE>i_opening_minus</CODE> = <CODE>find_token_starting_list</CODE>($<CODE>i_opening_paren</CODE>);
        return
          unless <CODE>excess_line_length</CODE>( $<CODE>i_opening_minus</CODE>, $<CODE>i_closing_paren</CODE> ) > 0;

        #-------------------------------------------------------------------
        # <COMMENTS>Now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>spans</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>lines</COMMENTS>; <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>set</COMMENTS>
        # <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>breakpoint</COMMENTS> -- <COMMENTS>real</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>fake</COMMENTS> -- <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>signal</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS>
        # <COMMENTS>open</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>outer</COMMENTS> <COMMENTS>containers</COMMENTS>.
        #-------------------------------------------------------------------
        <CODE>set_fake_breakpoint</CODE>();

        # <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>extend</COMMENTS> <COMMENTS>beyond</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>length</COMMENTS>
        if ( $<CODE>i_effective_last_comma</CODE> >= $<CODE>max_index_to_go</CODE> ) {
            $<CODE>i_effective_last_comma</CODE> = $<CODE>max_index_to_go</CODE> - 1;
        }

        # <COMMENTS>Set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>indicating</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> -<COMMENTS>lp</COMMENTS>
        # <COMMENTS>items</COMMENTS> <COMMENTS>aligned</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>terms</COMMENTS>
        # <COMMENTS>exceeds</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>available</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> '('.
        my $<CODE>need_lp_break_open</CODE> = $<CODE>must_break_open</CODE>;
        if ( $<CODE>rOpts_line_up_parentheses</CODE> && !$<CODE>must_break_open</CODE> ) {
            my $<CODE>columns_if_unbroken</CODE> =
              <CODE>maximum_line_length</CODE>($<CODE>i_opening_minus</CODE>) -
              <CODE>total_line_length</CODE>( $<CODE>i_opening_minus</CODE>, $<CODE>i_opening_paren</CODE> );
            $<CODE>need_lp_break_open</CODE> =
                 ( $<CODE>max_length</CODE>[0] > $<CODE>columns_if_unbroken</CODE> )
              || ( $<CODE>max_length</CODE>[1] > $<CODE>columns_if_unbroken</CODE> )
              || ( $<CODE>first_term_length</CODE> > $<CODE>columns_if_unbroken</CODE> );
        }

        # <COMMENTS>Specify</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>not</COMMENTS>.
        # <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>generally</COMMENTS> <COMMENTS>safest</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>assume</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>number</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>list</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>list</COMMENTS>.  <COMMENTS>But</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>that</COMMENTS>
        # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>odd</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>more</COMMENTS>
        # <COMMENTS>flexibility</COMMENTS>.
        my $<CODE>odd_or_even</CODE> = 2;    # <COMMENTS>1</COMMENTS> = <COMMENTS>odd</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>ok</COMMENTS>, <COMMENTS>2</COMMENTS> = <COMMENTS>want</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>count</COMMENTS>

        if (   $<CODE>identifier_count</CODE> >= $<CODE>item_count</CODE> - 1
            || $<CODE>is_assignment</CODE>{$<CODE>next_nonblank_type</CODE>}
            || ( $<CODE>list_type</CODE> && $<CODE>list_type</CODE> ne '=>' && $<CODE>list_type</CODE> !~ /^[\:\?]$/ )
          )
        {
            $<CODE>odd_or_even</CODE> = 1;
        }

        # <COMMENTS>do</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS>
        # <COMMENTS>left</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>itself</COMMENTS>?
        my $<CODE>use_separate_first_term</CODE> = (
            $<CODE>odd_or_even</CODE> == 1       # <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>field</COMMENTS>/<COMMENTS>line</COMMENTS>
              && $<CODE>item_count</CODE> > 3    # <COMMENTS>need</COMMENTS> <COMMENTS>several</COMMENTS> <COMMENTS>items</COMMENTS>
              && $<CODE>first_term_length</CODE> >
              2 * $<CODE>max_length</CODE>[0] - 2    # <COMMENTS>need</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>term</COMMENTS>
              && $<CODE>first_term_length</CODE> >
              2 * $<CODE>max_length</CODE>[1] - 2    # <COMMENTS>need</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>term</COMMENTS>
        );

        # <COMMENTS>or</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>should</COMMENTS>
        # <COMMENTS>be</COMMENTS> <COMMENTS>placed</COMMENTS> <COMMENTS>alone</COMMENTS>?
        if ( !$<CODE>use_separate_first_term</CODE> ) {
            if ( $<CODE>is_keyword_with_special_leading_term</CODE>{$<CODE>list_type</CODE>} ) {
                $<CODE>use_separate_first_term</CODE> = 1;

                # <COMMENTS>should</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>broken</COMMENTS> <COMMENTS>open</COMMENTS>?
                if ( $<CODE>item_count</CODE> < 3 ) {
                    if ( $<CODE>i_first_comma</CODE> - $<CODE>i_opening_paren</CODE> < 4 ) {
                        $$<CODE>rdo_not_break_apart</CODE> = 1;
                    }
                }
                elsif ($<CODE>first_term_length</CODE> < 20
                    && $<CODE>i_first_comma</CODE> - $<CODE>i_opening_paren</CODE> < 4 )
                {
                    my $<CODE>columns</CODE> = <CODE>table_columns_available</CODE>($<CODE>i_first_comma</CODE>);
                    if ( $<CODE>first_term_length</CODE> < $<CODE>columns</CODE> ) {
                        $$<CODE>rdo_not_break_apart</CODE> = 1;
                    }
                }
            }
        }

        # <COMMENTS>if</COMMENTS> <COMMENTS>so</COMMENTS>,
        if ($<CODE>use_separate_first_term</CODE>) {

            # ..<COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>update</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>values</COMMENTS>
            $<CODE>use_separate_first_term</CODE> = 1;
            <CODE>set_forced_breakpoint</CODE>($<CODE>i_first_comma</CODE>);
            $<CODE>i_opening_paren</CODE> = $<CODE>i_first_comma</CODE>;
            $<CODE>i_first_comma</CODE>   = $$<CODE>rcomma_index</CODE>[1];
            $<CODE>item_count</CODE>--;
            return if $<CODE>comma_count</CODE> == 1;
            shift @<CODE>item_lengths</CODE>;
            shift @<CODE>i_term_begin</CODE>;
            shift @<CODE>i_term_end</CODE>;
            shift @<CODE>i_term_comma</CODE>;
        }

        # <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS>, <COMMENTS>update</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>metrics</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>include</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>term</COMMENTS>
        else {
            if ( $<CODE>first_term_length</CODE> > $<CODE>max_length</CODE>[0] ) {
                $<CODE>max_length</CODE>[0] = $<CODE>first_term_length</CODE>;
            }
        }

        # <COMMENTS>Field</COMMENTS> <COMMENTS>width</COMMENTS> <COMMENTS>parameters</COMMENTS>
        my $<CODE>pair_width</CODE> = ( $<CODE>max_length</CODE>[0] + $<CODE>max_length</CODE>[1] );
        my $<CODE>max_width</CODE> =
          ( $<CODE>max_length</CODE>[0] > $<CODE>max_length</CODE>[1] ) ? $<CODE>max_length</CODE>[0] : $<CODE>max_length</CODE>[1];

        # <COMMENTS>Number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>free</COMMENTS> <COMMENTS>columns</COMMENTS> <COMMENTS>across</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>page</COMMENTS> <COMMENTS>width</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>laying</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>tables</COMMENTS>
        my $<CODE>columns</CODE> = <CODE>table_columns_available</CODE>($<CODE>i_first_comma</CODE>);

        # <COMMENTS>Estimated</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>fit</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>space</COMMENTS>
        # <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>our</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>guess</COMMENTS>
        my $<CODE>number_of_fields_max</CODE> =
          <CODE>maximum_number_of_fields</CODE>( $<CODE>columns</CODE>, $<CODE>odd_or_even</CODE>, $<CODE>max_width</CODE>,
            $<CODE>pair_width</CODE> );
        my $<CODE>number_of_fields</CODE> = $<CODE>number_of_fields_max</CODE>;

        # <COMMENTS>Find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>best</COMMENTS>-<COMMENTS>looking</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>fields</COMMENTS>
        # <COMMENTS>and</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>our</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>guess</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>possible</COMMENTS>
        my ( $<CODE>number_of_fields_best</CODE>, $<CODE>ri_ragged_break_list</CODE>,
            $<CODE>new_identifier_count</CODE> )
          = <CODE>study_list_complexity</CODE>( \@<CODE>i_term_begin</CODE>, \@<CODE>i_term_end</CODE>, \@<CODE>item_lengths</CODE>,
            $<CODE>max_width</CODE> );

        if (   $<CODE>number_of_fields_best</CODE> != 0
            && $<CODE>number_of_fields_best</CODE> < $<CODE>number_of_fields_max</CODE> )
        {
            $<CODE>number_of_fields</CODE> = $<CODE>number_of_fields_best</CODE>;
        }

        # ----------------------------------------------------------------------
        # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>crowded</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>used</COMMENTS>, <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS>
        # <COMMENTS>undo</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>indentation</COMMENTS>
        # ----------------------------------------------------------------------
        if (
            $<CODE>rOpts_line_up_parentheses</CODE>
            && (
                $<CODE>number_of_fields</CODE> == 0
                || (   $<CODE>number_of_fields</CODE> == 1
                    && $<CODE>number_of_fields</CODE> != $<CODE>number_of_fields_best</CODE> )
            )
          )
        {
            my $<CODE>available_spaces</CODE> = <CODE>get_AVAILABLE_SPACES_to_go</CODE>($<CODE>i_first_comma</CODE>);
            if ( $<CODE>available_spaces</CODE> > 0 ) {

                my $<CODE>spaces_wanted</CODE> = $<CODE>max_width</CODE> - $<CODE>columns</CODE>;    # <COMMENTS>for</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>field</COMMENTS>

                if ( $<CODE>number_of_fields_best</CODE> == 0 ) {
                    $<CODE>number_of_fields_best</CODE> =
                      <CODE>get_maximum_fields_wanted</CODE>( \@<CODE>item_lengths</CODE> );
                }

                if ( $<CODE>number_of_fields_best</CODE> != 1 ) {
                    my $<CODE>spaces_wanted_2</CODE> =
                      1 + $<CODE>pair_width</CODE> - $<CODE>columns</CODE>;             # <COMMENTS>for</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>fields</COMMENTS>
                    if ( $<CODE>available_spaces</CODE> > $<CODE>spaces_wanted_2</CODE> ) {
                        $<CODE>spaces_wanted</CODE> = $<CODE>spaces_wanted_2</CODE>;
                    }
                }

                if ( $<CODE>spaces_wanted</CODE> > 0 ) {
                    my $<CODE>deleted_spaces</CODE> =
                      <CODE>reduce_lp_indentation</CODE>( $<CODE>i_first_comma</CODE>, $<CODE>spaces_wanted</CODE> );

                    # <COMMENTS>redo</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>math</COMMENTS>
                    if ( $<CODE>deleted_spaces</CODE> > 0 ) {
                        $<CODE>columns</CODE> = <CODE>table_columns_available</CODE>($<CODE>i_first_comma</CODE>);
                        $<CODE>number_of_fields_max</CODE> =
                          <CODE>maximum_number_of_fields</CODE>( $<CODE>columns</CODE>, $<CODE>odd_or_even</CODE>,
                            $<CODE>max_width</CODE>, $<CODE>pair_width</CODE> );
                        $<CODE>number_of_fields</CODE> = $<CODE>number_of_fields_max</CODE>;

                        if (   $<CODE>number_of_fields_best</CODE> == 1
                            && $<CODE>number_of_fields</CODE> >= 1 )
                        {
                            $<CODE>number_of_fields</CODE> = $<CODE>number_of_fields_best</CODE>;
                        }
                    }
                }
            }
        }

        # <COMMENTS>try</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>won</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS>
        if ( $<CODE>number_of_fields</CODE> <= 0 ) {
            $<CODE>number_of_fields</CODE> = int( $<CODE>columns</CODE> / $<CODE>max_width</CODE> );
        }

        # <COMMENTS>The</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>place</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>upper</COMMENTS> <COMMENTS>bound</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>fields</COMMENTS>,
        # <COMMENTS>which</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>useful</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>doing</COMMENTS> <COMMENTS>maintenance</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>tables</COMMENTS>
        if (   $<CODE>rOpts_maximum_fields_per_table</CODE>
            && $<CODE>number_of_fields</CODE> > $<CODE>rOpts_maximum_fields_per_table</CODE> )
        {
            $<CODE>number_of_fields</CODE> = $<CODE>rOpts_maximum_fields_per_table</CODE>;
        }

        # <COMMENTS>How</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>columns</COMMENTS> (<COMMENTS>characters</COMMENTS>) <COMMENTS>and</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>take</COMMENTS>
        # <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>additional</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>added</COMMENTS>?
        my $<CODE>packed_columns</CODE> = <CODE>token_sequence_length</CODE>( $<CODE>i_opening_paren</CODE> + 1,
            $<CODE>i_effective_last_comma</CODE> + 1 );
        if ( $<CODE>columns</CODE> <= 0 ) { $<CODE>columns</CODE> = 1 }    # <COMMENTS>avoid</COMMENTS> <COMMENTS>divide</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>zero</COMMENTS>
        my $<CODE>packed_lines</CODE> = 1 + int( $<CODE>packed_columns</CODE> / $<CODE>columns</CODE> );

        # <COMMENTS>are</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>contained</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>outer</COMMENTS> <COMMENTS>list</COMMENTS>?
        my $<CODE>in_hierarchical_list</CODE> = $<CODE>next_nonblank_type</CODE> =~ /^[\}\,]$/;

        if ( $<CODE>number_of_fields</CODE> <= 0 ) {

#         #---------------------------------------------------------------
#         # <COMMENTS>We</COMMENTS>'<COMMENTS>re</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>trouble</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>width</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>works</COMMENTS>.
#         # <COMMENTS>There</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>answer</COMMENTS> <COMMENTS>here</COMMENTS>; <COMMENTS>we</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>list</COMMENTS>
#         # <COMMENTS>item</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>many</COMMENTS>.
#         #---------------------------------------------------------------
#
#         <COMMENTS>In</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>cases</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>one</COMMENTS>
#         <COMMENTS>comma</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>better</COMMENTS>
#         <COMMENTS>job</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>it</COMMENTS>.
#
#         <COMMENTS>In</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>terms</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>fit</COMMENTS>
#         <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>better</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>the</COMMENTS>
#         <COMMENTS>containing</COMMENTS> <COMMENTS>parens</COMMENTS>.  <COMMENTS>Consider</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>
#
#             <COMMENTS>$color</COMMENTS> =
#               <COMMENTS>join</COMMENTS> ( '/',
#                 <COMMENTS>sort</COMMENTS> { <COMMENTS>$color_value</COMMENTS>{<COMMENTS>$</COMMENTS>::<COMMENTS>a</COMMENTS>} <=> <COMMENTS>$color_value</COMMENTS>{<COMMENTS>$</COMMENTS>::<COMMENTS>b</COMMENTS>}; }
#                 <COMMENTS>keys</COMMENTS> %<COMMENTS>colors</COMMENTS> );
#
#         <COMMENTS>which</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>broken</COMMENTS>:
#
#             <COMMENTS>$color</COMMENTS> = <COMMENTS>join</COMMENTS> (
#                 '/',
#                 <COMMENTS>sort</COMMENTS> { <COMMENTS>$color_value</COMMENTS>{<COMMENTS>$</COMMENTS>::<COMMENTS>a</COMMENTS>} <=> <COMMENTS>$color_value</COMMENTS>{<COMMENTS>$</COMMENTS>::<COMMENTS>b</COMMENTS>}; } <COMMENTS>keys</COMMENTS> %<COMMENTS>colors</COMMENTS>
#             );
#
#         <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>term</COMMENTS>:
#
#             <COMMENTS>log_message</COMMENTS>( <COMMENTS>0</COMMENTS>, <COMMENTS>256</COMMENTS>, <COMMENTS>128</COMMENTS>,
#                 "<COMMENTS>Number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>routes</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>adj</COMMENTS>-<COMMENTS>RIB</COMMENTS>-<COMMENTS>in</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>considered</COMMENTS>: <COMMENTS>$peercount</COMMENTS>" );
#
#         <COMMENTS>And</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>term</COMMENTS>:
#
#         <COMMENTS>$s</COMMENTS> = <COMMENTS>sprintf</COMMENTS>(
# "%<COMMENTS>2d</COMMENTS> <COMMENTS>wallclock</COMMENTS> <COMMENTS>secs</COMMENTS> (%<COMMENTS>$f</COMMENTS> <COMMENTS>usr</COMMENTS> %<COMMENTS>$f</COMMENTS> <COMMENTS>sys</COMMENTS> + %<COMMENTS>$f</COMMENTS> <COMMENTS>cusr</COMMENTS> %<COMMENTS>$f</COMMENTS> <COMMENTS>csys</COMMENTS> = %<COMMENTS>$f</COMMENTS> <COMMENTS>CPU</COMMENTS>)",
#             <COMMENTS>$r</COMMENTS>, <COMMENTS>$pu</COMMENTS>, <COMMENTS>$ps</COMMENTS>, <COMMENTS>$cu</COMMENTS>, <COMMENTS>$cs</COMMENTS>, <COMMENTS>$tt</COMMENTS>
#           )
#           <COMMENTS>if</COMMENTS> <COMMENTS>$style</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>all</COMMENTS>';

            my $<CODE>i_last_comma</CODE> = $$<CODE>rcomma_index</CODE>[ $<CODE>comma_count</CODE> - 1 ];
            my $<CODE>long_last_term</CODE> = <CODE>excess_line_length</CODE>( 0, $<CODE>i_last_comma</CODE> ) <= 0;
            my $<CODE>long_first_term</CODE> =
              <CODE>excess_line_length</CODE>( $<CODE>i_first_comma</CODE> + 1, $<CODE>max_index_to_go</CODE> ) <= 0;

            # <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>every</COMMENTS> <COMMENTS>comma</COMMENTS> ...
            if (

                # <COMMENTS>if</COMMENTS> <COMMENTS>requested</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>looking</COMMENTS>
                $<CODE>number_of_fields_best</CODE> == 1

                # <COMMENTS>or</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sublist</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>larger</COMMENTS> <COMMENTS>list</COMMENTS>
                || $<CODE>in_hierarchical_list</CODE>

                # <COMMENTS>or</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>last</COMMENTS>
                # <COMMENTS>term</COMMENTS>
                || ( $<CODE>comma_count</CODE> > 1
                    && !( $<CODE>long_last_term</CODE> || $<CODE>long_first_term</CODE> ) )
              )
            {
                foreach ( 0 .. $<CODE>comma_count</CODE> - 1 ) {
                    <CODE>set_forced_breakpoint</CODE>( $$<CODE>rcomma_index</CODE>[$<CODE>_</CODE>] );
                }
            }
            elsif ($<CODE>long_last_term</CODE>) {

                <CODE>set_forced_breakpoint</CODE>($<CODE>i_last_comma</CODE>);
                $$<CODE>rdo_not_break_apart</CODE> = 1 unless $<CODE>must_break_open</CODE>;
            }
            elsif ($<CODE>long_first_term</CODE>) {

                <CODE>set_forced_breakpoint</CODE>($<CODE>i_first_comma</CODE>);
            }
            else {

                # <COMMENTS>let</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>logic</COMMENTS>
            }
            return;
        }

        # --------------------------------------------------------
        # <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>tentative</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>work</COMMENTS>.
        # <COMMENTS>How</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>require</COMMENTS>?
        # --------------------------------------------------------
        my $<CODE>formatted_lines</CODE> = $<CODE>item_count</CODE> / ($<CODE>number_of_fields</CODE>);
        if ( $<CODE>formatted_lines</CODE> != int $<CODE>formatted_lines</CODE> ) {
            $<CODE>formatted_lines</CODE> = 1 + int $<CODE>formatted_lines</CODE>;
        }

        # <COMMENTS>So</COMMENTS> <COMMENTS>far</COMMENTS> <COMMENTS>we</COMMENTS>'<COMMENTS>ve</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>trying</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>fill</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>margin</COMMENTS>.  <COMMENTS>But</COMMENTS>
        # <COMMENTS>compact</COMMENTS> <COMMENTS>tables</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>easier</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>read</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>let</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>fewer</COMMENTS>
        # <COMMENTS>fields</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>increasing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS>.
        $<CODE>number_of_fields</CODE> =
          <CODE>compactify_table</CODE>( $<CODE>item_count</CODE>, $<CODE>number_of_fields</CODE>, $<CODE>formatted_lines</CODE>,
            $<CODE>odd_or_even</CODE> );

        # <COMMENTS>How</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>across</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>page</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>fill</COMMENTS>?
        my $<CODE>columns_per_line</CODE> =
          ( int $<CODE>number_of_fields</CODE> / 2 ) * $<CODE>pair_width</CODE> +
          ( $<CODE>number_of_fields</CODE> % 2 ) * $<CODE>max_width</CODE>;

        my $<CODE>formatted_columns</CODE>;

        if ( $<CODE>number_of_fields</CODE> > 1 ) {
            $<CODE>formatted_columns</CODE> =
              ( $<CODE>pair_width</CODE> * ( int( $<CODE>item_count</CODE> / 2 ) ) +
                  ( $<CODE>item_count</CODE> % 2 ) * $<CODE>max_width</CODE> );
        }
        else {
            $<CODE>formatted_columns</CODE> = $<CODE>max_width</CODE> * $<CODE>item_count</CODE>;
        }
        if ( $<CODE>formatted_columns</CODE> < $<CODE>packed_columns</CODE> ) {
            $<CODE>formatted_columns</CODE> = $<CODE>packed_columns</CODE>;
        }

        my $<CODE>unused_columns</CODE> = $<CODE>formatted_columns</CODE> - $<CODE>packed_columns</CODE>;

        # <COMMENTS>set</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>empirical</COMMENTS> <COMMENTS>parameters</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>help</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS>
        # <COMMENTS>align</COMMENTS>; <COMMENTS>high</COMMENTS> <COMMENTS>sparsity</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>good</COMMENTS>, <COMMENTS>especially</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>few</COMMENTS> <COMMENTS>lines</COMMENTS>
        my $<CODE>sparsity</CODE> = ($<CODE>unused_columns</CODE>) / ($<CODE>formatted_columns</CODE>);
        my $<CODE>max_allowed_sparsity</CODE> =
            ( $<CODE>item_count</CODE> < 3 )    ? 0.1
          : ( $<CODE>packed_lines</CODE> == 1 ) ? 0.15
          : ( $<CODE>packed_lines</CODE> == 2 ) ? 0.4
          :                          0.7;

        # <COMMENTS>Begin</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>shortcut</COMMENTS> <COMMENTS>methods</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>treating</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS>
        # <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>relatively</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>parenthesized</COMMENTS> <COMMENTS>lists</COMMENTS>.  <COMMENTS>These</COMMENTS>
        # <COMMENTS>are</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>easier</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>read</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>formatted</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>tables</COMMENTS>.
        if (
            $<CODE>packed_lines</CODE> <= 2                    # <COMMENTS>probably</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>fit</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>lines</COMMENTS>
            && $<CODE>item_count</CODE> < 9                    # <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>items</COMMENTS>
            && $<CODE>opening_environment</CODE> eq '<LITERALS>BLOCK</LITERALS>'    # <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS>-<COMMENTS>container</COMMENTS>
            && $<CODE>opening_token</CODE> eq '('              # <COMMENTS>is</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>list</COMMENTS>
          )
        {

            # <COMMENTS>Shortcut</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>1</COMMENTS>: <COMMENTS>for</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>comma</COMMENTS>:
            # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>no</COMMENTS>-<COMMENTS>brainer</COMMENTS>, <COMMENTS>just</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>comma</COMMENTS>.
            if (
                $<CODE>rOpts_line_up_parentheses</CODE>    # -<COMMENTS>lp</COMMENTS>
                && $<CODE>item_count</CODE> == 2           # <COMMENTS>two</COMMENTS> <COMMENTS>items</COMMENTS>, <COMMENTS>one</COMMENTS> <COMMENTS>comma</COMMENTS>
                && !$<CODE>must_break_open</CODE>
              )
            {
                my $<CODE>i_break</CODE> = $$<CODE>rcomma_index</CODE>[0];
                <CODE>set_forced_breakpoint</CODE>($<CODE>i_break</CODE>);
                $$<CODE>rdo_not_break_apart</CODE> = 1;
                <CODE>set_non_alignment_flags</CODE>( $<CODE>comma_count</CODE>, $<CODE>rcomma_index</CODE> );
                return;

            }

            # <COMMENTS>method</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>ragged</COMMENTS> <COMMENTS>lists</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>look</COMMENTS>
            # <COMMENTS>best</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>displayed</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>table</COMMENTS>.
            if (
                ( $<CODE>number_of_fields</CODE> == 2 && $<CODE>item_count</CODE> == 3 )
                || (
                    $<CODE>new_identifier_count</CODE> > 0    # <COMMENTS>isn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>quotes</COMMENTS>
                    && $<CODE>sparsity</CODE> > 0.15
                )    # <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>fairly</COMMENTS> <COMMENTS>spaced</COMMENTS> <COMMENTS>gaps</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>aligned</COMMENTS>
              )
            {

                my $<CODE>break_count</CODE> = <CODE>set_ragged_breakpoints</CODE>( \@<CODE>i_term_comma</CODE>,
                    $<CODE>ri_ragged_break_list</CODE> );
                ++$<CODE>break_count</CODE> if ($<CODE>use_separate_first_term</CODE>);

                # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>true</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>here</COMMENTS>,
                # <COMMENTS>which</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>greater</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>large</COMMENTS> <COMMENTS>terms</COMMENTS> <COMMENTS>and</COMMENTS>
                # <COMMENTS>little</COMMENTS> <COMMENTS>space</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>well</COMMENTS> <COMMENTS>enough</COMMENTS>.
                unless ($<CODE>must_break_open</CODE>) {

                    if ( $<CODE>break_count</CODE> <= 1 ) {
                        $$<CODE>rdo_not_break_apart</CODE> = 1;
                    }
                    elsif ( $<CODE>rOpts_line_up_parentheses</CODE> && !$<CODE>need_lp_break_open</CODE> )
                    {
                        $$<CODE>rdo_not_break_apart</CODE> = 1;
                    }
                }
                <CODE>set_non_alignment_flags</CODE>( $<CODE>comma_count</CODE>, $<CODE>rcomma_index</CODE> );
                return;
            }

        }    # <COMMENTS>end</COMMENTS> <COMMENTS>shortcut</COMMENTS> <COMMENTS>methods</COMMENTS>

        # <COMMENTS>debug</COMMENTS> <COMMENTS>stuff</COMMENTS>

        <CODE>FORMATTER_DEBUG_FLAG_SPARSE</CODE> && do {
            print <CODE>STDOUT</CODE>
"<LITERALS>SPARSE</LITERALS>:<LITERALS>cols</LITERALS>=$<CODE>columns</CODE> <LITERALS>commas</LITERALS>=$<CODE>comma_count</CODE> <LITERALS>items</LITERALS>:$<CODE>item_count</CODE> <LITERALS>ids</LITERALS>=$<CODE>identifier_count</CODE> <LITERALS>pairwidth</LITERALS>=$<CODE>pair_width</CODE> <LITERALS>fields</LITERALS>=$<CODE>number_of_fields</CODE> <LITERALS>lines</LITERALS> <LITERALS>packed</LITERALS>: $<CODE>packed_lines</CODE> <LITERALS>packed_cols</LITERALS>=$<CODE>packed_columns</CODE> <LITERALS>fmtd</LITERALS>:$<CODE>formatted_lines</CODE> <LITERALS>cols</LITERALS> /<LITERALS>line</LITERALS>:$<CODE>columns_per_line</CODE>  <LITERALS>unused</LITERALS>:$<CODE>unused_columns</CODE> <LITERALS>fmtd</LITERALS>:$<CODE>formatted_columns</CODE> <LITERALS>sparsity</LITERALS>=$<CODE>sparsity</CODE> <LITERALS>allow</LITERALS>=$<CODE>max_allowed_sparsity</CODE>\n";

        };

        #---------------------------------------------------------------
        # <COMMENTS>Compound</COMMENTS> <COMMENTS>List</COMMENTS> <COMMENTS>Rule</COMMENTS> <COMMENTS>2</COMMENTS>:
        # <COMMENTS>If</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS>
        # <COMMENTS>larger</COMMENTS> <COMMENTS>list</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>format</COMMENTS> <COMMENTS>it</COMMENTS>, <COMMENTS>regardless</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>sparsity</COMMENTS>
        # (<COMMENTS>ian</COMMENTS>.<COMMENTS>t</COMMENTS>).  <COMMENTS>One</COMMENTS> <COMMENTS>reason</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>trigger</COMMENTS>
        # <COMMENTS>Compound</COMMENTS> <COMMENTS>List</COMMENTS> <COMMENTS>Rule</COMMENTS> <COMMENTS>1</COMMENTS>, <COMMENTS>above</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>causes</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>of</COMMENTS>
        # <COMMENTS>all</COMMENTS> <COMMENTS>outer</COMMENTS> <COMMENTS>lists</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>way</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>structure</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>properly</COMMENTS>
        # <COMMENTS>displayed</COMMENTS>.
        #---------------------------------------------------------------

        # <COMMENTS>Decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>broken</COMMENTS>
        my $<CODE>total_columns</CODE> = <CODE>table_columns_available</CODE>($<CODE>i_opening_paren</CODE>);
        my $<CODE>too_long</CODE>      = $<CODE>packed_columns</CODE> > $<CODE>total_columns</CODE>;

        # <COMMENTS>For</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>list</COMMENTS>, <COMMENTS>include</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS>
        # '(' <COMMENTS>because</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>likely</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>call</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS>
        # <COMMENTS>include</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>still</COMMENTS>
        # <COMMENTS>imprecise</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>bad</COMMENTS>.  (<COMMENTS>steve</COMMENTS>.<COMMENTS>t</COMMENTS>)
        if ( !$<CODE>too_long</CODE> && $<CODE>i_opening_paren</CODE> > 0 && $<CODE>opening_token</CODE> eq '(' ) {

            $<CODE>too_long</CODE> = <CODE>excess_line_length</CODE>( $<CODE>i_opening_minus</CODE>,
                $<CODE>i_effective_last_comma</CODE> + 1 ) > 0;
        }

        # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>For</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> '=>', <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>include</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>thing</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> '=>'.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>crude</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>improved</COMMENTS> <COMMENTS>by</COMMENTS>
        # <COMMENTS>actually</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>token</COMMENTS>.
        if ( !$<CODE>too_long</CODE> && $<CODE>i_opening_paren</CODE> > 0 && $<CODE>list_type</CODE> eq '=>' ) {
            my $<CODE>i_opening_minus</CODE> = $<CODE>i_opening_paren</CODE> - 4;
            if ( $<CODE>i_opening_minus</CODE> >= 0 ) {
                $<CODE>too_long</CODE> = <CODE>excess_line_length</CODE>( $<CODE>i_opening_minus</CODE>,
                    $<CODE>i_effective_last_comma</CODE> + 1 ) > 0;
            }
        }

        # <COMMENTS>Always</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>lists</COMMENTS> <COMMENTS>contained</COMMENTS> <COMMENTS>in</COMMENTS> '[' <COMMENTS>and</COMMENTS> '{' <COMMENTS>if</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>line</COMMENTS>,
        # <COMMENTS>and</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>lists</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>part</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>complex</COMMENTS>
        # <COMMENTS>structure</COMMENTS>.
        my $<CODE>must_break_open_container</CODE> = $<CODE>must_break_open</CODE>
          || ( $<CODE>too_long</CODE>
            && ( $<CODE>in_hierarchical_list</CODE> || $<CODE>opening_token</CODE> ne '(' ) );

#<COMMENTS>print</COMMENTS> "<COMMENTS>LISTX</COMMENTS>: <COMMENTS>next</COMMENTS>=<COMMENTS>$next_nonblank_type</COMMENTS>  <COMMENTS>avail</COMMENTS> <COMMENTS>cols</COMMENTS>=<COMMENTS>$columns</COMMENTS> <COMMENTS>packed</COMMENTS>=<COMMENTS>$packed_columns</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>format</COMMENTS> = <COMMENTS>$must_break_open_container</COMMENTS> <COMMENTS>too</COMMENTS>-<COMMENTS>long</COMMENTS>=<COMMENTS>$too_long</COMMENTS>  <COMMENTS>opening</COMMENTS>=<COMMENTS>$opening_token</COMMENTS> <COMMENTS>list_type</COMMENTS>=<COMMENTS>$list_type</COMMENTS> <COMMENTS>formatted_lines</COMMENTS>=<COMMENTS>$formatted_lines</COMMENTS>  <COMMENTS>packed</COMMENTS>=<COMMENTS>$packed_lines</COMMENTS> <COMMENTS>max_sparsity</COMMENTS>= <COMMENTS>$max_allowed_sparsity</COMMENTS> <COMMENTS>sparsity</COMMENTS>=<COMMENTS>$sparsity</COMMENTS> \<COMMENTS>n</COMMENTS>";

        #---------------------------------------------------------------
        # <COMMENTS>The</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>decision</COMMENTS>:
        # <COMMENTS>Now</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>data</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>aligned</COMMENTS> <COMMENTS>columns</COMMENTS>.  <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS>
        # <COMMENTS>attempt</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>columns</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>tiny</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS>
        # <COMMENTS>too</COMMENTS> <COMMENTS>spaced</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>packed</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS>, <COMMENTS>the</COMMENTS>
        # <COMMENTS>sparser</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>allowed</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>ok</COMMENTS>.
        #---------------------------------------------------------------

        if (   ( $<CODE>formatted_lines</CODE> < 3 && $<CODE>packed_lines</CODE> < $<CODE>formatted_lines</CODE> )
            || ( $<CODE>formatted_lines</CODE> < 2 )
            || ( $<CODE>unused_columns</CODE> > $<CODE>max_allowed_sparsity</CODE> * $<CODE>formatted_columns</CODE> )
          )
        {

            #---------------------------------------------------------------
            # <COMMENTS>too</COMMENTS> <COMMENTS>sparse</COMMENTS>: <COMMENTS>would</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>ugly</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>aligned</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>table</COMMENTS>;
            #---------------------------------------------------------------

            # <COMMENTS>use</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>big</COMMENTS>' <COMMENTS>list</COMMENTS>
            # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>goal</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>improve</COMMENTS> <COMMENTS>set_ragged_breakpoints</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS>
            # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>necessary</COMMENTS>.
            if ( $<CODE>packed_lines</CODE> > 2 && $<CODE>item_count</CODE> > 10 ) {
                <CODE>write_logfile_entry</CODE>("<LITERALS>List</LITERALS> <LITERALS>sparse</LITERALS>: <LITERALS>using</LITERALS> <LITERALS>old</LITERALS> <LITERALS>breakpoints</LITERALS>\n");
                <CODE>copy_old_breakpoints</CODE>( $<CODE>i_first_comma</CODE>, $<CODE>i_last_comma</CODE> );
            }

            # <COMMENTS>let</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>lines</COMMENTS>
            else {

                my $<CODE>break_count</CODE> = <CODE>set_ragged_breakpoints</CODE>( \@<CODE>i_term_comma</CODE>,
                    $<CODE>ri_ragged_break_list</CODE> );
                ++$<CODE>break_count</CODE> if ($<CODE>use_separate_first_term</CODE>);

                unless ($<CODE>must_break_open_container</CODE>) {
                    if ( $<CODE>break_count</CODE> <= 1 ) {
                        $$<CODE>rdo_not_break_apart</CODE> = 1;
                    }
                    elsif ( $<CODE>rOpts_line_up_parentheses</CODE> && !$<CODE>need_lp_break_open</CODE> )
                    {
                        $$<CODE>rdo_not_break_apart</CODE> = 1;
                    }
                }
                <CODE>set_non_alignment_flags</CODE>( $<CODE>comma_count</CODE>, $<CODE>rcomma_index</CODE> );
            }
            return;
        }

        #---------------------------------------------------------------
        # <COMMENTS>go</COMMENTS> <COMMENTS>ahead</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>format</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>table</COMMENTS>
        #---------------------------------------------------------------
        <CODE>write_logfile_entry</CODE>(
            "<LITERALS>List</LITERALS>: <LITERALS>auto</LITERALS> <LITERALS>formatting</LITERALS> <LITERALS>with</LITERALS> $<CODE>number_of_fields</CODE> <LITERALS>fields</LITERALS>/<LITERALS>row</LITERALS>\n");

        my $<CODE>j_first_break</CODE> =
          $<CODE>use_separate_first_term</CODE> ? $<CODE>number_of_fields</CODE> : $<CODE>number_of_fields</CODE> - 1;

        for (
            my $<CODE>j</CODE> = $<CODE>j_first_break</CODE> ;
            $<CODE>j</CODE> < $<CODE>comma_count</CODE> ;
            $<CODE>j</CODE> += $<CODE>number_of_fields</CODE>
          )
        {
            my $<CODE>i</CODE> = $$<CODE>rcomma_index</CODE>[$<CODE>j</CODE>];
            <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>);
        }
        return;
    }
}

sub <CODE>set_non_alignment_flags</CODE> {

    # <COMMENTS>set</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>indicates</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>aligned</COMMENTS>
    my ( $<CODE>comma_count</CODE>, $<CODE>rcomma_index</CODE> ) = @<CODE>_</CODE>;
    foreach ( 0 .. $<CODE>comma_count</CODE> - 1 ) {
        $<CODE>matching_token_to_go</CODE>[ $$<CODE>rcomma_index</CODE>[$<CODE>_</CODE>] ] = 1;
    }
}

sub <CODE>study_list_complexity</CODE> {

    # <COMMENTS>Look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>complex</COMMENTS> <COMMENTS>tables</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>formatted</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>per</COMMENTS> <COMMENTS>line</COMMENTS>.
    # <COMMENTS>Returns</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>:
    #
    #  \@<COMMENTS>i_ragged_break_list</COMMENTS> = <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>lines</COMMENTS>
    #    <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>hard</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>read</COMMENTS>
    #  <COMMENTS>$number_of_fields_best</COMMENTS> = <COMMENTS>suggested</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>based</COMMENTS> <COMMENTS>on</COMMENTS>
    #    <COMMENTS>complexity</COMMENTS>; = <COMMENTS>0</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS>.
    #
    my ( $<CODE>ri_term_begin</CODE>, $<CODE>ri_term_end</CODE>, $<CODE>ritem_lengths</CODE>, $<CODE>max_width</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>item_count</CODE>            = @{$<CODE>ri_term_begin</CODE>};
    my $<CODE>complex_item_count</CODE>    = 0;
    my $<CODE>number_of_fields_best</CODE> = $<CODE>rOpts_maximum_fields_per_table</CODE>;
    my $<CODE>i_max</CODE>                 = @{$<CODE>ritem_lengths</CODE>} - 1;
    ##<COMMENTS>my</COMMENTS> @<COMMENTS>item_complexity</COMMENTS>;

    my $<CODE>i_last_last_break</CODE> = -3;
    my $<CODE>i_last_break</CODE>      = -2;
    my @<CODE>i_ragged_break_list</CODE>;

    my $<CODE>definitely_complex</CODE> = 30;
    my $<CODE>definitely_simple</CODE>  = 12;
    my $<CODE>quote_count</CODE>        = 0;

    for my $<CODE>i</CODE> ( 0 .. $<CODE>i_max</CODE> ) {
        my $<CODE>ib</CODE> = $<CODE>ri_term_begin</CODE>->[$<CODE>i</CODE>];
        my $<CODE>ie</CODE> = $<CODE>ri_term_end</CODE>->[$<CODE>i</CODE>];

        # <COMMENTS>define</COMMENTS> <COMMENTS>complexity</COMMENTS>: <COMMENTS>start</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>length</COMMENTS>
        my $<CODE>weighted_length</CODE> = ( $<CODE>ritem_lengths</CODE>->[$<CODE>i</CODE>] - 2 );

        ##<COMMENTS>TBD</COMMENTS>: <COMMENTS>join</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>variations</COMMENTS>
        ##<COMMENTS>my</COMMENTS> <COMMENTS>$str</COMMENTS>=<COMMENTS>join</COMMENTS> "", @<COMMENTS>tokens_to_go</COMMENTS>[<COMMENTS>$ib</COMMENTS>..<COMMENTS>$ie</COMMENTS>];

        my $<CODE>is_quote</CODE> = 0;
        if ( $<CODE>types_to_go</CODE>[$<CODE>ib</CODE>] =~ /^[qQ]$/ ) {
            $<CODE>is_quote</CODE> = 1;
            $<CODE>quote_count</CODE>++;
        }
        elsif ( $<CODE>types_to_go</CODE>[$<CODE>ib</CODE>] =~ /^[w\-]$/ ) {
            $<CODE>quote_count</CODE>++;
        }

        if ( $<CODE>ib</CODE> eq $<CODE>ie</CODE> ) {
            if ( $<CODE>is_quote</CODE> && $<CODE>tokens_to_go</CODE>[$<CODE>ib</CODE>] =~ /\s/ ) {
                $<CODE>complex_item_count</CODE>++;
                $<CODE>weighted_length</CODE> *= 2;
            }
            else {
            }
        }
        else {
            if ( grep { $<CODE>_</CODE> eq '<LITERALS>b</LITERALS>' } @<CODE>types_to_go</CODE>[ $<CODE>ib</CODE> .. $<CODE>ie</CODE> ] ) {
                $<CODE>complex_item_count</CODE>++;
                $<CODE>weighted_length</CODE> *= 2;
            }
            if ( grep { $<CODE>_</CODE> eq '..' } @<CODE>types_to_go</CODE>[ $<CODE>ib</CODE> .. $<CODE>ie</CODE> ] ) {
                $<CODE>weighted_length</CODE> += 4;
            }
        }

        # <COMMENTS>add</COMMENTS> <COMMENTS>weight</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>tokens</COMMENTS>.
        $<CODE>weighted_length</CODE> += 2 * ( $<CODE>ie</CODE> - $<CODE>ib</CODE> );

##        <COMMENTS>my</COMMENTS> <COMMENTS>$BUB</COMMENTS> = <COMMENTS>join</COMMENTS> '', @<COMMENTS>tokens_to_go</COMMENTS>[<COMMENTS>$ib</COMMENTS>..<COMMENTS>$ie</COMMENTS>];
##        <COMMENTS>print</COMMENTS> "# <COMMENTS>COMPLEXITY</COMMENTS>:<COMMENTS>$weighted_length</COMMENTS>   <COMMENTS>$BUB</COMMENTS>\<COMMENTS>n</COMMENTS>";

##<COMMENTS>push</COMMENTS> @<COMMENTS>item_complexity</COMMENTS>, <COMMENTS>$weighted_length</COMMENTS>;

        # <COMMENTS>now</COMMENTS> <COMMENTS>mark</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>ragged</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> '<COMMENTS>long</COMMENTS> <COMMENTS>and</COMMENTS>
        # <COMMENTS>complex</COMMENTS>':
        if ( $<CODE>weighted_length</CODE> >= $<CODE>definitely_complex</CODE> ) {

            # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>broke</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>term</COMMENTS>
            # <COMMENTS>then</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>too</COMMENTS>
            if (   $<CODE>i_last_break</CODE> == $<CODE>i</CODE> - 1
                && $<CODE>i</CODE> > 1
                && $<CODE>i_last_last_break</CODE> != $<CODE>i</CODE> - 2 )
            {

                ## <COMMENTS>FIXME</COMMENTS>: <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>strand</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>term</COMMENTS>
                pop @<CODE>i_ragged_break_list</CODE>;
                push @<CODE>i_ragged_break_list</CODE>, $<CODE>i</CODE> - 2;
                push @<CODE>i_ragged_break_list</CODE>, $<CODE>i</CODE> - 1;
            }

            push @<CODE>i_ragged_break_list</CODE>, $<CODE>i</CODE>;
            $<CODE>i_last_last_break</CODE> = $<CODE>i_last_break</CODE>;
            $<CODE>i_last_break</CODE>      = $<CODE>i</CODE>;
        }

        # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>term</COMMENTS> -- <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS>
        # <COMMENTS>not</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>itself</COMMENTS>.
        elsif ($<CODE>i</CODE> == $<CODE>i_max</CODE>
            && $<CODE>i_last_break</CODE> == $<CODE>i</CODE> - 1
            && $<CODE>weighted_length</CODE> <= $<CODE>definitely_simple</CODE> )
        {
            pop @<CODE>i_ragged_break_list</CODE>;
        }
    }

    my $<CODE>identifier_count</CODE> = $<CODE>i_max</CODE> + 1 - $<CODE>quote_count</CODE>;

    # <COMMENTS>Need</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>tuning</COMMENTS> <COMMENTS>here</COMMENTS>..
    if (   $<CODE>max_width</CODE> > 12
        && $<CODE>complex_item_count</CODE> > $<CODE>item_count</CODE> / 2
        && $<CODE>number_of_fields_best</CODE> != 2 )
    {
        $<CODE>number_of_fields_best</CODE> = 1;
    }

    return ( $<CODE>number_of_fields_best</CODE>, \@<CODE>i_ragged_break_list</CODE>, $<CODE>identifier_count</CODE> );
}

sub <CODE>get_maximum_fields_wanted</CODE> {

    # <COMMENTS>Not</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tables</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>items</COMMENTS>.
    # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>decides</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>formatted</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>not</COMMENTS>.
    # <COMMENTS>This</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>under</COMMENTS> <COMMENTS>development</COMMENTS>.
    my ($<CODE>ritem_lengths</CODE>) = @<CODE>_</CODE>;

    my $<CODE>number_of_fields_best</CODE> = 0;

    # <COMMENTS>For</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>few</COMMENTS> <COMMENTS>items</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>tentatively</COMMENTS> <COMMENTS>assume</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>field</COMMENTS>.
    my $<CODE>item_count</CODE> = @{$<CODE>ritem_lengths</CODE>};
    if ( $<CODE>item_count</CODE> <= 5 ) {
        $<CODE>number_of_fields_best</CODE> = 1;
    }

    # <COMMENTS>For</COMMENTS> <COMMENTS>larger</COMMENTS> <COMMENTS>tables</COMMENTS>, <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>ways</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>best</COMMENTS>
    else {

        my $<CODE>is_odd</CODE>            = 1;
        my @<CODE>max_length</CODE>        = ( 0, 0 );
        my @<CODE>last_length_2</CODE>     = ( undef, undef );
        my @<CODE>first_length_2</CODE>    = ( undef, undef );
        my $<CODE>last_length</CODE>       = undef;
        my $<CODE>total_variation_1</CODE> = 0;
        my $<CODE>total_variation_2</CODE> = 0;
        my @<CODE>total_variation_2</CODE> = ( 0, 0 );
        for ( my $<CODE>j</CODE> = 0 ; $<CODE>j</CODE> < $<CODE>item_count</CODE> ; $<CODE>j</CODE>++ ) {

            $<CODE>is_odd</CODE> = 1 - $<CODE>is_odd</CODE>;
            my $<CODE>length</CODE> = $<CODE>ritem_lengths</CODE>->[$<CODE>j</CODE>];
            if ( $<CODE>length</CODE> > $<CODE>max_length</CODE>[$<CODE>is_odd</CODE>] ) {
                $<CODE>max_length</CODE>[$<CODE>is_odd</CODE>] = $<CODE>length</CODE>;
            }

            if ( defined($<CODE>last_length</CODE>) ) {
                my $<CODE>dl</CODE> = abs( $<CODE>length</CODE> - $<CODE>last_length</CODE> );
                $<CODE>total_variation_1</CODE> += $<CODE>dl</CODE>;
            }
            $<CODE>last_length</CODE> = $<CODE>length</CODE>;

            my $<CODE>ll</CODE> = $<CODE>last_length_2</CODE>[$<CODE>is_odd</CODE>];
            if ( defined($<CODE>ll</CODE>) ) {
                my $<CODE>dl</CODE> = abs( $<CODE>length</CODE> - $<CODE>ll</CODE> );
                $<CODE>total_variation_2</CODE>[$<CODE>is_odd</CODE>] += $<CODE>dl</CODE>;
            }
            else {
                $<CODE>first_length_2</CODE>[$<CODE>is_odd</CODE>] = $<CODE>length</CODE>;
            }
            $<CODE>last_length_2</CODE>[$<CODE>is_odd</CODE>] = $<CODE>length</CODE>;
        }
        $<CODE>total_variation_2</CODE> = $<CODE>total_variation_2</CODE>[0] + $<CODE>total_variation_2</CODE>[1];

        my $<CODE>factor</CODE> = ( $<CODE>item_count</CODE> > 10 ) ? 1 : ( $<CODE>item_count</CODE> > 5 ) ? 0.75 : 0;
        unless ( $<CODE>total_variation_2</CODE> < $<CODE>factor</CODE> * $<CODE>total_variation_1</CODE> ) {
            $<CODE>number_of_fields_best</CODE> = 1;
        }
    }
    return ($<CODE>number_of_fields_best</CODE>);
}

sub <CODE>table_columns_available</CODE> {
    my $<CODE>i_first_comma</CODE> = shift;
    my $<CODE>columns</CODE> =
      <CODE>maximum_line_length</CODE>($<CODE>i_first_comma</CODE>) -
      <CODE>leading_spaces_to_go</CODE>($<CODE>i_first_comma</CODE>);

    # <COMMENTS>Patch</COMMENTS>: <COMMENTS>the</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>formatter</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>whose</COMMENTS> <COMMENTS>lengths</COMMENTS>
    # <COMMENTS>exactly</COMMENTS> <COMMENTS>equal</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>available</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>allowances</COMMENTS>
    # <COMMENTS>that</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>made</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>.  <COMMENTS>Therefore</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS>
    # <COMMENTS>available</COMMENTS> <COMMENTS>columns</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>reduced</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>character</COMMENTS>.
    $<CODE>columns</CODE> -= 1;
    return $<CODE>columns</CODE>;
}

sub <CODE>maximum_number_of_fields</CODE> {

    # <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>fit</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>available</COMMENTS> <COMMENTS>space</COMMENTS>?
    my ( $<CODE>columns</CODE>, $<CODE>odd_or_even</CODE>, $<CODE>max_width</CODE>, $<CODE>pair_width</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>max_pairs</CODE>        = int( $<CODE>columns</CODE> / $<CODE>pair_width</CODE> );
    my $<CODE>number_of_fields</CODE> = $<CODE>max_pairs</CODE> * 2;
    if (   $<CODE>odd_or_even</CODE> == 1
        && $<CODE>max_pairs</CODE> * $<CODE>pair_width</CODE> + $<CODE>max_width</CODE> <= $<CODE>columns</CODE> )
    {
        $<CODE>number_of_fields</CODE>++;
    }
    return $<CODE>number_of_fields</CODE>;
}

sub <CODE>compactify_table</CODE> {

    # <COMMENTS>given</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>number</COMMENTS>
    # <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS>, <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>reducing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>look</COMMENTS>
    # <COMMENTS>better</COMMENTS>.
    my ( $<CODE>item_count</CODE>, $<CODE>number_of_fields</CODE>, $<CODE>formatted_lines</CODE>, $<CODE>odd_or_even</CODE> ) = @<CODE>_</CODE>;
    if ( $<CODE>number_of_fields</CODE> >= $<CODE>odd_or_even</CODE> * 2 && $<CODE>formatted_lines</CODE> > 0 ) {
        my $<CODE>min_fields</CODE>;

        for (
            $<CODE>min_fields</CODE> = $<CODE>number_of_fields</CODE> ;
            $<CODE>min_fields</CODE> >= $<CODE>odd_or_even</CODE>
            && $<CODE>min_fields</CODE> * $<CODE>formatted_lines</CODE> >= $<CODE>item_count</CODE> ;
            $<CODE>min_fields</CODE> -= $<CODE>odd_or_even</CODE>
          )
        {
            $<CODE>number_of_fields</CODE> = $<CODE>min_fields</CODE>;
        }
    }
    return $<CODE>number_of_fields</CODE>;
}

sub <CODE>set_ragged_breakpoints</CODE> {

    # <COMMENTS>Set</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>cannot</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>formatted</COMMENTS> <COMMENTS>nicely</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS>
    # <COMMENTS>table</COMMENTS>.
    my ( $<CODE>ri_term_comma</CODE>, $<CODE>ri_ragged_break_list</CODE> ) = @<CODE>_</CODE>;

    my $<CODE>break_count</CODE> = 0;
    foreach (@$<CODE>ri_ragged_break_list</CODE>) {
        my $<CODE>j</CODE> = $<CODE>ri_term_comma</CODE>->[$<CODE>_</CODE>];
        if ($<CODE>j</CODE>) {
            <CODE>set_forced_breakpoint</CODE>($<CODE>j</CODE>);
            $<CODE>break_count</CODE>++;
        }
    }
    return $<CODE>break_count</CODE>;
}

sub <CODE>copy_old_breakpoints</CODE> {
    my ( $<CODE>i_first_comma</CODE>, $<CODE>i_last_comma</CODE> ) = @<CODE>_</CODE>;
    for my $<CODE>i</CODE> ( $<CODE>i_first_comma</CODE> .. $<CODE>i_last_comma</CODE> ) {
        if ( $<CODE>old_breakpoint_to_go</CODE>[$<CODE>i</CODE>] ) {
            <CODE>set_forced_breakpoint</CODE>($<CODE>i</CODE>);
        }
    }
}

sub <CODE>set_nobreaks</CODE> {
    my ( $<CODE>i</CODE>, $<CODE>j</CODE> ) = @<CODE>_</CODE>;
    if ( $<CODE>i</CODE> >= 0 && $<CODE>i</CODE> <= $<CODE>j</CODE> && $<CODE>j</CODE> <= $<CODE>max_index_to_go</CODE> ) {

        <CODE>FORMATTER_DEBUG_FLAG_NOBREAK</CODE> && do {
            my ( $<CODE>a</CODE>, $<CODE>b</CODE>, $<CODE>c</CODE> ) = caller();
            print <CODE>STDOUT</CODE>
"<LITERALS>NOBREAK</LITERALS>: <LITERALS>forced_breakpoint</LITERALS> $<CODE>forced_breakpoint_count</CODE> <LITERALS>from</LITERALS> $<CODE>a</CODE> $<CODE>c</CODE> <LITERALS>with</LITERALS> <LITERALS>i</LITERALS>=$<CODE>i</CODE> <LITERALS>max</LITERALS>=$<CODE>max_index_to_go</CODE> <LITERALS>type</LITERALS>=$<CODE>types_to_go</CODE>[$<CODE>i</CODE>]\n";
        };

        @<CODE>nobreak_to_go</CODE>[ $<CODE>i</CODE> .. $<CODE>j</CODE> ] = (1) x ( $<CODE>j</CODE> - $<CODE>i</CODE> + 1 );
    }

    # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>; <COMMENTS>non</COMMENTS>-<COMMENTS>critical</COMMENTS> <COMMENTS>error</COMMENTS>
    else {
        <CODE>FORMATTER_DEBUG_FLAG_NOBREAK</CODE> && do {
            my ( $<CODE>a</CODE>, $<CODE>b</CODE>, $<CODE>c</CODE> ) = caller();
            print <CODE>STDOUT</CODE>
              "<LITERALS>NOBREAK</LITERALS> <LITERALS>ERROR</LITERALS>: <LITERALS>from</LITERALS> $<CODE>a</CODE> $<CODE>c</CODE> <LITERALS>with</LITERALS> <LITERALS>i</LITERALS>=$<CODE>i</CODE> <LITERALS>j</LITERALS>=$<CODE>j</CODE> <LITERALS>max</LITERALS>=$<CODE>max_index_to_go</CODE>\n";
        };
    }
}

sub <CODE>set_fake_breakpoint</CODE> {

    # <COMMENTS>Just</COMMENTS> <COMMENTS>bump</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>breakpoint</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>signal</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>breaks</COMMENTS>.
    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>useful</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>postpone</COMMENTS> <COMMENTS>deciding</COMMENTS> <COMMENTS>where</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>them</COMMENTS>.
    $<CODE>forced_breakpoint_count</CODE>++;
}

sub <CODE>set_forced_breakpoint</CODE> {
    my $<CODE>i</CODE> = shift;

    return unless defined $<CODE>i</CODE> && $<CODE>i</CODE> >= 0;

    # <COMMENTS>when</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>use</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strengths</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>decide</COMMENTS>
    # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>it</COMMENTS>
    my $<CODE>token</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>];

    if ( $<CODE>token</CODE> =~ /^([\=\.\,\:\?]|and|or|xor|&&|\|\|)$/ ) {
        if ( $<CODE>want_break_before</CODE>{$<CODE>token</CODE>} && $<CODE>i</CODE> >= 0 ) { $<CODE>i</CODE>-- }
    }

    # <COMMENTS>breaks</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>forced</COMMENTS> <COMMENTS>before</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>unless</COMMENTS>'
    elsif ( $<CODE>is_if_unless</CODE>{$<CODE>token</CODE>} ) { $<CODE>i</CODE>-- }

    if ( $<CODE>i</CODE> >= 0 && $<CODE>i</CODE> <= $<CODE>max_index_to_go</CODE> ) {
        my $<CODE>i_nonblank</CODE> = ( $<CODE>types_to_go</CODE>[$<CODE>i</CODE>] ne '<LITERALS>b</LITERALS>' ) ? $<CODE>i</CODE> : $<CODE>i</CODE> - 1;

        <CODE>FORMATTER_DEBUG_FLAG_FORCE</CODE> && do {
            my ( $<CODE>a</CODE>, $<CODE>b</CODE>, $<CODE>c</CODE> ) = caller();
            print <CODE>STDOUT</CODE>
"<LITERALS>FORCE</LITERALS> $<CODE>forced_breakpoint_count</CODE> <LITERALS>from</LITERALS> $<CODE>a</CODE> $<CODE>c</CODE> <LITERALS>with</LITERALS> <LITERALS>i</LITERALS>=$<CODE>i_nonblank</CODE> <LITERALS>max</LITERALS>=$<CODE>max_index_to_go</CODE> <LITERALS>tok</LITERALS>=$<CODE>tokens_to_go</CODE>[$<CODE>i_nonblank</CODE>] <LITERALS>type</LITERALS>=$<CODE>types_to_go</CODE>[$<CODE>i_nonblank</CODE>] <LITERALS>nobr</LITERALS>=$<CODE>nobreak_to_go</CODE>[$<CODE>i_nonblank</CODE>]\n";
        };

        if ( $<CODE>i_nonblank</CODE> >= 0 && $<CODE>nobreak_to_go</CODE>[$<CODE>i_nonblank</CODE>] == 0 ) {
            $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>i_nonblank</CODE>] = 1;

            if ( $<CODE>i_nonblank</CODE> > $<CODE>index_max_forced_break</CODE> ) {
                $<CODE>index_max_forced_break</CODE> = $<CODE>i_nonblank</CODE>;
            }
            $<CODE>forced_breakpoint_count</CODE>++;
            $<CODE>forced_breakpoint_undo_stack</CODE>[ $<CODE>forced_breakpoint_undo_count</CODE>++ ] =
              $<CODE>i_nonblank</CODE>;

            # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>container</COMMENTS>..<COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS>
            if ( $<CODE>tokens_to_go</CODE>[$<CODE>i_nonblank</CODE>] =~ /^[\{\[\(\?]$/ ) {
                <CODE>set_closing_breakpoint</CODE>($<CODE>i_nonblank</CODE>);
            }
        }
    }
}

sub <CODE>clear_breakpoint_undo_stack</CODE> {
    $<CODE>forced_breakpoint_undo_count</CODE> = 0;
}

sub <CODE>undo_forced_breakpoint_stack</CODE> {

    my $<CODE>i_start</CODE> = shift;
    if ( $<CODE>i_start</CODE> < 0 ) {
        $<CODE>i_start</CODE> = 0;
        my ( $<CODE>a</CODE>, $<CODE>b</CODE>, $<CODE>c</CODE> ) = caller();
        <CODE>warning</CODE>(
"<LITERALS>Program</LITERALS> <LITERALS>Bug</LITERALS>: <LITERALS>undo_forced_breakpoint_stack</LITERALS> <LITERALS>from</LITERALS> $<CODE>a</CODE> $<CODE>c</CODE> <LITERALS>has</LITERALS> <LITERALS>i</LITERALS>=$<CODE>i_start</CODE> "
        );
    }

    while ( $<CODE>forced_breakpoint_undo_count</CODE> > $<CODE>i_start</CODE> ) {
        my $<CODE>i</CODE> =
          $<CODE>forced_breakpoint_undo_stack</CODE>[ --$<CODE>forced_breakpoint_undo_count</CODE> ];
        if ( $<CODE>i</CODE> >= 0 && $<CODE>i</CODE> <= $<CODE>max_index_to_go</CODE> ) {
            $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>i</CODE>] = 0;
            $<CODE>forced_breakpoint_count</CODE>--;

            <CODE>FORMATTER_DEBUG_FLAG_UNDOBP</CODE> && do {
                my ( $<CODE>a</CODE>, $<CODE>b</CODE>, $<CODE>c</CODE> ) = caller();
                print <CODE>STDOUT</CODE>
"<LITERALS>UNDOBP</LITERALS>: <LITERALS>undo</LITERALS> <LITERALS>forced_breakpoint</LITERALS> <LITERALS>i</LITERALS>=$<CODE>i</CODE> $<CODE>forced_breakpoint_undo_count</CODE> <LITERALS>from</LITERALS> $<CODE>a</CODE> $<CODE>c</CODE> <LITERALS>max</LITERALS>=$<CODE>max_index_to_go</CODE>\n";
            };
        }

        # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>critical</COMMENTS> <COMMENTS>error</COMMENTS>
        else {
            <CODE>FORMATTER_DEBUG_FLAG_UNDOBP</CODE> && do {
                my ( $<CODE>a</CODE>, $<CODE>b</CODE>, $<CODE>c</CODE> ) = caller();
                print <CODE>STDOUT</CODE>
"<LITERALS>Program</LITERALS> <LITERALS>Bug</LITERALS>: <LITERALS>undo_forced_breakpoint</LITERALS> <LITERALS>from</LITERALS> $<CODE>a</CODE> $<CODE>c</CODE> <LITERALS>has</LITERALS> <LITERALS>i</LITERALS>=$<CODE>i</CODE> <LITERALS>but</LITERALS> <LITERALS>max</LITERALS>=$<CODE>max_index_to_go</CODE>";
            };
        }
    }
}

{    # <COMMENTS>begin</COMMENTS> <COMMENTS>recombine_breakpoints</COMMENTS>

    my %<CODE>is_amp_amp</CODE>;
    my %<CODE>is_ternary</CODE>;
    my %<CODE>is_math_op</CODE>;
    my %<CODE>is_plus_minus</CODE>;
    my %<CODE>is_mult_div</CODE>;

    <CODE>BEGIN</CODE> {

        @<CODE>_</CODE> = qw( && || );
        @<CODE>is_amp_amp</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

        @<CODE>_</CODE> = qw( ? : );
        @<CODE>is_ternary</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

        @<CODE>_</CODE> = qw( + - * / );
        @<CODE>is_math_op</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

        @<CODE>_</CODE> = qw( + - );
        @<CODE>is_plus_minus</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

        @<CODE>_</CODE> = qw( * / );
        @<CODE>is_mult_div</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);
    }

    sub <CODE>DUMP_BREAKPOINTS</CODE> {

        # <COMMENTS>Debug</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>dump</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>breakpoints</COMMENTS>...<COMMENTS>not</COMMENTS> <COMMENTS>normally</COMMENTS> <COMMENTS>called</COMMENTS>
        # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>lines</COMMENTS>:
        # <COMMENTS>$ri_beg</COMMENTS> = <COMMENTS>ref</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>BEGinning</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS>
        # <COMMENTS>$ri_end</COMMENTS> = <COMMENTS>ref</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>ENDing</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS>
        my ( $<CODE>ri_beg</CODE>, $<CODE>ri_end</CODE>, $<CODE>msg</CODE> ) = @<CODE>_</CODE>;
        print <CODE>STDERR</CODE> "----<LITERALS>Dumping</LITERALS> <LITERALS>breakpoints</LITERALS> <LITERALS>from</LITERALS>: $<CODE>msg</CODE>----\n";
        for my $<CODE>n</CODE> ( 0 .. @{$<CODE>ri_end</CODE>} - 1 ) {
            my $<CODE>ibeg</CODE> = $$<CODE>ri_beg</CODE>[$<CODE>n</CODE>];
            my $<CODE>iend</CODE> = $$<CODE>ri_end</CODE>[$<CODE>n</CODE>];
            my $<CODE>text</CODE> = "";
            foreach my $<CODE>i</CODE> ( $<CODE>ibeg</CODE> .. $<CODE>iend</CODE> ) {
                $<CODE>text</CODE> .= $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>];
            }
            print <CODE>STDERR</CODE> "$<CODE>n</CODE> ($<CODE>ibeg</CODE>:$<CODE>iend</CODE>) $<CODE>text</CODE>\n";
        }
        print <CODE>STDERR</CODE> "----\n";
    }

    sub <CODE>recombine_breakpoints</CODE> {

        # <COMMENTS>sub</COMMENTS> <COMMENTS>set_continuation_breaks</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>liberal</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>setting</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>breaks</COMMENTS>
        # <COMMENTS>for</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>lines</COMMENTS>, <COMMENTS>always</COMMENTS> <COMMENTS>setting</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>breakpoints</COMMENTS>, <COMMENTS>even</COMMENTS>
        # <COMMENTS>when</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>creates</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>lines</COMMENTS>.  <COMMENTS>Sometimes</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>fragments</COMMENTS>
        # <COMMENTS>are</COMMENTS> <COMMENTS>produced</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>better</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>combined</COMMENTS>.
        # <COMMENTS>That</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>task</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS>.
        #
        # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>lines</COMMENTS>:
        # <COMMENTS>$ri_beg</COMMENTS> = <COMMENTS>ref</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>BEGinning</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS>
        # <COMMENTS>$ri_end</COMMENTS> = <COMMENTS>ref</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>ENDing</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS>
        my ( $<CODE>ri_beg</CODE>, $<CODE>ri_end</CODE> ) = @<CODE>_</CODE>;

        # <COMMENTS>Make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>joining</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>lines</COMMENTS>
        # <COMMENTS>n</COMMENTS>-<COMMENTS>1</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>n</COMMENTS>.
        my @<CODE>joint</CODE>;
        my $<CODE>nmax</CODE> = @$<CODE>ri_end</CODE> - 1;
        for my $<CODE>n</CODE> ( 1 .. $<CODE>nmax</CODE> ) {
            my $<CODE>ibeg_1</CODE> = $$<CODE>ri_beg</CODE>[ $<CODE>n</CODE> - 1 ];
            my $<CODE>iend_1</CODE> = $$<CODE>ri_end</CODE>[ $<CODE>n</CODE> - 1 ];
            my $<CODE>iend_2</CODE> = $$<CODE>ri_end</CODE>[$<CODE>n</CODE>];
            my $<CODE>ibeg_2</CODE> = $$<CODE>ri_beg</CODE>[$<CODE>n</CODE>];

            my ( $<CODE>itok</CODE>, $<CODE>itokp</CODE>, $<CODE>itokm</CODE> );

            foreach my $<CODE>itest</CODE> ( $<CODE>iend_1</CODE>, $<CODE>ibeg_2</CODE> ) {
                my $<CODE>type</CODE> = $<CODE>types_to_go</CODE>[$<CODE>itest</CODE>];
                if (   $<CODE>is_math_op</CODE>{$<CODE>type</CODE>}
                    || $<CODE>is_amp_amp</CODE>{$<CODE>type</CODE>}
                    || $<CODE>is_assignment</CODE>{$<CODE>type</CODE>}
                    || $<CODE>type</CODE> eq ':' )
                {
                    $<CODE>itok</CODE> = $<CODE>itest</CODE>;
                }
            }
            $<CODE>joint</CODE>[$<CODE>n</CODE>] = [$<CODE>itok</CODE>];
        }

        my $<CODE>more_to_do</CODE> = 1;

        # <COMMENTS>We</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>looping</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
        # <COMMENTS>until</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>recombinations</COMMENTS>
        my $<CODE>nmax_last</CODE> = @$<CODE>ri_end</CODE>;
        while ($<CODE>more_to_do</CODE>) {
            my $<CODE>n_best</CODE> = 0;
            my $<CODE>bs_best</CODE>;
            my $<CODE>n</CODE>;
            my $<CODE>nmax</CODE> = @$<CODE>ri_end</CODE> - 1;

            # <COMMENTS>Safety</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>infinite</COMMENTS> <COMMENTS>loop</COMMENTS>
            unless ( $<CODE>nmax</CODE> < $<CODE>nmax_last</CODE> ) {

                # <COMMENTS>Shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>splice</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>decreases</COMMENTS> <COMMENTS>nmax</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>each</COMMENTS>
                # <COMMENTS>pass</COMMENTS>.
                <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Die</CODE>
                  "<LITERALS>Program</LITERALS> <LITERALS>bug</LITERALS>-<LITERALS>infinite</LITERALS> <LITERALS>loop</LITERALS> <LITERALS>in</LITERALS> <LITERALS>recombine</LITERALS> <LITERALS>breakpoints</LITERALS>\n";
            }
            $<CODE>nmax_last</CODE>  = $<CODE>nmax</CODE>;
            $<CODE>more_to_do</CODE> = 0;
            my $<CODE>previous_outdentable_closing_paren</CODE>;
            my $<CODE>leading_amp_count</CODE> = 0;
            my $<CODE>this_line_is_semicolon_terminated</CODE>;

            # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>remaining</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>batch</COMMENTS>
            for $<CODE>n</CODE> ( 1 .. $<CODE>nmax</CODE> ) {

                #----------------------------------------------------------
                # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>pair</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS>,
                # <COMMENTS>line</COMMENTS> <COMMENTS>$n</COMMENTS>-<COMMENTS>1</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>become</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>part</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>joined</COMMENTS> <COMMENTS>line</COMMENTS>
                # <COMMENTS>line</COMMENTS> <COMMENTS>$n</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>become</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>part</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>joined</COMMENTS> <COMMENTS>line</COMMENTS>
                #
                # <COMMENTS>Here</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>Indexes</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>endpoint</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS>:
                #
                #  -----<COMMENTS>line</COMMENTS> <COMMENTS>$n</COMMENTS>-<COMMENTS>1</COMMENTS>--- | -----<COMMENTS>line</COMMENTS> <COMMENTS>$n</COMMENTS>-----
                #  <COMMENTS>$ibeg_1</COMMENTS>   <COMMENTS>$iend_1</COMMENTS> | <COMMENTS>$ibeg_2</COMMENTS>   <COMMENTS>$iend_2</COMMENTS>
                #                    ^
                #                    |
                # <COMMENTS>We</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>break</COMMENTS>
                # <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>$iend_1</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>$ibeg_2</COMMENTS>
                #
                # <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>apply</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>ad</COMMENTS>-<COMMENTS>hoc</COMMENTS> <COMMENTS>tests</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>joining</COMMENTS>
                # <COMMENTS>here</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>ok</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>issue</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>next</COMMENTS>'
                # <COMMENTS>command</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>good</COMMENTS>.  <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>through</COMMENTS>
                # <COMMENTS>the</COMMENTS> <COMMENTS>gauntlet</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tests</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>recombined</COMMENTS>.
                #----------------------------------------------------------
                #
                # <COMMENTS>beginning</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>working</COMMENTS> <COMMENTS>on</COMMENTS>
                my $<CODE>ibeg_1</CODE>    = $$<CODE>ri_beg</CODE>[ $<CODE>n</CODE> - 1 ];
                my $<CODE>iend_1</CODE>    = $$<CODE>ri_end</CODE>[ $<CODE>n</CODE> - 1 ];
                my $<CODE>iend_2</CODE>    = $$<CODE>ri_end</CODE>[$<CODE>n</CODE>];
                my $<CODE>ibeg_2</CODE>    = $$<CODE>ri_beg</CODE>[$<CODE>n</CODE>];
                my $<CODE>ibeg_nmax</CODE> = $$<CODE>ri_beg</CODE>[$<CODE>nmax</CODE>];

                my $<CODE>type_iend_1</CODE> = $<CODE>types_to_go</CODE>[$<CODE>iend_1</CODE>];
                my $<CODE>type_iend_2</CODE> = $<CODE>types_to_go</CODE>[$<CODE>iend_2</CODE>];
                my $<CODE>type_ibeg_1</CODE> = $<CODE>types_to_go</CODE>[$<CODE>ibeg_1</CODE>];
                my $<CODE>type_ibeg_2</CODE> = $<CODE>types_to_go</CODE>[$<CODE>ibeg_2</CODE>];

                # <COMMENTS>some</COMMENTS> <COMMENTS>beginning</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>lines</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>exist</COMMENTS>
                my $<CODE>ibeg_0</CODE> = $<CODE>n</CODE> > 1          ? $$<CODE>ri_beg</CODE>[ $<CODE>n</CODE> - 2 ] : -1;
                my $<CODE>ibeg_3</CODE> = $<CODE>n</CODE> < $<CODE>nmax</CODE>      ? $$<CODE>ri_beg</CODE>[ $<CODE>n</CODE> + 1 ] : -1;
                my $<CODE>ibeg_4</CODE> = $<CODE>n</CODE> + 2 <= $<CODE>nmax</CODE> ? $$<CODE>ri_beg</CODE>[ $<CODE>n</CODE> + 2 ] : -1;

                my $<CODE>bs_tweak</CODE> = 0;

                #<COMMENTS>my</COMMENTS> <COMMENTS>$depth_increase</COMMENTS>=( <COMMENTS>$nesting_depth_to_go</COMMENTS>[<COMMENTS>$ibeg_2</COMMENTS>] -
                #        <COMMENTS>$nesting_depth_to_go</COMMENTS>[<COMMENTS>$ibeg_1</COMMENTS>] );

                <CODE>FORMATTER_DEBUG_FLAG_RECOMBINE</CODE> && do {
                    print <CODE>STDERR</CODE>
"<LITERALS>RECOMBINE</LITERALS>: <LITERALS>n</LITERALS>=$<CODE>n</CODE> <LITERALS>imid</LITERALS>=$<CODE>iend_1</CODE> <LITERALS>if</LITERALS>=$<CODE>ibeg_1</CODE> <LITERALS>type</LITERALS>=$<CODE>type_ibeg_1</CODE> =$<CODE>tokens_to_go</CODE>[$<CODE>ibeg_1</CODE>] <LITERALS>next_type</LITERALS>=$<CODE>type_ibeg_2</CODE> <LITERALS>next_tok</LITERALS>=$<CODE>tokens_to_go</CODE>[$<CODE>ibeg_2</CODE>]\n";
                };

                # <COMMENTS>If</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>$n</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>and</COMMENTS>
                # <COMMENTS>do</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>checks</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>it</COMMENTS>
                if ( $<CODE>n</CODE> == $<CODE>nmax</CODE> ) {

                    # <COMMENTS>a</COMMENTS> <COMMENTS>terminal</COMMENTS> '{' <COMMENTS>should</COMMENTS> <COMMENTS>stay</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS>
                    next if $<CODE>type_ibeg_2</CODE> eq '{';

                    # <COMMENTS>set</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>$n</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> ';'
                    $<CODE>this_line_is_semicolon_terminated</CODE> = $<CODE>type_iend_2</CODE> eq ';'

                      # <COMMENTS>with</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
                      || ( $<CODE>type_iend_2</CODE> eq '#'
                        && $<CODE>iend_2</CODE> - $<CODE>ibeg_2</CODE> >= 2
                        && $<CODE>types_to_go</CODE>[ $<CODE>iend_2</CODE> - 2 ] eq ';'
                        && $<CODE>types_to_go</CODE>[ $<CODE>iend_2</CODE> - 1 ] eq '<LITERALS>b</LITERALS>' );
                }

                #----------------------------------------------------------
                # <COMMENTS>Recombine</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>1</COMMENTS>:
                # <COMMENTS>Examine</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>joining</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>pair</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS>.
                # <COMMENTS>Put</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>tests</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>duplicate</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>and</COMMENTS>
                # <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>formatting</COMMENTS> <COMMENTS>independent</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>whether</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS>
                # <COMMENTS>left</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS>.
                #----------------------------------------------------------

                my ($<CODE>itok</CODE>) = @{ $<CODE>joint</CODE>[$<CODE>n</CODE>] };
                if ($<CODE>itok</CODE>) {

                    # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>Patch</COMMENTS> - <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>necessary</COMMENTS>
                    my $<CODE>iend_1</CODE> =
                        $<CODE>type_iend_1</CODE> eq '<LITERALS>b</LITERALS>'
                      ? $<CODE>iend_1</CODE> - 1
                      : $<CODE>iend_1</CODE>;

                    my $<CODE>iend_2</CODE> =
                        $<CODE>type_iend_2</CODE> eq '<LITERALS>b</LITERALS>'
                      ? $<CODE>iend_2</CODE> - 1
                      : $<CODE>iend_2</CODE>;
                    ## <COMMENTS>END</COMMENTS> <COMMENTS>PATCH</COMMENTS>

                    my $<CODE>type</CODE> = $<CODE>types_to_go</CODE>[$<CODE>itok</CODE>];

                    if ( $<CODE>type</CODE> eq ':' ) {

                   # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>colon</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>disobeys</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>request</COMMENTS>
                        if ( $<CODE>itok</CODE> eq $<CODE>iend_1</CODE> ) {
                            next unless $<CODE>want_break_before</CODE>{$<CODE>type</CODE>};
                        }
                        else {
                            $<CODE>leading_amp_count</CODE>++;
                            next if $<CODE>want_break_before</CODE>{$<CODE>type</CODE>};
                        }
                    } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ':'

                    # <COMMENTS>handle</COMMENTS> <COMMENTS>math</COMMENTS> <COMMENTS>operators</COMMENTS> + - * /
                    elsif ( $<CODE>is_math_op</CODE>{$<CODE>type</CODE>} ) {

                        # <COMMENTS>Combine</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS>
                        # <COMMENTS>number</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>same</COMMENTS>
                        # <COMMENTS>operator</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>in</COMMENTS>
                        # <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS>
                        # <COMMENTS>short</COMMENTS> <COMMENTS>terms</COMMENTS> <COMMENTS>$A</COMMENTS>, <COMMENTS>$B</COMMENTS>, <COMMENTS>$C</COMMENTS>, <COMMENTS>$D</COMMENTS>, <COMMENTS>$E</COMMENTS>, <COMMENTS>$F</COMMENTS>, <COMMENTS>together</COMMENTS>
                        # <COMMENTS>instead</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>leaving</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>per</COMMENTS> <COMMENTS>line</COMMENTS>:
                        #  <COMMENTS>my</COMMENTS> <COMMENTS>$time</COMMENTS> =
                        #    <COMMENTS>$A</COMMENTS> * <COMMENTS>$B</COMMENTS> * <COMMENTS>$C</COMMENTS> * <COMMENTS>$D</COMMENTS> * <COMMENTS>$E</COMMENTS> * <COMMENTS>$F</COMMENTS> *
                        #    ( <COMMENTS>2</COMMENTS>. * <COMMENTS>$eps</COMMENTS> * <COMMENTS>$sigma</COMMENTS> * <COMMENTS>$area</COMMENTS> ) *
                        #    ( <COMMENTS>1</COMMENTS>. / <COMMENTS>$tcold</COMMENTS>**<COMMENTS>3</COMMENTS> - <COMMENTS>1</COMMENTS>. / <COMMENTS>$thot</COMMENTS>**<COMMENTS>3</COMMENTS> );

                        # <COMMENTS>This</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>important</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>math</COMMENTS>-<COMMENTS>intensive</COMMENTS> <COMMENTS>code</COMMENTS>.

                        my $<CODE>good_combo</CODE>;

                        my $<CODE>itokp</CODE>  = <CODE>min</CODE>( $<CODE>inext_to_go</CODE>[$<CODE>itok</CODE>],  $<CODE>iend_2</CODE> );
                        my $<CODE>itokpp</CODE> = <CODE>min</CODE>( $<CODE>inext_to_go</CODE>[$<CODE>itokp</CODE>], $<CODE>iend_2</CODE> );
                        my $<CODE>itokm</CODE>  = <CODE>max</CODE>( $<CODE>iprev_to_go</CODE>[$<CODE>itok</CODE>],  $<CODE>ibeg_1</CODE> );
                        my $<CODE>itokmm</CODE> = <CODE>max</CODE>( $<CODE>iprev_to_go</CODE>[$<CODE>itokm</CODE>], $<CODE>ibeg_1</CODE> );

                        # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS>
                        if ( $<CODE>types_to_go</CODE>[$<CODE>itokp</CODE>] eq '<LITERALS>n</LITERALS>' ) {

                            # <COMMENTS>ok</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>nothing</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>right</COMMENTS>
                            if ( $<CODE>itokp</CODE> == $<CODE>iend_2</CODE> ) {
                                $<CODE>good_combo</CODE> = 1;
                            }
                            else {

                                # <COMMENTS>look</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>right</COMMENTS>..
                                # <COMMENTS>okay</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>math</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>termination</COMMENTS>
                                $<CODE>good_combo</CODE> =
                                  ( ( $<CODE>itokpp</CODE> == $<CODE>iend_2</CODE> )
                                      && $<CODE>is_math_op</CODE>{ $<CODE>types_to_go</CODE>[$<CODE>itokpp</CODE>] } )
                                  || $<CODE>types_to_go</CODE>[$<CODE>itokpp</CODE>] =~ /^[#,;]$/;
                            }
                        }

                        # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS>
                        if ( !$<CODE>good_combo</CODE> && $<CODE>types_to_go</CODE>[$<CODE>itokm</CODE>] eq '<LITERALS>n</LITERALS>' ) {

                            # <COMMENTS>okay</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>nothing</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>left</COMMENTS>
                            if ( $<CODE>itokm</CODE> == $<CODE>ibeg_1</CODE> ) {
                                $<CODE>good_combo</CODE> = 1;
                            }

                            # <COMMENTS>otherwise</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>left</COMMENTS>
                            else {

                                # <COMMENTS>okay</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>math</COMMENTS> <COMMENTS>operator</COMMENTS>, <COMMENTS>comma</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>assignment</COMMENTS>
                                $<CODE>good_combo</CODE> = ( $<CODE>itokmm</CODE> == $<CODE>ibeg_1</CODE> )
                                  && ( $<CODE>is_math_op</CODE>{ $<CODE>types_to_go</CODE>[$<CODE>itokmm</CODE>] }
                                    || $<CODE>types_to_go</CODE>[$<CODE>itokmm</CODE>] =~ /^[,]$/
                                    || $<CODE>is_assignment</CODE>{ $<CODE>types_to_go</CODE>[$<CODE>itokmm</CODE>] }
                                  );
                            }
                        }

                        # <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS>
                        # <COMMENTS>operator</COMMENTS>
                        if ( !$<CODE>good_combo</CODE> ) {

                            # <COMMENTS>Slight</COMMENTS> <COMMENTS>adjustment</COMMENTS> <COMMENTS>factor</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>results</COMMENTS>
                            # <COMMENTS>independent</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>in</COMMENTS>
                            # <COMMENTS>long</COMMENTS> <COMMENTS>summed</COMMENTS> <COMMENTS>lists</COMMENTS>.  (<COMMENTS>An</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>make</COMMENTS>
                            # <COMMENTS>two</COMMENTS> <COMMENTS>spaces</COMMENTS>).
                            my $<CODE>two</CODE> = ( $<CODE>itok</CODE> eq $<CODE>iend_1</CODE> ) ? 2 : 0;

                            $<CODE>good_combo</CODE> =

                              # <COMMENTS>numbers</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>id</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>sides</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>joint</COMMENTS>
                              $<CODE>types_to_go</CODE>[$<CODE>itokp</CODE>] =~ /^[in]$/
                              && $<CODE>types_to_go</CODE>[$<CODE>itokm</CODE>] =~ /^[in]$/

                              # <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>short</COMMENTS>:
                              && (
                                (
                                    # <COMMENTS>no</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>of</COMMENTS>
                                    # <COMMENTS>joint</COMMENTS>
                                    $<CODE>itokpp</CODE> == $<CODE>iend_2</CODE>

                                    # <COMMENTS>short</COMMENTS>
                                    && <CODE>token_sequence_length</CODE>( $<CODE>itokp</CODE>, $<CODE>iend_2</CODE> )
                                    < $<CODE>two</CODE> +
                                    $<CODE>rOpts_short_concatenation_item_length</CODE>
                                )
                                || (
                                    # <COMMENTS>no</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>of</COMMENTS>
                                    # <COMMENTS>joint</COMMENTS>
                                    $<CODE>itokmm</CODE> == $<CODE>ibeg_1</CODE>

                                    # <COMMENTS>short</COMMENTS>
                                    && <CODE>token_sequence_length</CODE>( $<CODE>ibeg_1</CODE>, $<CODE>itokm</CODE> )
                                    < 2 - $<CODE>two</CODE> +
                                    $<CODE>rOpts_short_concatenation_item_length</CODE>
                                )

                              )

                              # <COMMENTS>keep</COMMENTS> <COMMENTS>pure</COMMENTS> <COMMENTS>terms</COMMENTS>; <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>mix</COMMENTS> +- <COMMENTS>with</COMMENTS> */
                              && !(
                                $<CODE>is_plus_minus</CODE>{$<CODE>type</CODE>}
                                && (   $<CODE>is_mult_div</CODE>{ $<CODE>types_to_go</CODE>[$<CODE>itokmm</CODE>] }
                                    || $<CODE>is_mult_div</CODE>{ $<CODE>types_to_go</CODE>[$<CODE>itokpp</CODE>] } )
                              )
                              && !(
                                $<CODE>is_mult_div</CODE>{$<CODE>type</CODE>}
                                && (   $<CODE>is_plus_minus</CODE>{ $<CODE>types_to_go</CODE>[$<CODE>itokmm</CODE>] }
                                    || $<CODE>is_plus_minus</CODE>{ $<CODE>types_to_go</CODE>[$<CODE>itokpp</CODE>] } )
                              )

                              ;
                        }

                        # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>reduce</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>lines</COMMENTS>
                        if ( !$<CODE>good_combo</CODE> ) {

                            # <COMMENTS>index</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS>
                            # <COMMENTS>long</COMMENTS> <COMMENTS>chain</COMMENTS>.
                            my $<CODE>iother</CODE> =
                              ( $<CODE>itok</CODE> == $<CODE>iend_1</CODE> ) ? $<CODE>iend_2</CODE> : $<CODE>ibeg_1</CODE>;

                            $<CODE>good_combo</CODE> =
                                 $<CODE>n</CODE> == 2
                              && $<CODE>n</CODE> == $<CODE>nmax</CODE>
                              && $<CODE>types_to_go</CODE>[$<CODE>iother</CODE>] ne $<CODE>type</CODE>;
                        }

                        next unless ($<CODE>good_combo</CODE>);

                    } ## <COMMENTS>end</COMMENTS> <COMMENTS>math</COMMENTS>

                    elsif ( $<CODE>is_amp_amp</CODE>{$<CODE>type</CODE>} ) {
                        ##<COMMENTS>TBD</COMMENTS>
                    } ## <COMMENTS>end</COMMENTS> &&, ||

                    elsif ( $<CODE>is_assignment</CODE>{$<CODE>type</CODE>} ) {
                        ##<COMMENTS>TBD</COMMENTS>
                    } ## <COMMENTS>end</COMMENTS> <COMMENTS>assignment</COMMENTS>
                }

                #----------------------------------------------------------
                # <COMMENTS>Recombine</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>2</COMMENTS>:
                # <COMMENTS>Examine</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>$iend_1</COMMENTS> (<COMMENTS>right</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>pair</COMMENTS>)
                #----------------------------------------------------------

                # <COMMENTS>an</COMMENTS> <COMMENTS>isolated</COMMENTS> '}' <COMMENTS>may</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> ';' <COMMENTS>terminated</COMMENTS> <COMMENTS>segment</COMMENTS>
                if ( $<CODE>type_iend_1</CODE> eq '}' ) {

                    # <COMMENTS>Check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>cases</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>combining</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>semicolon</COMMENTS> <COMMENTS>terminated</COMMENTS>
                    # <COMMENTS>statement</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>isolated</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>will</COMMENTS>
                    # <COMMENTS>allow</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>combined</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>outdented</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS>
                    # <COMMENTS>generally</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>move</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>up</COMMENTS>
                    # <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>here</COMMENTS>:
                    #  (
                    #      <COMMENTS>$dev</COMMENTS>,  <COMMENTS>$ino</COMMENTS>,   <COMMENTS>$mode</COMMENTS>,  <COMMENTS>$nlink</COMMENTS>, <COMMENTS>$uid</COMMENTS>,     <COMMENTS>$gid</COMMENTS>, <COMMENTS>$rdev</COMMENTS>,
                    #      <COMMENTS>$size</COMMENTS>, <COMMENTS>$atime</COMMENTS>, <COMMENTS>$mtime</COMMENTS>, <COMMENTS>$ctime</COMMENTS>, <COMMENTS>$blksize</COMMENTS>, <COMMENTS>$blocks</COMMENTS>
                    #    )
                    #    = <COMMENTS>stat</COMMENTS>(<COMMENTS>$file</COMMENTS>);
                    #
                    # <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS>:
                    #  (
                    #      <COMMENTS>$dev</COMMENTS>,  <COMMENTS>$ino</COMMENTS>,   <COMMENTS>$mode</COMMENTS>,  <COMMENTS>$nlink</COMMENTS>, <COMMENTS>$uid</COMMENTS>,     <COMMENTS>$gid</COMMENTS>, <COMMENTS>$rdev</COMMENTS>,
                    #      <COMMENTS>$size</COMMENTS>, <COMMENTS>$atime</COMMENTS>, <COMMENTS>$mtime</COMMENTS>, <COMMENTS>$ctime</COMMENTS>, <COMMENTS>$blksize</COMMENTS>, <COMMENTS>$blocks</COMMENTS>
                    #  ) = <COMMENTS>stat</COMMENTS>(<COMMENTS>$file</COMMENTS>);
                    #
                    # <COMMENTS>which</COMMENTS> <COMMENTS>makes</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS>.
                    #
                    # <COMMENTS>Another</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>from</COMMENTS> <COMMENTS>Joe</COMMENTS> <COMMENTS>Matarazzo</COMMENTS>, <COMMENTS>probably</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>best</COMMENTS>
                    # <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>or</COMMENTS>' <COMMENTS>clause</COMMENTS> <COMMENTS>appended</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>paren</COMMENTS>:
                    #  <COMMENTS>$self</COMMENTS>-><COMMENTS>some_method</COMMENTS>(
                    #      <COMMENTS>PARAM1</COMMENTS> => '<COMMENTS>foo</COMMENTS>',
                    #      <COMMENTS>PARAM2</COMMENTS> => '<COMMENTS>bar</COMMENTS>'
                    #  ) <COMMENTS>or</COMMENTS> <COMMENTS>die</COMMENTS> "<COMMENTS>Some_method</COMMENTS> <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS>";
                    #
                    # <COMMENTS>But</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>lp</COMMENTS>
                    # <COMMENTS>option</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>outdentable</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS>
                    # <COMMENTS>trailing</COMMENTS> <COMMENTS>clause</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>far</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS>.
                    #
                    # <COMMENTS>The</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>synchronized</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>sub</COMMENTS>
                    # <COMMENTS>sub</COMMENTS> <COMMENTS>set_adjusted_indentation</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>actually</COMMENTS> <COMMENTS>does</COMMENTS>
                    # <COMMENTS>the</COMMENTS> <COMMENTS>outdenting</COMMENTS>.
                    #
                    $<CODE>previous_outdentable_closing_paren</CODE> =
                      $<CODE>this_line_is_semicolon_terminated</CODE>

                      # <COMMENTS>only</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS>
                      && $<CODE>ibeg_1</CODE> == $<CODE>iend_1</CODE>

                      # <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>paren</COMMENTS>
                      && $<CODE>tokens_to_go</CODE>[$<CODE>iend_1</CODE>] eq ')'

                      # <COMMENTS>style</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>outdenting</COMMENTS>,
                      && !$<CODE>closing_token_indentation</CODE>{')'}

                      # <COMMENTS>only</COMMENTS> <COMMENTS>leading</COMMENTS> '&&', '||', <COMMENTS>and</COMMENTS> ':' <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>others</COMMENTS> <COMMENTS>seen</COMMENTS>
                      # (<COMMENTS>but</COMMENTS> <COMMENTS>note</COMMENTS>: <COMMENTS>our</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>made</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>wrong</COMMENTS>
                      # <COMMENTS>due</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>intervening</COMMENTS> <COMMENTS>comments</COMMENTS>)
                      && ( $<CODE>leading_amp_count</CODE> == 0
                        || $<CODE>type_ibeg_2</CODE> !~ /^(:|\&\&|\|\|)$/ )

                      # <COMMENTS>but</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>colons</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS>
                      # <COMMENTS>previous</COMMENTS> <COMMENTS>colon</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>question</COMMENTS> (<COMMENTS>count</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>wrong</COMMENTS>).
                      && $<CODE>type_ibeg_2</CODE> ne ':'

                      # <COMMENTS>only</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>step</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>allowed</COMMENTS>.  <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>not</COMMENTS>
                      # <COMMENTS>begin</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> ')' <COMMENTS>itself</COMMENTS>.
                      && ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>iend_1</CODE>] ==
                        $<CODE>nesting_depth_to_go</CODE>[$<CODE>iend_2</CODE>] + 1 );

                    # <COMMENTS>YVES</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>2</COMMENTS>:
                    # <COMMENTS>Allow</COMMENTS> <COMMENTS>cuddled</COMMENTS> <COMMENTS>eval</COMMENTS> <COMMENTS>chains</COMMENTS>, <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
                    #   <COMMENTS>eval</COMMENTS> {
                    #       #<COMMENTS>STUFF</COMMENTS>;
                    #       <COMMENTS>1</COMMENTS>; # <COMMENTS>return</COMMENTS> <COMMENTS>true</COMMENTS>
                    #   } <COMMENTS>or</COMMENTS> <COMMENTS>do</COMMENTS> {
                    #       #<COMMENTS>handle</COMMENTS> <COMMENTS>error</COMMENTS>
                    #   };
                    # <COMMENTS>This</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>works</COMMENTS> <COMMENTS>together</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>in</COMMENTS>
                    # <COMMENTS>setting</COMMENTS> <COMMENTS>adjusted</COMMENTS> <COMMENTS>indentation</COMMENTS> (<COMMENTS>where</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>eval</COMMENTS>
                    # <COMMENTS>brace</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>outdented</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>possible</COMMENTS>).
                    # <COMMENTS>The</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>an</COMMENTS> '<COMMENTS>eval</COMMENTS>' <COMMENTS>block</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>continuation</COMMENTS>
                    # <COMMENTS>indentation</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>better</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>undo</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>some</COMMENTS>
                    # <COMMENTS>cases</COMMENTS>.  <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>get</COMMENTS>:
                    #   <COMMENTS>eval</COMMENTS> {
                    #       #<COMMENTS>STUFF</COMMENTS>;
                    #       <COMMENTS>1</COMMENTS>; # <COMMENTS>return</COMMENTS> <COMMENTS>true</COMMENTS>
                    #       }
                    #       <COMMENTS>or</COMMENTS> <COMMENTS>do</COMMENTS> {
                    #       #<COMMENTS>handle</COMMENTS> <COMMENTS>error</COMMENTS>
                    #     };
                    # <COMMENTS>The</COMMENTS> <COMMENTS>alternative</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>uncuddled</COMMENTS> <COMMENTS>style</COMMENTS>, <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>create</COMMENTS>
                    # <COMMENTS>a</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>set_adjusted_indentation</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>undoes</COMMENTS>
                    # <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>like</COMMENTS> '<COMMENTS>or</COMMENTS> <COMMENTS>do</COMMENTS> {'.
                    # <COMMENTS>This</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>well</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>icb</COMMENTS> <COMMENTS>through</COMMENTS>
                    if (
                           $<CODE>block_type_to_go</CODE>[$<CODE>iend_1</CODE>] eq '<LITERALS>eval</LITERALS>'
                        && !$<CODE>rOpts</CODE>->{'<LITERALS>line</LITERALS>-<LITERALS>up</LITERALS>-<LITERALS>parentheses</LITERALS>'}
                        && !$<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>closing</LITERALS>-<LITERALS>brace</LITERALS>'}
                        && $<CODE>tokens_to_go</CODE>[$<CODE>iend_2</CODE>] eq '{'
                        && (
                            ( $<CODE>type_ibeg_2</CODE> =~ /^(|\&\&|\|\|)$/ )
                            || (   $<CODE>type_ibeg_2</CODE> eq '<LITERALS>k</LITERALS>'
                                && $<CODE>is_and_or</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_2</CODE>] } )
                            || $<CODE>is_if_unless</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_2</CODE>] }
                        )
                      )
                    {
                        $<CODE>previous_outdentable_closing_paren</CODE> ||= 1;
                    }

                    next
                      unless (
                        $<CODE>previous_outdentable_closing_paren</CODE>

                        # <COMMENTS>handle</COMMENTS> '.' <COMMENTS>and</COMMENTS> '?' <COMMENTS>specially</COMMENTS> <COMMENTS>below</COMMENTS>
                        || ( $<CODE>type_ibeg_2</CODE> =~ /^[\.\?]$/ )
                      );
                }

                # <COMMENTS>YVES</COMMENTS>
                # <COMMENTS>honor</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS>
                # <COMMENTS>Added</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>recombining</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
                #  } || <COMMENTS>eval</COMMENTS> { <COMMENTS>package</COMMENTS> <COMMENTS>main</COMMENTS>;
                elsif ( $<CODE>type_iend_1</CODE> eq '{' ) {
                    next if $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>];
                }

                # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>ending</COMMENTS> &&, ||,
                elsif ( $<CODE>is_amp_amp</CODE>{$<CODE>type_iend_1</CODE>} ) {
                    next unless $<CODE>want_break_before</CODE>{$<CODE>type_iend_1</CODE>};
                }

                # <COMMENTS>Identify</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>broken</COMMENTS> ?/: <COMMENTS>chain</COMMENTS>
                elsif ( $<CODE>type_iend_1</CODE> eq '?' ) {

                    # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>levels</COMMENTS>
                    next
                      if ( $<CODE>levels_to_go</CODE>[$<CODE>ibeg_1</CODE>] ne $<CODE>levels_to_go</CODE>[$<CODE>ibeg_2</CODE>] );

                    # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> :
                    next unless $<CODE>type_iend_2</CODE> eq ':';
                }

                # <COMMENTS>for</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>...
                elsif ( $<CODE>type_iend_1</CODE> eq ',' ) {

                    # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>the</COMMENTS>
                    # <COMMENTS>input</COMMENTS> <COMMENTS>bias</COMMENTS>.
                    # <COMMENTS>TODO</COMMENTS>: <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>flag</COMMENTS>
                    next if ( $<CODE>old_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>] );

                 # <COMMENTS>an</COMMENTS> <COMMENTS>isolated</COMMENTS> '},' <COMMENTS>may</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>identifier</COMMENTS> + ';'
                 # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>useful</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>bless</COMMENTS>' <COMMENTS>statement</COMMENTS> (<COMMENTS>bless</COMMENTS>.<COMMENTS>t</COMMENTS>)
                    if (   $<CODE>type_ibeg_1</CODE> eq '}'
                        && $<CODE>type_ibeg_2</CODE> eq '<LITERALS>i</LITERALS>' )
                    {
                        next
                          unless ( ( $<CODE>ibeg_1</CODE> == ( $<CODE>iend_1</CODE> - 1 ) )
                            && ( $<CODE>iend_2</CODE> == ( $<CODE>ibeg_2</CODE> + 1 ) )
                            && $<CODE>this_line_is_semicolon_terminated</CODE> );

                        # <COMMENTS>override</COMMENTS> <COMMENTS>breakpoint</COMMENTS>
                        $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>] = 0;
                    }

                    # <COMMENTS>but</COMMENTS> <COMMENTS>otherwise</COMMENTS> ..
                    else {

                        # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>leave</COMMENTS>
                        # <COMMENTS>just</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>line</COMMENTS>
                        next unless ( $<CODE>n</CODE> + 1 >= $<CODE>nmax</CODE> );

                    # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>depth</COMMENTS>
                        next
                          if (
                            $<CODE>levels_to_go</CODE>[$<CODE>iend_1</CODE>] != $<CODE>levels_to_go</CODE>[$<CODE>iend_2</CODE>] );

                        # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>a</COMMENTS> "<COMMENTS>complex</COMMENTS> <COMMENTS>expression</COMMENTS>" <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS>
                        # <COMMENTS>comma</COMMENTS>.  "<COMMENTS>complex</COMMENTS>" <COMMENTS>means</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>parens</COMMENTS>.
                        my $<CODE>saw_paren</CODE>;
                        foreach my $<CODE>ii</CODE> ( $<CODE>ibeg_2</CODE> .. $<CODE>iend_2</CODE> ) {
                            if ( $<CODE>tokens_to_go</CODE>[$<CODE>ii</CODE>] eq '(' ) {
                                $<CODE>saw_paren</CODE> = 1;
                                last;
                            }
                        }
                        next if $<CODE>saw_paren</CODE>;
                    }
                }

                # <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS>..
                elsif ( $<CODE>type_iend_1</CODE> eq '(' ) {

                    # <COMMENTS>No</COMMENTS> <COMMENTS>longer</COMMENTS> <COMMENTS>doing</COMMENTS> <COMMENTS>this</COMMENTS>
                }

                elsif ( $<CODE>type_iend_1</CODE> eq ')' ) {

                    # <COMMENTS>No</COMMENTS> <COMMENTS>longer</COMMENTS> <COMMENTS>doing</COMMENTS> <COMMENTS>this</COMMENTS>
                }

                # <COMMENTS>keep</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>for</COMMENTS>-<COMMENTS>semicolon</COMMENTS>
                elsif ( $<CODE>type_iend_1</CODE> eq '<LITERALS>f</LITERALS>' ) {
                    next;
                }

                # <COMMENTS>if</COMMENTS> '=' <COMMENTS>at</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS> ...
                elsif ( $<CODE>is_assignment</CODE>{$<CODE>type_iend_1</CODE>} ) {

                    # <COMMENTS>keep</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> = <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>stream</COMMENTS>
                    # <COMMENTS>this</COMMENTS> <COMMENTS>helps</COMMENTS> <COMMENTS>prevent</COMMENTS> '<COMMENTS>blinkers</COMMENTS>'
                    next if $<CODE>old_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>]

                      # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>strand</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>isolated</COMMENTS> '='
                      && $<CODE>iend_1</CODE> != $<CODE>ibeg_1</CODE>;

                    my $<CODE>is_short_quote</CODE> =
                      (      $<CODE>type_ibeg_2</CODE> eq '<LITERALS>Q</LITERALS>'
                          && $<CODE>ibeg_2</CODE> == $<CODE>iend_2</CODE>
                          && <CODE>token_sequence_length</CODE>( $<CODE>ibeg_2</CODE>, $<CODE>ibeg_2</CODE> ) <
                          $<CODE>rOpts_short_concatenation_item_length</CODE> );
                    my $<CODE>is_ternary</CODE> =
                      ( $<CODE>type_ibeg_1</CODE> eq '?'
                          && ( $<CODE>ibeg_3</CODE> >= 0 && $<CODE>types_to_go</CODE>[$<CODE>ibeg_3</CODE>] eq ':' ) );

                    # <COMMENTS>always</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>isolated</COMMENTS> '=', <COMMENTS>a</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>quote</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS>
                    # <COMMENTS>will</COMMENTS> <COMMENTS>put</COMMENTS> ?/: <COMMENTS>at</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>adjacent</COMMENTS> <COMMENTS>lines</COMMENTS>
                    if (   $<CODE>ibeg_1</CODE> != $<CODE>iend_1</CODE>
                        && !$<CODE>is_short_quote</CODE>
                        && !$<CODE>is_ternary</CODE> )
                    {
                        next
                          unless (
                            (

                                # <COMMENTS>unless</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>reduce</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS>
                                $<CODE>nmax</CODE> < $<CODE>n</CODE> + 2

                             # <COMMENTS>or</COMMENTS> <COMMENTS>three</COMMENTS> <COMMENTS>lines</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>semicolon</COMMENTS>
                                || (   $<CODE>nmax</CODE> == $<CODE>n</CODE> + 2
                                    && $<CODE>types_to_go</CODE>[$<CODE>ibeg_nmax</CODE>] eq ';' )

                                # <COMMENTS>or</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>doc</COMMENTS>
                                || $<CODE>type_iend_2</CODE> eq '<LITERALS>h</LITERALS>'

                               # <COMMENTS>or</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>brace</COMMENTS>
                               # <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>hasn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>forced</COMMENTS> [<COMMENTS>dima</COMMENTS>.<COMMENTS>t</COMMENTS>]
                                || (  !$<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>]
                                    && $<CODE>type_iend_2</CODE> eq '{' )
                            )

                            # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>well</COMMENTS>
                            # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>approximate</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS>
                            && (   $<CODE>ibeg_3</CODE> >= 0
                                && $<CODE>type_ibeg_2</CODE> ne $<CODE>types_to_go</CODE>[$<CODE>ibeg_3</CODE>] )
                          );

                        if (

                            # <COMMENTS>Recombine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS>
                            $<CODE>nmax</CODE> >= $<CODE>n</CODE> + 2

                            # -<COMMENTS>lp</COMMENTS> <COMMENTS>users</COMMENTS> <COMMENTS>often</COMMENTS> <COMMENTS>prefer</COMMENTS> <COMMENTS>this</COMMENTS>:
                            #  <COMMENTS>my</COMMENTS> <COMMENTS>$title</COMMENTS> = <COMMENTS>function</COMMENTS>(<COMMENTS>$env</COMMENTS>, <COMMENTS>$env</COMMENTS>, <COMMENTS>$sysarea</COMMENTS>,
                            #                       "<COMMENTS>bubba</COMMENTS> <COMMENTS>Borrower</COMMENTS> <COMMENTS>Entry</COMMENTS>");
                            #  <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>if</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS>
                            #  <COMMENTS>ending</COMMENTS> <COMMENTS>comma</COMMENTS>
                            && (  !$<CODE>rOpts_line_up_parentheses</CODE>
                                || $<CODE>type_iend_2</CODE> ne ',' )
                          )
                        {

                           # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>scan</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>rhs</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>for</COMMENTS>
                           # <COMMENTS>complexity</COMMENTS>.  <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>counting</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS>
                           # <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS>.
                            my $<CODE>tv</CODE>    = 0;
                            my $<CODE>depth</CODE> = $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg_2</CODE>];
                            for ( my $<CODE>i</CODE> = $<CODE>ibeg_2</CODE> + 1 ; $<CODE>i</CODE> < $<CODE>iend_2</CODE> ; $<CODE>i</CODE>++ ) {
                                if ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>i</CODE>] != $<CODE>depth</CODE> ) {
                                    $<CODE>tv</CODE>++;
                                    last if ( $<CODE>tv</CODE> > 1 );
                                }
                                $<CODE>depth</CODE> = $<CODE>nesting_depth_to_go</CODE>[$<CODE>i</CODE>];
                            }

                         # <COMMENTS>ok</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>changes</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS>
                            if ( $<CODE>tv</CODE> > 0 ) {

                                # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>two</COMMENTS>
                                # <COMMENTS>level</COMMENTS> <COMMENTS>changes</COMMENTS>.
                                next if ( $<CODE>tv</CODE> > 1 );

                              # <COMMENTS>check</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>complexity</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>adjacent</COMMENTS> <COMMENTS>lines</COMMENTS>
                              # <COMMENTS>that</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>occur</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>join</COMMENTS>
                                my $<CODE>istop</CODE> =
                                  ( $<CODE>n</CODE> < $<CODE>nmax</CODE> ) ? $$<CODE>ri_end</CODE>[ $<CODE>n</CODE> + 1 ] : $<CODE>iend_2</CODE>;
                                for ( my $<CODE>i</CODE> = $<CODE>iend_2</CODE> ; $<CODE>i</CODE> <= $<CODE>istop</CODE> ; $<CODE>i</CODE>++ ) {
                                    if ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>i</CODE>] != $<CODE>depth</CODE> ) {
                                        $<CODE>tv</CODE>++;
                                        last if ( $<CODE>tv</CODE> > 2 );
                                    }
                                    $<CODE>depth</CODE> = $<CODE>nesting_depth_to_go</CODE>[$<CODE>i</CODE>];
                                }

                        # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>changes</COMMENTS>
                                next if ( $<CODE>tv</CODE> > 2 );
                            }
                        }
                    }

                    unless ( $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_2</CODE>] =~ /^[\{\(\[]$/ ) {
                        $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>] = 0;
                    }
                }

                # <COMMENTS>for</COMMENTS> <COMMENTS>keywords</COMMENTS>..
                elsif ( $<CODE>type_iend_1</CODE> eq '<LITERALS>k</LITERALS>' ) {

                    # <COMMENTS>make</COMMENTS> <COMMENTS>major</COMMENTS> <COMMENTS>control</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>stand</COMMENTS> <COMMENTS>out</COMMENTS>
                    # (<COMMENTS>recombine</COMMENTS>.<COMMENTS>t</COMMENTS>)
                    next
                      if (

                        #/^(<COMMENTS>last</COMMENTS>|<COMMENTS>next</COMMENTS>|<COMMENTS>redo</COMMENTS>|<COMMENTS>return</COMMENTS>)<COMMENTS>$</COMMENTS>/
                        $<CODE>is_last_next_redo_return</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>iend_1</CODE>] }

                        # <COMMENTS>but</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>lines</COMMENTS>
                        && $<CODE>n</CODE> < $<CODE>nmax</CODE>
                      );

                    if ( $<CODE>is_and_or</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>iend_1</CODE>] } ) {
                        next
                          unless $<CODE>want_break_before</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>iend_1</CODE>] };
                    }
                }

                #----------------------------------------------------------
                # <COMMENTS>Recombine</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>3</COMMENTS>:
                # <COMMENTS>Examine</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>$ibeg_2</COMMENTS> (<COMMENTS>left</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>pair</COMMENTS>)
                #----------------------------------------------------------

                # <COMMENTS>join</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>identified</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>capable</COMMENTS> <COMMENTS>of</COMMENTS>
                # <COMMENTS>causing</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>outdented</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>paren</COMMENTS>
                # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>skipping</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>rest</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>section</COMMENTS>
                if ($<CODE>previous_outdentable_closing_paren</CODE>) {
                    $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>] = 0;
                }

                # <COMMENTS>handle</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> &&, ||
                elsif ( $<CODE>is_amp_amp</CODE>{$<CODE>type_ibeg_2</CODE>} ) {

                    $<CODE>leading_amp_count</CODE>++;

                    # <COMMENTS>ok</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>follows</COMMENTS> <COMMENTS>a</COMMENTS> ? <COMMENTS>or</COMMENTS> :
                    # <COMMENTS>and</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>paren</COMMENTS>..
                    my $<CODE>ok</CODE> =
                      (      $<CODE>is_ternary</CODE>{$<CODE>type_ibeg_1</CODE>}
                          && $<CODE>tokens_to_go</CODE>[$<CODE>iend_2</CODE>] eq '(' )

                    # <COMMENTS>or</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> ? <COMMENTS>or</COMMENTS> : <COMMENTS>at</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>depth</COMMENTS>
                    #
                    # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>. <COMMENTS>We</COMMENTS> <COMMENTS>can</COMMENTS>
                    # <COMMENTS>recombine</COMMENTS> <COMMENTS>the</COMMENTS> && <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS>
                    # <COMMENTS>structure</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>clear</COMMENTS>:
                    #  <COMMENTS>return</COMMENTS>
                    #    <COMMENTS>exists</COMMENTS> <COMMENTS>$G</COMMENTS>->{<COMMENTS>Attr</COMMENTS>}->{<COMMENTS>V</COMMENTS>}
                    #    && <COMMENTS>exists</COMMENTS> <COMMENTS>$G</COMMENTS>->{<COMMENTS>Attr</COMMENTS>}->{<COMMENTS>V</COMMENTS>}->{<COMMENTS>$u</COMMENTS>}
                    #    ? %{ <COMMENTS>$G</COMMENTS>->{<COMMENTS>Attr</COMMENTS>}->{<COMMENTS>V</COMMENTS>}->{<COMMENTS>$u</COMMENTS>} }
                    #    : ();
                    #
                    # <COMMENTS>We</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>leave</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>alone</COMMENTS>:
                    #  <COMMENTS>return</COMMENTS>
                    #       <COMMENTS>exists</COMMENTS> <COMMENTS>$G</COMMENTS>->{<COMMENTS>Attr</COMMENTS>}->{<COMMENTS>E</COMMENTS>}
                    #    && <COMMENTS>exists</COMMENTS> <COMMENTS>$G</COMMENTS>->{<COMMENTS>Attr</COMMENTS>}->{<COMMENTS>E</COMMENTS>}->{<COMMENTS>$u</COMMENTS>}
                    #    && <COMMENTS>exists</COMMENTS> <COMMENTS>$G</COMMENTS>->{<COMMENTS>Attr</COMMENTS>}->{<COMMENTS>E</COMMENTS>}->{<COMMENTS>$u</COMMENTS>}->{<COMMENTS>$v</COMMENTS>}
                    #    ? %{ <COMMENTS>$G</COMMENTS>->{<COMMENTS>Attr</COMMENTS>}->{<COMMENTS>E</COMMENTS>}->{<COMMENTS>$u</COMMENTS>}->{<COMMENTS>$v</COMMENTS>} }
                    #    : ();
                    # <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> &&'<COMMENTS>s</COMMENTS> (<COMMENTS>or</COMMENTS> ||'<COMMENTS>s</COMMENTS>)
                    # <COMMENTS>on</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS>
                    # <COMMENTS>each</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>example</COMMENTS>.  <COMMENTS>However</COMMENTS>, <COMMENTS>it</COMMENTS>
                    # <COMMENTS>sometimes</COMMENTS> <COMMENTS>makes</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>worse</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>because</COMMENTS>
                    # <COMMENTS>it</COMMENTS> <COMMENTS>prevents</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>recombinations</COMMENTS>.  <COMMENTS>So</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>done</COMMENTS>.
                      || ( $<CODE>ibeg_3</CODE> >= 0
                        && $<CODE>is_ternary</CODE>{ $<CODE>types_to_go</CODE>[$<CODE>ibeg_3</CODE>] }
                        && $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg_3</CODE>] ==
                        $<CODE>nesting_depth_to_go</CODE>[$<CODE>ibeg_2</CODE>] );

                    next if !$<CODE>ok</CODE> && $<CODE>want_break_before</CODE>{$<CODE>type_ibeg_2</CODE>};
                    $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>] = 0;

                    # <COMMENTS>tweak</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>joint</COMMENTS> <COMMENTS>priority</COMMENTS>
                    # <COMMENTS>over</COMMENTS> ? <COMMENTS>and</COMMENTS> :
                    $<CODE>bs_tweak</CODE> = 0.25;
                }

                # <COMMENTS>Identify</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>broken</COMMENTS> ?/: <COMMENTS>chain</COMMENTS>
                elsif ( $<CODE>type_ibeg_2</CODE> eq '?' ) {

                    # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>levels</COMMENTS>
                    my $<CODE>lev</CODE> = $<CODE>levels_to_go</CODE>[$<CODE>ibeg_2</CODE>];
                    next if ( $<CODE>lev</CODE> ne $<CODE>levels_to_go</CODE>[$<CODE>ibeg_1</CODE>] );

                    # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>a</COMMENTS> '?' <COMMENTS>if</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>or</COMMENTS>
                    # <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> ':'.  <COMMENTS>The</COMMENTS> <COMMENTS>reasons</COMMENTS>
                    # <COMMENTS>are</COMMENTS> <COMMENTS>that</COMMENTS> (<COMMENTS>1</COMMENTS>) <COMMENTS>no</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> ? <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>possible</COMMENTS>
                    # <COMMENTS>and</COMMENTS> (<COMMENTS>2</COMMENTS>) <COMMENTS>the</COMMENTS> <COMMENTS>expression</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>somewhat</COMMENTS> <COMMENTS>complex</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>the</COMMENTS>
                    # '?' <COMMENTS>is</COMMENTS> <COMMENTS>harder</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>interior</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>.
                    my $<CODE>follows_colon</CODE> = $<CODE>ibeg_1</CODE> >= 0 && $<CODE>type_ibeg_1</CODE> eq ':';
                    my $<CODE>precedes_colon</CODE> =
                      $<CODE>ibeg_3</CODE> >= 0 && $<CODE>types_to_go</CODE>[$<CODE>ibeg_3</CODE>] eq ':';
                    next unless ( $<CODE>follows_colon</CODE> || $<CODE>precedes_colon</CODE> );

                    # <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>combining</COMMENTS> <COMMENTS>a</COMMENTS> ? <COMMENTS>line</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>a</COMMENTS> : <COMMENTS>line</COMMENTS>
                    if ( !$<CODE>follows_colon</CODE> ) {

                        # ...<COMMENTS>otherwise</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>chain</COMMENTS>.
                        # <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>few</COMMENTS> <COMMENTS>nearby</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS>
                        # <COMMENTS>this</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>chain</COMMENTS>.
                        my $<CODE>local_count</CODE> = 0;
                        foreach my $<CODE>ii</CODE> ( $<CODE>ibeg_0</CODE>, $<CODE>ibeg_1</CODE>, $<CODE>ibeg_3</CODE>, $<CODE>ibeg_4</CODE> ) {
                            $<CODE>local_count</CODE>++
                              if $<CODE>ii</CODE> >= 0
                              && $<CODE>types_to_go</CODE>[$<CODE>ii</CODE>] eq ':'
                              && $<CODE>levels_to_go</CODE>[$<CODE>ii</CODE>] == $<CODE>lev</CODE>;
                        }
                        next unless ( $<CODE>local_count</CODE> > 1 );
                    }
                    $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>] = 0;
                }

                # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> '.'
                elsif ( $<CODE>type_ibeg_2</CODE> eq '.' ) {
                    my $<CODE>i_next_nonblank</CODE> = <CODE>min</CODE>( $<CODE>inext_to_go</CODE>[$<CODE>ibeg_2</CODE>], $<CODE>iend_2</CODE> );
                    next
                      unless (

                   # ... <COMMENTS>unless</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>reduce</COMMENTS>
                   # <COMMENTS>this</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>this</COMMENTS>
                   #
                   #
                   #  <COMMENTS>$bodyA</COMMENTS> .=
                   #    '(<COMMENTS>$dummy</COMMENTS>, <COMMENTS>$pat</COMMENTS>) = &<COMMENTS>get_next_tex_cmd</COMMENTS>;' . '<COMMENTS>$args</COMMENTS> .= <COMMENTS>$pat</COMMENTS>;'
                   #
                   #  <COMMENTS>looks</COMMENTS> <COMMENTS>better</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>this</COMMENTS>:
                   #  <COMMENTS>$bodyA</COMMENTS> .= '(<COMMENTS>$dummy</COMMENTS>, <COMMENTS>$pat</COMMENTS>) = &<COMMENTS>get_next_tex_cmd</COMMENTS>;'
                   #    . '<COMMENTS>$args</COMMENTS> .= <COMMENTS>$pat</COMMENTS>;'

                        (
                               $<CODE>n</CODE> == 2
                            && $<CODE>n</CODE> == $<CODE>nmax</CODE>
                            && $<CODE>type_ibeg_1</CODE> ne $<CODE>type_ibeg_2</CODE>
                        )

                        #  ... <COMMENTS>or</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>strand</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>quote</COMMENTS> , <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>
                        #                . "<COMMENTS>some</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>quote</COMMENTS>"
                        #                . "\<COMMENTS>n</COMMENTS>";

                        || (   $<CODE>types_to_go</CODE>[$<CODE>i_next_nonblank</CODE>] eq '<LITERALS>Q</LITERALS>'
                            && $<CODE>i_next_nonblank</CODE> >= $<CODE>iend_2</CODE> - 1
                            && $<CODE>token_lengths_to_go</CODE>[$<CODE>i_next_nonblank</CODE>] <
                            $<CODE>rOpts_short_concatenation_item_length</CODE> )
                      );
                }

                # <COMMENTS>handle</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>keyword</COMMENTS>..
                elsif ( $<CODE>type_ibeg_2</CODE> eq '<LITERALS>k</LITERALS>' ) {

                    # <COMMENTS>handle</COMMENTS> <COMMENTS>leading</COMMENTS> "<COMMENTS>or</COMMENTS>"
                    if ( $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_2</CODE>] eq '<LITERALS>or</LITERALS>' ) {
                        next
                          unless (
                            $<CODE>this_line_is_semicolon_terminated</CODE>
                            && (

                                # <COMMENTS>following</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>or</COMMENTS> '<COMMENTS>unless</COMMENTS>' <COMMENTS>or</COMMENTS> '<COMMENTS>or</COMMENTS>'
                                $<CODE>type_ibeg_1</CODE> eq '<LITERALS>k</LITERALS>'
                                && $<CODE>is_if_unless</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_1</CODE>] }

                                # <COMMENTS>important</COMMENTS>: <COMMENTS>only</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>or</COMMENTS>
                                # <COMMENTS>statement</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>step</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS>
                                # <COMMENTS>combined</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>trailing</COMMENTS> '<COMMENTS>and</COMMENTS>' <COMMENTS>with</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>or</COMMENTS>,
                                # <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>combine</COMMENTS>
                                # <COMMENTS>everything</COMMENTS> <COMMENTS>together</COMMENTS>
                                && ( $<CODE>iend_2</CODE> - $<CODE>ibeg_2</CODE> <= 7 )
                            )
                          );
##<COMMENTS>X</COMMENTS>: <COMMENTS>RT</COMMENTS> #<COMMENTS>81854</COMMENTS>
                        $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>] = 0
                          unless $<CODE>old_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>];
                    }

                    # <COMMENTS>handle</COMMENTS> <COMMENTS>leading</COMMENTS> '<COMMENTS>and</COMMENTS>'
                    elsif ( $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_2</CODE>] eq '<LITERALS>and</LITERALS>' ) {

                        # <COMMENTS>Decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>terminal</COMMENTS> '<COMMENTS>and</COMMENTS>'
                        # <COMMENTS>after</COMMENTS> <COMMENTS>an</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>or</COMMENTS> '<COMMENTS>unless</COMMENTS>'.

                        #     <COMMENTS>This</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>and</COMMENTS>' <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS>
                        #     <COMMENTS>line</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>if</COMMENTS>':
                        #
                        #         <COMMENTS>$a</COMMENTS> = <COMMENTS>1</COMMENTS>
                        #           <COMMENTS>if</COMMENTS> <COMMENTS>$seconds</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>$nu</COMMENTS> < <COMMENTS>2</COMMENTS>;
                        #
                        #     <COMMENTS>But</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>better</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>shown</COMMENTS>:
                        #
                        #         <COMMENTS>$a</COMMENTS> = <COMMENTS>1</COMMENTS>
                        #           <COMMENTS>if</COMMENTS> !<COMMENTS>$this</COMMENTS>->{<COMMENTS>Parents</COMMENTS>}{<COMMENTS>$_</COMMENTS>}
                        #           <COMMENTS>or</COMMENTS> <COMMENTS>$this</COMMENTS>->{<COMMENTS>Parents</COMMENTS>}{<COMMENTS>$_</COMMENTS>} <COMMENTS>eq</COMMENTS> <COMMENTS>$_</COMMENTS>;
                        #
                        next
                          unless (
                            $<CODE>this_line_is_semicolon_terminated</CODE>
                            && (

                                # <COMMENTS>following</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>or</COMMENTS> '<COMMENTS>unless</COMMENTS>' <COMMENTS>or</COMMENTS> '<COMMENTS>or</COMMENTS>'
                                $<CODE>type_ibeg_1</CODE> eq '<LITERALS>k</LITERALS>'
                                && (   $<CODE>is_if_unless</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_1</CODE>] }
                                    || $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_1</CODE>] eq '<LITERALS>or</LITERALS>' )
                            )
                          );
                    }

                    # <COMMENTS>handle</COMMENTS> <COMMENTS>leading</COMMENTS> "<COMMENTS>if</COMMENTS>" <COMMENTS>and</COMMENTS> "<COMMENTS>unless</COMMENTS>"
                    elsif ( $<CODE>is_if_unless</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_2</CODE>] } ) {

                      # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>experimental</COMMENTS>..<COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>useful</COMMENTS>
                        next
                          unless (
                            $<CODE>this_line_is_semicolon_terminated</CODE>

                            #  <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>begins</COMMENTS> <COMMENTS>with</COMMENTS> '<COMMENTS>and</COMMENTS>' <COMMENTS>or</COMMENTS> '<COMMENTS>or</COMMENTS>'
                            && $<CODE>type_ibeg_1</CODE> eq '<LITERALS>k</LITERALS>'
                            && $<CODE>is_and_or</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_1</CODE>] }

                          );
                    }

                    # <COMMENTS>handle</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>keywords</COMMENTS>
                    else {

                        # <COMMENTS>keywords</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS>,
                        # <COMMENTS>but</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>like</COMMENTS> "<COMMENTS>1</COMMENTS> <COMMENTS>while</COMMENTS>"
                        unless ( $<CODE>is_assignment</CODE>{$<CODE>type_iend_1</CODE>} ) {
                            next
                              if ( ( $<CODE>type_iend_1</CODE> ne '<LITERALS>k</LITERALS>' )
                                && ( $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_2</CODE>] ne '<LITERALS>while</LITERALS>' ) );
                        }
                    }
                }

                # <COMMENTS>similar</COMMENTS> <COMMENTS>treatment</COMMENTS> <COMMENTS>of</COMMENTS> && <COMMENTS>and</COMMENTS> || <COMMENTS>as</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>for</COMMENTS> '<COMMENTS>and</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>or</COMMENTS>':
                # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>currently</COMMENTS> <COMMENTS>bypassed</COMMENTS> <COMMENTS>because</COMMENTS>
                # <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>retained</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>future</COMMENTS> <COMMENTS>use</COMMENTS>.
                elsif ( $<CODE>is_amp_amp</CODE>{$<CODE>type_ibeg_2</CODE>} ) {

                    # <COMMENTS>maybe</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS>:
                    # <COMMENTS>unless</COMMENTS> <COMMENTS>$TEXTONLY</COMMENTS> || <COMMENTS>$item</COMMENTS> =~ <COMMENTS>m</COMMENTS>%</?(<COMMENTS>hr</COMMENTS>>|<COMMENTS>p</COMMENTS>>|<COMMENTS>a</COMMENTS>|<COMMENTS>img</COMMENTS>)%<COMMENTS>i</COMMENTS>;

                    next
                      unless (
                        $<CODE>this_line_is_semicolon_terminated</CODE>

                        # <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>begins</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>an</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>or</COMMENTS> '<COMMENTS>unless</COMMENTS>' <COMMENTS>keyword</COMMENTS>
                        && $<CODE>type_ibeg_1</CODE> eq '<LITERALS>k</LITERALS>'
                        && $<CODE>is_if_unless</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_1</CODE>] }

                      );
                }

                # <COMMENTS>handle</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> = <COMMENTS>or</COMMENTS> <COMMENTS>similar</COMMENTS>
                elsif ( $<CODE>is_assignment</CODE>{$<CODE>type_ibeg_2</CODE>} ) {
                    next unless ( $<CODE>n</CODE> == 1 || $<CODE>n</CODE> == $<CODE>nmax</CODE> );
                    next if $<CODE>old_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>];
                    next
                      unless (

                        # <COMMENTS>unless</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>reduce</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS>
                        $<CODE>nmax</CODE> == 2

                        # <COMMENTS>or</COMMENTS> <COMMENTS>three</COMMENTS> <COMMENTS>lines</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>semicolon</COMMENTS>
                        || ( $<CODE>nmax</CODE> == 3 && $<CODE>types_to_go</CODE>[$<CODE>ibeg_nmax</CODE>] eq ';' )

                        # <COMMENTS>or</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>doc</COMMENTS>
                        || $<CODE>type_iend_2</CODE> eq '<LITERALS>h</LITERALS>'

                        # <COMMENTS>or</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS> ;
                        || ( $<CODE>n</CODE> == $<CODE>nmax</CODE> && $<CODE>this_line_is_semicolon_terminated</CODE> )
                      );
                    $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>] = 0;
                }

                #----------------------------------------------------------
                # <COMMENTS>Recombine</COMMENTS> <COMMENTS>Section</COMMENTS> <COMMENTS>4</COMMENTS>:
                # <COMMENTS>Combine</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>arrive</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>possible</COMMENTS>
                #----------------------------------------------------------

                # <COMMENTS>honor</COMMENTS> <COMMENTS>hard</COMMENTS> <COMMENTS>breakpoints</COMMENTS>
                next if ( $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>] > 0 );

                my $<CODE>bs</CODE> = $<CODE>bond_strength_to_go</CODE>[$<CODE>iend_1</CODE>] + $<CODE>bs_tweak</CODE>;

                # <COMMENTS>combined</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>cannot</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>long</COMMENTS>
                my $<CODE>excess</CODE> = <CODE>excess_line_length</CODE>( $<CODE>ibeg_1</CODE>, $<CODE>iend_2</CODE> );
                next if ( $<CODE>excess</CODE> > 0 );

                # <COMMENTS>Require</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>few</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>recombining</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS>
                # <COMMENTS>at</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>breakpoint</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>terminal</COMMENTS>
                # <COMMENTS>line</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>goal</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>oscillating</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>two</COMMENTS>
                # <COMMENTS>quasi</COMMENTS>-<COMMENTS>stable</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>states</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>snippet</COMMENTS> <COMMENTS>caused</COMMENTS>
                # <COMMENTS>problems</COMMENTS>:
##    <COMMENTS>my</COMMENTS> <COMMENTS>$this</COMMENTS> =
##    <COMMENTS>bless</COMMENTS> {
##        <COMMENTS>TText</COMMENTS> => "[" . ( <COMMENTS>join</COMMENTS> ',', <COMMENTS>map</COMMENTS> { "\"<COMMENTS>$_</COMMENTS>\"" } <COMMENTS>split</COMMENTS> "\<COMMENTS>n</COMMENTS>", <COMMENTS>$_</COMMENTS> ) . "]"
##      },
##      <COMMENTS>$type</COMMENTS>;
                next
                  if ( $<CODE>old_breakpoint_to_go</CODE>[$<CODE>iend_1</CODE>]
                    && !$<CODE>this_line_is_semicolon_terminated</CODE>
                    && $<CODE>n</CODE> < $<CODE>nmax</CODE>
                    && $<CODE>excess</CODE> + 4 > 0
                    && $<CODE>type_iend_2</CODE> ne ',' );

                # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recombine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>skip</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>levels</COMMENTS>
                if ( $<CODE>n</CODE> < $<CODE>nmax</CODE> ) {
                    my $<CODE>if_next</CODE> = $$<CODE>ri_beg</CODE>[ $<CODE>n</CODE> + 1 ];
                    next
                      if (
                           $<CODE>levels_to_go</CODE>[$<CODE>ibeg_1</CODE>] < $<CODE>levels_to_go</CODE>[$<CODE>ibeg_2</CODE>]
                        && $<CODE>levels_to_go</CODE>[$<CODE>ibeg_2</CODE>] < $<CODE>levels_to_go</CODE>[$<CODE>if_next</CODE>]

                        # <COMMENTS>but</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>isolated</COMMENTS> '<COMMENTS>if</COMMENTS> (' <COMMENTS>is</COMMENTS> <COMMENTS>undesirable</COMMENTS>
                        && !(
                               $<CODE>n</CODE> == 1
                            && $<CODE>iend_1</CODE> - $<CODE>ibeg_1</CODE> <= 2
                            && $<CODE>type_ibeg_1</CODE> eq '<LITERALS>k</LITERALS>'
                            && $<CODE>tokens_to_go</CODE>[$<CODE>ibeg_1</CODE>] eq '<LITERALS>if</LITERALS>'
                            && $<CODE>tokens_to_go</CODE>[$<CODE>iend_1</CODE>] ne '('
                        )
                      );
                }

                # <COMMENTS>honor</COMMENTS> <COMMENTS>no</COMMENTS>-<COMMENTS>break</COMMENTS>'<COMMENTS>s</COMMENTS>
                next if ( $<CODE>bs</CODE> >= <CODE>NO_BREAK</CODE> - 1 );

                # <COMMENTS>remember</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pair</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>greatest</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS>
                if ( !$<CODE>n_best</CODE> ) {
                    $<CODE>n_best</CODE>  = $<CODE>n</CODE>;
                    $<CODE>bs_best</CODE> = $<CODE>bs</CODE>;
                }
                else {

                    if ( $<CODE>bs</CODE> > $<CODE>bs_best</CODE> ) {
                        $<CODE>n_best</CODE>  = $<CODE>n</CODE>;
                        $<CODE>bs_best</CODE> = $<CODE>bs</CODE>;
                    }
                }
            }

            # <COMMENTS>recombine</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pair</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>greatest</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS>
            if ($<CODE>n_best</CODE>) {
                splice @$<CODE>ri_beg</CODE>, $<CODE>n_best</CODE>, 1;
                splice @$<CODE>ri_end</CODE>, $<CODE>n_best</CODE> - 1, 1;
                splice @<CODE>joint</CODE>, $<CODE>n_best</CODE>, 1;

                # <COMMENTS>keep</COMMENTS> <COMMENTS>going</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>making</COMMENTS> <COMMENTS>progress</COMMENTS>
                $<CODE>more_to_do</CODE>++;
            }
        }
        return ( $<CODE>ri_beg</CODE>, $<CODE>ri_end</CODE> );
    }
}    # <COMMENTS>end</COMMENTS> <COMMENTS>recombine_breakpoints</COMMENTS>

sub <CODE>break_all_chain_tokens</CODE> {

    # <COMMENTS>scan</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>certain</COMMENTS> "<COMMENTS>chain</COMMENTS>
    # <COMMENTS>operators</COMMENTS>" (. : && || + <COMMENTS>etc</COMMENTS>) <COMMENTS>which</COMMENTS> <COMMENTS>often</COMMENTS> <COMMENTS>occur</COMMENTS> <COMMENTS>repeatedly</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS>
    # <COMMENTS>statement</COMMENTS>.  <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>one</COMMENTS>, <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>similar</COMMENTS> <COMMENTS>tokens</COMMENTS>
    # <COMMENTS>within</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>container</COMMENTS>.
    #
    my ( $<CODE>ri_left</CODE>, $<CODE>ri_right</CODE> ) = @<CODE>_</CODE>;

    my %<CODE>saw_chain_type</CODE>;
    my %<CODE>left_chain_type</CODE>;
    my %<CODE>right_chain_type</CODE>;
    my %<CODE>interior_chain_type</CODE>;
    my $<CODE>nmax</CODE> = @$<CODE>ri_right</CODE> - 1;

    # <COMMENTS>scan</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>lines</COMMENTS>
    my $<CODE>count</CODE> = 0;
    for my $<CODE>n</CODE> ( 0 .. $<CODE>nmax</CODE> ) {
        my $<CODE>il</CODE>    = $$<CODE>ri_left</CODE>[$<CODE>n</CODE>];
        my $<CODE>ir</CODE>    = $$<CODE>ri_right</CODE>[$<CODE>n</CODE>];
        my $<CODE>typel</CODE> = $<CODE>types_to_go</CODE>[$<CODE>il</CODE>];
        my $<CODE>typer</CODE> = $<CODE>types_to_go</CODE>[$<CODE>ir</CODE>];
        $<CODE>typel</CODE> = '+' if ( $<CODE>typel</CODE> eq '-' );    # <COMMENTS>treat</COMMENTS> + <COMMENTS>and</COMMENTS> - <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS>
        $<CODE>typer</CODE> = '+' if ( $<CODE>typer</CODE> eq '-' );
        $<CODE>typel</CODE> = '*' if ( $<CODE>typel</CODE> eq '/' );    # <COMMENTS>treat</COMMENTS> * <COMMENTS>and</COMMENTS> / <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS>
        $<CODE>typer</CODE> = '*' if ( $<CODE>typer</CODE> eq '/' );
        my $<CODE>tokenl</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>il</CODE>];
        my $<CODE>tokenr</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>ir</CODE>];

        if ( $<CODE>is_chain_operator</CODE>{$<CODE>tokenl</CODE>} && $<CODE>want_break_before</CODE>{$<CODE>typel</CODE>} ) {
            next if ( $<CODE>typel</CODE> eq '?' );
            push @{ $<CODE>left_chain_type</CODE>{$<CODE>typel</CODE>} }, $<CODE>il</CODE>;
            $<CODE>saw_chain_type</CODE>{$<CODE>typel</CODE>} = 1;
            $<CODE>count</CODE>++;
        }
        if ( $<CODE>is_chain_operator</CODE>{$<CODE>tokenr</CODE>} && !$<CODE>want_break_before</CODE>{$<CODE>typer</CODE>} ) {
            next if ( $<CODE>typer</CODE> eq '?' );
            push @{ $<CODE>right_chain_type</CODE>{$<CODE>typer</CODE>} }, $<CODE>ir</CODE>;
            $<CODE>saw_chain_type</CODE>{$<CODE>typer</CODE>} = 1;
            $<CODE>count</CODE>++;
        }
    }
    return unless $<CODE>count</CODE>;

    # <COMMENTS>now</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>interior</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>types</COMMENTS>
    $<CODE>count</CODE> = 0;
    for my $<CODE>n</CODE> ( 0 .. $<CODE>nmax</CODE> ) {
        my $<CODE>il</CODE> = $$<CODE>ri_left</CODE>[$<CODE>n</CODE>];
        my $<CODE>ir</CODE> = $$<CODE>ri_right</CODE>[$<CODE>n</CODE>];
        for ( my $<CODE>i</CODE> = $<CODE>il</CODE> + 1 ; $<CODE>i</CODE> < $<CODE>ir</CODE> ; $<CODE>i</CODE>++ ) {
            my $<CODE>type</CODE> = $<CODE>types_to_go</CODE>[$<CODE>i</CODE>];
            $<CODE>type</CODE> = '+' if ( $<CODE>type</CODE> eq '-' );
            $<CODE>type</CODE> = '*' if ( $<CODE>type</CODE> eq '/' );
            if ( $<CODE>saw_chain_type</CODE>{$<CODE>type</CODE>} ) {
                push @{ $<CODE>interior_chain_type</CODE>{$<CODE>type</CODE>} }, $<CODE>i</CODE>;
                $<CODE>count</CODE>++;
            }
        }
    }
    return unless $<CODE>count</CODE>;

    # <COMMENTS>now</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>points</COMMENTS>
    my @<CODE>insert_list</CODE>;

    # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>types</COMMENTS>
    foreach my $<CODE>type</CODE> ( keys %<CODE>saw_chain_type</CODE> ) {

        # <COMMENTS>quit</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>ONE</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> .  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>--
        # <COMMENTS>print</COMMENTS> <COMMENTS>LATEXFILE</COMMENTS> '\<COMMENTS>framebox</COMMENTS>{\<COMMENTS>parbox</COMMENTS>[<COMMENTS>c</COMMENTS>][' . <COMMENTS>$h</COMMENTS> . '][<COMMENTS>t</COMMENTS>]{' . <COMMENTS>$w</COMMENTS> . '}{'
        #  . <COMMENTS>$contents</COMMENTS>;
        last if ( $<CODE>nmax</CODE> == 1 && $<CODE>type</CODE> =~ /^[\.\+]$/ );

        # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>interior</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>tokens</COMMENTS>
        foreach my $<CODE>itest</CODE> ( @{ $<CODE>interior_chain_type</CODE>{$<CODE>type</CODE>} } ) {

            # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>type</COMMENTS>
            if ( $<CODE>left_chain_type</CODE>{$<CODE>type</CODE>} ) {
                next if $<CODE>nobreak_to_go</CODE>[ $<CODE>itest</CODE> - 1 ];
                foreach my $<CODE>i</CODE> ( @{ $<CODE>left_chain_type</CODE>{$<CODE>type</CODE>} } ) {
                    next unless <CODE>in_same_container</CODE>( $<CODE>i</CODE>, $<CODE>itest</CODE> );
                    push @<CODE>insert_list</CODE>, $<CODE>itest</CODE> - 1;

                    # <COMMENTS>Break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>matching</COMMENTS> ? <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> : <COMMENTS>is</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>level</COMMENTS>.
                    # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>the</COMMENTS> ? <COMMENTS>before</COMMENTS> <COMMENTS>$THRf_DEAD</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>
                    # <COMMENTS>should</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>its</COMMENTS> : <COMMENTS>gets</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS>.
                    #
                    # <COMMENTS>my</COMMENTS> <COMMENTS>$flags</COMMENTS> =
                    #     ( <COMMENTS>$_</COMMENTS> & <COMMENTS>1</COMMENTS> ) ? ( <COMMENTS>$_</COMMENTS> & <COMMENTS>4</COMMENTS> ) ? <COMMENTS>$THRf_DEAD</COMMENTS> : <COMMENTS>$THRf_ZOMBIE</COMMENTS>
                    #   : ( <COMMENTS>$_</COMMENTS> & <COMMENTS>4</COMMENTS> ) ? <COMMENTS>$THRf_R_DETACHED</COMMENTS>
                    #   :              <COMMENTS>$THRf_R_JOINABLE</COMMENTS>;
                    if (   $<CODE>type</CODE> eq ':'
                        && $<CODE>levels_to_go</CODE>[$<CODE>i</CODE>] != $<CODE>levels_to_go</CODE>[$<CODE>itest</CODE>] )
                    {
                        my $<CODE>i_question</CODE> = $<CODE>mate_index_to_go</CODE>[$<CODE>itest</CODE>];
                        if ( $<CODE>i_question</CODE> > 0 ) {
                            push @<CODE>insert_list</CODE>, $<CODE>i_question</CODE> - 1;
                        }
                    }
                    last;
                }
            }

            # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>type</COMMENTS>
            if ( $<CODE>right_chain_type</CODE>{$<CODE>type</CODE>} ) {
                next if $<CODE>nobreak_to_go</CODE>[$<CODE>itest</CODE>];
                foreach my $<CODE>i</CODE> ( @{ $<CODE>right_chain_type</CODE>{$<CODE>type</CODE>} } ) {
                    next unless <CODE>in_same_container</CODE>( $<CODE>i</CODE>, $<CODE>itest</CODE> );
                    push @<CODE>insert_list</CODE>, $<CODE>itest</CODE>;

                    # <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>matching</COMMENTS> ? <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> : <COMMENTS>is</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>level</COMMENTS>
                    if (   $<CODE>type</CODE> eq ':'
                        && $<CODE>levels_to_go</CODE>[$<CODE>i</CODE>] != $<CODE>levels_to_go</CODE>[$<CODE>itest</CODE>] )
                    {
                        my $<CODE>i_question</CODE> = $<CODE>mate_index_to_go</CODE>[$<CODE>itest</CODE>];
                        if ( $<CODE>i_question</CODE> >= 0 ) {
                            push @<CODE>insert_list</CODE>, $<CODE>i_question</CODE>;
                        }
                    }
                    last;
                }
            }
        }
    }

    # <COMMENTS>insert</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>points</COMMENTS>
    if (@<CODE>insert_list</CODE>) {
        <CODE>insert_additional_breaks</CODE>( \@<CODE>insert_list</CODE>, $<CODE>ri_left</CODE>, $<CODE>ri_right</CODE> );
    }
}

sub <CODE>break_equals</CODE> {

    # <COMMENTS>Look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>assignment</COMMENTS> <COMMENTS>operators</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>breakpoint</COMMENTS>.
    # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>snippet</COMMENTS>
    #
    #    <COMMENTS>$HOME</COMMENTS> = <COMMENTS>$ENV</COMMENTS>{<COMMENTS>HOME</COMMENTS>}
    #      || <COMMENTS>$ENV</COMMENTS>{<COMMENTS>LOGDIR</COMMENTS>}
    #      || <COMMENTS>$pw</COMMENTS>[<COMMENTS>7</COMMENTS>]
    #      || <COMMENTS>die</COMMENTS> "<COMMENTS>no</COMMENTS> <COMMENTS>home</COMMENTS> <COMMENTS>directory</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>$</COMMENTS><";
    #
    # <COMMENTS>we</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> = <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>this</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>little</COMMENTS> <COMMENTS>nicer</COMMENTS>:
    #    <COMMENTS>$HOME</COMMENTS> =
    #         <COMMENTS>$ENV</COMMENTS>{<COMMENTS>HOME</COMMENTS>}
    #      || <COMMENTS>$ENV</COMMENTS>{<COMMENTS>LOGDIR</COMMENTS>}
    #      || <COMMENTS>$pw</COMMENTS>[<COMMENTS>7</COMMENTS>]
    #      || <COMMENTS>die</COMMENTS> "<COMMENTS>no</COMMENTS> <COMMENTS>home</COMMENTS> <COMMENTS>directory</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>$</COMMENTS><";
    #
    # <COMMENTS>The</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>follows</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>set_logical_padding</COMMENTS>, <COMMENTS>which</COMMENTS>
    # <COMMENTS>will</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>improve</COMMENTS> <COMMENTS>alignment</COMMENTS>.
    #
    my ( $<CODE>ri_left</CODE>, $<CODE>ri_right</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>nmax</CODE> = @$<CODE>ri_right</CODE> - 1;
    return unless ( $<CODE>nmax</CODE> >= 2 );

    # <COMMENTS>scan</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS>
    my $<CODE>tokbeg</CODE> = "";
    my $<CODE>depth_beg</CODE>;
    for my $<CODE>n</CODE> ( 1 .. 2 ) {
        my $<CODE>il</CODE>     = $$<CODE>ri_left</CODE>[$<CODE>n</CODE>];
        my $<CODE>typel</CODE>  = $<CODE>types_to_go</CODE>[$<CODE>il</CODE>];
        my $<CODE>tokenl</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>il</CODE>];

        my $<CODE>has_leading_op</CODE> = ( $<CODE>tokenl</CODE> =~ /^\w/ )
          ? $<CODE>is_chain_operator</CODE>{$<CODE>tokenl</CODE>}    # + - * / : ? && ||
          : $<CODE>is_chain_operator</CODE>{$<CODE>typel</CODE>};    # <COMMENTS>and</COMMENTS>, <COMMENTS>or</COMMENTS>
        return unless ($<CODE>has_leading_op</CODE>);
        if ( $<CODE>n</CODE> > 1 ) {
            return
              unless ( $<CODE>tokenl</CODE> eq $<CODE>tokbeg</CODE>
                && $<CODE>nesting_depth_to_go</CODE>[$<CODE>il</CODE>] eq $<CODE>depth_beg</CODE> );
        }
        $<CODE>tokbeg</CODE>    = $<CODE>tokenl</CODE>;
        $<CODE>depth_beg</CODE> = $<CODE>nesting_depth_to_go</CODE>[$<CODE>il</CODE>];
    }

    # <COMMENTS>now</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>interior</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>types</COMMENTS>
    my $<CODE>il</CODE> = $$<CODE>ri_left</CODE>[0];
    my $<CODE>ir</CODE> = $$<CODE>ri_right</CODE>[0];

    # <COMMENTS>now</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>points</COMMENTS>
    my @<CODE>insert_list</CODE>;
    for ( my $<CODE>i</CODE> = $<CODE>ir</CODE> - 1 ; $<CODE>i</CODE> > $<CODE>il</CODE> ; $<CODE>i</CODE>-- ) {
        my $<CODE>type</CODE> = $<CODE>types_to_go</CODE>[$<CODE>i</CODE>];
        if (   $<CODE>is_assignment</CODE>{$<CODE>type</CODE>}
            && $<CODE>nesting_depth_to_go</CODE>[$<CODE>i</CODE>] eq $<CODE>depth_beg</CODE> )
        {
            if ( $<CODE>want_break_before</CODE>{$<CODE>type</CODE>} ) {
                push @<CODE>insert_list</CODE>, $<CODE>i</CODE> - 1;
            }
            else {
                push @<CODE>insert_list</CODE>, $<CODE>i</CODE>;
            }
        }
    }

    # <COMMENTS>Break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>return</COMMENTS>' <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>operators</COMMENTS>
    #  <COMMENTS>return</COMMENTS> ( <COMMENTS>$</COMMENTS>^<COMMENTS>O</COMMENTS> !~ /<COMMENTS>win32</COMMENTS>|<COMMENTS>dos</COMMENTS>/<COMMENTS>i</COMMENTS> )
    #    && ( <COMMENTS>$</COMMENTS>^<COMMENTS>O</COMMENTS> <COMMENTS>ne</COMMENTS> '<COMMENTS>VMS</COMMENTS>' )
    #    && ( <COMMENTS>$</COMMENTS>^<COMMENTS>O</COMMENTS> <COMMENTS>ne</COMMENTS> '<COMMENTS>OS2</COMMENTS>' )
    #    && ( <COMMENTS>$</COMMENTS>^<COMMENTS>O</COMMENTS> <COMMENTS>ne</COMMENTS> '<COMMENTS>MacOS</COMMENTS>' );
    # <COMMENTS>To</COMMENTS> <COMMENTS>give</COMMENTS>:
    #  <COMMENTS>return</COMMENTS>
    #       ( <COMMENTS>$</COMMENTS>^<COMMENTS>O</COMMENTS> !~ /<COMMENTS>win32</COMMENTS>|<COMMENTS>dos</COMMENTS>/<COMMENTS>i</COMMENTS> )
    #    && ( <COMMENTS>$</COMMENTS>^<COMMENTS>O</COMMENTS> <COMMENTS>ne</COMMENTS> '<COMMENTS>VMS</COMMENTS>' )
    #    && ( <COMMENTS>$</COMMENTS>^<COMMENTS>O</COMMENTS> <COMMENTS>ne</COMMENTS> '<COMMENTS>OS2</COMMENTS>' )
    #    && ( <COMMENTS>$</COMMENTS>^<COMMENTS>O</COMMENTS> <COMMENTS>ne</COMMENTS> '<COMMENTS>MacOS</COMMENTS>' );
    my $<CODE>i</CODE> = 0;
    if (   $<CODE>types_to_go</CODE>[$<CODE>i</CODE>] eq '<LITERALS>k</LITERALS>'
        && $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>] eq '<LITERALS>return</LITERALS>'
        && $<CODE>ir</CODE> > $<CODE>il</CODE>
        && $<CODE>nesting_depth_to_go</CODE>[$<CODE>i</CODE>] eq $<CODE>depth_beg</CODE> )
    {
        push @<CODE>insert_list</CODE>, $<CODE>i</CODE>;
    }

    return unless (@<CODE>insert_list</CODE>);

    # <COMMENTS>One</COMMENTS> <COMMENTS>final</COMMENTS> <COMMENTS>check</COMMENTS>...
    # <COMMENTS>scan</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>third</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>assignments</COMMENTS>
    # <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>breaking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>an</COMMENTS> = <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
    #    <COMMENTS>unless</COMMENTS> ( <COMMENTS>$icon</COMMENTS> =
    #           <COMMENTS>$html_icons</COMMENTS>{"<COMMENTS>$type</COMMENTS>-<COMMENTS>$state</COMMENTS>"}
    #        <COMMENTS>or</COMMENTS> <COMMENTS>$icon</COMMENTS> = <COMMENTS>$html_icons</COMMENTS>{<COMMENTS>$type</COMMENTS>}
    #        <COMMENTS>or</COMMENTS> <COMMENTS>$icon</COMMENTS> = <COMMENTS>$html_icons</COMMENTS>{<COMMENTS>$state</COMMENTS>} )
    for my $<CODE>n</CODE> ( 1 .. 2 ) {
        my $<CODE>il</CODE> = $$<CODE>ri_left</CODE>[$<CODE>n</CODE>];
        my $<CODE>ir</CODE> = $$<CODE>ri_right</CODE>[$<CODE>n</CODE>];
        for ( my $<CODE>i</CODE> = $<CODE>il</CODE> + 1 ; $<CODE>i</CODE> <= $<CODE>ir</CODE> ; $<CODE>i</CODE>++ ) {
            my $<CODE>type</CODE> = $<CODE>types_to_go</CODE>[$<CODE>i</CODE>];
            return
              if ( $<CODE>is_assignment</CODE>{$<CODE>type</CODE>}
                && $<CODE>nesting_depth_to_go</CODE>[$<CODE>i</CODE>] eq $<CODE>depth_beg</CODE> );
        }
    }

    # <COMMENTS>ok</COMMENTS>, <COMMENTS>insert</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>point</COMMENTS>
    if (@<CODE>insert_list</CODE>) {
        <CODE>insert_additional_breaks</CODE>( \@<CODE>insert_list</CODE>, $<CODE>ri_left</CODE>, $<CODE>ri_right</CODE> );
    }
}

sub <CODE>insert_final_breaks</CODE> {

    my ( $<CODE>ri_left</CODE>, $<CODE>ri_right</CODE> ) = @<CODE>_</CODE>;

    my $<CODE>nmax</CODE> = @$<CODE>ri_right</CODE> - 1;

    # <COMMENTS>scan</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>lines</COMMENTS>
    my $<CODE>count</CODE>         = 0;
    my $<CODE>i_first_colon</CODE> = -1;
    for my $<CODE>n</CODE> ( 0 .. $<CODE>nmax</CODE> ) {
        my $<CODE>il</CODE>    = $$<CODE>ri_left</CODE>[$<CODE>n</CODE>];
        my $<CODE>ir</CODE>    = $$<CODE>ri_right</CODE>[$<CODE>n</CODE>];
        my $<CODE>typel</CODE> = $<CODE>types_to_go</CODE>[$<CODE>il</CODE>];
        my $<CODE>typer</CODE> = $<CODE>types_to_go</CODE>[$<CODE>ir</CODE>];
        return if ( $<CODE>typel</CODE> eq '?' );
        return if ( $<CODE>typer</CODE> eq '?' );
        if    ( $<CODE>typel</CODE> eq ':' ) { $<CODE>i_first_colon</CODE> = $<CODE>il</CODE>; last; }
        elsif ( $<CODE>typer</CODE> eq ':' ) { $<CODE>i_first_colon</CODE> = $<CODE>ir</CODE>; last; }
    }

    # <COMMENTS>For</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>ternary</COMMENTS> <COMMENTS>chains</COMMENTS>,
    # <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> : <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>its</COMMENTS> # ? <COMMENTS>is</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>interior</COMMENTS>
    # <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>preceding</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>good</COMMENTS>
    # <COMMENTS>breakpoints</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> ?.
    if ( $<CODE>i_first_colon</CODE> > 0 ) {
        my $<CODE>i_question</CODE> = $<CODE>mate_index_to_go</CODE>[$<CODE>i_first_colon</CODE>];
        if ( $<CODE>i_question</CODE> > 0 ) {
            my @<CODE>insert_list</CODE>;
            for ( my $<CODE>ii</CODE> = $<CODE>i_question</CODE> - 1 ; $<CODE>ii</CODE> >= 0 ; $<CODE>ii</CODE> -= 1 ) {
                my $<CODE>token</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>ii</CODE>];
                my $<CODE>type</CODE>  = $<CODE>types_to_go</CODE>[$<CODE>ii</CODE>];

                # <COMMENTS>For</COMMENTS> <COMMENTS>now</COMMENTS>, <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>return</COMMENTS>'.
                if ( ( $<CODE>type</CODE> eq ',' || $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>' && $<CODE>token</CODE> eq '<LITERALS>return</LITERALS>' )
                    && <CODE>in_same_container</CODE>( $<CODE>ii</CODE>, $<CODE>i_question</CODE> ) )
                {
                    push @<CODE>insert_list</CODE>, $<CODE>ii</CODE>;
                    last;
                }
            }

            # <COMMENTS>insert</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>points</COMMENTS>
            if (@<CODE>insert_list</CODE>) {
                <CODE>insert_additional_breaks</CODE>( \@<CODE>insert_list</CODE>, $<CODE>ri_left</CODE>, $<CODE>ri_right</CODE> );
            }
        }
    }
}

sub <CODE>in_same_container</CODE> {

    # <COMMENTS>check</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>i1</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>i2</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>same</COMMENTS> <COMMENTS>container</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>separated</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>, ? <COMMENTS>or</COMMENTS> :
    my ( $<CODE>i1</CODE>, $<CODE>i2</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>type</CODE>  = $<CODE>types_to_go</CODE>[$<CODE>i1</CODE>];
    my $<CODE>depth</CODE> = $<CODE>nesting_depth_to_go</CODE>[$<CODE>i1</CODE>];
    return unless ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>i2</CODE>] == $<CODE>depth</CODE> );
    if ( $<CODE>i2</CODE> < $<CODE>i1</CODE> ) { ( $<CODE>i1</CODE>, $<CODE>i2</CODE> ) = ( $<CODE>i2</CODE>, $<CODE>i1</CODE> ) }

    ###########################################################
    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>potentially</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>slow</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>critical</COMMENTS>.
    # <COMMENTS>For</COMMENTS> <COMMENTS>safety</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>large</COMMENTS> <COMMENTS>differences</COMMENTS>.
    # <COMMENTS>See</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>file</COMMENTS> '<COMMENTS>infinite_loop</COMMENTS>.<COMMENTS>txt</COMMENTS>'
    # <COMMENTS>TODO</COMMENTS>: <COMMENTS>replace</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>data</COMMENTS> <COMMENTS>structure</COMMENTS>
    ###########################################################
    return if ( $<CODE>i2</CODE> - $<CODE>i1</CODE> > 200 );

    for ( my $<CODE>i</CODE> = $<CODE>i1</CODE> + 1 ; $<CODE>i</CODE> < $<CODE>i2</CODE> ; $<CODE>i</CODE>++ ) {
        next   if ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>i</CODE>] > $<CODE>depth</CODE> );
        return if ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>i</CODE>] < $<CODE>depth</CODE> );

        my $<CODE>tok</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>];
        $<CODE>tok</CODE> = ',' if $<CODE>tok</CODE> eq '=>';    # <COMMENTS>treat</COMMENTS> => <COMMENTS>same</COMMENTS> <COMMENTS>as</COMMENTS> ,

        # <COMMENTS>Example</COMMENTS>: <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> .'<COMMENTS>s</COMMENTS>
        #  : "<<COMMENTS>A</COMMENTS> <COMMENTS>HREF</COMMENTS>=\"#<COMMENTS>item_</COMMENTS>" . <COMMENTS>htmlify</COMMENTS>( <COMMENTS>0</COMMENTS>, <COMMENTS>$s2</COMMENTS> ) . "\"><COMMENTS>$str</COMMENTS></<COMMENTS>A</COMMENTS>>"
        if ( $<CODE>type</CODE> ne ':' ) {
            return if ( $<CODE>tok</CODE> =~ /^[\,\:\?]$/ ) || $<CODE>tok</CODE> eq '||' || $<CODE>tok</CODE> eq '<LITERALS>or</LITERALS>';
        }
        else {
            return if ( $<CODE>tok</CODE> =~ /^[\,]$/ );
        }
    }
    return 1;
}

sub <CODE>set_continuation_breaks</CODE> {

    # <COMMENTS>Define</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>inserting</COMMENTS> <COMMENTS>newline</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>to</COMMENTS>
    # <COMMENTS>keep</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>lengths</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>desired</COMMENTS> <COMMENTS>length</COMMENTS>.  <COMMENTS>There</COMMENTS> <COMMENTS>is</COMMENTS>
    # <COMMENTS>an</COMMENTS> <COMMENTS>implied</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>included</COMMENTS>.

    # <COMMENTS>Method</COMMENTS>:
    # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>part</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>series</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>routines</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>adjust</COMMENTS> <COMMENTS>line</COMMENTS>
    # <COMMENTS>lengths</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>longer</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>maximum</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>preliminary</COMMENTS> <COMMENTS>scanning</COMMENTS> <COMMENTS>located</COMMENTS>
    # <COMMENTS>desirable</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>points</COMMENTS>.   <COMMENTS>Sub</COMMENTS> <COMMENTS>scan_list</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>looked</COMMENTS> <COMMENTS>at</COMMENTS>
    # <COMMENTS>these</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>breakpoints</COMMENTS> (<COMMENTS>in</COMMENTS> <COMMENTS>array</COMMENTS>
    # <COMMENTS>$forced_breakpoint_to_go</COMMENTS>[<COMMENTS>$i</COMMENTS>]) <COMMENTS>where</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>wants</COMMENTS> <COMMENTS>breaks</COMMENTS> (<COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>
    # <COMMENTS>after</COMMENTS> <COMMENTS>commas</COMMENTS>, <COMMENTS>after</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>parens</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>parens</COMMENTS>).
    # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>honor</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>additional</COMMENTS>
    # <COMMENTS>breakpoints</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>maximum</COMMENTS>
    # <COMMENTS>requested</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>bases</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>decision</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS>' <COMMENTS>is</COMMENTS>
    # <COMMENTS>lowest</COMMENTS>.

    # <COMMENTS>Output</COMMENTS>: <COMMENTS>returns</COMMENTS> <COMMENTS>references</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>arrays</COMMENTS>:
    #  @<COMMENTS>i_first</COMMENTS>
    #  @<COMMENTS>i_last</COMMENTS>
    # <COMMENTS>which</COMMENTS> <COMMENTS>contain</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>each</COMMENTS>
    # <COMMENTS>line</COMMENTS>.

    # <COMMENTS>In</COMMENTS> <COMMENTS>addition</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>array</COMMENTS>:
    #   <COMMENTS>$forced_breakpoint_to_go</COMMENTS>[<COMMENTS>$i</COMMENTS>]
    # <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>updated</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> =<COMMENTS>1</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>signals</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>routines</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>undo</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>breakpoint</COMMENTS>.

    my $<CODE>saw_good_break</CODE> = shift;
    my @<CODE>i_first</CODE>        = ();      # <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>output</COMMENTS>
    my @<CODE>i_last</CODE>         = ();      # <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>output</COMMENTS>
    my @<CODE>i_colon_breaks</CODE> = ();      # <COMMENTS>needed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> ?'<COMMENTS>s</COMMENTS>
    if ( $<CODE>types_to_go</CODE>[0] eq ':' ) { push @<CODE>i_colon_breaks</CODE>, 0 }

    <CODE>set_bond_strengths</CODE>();

    my $<CODE>imin</CODE> = 0;
    my $<CODE>imax</CODE> = $<CODE>max_index_to_go</CODE>;
    if ( $<CODE>types_to_go</CODE>[$<CODE>imin</CODE>] eq '<LITERALS>b</LITERALS>' ) { $<CODE>imin</CODE>++ }
    if ( $<CODE>types_to_go</CODE>[$<CODE>imax</CODE>] eq '<LITERALS>b</LITERALS>' ) { $<CODE>imax</CODE>-- }
    my $<CODE>i_begin</CODE> = $<CODE>imin</CODE>;          # <COMMENTS>index</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>iteration</COMMENTS>

    my $<CODE>leading_spaces</CODE>          = <CODE>leading_spaces_to_go</CODE>($<CODE>imin</CODE>);
    my $<CODE>line_count</CODE>              = 0;
    my $<CODE>last_break_strength</CODE>     = <CODE>NO_BREAK</CODE>;
    my $<CODE>i_last_break</CODE>            = -1;
    my $<CODE>max_bias</CODE>                = 0.001;
    my $<CODE>tiny_bias</CODE>               = 0.0001;
    my $<CODE>leading_alignment_token</CODE> = "";
    my $<CODE>leading_alignment_type</CODE>  = "";

    # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS> ?/:'<COMMENTS>s</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>order</COMMENTS>
    my $<CODE>colons_in_order</CODE> = 1;
    my $<CODE>last_tok</CODE>        = "";
    my @<CODE>colon_list</CODE>  = grep /^[\?\:]$/, @<CODE>types_to_go</CODE>[ 0 .. $<CODE>max_index_to_go</CODE> ];
    my $<CODE>colon_count</CODE> = @<CODE>colon_list</CODE>;
    foreach (@<CODE>colon_list</CODE>) {
        if ( $<CODE>_</CODE> eq $<CODE>last_tok</CODE> ) { $<CODE>colons_in_order</CODE> = 0; last }
        $<CODE>last_tok</CODE> = $<CODE>_</CODE>;
    }

    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sufficient</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>condition</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>colon</COMMENTS> <COMMENTS>chain</COMMENTS>
    my $<CODE>is_colon_chain</CODE> = ( $<CODE>colons_in_order</CODE> && @<CODE>colon_list</CODE> > 2 );

    #-------------------------------------------------------
    # <COMMENTS>BEGINNING</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>breakpoints</COMMENTS>
    # <COMMENTS>Keep</COMMENTS> <COMMENTS>iterating</COMMENTS> <COMMENTS>until</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>reach</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS>
    #-------------------------------------------------------
    while ( $<CODE>i_begin</CODE> <= $<CODE>imax</CODE> ) {
        my $<CODE>lowest_strength</CODE>        = <CODE>NO_BREAK</CODE>;
        my $<CODE>starting_sum</CODE>           = $<CODE>summed_lengths_to_go</CODE>[$<CODE>i_begin</CODE>];
        my $<CODE>i_lowest</CODE>               = -1;
        my $<CODE>i_test</CODE>                 = -1;
        my $<CODE>lowest_next_token</CODE>      = '';
        my $<CODE>lowest_next_type</CODE>       = '<LITERALS>b</LITERALS>';
        my $<CODE>i_lowest_next_nonblank</CODE> = -1;

        #-------------------------------------------------------
        # <COMMENTS>BEGINNING</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>inner</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>breakpoint</COMMENTS>
        #-------------------------------------------------------
        for ( $<CODE>i_test</CODE> = $<CODE>i_begin</CODE> ; $<CODE>i_test</CODE> <= $<CODE>imax</CODE> ; $<CODE>i_test</CODE>++ ) {
            my $<CODE>type</CODE>                     = $<CODE>types_to_go</CODE>[$<CODE>i_test</CODE>];
            my $<CODE>token</CODE>                    = $<CODE>tokens_to_go</CODE>[$<CODE>i_test</CODE>];
            my $<CODE>next_type</CODE>                = $<CODE>types_to_go</CODE>[ $<CODE>i_test</CODE> + 1 ];
            my $<CODE>next_token</CODE>               = $<CODE>tokens_to_go</CODE>[ $<CODE>i_test</CODE> + 1 ];
            my $<CODE>i_next_nonblank</CODE>          = $<CODE>inext_to_go</CODE>[$<CODE>i_test</CODE>];
            my $<CODE>next_nonblank_type</CODE>       = $<CODE>types_to_go</CODE>[$<CODE>i_next_nonblank</CODE>];
            my $<CODE>next_nonblank_token</CODE>      = $<CODE>tokens_to_go</CODE>[$<CODE>i_next_nonblank</CODE>];
            my $<CODE>next_nonblank_block_type</CODE> = $<CODE>block_type_to_go</CODE>[$<CODE>i_next_nonblank</CODE>];
            my $<CODE>strength</CODE>                 = $<CODE>bond_strength_to_go</CODE>[$<CODE>i_test</CODE>];
            my $<CODE>maximum_line_length</CODE>      = <CODE>maximum_line_length</CODE>($<CODE>i_begin</CODE>);

            # <COMMENTS>use</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>tie</COMMENTS>-<COMMENTS>breaker</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>to</COMMENTS>
            # <COMMENTS>prevent</COMMENTS> <COMMENTS>blinkers</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>pbp</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>code</COMMENTS>:

##@<COMMENTS>keywords</COMMENTS>{
##    <COMMENTS>qw</COMMENTS>/<COMMENTS>ARG</COMMENTS> <COMMENTS>OUTPUT</COMMENTS> <COMMENTS>PROTO</COMMENTS> <COMMENTS>CONSTRUCTOR</COMMENTS> <COMMENTS>RETURNS</COMMENTS> <COMMENTS>DESC</COMMENTS> <COMMENTS>PARAMS</COMMENTS> <COMMENTS>SEEALSO</COMMENTS> <COMMENTS>EXAMPLE</COMMENTS>/}
##    = ();

            # <COMMENTS>At</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>time</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS> * <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>code</COMMENTS>
            # <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>formatting</COMMENTS>:
            #
##                <COMMENTS>return</COMMENTS>
##                    <COMMENTS>factorial</COMMENTS>( <COMMENTS>$a</COMMENTS> + <COMMENTS>$b</COMMENTS> - <COMMENTS>1</COMMENTS> ) / <COMMENTS>factorial</COMMENTS>( <COMMENTS>$a</COMMENTS> - <COMMENTS>1</COMMENTS> ) / <COMMENTS>factorial</COMMENTS>( <COMMENTS>$b</COMMENTS> - <COMMENTS>1</COMMENTS> )
##                  * ( <COMMENTS>$x</COMMENTS>**( <COMMENTS>$a</COMMENTS> - <COMMENTS>1</COMMENTS> ) )
##                  * ( ( <COMMENTS>1</COMMENTS> - <COMMENTS>$x</COMMENTS> )**( <COMMENTS>$b</COMMENTS> - <COMMENTS>1</COMMENTS> ) );

            # <COMMENTS>reduce</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bit</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>ties</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>breakpoint</COMMENTS> ...
            if (
                $<CODE>old_breakpoint_to_go</CODE>[$<CODE>i_test</CODE>]

                # <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>good</COMMENTS>' <COMMENTS>breakpoint</COMMENTS>, <COMMENTS>meaning</COMMENTS> ...
                # <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>it</COMMENTS>
                && !$<CODE>want_break_before</CODE>{$<CODE>type</CODE>}

                # <COMMENTS>and</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>token</COMMENTS>
                # <COMMENTS>or</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>short</COMMENTS> (<COMMENTS>i</COMMENTS>.<COMMENTS>e</COMMENTS>. <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> '*', '/' <COMMENTS>etc</COMMENTS>.)
                && $<CODE>i_next_nonblank</CODE> <= $<CODE>imax</CODE>
                && (   $<CODE>want_break_before</CODE>{$<CODE>next_nonblank_type</CODE>}
                    || $<CODE>token_lengths_to_go</CODE>[$<CODE>i_next_nonblank</CODE>] > 2
                    || $<CODE>next_nonblank_type</CODE> =~ /^[\,\(\[\{L]$/ )
              )
            {
                $<CODE>strength</CODE> -= $<CODE>tiny_bias</CODE>;
            }

            # <COMMENTS>otherwise</COMMENTS> <COMMENTS>increase</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bit</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS>
            # <COMMENTS>maximum</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>blinking</COMMENTS>
            # <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>iob</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>added</COMMENTS>.
            else {
                my $<CODE>len</CODE> =
                  $<CODE>leading_spaces</CODE> +
                  $<CODE>summed_lengths_to_go</CODE>[ $<CODE>i_test</CODE> + 1 ] -
                  $<CODE>starting_sum</CODE>;
                if ( $<CODE>len</CODE> >= $<CODE>maximum_line_length</CODE> ) {
                    $<CODE>strength</CODE> += $<CODE>tiny_bias</CODE>;
                }
            }

            my $<CODE>must_break</CODE> = 0;

            # <COMMENTS>Force</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>immediate</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>operators</COMMENTS>
            # <COMMENTS>with</COMMENTS> <COMMENTS>lower</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>,
            # <COMMENTS>unless</COMMENTS> <COMMENTS>we</COMMENTS>'<COMMENTS>ve</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>seen</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>better</COMMENTS> <COMMENTS>break</COMMENTS>.
            #
            ##############################################
            # <COMMENTS>Note</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>issue</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>preceding</COMMENTS> ?
            ##############################################
            # <COMMENTS>We</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>include</COMMENTS> <COMMENTS>a</COMMENTS> ? <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>list</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>may</COMMENTS>
            # <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>previous</COMMENTS> ? <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>long</COMMENTS>.
            # <COMMENTS>Because</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>force</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>if</COMMENTS>
            # <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>previous</COMMENTS> ? <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>now</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>way</COMMENTS>
            # <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>seen</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>lower</COMMENTS> <COMMENTS>strength</COMMENTS>
            # <COMMENTS>point</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>a</COMMENTS> ?.
            #
            # <COMMENTS>Example</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>avoiding</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> '.' <COMMENTS>following</COMMENTS> <COMMENTS>a</COMMENTS> ?
            # <COMMENTS>from</COMMENTS> <COMMENTS>pod2html</COMMENTS> <COMMENTS>using</COMMENTS> <COMMENTS>perltidy</COMMENTS> -<COMMENTS>gnu</COMMENTS>:
            # )
            # ? "\<COMMENTS>n</COMMENTS>&<COMMENTS>lt</COMMENTS>;<COMMENTS>A</COMMENTS> <COMMENTS>NAME</COMMENTS>=\""
            # . <COMMENTS>$value</COMMENTS>
            # . "\"&<COMMENTS>gt</COMMENTS>;\<COMMENTS>n$text</COMMENTS>&<COMMENTS>lt</COMMENTS>;/<COMMENTS>A</COMMENTS>&<COMMENTS>gt</COMMENTS>;\<COMMENTS>n</COMMENTS>"
            # : "\<COMMENTS>n$type$pod2</COMMENTS>.<COMMENTS>html</COMMENTS>\#" . <COMMENTS>$value</COMMENTS> . "\"&<COMMENTS>gt</COMMENTS>;<COMMENTS>$text</COMMENTS>&<COMMENTS>lt</COMMENTS>;\/<COMMENTS>A</COMMENTS>&<COMMENTS>gt</COMMENTS>;\<COMMENTS>n</COMMENTS>";
            if (
                (
                    $<CODE>next_nonblank_type</CODE> =~ /^(\.|\&\&|\|\|)$/
                    || (   $<CODE>next_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>'
                        && $<CODE>next_nonblank_token</CODE> =~ /^(and|or)$/ )
                )
                && ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_begin</CODE>] >
                    $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_next_nonblank</CODE>] )
                && ( $<CODE>strength</CODE> <= $<CODE>lowest_strength</CODE> )
              )
            {
                <CODE>set_forced_breakpoint</CODE>($<CODE>i_next_nonblank</CODE>);
            }

            if (

                # <COMMENTS>Try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>requested</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>scan_list</COMMENTS>
                $<CODE>forced_breakpoint_to_go</CODE>[$<CODE>i_test</CODE>]

                # <COMMENTS>break</COMMENTS> <COMMENTS>between</COMMENTS> ) { <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>continued</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> '{' <COMMENTS>can</COMMENTS>
                # <COMMENTS>be</COMMENTS> <COMMENTS>outdented</COMMENTS>
                # <COMMENTS>See</COMMENTS> <COMMENTS>similar</COMMENTS> <COMMENTS>logic</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>scan_list</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>catches</COMMENTS> <COMMENTS>instances</COMMENTS>
                # <COMMENTS>where</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> ') {'.  <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS>
                # <COMMENTS>be</COMMENTS> <COMMENTS>careful</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>corresponding</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>might</COMMENTS>
                # <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> '<COMMENTS>for</COMMENTS>' <COMMENTS>here</COMMENTS>:
                #
                # <COMMENTS>eval</COMMENTS> {
                #     <COMMENTS>for</COMMENTS> ("<COMMENTS>a</COMMENTS>") {
                #         <COMMENTS>for</COMMENTS> <COMMENTS>$x</COMMENTS> ( <COMMENTS>1</COMMENTS>, <COMMENTS>2</COMMENTS> ) { <COMMENTS>local</COMMENTS> <COMMENTS>$_</COMMENTS> = "<COMMENTS>b</COMMENTS>"; <COMMENTS>s</COMMENTS>/(.*)/+<COMMENTS>$1</COMMENTS>/ }
                #     }
                # };
                #
                || (
                       $<CODE>line_count</CODE>
                    && ( $<CODE>token</CODE> eq ')' )
                    && ( $<CODE>next_nonblank_type</CODE> eq '{' )
                    && ($<CODE>next_nonblank_block_type</CODE>)
                    && ( $<CODE>next_nonblank_block_type</CODE> ne $<CODE>tokens_to_go</CODE>[$<CODE>i_begin</CODE>] )

                    # <COMMENTS>RT</COMMENTS> #<COMMENTS>104427</COMMENTS>: <COMMENTS>Dont</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>because</COMMENTS>
                    # <COMMENTS>sub</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>higher</COMMENTS> <COMMENTS>level</COMMENTS>, <COMMENTS>unless</COMMENTS>
                    # <COMMENTS>it</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>preceeding</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>broken</COMMENTS>
                    && !(
                        $<CODE>next_nonblank_block_type</CODE> =~ /^sub/
                        && ( $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_begin</CODE>] ==
                            $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_next_nonblank</CODE>] )
                    )

                    && !$<CODE>rOpts</CODE>->{'<LITERALS>opening</LITERALS>-<LITERALS>brace</LITERALS>-<LITERALS>always</LITERALS>-<LITERALS>on</LITERALS>-<LITERALS>right</LITERALS>'}
                )

                # <COMMENTS>There</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>implied</COMMENTS> <COMMENTS>forced</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS>
                || ( ( $<CODE>type</CODE> eq '{' ) && ( $<CODE>i_test</CODE> == $<CODE>imax</CODE> ) )
              )
            {

                # <COMMENTS>Forced</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>sometimes</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>overridden</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>
                # <COMMENTS>because</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>causing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>NO_BREAK</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>easier</COMMENTS>
                # <COMMENTS>to</COMMENTS> <COMMENTS>catch</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>set</COMMENTS>.
                if ( $<CODE>strength</CODE> < <CODE>NO_BREAK</CODE> - 1 ) {
                    $<CODE>strength</CODE>   = $<CODE>lowest_strength</CODE> - $<CODE>tiny_bias</CODE>;
                    $<CODE>must_break</CODE> = 1;
                }
            }

            # <COMMENTS>quit</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>on</COMMENTS>
            # <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>break</COMMENTS>
            if (
                   !$<CODE>must_break</CODE>
                && ( $<CODE>next_nonblank_type</CODE> =~ /^[\;\,]$/ )
                && (
                    (
                        $<CODE>leading_spaces</CODE> +
                        $<CODE>summed_lengths_to_go</CODE>[ $<CODE>i_next_nonblank</CODE> + 1 ] -
                        $<CODE>starting_sum</CODE>
                    ) > $<CODE>maximum_line_length</CODE>
                )
              )
            {
                last if ( $<CODE>i_lowest</CODE> >= 0 );
            }

            # <COMMENTS>Avoid</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>strand</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>punctuation</COMMENTS>
            # <COMMENTS>token</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>strand</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS>
            # '.' <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>string</COMMENTS>.
            # <COMMENTS>But</COMMENTS> <COMMENTS>note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>extrude</COMMENTS> (<COMMENTS>l</COMMENTS>=<COMMENTS>1</COMMENTS>)
            # <COMMENTS>so</COMMENTS> <COMMENTS>please</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>changes</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>on</COMMENTS> -<COMMENTS>extrude</COMMENTS>.
            if (
                   !$<CODE>must_break</CODE>
                && ( $<CODE>i_test</CODE> == $<CODE>i_begin</CODE> )
                && ( $<CODE>i_test</CODE> < $<CODE>imax</CODE> )
                && ( $<CODE>token</CODE> eq $<CODE>type</CODE> )
                && (
                    (
                        $<CODE>leading_spaces</CODE> +
                        $<CODE>summed_lengths_to_go</CODE>[ $<CODE>i_test</CODE> + 1 ] -
                        $<CODE>starting_sum</CODE>
                    ) < $<CODE>maximum_line_length</CODE>
                )
              )
            {
                $<CODE>i_test</CODE> = <CODE>min</CODE>( $<CODE>imax</CODE>, $<CODE>inext_to_go</CODE>[$<CODE>i_test</CODE>] );
                redo;
            }

            if ( ( $<CODE>strength</CODE> <= $<CODE>lowest_strength</CODE> ) && ( $<CODE>strength</CODE> < <CODE>NO_BREAK</CODE> ) )
            {

                # <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>produced</COMMENTS>
                # <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS>
                # <COMMENTS>is</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>latest</COMMENTS> <COMMENTS>candidate</COMMENTS> <COMMENTS>break</COMMENTS>
                last
                  if ($<CODE>leading_alignment_type</CODE>);

                # <COMMENTS>Force</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>breakpoint</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>had</COMMENTS> <COMMENTS>good</COMMENTS>
                # <COMMENTS>break</COMMENTS> <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>breakpoint</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>required</COMMENTS> <COMMENTS>or</COMMENTS>
                # <COMMENTS>desired</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>adjustments</COMMENTS>
                # <COMMENTS>over</COMMENTS> <COMMENTS>time</COMMENTS>.  <COMMENTS>A</COMMENTS> <COMMENTS>goal</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>that</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS>
                # <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>introduced</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>formatted</COMMENTS> <COMMENTS>text</COMMENTS>, <COMMENTS>then</COMMENTS>
                # <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>occur</COMMENTS>.  <COMMENTS>scbreak</COMMENTS>.<COMMENTS>t</COMMENTS>
                last
                  if (
                    $<CODE>i_test</CODE> == $<CODE>imax</CODE>              # <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS>
                    && !$<CODE>forced_breakpoint_count</CODE>  #
                    && $<CODE>saw_good_break</CODE>            # <COMMENTS>old</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>had</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>break</COMMENTS>
                    && $<CODE>type</CODE> =~ /^[#;\{]$/        # <COMMENTS>and</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS>
                                                  # ';' <COMMENTS>or</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
                    && $<CODE>i_last_break</CODE> < 0          # <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>haven</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>made</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS>
                    && $<CODE>i_lowest</CODE> >= 0             # <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>saw</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>break</COMMENTS>
                    && $<CODE>i_lowest</CODE> < $<CODE>imax</CODE> - 1      # (<COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>this</COMMENTS> ;)
                    && $<CODE>strength</CODE> - $<CODE>lowest_strength</CODE> < 0.5 * <CODE>WEAK</CODE> # <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>good</COMMENTS>
                  );

                # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>skip</COMMENTS> <COMMENTS>past</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>important</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>point</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>short</COMMENTS> <COMMENTS>final</COMMENTS>
                # <COMMENTS>segment</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>without</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>miss</COMMENTS> <COMMENTS>the</COMMENTS>
                # <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>final</COMMENTS> / <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>code</COMMENTS>:
                #
                #  <COMMENTS>$depth_stop</COMMENTS> =
                #    ( <COMMENTS>$tau</COMMENTS> * <COMMENTS>$mass_pellet</COMMENTS> * <COMMENTS>$q_0</COMMENTS> *
                #        ( <COMMENTS>1</COMMENTS>. - <COMMENTS>exp</COMMENTS>( -<COMMENTS>$t_stop</COMMENTS> / <COMMENTS>$tau</COMMENTS> ) ) -
                #        <COMMENTS>4</COMMENTS>. * <COMMENTS>$pi</COMMENTS> * <COMMENTS>$factor</COMMENTS> * <COMMENTS>$k_ice</COMMENTS> *
                #        ( <COMMENTS>$t_melt</COMMENTS> - <COMMENTS>$t_ice</COMMENTS> ) *
                #        <COMMENTS>$r_pellet</COMMENTS> *
                #        <COMMENTS>$t_stop</COMMENTS> ) /
                #    ( <COMMENTS>$rho_ice</COMMENTS> * <COMMENTS>$Qs</COMMENTS> * <COMMENTS>$pi</COMMENTS> * <COMMENTS>$r_pellet</COMMENTS>**<COMMENTS>2</COMMENTS> );
                #
                if (   $<CODE>line_count</CODE> > 2
                    && $<CODE>i_lowest</CODE> < $<CODE>i_test</CODE>
                    && $<CODE>i_test</CODE> > $<CODE>imax</CODE> - 2
                    && $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_begin</CODE>] >
                    $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_lowest</CODE>]
                    && $<CODE>lowest_strength</CODE> < $<CODE>last_break_strength</CODE> - .5 * <CODE>WEAK</CODE> )
                {
                    # <COMMENTS>Make</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>math</COMMENTS> <COMMENTS>operators</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>now</COMMENTS>
                    my $<CODE>ir</CODE> = $<CODE>inext_to_go</CODE>[$<CODE>i_lowest</CODE>];
                    my $<CODE>il</CODE> = $<CODE>iprev_to_go</CODE>[$<CODE>ir</CODE>];
                    last
                      if ( $<CODE>types_to_go</CODE>[$<CODE>il</CODE>] =~ /^[\/\*\+\-\%]$/
                        || $<CODE>types_to_go</CODE>[$<CODE>ir</CODE>] =~ /^[\/\*\+\-\%]$/ );
                }

                # <COMMENTS>Update</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>minimum</COMMENTS> <COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>location</COMMENTS>
                $<CODE>lowest_strength</CODE>        = $<CODE>strength</CODE>;
                $<CODE>i_lowest</CODE>               = $<CODE>i_test</CODE>;
                $<CODE>lowest_next_token</CODE>      = $<CODE>next_nonblank_token</CODE>;
                $<CODE>lowest_next_type</CODE>       = $<CODE>next_nonblank_type</CODE>;
                $<CODE>i_lowest_next_nonblank</CODE> = $<CODE>i_next_nonblank</CODE>;
                last if $<CODE>must_break</CODE>;

                # <COMMENTS>set</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>remember</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>produce</COMMENTS> <COMMENTS>a</COMMENTS>
                # <COMMENTS>leading</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>tokens</COMMENTS>
                if (   $<CODE>line_count</CODE> > 0
                    && $<CODE>i_test</CODE> < $<CODE>imax</CODE>
                    && ( $<CODE>lowest_strength</CODE> - $<CODE>last_break_strength</CODE> <= $<CODE>max_bias</CODE> )
                  )
                {
                    my $<CODE>i_last_end</CODE> = $<CODE>iprev_to_go</CODE>[$<CODE>i_begin</CODE>];
                    my $<CODE>tok_beg</CODE>    = $<CODE>tokens_to_go</CODE>[$<CODE>i_begin</CODE>];
                    my $<CODE>type_beg</CODE>   = $<CODE>types_to_go</CODE>[$<CODE>i_begin</CODE>];
                    if (

                        # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>tokens</COMMENTS>
                        (
                               $<CODE>tok_beg</CODE> eq $<CODE>next_nonblank_token</CODE>
                            && $<CODE>is_chain_operator</CODE>{$<CODE>tok_beg</CODE>}
                            && (   $<CODE>type_beg</CODE> eq '<LITERALS>k</LITERALS>'
                                || $<CODE>type_beg</CODE> eq $<CODE>tok_beg</CODE> )
                            && $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_begin</CODE>] >=
                            $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_next_nonblank</CODE>]
                        )

                        || (   $<CODE>tokens_to_go</CODE>[$<CODE>i_last_end</CODE>] eq $<CODE>token</CODE>
                            && $<CODE>is_chain_operator</CODE>{$<CODE>token</CODE>}
                            && ( $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>' || $<CODE>type</CODE> eq $<CODE>token</CODE> )
                            && $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_last_end</CODE>] >=
                            $<CODE>nesting_depth_to_go</CODE>[$<CODE>i_test</CODE>] )
                      )
                    {
                        $<CODE>leading_alignment_token</CODE> = $<CODE>next_nonblank_token</CODE>;
                        $<CODE>leading_alignment_type</CODE>  = $<CODE>next_nonblank_type</CODE>;
                    }
                }
            }

            my $<CODE>too_long</CODE> = ( $<CODE>i_test</CODE> >= $<CODE>imax</CODE> );
            if ( !$<CODE>too_long</CODE> ) {
                my $<CODE>next_length</CODE> =
                  $<CODE>leading_spaces</CODE> +
                  $<CODE>summed_lengths_to_go</CODE>[ $<CODE>i_test</CODE> + 2 ] -
                  $<CODE>starting_sum</CODE>;
                $<CODE>too_long</CODE> = $<CODE>next_length</CODE> > $<CODE>maximum_line_length</CODE>;

                # <COMMENTS>To</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>blinkers</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>leaving</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>exactly</COMMENTS> <COMMENTS>at</COMMENTS>
                # <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>limit</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS>
                # <COMMENTS>several</COMMENTS> "<COMMENTS>good</COMMENTS>" <COMMENTS>types</COMMENTS>.
                #
                # <COMMENTS>The</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blinker</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>pbp</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>this</COMMENTS>
                # <COMMENTS>modification</COMMENTS>:
##                    <COMMENTS>$last_nonblank_token</COMMENTS> <COMMENTS>eq</COMMENTS> '('
##                        && <COMMENTS>$is_indirect_object_taker</COMMENTS>{ <COMMENTS>$paren_type</COMMENTS>
##                            [<COMMENTS>$paren_depth</COMMENTS>] }
                # <COMMENTS>The</COMMENTS> <COMMENTS>issue</COMMENTS> <COMMENTS>causing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS>
                # <COMMENTS>term</COMMENTS> [<COMMENTS>$paren_depth</COMMENTS>] <COMMENTS>gets</COMMENTS> <COMMENTS>broken</COMMENTS> <COMMENTS>across</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>then</COMMENTS>
                # <COMMENTS>the</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS>
                # <COMMENTS>brackets</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>format</COMMENTS> <COMMENTS>like</COMMENTS> '[ <COMMENTS>$paren_depth</COMMENTS> ]'.  <COMMENTS>This</COMMENTS>
                # <COMMENTS>leads</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>oscillation</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>depending</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>break</COMMENTS>
                # <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>bracket</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>not</COMMENTS>.
                if (  !$<CODE>too_long</CODE>
                    && $<CODE>i_test</CODE> + 1 < $<CODE>imax</CODE>
                    && $<CODE>next_nonblank_type</CODE> !~ /^[,\}\]\)R]$/ )
                {
                    $<CODE>too_long</CODE> = $<CODE>next_length</CODE> >= $<CODE>maximum_line_length</CODE>;
                }
            }

            <CODE>FORMATTER_DEBUG_FLAG_BREAK</CODE>
              && do {
                my $<CODE>ltok</CODE>     = $<CODE>token</CODE>;
                my $<CODE>rtok</CODE>     = $<CODE>next_nonblank_token</CODE> ? $<CODE>next_nonblank_token</CODE> : "";
                my $<CODE>i_testp2</CODE> = $<CODE>i_test</CODE> + 2;
                if ( $<CODE>i_testp2</CODE> > $<CODE>max_index_to_go</CODE> + 1 ) {
                    $<CODE>i_testp2</CODE> = $<CODE>max_index_to_go</CODE> + 1;
                }
                if ( length($<CODE>ltok</CODE>) > 6 ) { $<CODE>ltok</CODE> = substr( $<CODE>ltok</CODE>, 0, 8 ) }
                if ( length($<CODE>rtok</CODE>) > 6 ) { $<CODE>rtok</CODE> = substr( $<CODE>rtok</CODE>, 0, 8 ) }
                print <CODE>STDOUT</CODE>
"<LITERALS>BREAK</LITERALS>: <LITERALS>i</LITERALS>=$<CODE>i_test</CODE> <LITERALS>imax</LITERALS>=$<CODE>imax</CODE> $<CODE>types_to_go</CODE>[$<CODE>i_test</CODE>] $<CODE>next_nonblank_type</CODE> <LITERALS>sp</LITERALS>=($<CODE>leading_spaces</CODE>) <LITERALS>lnext</LITERALS>= $<CODE>summed_lengths_to_go</CODE>[$<CODE>i_testp2</CODE>] <LITERALS>2long</LITERALS>=$<CODE>too_long</CODE> <LITERALS>str</LITERALS>=$<CODE>strength</CODE>    $<CODE>ltok</CODE> $<CODE>rtok</CODE>\n";
              };

            # <COMMENTS>allow</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>exceeding</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>
            # <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>strand</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS>.
            if (   $<CODE>rOpts_fuzzy_line_length</CODE>
                && $<CODE>too_long</CODE>
                && $<CODE>i_lowest</CODE> == $<CODE>i_test</CODE>
                && $<CODE>token_lengths_to_go</CODE>[$<CODE>i_test</CODE>] > 1
                && $<CODE>next_nonblank_type</CODE> =~ /^[\;\,]$/ )
            {
                $<CODE>too_long</CODE> = 0;
            }

            last
              if (
                ( $<CODE>i_test</CODE> == $<CODE>imax</CODE> )    # <COMMENTS>we</COMMENTS>'<COMMENTS>re</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>tokens</COMMENTS>,
                || (
                    ( $<CODE>i_lowest</CODE> >= 0 )    # <COMMENTS>or</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS>
                    && $<CODE>too_long</CODE>
                )
              );
        }

        #-------------------------------------------------------
        # <COMMENTS>END</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>inner</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>breakpoint</COMMENTS>
        # <COMMENTS>Now</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>exactly</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>breakpoint</COMMENTS>
        #-------------------------------------------------------

        # <COMMENTS>it</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>imax</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>found</COMMENTS>
        if ( $<CODE>i_lowest</CODE> < 0 ) { $<CODE>i_lowest</CODE> = $<CODE>imax</CODE> }

        # <COMMENTS>semi</COMMENTS>-<COMMENTS>final</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>calculation</COMMENTS>
        my $<CODE>i_next_nonblank</CODE>     = $<CODE>inext_to_go</CODE>[$<CODE>i_lowest</CODE>];
        my $<CODE>next_nonblank_type</CODE>  = $<CODE>types_to_go</CODE>[$<CODE>i_next_nonblank</CODE>];
        my $<CODE>next_nonblank_token</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>i_next_nonblank</CODE>];

        #-------------------------------------------------------
        # ?/: <COMMENTS>rule</COMMENTS> <COMMENTS>1</COMMENTS> : <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>a</COMMENTS> '?' <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS>
        # <COMMENTS>line</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>closing</COMMENTS> ':', <COMMENTS>then</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> '?' <COMMENTS>instead</COMMENTS>.
        #-------------------------------------------------------
        my $<CODE>i</CODE>;
        foreach $<CODE>i</CODE> ( $<CODE>i_begin</CODE> + 1 .. $<CODE>i_lowest</CODE> - 1 ) {
            next unless ( $<CODE>tokens_to_go</CODE>[$<CODE>i</CODE>] eq '?' );

            # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>probable</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>of</COMMENTS> ?/: <COMMENTS>statements</COMMENTS>
            next if ($<CODE>is_colon_chain</CODE>);

            # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>broken</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
            next
              if (
                $<CODE>tokens_to_go</CODE>[$<CODE>max_index_to_go</CODE>] eq '#'
                && <CODE>terminal_type</CODE>( \@<CODE>types_to_go</CODE>, \@<CODE>block_type_to_go</CODE>, 0,
                    $<CODE>max_index_to_go</CODE> ) !~ /^[\;\}]$/
              );

            # <COMMENTS>no</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>matching</COMMENTS> : <COMMENTS>is</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>
            next
              if ( $<CODE>mate_index_to_go</CODE>[$<CODE>i</CODE>] >= 0
                && $<CODE>mate_index_to_go</CODE>[$<CODE>i</CODE>] <= $<CODE>i_next_nonblank</CODE> );

            $<CODE>i_lowest</CODE> = $<CODE>i</CODE>;
            if ( $<CODE>want_break_before</CODE>{'?'} ) { $<CODE>i_lowest</CODE>-- }
            last;
        }

        #-------------------------------------------------------
        # <COMMENTS>END</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>inner</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>breakpoint</COMMENTS>:
        # <COMMENTS>Break</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>i</COMMENTS>=<COMMENTS>$i_lowest</COMMENTS>
        #-------------------------------------------------------

        # <COMMENTS>final</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>calculation</COMMENTS>
        $<CODE>i_next_nonblank</CODE>     = $<CODE>inext_to_go</CODE>[$<CODE>i_lowest</CODE>];
        $<CODE>next_nonblank_type</CODE>  = $<CODE>types_to_go</CODE>[$<CODE>i_next_nonblank</CODE>];
        $<CODE>next_nonblank_token</CODE> = $<CODE>tokens_to_go</CODE>[$<CODE>i_next_nonblank</CODE>];

        <CODE>FORMATTER_DEBUG_FLAG_BREAK</CODE>
          && print <CODE>STDOUT</CODE>
          "<LITERALS>BREAK</LITERALS>: <LITERALS>best</LITERALS> <LITERALS>is</LITERALS> <LITERALS>i</LITERALS> = $<CODE>i_lowest</CODE> <LITERALS>strength</LITERALS> = $<CODE>lowest_strength</CODE>\n";

        #-------------------------------------------------------
        # ?/: <COMMENTS>rule</COMMENTS> <COMMENTS>2</COMMENTS> : <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> '?', <COMMENTS>then</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>its</COMMENTS> ':'
        #
        # <COMMENTS>Note</COMMENTS>: <COMMENTS>this</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>scan_list</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS>
        # <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> (<COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>dictated</COMMENTS>
        # <COMMENTS>by</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>).
        #-------------------------------------------------------
        if ( $<CODE>next_nonblank_type</CODE> eq '?' ) {
            <CODE>set_closing_breakpoint</CODE>($<CODE>i_next_nonblank</CODE>);
        }
        elsif ( $<CODE>types_to_go</CODE>[$<CODE>i_lowest</CODE>] eq '?' ) {
            <CODE>set_closing_breakpoint</CODE>($<CODE>i_lowest</CODE>);
        }

        #-------------------------------------------------------
        # ?/: <COMMENTS>rule</COMMENTS> <COMMENTS>3</COMMENTS> : <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> ':' <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>save</COMMENTS>
        # <COMMENTS>its</COMMENTS> <COMMENTS>location</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>further</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>below</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>go</COMMENTS>
        # <COMMENTS>back</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>its</COMMENTS> '?'.
        #-------------------------------------------------------
        if ( $<CODE>next_nonblank_type</CODE> eq ':' ) {
            push @<CODE>i_colon_breaks</CODE>, $<CODE>i_next_nonblank</CODE>;
        }
        elsif ( $<CODE>types_to_go</CODE>[$<CODE>i_lowest</CODE>] eq ':' ) {
            push @<CODE>i_colon_breaks</CODE>, $<CODE>i_lowest</CODE>;
        }

        # <COMMENTS>here</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>all</COMMENTS> '?'/':' <COMMENTS>pairs</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS>
        # <COMMENTS>separated</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>

        $<CODE>line_count</CODE>++;

        # <COMMENTS>save</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>segment</COMMENTS>, <COMMENTS>after</COMMENTS> <COMMENTS>trimming</COMMENTS> <COMMENTS>blanks</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>ends</COMMENTS>
        push( @<CODE>i_first</CODE>,
            ( $<CODE>types_to_go</CODE>[$<CODE>i_begin</CODE>] eq '<LITERALS>b</LITERALS>' ) ? $<CODE>i_begin</CODE> + 1 : $<CODE>i_begin</CODE> );
        push( @<CODE>i_last</CODE>,
            ( $<CODE>types_to_go</CODE>[$<CODE>i_lowest</CODE>] eq '<LITERALS>b</LITERALS>' ) ? $<CODE>i_lowest</CODE> - 1 : $<CODE>i_lowest</CODE> );

        # <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>forced</COMMENTS> <COMMENTS>breakpoint</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>opening</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>, <COMMENTS>to</COMMENTS>
        # <COMMENTS>signal</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>container</COMMENTS>.  <COMMENTS>Excepting</COMMENTS> '(' <COMMENTS>for</COMMENTS> <COMMENTS>now</COMMENTS>.
        if ( $<CODE>tokens_to_go</CODE>[$<CODE>i_lowest</CODE>] =~ /^[\{\[]$/
            && !$<CODE>forced_breakpoint_to_go</CODE>[$<CODE>i_lowest</CODE>] )
        {
            <CODE>set_closing_breakpoint</CODE>($<CODE>i_lowest</CODE>);
        }

        # <COMMENTS>get</COMMENTS> <COMMENTS>ready</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>again</COMMENTS>
        $<CODE>i_begin</CODE>                 = $<CODE>i_lowest</CODE> + 1;
        $<CODE>last_break_strength</CODE>     = $<CODE>lowest_strength</CODE>;
        $<CODE>i_last_break</CODE>            = $<CODE>i_lowest</CODE>;
        $<CODE>leading_alignment_token</CODE> = "";
        $<CODE>leading_alignment_type</CODE>  = "";
        $<CODE>lowest_next_token</CODE>       = '';
        $<CODE>lowest_next_type</CODE>        = '<LITERALS>b</LITERALS>';

        if ( ( $<CODE>i_begin</CODE> <= $<CODE>imax</CODE> ) && ( $<CODE>types_to_go</CODE>[$<CODE>i_begin</CODE>] eq '<LITERALS>b</LITERALS>' ) ) {
            $<CODE>i_begin</CODE>++;
        }

        # <COMMENTS>update</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>size</COMMENTS>
        if ( $<CODE>i_begin</CODE> <= $<CODE>imax</CODE> ) {
            $<CODE>leading_spaces</CODE> = <CODE>leading_spaces_to_go</CODE>($<CODE>i_begin</CODE>);
        }
    }

    #-------------------------------------------------------
    # <COMMENTS>END</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>breakpoints</COMMENTS>
    # <COMMENTS>Now</COMMENTS> <COMMENTS>go</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>corrections</COMMENTS>
    #-------------------------------------------------------

    #-------------------------------------------------------
    # ?/: <COMMENTS>rule</COMMENTS> <COMMENTS>4</COMMENTS> -- <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>broke</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> ':', <COMMENTS>then</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS>
    # <COMMENTS>corresponding</COMMENTS> '?' <COMMENTS>unless</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>of</COMMENTS> ?: <COMMENTS>expressions</COMMENTS>
    #-------------------------------------------------------
    if (@<CODE>i_colon_breaks</CODE>) {

        # <COMMENTS>using</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>deciding</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> ?/: <COMMENTS>chain</COMMENTS> --
        # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>chain</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>multiple</COMMENTS> ?/: <COMMENTS>pairs</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>order</COMMENTS>;
        # <COMMENTS>otherwise</COMMENTS> <COMMENTS>not</COMMENTS>.
        # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>starts</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> ':' <COMMENTS>we</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS>
        my $<CODE>is_chain</CODE> = ( $<CODE>colons_in_order</CODE> && @<CODE>i_colon_breaks</CODE> > 1 );

        unless ($<CODE>is_chain</CODE>) {
            my @<CODE>insert_list</CODE> = ();
            foreach (@<CODE>i_colon_breaks</CODE>) {
                my $<CODE>i_question</CODE> = $<CODE>mate_index_to_go</CODE>[$<CODE>_</CODE>];
                if ( $<CODE>i_question</CODE> >= 0 ) {
                    if ( $<CODE>want_break_before</CODE>{'?'} ) {
                        $<CODE>i_question</CODE> = $<CODE>iprev_to_go</CODE>[$<CODE>i_question</CODE>];
                    }

                    if ( $<CODE>i_question</CODE> >= 0 ) {
                        push @<CODE>insert_list</CODE>, $<CODE>i_question</CODE>;
                    }
                }
                <CODE>insert_additional_breaks</CODE>( \@<CODE>insert_list</CODE>, \@<CODE>i_first</CODE>, \@<CODE>i_last</CODE> );
            }
        }
    }
    return ( \@<CODE>i_first</CODE>, \@<CODE>i_last</CODE>, $<CODE>colon_count</CODE> );
}

sub <CODE>insert_additional_breaks</CODE> {

    # <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>requested</COMMENTS> <COMMENTS>locations</COMMENTS> <COMMENTS>after</COMMENTS>
    # <COMMENTS>sub</COMMENTS> <COMMENTS>set_continuation_breaks</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>made</COMMENTS> <COMMENTS>preliminary</COMMENTS> <COMMENTS>breaks</COMMENTS>.

    my ( $<CODE>ri_break_list</CODE>, $<CODE>ri_first</CODE>, $<CODE>ri_last</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>i_f</CODE>;
    my $<CODE>i_l</CODE>;
    my $<CODE>line_number</CODE> = 0;
    my $<CODE>i_break_left</CODE>;
    foreach $<CODE>i_break_left</CODE> ( sort { $<CODE>a</CODE> <=> $<CODE>b</CODE> } @$<CODE>ri_break_list</CODE> ) {

        $<CODE>i_f</CODE> = $$<CODE>ri_first</CODE>[$<CODE>line_number</CODE>];
        $<CODE>i_l</CODE> = $$<CODE>ri_last</CODE>[$<CODE>line_number</CODE>];
        while ( $<CODE>i_break_left</CODE> >= $<CODE>i_l</CODE> ) {
            $<CODE>line_number</CODE>++;

            # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>caller</COMMENTS> <COMMENTS>passes</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>indexes</COMMENTS>
            if ( $<CODE>line_number</CODE> >= @$<CODE>ri_last</CODE> ) {
                <CODE>warning</CODE>(
"<LITERALS>Non</LITERALS>-<LITERALS>fatal</LITERALS> <LITERALS>program</LITERALS> <LITERALS>bug</LITERALS>: <LITERALS>couldn</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>set</LITERALS> <LITERALS>break</LITERALS> <LITERALS>at</LITERALS> $<CODE>i_break_left</CODE>\n"
                );
                <CODE>report_definite_bug</CODE>();
                return;
            }
            $<CODE>i_f</CODE> = $$<CODE>ri_first</CODE>[$<CODE>line_number</CODE>];
            $<CODE>i_l</CODE> = $$<CODE>ri_last</CODE>[$<CODE>line_number</CODE>];
        }

        # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>leave</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>; <COMMENTS>back</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
        if ( $<CODE>types_to_go</CODE>[$<CODE>i_break_left</CODE>] eq '<LITERALS>b</LITERALS>' ) { $<CODE>i_break_left</CODE>-- }

        my $<CODE>i_break_right</CODE> = $<CODE>inext_to_go</CODE>[$<CODE>i_break_left</CODE>];
        if (   $<CODE>i_break_left</CODE> >= $<CODE>i_f</CODE>
            && $<CODE>i_break_left</CODE> < $<CODE>i_l</CODE>
            && $<CODE>i_break_right</CODE> > $<CODE>i_f</CODE>
            && $<CODE>i_break_right</CODE> <= $<CODE>i_l</CODE> )
        {
            splice( @$<CODE>ri_first</CODE>, $<CODE>line_number</CODE>, 1, ( $<CODE>i_f</CODE>, $<CODE>i_break_right</CODE> ) );
            splice( @$<CODE>ri_last</CODE>, $<CODE>line_number</CODE>, 1, ( $<CODE>i_break_left</CODE>, $<CODE>i_l</CODE> ) );
        }
    }
}

sub <CODE>set_closing_breakpoint</CODE> {

    # <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>breakpoint</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>matching</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS>
    # <COMMENTS>at</COMMENTS> <COMMENTS>present</COMMENTS>, <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> ':' <COMMENTS>which</COMMENTS> <COMMENTS>matches</COMMENTS> <COMMENTS>a</COMMENTS> '?'
    my $<CODE>i_break</CODE> = shift;

    if ( $<CODE>mate_index_to_go</CODE>[$<CODE>i_break</CODE>] >= 0 ) {

        # <COMMENTS>CAUTION</COMMENTS>: <COMMENTS>infinite</COMMENTS> <COMMENTS>recursion</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>here</COMMENTS>:
        #   <COMMENTS>set_closing_breakpoint</COMMENTS> <COMMENTS>calls</COMMENTS> <COMMENTS>set_forced_breakpoint</COMMENTS>, <COMMENTS>and</COMMENTS>
        #   <COMMENTS>set_forced_breakpoint</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>set_closing_breakpoint</COMMENTS>
        #   ( <COMMENTS>test</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>attrib</COMMENTS>.<COMMENTS>t</COMMENTS>, <COMMENTS>BasicLyx</COMMENTS>.<COMMENTS>pm</COMMENTS>.<COMMENTS>html</COMMENTS>).
        # <COMMENTS>Don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>reduce</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>2</COMMENTS>' <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>below</COMMENTS>
        if ( $<CODE>mate_index_to_go</CODE>[$<CODE>i_break</CODE>] > $<CODE>i_break</CODE> + 2 ) {

            # <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> } ] <COMMENTS>and</COMMENTS> ), <COMMENTS>but</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>set_forced_breakpoint</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>decide</COMMENTS>
            # <COMMENTS>to</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> ? <COMMENTS>and</COMMENTS> :
            my $<CODE>inc</CODE> = ( $<CODE>tokens_to_go</CODE>[$<CODE>i_break</CODE>] eq '?' ) ? 0 : 1;
            <CODE>set_forced_breakpoint</CODE>( $<CODE>mate_index_to_go</CODE>[$<CODE>i_break</CODE>] - $<CODE>inc</CODE> );
        }
    }
    else {
        my $<CODE>type_sequence</CODE> = $<CODE>type_sequence_to_go</CODE>[$<CODE>i_break</CODE>];
        if ($<CODE>type_sequence</CODE>) {
            my $<CODE>closing_token</CODE> = $<CODE>matching_token</CODE>{ $<CODE>tokens_to_go</CODE>[$<CODE>i_break</CODE>] };
            $<CODE>postponed_breakpoint</CODE>{$<CODE>type_sequence</CODE>} = 1;
        }
    }
}

sub <CODE>compare_indentation_levels</CODE> {

    # <COMMENTS>check</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>tabbing</COMMENTS> <COMMENTS>agrees</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>line</COMMENTS>
    # <COMMENTS>this</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>useful</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>debugging</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>script</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>extra</COMMENTS>
    # <COMMENTS>or</COMMENTS> <COMMENTS>missing</COMMENTS> <COMMENTS>brace</COMMENTS>
    my ( $<CODE>guessed_indentation_level</CODE>, $<CODE>structural_indentation_level</CODE> ) = @<CODE>_</CODE>;
    if ( $<CODE>guessed_indentation_level</CODE> ne $<CODE>structural_indentation_level</CODE> ) {
        $<CODE>last_tabbing_disagreement</CODE> = $<CODE>input_line_number</CODE>;

        if ($<CODE>in_tabbing_disagreement</CODE>) {
        }
        else {
            $<CODE>tabbing_disagreement_count</CODE>++;

            if ( $<CODE>tabbing_disagreement_count</CODE> <= <CODE>MAX_NAG_MESSAGES</CODE> ) {
                <CODE>write_logfile_entry</CODE>(
"<LITERALS>Start</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>disagreement</LITERALS>: <LITERALS>input</LITERALS>=$<CODE>guessed_indentation_level</CODE>; <LITERALS>output</LITERALS>=$<CODE>structural_indentation_level</CODE>\n"
                );
            }
            $<CODE>in_tabbing_disagreement</CODE>    = $<CODE>input_line_number</CODE>;
            $<CODE>first_tabbing_disagreement</CODE> = $<CODE>in_tabbing_disagreement</CODE>
              unless ($<CODE>first_tabbing_disagreement</CODE>);
        }
    }
    else {

        if ($<CODE>in_tabbing_disagreement</CODE>) {

            if ( $<CODE>tabbing_disagreement_count</CODE> <= <CODE>MAX_NAG_MESSAGES</CODE> ) {
                <CODE>write_logfile_entry</CODE>(
"<LITERALS>End</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>disagreement</LITERALS> <LITERALS>from</LITERALS> <LITERALS>input</LITERALS> <LITERALS>line</LITERALS> $<CODE>in_tabbing_disagreement</CODE>\n"
                );

                if ( $<CODE>tabbing_disagreement_count</CODE> == <CODE>MAX_NAG_MESSAGES</CODE> ) {
                    <CODE>write_logfile_entry</CODE>(
                        "<LITERALS>No</LITERALS> <LITERALS>further</LITERALS> <LITERALS>tabbing</LITERALS> <LITERALS>disagreements</LITERALS> <LITERALS>will</LITERALS> <LITERALS>be</LITERALS> <LITERALS>noted</LITERALS>\n");
                }
            }
            $<CODE>in_tabbing_disagreement</CODE> = 0;
        }
    }
}

#####################################################################
#
# <COMMENTS>the</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>IndentationItem</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>supplies</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>contain</COMMENTS>
# <COMMENTS>how</COMMENTS> <COMMENTS>much</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>
#
#####################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>IndentationItem</CODE>;

# <COMMENTS>Indexes</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>items</COMMENTS>
use <CODE>constant</CODE> <LITERALS>SPACES</LITERALS>             => 0;     # <COMMENTS>total</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>white</COMMENTS> <COMMENTS>spaces</COMMENTS>
use <CODE>constant</CODE> <LITERALS>LEVEL</LITERALS>              => 1;     # <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> '<COMMENTS>level</COMMENTS>'
use <CODE>constant</CODE> <LITERALS>CI_LEVEL</LITERALS>           => 2;     # <COMMENTS>the</COMMENTS> '<COMMENTS>continuation</COMMENTS> <COMMENTS>level</COMMENTS>'
use <CODE>constant</CODE> <LITERALS>AVAILABLE_SPACES</LITERALS>   => 3;     # <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>available</COMMENTS>
                                          # <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>level</COMMENTS>
use <CODE>constant</CODE> <LITERALS>CLOSED</LITERALS>             => 4;     # <COMMENTS>index</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>saw</COMMENTS> <COMMENTS>closing</COMMENTS> '}'
use <CODE>constant</CODE> <LITERALS>COMMA_COUNT</LITERALS>        => 5;     # <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>level</COMMENTS>?
use <CODE>constant</CODE> <LITERALS>SEQUENCE_NUMBER</LITERALS>    => 6;     # <COMMENTS>output</COMMENTS> <COMMENTS>batch</COMMENTS> <COMMENTS>number</COMMENTS>
use <CODE>constant</CODE> <LITERALS>INDEX</LITERALS>              => 7;     # <COMMENTS>index</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>batch</COMMENTS> <COMMENTS>list</COMMENTS>
use <CODE>constant</CODE> <LITERALS>HAVE_CHILD</LITERALS>         => 8;     # <COMMENTS>any</COMMENTS> <COMMENTS>dependents</COMMENTS>?
use <CODE>constant</CODE> <LITERALS>RECOVERABLE_SPACES</LITERALS> => 9;     # <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS>
                                          # <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>move</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS>
                                          # <COMMENTS>alignment</COMMENTS> (<COMMENTS>negative</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>left</COMMENTS>)
use <CODE>constant</CODE> <LITERALS>ALIGN_PAREN</LITERALS>        => 10;    # <COMMENTS>do</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS>
                                          # <COMMENTS>with</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>structure</COMMENTS>?
use <CODE>constant</CODE> <LITERALS>MARKED</LITERALS>             => 11;    # <COMMENTS>if</COMMENTS> <COMMENTS>visited</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>corrector</COMMENTS> <COMMENTS>logic</COMMENTS>
use <CODE>constant</CODE> <LITERALS>STACK_DEPTH</LITERALS>        => 12;    # <COMMENTS>indentation</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depth</COMMENTS>
use <CODE>constant</CODE> <LITERALS>STARTING_INDEX</LITERALS>     => 13;    # <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>level</COMMENTS>
use <CODE>constant</CODE> <LITERALS>ARROW_COUNT</LITERALS>        => 14;    # <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> =>'<COMMENTS>s</COMMENTS>

sub <CODE>new</CODE> {

    # <COMMENTS>Create</COMMENTS> <COMMENTS>an</COMMENTS> '<COMMENTS>indentation_item</COMMENTS>' <COMMENTS>which</COMMENTS> <COMMENTS>describes</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>leading</COMMENTS>
    # <COMMENTS>whitespace</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>the</COMMENTS> '-<COMMENTS>lp</COMMENTS>' <COMMENTS>indentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>return</COMMENTS>
    # <COMMENTS>a</COMMENTS> <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>associated</COMMENTS> <COMMENTS>variables</COMMENTS>.
    # <COMMENTS>See</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>constants</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>storage</COMMENTS> <COMMENTS>scheme</COMMENTS>.
    my (
        $<CODE>class</CODE>,               $<CODE>spaces</CODE>,           $<CODE>level</CODE>,
        $<CODE>ci_level</CODE>,            $<CODE>available_spaces</CODE>, $<CODE>index</CODE>,
        $<CODE>gnu_sequence_number</CODE>, $<CODE>align_paren</CODE>,      $<CODE>stack_depth</CODE>,
        $<CODE>starting_index</CODE>,
    ) = @<CODE>_</CODE>;
    my $<CODE>closed</CODE>            = -1;
    my $<CODE>arrow_count</CODE>       = 0;
    my $<CODE>comma_count</CODE>       = 0;
    my $<CODE>have_child</CODE>        = 0;
    my $<CODE>want_right_spaces</CODE> = 0;
    my $<CODE>marked</CODE>            = 0;
    bless [
        $<CODE>spaces</CODE>,              $<CODE>level</CODE>,          $<CODE>ci_level</CODE>,
        $<CODE>available_spaces</CODE>,    $<CODE>closed</CODE>,         $<CODE>comma_count</CODE>,
        $<CODE>gnu_sequence_number</CODE>, $<CODE>index</CODE>,          $<CODE>have_child</CODE>,
        $<CODE>want_right_spaces</CODE>,   $<CODE>align_paren</CODE>,    $<CODE>marked</CODE>,
        $<CODE>stack_depth</CODE>,         $<CODE>starting_index</CODE>, $<CODE>arrow_count</CODE>,
    ], $<CODE>class</CODE>;
}

sub <CODE>permanently_decrease_AVAILABLE_SPACES</CODE> {

    # <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>permanent</COMMENTS> <COMMENTS>reduction</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>available</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>spaces</COMMENTS>
    # <COMMENTS>at</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>item</COMMENTS>.  <COMMENTS>NOTE</COMMENTS>: <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>child</COMMENTS> <COMMENTS>nodes</COMMENTS>, <COMMENTS>their</COMMENTS>
    # <COMMENTS>total</COMMENTS> <COMMENTS>SPACES</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>reduced</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>caller</COMMENTS>.

    my ( $<CODE>item</CODE>, $<CODE>spaces_needed</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>available_spaces</CODE> = $<CODE>item</CODE>-><CODE>get_AVAILABLE_SPACES</CODE>();
    my $<CODE>deleted_spaces</CODE> =
      ( $<CODE>available_spaces</CODE> > $<CODE>spaces_needed</CODE> )
      ? $<CODE>spaces_needed</CODE>
      : $<CODE>available_spaces</CODE>;
    $<CODE>item</CODE>-><CODE>decrease_AVAILABLE_SPACES</CODE>($<CODE>deleted_spaces</CODE>);
    $<CODE>item</CODE>-><CODE>decrease_SPACES</CODE>($<CODE>deleted_spaces</CODE>);
    $<CODE>item</CODE>-><CODE>set_RECOVERABLE_SPACES</CODE>(0);

    return $<CODE>deleted_spaces</CODE>;
}

sub <CODE>tentatively_decrease_AVAILABLE_SPACES</CODE> {

    # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>asked</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>tentatively</COMMENTS> <COMMENTS>delete</COMMENTS> <COMMENTS>$spaces_needed</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>indentation</COMMENTS>
    # <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>item</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>undo</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>later</COMMENTS>.  <COMMENTS>NOTE</COMMENTS>: <COMMENTS>if</COMMENTS>
    # <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>child</COMMENTS> <COMMENTS>nodes</COMMENTS>, <COMMENTS>their</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>SPACES</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>reduced</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>caller</COMMENTS>.
    my ( $<CODE>item</CODE>, $<CODE>spaces_needed</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>available_spaces</CODE> = $<CODE>item</CODE>-><CODE>get_AVAILABLE_SPACES</CODE>();
    my $<CODE>deleted_spaces</CODE> =
      ( $<CODE>available_spaces</CODE> > $<CODE>spaces_needed</CODE> )
      ? $<CODE>spaces_needed</CODE>
      : $<CODE>available_spaces</CODE>;
    $<CODE>item</CODE>-><CODE>decrease_AVAILABLE_SPACES</CODE>($<CODE>deleted_spaces</CODE>);
    $<CODE>item</CODE>-><CODE>decrease_SPACES</CODE>($<CODE>deleted_spaces</CODE>);
    $<CODE>item</CODE>-><CODE>increase_RECOVERABLE_SPACES</CODE>($<CODE>deleted_spaces</CODE>);
    return $<CODE>deleted_spaces</CODE>;
}

sub <CODE>get_STACK_DEPTH</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>STACK_DEPTH</CODE>];
}

sub <CODE>get_SPACES</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>SPACES</CODE>];
}

sub <CODE>get_MARKED</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>MARKED</CODE>];
}

sub <CODE>set_MARKED</CODE> {
    my ( $<CODE>self</CODE>, $<CODE>value</CODE> ) = @<CODE>_</CODE>;
    if ( defined($<CODE>value</CODE>) ) {
        $<CODE>self</CODE>->[<CODE>MARKED</CODE>] = $<CODE>value</CODE>;
    }
    return $<CODE>self</CODE>->[<CODE>MARKED</CODE>];
}

sub <CODE>get_AVAILABLE_SPACES</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>AVAILABLE_SPACES</CODE>];
}

sub <CODE>decrease_SPACES</CODE> {
    my ( $<CODE>self</CODE>, $<CODE>value</CODE> ) = @<CODE>_</CODE>;
    if ( defined($<CODE>value</CODE>) ) {
        $<CODE>self</CODE>->[<CODE>SPACES</CODE>] -= $<CODE>value</CODE>;
    }
    return $<CODE>self</CODE>->[<CODE>SPACES</CODE>];
}

sub <CODE>decrease_AVAILABLE_SPACES</CODE> {
    my ( $<CODE>self</CODE>, $<CODE>value</CODE> ) = @<CODE>_</CODE>;
    if ( defined($<CODE>value</CODE>) ) {
        $<CODE>self</CODE>->[<CODE>AVAILABLE_SPACES</CODE>] -= $<CODE>value</CODE>;
    }
    return $<CODE>self</CODE>->[<CODE>AVAILABLE_SPACES</CODE>];
}

sub <CODE>get_ALIGN_PAREN</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>ALIGN_PAREN</CODE>];
}

sub <CODE>get_RECOVERABLE_SPACES</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>RECOVERABLE_SPACES</CODE>];
}

sub <CODE>set_RECOVERABLE_SPACES</CODE> {
    my ( $<CODE>self</CODE>, $<CODE>value</CODE> ) = @<CODE>_</CODE>;
    if ( defined($<CODE>value</CODE>) ) {
        $<CODE>self</CODE>->[<CODE>RECOVERABLE_SPACES</CODE>] = $<CODE>value</CODE>;
    }
    return $<CODE>self</CODE>->[<CODE>RECOVERABLE_SPACES</CODE>];
}

sub <CODE>increase_RECOVERABLE_SPACES</CODE> {
    my ( $<CODE>self</CODE>, $<CODE>value</CODE> ) = @<CODE>_</CODE>;
    if ( defined($<CODE>value</CODE>) ) {
        $<CODE>self</CODE>->[<CODE>RECOVERABLE_SPACES</CODE>] += $<CODE>value</CODE>;
    }
    return $<CODE>self</CODE>->[<CODE>RECOVERABLE_SPACES</CODE>];
}

sub <CODE>get_CI_LEVEL</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>CI_LEVEL</CODE>];
}

sub <CODE>get_LEVEL</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>LEVEL</CODE>];
}

sub <CODE>get_SEQUENCE_NUMBER</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>SEQUENCE_NUMBER</CODE>];
}

sub <CODE>get_INDEX</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>INDEX</CODE>];
}

sub <CODE>get_STARTING_INDEX</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>STARTING_INDEX</CODE>];
}

sub <CODE>set_HAVE_CHILD</CODE> {
    my ( $<CODE>self</CODE>, $<CODE>value</CODE> ) = @<CODE>_</CODE>;
    if ( defined($<CODE>value</CODE>) ) {
        $<CODE>self</CODE>->[<CODE>HAVE_CHILD</CODE>] = $<CODE>value</CODE>;
    }
    return $<CODE>self</CODE>->[<CODE>HAVE_CHILD</CODE>];
}

sub <CODE>get_HAVE_CHILD</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>HAVE_CHILD</CODE>];
}

sub <CODE>set_ARROW_COUNT</CODE> {
    my ( $<CODE>self</CODE>, $<CODE>value</CODE> ) = @<CODE>_</CODE>;
    if ( defined($<CODE>value</CODE>) ) {
        $<CODE>self</CODE>->[<CODE>ARROW_COUNT</CODE>] = $<CODE>value</CODE>;
    }
    return $<CODE>self</CODE>->[<CODE>ARROW_COUNT</CODE>];
}

sub <CODE>get_ARROW_COUNT</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>ARROW_COUNT</CODE>];
}

sub <CODE>set_COMMA_COUNT</CODE> {
    my ( $<CODE>self</CODE>, $<CODE>value</CODE> ) = @<CODE>_</CODE>;
    if ( defined($<CODE>value</CODE>) ) {
        $<CODE>self</CODE>->[<CODE>COMMA_COUNT</CODE>] = $<CODE>value</CODE>;
    }
    return $<CODE>self</CODE>->[<CODE>COMMA_COUNT</CODE>];
}

sub <CODE>get_COMMA_COUNT</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>COMMA_COUNT</CODE>];
}

sub <CODE>set_CLOSED</CODE> {
    my ( $<CODE>self</CODE>, $<CODE>value</CODE> ) = @<CODE>_</CODE>;
    if ( defined($<CODE>value</CODE>) ) {
        $<CODE>self</CODE>->[<CODE>CLOSED</CODE>] = $<CODE>value</CODE>;
    }
    return $<CODE>self</CODE>->[<CODE>CLOSED</CODE>];
}

sub <CODE>get_CLOSED</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->[<CODE>CLOSED</CODE>];
}

#####################################################################
#
# <COMMENTS>the</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>VerticalAligner</COMMENTS>::<COMMENTS>Line</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>supplies</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>to</COMMENTS>
# <COMMENTS>contain</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>line</COMMENTS>
#
#####################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>::<CODE>Line</CODE>;

{

    use <CODE>strict</CODE>;
    use <CODE>Carp</CODE>;

    use <CODE>constant</CODE> <LITERALS>JMAX</LITERALS>                      => 0;
    use <CODE>constant</CODE> <LITERALS>JMAX_ORIGINAL_LINE</LITERALS>        => 1;
    use <CODE>constant</CODE> <LITERALS>RTOKENS</LITERALS>                   => 2;
    use <CODE>constant</CODE> <LITERALS>RFIELDS</LITERALS>                   => 3;
    use <CODE>constant</CODE> <LITERALS>RPATTERNS</LITERALS>                 => 4;
    use <CODE>constant</CODE> <LITERALS>INDENTATION</LITERALS>               => 5;
    use <CODE>constant</CODE> <LITERALS>LEADING_SPACE_COUNT</LITERALS>       => 6;
    use <CODE>constant</CODE> <LITERALS>OUTDENT_LONG_LINES</LITERALS>        => 7;
    use <CODE>constant</CODE> <LITERALS>LIST_TYPE</LITERALS>                 => 8;
    use <CODE>constant</CODE> <LITERALS>IS_HANGING_SIDE_COMMENT</LITERALS>   => 9;
    use <CODE>constant</CODE> <LITERALS>RALIGNMENTS</LITERALS>               => 10;
    use <CODE>constant</CODE> <LITERALS>MAXIMUM_LINE_LENGTH</LITERALS>       => 11;
    use <CODE>constant</CODE> <LITERALS>RVERTICAL_TIGHTNESS_FLAGS</LITERALS> => 12;

    my %<CODE>_index_map</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>jmax</LITERALS>}                      = <CODE>JMAX</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>jmax_original_line</LITERALS>}        = <CODE>JMAX_ORIGINAL_LINE</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>rtokens</LITERALS>}                   = <CODE>RTOKENS</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>rfields</LITERALS>}                   = <CODE>RFIELDS</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>rpatterns</LITERALS>}                 = <CODE>RPATTERNS</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>indentation</LITERALS>}               = <CODE>INDENTATION</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>leading_space_count</LITERALS>}       = <CODE>LEADING_SPACE_COUNT</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>outdent_long_lines</LITERALS>}        = <CODE>OUTDENT_LONG_LINES</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>list_type</LITERALS>}                 = <CODE>LIST_TYPE</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>is_hanging_side_comment</LITERALS>}   = <CODE>IS_HANGING_SIDE_COMMENT</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>ralignments</LITERALS>}               = <CODE>RALIGNMENTS</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>maximum_line_length</LITERALS>}       = <CODE>MAXIMUM_LINE_LENGTH</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>rvertical_tightness_flags</LITERALS>} = <CODE>RVERTICAL_TIGHTNESS_FLAGS</CODE>;

    my @<CODE>_default_data</CODE> = ();
    $<CODE>_default_data</CODE>[<CODE>JMAX</CODE>]                      = undef;
    $<CODE>_default_data</CODE>[<CODE>JMAX_ORIGINAL_LINE</CODE>]        = undef;
    $<CODE>_default_data</CODE>[<CODE>RTOKENS</CODE>]                   = undef;
    $<CODE>_default_data</CODE>[<CODE>RFIELDS</CODE>]                   = undef;
    $<CODE>_default_data</CODE>[<CODE>RPATTERNS</CODE>]                 = undef;
    $<CODE>_default_data</CODE>[<CODE>INDENTATION</CODE>]               = undef;
    $<CODE>_default_data</CODE>[<CODE>LEADING_SPACE_COUNT</CODE>]       = undef;
    $<CODE>_default_data</CODE>[<CODE>OUTDENT_LONG_LINES</CODE>]        = undef;
    $<CODE>_default_data</CODE>[<CODE>LIST_TYPE</CODE>]                 = undef;
    $<CODE>_default_data</CODE>[<CODE>IS_HANGING_SIDE_COMMENT</CODE>]   = undef;
    $<CODE>_default_data</CODE>[<CODE>RALIGNMENTS</CODE>]               = [];
    $<CODE>_default_data</CODE>[<CODE>MAXIMUM_LINE_LENGTH</CODE>]       = undef;
    $<CODE>_default_data</CODE>[<CODE>RVERTICAL_TIGHTNESS_FLAGS</CODE>] = undef;

    {

        # <COMMENTS>methods</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>population</COMMENTS>
        my $<CODE>_count</CODE> = 0;
        sub <CODE>get_count</CODE>        { $<CODE>_count</CODE>; }
        sub <CODE>_increment_count</CODE> { ++$<CODE>_count</CODE> }
        sub <CODE>_decrement_count</CODE> { --$<CODE>_count</CODE> }
    }

    # <COMMENTS>Constructor</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>method</COMMENTS>
    sub <CODE>new</CODE> {
        my ( $<CODE>caller</CODE>, %<CODE>arg</CODE> ) = @<CODE>_</CODE>;
        my $<CODE>caller_is_obj</CODE> = ref($<CODE>caller</CODE>);
        my $<CODE>class</CODE> = $<CODE>caller_is_obj</CODE> || $<CODE>caller</CODE>;
        no <CODE>strict</CODE> "<LITERALS>refs</LITERALS>";
        my $<CODE>self</CODE> = bless [], $<CODE>class</CODE>;

        $<CODE>self</CODE>->[<CODE>RALIGNMENTS</CODE>] = [];

        my $<CODE>index</CODE>;
        foreach ( keys %<CODE>_index_map</CODE> ) {
            $<CODE>index</CODE> = $<CODE>_index_map</CODE>{$<CODE>_</CODE>};
            if    ( exists $<CODE>arg</CODE>{$<CODE>_</CODE>} ) { $<CODE>self</CODE>->[$<CODE>index</CODE>] = $<CODE>arg</CODE>{$<CODE>_</CODE>} }
            elsif ($<CODE>caller_is_obj</CODE>)    { $<CODE>self</CODE>->[$<CODE>index</CODE>] = $<CODE>caller</CODE>->[$<CODE>index</CODE>] }
            else { $<CODE>self</CODE>->[$<CODE>index</CODE>] = $<CODE>_default_data</CODE>[$<CODE>index</CODE>] }
        }

        $<CODE>self</CODE>-><CODE>_increment_count</CODE>();
        return $<CODE>self</CODE>;
    }

    sub <CODE>DESTROY</CODE> {
        $<CODE>_</CODE>[0]-><CODE>_decrement_count</CODE>();
    }

    sub <CODE>get_jmax</CODE>                      { $<CODE>_</CODE>[0]->[<CODE>JMAX</CODE>] }
    sub <CODE>get_jmax_original_line</CODE>        { $<CODE>_</CODE>[0]->[<CODE>JMAX_ORIGINAL_LINE</CODE>] }
    sub <CODE>get_rtokens</CODE>                   { $<CODE>_</CODE>[0]->[<CODE>RTOKENS</CODE>] }
    sub <CODE>get_rfields</CODE>                   { $<CODE>_</CODE>[0]->[<CODE>RFIELDS</CODE>] }
    sub <CODE>get_rpatterns</CODE>                 { $<CODE>_</CODE>[0]->[<CODE>RPATTERNS</CODE>] }
    sub <CODE>get_indentation</CODE>               { $<CODE>_</CODE>[0]->[<CODE>INDENTATION</CODE>] }
    sub <CODE>get_leading_space_count</CODE>       { $<CODE>_</CODE>[0]->[<CODE>LEADING_SPACE_COUNT</CODE>] }
    sub <CODE>get_outdent_long_lines</CODE>        { $<CODE>_</CODE>[0]->[<CODE>OUTDENT_LONG_LINES</CODE>] }
    sub <CODE>get_list_type</CODE>                 { $<CODE>_</CODE>[0]->[<CODE>LIST_TYPE</CODE>] }
    sub <CODE>get_is_hanging_side_comment</CODE>   { $<CODE>_</CODE>[0]->[<CODE>IS_HANGING_SIDE_COMMENT</CODE>] }
    sub <CODE>get_rvertical_tightness_flags</CODE> { $<CODE>_</CODE>[0]->[<CODE>RVERTICAL_TIGHTNESS_FLAGS</CODE>] }

    sub <CODE>set_column</CODE>     { $<CODE>_</CODE>[0]->[<CODE>RALIGNMENTS</CODE>]->[ $<CODE>_</CODE>[1] ]-><CODE>set_column</CODE>( $<CODE>_</CODE>[2] ) }
    sub <CODE>get_alignment</CODE>  { $<CODE>_</CODE>[0]->[<CODE>RALIGNMENTS</CODE>]->[ $<CODE>_</CODE>[1] ] }
    sub <CODE>get_alignments</CODE> { @{ $<CODE>_</CODE>[0]->[<CODE>RALIGNMENTS</CODE>] } }
    sub <CODE>get_column</CODE>     { $<CODE>_</CODE>[0]->[<CODE>RALIGNMENTS</CODE>]->[ $<CODE>_</CODE>[1] ]-><CODE>get_column</CODE>() }

    sub <CODE>get_starting_column</CODE> {
        $<CODE>_</CODE>[0]->[<CODE>RALIGNMENTS</CODE>]->[ $<CODE>_</CODE>[1] ]-><CODE>get_starting_column</CODE>();
    }

    sub <CODE>increment_column</CODE> {
        $<CODE>_</CODE>[0]->[<CODE>RALIGNMENTS</CODE>]->[ $<CODE>_</CODE>[1] ]-><CODE>increment_column</CODE>( $<CODE>_</CODE>[2] );
    }
    sub <CODE>set_alignments</CODE> { my $<CODE>self</CODE> = shift; @{ $<CODE>self</CODE>->[<CODE>RALIGNMENTS</CODE>] } = @<CODE>_</CODE>; }

    sub <CODE>current_field_width</CODE> {
        my $<CODE>self</CODE> = shift;
        my ($<CODE>j</CODE>) = @<CODE>_</CODE>;
        if ( $<CODE>j</CODE> == 0 ) {
            return $<CODE>self</CODE>-><CODE>get_column</CODE>($<CODE>j</CODE>);
        }
        else {
            return $<CODE>self</CODE>-><CODE>get_column</CODE>($<CODE>j</CODE>) - $<CODE>self</CODE>-><CODE>get_column</CODE>( $<CODE>j</CODE> - 1 );
        }
    }

    sub <CODE>field_width_growth</CODE> {
        my $<CODE>self</CODE> = shift;
        my $<CODE>j</CODE>    = shift;
        return $<CODE>self</CODE>-><CODE>get_column</CODE>($<CODE>j</CODE>) - $<CODE>self</CODE>-><CODE>get_starting_column</CODE>($<CODE>j</CODE>);
    }

    sub <CODE>starting_field_width</CODE> {
        my $<CODE>self</CODE> = shift;
        my $<CODE>j</CODE>    = shift;
        if ( $<CODE>j</CODE> == 0 ) {
            return $<CODE>self</CODE>-><CODE>get_starting_column</CODE>($<CODE>j</CODE>);
        }
        else {
            return $<CODE>self</CODE>-><CODE>get_starting_column</CODE>($<CODE>j</CODE>) -
              $<CODE>self</CODE>-><CODE>get_starting_column</CODE>( $<CODE>j</CODE> - 1 );
        }
    }

    sub <CODE>increase_field_width</CODE> {

        my $<CODE>self</CODE> = shift;
        my ( $<CODE>j</CODE>, $<CODE>pad</CODE> ) = @<CODE>_</CODE>;
        my $<CODE>jmax</CODE> = $<CODE>self</CODE>-><CODE>get_jmax</CODE>();
        for my $<CODE>k</CODE> ( $<CODE>j</CODE> .. $<CODE>jmax</CODE> ) {
            $<CODE>self</CODE>-><CODE>increment_column</CODE>( $<CODE>k</CODE>, $<CODE>pad</CODE> );
        }
    }

    sub <CODE>get_available_space_on_right</CODE> {
        my $<CODE>self</CODE> = shift;
        my $<CODE>jmax</CODE> = $<CODE>self</CODE>-><CODE>get_jmax</CODE>();
        return $<CODE>self</CODE>->[<CODE>MAXIMUM_LINE_LENGTH</CODE>] - $<CODE>self</CODE>-><CODE>get_column</CODE>($<CODE>jmax</CODE>);
    }

    sub <CODE>set_jmax</CODE>                    { $<CODE>_</CODE>[0]->[<CODE>JMAX</CODE>]                    = $<CODE>_</CODE>[1] }
    sub <CODE>set_jmax_original_line</CODE>      { $<CODE>_</CODE>[0]->[<CODE>JMAX_ORIGINAL_LINE</CODE>]      = $<CODE>_</CODE>[1] }
    sub <CODE>set_rtokens</CODE>                 { $<CODE>_</CODE>[0]->[<CODE>RTOKENS</CODE>]                 = $<CODE>_</CODE>[1] }
    sub <CODE>set_rfields</CODE>                 { $<CODE>_</CODE>[0]->[<CODE>RFIELDS</CODE>]                 = $<CODE>_</CODE>[1] }
    sub <CODE>set_rpatterns</CODE>               { $<CODE>_</CODE>[0]->[<CODE>RPATTERNS</CODE>]               = $<CODE>_</CODE>[1] }
    sub <CODE>set_indentation</CODE>             { $<CODE>_</CODE>[0]->[<CODE>INDENTATION</CODE>]             = $<CODE>_</CODE>[1] }
    sub <CODE>set_leading_space_count</CODE>     { $<CODE>_</CODE>[0]->[<CODE>LEADING_SPACE_COUNT</CODE>]     = $<CODE>_</CODE>[1] }
    sub <CODE>set_outdent_long_lines</CODE>      { $<CODE>_</CODE>[0]->[<CODE>OUTDENT_LONG_LINES</CODE>]      = $<CODE>_</CODE>[1] }
    sub <CODE>set_list_type</CODE>               { $<CODE>_</CODE>[0]->[<CODE>LIST_TYPE</CODE>]               = $<CODE>_</CODE>[1] }
    sub <CODE>set_is_hanging_side_comment</CODE> { $<CODE>_</CODE>[0]->[<CODE>IS_HANGING_SIDE_COMMENT</CODE>] = $<CODE>_</CODE>[1] }
    sub <CODE>set_alignment</CODE>               { $<CODE>_</CODE>[0]->[<CODE>RALIGNMENTS</CODE>]->[ $<CODE>_</CODE>[1] ]  = $<CODE>_</CODE>[2] }

}

#####################################################################
#
# <COMMENTS>the</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>VerticalAligner</COMMENTS>::<COMMENTS>Alignment</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>holds</COMMENTS> <COMMENTS>information</COMMENTS>
# <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>aligned</COMMENTS>
#
#####################################################################
package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>::<CODE>Alignment</CODE>;

{

    use <CODE>strict</CODE>;

    #<COMMENTS>use</COMMENTS> <COMMENTS>Carp</COMMENTS>;

    # <COMMENTS>Symbolic</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>indexes</COMMENTS>
    use <CODE>constant</CODE> <LITERALS>COLUMN</LITERALS>          => 0;    # <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>number</COMMENTS>
    use <CODE>constant</CODE> <LITERALS>STARTING_COLUMN</LITERALS> => 1;    # <COMMENTS>column</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>created</COMMENTS>
    use <CODE>constant</CODE> <LITERALS>MATCHING_TOKEN</LITERALS>  => 2;    # <COMMENTS>what</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>matching</COMMENTS>
    use <CODE>constant</CODE> <LITERALS>STARTING_LINE</LITERALS>   => 3;    # <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>creation</COMMENTS>
    use <CODE>constant</CODE> <LITERALS>ENDING_LINE</LITERALS>     => 4;    # <COMMENTS>the</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>recent</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>it</COMMENTS>
    use <CODE>constant</CODE> <LITERALS>SAVED_COLUMN</LITERALS>    => 5;    # <COMMENTS>the</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>recent</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>it</COMMENTS>
    use <CODE>constant</CODE> <LITERALS>SERIAL_NUMBER</LITERALS>   => 6;    # <COMMENTS>unique</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>alignment</COMMENTS>
                                          # (<COMMENTS>just</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>array</COMMENTS>)

    # <COMMENTS>Correspondence</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>variables</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>indexes</COMMENTS>
    my %<CODE>_index_map</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>column</LITERALS>}          = <CODE>COLUMN</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>starting_column</LITERALS>} = <CODE>STARTING_COLUMN</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>matching_token</LITERALS>}  = <CODE>MATCHING_TOKEN</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>starting_line</LITERALS>}   = <CODE>STARTING_LINE</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>ending_line</LITERALS>}     = <CODE>ENDING_LINE</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>saved_column</LITERALS>}    = <CODE>SAVED_COLUMN</CODE>;
    $<CODE>_index_map</CODE>{<LITERALS>serial_number</LITERALS>}   = <CODE>SERIAL_NUMBER</CODE>;

    my @<CODE>_default_data</CODE> = ();
    $<CODE>_default_data</CODE>[<CODE>COLUMN</CODE>]          = undef;
    $<CODE>_default_data</CODE>[<CODE>STARTING_COLUMN</CODE>] = undef;
    $<CODE>_default_data</CODE>[<CODE>MATCHING_TOKEN</CODE>]  = undef;
    $<CODE>_default_data</CODE>[<CODE>STARTING_LINE</CODE>]   = undef;
    $<CODE>_default_data</CODE>[<CODE>ENDING_LINE</CODE>]     = undef;
    $<CODE>_default_data</CODE>[<CODE>SAVED_COLUMN</CODE>]    = undef;
    $<CODE>_default_data</CODE>[<CODE>SERIAL_NUMBER</CODE>]   = undef;

    # <COMMENTS>class</COMMENTS> <COMMENTS>population</COMMENTS> <COMMENTS>count</COMMENTS>
    {
        my $<CODE>_count</CODE> = 0;
        sub <CODE>get_count</CODE>        { $<CODE>_count</CODE>; }
        sub <CODE>_increment_count</CODE> { ++$<CODE>_count</CODE> }
        sub <CODE>_decrement_count</CODE> { --$<CODE>_count</CODE> }
    }

    # <COMMENTS>constructor</COMMENTS>
    sub <CODE>new</CODE> {
        my ( $<CODE>caller</CODE>, %<CODE>arg</CODE> ) = @<CODE>_</CODE>;
        my $<CODE>caller_is_obj</CODE> = ref($<CODE>caller</CODE>);
        my $<CODE>class</CODE> = $<CODE>caller_is_obj</CODE> || $<CODE>caller</CODE>;
        no <CODE>strict</CODE> "<LITERALS>refs</LITERALS>";
        my $<CODE>self</CODE> = bless [], $<CODE>class</CODE>;

        foreach ( keys %<CODE>_index_map</CODE> ) {
            my $<CODE>index</CODE> = $<CODE>_index_map</CODE>{$<CODE>_</CODE>};
            if    ( exists $<CODE>arg</CODE>{$<CODE>_</CODE>} ) { $<CODE>self</CODE>->[$<CODE>index</CODE>] = $<CODE>arg</CODE>{$<CODE>_</CODE>} }
            elsif ($<CODE>caller_is_obj</CODE>)    { $<CODE>self</CODE>->[$<CODE>index</CODE>] = $<CODE>caller</CODE>->[$<CODE>index</CODE>] }
            else { $<CODE>self</CODE>->[$<CODE>index</CODE>] = $<CODE>_default_data</CODE>[$<CODE>index</CODE>] }
        }
        $<CODE>self</CODE>-><CODE>_increment_count</CODE>();
        return $<CODE>self</CODE>;
    }

    sub <CODE>DESTROY</CODE> {
        $<CODE>_</CODE>[0]-><CODE>_decrement_count</CODE>();
    }

    sub <CODE>get_column</CODE>          { return $<CODE>_</CODE>[0]->[<CODE>COLUMN</CODE>] }
    sub <CODE>get_starting_column</CODE> { return $<CODE>_</CODE>[0]->[<CODE>STARTING_COLUMN</CODE>] }
    sub <CODE>get_matching_token</CODE>  { return $<CODE>_</CODE>[0]->[<CODE>MATCHING_TOKEN</CODE>] }
    sub <CODE>get_starting_line</CODE>   { return $<CODE>_</CODE>[0]->[<CODE>STARTING_LINE</CODE>] }
    sub <CODE>get_ending_line</CODE>     { return $<CODE>_</CODE>[0]->[<CODE>ENDING_LINE</CODE>] }
    sub <CODE>get_serial_number</CODE>   { return $<CODE>_</CODE>[0]->[<CODE>SERIAL_NUMBER</CODE>] }

    sub <CODE>set_column</CODE>          { $<CODE>_</CODE>[0]->[<CODE>COLUMN</CODE>]          = $<CODE>_</CODE>[1] }
    sub <CODE>set_starting_column</CODE> { $<CODE>_</CODE>[0]->[<CODE>STARTING_COLUMN</CODE>] = $<CODE>_</CODE>[1] }
    sub <CODE>set_matching_token</CODE>  { $<CODE>_</CODE>[0]->[<CODE>MATCHING_TOKEN</CODE>]  = $<CODE>_</CODE>[1] }
    sub <CODE>set_starting_line</CODE>   { $<CODE>_</CODE>[0]->[<CODE>STARTING_LINE</CODE>]   = $<CODE>_</CODE>[1] }
    sub <CODE>set_ending_line</CODE>     { $<CODE>_</CODE>[0]->[<CODE>ENDING_LINE</CODE>]     = $<CODE>_</CODE>[1] }
    sub <CODE>increment_column</CODE> { $<CODE>_</CODE>[0]->[<CODE>COLUMN</CODE>] += $<CODE>_</CODE>[1] }

    sub <CODE>save_column</CODE>    { $<CODE>_</CODE>[0]->[<CODE>SAVED_COLUMN</CODE>] = $<CODE>_</CODE>[0]->[<CODE>COLUMN</CODE>] }
    sub <CODE>restore_column</CODE> { $<CODE>_</CODE>[0]->[<CODE>COLUMN</CODE>]       = $<CODE>_</CODE>[0]->[<CODE>SAVED_COLUMN</CODE>] }

}

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>;

# <COMMENTS>The</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>VerticalAligner</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>collects</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>and</COMMENTS>
# <COMMENTS>attempts</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> => <COMMENTS>and</COMMENTS> #, <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS>
# <COMMENTS>identified</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>calling</COMMENTS> <COMMENTS>routine</COMMENTS>.
#
# <COMMENTS>There</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>routines</COMMENTS>: <COMMENTS>valign_input</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>flush</COMMENTS>.  <COMMENTS>Append</COMMENTS> <COMMENTS>acts</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS>
# <COMMENTS>storage</COMMENTS> <COMMENTS>buffer</COMMENTS>, <COMMENTS>collecting</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>vertically</COMMENTS>
# <COMMENTS>aligned</COMMENTS>.  <COMMENTS>When</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>longer</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>desirable</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>dumps</COMMENTS>
# <COMMENTS>the</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>flush</COMMENTS>.
#
#     <COMMENTS>valign_input</COMMENTS> -----> <COMMENTS>flush</COMMENTS>
#
#     <COMMENTS>collects</COMMENTS>          <COMMENTS>writes</COMMENTS>
#     <COMMENTS>vertical</COMMENTS>          <COMMENTS>one</COMMENTS>
#     <COMMENTS>groups</COMMENTS>            <COMMENTS>group</COMMENTS>

<CODE>BEGIN</CODE> {

    # <COMMENTS>Caution</COMMENTS>: <COMMENTS>these</COMMENTS> <COMMENTS>debug</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>produce</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>lot</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>output</COMMENTS>
    # <COMMENTS>They</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>0</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>debugging</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>scripts</COMMENTS>

    use <CODE>constant</CODE> <LITERALS>VALIGN_DEBUG_FLAG_APPEND</LITERALS>  => 0;
    use <CODE>constant</CODE> <LITERALS>VALIGN_DEBUG_FLAG_APPEND0</LITERALS> => 0;
    use <CODE>constant</CODE> <LITERALS>VALIGN_DEBUG_FLAG_TERNARY</LITERALS> => 0;
    use <CODE>constant</CODE> <LITERALS>VALIGN_DEBUG_FLAG_TABS</LITERALS>    => 0;

    my $<CODE>debug_warning</CODE> = sub {
        print <CODE>STDOUT</CODE> "<LITERALS>VALIGN_DEBUGGING</LITERALS> <LITERALS>with</LITERALS> <LITERALS>key</LITERALS> $<CODE>_</CODE>[0]\n";
    };

    <CODE>VALIGN_DEBUG_FLAG_APPEND</CODE>  && $<CODE>debug_warning</CODE>->('<LITERALS>APPEND</LITERALS>');
    <CODE>VALIGN_DEBUG_FLAG_APPEND0</CODE> && $<CODE>debug_warning</CODE>->('<LITERALS>APPEND0</LITERALS>');
    <CODE>VALIGN_DEBUG_FLAG_TERNARY</CODE> && $<CODE>debug_warning</CODE>->('<LITERALS>TERNARY</LITERALS>');
    <CODE>VALIGN_DEBUG_FLAG_TABS</CODE>    && $<CODE>debug_warning</CODE>->('<LITERALS>TABS</LITERALS>');

}

use <CODE>vars</CODE> qw(
  $<CODE>vertical_aligner_self</CODE>
  $<CODE>current_line</CODE>
  $<CODE>maximum_alignment_index</CODE>
  $<CODE>ralignment_list</CODE>
  $<CODE>maximum_jmax_seen</CODE>
  $<CODE>minimum_jmax_seen</CODE>
  $<CODE>previous_minimum_jmax_seen</CODE>
  $<CODE>previous_maximum_jmax_seen</CODE>
  $<CODE>maximum_line_index</CODE>
  $<CODE>group_level</CODE>
  $<CODE>group_type</CODE>
  $<CODE>group_maximum_gap</CODE>
  $<CODE>marginal_match</CODE>
  $<CODE>last_level_written</CODE>
  $<CODE>last_leading_space_count</CODE>
  $<CODE>extra_indent_ok</CODE>
  $<CODE>zero_count</CODE>
  @<CODE>group_lines</CODE>
  $<CODE>last_comment_column</CODE>
  $<CODE>last_side_comment_line_number</CODE>
  $<CODE>last_side_comment_length</CODE>
  $<CODE>last_side_comment_level</CODE>
  $<CODE>outdented_line_count</CODE>
  $<CODE>first_outdented_line_at</CODE>
  $<CODE>last_outdented_line_at</CODE>
  $<CODE>diagnostics_object</CODE>
  $<CODE>logger_object</CODE>
  $<CODE>file_writer_object</CODE>
  @<CODE>side_comment_history</CODE>
  $<CODE>comment_leading_space_count</CODE>
  $<CODE>is_matching_terminal_line</CODE>
  $<CODE>consecutive_block_comments</CODE>

  $<CODE>cached_line_text</CODE>
  $<CODE>cached_line_type</CODE>
  $<CODE>cached_line_flag</CODE>
  $<CODE>cached_seqno</CODE>
  $<CODE>cached_line_valid</CODE>
  $<CODE>cached_line_leading_space_count</CODE>
  $<CODE>cached_seqno_string</CODE>

  $<CODE>valign_buffer_filling</CODE>
  @<CODE>valign_buffer</CODE>

  $<CODE>seqno_string</CODE>
  $<CODE>last_nonblank_seqno_string</CODE>

  $<CODE>rOpts</CODE>

  $<CODE>rOpts_maximum_line_length</CODE>
  $<CODE>rOpts_variable_maximum_line_length</CODE>
  $<CODE>rOpts_continuation_indentation</CODE>
  $<CODE>rOpts_indent_columns</CODE>
  $<CODE>rOpts_tabs</CODE>
  $<CODE>rOpts_entab_leading_whitespace</CODE>
  $<CODE>rOpts_valign</CODE>

  $<CODE>rOpts_fixed_position_side_comment</CODE>
  $<CODE>rOpts_minimum_space_to_comment</CODE>

);

sub <CODE>initialize</CODE> {

    my $<CODE>class</CODE>;

    ( $<CODE>class</CODE>, $<CODE>rOpts</CODE>, $<CODE>file_writer_object</CODE>, $<CODE>logger_object</CODE>, $<CODE>diagnostics_object</CODE> )
      = @<CODE>_</CODE>;

    # <COMMENTS>variables</COMMENTS> <COMMENTS>describing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>entire</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>group</COMMENTS>:
    $<CODE>ralignment_list</CODE>            = [];
    $<CODE>group_level</CODE>                = 0;
    $<CODE>last_level_written</CODE>         = -1;
    $<CODE>extra_indent_ok</CODE>            = 0;    # <COMMENTS>can</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>move</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS>?
    $<CODE>last_side_comment_length</CODE>   = 0;
    $<CODE>maximum_jmax_seen</CODE>          = 0;
    $<CODE>minimum_jmax_seen</CODE>          = 0;
    $<CODE>previous_minimum_jmax_seen</CODE> = 0;
    $<CODE>previous_maximum_jmax_seen</CODE> = 0;

    # <COMMENTS>variables</COMMENTS> <COMMENTS>describing</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>group</COMMENTS>
    @<CODE>group_lines</CODE> = ();                  # <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>group</COMMENTS>

    $<CODE>outdented_line_count</CODE>          = 0;
    $<CODE>first_outdented_line_at</CODE>       = 0;
    $<CODE>last_outdented_line_at</CODE>        = 0;
    $<CODE>last_side_comment_line_number</CODE> = 0;
    $<CODE>last_side_comment_level</CODE>       = -1;
    $<CODE>is_matching_terminal_line</CODE>     = 0;

    # <COMMENTS>most</COMMENTS> <COMMENTS>recent</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>; [ <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS>, <COMMENTS>column</COMMENTS> ]
    $<CODE>side_comment_history</CODE>[0] = [ -300, 0 ];
    $<CODE>side_comment_history</CODE>[1] = [ -200, 0 ];
    $<CODE>side_comment_history</CODE>[2] = [ -100, 0 ];

    # <COMMENTS>valign_output_step_B</COMMENTS> <COMMENTS>cache</COMMENTS>:
    $<CODE>cached_line_text</CODE>                = "";
    $<CODE>cached_line_type</CODE>                = 0;
    $<CODE>cached_line_flag</CODE>                = 0;
    $<CODE>cached_seqno</CODE>                    = 0;
    $<CODE>cached_line_valid</CODE>               = 0;
    $<CODE>cached_line_leading_space_count</CODE> = 0;
    $<CODE>cached_seqno_string</CODE>             = "";

    # <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>joined</COMMENTS> <COMMENTS>together</COMMENTS>
    $<CODE>seqno_string</CODE>               = "";
    $<CODE>last_nonblank_seqno_string</CODE> = "";

    # <COMMENTS>frequently</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>parameters</COMMENTS>
    $<CODE>rOpts_indent_columns</CODE>           = $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>columns</LITERALS>'};
    $<CODE>rOpts_tabs</CODE>                     = $<CODE>rOpts</CODE>->{'<LITERALS>tabs</LITERALS>'};
    $<CODE>rOpts_entab_leading_whitespace</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>entab</LITERALS>-<LITERALS>leading</LITERALS>-<LITERALS>whitespace</LITERALS>'};
    $<CODE>rOpts_fixed_position_side_comment</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>fixed</LITERALS>-<LITERALS>position</LITERALS>-<LITERALS>side</LITERALS>-<LITERALS>comment</LITERALS>'};
    $<CODE>rOpts_minimum_space_to_comment</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>minimum</LITERALS>-<LITERALS>space</LITERALS>-<LITERALS>to</LITERALS>-<LITERALS>comment</LITERALS>'};
    $<CODE>rOpts_maximum_line_length</CODE>      = $<CODE>rOpts</CODE>->{'<LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>'};
    $<CODE>rOpts_variable_maximum_line_length</CODE> =
      $<CODE>rOpts</CODE>->{'<LITERALS>variable</LITERALS>-<LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>'};
    $<CODE>rOpts_valign</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>valign</LITERALS>'};

    $<CODE>consecutive_block_comments</CODE> = 0;
    <CODE>forget_side_comment</CODE>();

    <CODE>initialize_for_new_group</CODE>();

    $<CODE>vertical_aligner_self</CODE> = {};
    bless $<CODE>vertical_aligner_self</CODE>, $<CODE>class</CODE>;
    return $<CODE>vertical_aligner_self</CODE>;
}

sub <CODE>initialize_for_new_group</CODE> {
    $<CODE>maximum_line_index</CODE>      = -1;      # <COMMENTS>lines</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS>
    $<CODE>maximum_alignment_index</CODE> = -1;      # <COMMENTS>alignments</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS>
    $<CODE>zero_count</CODE>              = 0;       # <COMMENTS>count</COMMENTS> <COMMENTS>consecutive</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>tokens</COMMENTS>
    $<CODE>current_line</CODE>            = undef;   # <COMMENTS>line</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>matched</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>alignment</COMMENTS>
    $<CODE>group_maximum_gap</CODE>       = 0;       # <COMMENTS>largest</COMMENTS> <COMMENTS>gap</COMMENTS> <COMMENTS>introduced</COMMENTS>
    $<CODE>group_type</CODE>              = "";
    $<CODE>marginal_match</CODE>          = 0;
    $<CODE>comment_leading_space_count</CODE> = 0;
    $<CODE>last_leading_space_count</CODE>    = 0;
}

# <COMMENTS>interface</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Diagnostics</COMMENTS> <COMMENTS>routines</COMMENTS>
sub <CODE>write_diagnostics</CODE> {
    if ($<CODE>diagnostics_object</CODE>) {
        $<CODE>diagnostics_object</CODE>-><CODE>write_diagnostics</CODE>(@<CODE>_</CODE>);
    }
}

# <COMMENTS>interface</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Logger</COMMENTS> <COMMENTS>routines</COMMENTS>
sub <CODE>warning</CODE> {
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>warning</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>write_logfile_entry</CODE> {
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>report_definite_bug</CODE> {
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>report_definite_bug</CODE>();
    }
}

sub <CODE>get_SPACES</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>associated</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>indentation</COMMENTS>
    # <COMMENTS>variable</COMMENTS> <COMMENTS>$indentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>constant</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>an</COMMENTS>
    # <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>get_SPACES</COMMENTS> <COMMENTS>method</COMMENTS>.
    my $<CODE>indentation</CODE> = shift;
    return ref($<CODE>indentation</CODE>) ? $<CODE>indentation</CODE>-><CODE>get_SPACES</CODE>() : $<CODE>indentation</CODE>;
}

sub <CODE>get_RECOVERABLE_SPACES</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>spaces</COMMENTS> (+ <COMMENTS>means</COMMENTS> <COMMENTS>shift</COMMENTS> <COMMENTS>right</COMMENTS>, - <COMMENTS>means</COMMENTS> <COMMENTS>shift</COMMENTS> <COMMENTS>left</COMMENTS>)
    # <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>shift</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>indentation</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>parens</COMMENTS>
    my $<CODE>indentation</CODE> = shift;
    return ref($<CODE>indentation</CODE>) ? $<CODE>indentation</CODE>-><CODE>get_RECOVERABLE_SPACES</CODE>() : 0;
}

sub <CODE>get_STACK_DEPTH</CODE> {

    my $<CODE>indentation</CODE> = shift;
    return ref($<CODE>indentation</CODE>) ? $<CODE>indentation</CODE>-><CODE>get_STACK_DEPTH</CODE>() : 0;
}

sub <CODE>make_alignment</CODE> {
    my ( $<CODE>col</CODE>, $<CODE>token</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>make</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>$col</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>aligns</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>$token</COMMENTS>
    ++$<CODE>maximum_alignment_index</CODE>;
    my $<CODE>alignment</CODE> = <CODE>new</CODE> <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>::<CODE>Alignment</CODE>(
        <LITERALS>column</LITERALS>          => $<CODE>col</CODE>,
        <LITERALS>starting_column</LITERALS> => $<CODE>col</CODE>,
        <LITERALS>matching_token</LITERALS>  => $<CODE>token</CODE>,
        <LITERALS>starting_line</LITERALS>   => $<CODE>maximum_line_index</CODE>,
        <LITERALS>ending_line</LITERALS>     => $<CODE>maximum_line_index</CODE>,
        <LITERALS>serial_number</LITERALS>   => $<CODE>maximum_alignment_index</CODE>,
    );
    $<CODE>ralignment_list</CODE>->[$<CODE>maximum_alignment_index</CODE>] = $<CODE>alignment</CODE>;
    return $<CODE>alignment</CODE>;
}

sub <CODE>dump_alignments</CODE> {
    print <CODE>STDOUT</CODE>
"<LITERALS>Current</LITERALS> <LITERALS>Alignments</LITERALS>:\n<LITERALS>i</LITERALS>\t<LITERALS>token</LITERALS>\t<LITERALS>starting_column</LITERALS>\t<LITERALS>column</LITERALS>\t<LITERALS>starting_line</LITERALS>\t<LITERALS>ending_line</LITERALS>\n";
    for my $<CODE>i</CODE> ( 0 .. $<CODE>maximum_alignment_index</CODE> ) {
        my $<CODE>column</CODE>          = $<CODE>ralignment_list</CODE>->[$<CODE>i</CODE>]-><CODE>get_column</CODE>();
        my $<CODE>starting_column</CODE> = $<CODE>ralignment_list</CODE>->[$<CODE>i</CODE>]-><CODE>get_starting_column</CODE>();
        my $<CODE>matching_token</CODE>  = $<CODE>ralignment_list</CODE>->[$<CODE>i</CODE>]-><CODE>get_matching_token</CODE>();
        my $<CODE>starting_line</CODE>   = $<CODE>ralignment_list</CODE>->[$<CODE>i</CODE>]-><CODE>get_starting_line</CODE>();
        my $<CODE>ending_line</CODE>     = $<CODE>ralignment_list</CODE>->[$<CODE>i</CODE>]-><CODE>get_ending_line</CODE>();
        print <CODE>STDOUT</CODE>
"$<CODE>i</CODE>\t$<CODE>matching_token</CODE>\t$<CODE>starting_column</CODE>\t$<CODE>column</CODE>\t$<CODE>starting_line</CODE>\t$<CODE>ending_line</CODE>\n";
    }
}

sub <CODE>save_alignment_columns</CODE> {
    for my $<CODE>i</CODE> ( 0 .. $<CODE>maximum_alignment_index</CODE> ) {
        $<CODE>ralignment_list</CODE>->[$<CODE>i</CODE>]-><CODE>save_column</CODE>();
    }
}

sub <CODE>restore_alignment_columns</CODE> {
    for my $<CODE>i</CODE> ( 0 .. $<CODE>maximum_alignment_index</CODE> ) {
        $<CODE>ralignment_list</CODE>->[$<CODE>i</CODE>]-><CODE>restore_column</CODE>();
    }
}

sub <CODE>forget_side_comment</CODE> {
    $<CODE>last_comment_column</CODE> = 0;
}

sub <CODE>maximum_line_length_for_level</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>level</COMMENTS>
    my $<CODE>maximum_line_length</CODE> = $<CODE>rOpts_maximum_line_length</CODE>;
    if ($<CODE>rOpts_variable_maximum_line_length</CODE>) {
        my $<CODE>level</CODE> = shift;
        if ( $<CODE>level</CODE> < 0 ) { $<CODE>level</CODE> = 0 }
        $<CODE>maximum_line_length</CODE> += $<CODE>level</CODE> * $<CODE>rOpts_indent_columns</CODE>;
    }
    return $<CODE>maximum_line_length</CODE>;
}

sub <CODE>valign_input</CODE> {

    # <COMMENTS>Place</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>group</COMMENTS>.
    #
    # <COMMENTS>The</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>parameters</COMMENTS> <COMMENTS>are</COMMENTS>:
    #     <COMMENTS>$level</COMMENTS> = <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
    #     <COMMENTS>$rfields</COMMENTS> = <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>fields</COMMENTS>
    #     <COMMENTS>$rpatterns</COMMENTS> = <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>patterns</COMMENTS>, <COMMENTS>one</COMMENTS> <COMMENTS>per</COMMENTS> <COMMENTS>field</COMMENTS>
    #     <COMMENTS>$rtokens</COMMENTS>   = <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>1</COMMENTS>,<COMMENTS>2</COMMENTS>,..
    #
    # <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>does</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>example</COMMENTS>,
    # <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>trying</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>the</COMMENTS> '=>' <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> '#'.
    #
    #         '<COMMENTS>18</COMMENTS>' => '<COMMENTS>grave</COMMENTS>',    #   \`
    #         '<COMMENTS>19</COMMENTS>' => '<COMMENTS>acute</COMMENTS>',    #   `'
    #         '<COMMENTS>20</COMMENTS>' => '<COMMENTS>caron</COMMENTS>',    #   \<COMMENTS>v</COMMENTS>
    # <-<COMMENTS>tabs</COMMENTS>-><<COMMENTS>f1</COMMENTS>-><--<COMMENTS>field</COMMENTS> <COMMENTS>2</COMMENTS> ---><-<COMMENTS>f3</COMMENTS>->
    # |            |              |    |
    # |            |              |    |
    # <COMMENTS>col1</COMMENTS>        <COMMENTS>col2</COMMENTS>         <COMMENTS>col3</COMMENTS> <COMMENTS>col4</COMMENTS>
    #
    # <COMMENTS>The</COMMENTS> <COMMENTS>calling</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>broken</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>entire</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>as</COMMENTS>
    # <COMMENTS>indicated</COMMENTS>.  (<COMMENTS>So</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>identifying</COMMENTS> <COMMENTS>promising</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>has</COMMENTS>
    # <COMMENTS>already</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>done</COMMENTS>).
    #
    # <COMMENTS>In</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>there</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>matched</COMMENTS>: '=>' <COMMENTS>and</COMMENTS> '#'.
    # <COMMENTS>They</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>parts</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>3</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>know</COMMENTS>
    # <COMMENTS>what</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>dump</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>tokens</COMMENTS>
    # <COMMENTS>change</COMMENTS>.
    #
    # <COMMENTS>The</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>contain</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>field</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>patterns</COMMENTS>
    # <COMMENTS>are</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>fields</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>contain</COMMENTS> <COMMENTS>mainly</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>instead</COMMENTS>
    # <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>fewer</COMMENTS> <COMMENTS>characters</COMMENTS>.  <COMMENTS>They</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>matching</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>similar</COMMENTS> <COMMENTS>type</COMMENTS>.
    #
    # <COMMENTS>In</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>there</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>4</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>adjusted</COMMENTS>.  <COMMENTS>The</COMMENTS>
    # <COMMENTS>first</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>zero</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>interior</COMMENTS> <COMMENTS>columns</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>matching</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>tracks</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>.
    #
    # <COMMENTS>Each</COMMENTS> <COMMENTS>time</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>comes</COMMENTS> <COMMENTS>in</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>joins</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>vertical</COMMENTS>
    # <COMMENTS>group</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>possible</COMMENTS>.  <COMMENTS>Otherwise</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>causes</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>dumped</COMMENTS>
    # <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>started</COMMENTS>.
    #
    # <COMMENTS>For</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>member</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>locations</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>increased</COMMENTS>, <COMMENTS>as</COMMENTS>
    # <COMMENTS>necessary</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>room</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>fields</COMMENTS>.  <COMMENTS>When</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>finally</COMMENTS>
    # <COMMENTS>output</COMMENTS>, <COMMENTS>these</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>compute</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>amount</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>of</COMMENTS>
    # <COMMENTS>padding</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>field</COMMENTS>.
    #
    # <COMMENTS>Programming</COMMENTS> <COMMENTS>note</COMMENTS>: <COMMENTS>the</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>assumed</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>tab</COMMENTS> <COMMENTS>characters</COMMENTS>.
    # <COMMENTS>Tabs</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>previously</COMMENTS> <COMMENTS>removed</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>tabs</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>strings</COMMENTS> <COMMENTS>and</COMMENTS>
    # <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>.  <COMMENTS>Tabs</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>mess</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>counting</COMMENTS>.
    # <COMMENTS>The</COMMENTS> <COMMENTS>log</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>warns</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>tabs</COMMENTS>.

    my (
        $<CODE>level</CODE>,               $<CODE>level_end</CODE>,
        $<CODE>indentation</CODE>,         $<CODE>rfields</CODE>,
        $<CODE>rtokens</CODE>,             $<CODE>rpatterns</CODE>,
        $<CODE>is_forced_break</CODE>,     $<CODE>outdent_long_lines</CODE>,
        $<CODE>is_terminal_ternary</CODE>, $<CODE>is_terminal_statement</CODE>,
        $<CODE>do_not_pad</CODE>,          $<CODE>rvertical_tightness_flags</CODE>,
        $<CODE>level_jump</CODE>,
    ) = @<CODE>_</CODE>;

    # <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>$jmax</COMMENTS>
    # <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>$jmax</COMMENTS>-<COMMENTS>1</COMMENTS>
    my $<CODE>jmax</CODE> = $#{$<CODE>rfields</CODE>};

    my $<CODE>leading_space_count</CODE> = <CODE>get_SPACES</CODE>($<CODE>indentation</CODE>);

    # <COMMENTS>set</COMMENTS> <COMMENTS>outdented</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>statements</COMMENTS> <COMMENTS>or</COMMENTS>
    # <COMMENTS>across</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>boundaries</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>both</COMMENTS>.
    my $<CODE>is_outdented</CODE> = $<CODE>last_leading_space_count</CODE> > $<CODE>leading_space_count</CODE>;
    $<CODE>last_leading_space_count</CODE> = $<CODE>leading_space_count</CODE>;

    # <COMMENTS>Patch</COMMENTS>: <COMMENTS>undo</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>hanging</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
    my $<CODE>is_hanging_side_comment</CODE> =
      ( $<CODE>jmax</CODE> == 1 && $<CODE>rtokens</CODE>->[0] eq '#' && $<CODE>rfields</CODE>->[0] =~ /^\s*$/ );
    $<CODE>is_outdented</CODE> = 0 if $<CODE>is_hanging_side_comment</CODE>;

    # <COMMENTS>Forget</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>seeing</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>comments</COMMENTS>
    my $<CODE>is_block_comment</CODE> = ( $<CODE>jmax</CODE> == 0 && $<CODE>rfields</CODE>->[0] =~ /^#/ );
    if ($<CODE>is_block_comment</CODE>) {
        $<CODE>consecutive_block_comments</CODE>++;
    }
    else {
        if ( $<CODE>consecutive_block_comments</CODE> > 1 ) { <CODE>forget_side_comment</CODE>() }
        $<CODE>consecutive_block_comments</CODE> = 0;
    }

    <CODE>VALIGN_DEBUG_FLAG_APPEND0</CODE> && do {
        print <CODE>STDOUT</CODE>
"<LITERALS>APPEND0</LITERALS>: <LITERALS>entering</LITERALS> <LITERALS>lines</LITERALS>=$<CODE>maximum_line_index</CODE> <LITERALS>new</LITERALS> #<LITERALS>fields</LITERALS>= $<CODE>jmax</CODE>, <LITERALS>leading_count</LITERALS>=$<CODE>leading_space_count</CODE> <LITERALS>last_cmt</LITERALS>=$<CODE>last_comment_column</CODE> <LITERALS>force</LITERALS>=$<CODE>is_forced_break</CODE>\n";
    };

    # <COMMENTS>Validate</COMMENTS> <COMMENTS>cached</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>: <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>produce</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>container</COMMENTS>
    # <COMMENTS>with</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>combining</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>existing</COMMENTS> <COMMENTS>cached</COMMENTS> <COMMENTS>opening</COMMENTS>
    # <COMMENTS>token</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>follow</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>mark</COMMENTS> <COMMENTS>both</COMMENTS>
    # <COMMENTS>cached</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>valid</COMMENTS>.
    if ($<CODE>rvertical_tightness_flags</CODE>) {
        if (   $<CODE>maximum_line_index</CODE> <= 0
            && $<CODE>cached_line_type</CODE>
            && $<CODE>cached_seqno</CODE>
            && $<CODE>rvertical_tightness_flags</CODE>->[2]
            && $<CODE>rvertical_tightness_flags</CODE>->[2] == $<CODE>cached_seqno</CODE> )
        {
            $<CODE>rvertical_tightness_flags</CODE>->[3] ||= 1;
            $<CODE>cached_line_valid</CODE> ||= 1;
        }
    }

    # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>unbalanced</COMMENTS> <COMMENTS>line</COMMENTS>
    # <COMMENTS>unless</COMMENTS> <COMMENTS>requested</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>2</COMMENTS>
    if (   $<CODE>cached_line_type</CODE> == 3
        && $<CODE>maximum_line_index</CODE> < 0
        && $<CODE>cached_line_flag</CODE> < 2
        && $<CODE>level_jump</CODE> != 0 )
    {
        $<CODE>cached_line_valid</CODE> = 0;
    }

    # <COMMENTS>patch</COMMENTS> <COMMENTS>until</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>aligner</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>finished</COMMENTS>
    if ($<CODE>do_not_pad</CODE>) { <CODE>my_flush</CODE>() }

    # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>:
    if ( $<CODE>level</CODE> < 0 ) { $<CODE>level</CODE> = 0 }

    # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>across</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>changes</COMMENTS>
    # <COMMENTS>or</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>turned</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>debugging</COMMENTS>
    if ( $<CODE>level</CODE> != $<CODE>group_level</CODE> || $<CODE>is_outdented</CODE> || !$<CODE>rOpts_valign</CODE> ) {

        # <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>allowed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>shift</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>its</COMMENTS>
        # <COMMENTS>level</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>greater</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>group</COMMENTS>
        $<CODE>extra_indent_ok</CODE> =
          ( $<CODE>level</CODE> < $<CODE>group_level</CODE> && $<CODE>last_level_written</CODE> < $<CODE>group_level</CODE> );

        <CODE>my_flush</CODE>();

        # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>flushed</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>itself</COMMENTS> <COMMENTS>because</COMMENTS>
        # <COMMENTS>of</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>changes</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>leave</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>extra_indent_ok</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>set</COMMENTS>.
        # <COMMENTS>That</COMMENTS> <COMMENTS>way</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>external</COMMENTS> <COMMENTS>flush</COMMENTS> <COMMENTS>call</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>be</COMMENTS>
        # <COMMENTS>able</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>some</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>.
        $<CODE>extra_indent_ok</CODE> = ( $<CODE>is_terminal_statement</CODE> && $<CODE>level</CODE> > $<CODE>group_level</CODE> );

        $<CODE>group_level</CODE> = $<CODE>level</CODE>;

        # <COMMENTS>wait</COMMENTS> <COMMENTS>until</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>flush</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>space</COMMENTS>
        # <COMMENTS>count</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>changed</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>icp</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>in</COMMENTS>
        # <COMMENTS>effect</COMMENTS>
        $<CODE>leading_space_count</CODE> = <CODE>get_SPACES</CODE>($<CODE>indentation</CODE>);

    }

    # --------------------------------------------------------------------
    # <COMMENTS>Patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>collect</COMMENTS> <COMMENTS>outdentable</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>COMMENTS</COMMENTS>
    # --------------------------------------------------------------------
    my $<CODE>is_blank_line</CODE> = "";
    if ( $<CODE>group_type</CODE> eq '<LITERALS>COMMENT</LITERALS>' ) {
        if (
            (
                   $<CODE>is_block_comment</CODE>
                && $<CODE>outdent_long_lines</CODE>
                && $<CODE>leading_space_count</CODE> == $<CODE>comment_leading_space_count</CODE>
            )
            || $<CODE>is_blank_line</CODE>
          )
        {
            $<CODE>group_lines</CODE>[ ++$<CODE>maximum_line_index</CODE> ] = $<CODE>rfields</CODE>->[0];
            return;
        }
        else {
            <CODE>my_flush</CODE>();
        }
    }

    # --------------------------------------------------------------------
    # <COMMENTS>add</COMMENTS> <COMMENTS>dummy</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>ternary</COMMENTS>
    # --------------------------------------------------------------------
    my $<CODE>j_terminal_match</CODE>;
    if ( $<CODE>is_terminal_ternary</CODE> && $<CODE>current_line</CODE> ) {
        $<CODE>j_terminal_match</CODE> =
          <CODE>fix_terminal_ternary</CODE>( $<CODE>rfields</CODE>, $<CODE>rtokens</CODE>, $<CODE>rpatterns</CODE> );
        $<CODE>jmax</CODE> = @{$<CODE>rfields</CODE>} - 1;
    }

    # --------------------------------------------------------------------
    # <COMMENTS>add</COMMENTS> <COMMENTS>dummy</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>statement</COMMENTS>
    # --------------------------------------------------------------------
    if (   $<CODE>rfields</CODE>->[0] =~ /^else\s*$/
        && $<CODE>current_line</CODE>
        && $<CODE>level_jump</CODE> == 0 )
    {
        $<CODE>j_terminal_match</CODE> = <CODE>fix_terminal_else</CODE>( $<CODE>rfields</CODE>, $<CODE>rtokens</CODE>, $<CODE>rpatterns</CODE> );
        $<CODE>jmax</CODE> = @{$<CODE>rfields</CODE>} - 1;
    }

    # --------------------------------------------------------------------
    # <COMMENTS>Step</COMMENTS> <COMMENTS>1</COMMENTS>. <COMMENTS>Handle</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>match</COMMENTS>.
    # --------------------------------------------------------------------
    if ( $<CODE>jmax</CODE> <= 0 ) {
        $<CODE>zero_count</CODE>++;

        if ( $<CODE>maximum_line_index</CODE> >= 0
            && !<CODE>get_RECOVERABLE_SPACES</CODE>( $<CODE>group_lines</CODE>[0]-><CODE>get_indentation</CODE>() ) )
        {

            # <COMMENTS>flush</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>aligned</COMMENTS> <COMMENTS>columns</COMMENTS>..
            if ( $<CODE>group_lines</CODE>[0]-><CODE>get_jmax</CODE>() > 1 ) { <CODE>my_flush</CODE>() }

            # <COMMENTS>flush</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>collecting</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>..
            elsif (

                # ...<COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>haven</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>seen</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>lately</COMMENTS>
                ( $<CODE>zero_count</CODE> > 3 )

                # ..<COMMENTS>or</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>fit</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>comments</COMMENTS>
                || ( ( $<CODE>leading_space_count</CODE> + length( $$<CODE>rfields</CODE>[0] ) ) >
                    $<CODE>group_lines</CODE>[0]-><CODE>get_column</CODE>(0) )
              )
            {
                <CODE>my_flush</CODE>();
            }
        }

        # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>COMMENT</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>outdented</COMMENTS>
        if (   $<CODE>is_block_comment</CODE>
            && $<CODE>outdent_long_lines</CODE>
            && $<CODE>maximum_line_index</CODE> < 0 )
        {
            $<CODE>group_type</CODE>                           = '<LITERALS>COMMENT</LITERALS>';
            $<CODE>comment_leading_space_count</CODE>          = $<CODE>leading_space_count</CODE>;
            $<CODE>group_lines</CODE>[ ++$<CODE>maximum_line_index</CODE> ] = $<CODE>rfields</CODE>->[0];
            return;
        }

        # <COMMENTS>just</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>directly</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS>, <COMMENTS>no</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>,
        # <COMMENTS>and</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>recovery</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>needed</COMMENTS>.
        if ( $<CODE>maximum_line_index</CODE> < 0 && !<CODE>get_RECOVERABLE_SPACES</CODE>($<CODE>indentation</CODE>) )
        {
            <CODE>valign_output_step_B</CODE>( $<CODE>leading_space_count</CODE>, $$<CODE>rfields</CODE>[0], 0,
                $<CODE>outdent_long_lines</CODE>, $<CODE>rvertical_tightness_flags</CODE>, $<CODE>level</CODE> );
            return;
        }
    }
    else {
        $<CODE>zero_count</CODE> = 0;
    }

    # <COMMENTS>programming</COMMENTS> <COMMENTS>check</COMMENTS>: (<COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>)
    # <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>implies</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>incorrect</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>made</COMMENTS>
    if ( $<CODE>jmax</CODE> > 0 && ( $#{$<CODE>rtokens</CODE>} != ( $<CODE>jmax</CODE> - 1 ) ) ) {
        <CODE>warning</CODE>(
"<LITERALS>Program</LITERALS> <LITERALS>bug</LITERALS> <LITERALS>in</LITERALS> <LITERALS>Perl</LITERALS>::<LITERALS>Tidy</LITERALS>::<LITERALS>VerticalAligner</LITERALS> - <LITERALS>number</LITERALS> <LITERALS>of</LITERALS> <LITERALS>tokens</LITERALS> = $#{$<CODE>rtokens</CODE>} <LITERALS>should</LITERALS> <LITERALS>be</LITERALS> <LITERALS>one</LITERALS> <LITERALS>less</LITERALS> <LITERALS>than</LITERALS> <LITERALS>number</LITERALS> <LITERALS>of</LITERALS> <LITERALS>fields</LITERALS>: $#{$<CODE>rfields</CODE>})\n"
        );
        <CODE>report_definite_bug</CODE>();
    }

    # --------------------------------------------------------------------
    # <COMMENTS>create</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>hold</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
    # --------------------------------------------------------------------
    my $<CODE>new_line</CODE> = <CODE>new</CODE> <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>VerticalAligner</CODE>::<CODE>Line</CODE>(
        <LITERALS>jmax</LITERALS>                      => $<CODE>jmax</CODE>,
        <LITERALS>jmax_original_line</LITERALS>        => $<CODE>jmax</CODE>,
        <LITERALS>rtokens</LITERALS>                   => $<CODE>rtokens</CODE>,
        <LITERALS>rfields</LITERALS>                   => $<CODE>rfields</CODE>,
        <LITERALS>rpatterns</LITERALS>                 => $<CODE>rpatterns</CODE>,
        <LITERALS>indentation</LITERALS>               => $<CODE>indentation</CODE>,
        <LITERALS>leading_space_count</LITERALS>       => $<CODE>leading_space_count</CODE>,
        <LITERALS>outdent_long_lines</LITERALS>        => $<CODE>outdent_long_lines</CODE>,
        <LITERALS>list_type</LITERALS>                 => "",
        <LITERALS>is_hanging_side_comment</LITERALS>   => $<CODE>is_hanging_side_comment</CODE>,
        <LITERALS>maximum_line_length</LITERALS>       => <CODE>maximum_line_length_for_level</CODE>($<CODE>level</CODE>),
        <LITERALS>rvertical_tightness_flags</LITERALS> => $<CODE>rvertical_tightness_flags</CODE>,
    );

    # <COMMENTS>Initialize</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>global</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>saying</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>should</COMMENTS>
    # <COMMENTS>match</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>terminate</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>group</COMMENTS>.  <COMMENTS>There</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>no</COMMENTS>
    # <COMMENTS>returns</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>bottom</COMMENTS>.
    my $<CODE>col_matching_terminal</CODE> = 0;
    if ( defined($<CODE>j_terminal_match</CODE>) ) {

        # <COMMENTS>remember</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>terminal</COMMENTS> ? <COMMENTS>or</COMMENTS> { <COMMENTS>to</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>with</COMMENTS>
        $<CODE>col_matching_terminal</CODE> = $<CODE>current_line</CODE>-><CODE>get_column</CODE>($<CODE>j_terminal_match</CODE>);

        # <COMMENTS>set</COMMENTS> <COMMENTS>global</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>decide_if_aligned</COMMENTS>
        $<CODE>is_matching_terminal_line</CODE> = 1;
    }

    # --------------------------------------------------------------------
    # <COMMENTS>It</COMMENTS> <COMMENTS>simplifies</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>zero</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
    # <COMMENTS>if</COMMENTS> <COMMENTS>none</COMMENTS> <COMMENTS>exists</COMMENTS>.
    # --------------------------------------------------------------------
    <CODE>make_side_comment</CODE>( $<CODE>new_line</CODE>, $<CODE>level_end</CODE> );

    # --------------------------------------------------------------------
    # <COMMENTS>Decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>items</COMMENTS>.
    # <COMMENTS>There</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>types</COMMENTS>: <COMMENTS>none</COMMENTS>, <COMMENTS>comma</COMMENTS>, <COMMENTS>comma</COMMENTS>-<COMMENTS>arrow</COMMENTS>.
    # <COMMENTS>We</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>less</COMMENTS> <COMMENTS>restrictive</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>deciding</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS>.
    # --------------------------------------------------------------------
    if ($<CODE>is_forced_break</CODE>) {
        <CODE>decide_if_list</CODE>($<CODE>new_line</CODE>);
    }

    if ($<CODE>current_line</CODE>) {

        # --------------------------------------------------------------------
        # <COMMENTS>Allow</COMMENTS> <COMMENTS>hanging</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS>
        # <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>help</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>aligned</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>otherwise</COMMENTS> <COMMENTS>we</COMMENTS>
        # <COMMENTS>will</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>group</COMMENTS>, <COMMENTS>making</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>less</COMMENTS> <COMMENTS>likely</COMMENTS>.
        # --------------------------------------------------------------------
        <CODE>join_hanging_comment</CODE>( $<CODE>new_line</CODE>, $<CODE>current_line</CODE> )
          if $<CODE>is_hanging_side_comment</CODE>;

        # --------------------------------------------------------------------
        # <COMMENTS>If</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>fields</COMMENTS>
        # <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>together</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>with</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>At</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>present</COMMENTS> <COMMENTS>time</COMMENTS>, <COMMENTS>only</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>leading</COMMENTS> '=' <COMMENTS>is</COMMENTS>
        # <COMMENTS>allowed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>compressed</COMMENTS> <COMMENTS>out</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>useful</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>rare</COMMENTS> <COMMENTS>cases</COMMENTS> <COMMENTS>where</COMMENTS>
        # <COMMENTS>a</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>forced</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>breakpoints</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>,
        # <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>table</COMMENTS> <COMMENTS>starts</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
        #   <COMMENTS>my</COMMENTS> %<COMMENTS>MonthChars</COMMENTS> = ('<COMMENTS>0</COMMENTS>', '<COMMENTS>Jan</COMMENTS>',   # <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
        #                     '<COMMENTS>1</COMMENTS>', '<COMMENTS>Feb</COMMENTS>',
        #                     '<COMMENTS>2</COMMENTS>', '<COMMENTS>Mar</COMMENTS>',
        # <COMMENTS>Eliminating</COMMENTS> <COMMENTS>the</COMMENTS> '=' <COMMENTS>field</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>remaining</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS>.
        # <COMMENTS>This</COMMENTS> <COMMENTS>situation</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>occur</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>
        # <COMMENTS>because</COMMENTS> <COMMENTS>scan_list</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> '('.
        # --------------------------------------------------------------------
        <CODE>eliminate_old_fields</CODE>( $<CODE>new_line</CODE>, $<CODE>current_line</CODE> );

        # --------------------------------------------------------------------
        # <COMMENTS>If</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS>,
        # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>remaining</COMMENTS>
        # <COMMENTS>fields</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>.
        # --------------------------------------------------------------------
        <CODE>eliminate_new_fields</CODE>( $<CODE>new_line</CODE>, $<CODE>current_line</CODE> );

        # --------------------------------------------------------------------
        # <COMMENTS>Flush</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>patterns</COMMENTS> <COMMENTS>match</COMMENTS>..
        # --------------------------------------------------------------------
        <CODE>check_match</CODE>( $<CODE>new_line</CODE>, $<CODE>current_line</CODE> );

        # --------------------------------------------------------------------
        # <COMMENTS>See</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS> (<COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS>)
        # --------------------------------------------------------------------
        if ($<CODE>current_line</CODE>) {
            <CODE>check_fit</CODE>( $<CODE>new_line</CODE>, $<CODE>current_line</CODE> );
        }
    }

    # --------------------------------------------------------------------
    # <COMMENTS>Append</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS> (<COMMENTS>or</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>group</COMMENTS>)
    # --------------------------------------------------------------------
    <CODE>add_to_group</CODE>($<CODE>new_line</CODE>);

    # <COMMENTS>Future</COMMENTS> <COMMENTS>update</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>vary</COMMENTS>:
    $<CODE>current_line</CODE> = $<CODE>new_line</CODE> if ( $<CODE>maximum_line_index</CODE> == 0 );

    # <COMMENTS>output</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>ternary</COMMENTS> <COMMENTS>line</COMMENTS>
    if ( defined($<CODE>j_terminal_match</CODE>) ) {

        # <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>group</COMMENTS> (<COMMENTS>maybe</COMMENTS> <COMMENTS>due</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>failure</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>match</COMMENTS>
        # <COMMENTS>perfectly</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>lines</COMMENTS>), <COMMENTS>then</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>the</COMMENTS> ? <COMMENTS>or</COMMENTS> { <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS>
        # <COMMENTS>terminal</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>
        # <COMMENTS>too</COMMENTS> <COMMENTS>long</COMMENTS>
        if ( $<CODE>maximum_line_index</CODE> == 0 ) {
            my $<CODE>col_now</CODE> = $<CODE>current_line</CODE>-><CODE>get_column</CODE>($<CODE>j_terminal_match</CODE>);
            my $<CODE>pad</CODE>     = $<CODE>col_matching_terminal</CODE> - $<CODE>col_now</CODE>;
            my $<CODE>padding_available</CODE> =
              $<CODE>current_line</CODE>-><CODE>get_available_space_on_right</CODE>();
            if ( $<CODE>pad</CODE> > 0 && $<CODE>pad</CODE> <= $<CODE>padding_available</CODE> ) {
                $<CODE>current_line</CODE>-><CODE>increase_field_width</CODE>( $<CODE>j_terminal_match</CODE>, $<CODE>pad</CODE> );
            }
        }
        <CODE>my_flush</CODE>();
        $<CODE>is_matching_terminal_line</CODE> = 0;
    }

    # --------------------------------------------------------------------
    # <COMMENTS>Step</COMMENTS> <COMMENTS>8</COMMENTS>. <COMMENTS>Some</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>debugging</COMMENTS> <COMMENTS>stuff</COMMENTS>
    # --------------------------------------------------------------------
    <CODE>VALIGN_DEBUG_FLAG_APPEND</CODE> && do {
        print <CODE>STDOUT</CODE> "<LITERALS>APPEND</LITERALS> <LITERALS>fields</LITERALS>:";
        <CODE>dump_array</CODE>(@$<CODE>rfields</CODE>);
        print <CODE>STDOUT</CODE> "<LITERALS>APPEND</LITERALS> <LITERALS>tokens</LITERALS>:";
        <CODE>dump_array</CODE>(@$<CODE>rtokens</CODE>);
        print <CODE>STDOUT</CODE> "<LITERALS>APPEND</LITERALS> <LITERALS>patterns</LITERALS>:";
        <CODE>dump_array</CODE>(@$<CODE>rpatterns</CODE>);
        <CODE>dump_alignments</CODE>();
    };

    return;
}

sub <CODE>join_hanging_comment</CODE> {

    my $<CODE>line</CODE> = shift;
    my $<CODE>jmax</CODE> = $<CODE>line</CODE>-><CODE>get_jmax</CODE>();
    return 0 unless $<CODE>jmax</CODE> == 1;    # <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>fields</COMMENTS>
    my $<CODE>rtokens</CODE> = $<CODE>line</CODE>-><CODE>get_rtokens</CODE>();
    return 0 unless $$<CODE>rtokens</CODE>[0] eq '#';    # <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comment</COMMENTS>..
    my $<CODE>rfields</CODE> = $<CODE>line</CODE>-><CODE>get_rfields</CODE>();
    return 0 unless $$<CODE>rfields</CODE>[0] =~ /^\s*$/;    # <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>empty</COMMENTS>...
    my $<CODE>old_line</CODE>            = shift;
    my $<CODE>maximum_field_index</CODE> = $<CODE>old_line</CODE>-><CODE>get_jmax</CODE>();
    return 0
      unless $<CODE>maximum_field_index</CODE> > $<CODE>jmax</CODE>;    # <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>fields</COMMENTS>
    my $<CODE>rpatterns</CODE> = $<CODE>line</CODE>-><CODE>get_rpatterns</CODE>();

    $<CODE>line</CODE>-><CODE>set_is_hanging_side_comment</CODE>(1);
    $<CODE>jmax</CODE> = $<CODE>maximum_field_index</CODE>;
    $<CODE>line</CODE>-><CODE>set_jmax</CODE>($<CODE>jmax</CODE>);
    $$<CODE>rfields</CODE>[$<CODE>jmax</CODE>]         = $$<CODE>rfields</CODE>[1];
    $$<CODE>rtokens</CODE>[ $<CODE>jmax</CODE> - 1 ]   = $$<CODE>rtokens</CODE>[0];
    $$<CODE>rpatterns</CODE>[ $<CODE>jmax</CODE> - 1 ] = $$<CODE>rpatterns</CODE>[0];
    for ( my $<CODE>j</CODE> = 1 ; $<CODE>j</CODE> < $<CODE>jmax</CODE> ; $<CODE>j</CODE>++ ) {
        $$<CODE>rfields</CODE>[$<CODE>j</CODE>]         = " ";  # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>caused</COMMENTS> <COMMENTS>glitch</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>blank</COMMENTS>, <COMMENTS>why</COMMENTS>?
        $$<CODE>rtokens</CODE>[ $<CODE>j</CODE> - 1 ]   = "";
        $$<CODE>rpatterns</CODE>[ $<CODE>j</CODE> - 1 ] = "";
    }
    return 1;
}

sub <CODE>eliminate_old_fields</CODE> {

    my $<CODE>new_line</CODE> = shift;
    my $<CODE>jmax</CODE>     = $<CODE>new_line</CODE>-><CODE>get_jmax</CODE>();
    if ( $<CODE>jmax</CODE> > $<CODE>maximum_jmax_seen</CODE> ) { $<CODE>maximum_jmax_seen</CODE> = $<CODE>jmax</CODE> }
    if ( $<CODE>jmax</CODE> < $<CODE>minimum_jmax_seen</CODE> ) { $<CODE>minimum_jmax_seen</CODE> = $<CODE>jmax</CODE> }

    # <COMMENTS>there</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS>
    return unless ( $<CODE>maximum_line_index</CODE> == 0 );

    my $<CODE>old_line</CODE>            = shift;
    my $<CODE>maximum_field_index</CODE> = $<CODE>old_line</CODE>-><CODE>get_jmax</CODE>();

    ###############################################
    # <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>fewer</COMMENTS> <COMMENTS>fields</COMMENTS>
    return unless $<CODE>maximum_field_index</CODE> > $<CODE>jmax</CODE>;
    ###############################################

    # <COMMENTS>Identify</COMMENTS> <COMMENTS>specific</COMMENTS> <COMMENTS>cases</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>elimination</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>allowed</COMMENTS>:
    # <COMMENTS>case</COMMENTS>=<COMMENTS>1</COMMENTS>: <COMMENTS>both</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>comma</COMMENTS>-<COMMENTS>separated</COMMENTS> <COMMENTS>lists</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS>
    #         <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>equals</COMMENTS>
    # <COMMENTS>case</COMMENTS>=<COMMENTS>2</COMMENTS>: <COMMENTS>both</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>equals</COMMENTS>

    # <COMMENTS>case</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS>
    my $<CODE>case</CODE> = 1;

    # <COMMENTS>See</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>2</COMMENTS>: <COMMENTS>both</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>leading</COMMENTS> '='
    # <COMMENTS>We</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>require</COMMENTS> <COMMENTS>similar</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>patterns</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>case</COMMENTS>
    my $<CODE>old_rtokens</CODE>   = $<CODE>old_line</CODE>-><CODE>get_rtokens</CODE>();
    my $<CODE>rtokens</CODE>       = $<CODE>new_line</CODE>-><CODE>get_rtokens</CODE>();
    my $<CODE>rpatterns</CODE>     = $<CODE>new_line</CODE>-><CODE>get_rpatterns</CODE>();
    my $<CODE>old_rpatterns</CODE> = $<CODE>old_line</CODE>-><CODE>get_rpatterns</CODE>();
    if (   $<CODE>rtokens</CODE>->[0] =~ /^=\d*$/
        && $<CODE>old_rtokens</CODE>->[0] eq $<CODE>rtokens</CODE>->[0]
        && $<CODE>old_rpatterns</CODE>->[0] eq $<CODE>rpatterns</CODE>->[0] )
    {
        $<CODE>case</CODE> = 2;
    }

    # <COMMENTS>not</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>fewer</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>1</COMMENTS>
    return unless ( $<CODE>case</CODE> != 1 || $<CODE>maximum_field_index</CODE> - 2 <= $<CODE>jmax</CODE> );

    # <COMMENTS>case</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
    my $<CODE>old_rfields</CODE> = $<CODE>old_line</CODE>-><CODE>get_rfields</CODE>();
    return
      if ( $<CODE>case</CODE> == 1
        && length( $$<CODE>old_rfields</CODE>[$<CODE>maximum_field_index</CODE>] ) == 0 );

    my $<CODE>rfields</CODE> = $<CODE>new_line</CODE>-><CODE>get_rfields</CODE>();

    my $<CODE>hid_equals</CODE> = 0;

    my @<CODE>new_alignments</CODE>        = ();
    my @<CODE>new_fields</CODE>            = ();
    my @<CODE>new_matching_patterns</CODE> = ();
    my @<CODE>new_matching_tokens</CODE>   = ();

    my $<CODE>j</CODE> = 0;
    my $<CODE>k</CODE>;
    my $<CODE>current_field</CODE>   = '';
    my $<CODE>current_pattern</CODE> = '';

    # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>tokens</COMMENTS>
    my $<CODE>in_match</CODE> = 0;
    for ( $<CODE>k</CODE> = 0 ; $<CODE>k</CODE> < $<CODE>maximum_field_index</CODE> ; $<CODE>k</CODE>++ ) {
        $<CODE>current_field</CODE>   .= $$<CODE>old_rfields</CODE>[$<CODE>k</CODE>];
        $<CODE>current_pattern</CODE> .= $$<CODE>old_rpatterns</CODE>[$<CODE>k</CODE>];
        last if ( $<CODE>j</CODE> > $<CODE>jmax</CODE> - 1 );

        if ( $$<CODE>old_rtokens</CODE>[$<CODE>k</CODE>] eq $$<CODE>rtokens</CODE>[$<CODE>j</CODE>] ) {
            $<CODE>in_match</CODE>                  = 1;
            $<CODE>new_fields</CODE>[$<CODE>j</CODE>]            = $<CODE>current_field</CODE>;
            $<CODE>new_matching_patterns</CODE>[$<CODE>j</CODE>] = $<CODE>current_pattern</CODE>;
            $<CODE>current_field</CODE>             = '';
            $<CODE>current_pattern</CODE>           = '';
            $<CODE>new_matching_tokens</CODE>[$<CODE>j</CODE>]   = $$<CODE>old_rtokens</CODE>[$<CODE>k</CODE>];
            $<CODE>new_alignments</CODE>[$<CODE>j</CODE>]        = $<CODE>old_line</CODE>-><CODE>get_alignment</CODE>($<CODE>k</CODE>);
            $<CODE>j</CODE>++;
        }
        else {

            if ( $$<CODE>old_rtokens</CODE>[$<CODE>k</CODE>] =~ /^\=\d*$/ ) {
                last if ( $<CODE>case</CODE> == 2 );    # <COMMENTS>avoid</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>stuff</COMMENTS>
                                           # <COMMENTS>like</COMMENTS>:   <COMMENTS>$a</COMMENTS>=<COMMENTS>$b</COMMENTS>=<COMMENTS>$c</COMMENTS>=<COMMENTS>$d</COMMENTS>;
                $<CODE>hid_equals</CODE> = 1;
            }
            last
              if ( $<CODE>in_match</CODE> && $<CODE>case</CODE> == 1 )
              ;    # <COMMENTS>disallow</COMMENTS> <COMMENTS>gaps</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>matching</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>1</COMMENTS>
        }
    }

    # <COMMENTS>Modify</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>state</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>successful</COMMENTS>.
    # <COMMENTS>We</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>exactly</COMMENTS> <COMMENTS>reach</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>lists</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>success</COMMENTS>.
    if (   ( $<CODE>j</CODE> == $<CODE>jmax</CODE> )
        && ( $<CODE>current_field</CODE> eq '' )
        && ( $<CODE>case</CODE> != 1 || $<CODE>hid_equals</CODE> ) )
    {
        $<CODE>k</CODE> = $<CODE>maximum_field_index</CODE>;
        $<CODE>current_field</CODE>   .= $$<CODE>old_rfields</CODE>[$<CODE>k</CODE>];
        $<CODE>current_pattern</CODE> .= $$<CODE>old_rpatterns</CODE>[$<CODE>k</CODE>];
        $<CODE>new_fields</CODE>[$<CODE>j</CODE>]            = $<CODE>current_field</CODE>;
        $<CODE>new_matching_patterns</CODE>[$<CODE>j</CODE>] = $<CODE>current_pattern</CODE>;

        $<CODE>new_alignments</CODE>[$<CODE>j</CODE>] = $<CODE>old_line</CODE>-><CODE>get_alignment</CODE>($<CODE>k</CODE>);
        $<CODE>maximum_field_index</CODE> = $<CODE>j</CODE>;

        $<CODE>old_line</CODE>-><CODE>set_alignments</CODE>(@<CODE>new_alignments</CODE>);
        $<CODE>old_line</CODE>-><CODE>set_jmax</CODE>($<CODE>jmax</CODE>);
        $<CODE>old_line</CODE>-><CODE>set_rtokens</CODE>( \@<CODE>new_matching_tokens</CODE> );
        $<CODE>old_line</CODE>-><CODE>set_rfields</CODE>( \@<CODE>new_fields</CODE> );
        $<CODE>old_line</CODE>-><CODE>set_rpatterns</CODE>( \@$<CODE>rpatterns</CODE> );
    }
}

# <COMMENTS>create</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>none</COMMENTS> <COMMENTS>exists</COMMENTS>
sub <CODE>make_side_comment</CODE> {
    my $<CODE>new_line</CODE>  = shift;
    my $<CODE>level_end</CODE> = shift;
    my $<CODE>jmax</CODE>      = $<CODE>new_line</CODE>-><CODE>get_jmax</CODE>();
    my $<CODE>rtokens</CODE>   = $<CODE>new_line</CODE>-><CODE>get_rtokens</CODE>();

    # <COMMENTS>if</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>...
    if ( ( $<CODE>jmax</CODE> == 0 ) || ( $$<CODE>rtokens</CODE>[ $<CODE>jmax</CODE> - 1 ] ne '#' ) ) {
        my $<CODE>rfields</CODE>   = $<CODE>new_line</CODE>-><CODE>get_rfields</CODE>();
        my $<CODE>rpatterns</CODE> = $<CODE>new_line</CODE>-><CODE>get_rpatterns</CODE>();
        $$<CODE>rtokens</CODE>[$<CODE>jmax</CODE>]     = '#';
        $$<CODE>rfields</CODE>[ ++$<CODE>jmax</CODE> ] = '';
        $$<CODE>rpatterns</CODE>[$<CODE>jmax</CODE>]   = '#';
        $<CODE>new_line</CODE>-><CODE>set_jmax</CODE>($<CODE>jmax</CODE>);
        $<CODE>new_line</CODE>-><CODE>set_jmax_original_line</CODE>($<CODE>jmax</CODE>);
    }

    # <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>..
    else {

        # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>remember</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>location</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>long</COMMENTS>
        my $<CODE>line_number</CODE> = $<CODE>vertical_aligner_self</CODE>-><CODE>get_output_line_number</CODE>();
        my $<CODE>rfields</CODE>     = $<CODE>new_line</CODE>-><CODE>get_rfields</CODE>();
        if (
            $<CODE>line_number</CODE> - $<CODE>last_side_comment_line_number</CODE> > 12

            # <COMMENTS>and</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>remember</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>location</COMMENTS> <COMMENTS>across</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>changes</COMMENTS>
            || ( $<CODE>level_end</CODE> < $<CODE>last_side_comment_level</CODE> && $$<CODE>rfields</CODE>[0] =~ /^}/ )
          )
        {
            <CODE>forget_side_comment</CODE>();
        }
        $<CODE>last_side_comment_line_number</CODE> = $<CODE>line_number</CODE>;
        $<CODE>last_side_comment_level</CODE>       = $<CODE>level_end</CODE>;
    }
}

sub <CODE>decide_if_list</CODE> {

    my $<CODE>line</CODE> = shift;

    # <COMMENTS>A</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>taken</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>forced</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>all</COMMENTS>
    # <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>separators</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>comma</COMMENTS>-<COMMENTS>arrows</COMMENTS> (<COMMENTS>except</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>trailing</COMMENTS> #)

    # <COMMENTS>List</COMMENTS> <COMMENTS>separator</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>like</COMMENTS> ',<COMMENTS>3</COMMENTS>'   <COMMENTS>or</COMMENTS> '=><COMMENTS>2</COMMENTS>',
    # <COMMENTS>where</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>digit</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depth</COMMENTS>.  <COMMENTS>Allow</COMMENTS> <COMMENTS>braces</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>nested</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>items</COMMENTS>.
    my $<CODE>rtokens</CODE>    = $<CODE>line</CODE>-><CODE>get_rtokens</CODE>();
    my $<CODE>test_token</CODE> = $$<CODE>rtokens</CODE>[0];
    if ( $<CODE>test_token</CODE> =~ /^(\,|=>)/ ) {
        my $<CODE>list_type</CODE> = $<CODE>test_token</CODE>;
        my $<CODE>jmax</CODE>      = $<CODE>line</CODE>-><CODE>get_jmax</CODE>();

        foreach ( 1 .. $<CODE>jmax</CODE> - 2 ) {
            if ( $$<CODE>rtokens</CODE>[$<CODE>_</CODE>] !~ /^(\,|=>|\{)/ ) {
                $<CODE>list_type</CODE> = "";
                last;
            }
        }
        $<CODE>line</CODE>-><CODE>set_list_type</CODE>($<CODE>list_type</CODE>);
    }
}

sub <CODE>eliminate_new_fields</CODE> {

    return unless ( $<CODE>maximum_line_index</CODE> >= 0 );
    my ( $<CODE>new_line</CODE>, $<CODE>old_line</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>jmax</CODE> = $<CODE>new_line</CODE>-><CODE>get_jmax</CODE>();

    my $<CODE>old_rtokens</CODE> = $<CODE>old_line</CODE>-><CODE>get_rtokens</CODE>();
    my $<CODE>rtokens</CODE>     = $<CODE>new_line</CODE>-><CODE>get_rtokens</CODE>();
    my $<CODE>is_assignment</CODE> =
      ( $<CODE>rtokens</CODE>->[0] =~ /^=\d*$/ && ( $<CODE>old_rtokens</CODE>->[0] eq $<CODE>rtokens</CODE>->[0] ) );

    # <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>monotonic</COMMENTS> <COMMENTS>variation</COMMENTS>
    return unless ( $<CODE>is_assignment</CODE> || $<CODE>previous_maximum_jmax_seen</CODE> <= $<CODE>jmax</CODE> );

    # <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>
    my $<CODE>maximum_field_index</CODE> = $<CODE>old_line</CODE>-><CODE>get_jmax</CODE>();
    return unless ( $<CODE>maximum_field_index</CODE> < $<CODE>jmax</CODE> );

    unless ($<CODE>is_assignment</CODE>) {
        return
          unless ( $<CODE>old_line</CODE>-><CODE>get_jmax_original_line</CODE>() == $<CODE>minimum_jmax_seen</CODE> )
          ;    # <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>monotonic</COMMENTS>

        # <COMMENTS>never</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>list</COMMENTS>
        return
          unless ( $<CODE>maximum_field_index</CODE> > 1 )
          && ( $<CODE>new_line</CODE>-><CODE>get_list_type</CODE>() !~ /^,/ );
    }

    my $<CODE>rfields</CODE>       = $<CODE>new_line</CODE>-><CODE>get_rfields</CODE>();
    my $<CODE>rpatterns</CODE>     = $<CODE>new_line</CODE>-><CODE>get_rpatterns</CODE>();
    my $<CODE>old_rpatterns</CODE> = $<CODE>old_line</CODE>-><CODE>get_rpatterns</CODE>();

    # <COMMENTS>loop</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>OLD</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>match</COMMENTS>
    my $<CODE>match</CODE> = 1;
    my $<CODE>k</CODE>;
    for ( $<CODE>k</CODE> = 0 ; $<CODE>k</CODE> < $<CODE>maximum_field_index</CODE> - 1 ; $<CODE>k</CODE>++ ) {
        if (   ( $$<CODE>old_rtokens</CODE>[$<CODE>k</CODE>] ne $$<CODE>rtokens</CODE>[$<CODE>k</CODE>] )
            || ( $$<CODE>old_rpatterns</CODE>[$<CODE>k</CODE>] ne $$<CODE>rpatterns</CODE>[$<CODE>k</CODE>] ) )
        {
            $<CODE>match</CODE> = 0;
            last;
        }
    }

    # <COMMENTS>first</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>agree</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>tokens</COMMENTS>
    if ($<CODE>match</CODE>) {
        for $<CODE>k</CODE> ( $<CODE>maximum_field_index</CODE> .. $<CODE>jmax</CODE> - 1 ) {

            $$<CODE>rfields</CODE>[ $<CODE>maximum_field_index</CODE> - 1 ] .= $$<CODE>rfields</CODE>[$<CODE>k</CODE>];
            $$<CODE>rfields</CODE>[$<CODE>k</CODE>] = "";
            $$<CODE>rpatterns</CODE>[ $<CODE>maximum_field_index</CODE> - 1 ] .= $$<CODE>rpatterns</CODE>[$<CODE>k</CODE>];
            $$<CODE>rpatterns</CODE>[$<CODE>k</CODE>] = "";
        }

        $$<CODE>rtokens</CODE>[ $<CODE>maximum_field_index</CODE> - 1 ] = '#';
        $$<CODE>rfields</CODE>[$<CODE>maximum_field_index</CODE>]       = $$<CODE>rfields</CODE>[$<CODE>jmax</CODE>];
        $$<CODE>rpatterns</CODE>[$<CODE>maximum_field_index</CODE>]     = $$<CODE>rpatterns</CODE>[$<CODE>jmax</CODE>];
        $<CODE>jmax</CODE>                                 = $<CODE>maximum_field_index</CODE>;
    }
    $<CODE>new_line</CODE>-><CODE>set_jmax</CODE>($<CODE>jmax</CODE>);
}

sub <CODE>fix_terminal_ternary</CODE> {

    # <COMMENTS>Add</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>ternary</COMMENTS> <COMMENTS>term</COMMENTS>
    # <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
    #
    #  <COMMENTS>my</COMMENTS> <COMMENTS>$leapyear</COMMENTS> =
    #      <COMMENTS>$year</COMMENTS> % <COMMENTS>4</COMMENTS>   ? <COMMENTS>0</COMMENTS>
    #    : <COMMENTS>$year</COMMENTS> % <COMMENTS>100</COMMENTS> ? <COMMENTS>1</COMMENTS>
    #    : <COMMENTS>$year</COMMENTS> % <COMMENTS>400</COMMENTS> ? <COMMENTS>0</COMMENTS>
    #    :               <COMMENTS>1</COMMENTS>;
    #
    # <COMMENTS>returns</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>indented</COMMENTS>

    my ( $<CODE>rfields</CODE>, $<CODE>rtokens</CODE>, $<CODE>rpatterns</CODE> ) = @<CODE>_</CODE>;

    my $<CODE>jmax</CODE>        = @{$<CODE>rfields</CODE>} - 1;
    my $<CODE>old_line</CODE>    = $<CODE>group_lines</CODE>[$<CODE>maximum_line_index</CODE>];
    my $<CODE>rfields_old</CODE> = $<CODE>old_line</CODE>-><CODE>get_rfields</CODE>();

    my $<CODE>rpatterns_old</CODE>       = $<CODE>old_line</CODE>-><CODE>get_rpatterns</CODE>();
    my $<CODE>rtokens_old</CODE>         = $<CODE>old_line</CODE>-><CODE>get_rtokens</CODE>();
    my $<CODE>maximum_field_index</CODE> = $<CODE>old_line</CODE>-><CODE>get_jmax</CODE>();

    # <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>question</COMMENTS> <COMMENTS>mark</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> :
    my ($<CODE>jquestion</CODE>);
    my $<CODE>depth_question</CODE>;
    my $<CODE>pad</CODE> = "";
    for ( my $<CODE>j</CODE> = 0 ; $<CODE>j</CODE> < $<CODE>maximum_field_index</CODE> ; $<CODE>j</CODE>++ ) {
        my $<CODE>tok</CODE> = $<CODE>rtokens_old</CODE>->[$<CODE>j</CODE>];
        if ( $<CODE>tok</CODE> =~ /^\?(\d+)$/ ) {
            $<CODE>depth_question</CODE> = $<CODE>1</CODE>;

            # <COMMENTS>depth</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>correct</COMMENTS>
            next unless ( $<CODE>depth_question</CODE> eq $<CODE>group_level</CODE> );

            $<CODE>jquestion</CODE> = $<CODE>j</CODE>;
            if ( $<CODE>rfields_old</CODE>->[ $<CODE>j</CODE> + 1 ] =~ /^(\?\s*)/ ) {
                $<CODE>pad</CODE> = " " x length($<CODE>1</CODE>);
            }
            else {
                return;    # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>
            }
            last;
        }
    }
    return unless ( defined($<CODE>jquestion</CODE>) );    # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>

    # <COMMENTS>Now</COMMENTS> <COMMENTS>splice</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>patterns</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS>
    # <COMMENTS>into</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>insure</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>match</COMMENTS>.  <COMMENTS>Add</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>fields</COMMENTS>
    # <COMMENTS>as</COMMENTS> <COMMENTS>necessary</COMMENTS>.
    my $<CODE>jadd</CODE> = $<CODE>jquestion</CODE>;

    # <COMMENTS>Work</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>copies</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>arrays</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>due</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS>
    my @<CODE>fields</CODE>   = @{$<CODE>rfields</CODE>};
    my @<CODE>patterns</CODE> = @{$<CODE>rpatterns</CODE>};
    my @<CODE>tokens</CODE>   = @{$<CODE>rtokens</CODE>};

    <CODE>VALIGN_DEBUG_FLAG_TERNARY</CODE> && do {
        local $" = '><';
        print <CODE>STDOUT</CODE> "<LITERALS>CURRENT</LITERALS> <LITERALS>FIELDS</LITERALS>=<@{$<CODE>rfields_old</CODE>}>\n";
        print <CODE>STDOUT</CODE> "<LITERALS>CURRENT</LITERALS> <LITERALS>TOKENS</LITERALS>=<@{$<CODE>rtokens_old</CODE>}>\n";
        print <CODE>STDOUT</CODE> "<LITERALS>CURRENT</LITERALS> <LITERALS>PATTERNS</LITERALS>=<@{$<CODE>rpatterns_old</CODE>}>\n";
        print <CODE>STDOUT</CODE> "<LITERALS>UNMODIFIED</LITERALS> <LITERALS>FIELDS</LITERALS>=<@{$<CODE>rfields</CODE>}>\n";
        print <CODE>STDOUT</CODE> "<LITERALS>UNMODIFIED</LITERALS> <LITERALS>TOKENS</LITERALS>=<@{$<CODE>rtokens</CODE>}>\n";
        print <CODE>STDOUT</CODE> "<LITERALS>UNMODIFIED</LITERALS> <LITERALS>PATTERNS</LITERALS>=<@{$<CODE>rpatterns</CODE>}>\n";
    };

    # <COMMENTS>handle</COMMENTS> <COMMENTS>cases</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>colon</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
    if ( $<CODE>fields</CODE>[0] =~ /^(:\s*)(.*)$/ ) {

        my ( $<CODE>colon</CODE>, $<CODE>therest</CODE> ) = ( $<CODE>1</CODE>, $<CODE>2</CODE> );

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>sub</COMMENTS>-<COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>colon</COMMENTS> <COMMENTS>plus</COMMENTS> <COMMENTS>additional</COMMENTS> <COMMENTS>code</COMMENTS>
        # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>usual</COMMENTS> <COMMENTS>situation</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>1</COMMENTS>' <COMMENTS>below</COMMENTS>:
        #  ...
        #  : <COMMENTS>$year</COMMENTS> % <COMMENTS>400</COMMENTS> ? <COMMENTS>0</COMMENTS>
        #  :               <COMMENTS>1</COMMENTS>;
        if ($<CODE>therest</CODE>) {

            # <COMMENTS>Split</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>colon</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>insert</COMMENTS> <COMMENTS>padding</COMMENTS>.
            # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>remain</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>goes</COMMENTS>
            # <COMMENTS>out</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>seem</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>bad</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>no</COMMENTS>
            # <COMMENTS>mechanism</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>included</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>undo</COMMENTS> <COMMENTS>it</COMMENTS>.
            my $<CODE>field1</CODE> = shift @<CODE>fields</CODE>;
            unshift @<CODE>fields</CODE>, ( $<CODE>colon</CODE>, $<CODE>pad</CODE> . $<CODE>therest</CODE> );

            # <COMMENTS>change</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>from</COMMENTS> : <COMMENTS>to</COMMENTS> ?
            return unless ( $<CODE>patterns</CODE>[0] =~ s/^\:/?/ );

            # <COMMENTS>install</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>patterns</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>existing</COMMENTS> <COMMENTS>line</COMMENTS>
            unshift( @<CODE>tokens</CODE>,   @{$<CODE>rtokens_old</CODE>}[ 0 .. $<CODE>jquestion</CODE> ] );
            unshift( @<CODE>patterns</CODE>, @{$<CODE>rpatterns_old</CODE>}[ 0 .. $<CODE>jquestion</CODE> ] );

            # <COMMENTS>insert</COMMENTS> <COMMENTS>appropriate</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>fields</COMMENTS>
            splice( @<CODE>fields</CODE>, 1, 0, ('') x $<CODE>jadd</CODE> ) if $<CODE>jadd</CODE>;
        }

        # <COMMENTS>handle</COMMENTS> <COMMENTS>sub</COMMENTS>-<COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>equal</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>colon</COMMENTS>.
        # <COMMENTS>This</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>where</COMMENTS>
        # <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> '(' <COMMENTS>would</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>token</COMMENTS>
        # : ( <COMMENTS>$name</COMMENTS> =~ /[]}]<COMMENTS>$</COMMENTS>/ ) ? ( <COMMENTS>$mname</COMMENTS> = <COMMENTS>$name</COMMENTS> )
        # :                        ( <COMMENTS>$mname</COMMENTS> = <COMMENTS>$name</COMMENTS> . '->' );
        else {

            return unless ( $<CODE>jmax</CODE> > 0 && $<CODE>tokens</CODE>[0] ne '#' ); # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>

            # <COMMENTS>prepend</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS> ? <COMMENTS>onto</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>pattern</COMMENTS>
            $<CODE>patterns</CODE>[1] = "?<LITERALS>b</LITERALS>" . $<CODE>patterns</CODE>[1];

            # <COMMENTS>pad</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>field</COMMENTS>
            $<CODE>fields</CODE>[1] = $<CODE>pad</CODE> . $<CODE>fields</CODE>[1];

            # <COMMENTS>install</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>patterns</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>existing</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>replacing</COMMENTS>
            # <COMMENTS>leading</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>inserting</COMMENTS> <COMMENTS>appropriate</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>fields</COMMENTS>
            splice( @<CODE>tokens</CODE>,   0, 1, @{$<CODE>rtokens_old</CODE>}[ 0 .. $<CODE>jquestion</CODE> ] );
            splice( @<CODE>patterns</CODE>, 1, 0, @{$<CODE>rpatterns_old</CODE>}[ 1 .. $<CODE>jquestion</CODE> ] );
            splice( @<CODE>fields</CODE>, 1, 0, ('') x $<CODE>jadd</CODE> ) if $<CODE>jadd</CODE>;
        }
    }

    # <COMMENTS>Handle</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>colon</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS>
    # <COMMENTS>be</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>when</COMMENTS> -<COMMENTS>wba</COMMENTS>=':' <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>,
    #  <COMMENTS>$year</COMMENTS> % <COMMENTS>400</COMMENTS> ? <COMMENTS>0</COMMENTS> :
    #                <COMMENTS>1</COMMENTS>;
    else {

        # <COMMENTS>install</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>patterns</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>existing</COMMENTS> <COMMENTS>line</COMMENTS>
        $<CODE>patterns</CODE>[0] = '?' . '<LITERALS>b</LITERALS>' . $<CODE>patterns</CODE>[0];
        unshift( @<CODE>tokens</CODE>,   @{$<CODE>rtokens_old</CODE>}[ 0 .. $<CODE>jquestion</CODE> ] );
        unshift( @<CODE>patterns</CODE>, @{$<CODE>rpatterns_old</CODE>}[ 0 .. $<CODE>jquestion</CODE> ] );

        # <COMMENTS>insert</COMMENTS> <COMMENTS>appropriate</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>fields</COMMENTS>
        $<CODE>jadd</CODE> = $<CODE>jquestion</CODE> + 1;
        $<CODE>fields</CODE>[0] = $<CODE>pad</CODE> . $<CODE>fields</CODE>[0];
        splice( @<CODE>fields</CODE>, 0, 0, ('') x $<CODE>jadd</CODE> ) if $<CODE>jadd</CODE>;
    }

    <CODE>VALIGN_DEBUG_FLAG_TERNARY</CODE> && do {
        local $" = '><';
        print <CODE>STDOUT</CODE> "<LITERALS>MODIFIED</LITERALS> <LITERALS>TOKENS</LITERALS>=<@<CODE>tokens</CODE>>\n";
        print <CODE>STDOUT</CODE> "<LITERALS>MODIFIED</LITERALS> <LITERALS>PATTERNS</LITERALS>=<@<CODE>patterns</CODE>>\n";
        print <CODE>STDOUT</CODE> "<LITERALS>MODIFIED</LITERALS> <LITERALS>FIELDS</LITERALS>=<@<CODE>fields</CODE>>\n";
    };

    # <COMMENTS>all</COMMENTS> <COMMENTS>ok</COMMENTS> .. <COMMENTS>update</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>arrays</COMMENTS>
    @{$<CODE>rfields</CODE>}   = @<CODE>fields</CODE>;
    @{$<CODE>rtokens</CODE>}   = @<CODE>tokens</CODE>;
    @{$<CODE>rpatterns</CODE>} = @<CODE>patterns</CODE>;

    # <COMMENTS>force</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flush</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
    return $<CODE>jquestion</CODE>;
}

sub <CODE>fix_terminal_else</CODE> {

    # <COMMENTS>Add</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>balanced</COMMENTS> <COMMENTS>terminal</COMMENTS>
    # <COMMENTS>else</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>if</COMMENTS>/<COMMENTS>elsif</COMMENTS>/<COMMENTS>unless</COMMENTS> <COMMENTS>block</COMMENTS>,
    # <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
    #
    #  <COMMENTS>if</COMMENTS>   ( <COMMENTS>1</COMMENTS> || <COMMENTS>$x</COMMENTS> ) { <COMMENTS>print</COMMENTS> "<COMMENTS>ok</COMMENTS> <COMMENTS>13</COMMENTS>\<COMMENTS>n</COMMENTS>"; }
    #  <COMMENTS>else</COMMENTS>             { <COMMENTS>print</COMMENTS> "<COMMENTS>not</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>13</COMMENTS>\<COMMENTS>n</COMMENTS>"; }
    #
    # <COMMENTS>returns</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>indented</COMMENTS>
    #
    my ( $<CODE>rfields</CODE>, $<CODE>rtokens</CODE>, $<CODE>rpatterns</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>jmax</CODE> = @{$<CODE>rfields</CODE>} - 1;
    return unless ( $<CODE>jmax</CODE> > 0 );

    # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>balanced</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>if</COMMENTS>/<COMMENTS>elsif</COMMENTS>/<COMMENTS>unless</COMMENTS>
    my $<CODE>rfields_old</CODE> = $<CODE>current_line</CODE>-><CODE>get_rfields</CODE>();

    # <COMMENTS>TBD</COMMENTS>: <COMMENTS>add</COMMENTS> <COMMENTS>handling</COMMENTS> <COMMENTS>for</COMMENTS> '<COMMENTS>case</COMMENTS>'
    return unless ( $<CODE>rfields_old</CODE>->[0] =~ /^(if|elsif|unless)\s*$/ );

    # <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>else</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>extract</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>depth</COMMENTS>
    my $<CODE>tok_brace</CODE> = $<CODE>rtokens</CODE>->[0];
    my $<CODE>depth_brace</CODE>;
    if ( $<CODE>tok_brace</CODE> =~ /^\{(\d+)/ ) { $<CODE>depth_brace</CODE> = $<CODE>1</CODE>; }

    # <COMMENTS>probably</COMMENTS>:  "<COMMENTS>else</COMMENTS> # <COMMENTS>side_comment</COMMENTS>"
    else { return }

    my $<CODE>rpatterns_old</CODE>       = $<CODE>current_line</CODE>-><CODE>get_rpatterns</CODE>();
    my $<CODE>rtokens_old</CODE>         = $<CODE>current_line</CODE>-><CODE>get_rtokens</CODE>();
    my $<CODE>maximum_field_index</CODE> = $<CODE>current_line</CODE>-><CODE>get_jmax</CODE>();

    # <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>if</COMMENTS>/<COMMENTS>elsif</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS>
    my $<CODE>jparen</CODE>    = 0;
    my $<CODE>tok_paren</CODE> = '(' . $<CODE>depth_brace</CODE>;
    my $<CODE>tok_test</CODE>  = $<CODE>rtokens_old</CODE>->[$<CODE>jparen</CODE>];
    return unless ( $<CODE>tok_test</CODE> eq $<CODE>tok_paren</CODE> );    # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>

    # <COMMENTS>Now</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>brace</COMMENTS>
    my ($<CODE>jbrace</CODE>);
    for ( my $<CODE>j</CODE> = 1 ; $<CODE>j</CODE> < $<CODE>maximum_field_index</CODE> ; $<CODE>j</CODE>++ ) {
        my $<CODE>tok</CODE> = $<CODE>rtokens_old</CODE>->[$<CODE>j</CODE>];
        if ( $<CODE>tok</CODE> eq $<CODE>tok_brace</CODE> ) {
            $<CODE>jbrace</CODE> = $<CODE>j</CODE>;
            last;
        }
    }
    return unless ( defined($<CODE>jbrace</CODE>) );           # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>

    # <COMMENTS>Now</COMMENTS> <COMMENTS>splice</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>patterns</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS>
    # <COMMENTS>into</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>insure</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>match</COMMENTS>.  <COMMENTS>Add</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>fields</COMMENTS>
    # <COMMENTS>as</COMMENTS> <COMMENTS>necessary</COMMENTS>.
    my $<CODE>jadd</CODE> = $<CODE>jbrace</CODE> - $<CODE>jparen</CODE>;
    splice( @{$<CODE>rtokens</CODE>},   0, 0, @{$<CODE>rtokens_old</CODE>}[ $<CODE>jparen</CODE> .. $<CODE>jbrace</CODE> - 1 ] );
    splice( @{$<CODE>rpatterns</CODE>}, 1, 0, @{$<CODE>rpatterns_old</CODE>}[ $<CODE>jparen</CODE> + 1 .. $<CODE>jbrace</CODE> ] );
    splice( @{$<CODE>rfields</CODE>}, 1, 0, ('') x $<CODE>jadd</CODE> );

    # <COMMENTS>force</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flush</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>case</COMMENTS>
    return $<CODE>jbrace</CODE>
      unless ( $<CODE>rfields_old</CODE>->[0] =~ /^case\s*$/ );
}

{    # <COMMENTS>sub</COMMENTS> <COMMENTS>check_match</COMMENTS>
    my %<CODE>is_good_alignment</CODE>;

    <CODE>BEGIN</CODE> {

        # <COMMENTS>Vertically</COMMENTS> <COMMENTS>aligning</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>certain</COMMENTS> "<COMMENTS>good</COMMENTS>" <COMMENTS>tokens</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>okay</COMMENTS>
        # <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>less</COMMENTS> <COMMENTS>restrictive</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>marginal</COMMENTS> <COMMENTS>cases</COMMENTS>.
        @<CODE>_</CODE> = qw( { ? => = );
        push @<CODE>_</CODE>, (',');
        @<CODE>is_good_alignment</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);
    }

    sub <CODE>check_match</CODE> {

        # <COMMENTS>See</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>matches</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>vertical</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>group</COMMENTS>.
        # <COMMENTS>If</COMMENTS> <COMMENTS>not</COMMENTS>, <COMMENTS>flush</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS>.
        my $<CODE>new_line</CODE> = shift;
        my $<CODE>old_line</CODE> = shift;

        # <COMMENTS>uses</COMMENTS> <COMMENTS>global</COMMENTS> <COMMENTS>variables</COMMENTS>:
        #  <COMMENTS>$previous_minimum_jmax_seen</COMMENTS>
        #  <COMMENTS>$maximum_jmax_seen</COMMENTS>
        #  <COMMENTS>$maximum_line_index</COMMENTS>
        #  <COMMENTS>$marginal_match</COMMENTS>
        my $<CODE>jmax</CODE>                = $<CODE>new_line</CODE>-><CODE>get_jmax</CODE>();
        my $<CODE>maximum_field_index</CODE> = $<CODE>old_line</CODE>-><CODE>get_jmax</CODE>();

        # <COMMENTS>flush</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>fields</COMMENTS>
        if ( $<CODE>jmax</CODE> > $<CODE>maximum_field_index</CODE> ) { goto <CODE>NO_MATCH</CODE> }

        # <COMMENTS>flush</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>monotonic</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>count</COMMENTS>
        if (
            ( $<CODE>maximum_field_index</CODE> > $<CODE>jmax</CODE> )    # <COMMENTS>this</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>few</COMMENTS> <COMMENTS>fields</COMMENTS>
            && (
                ( $<CODE>previous_minimum_jmax_seen</CODE> <
                    $<CODE>jmax</CODE> )                     # <COMMENTS>and</COMMENTS> <COMMENTS>wouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>monotonic</COMMENTS>
                || ( $<CODE>old_line</CODE>-><CODE>get_jmax_original_line</CODE>() != $<CODE>maximum_jmax_seen</CODE> )
            )
          )
        {
            goto <CODE>NO_MATCH</CODE>;
        }

        # <COMMENTS>otherwise</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>matches</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS>
        my $<CODE>jmax_original_line</CODE>      = $<CODE>new_line</CODE>-><CODE>get_jmax_original_line</CODE>();
        my $<CODE>is_hanging_side_comment</CODE> = $<CODE>new_line</CODE>-><CODE>get_is_hanging_side_comment</CODE>();
        my $<CODE>rtokens</CODE>                 = $<CODE>new_line</CODE>-><CODE>get_rtokens</CODE>();
        my $<CODE>rfields</CODE>                 = $<CODE>new_line</CODE>-><CODE>get_rfields</CODE>();
        my $<CODE>rpatterns</CODE>               = $<CODE>new_line</CODE>-><CODE>get_rpatterns</CODE>();
        my $<CODE>list_type</CODE>               = $<CODE>new_line</CODE>-><CODE>get_list_type</CODE>();

        my $<CODE>group_list_type</CODE> = $<CODE>old_line</CODE>-><CODE>get_list_type</CODE>();
        my $<CODE>old_rpatterns</CODE>   = $<CODE>old_line</CODE>-><CODE>get_rpatterns</CODE>();
        my $<CODE>old_rtokens</CODE>     = $<CODE>old_line</CODE>-><CODE>get_rtokens</CODE>();

        my $<CODE>jlimit</CODE> = $<CODE>jmax</CODE> - 1;
        if ( $<CODE>maximum_field_index</CODE> > $<CODE>jmax</CODE> ) {
            $<CODE>jlimit</CODE> = $<CODE>jmax_original_line</CODE>;
            --$<CODE>jlimit</CODE> unless ( length( $<CODE>new_line</CODE>-><CODE>get_rfields</CODE>()->[$<CODE>jmax</CODE>] ) );
        }

        # <COMMENTS>handle</COMMENTS> <COMMENTS>comma</COMMENTS>-<COMMENTS>separated</COMMENTS> <COMMENTS>lists</COMMENTS> ..
        if ( $<CODE>group_list_type</CODE> && ( $<CODE>list_type</CODE> eq $<CODE>group_list_type</CODE> ) ) {
            for my $<CODE>j</CODE> ( 0 .. $<CODE>jlimit</CODE> ) {
                my $<CODE>old_tok</CODE> = $$<CODE>old_rtokens</CODE>[$<CODE>j</CODE>];
                next unless $<CODE>old_tok</CODE>;
                my $<CODE>new_tok</CODE> = $$<CODE>rtokens</CODE>[$<CODE>j</CODE>];
                next unless $<CODE>new_tok</CODE>;

                # <COMMENTS>lists</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>match</COMMENTS> ...
                # <COMMENTS>unless</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>any</COMMENTS> '=>'<COMMENTS>s</COMMENTS> <COMMENTS>with</COMMENTS> ','<COMMENTS>s</COMMENTS>
                goto <CODE>NO_MATCH</CODE>
                  if ( $<CODE>old_tok</CODE> =~ /^=>/ && $<CODE>new_tok</CODE> =~ /^,/
                    || $<CODE>new_tok</CODE> =~ /^=>/ && $<CODE>old_tok</CODE> =~ /^,/ );
            }
        }

        # <COMMENTS>do</COMMENTS> <COMMENTS>detailed</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>everything</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>hanging</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>
        elsif ( !$<CODE>is_hanging_side_comment</CODE> ) {

            my $<CODE>leading_space_count</CODE> = $<CODE>new_line</CODE>-><CODE>get_leading_space_count</CODE>();

            my $<CODE>max_pad</CODE> = 0;
            my $<CODE>min_pad</CODE> = 0;
            my $<CODE>saw_good_alignment</CODE>;

            for my $<CODE>j</CODE> ( 0 .. $<CODE>jlimit</CODE> ) {

                my $<CODE>old_tok</CODE> = $$<CODE>old_rtokens</CODE>[$<CODE>j</CODE>];
                my $<CODE>new_tok</CODE> = $$<CODE>rtokens</CODE>[$<CODE>j</CODE>];

                # <COMMENTS>Note</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>encoding</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>tokens</COMMENTS>:
                # -------------------------------------------
                # <COMMENTS>Tokens</COMMENTS> <COMMENTS>are</COMMENTS> "<COMMENTS>decorated</COMMENTS>" <COMMENTS>with</COMMENTS> <COMMENTS>information</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>help</COMMENTS>
                # <COMMENTS>prevent</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>alignments</COMMENTS>.  <COMMENTS>Consider</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>the</COMMENTS>
                # <COMMENTS>following</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS>:
                #   <COMMENTS>local</COMMENTS> ( <COMMENTS>$xn</COMMENTS>, <COMMENTS>$xd</COMMENTS> ) = <COMMENTS>split</COMMENTS>( '/', &'<COMMENTS>rnorm</COMMENTS>(@<COMMENTS>_</COMMENTS>) );
                #   <COMMENTS>local</COMMENTS> ( <COMMENTS>$i</COMMENTS>, <COMMENTS>$f</COMMENTS> ) = &'<COMMENTS>bdiv</COMMENTS>( <COMMENTS>$xn</COMMENTS>, <COMMENTS>$xd</COMMENTS> );
                # <COMMENTS>There</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>three</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>,
                # <COMMENTS>an</COMMENTS> =, <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>three</COMMENTS> <COMMENTS>tokens</COMMENTS>
                # <COMMENTS>are</COMMENTS> <COMMENTS>encoded</COMMENTS> <COMMENTS>as</COMMENTS>:
                #    ,<COMMENTS>4</COMMENTS>+<COMMENTS>local</COMMENTS>-<COMMENTS>18</COMMENTS>     =<COMMENTS>3</COMMENTS>      ,<COMMENTS>4</COMMENTS>+<COMMENTS>split</COMMENTS>-<COMMENTS>7</COMMENTS>
                # <COMMENTS>and</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>encoded</COMMENTS> <COMMENTS>as</COMMENTS>
                #    ,<COMMENTS>4</COMMENTS>+<COMMENTS>local</COMMENTS>-<COMMENTS>18</COMMENTS>     =<COMMENTS>3</COMMENTS>      ,<COMMENTS>4</COMMENTS>+&'<COMMENTS>bdiv</COMMENTS>-<COMMENTS>8</COMMENTS>
                # <COMMENTS>Tokens</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>nesting</COMMENTS>
                # <COMMENTS>depth</COMMENTS>.  <COMMENTS>So</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>the</COMMENTS> ='<COMMENTS>s</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>and</COMMENTS>
                # <COMMENTS>the</COMMENTS> ,'<COMMENTS>s</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>4</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>prevents</COMMENTS> <COMMENTS>aligning</COMMENTS> <COMMENTS>tokens</COMMENTS>
                # <COMMENTS>of</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>depths</COMMENTS>.  <COMMENTS>Commas</COMMENTS> <COMMENTS>contain</COMMENTS> <COMMENTS>additional</COMMENTS>
                # <COMMENTS>information</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>follows</COMMENTS>:
                # ,  {<COMMENTS>depth</COMMENTS>} + {<COMMENTS>container</COMMENTS> <COMMENTS>name</COMMENTS>} - {<COMMENTS>spaces</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS>}
                # <COMMENTS>This</COMMENTS> <COMMENTS>allows</COMMENTS> <COMMENTS>us</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>reject</COMMENTS> <COMMENTS>matching</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>rightmost</COMMENTS> <COMMENTS>commas</COMMENTS>
                # <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS>, <COMMENTS>since</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>different</COMMENTS>
                # <COMMENTS>function</COMMENTS> <COMMENTS>calls</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>encoding</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>in</COMMENTS>
                # '<COMMENTS>sub</COMMENTS> <COMMENTS>send_lines_to_vertical_aligner</COMMENTS>'.

                # <COMMENTS>Pick</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>token</COMMENTS>.
                # <COMMENTS>Everything</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>digit</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>token</COMMENTS>.
                my $<CODE>alignment_token</CODE> = $<CODE>new_tok</CODE>;
                if ( $<CODE>alignment_token</CODE> =~ /^([^\d]+)/ ) { $<CODE>alignment_token</CODE> = $<CODE>1</CODE> }

                # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>decorated</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>match</COMMENTS>
                my $<CODE>tokens_match</CODE> = $<CODE>new_tok</CODE> eq $<CODE>old_tok</CODE>

                  # <COMMENTS>Exception</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>matching</COMMENTS> <COMMENTS>terminal</COMMENTS> : <COMMENTS>of</COMMENTS> <COMMENTS>ternary</COMMENTS> <COMMENTS>statement</COMMENTS>..
                  # <COMMENTS>consider</COMMENTS> <COMMENTS>containers</COMMENTS> <COMMENTS>prefixed</COMMENTS> <COMMENTS>by</COMMENTS> ? <COMMENTS>and</COMMENTS> : <COMMENTS>a</COMMENTS> <COMMENTS>match</COMMENTS>
                  || ( $<CODE>new_tok</CODE> =~ /^,\d*\+\:/ && $<CODE>old_tok</CODE> =~ /^,\d*\+\?/ );

                # <COMMENTS>No</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>differ</COMMENTS>...
                if ( !$<CODE>tokens_match</CODE> ) {

                    # ...<COMMENTS>Unless</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
                    if (
                        $<CODE>j</CODE> == $<CODE>jlimit</CODE>

                        # <COMMENTS>and</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>token</COMMENTS>
                        # <COMMENTS>or</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>item</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS>.  <COMMENTS>This</COMMENTS>
                        # <COMMENTS>latter</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>required</COMMENTS> <COMMENTS>for</COMMENTS> '<COMMENTS>December</COMMENTS>' <COMMENTS>to</COMMENTS> <COMMENTS>join</COMMENTS>
                        # <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>list</COMMENTS>:
                        # <COMMENTS>my</COMMENTS> (@<COMMENTS>months</COMMENTS>) = (
                        #     '',       '<COMMENTS>January</COMMENTS>',   '<COMMENTS>February</COMMENTS>', '<COMMENTS>March</COMMENTS>',
                        #     '<COMMENTS>April</COMMENTS>',  '<COMMENTS>May</COMMENTS>',       '<COMMENTS>June</COMMENTS>',     '<COMMENTS>July</COMMENTS>',
                        #     '<COMMENTS>August</COMMENTS>', '<COMMENTS>September</COMMENTS>', '<COMMENTS>October</COMMENTS>',  '<COMMENTS>November</COMMENTS>',
                        #     '<COMMENTS>December</COMMENTS>'
                        # );
                        # <COMMENTS>If</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>formatting</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>fail</COMMENTS>.
                        && ( $<CODE>j</CODE> > 0 || $<CODE>old_tok</CODE> =~ /^,/ )
                      )
                    {
                        $<CODE>marginal_match</CODE> = 1
                          if ( $<CODE>marginal_match</CODE> == 0
                            && $<CODE>maximum_line_index</CODE> == 0 );
                        last;
                    }

                    goto <CODE>NO_MATCH</CODE>;
                }

                # <COMMENTS>Calculate</COMMENTS> <COMMENTS>amount</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>required</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>fit</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>in</COMMENTS>.
                # <COMMENTS>$pad</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>increase</COMMENTS>
                # <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>squeeze</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>field</COMMENTS>.
                my $<CODE>pad</CODE> =
                  length( $$<CODE>rfields</CODE>[$<CODE>j</CODE>] ) - $<CODE>old_line</CODE>-><CODE>current_field_width</CODE>($<CODE>j</CODE>);
                if ( $<CODE>j</CODE> == 0 ) { $<CODE>pad</CODE> += $<CODE>leading_space_count</CODE>; }

                # <COMMENTS>remember</COMMENTS> <COMMENTS>max</COMMENTS> <COMMENTS>pads</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>limit</COMMENTS> <COMMENTS>marginal</COMMENTS> <COMMENTS>cases</COMMENTS>
                if ( $<CODE>alignment_token</CODE> ne '#' ) {
                    if ( $<CODE>pad</CODE> > $<CODE>max_pad</CODE> ) { $<CODE>max_pad</CODE> = $<CODE>pad</CODE> }
                    if ( $<CODE>pad</CODE> < $<CODE>min_pad</CODE> ) { $<CODE>min_pad</CODE> = $<CODE>pad</CODE> }
                }
                if ( $<CODE>is_good_alignment</CODE>{$<CODE>alignment_token</CODE>} ) {
                    $<CODE>saw_good_alignment</CODE> = 1;
                }

                # <COMMENTS>If</COMMENTS> <COMMENTS>patterns</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>match</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>careful</COMMENTS>...
                if ( $$<CODE>old_rpatterns</CODE>[$<CODE>j</CODE>] ne $$<CODE>rpatterns</CODE>[$<CODE>j</CODE>] ) {

                    # <COMMENTS>flag</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>marginal</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>since</COMMENTS> <COMMENTS>patterns</COMMENTS> <COMMENTS>differ</COMMENTS>
                    $<CODE>marginal_match</CODE> = 1
                      if ( $<CODE>marginal_match</CODE> == 0 && $<CODE>maximum_line_index</CODE> == 0 );

                    # <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>careful</COMMENTS> <COMMENTS>about</COMMENTS> <COMMENTS>aligning</COMMENTS> <COMMENTS>commas</COMMENTS>
                    # <COMMENTS>when</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pattern</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>match</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS>
                    # <COMMENTS>worse</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>none</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>needed</COMMENTS>
                    # <COMMENTS>than</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>omit</COMMENTS> <COMMENTS>one</COMMENTS>.  <COMMENTS>Here</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>the</COMMENTS> ','<COMMENTS>s</COMMENTS>
                    # <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>named</COMMENTS> <COMMENTS>containers</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>below</COMMENTS>
                    # <COMMENTS>should</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>two</COMMENTS>:
                    #   ( <COMMENTS>$a</COMMENTS>, <COMMENTS>$b</COMMENTS> ) = ( <COMMENTS>$b</COMMENTS>, <COMMENTS>$r</COMMENTS> );
                    #   ( <COMMENTS>$x1</COMMENTS>, <COMMENTS>$x2</COMMENTS> ) = ( <COMMENTS>$x2</COMMENTS> - <COMMENTS>$q</COMMENTS> * <COMMENTS>$x1</COMMENTS>, <COMMENTS>$x1</COMMENTS> );
                    #   ( <COMMENTS>$y1</COMMENTS>, <COMMENTS>$y2</COMMENTS> ) = ( <COMMENTS>$y2</COMMENTS> - <COMMENTS>$q</COMMENTS> * <COMMENTS>$y1</COMMENTS>, <COMMENTS>$y1</COMMENTS> );
                    if ( $<CODE>alignment_token</CODE> eq ',' ) {

                       # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>commas</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>named</COMMENTS> <COMMENTS>containers</COMMENTS>
                        goto <CODE>NO_MATCH</CODE> unless ( $<CODE>new_tok</CODE> =~ /[A-Za-z]/ );
                    }

                    # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>patterns</COMMENTS> <COMMENTS>match</COMMENTS>;
                    # <COMMENTS>large</COMMENTS> <COMMENTS>ugly</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>occur</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>math</COMMENTS> <COMMENTS>expressions</COMMENTS>.
                    elsif ( $<CODE>alignment_token</CODE> eq '(' ) {

                        # <COMMENTS>But</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS>
                        # <COMMENTS>require</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>padding</COMMENTS>.
                        if ( $<CODE>pad</CODE> != 0 ) { goto <CODE>NO_MATCH</CODE> }
                    }

                    # <COMMENTS>Handle</COMMENTS> <COMMENTS>an</COMMENTS> '=' <COMMENTS>alignment</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>patterns</COMMENTS> <COMMENTS>to</COMMENTS>
                    # <COMMENTS>the</COMMENTS> <COMMENTS>left</COMMENTS>.
                    elsif ( $<CODE>alignment_token</CODE> eq '=' ) {

                        # <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>little</COMMENTS> <COMMENTS>restrictive</COMMENTS> <COMMENTS>when</COMMENTS>
                        # <COMMENTS>aligning</COMMENTS> '=' <COMMENTS>tokens</COMMENTS>.  <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>of</COMMENTS>
                        # <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>align</COMMENTS>:
                        #       <COMMENTS>my</COMMENTS> <COMMENTS>$variable</COMMENTS>=<COMMENTS>6</COMMENTS>;
                        #       <COMMENTS>$bb</COMMENTS>=<COMMENTS>4</COMMENTS>;
                        # <COMMENTS>The</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>my</COMMENTS>' <COMMENTS>declaration</COMMENTS>,
                        # <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>isn</COMMENTS>'<COMMENTS>t</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>they</COMMENTS>'<COMMENTS>re</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>similar</COMMENTS>.
                        # <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>filter</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>comparing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS>
                        # <COMMENTS>letter</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pattern</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>crude</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>works</COMMENTS>
                        # <COMMENTS>well</COMMENTS> <COMMENTS>enough</COMMENTS>.
                        if (
                            substr( $$<CODE>old_rpatterns</CODE>[$<CODE>j</CODE>], 0, 1 ) ne
                            substr( $$<CODE>rpatterns</CODE>[$<CODE>j</CODE>],     0, 1 ) )
                        {
                            goto <CODE>NO_MATCH</CODE>;
                        }

                        # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>pass</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>test</COMMENTS>, <COMMENTS>we</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>marginal</COMMENTS> <COMMENTS>match</COMMENTS>.
                        # <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>marginal</COMMENTS> <COMMENTS>match</COMMENTS>:
                        #       <COMMENTS>$done</COMMENTS>{<COMMENTS>$$op</COMMENTS>} = <COMMENTS>1</COMMENTS>;
                        #       <COMMENTS>$op</COMMENTS>         = <COMMENTS>compile_bblock</COMMENTS>(<COMMENTS>$op</COMMENTS>);
                        # <COMMENTS>The</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>identifiers</COMMENTS>, <COMMENTS>but</COMMENTS>
                        # <COMMENTS>one</COMMENTS> <COMMENTS>accesses</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS>.
                        # <COMMENTS>We</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>tentative</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>undo</COMMENTS>
                        # <COMMENTS>it</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>lines</COMMENTS>
                        # <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>group</COMMENTS>.
                        elsif ( $<CODE>maximum_line_index</CODE> == 0 ) {
                            $<CODE>marginal_match</CODE> =
                              2;    # =<COMMENTS>2</COMMENTS> <COMMENTS>prevents</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>undone</COMMENTS> <COMMENTS>below</COMMENTS>
                        }
                    }
                }

                # <COMMENTS>Don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>fewer</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>increase</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>widths</COMMENTS>
                # ( <COMMENTS>align3</COMMENTS>.<COMMENTS>t</COMMENTS> )
                if ( $<CODE>maximum_field_index</CODE> > $<CODE>jmax</CODE> ) {

                    # <COMMENTS>Exception</COMMENTS>: <COMMENTS>suspend</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>join</COMMENTS>
                    if ( $<CODE>pad</CODE> > 0 ) { goto <CODE>NO_MATCH</CODE>; }
                }
            } ## <COMMENTS>end</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>$j</COMMENTS> ( <COMMENTS>0</COMMENTS> .. <COMMENTS>$jlimit</COMMENTS>)

            # <COMMENTS>Turn</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>the</COMMENTS> "<COMMENTS>marginal</COMMENTS> <COMMENTS>match</COMMENTS>" <COMMENTS>flag</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>cases</COMMENTS>...
            # <COMMENTS>A</COMMENTS> "<COMMENTS>marginal</COMMENTS> <COMMENTS>match</COMMENTS>" <COMMENTS>occurs</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>agree</COMMENTS>
            # <COMMENTS>but</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>differences</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>tokens</COMMENTS> (<COMMENTS>patterns</COMMENTS>).
            # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>leave</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>marginal</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>set</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS>
            # <COMMENTS>will</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>group</COMMENTS>.
            # <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>turn</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>almost</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>match</COMMENTS>
            # <COMMENTS>and</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>seen</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>we</COMMENTS>
            # <COMMENTS>just</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>pad</COMMENTS> (<COMMENTS>2</COMMENTS> <COMMENTS>spaces</COMMENTS>) <COMMENTS>to</COMMENTS> <COMMENTS>fit</COMMENTS>.  <COMMENTS>These</COMMENTS> <COMMENTS>rules</COMMENTS> <COMMENTS>are</COMMENTS>
            # <COMMENTS>the</COMMENTS> <COMMENTS>result</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>experimentation</COMMENTS>.  <COMMENTS>Tokens</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>misaligned</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>just</COMMENTS>
            # <COMMENTS>one</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>annoying</COMMENTS>.  <COMMENTS>On</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>hand</COMMENTS>,
            # <COMMENTS>large</COMMENTS> <COMMENTS>gaps</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>less</COMMENTS> <COMMENTS>important</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>annoying</COMMENTS>.
            if (   $<CODE>marginal_match</CODE> == 1
                && $<CODE>jmax</CODE> == $<CODE>maximum_field_index</CODE>
                && ( $<CODE>saw_good_alignment</CODE> || ( $<CODE>max_pad</CODE> < 3 && $<CODE>min_pad</CODE> > -3 ) )
              )
            {
                $<CODE>marginal_match</CODE> = 0;
            }
            ##<COMMENTS>print</COMMENTS> "<COMMENTS>marginal</COMMENTS>=<COMMENTS>$marginal_match</COMMENTS> <COMMENTS>saw</COMMENTS>=<COMMENTS>$saw_good_alignment</COMMENTS> <COMMENTS>jmax</COMMENTS>=<COMMENTS>$jmax</COMMENTS> <COMMENTS>max</COMMENTS>=<COMMENTS>$maximum_field_index</COMMENTS> <COMMENTS>maxpad</COMMENTS>=<COMMENTS>$max_pad</COMMENTS> <COMMENTS>minpad</COMMENTS>=<COMMENTS>$min_pad</COMMENTS>\<COMMENTS>n</COMMENTS>";
        }

        # <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>match</COMMENTS> (<COMMENTS>even</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>marginal</COMMENTS>).
        # <COMMENTS>If</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>fewer</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>group</COMMENTS>
        # <COMMENTS>but</COMMENTS> <COMMENTS>otherwise</COMMENTS> <COMMENTS>matches</COMMENTS>, <COMMENTS>copy</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>remaining</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>to</COMMENTS>
        # <COMMENTS>make</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>perfect</COMMENTS> <COMMENTS>match</COMMENTS>.
        if ( $<CODE>maximum_field_index</CODE> > $<CODE>jmax</CODE> ) {
            my $<CODE>comment</CODE> = $$<CODE>rfields</CODE>[$<CODE>jmax</CODE>];
            for $<CODE>jmax</CODE> ( $<CODE>jlimit</CODE> .. $<CODE>maximum_field_index</CODE> ) {
                $$<CODE>rtokens</CODE>[$<CODE>jmax</CODE>]     = $$<CODE>old_rtokens</CODE>[$<CODE>jmax</CODE>];
                $$<CODE>rfields</CODE>[ ++$<CODE>jmax</CODE> ] = '';
                $$<CODE>rpatterns</CODE>[$<CODE>jmax</CODE>]   = $$<CODE>old_rpatterns</CODE>[$<CODE>jmax</CODE>];
            }
            $$<CODE>rfields</CODE>[$<CODE>jmax</CODE>] = $<CODE>comment</CODE>;
            $<CODE>new_line</CODE>-><CODE>set_jmax</CODE>($<CODE>jmax</CODE>);
        }
        return;

      <CODE>NO_MATCH</CODE>:
        ##<COMMENTS>print</COMMENTS> "<COMMENTS>BUBBA</COMMENTS>: <COMMENTS>no</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>jmax</COMMENTS>=<COMMENTS>$jmax</COMMENTS>  <COMMENTS>max</COMMENTS>=<COMMENTS>$maximum_field_index</COMMENTS> <COMMENTS>$group_list_type</COMMENTS> <COMMENTS>lines</COMMENTS>=<COMMENTS>$maximum_line_index</COMMENTS> <COMMENTS>token</COMMENTS>=<COMMENTS>$$old_rtokens</COMMENTS>[<COMMENTS>0</COMMENTS>]\<COMMENTS>n</COMMENTS>";
        <CODE>my_flush</CODE>();
        return;
    }
}

sub <CODE>check_fit</CODE> {

    return unless ( $<CODE>maximum_line_index</CODE> >= 0 );
    my $<CODE>new_line</CODE> = shift;
    my $<CODE>old_line</CODE> = shift;

    my $<CODE>jmax</CODE>                    = $<CODE>new_line</CODE>-><CODE>get_jmax</CODE>();
    my $<CODE>leading_space_count</CODE>     = $<CODE>new_line</CODE>-><CODE>get_leading_space_count</CODE>();
    my $<CODE>is_hanging_side_comment</CODE> = $<CODE>new_line</CODE>-><CODE>get_is_hanging_side_comment</CODE>();
    my $<CODE>rtokens</CODE>                 = $<CODE>new_line</CODE>-><CODE>get_rtokens</CODE>();
    my $<CODE>rfields</CODE>                 = $<CODE>new_line</CODE>-><CODE>get_rfields</CODE>();
    my $<CODE>rpatterns</CODE>               = $<CODE>new_line</CODE>-><CODE>get_rpatterns</CODE>();

    my $<CODE>group_list_type</CODE> = $<CODE>group_lines</CODE>[0]-><CODE>get_list_type</CODE>();

    my $<CODE>padding_so_far</CODE>    = 0;
    my $<CODE>padding_available</CODE> = $<CODE>old_line</CODE>-><CODE>get_available_space_on_right</CODE>();

    # <COMMENTS>save</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>columns</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS>
    <CODE>save_alignment_columns</CODE>();

    my ( $<CODE>j</CODE>, $<CODE>pad</CODE>, $<CODE>eight</CODE> );
    my $<CODE>maximum_field_index</CODE> = $<CODE>old_line</CODE>-><CODE>get_jmax</CODE>();
    for $<CODE>j</CODE> ( 0 .. $<CODE>jmax</CODE> ) {

        $<CODE>pad</CODE> = length( $$<CODE>rfields</CODE>[$<CODE>j</CODE>] ) - $<CODE>old_line</CODE>-><CODE>current_field_width</CODE>($<CODE>j</CODE>);

        if ( $<CODE>j</CODE> == 0 ) {
            $<CODE>pad</CODE> += $<CODE>leading_space_count</CODE>;
        }

        # <COMMENTS>remember</COMMENTS> <COMMENTS>largest</COMMENTS> <COMMENTS>gap</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>group</COMMENTS>, <COMMENTS>excluding</COMMENTS> <COMMENTS>gap</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
        if (   $<CODE>pad</CODE> < 0
            && $<CODE>group_maximum_gap</CODE> < -$<CODE>pad</CODE>
            && $<CODE>j</CODE> > 0
            && $<CODE>j</CODE> < $<CODE>jmax</CODE> - 1 )
        {
            $<CODE>group_maximum_gap</CODE> = -$<CODE>pad</CODE>;
        }

        next if $<CODE>pad</CODE> < 0;

        ## <COMMENTS>This</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>helps</COMMENTS> <COMMENTS>sometimes</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS>
        ## <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>needs</COMMENTS>
        ## <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>reworked</COMMENTS>.
        ##<COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>push</COMMENTS>
        ##<COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>out</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>group</COMMENTS>.  (<COMMENTS>sidecmt1</COMMENTS>.<COMMENTS>t</COMMENTS>)
        ##<COMMENTS>next</COMMENTS> <COMMENTS>if</COMMENTS> (<COMMENTS>$j</COMMENTS>==<COMMENTS>$jmax</COMMENTS>-<COMMENTS>1</COMMENTS> && <COMMENTS>length</COMMENTS>(<COMMENTS>$$rfields</COMMENTS>[<COMMENTS>$jmax</COMMENTS>])==<COMMENTS>0</COMMENTS>);

        # <COMMENTS>This</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>space</COMMENTS>; <COMMENTS>lets</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>accept</COMMENTS> <COMMENTS>it</COMMENTS>..
        if (

            # <COMMENTS>not</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>won</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>fit</COMMENTS>
            ( $<CODE>pad</CODE> > $<CODE>padding_available</CODE> )

            # <COMMENTS>previously</COMMENTS>, <COMMENTS>there</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>upper</COMMENTS> <COMMENTS>bounds</COMMENTS> <COMMENTS>placed</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>here</COMMENTS>
            # (<COMMENTS>maximum_whitespace_columns</COMMENTS>), <COMMENTS>but</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>helpful</COMMENTS>

          )
        {

            # <COMMENTS>revert</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>state</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>flush</COMMENTS>; <COMMENTS>things</COMMENTS> <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>out</COMMENTS>
            <CODE>restore_alignment_columns</CODE>();
            <CODE>my_flush</CODE>();
            last;
        }

        # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>excessive</COMMENTS> <COMMENTS>gaps</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>lines</COMMENTS>,
        # <COMMENTS>due</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>fewer</COMMENTS> <COMMENTS>fields</COMMENTS>.
        #   <COMMENTS>return</COMMENTS> <COMMENTS>join</COMMENTS>( ".",
        #       <COMMENTS>$self</COMMENTS>->{"<COMMENTS>dfi</COMMENTS>"},  <COMMENTS>$self</COMMENTS>->{"<COMMENTS>aa</COMMENTS>"}, <COMMENTS>$self</COMMENTS>-><COMMENTS>rsvd</COMMENTS>,     <COMMENTS>$self</COMMENTS>->{"<COMMENTS>rd</COMMENTS>"},
        #       <COMMENTS>$self</COMMENTS>->{"<COMMENTS>area</COMMENTS>"}, <COMMENTS>$self</COMMENTS>->{"<COMMENTS>id</COMMENTS>"}, <COMMENTS>$self</COMMENTS>->{"<COMMENTS>sel</COMMENTS>"} );
        next if ( $<CODE>jmax</CODE> < $<CODE>maximum_field_index</CODE> && $<CODE>j</CODE> == $<CODE>jmax</CODE> - 1 );

        # <COMMENTS>looks</COMMENTS> <COMMENTS>ok</COMMENTS>, <COMMENTS>squeeze</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>in</COMMENTS>
        $<CODE>old_line</CODE>-><CODE>increase_field_width</CODE>( $<CODE>j</CODE>, $<CODE>pad</CODE> );
        $<CODE>padding_available</CODE> -= $<CODE>pad</CODE>;

        # <COMMENTS>remember</COMMENTS> <COMMENTS>largest</COMMENTS> <COMMENTS>gap</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>group</COMMENTS>, <COMMENTS>excluding</COMMENTS> <COMMENTS>gap</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
        if ( $<CODE>pad</CODE> > $<CODE>group_maximum_gap</CODE> && $<CODE>j</CODE> > 0 && $<CODE>j</CODE> < $<CODE>jmax</CODE> - 1 ) {
            $<CODE>group_maximum_gap</CODE> = $<CODE>pad</CODE>;
        }
    }
}

sub <CODE>add_to_group</CODE> {

    # <COMMENTS>The</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>starts</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>is</COMMENTS>
    # <COMMENTS>accepted</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>group</COMMENTS>.
    my $<CODE>new_line</CODE> = shift;
    $<CODE>group_lines</CODE>[ ++$<CODE>maximum_line_index</CODE> ] = $<CODE>new_line</CODE>;

    # <COMMENTS>initialize</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>lengths</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>group</COMMENTS>
    if ( $<CODE>maximum_line_index</CODE> == 0 ) {

        my $<CODE>jmax</CODE>    = $<CODE>new_line</CODE>-><CODE>get_jmax</CODE>();
        my $<CODE>rfields</CODE> = $<CODE>new_line</CODE>-><CODE>get_rfields</CODE>();
        my $<CODE>rtokens</CODE> = $<CODE>new_line</CODE>-><CODE>get_rtokens</CODE>();
        my $<CODE>j</CODE>;
        my $<CODE>col</CODE> = $<CODE>new_line</CODE>-><CODE>get_leading_space_count</CODE>();

        for $<CODE>j</CODE> ( 0 .. $<CODE>jmax</CODE> ) {
            $<CODE>col</CODE> += length( $$<CODE>rfields</CODE>[$<CODE>j</CODE>] );

            # <COMMENTS>create</COMMENTS> <COMMENTS>initial</COMMENTS> <COMMENTS>alignments</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>group</COMMENTS>
            my $<CODE>token</CODE> = "";
            if ( $<CODE>j</CODE> < $<CODE>jmax</CODE> ) { $<CODE>token</CODE> = $$<CODE>rtokens</CODE>[$<CODE>j</CODE>] }
            my $<CODE>alignment</CODE> = <CODE>make_alignment</CODE>( $<CODE>col</CODE>, $<CODE>token</CODE> );
            $<CODE>new_line</CODE>-><CODE>set_alignment</CODE>( $<CODE>j</CODE>, $<CODE>alignment</CODE> );
        }

        $<CODE>maximum_jmax_seen</CODE> = $<CODE>jmax</CODE>;
        $<CODE>minimum_jmax_seen</CODE> = $<CODE>jmax</CODE>;
    }

    # <COMMENTS>use</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>alignments</COMMENTS> <COMMENTS>otherwise</COMMENTS>
    else {
        my @<CODE>new_alignments</CODE> =
          $<CODE>group_lines</CODE>[ $<CODE>maximum_line_index</CODE> - 1 ]-><CODE>get_alignments</CODE>();
        $<CODE>new_line</CODE>-><CODE>set_alignments</CODE>(@<CODE>new_alignments</CODE>);
    }

    # <COMMENTS>remember</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>jmax</COMMENTS> <COMMENTS>extremes</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>valign_input</COMMENTS>
    $<CODE>previous_minimum_jmax_seen</CODE> = $<CODE>minimum_jmax_seen</CODE>;
    $<CODE>previous_maximum_jmax_seen</CODE> = $<CODE>maximum_jmax_seen</CODE>;
}

sub <CODE>dump_array</CODE> {

    # <COMMENTS>debug</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>dump</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>contents</COMMENTS>
    local $" = ')(';
    print <CODE>STDOUT</CODE> "(@<CODE>_</CODE>)\n";
}

# <COMMENTS>flush</COMMENTS>() <COMMENTS>sends</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>VerticalAligner</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>down</COMMENTS> <COMMENTS>the</COMMENTS>
# <COMMENTS>pipeline</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>FileWriter</COMMENTS>.

# <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>external</COMMENTS> <COMMENTS>flush</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>empties</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>buffer</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>cache</COMMENTS>
sub <CODE>flush</CODE> {

    # <COMMENTS>the</COMMENTS> <COMMENTS>buffer</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>emptied</COMMENTS> <COMMENTS>first</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>cached</COMMENTS> <COMMENTS>text</COMMENTS>
    <CODE>dump_valign_buffer</CODE>();

    if ( $<CODE>maximum_line_index</CODE> < 0 ) {
        if ($<CODE>cached_line_type</CODE>) {
            $<CODE>seqno_string</CODE> = $<CODE>cached_seqno_string</CODE>;
            <CODE>valign_output_step_C</CODE>( $<CODE>cached_line_text</CODE>,
                $<CODE>cached_line_leading_space_count</CODE>,
                $<CODE>last_level_written</CODE> );
            $<CODE>cached_line_type</CODE>    = 0;
            $<CODE>cached_line_text</CODE>    = "";
            $<CODE>cached_seqno_string</CODE> = "";
        }
    }
    else {
        <CODE>my_flush</CODE>();
    }
}

sub <CODE>reduce_valign_buffer_indentation</CODE> {

    my ($<CODE>diff</CODE>) = @<CODE>_</CODE>;
    if ( $<CODE>valign_buffer_filling</CODE> && $<CODE>diff</CODE> ) {
        my $<CODE>max_valign_buffer</CODE> = @<CODE>valign_buffer</CODE>;
        for ( my $<CODE>i</CODE> = 0 ; $<CODE>i</CODE> < $<CODE>max_valign_buffer</CODE> ; $<CODE>i</CODE>++ ) {
            my ( $<CODE>line</CODE>, $<CODE>leading_space_count</CODE>, $<CODE>level</CODE> ) =
              @{ $<CODE>valign_buffer</CODE>[$<CODE>i</CODE>] };
            my $<CODE>ws</CODE> = substr( $<CODE>line</CODE>, 0, $<CODE>diff</CODE> );
            if ( ( length($<CODE>ws</CODE>) == $<CODE>diff</CODE> ) && $<CODE>ws</CODE> =~ /^\s+$/ ) {
                $<CODE>line</CODE> = substr( $<CODE>line</CODE>, $<CODE>diff</CODE> );
            }
            if ( $<CODE>leading_space_count</CODE> >= $<CODE>diff</CODE> ) {
                $<CODE>leading_space_count</CODE> -= $<CODE>diff</CODE>;
                $<CODE>level</CODE> = <CODE>level_change</CODE>( $<CODE>leading_space_count</CODE>, $<CODE>diff</CODE>, $<CODE>level</CODE> );
            }
            $<CODE>valign_buffer</CODE>[$<CODE>i</CODE>] = [ $<CODE>line</CODE>, $<CODE>leading_space_count</CODE>, $<CODE>level</CODE> ];
        }
    }
}

sub <CODE>level_change</CODE> {

    # <COMMENTS>compute</COMMENTS> <COMMENTS>decrease</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>$diff</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>leading</COMMENTS> <COMMENTS>spaces</COMMENTS>
    my ( $<CODE>leading_space_count</CODE>, $<CODE>diff</CODE>, $<CODE>level</CODE> ) = @<CODE>_</CODE>;
    if ($<CODE>rOpts_indent_columns</CODE>) {
        my $<CODE>olev</CODE> =
          int( ( $<CODE>leading_space_count</CODE> + $<CODE>diff</CODE> ) / $<CODE>rOpts_indent_columns</CODE> );
        my $<CODE>nlev</CODE> = int( $<CODE>leading_space_count</CODE> / $<CODE>rOpts_indent_columns</CODE> );
        $<CODE>level</CODE> -= ( $<CODE>olev</CODE> - $<CODE>nlev</CODE> );
        if ( $<CODE>level</CODE> < 0 ) { $<CODE>level</CODE> = 0 }
    }
    return $<CODE>level</CODE>;
}

sub <CODE>dump_valign_buffer</CODE> {
    if (@<CODE>valign_buffer</CODE>) {
        foreach (@<CODE>valign_buffer</CODE>) {
            <CODE>valign_output_step_D</CODE>( @{$<CODE>_</CODE>} );
        }
        @<CODE>valign_buffer</CODE> = ();
    }
    $<CODE>valign_buffer_filling</CODE> = "";
}

# <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>internal</COMMENTS> <COMMENTS>flush</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>leaves</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>cache</COMMENTS> <COMMENTS>intact</COMMENTS>
sub <CODE>my_flush</CODE> {

    return if ( $<CODE>maximum_line_index</CODE> < 0 );

    # <COMMENTS>handle</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>lines</COMMENTS>
    if ( $<CODE>group_type</CODE> eq '<LITERALS>COMMENT</LITERALS>' ) {

        <CODE>VALIGN_DEBUG_FLAG_APPEND0</CODE> && do {
            my ( $<CODE>a</CODE>, $<CODE>b</CODE>, $<CODE>c</CODE> ) = caller();
            print <CODE>STDOUT</CODE>
"<LITERALS>APPEND0</LITERALS>: <LITERALS>Flush</LITERALS> <LITERALS>called</LITERALS> <LITERALS>from</LITERALS> $<CODE>a</CODE> $<CODE>b</CODE> $<CODE>c</CODE> <LITERALS>for</LITERALS> <LITERALS>COMMENT</LITERALS> <LITERALS>group</LITERALS>: <LITERALS>lines</LITERALS>=$<CODE>maximum_line_index</CODE> \n";

        };
        my $<CODE>leading_space_count</CODE> = $<CODE>comment_leading_space_count</CODE>;
        my $<CODE>leading_string</CODE>      = <CODE>get_leading_string</CODE>($<CODE>leading_space_count</CODE>);

        # <COMMENTS>zero</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>long</COMMENTS>
        my $<CODE>max_excess</CODE> = 0;
        for my $<CODE>i</CODE> ( 0 .. $<CODE>maximum_line_index</CODE> ) {
            my $<CODE>str</CODE> = $<CODE>group_lines</CODE>[$<CODE>i</CODE>];
            my $<CODE>excess</CODE> =
              length($<CODE>str</CODE>) +
              $<CODE>leading_space_count</CODE> -
              <CODE>maximum_line_length_for_level</CODE>($<CODE>group_level</CODE>);
            if ( $<CODE>excess</CODE> > $<CODE>max_excess</CODE> ) {
                $<CODE>max_excess</CODE> = $<CODE>excess</CODE>;
            }
        }

        if ( $<CODE>max_excess</CODE> > 0 ) {
            $<CODE>leading_space_count</CODE> -= $<CODE>max_excess</CODE>;
            if ( $<CODE>leading_space_count</CODE> < 0 ) { $<CODE>leading_space_count</CODE> = 0 }
            $<CODE>last_outdented_line_at</CODE> =
              $<CODE>file_writer_object</CODE>-><CODE>get_output_line_number</CODE>();
            unless ($<CODE>outdented_line_count</CODE>) {
                $<CODE>first_outdented_line_at</CODE> = $<CODE>last_outdented_line_at</CODE>;
            }
            $<CODE>outdented_line_count</CODE> += ( $<CODE>maximum_line_index</CODE> + 1 );
        }

        # <COMMENTS>write</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS>
        my $<CODE>outdent_long_lines</CODE> = 0;
        for my $<CODE>i</CODE> ( 0 .. $<CODE>maximum_line_index</CODE> ) {
            <CODE>valign_output_step_B</CODE>( $<CODE>leading_space_count</CODE>, $<CODE>group_lines</CODE>[$<CODE>i</CODE>], 0,
                $<CODE>outdent_long_lines</CODE>, "", $<CODE>group_level</CODE> );
        }
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>lines</COMMENTS>
    else {

        <CODE>VALIGN_DEBUG_FLAG_APPEND0</CODE> && do {
            my $<CODE>group_list_type</CODE> = $<CODE>group_lines</CODE>[0]-><CODE>get_list_type</CODE>();
            my ( $<CODE>a</CODE>, $<CODE>b</CODE>, $<CODE>c</CODE> ) = caller();
            my $<CODE>maximum_field_index</CODE> = $<CODE>group_lines</CODE>[0]-><CODE>get_jmax</CODE>();
            print <CODE>STDOUT</CODE>
"<LITERALS>APPEND0</LITERALS>: <LITERALS>Flush</LITERALS> <LITERALS>called</LITERALS> <LITERALS>from</LITERALS> $<CODE>a</CODE> $<CODE>b</CODE> $<CODE>c</CODE> <LITERALS>fields</LITERALS>=$<CODE>maximum_field_index</CODE> <LITERALS>list</LITERALS>=$<CODE>group_list_type</CODE> <LITERALS>lines</LITERALS>=$<CODE>maximum_line_index</CODE> <LITERALS>extra</LITERALS>=$<CODE>extra_indent_ok</CODE>\n";

        };

        # <COMMENTS>some</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>groups</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>unaligned</COMMENTS>
        my $<CODE>do_not_align</CODE> = <CODE>decide_if_aligned</CODE>();

        # <COMMENTS>optimize</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>location</COMMENTS>
        $<CODE>do_not_align</CODE> = <CODE>adjust_side_comment</CODE>($<CODE>do_not_align</CODE>);

        # <COMMENTS>recover</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>for</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>possible</COMMENTS>
        my $<CODE>extra_leading_spaces</CODE> = <CODE>get_extra_leading_spaces</CODE>();

        # <COMMENTS>all</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>basic</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>spacing</COMMENTS>
        my $<CODE>group_leader_length</CODE> = $<CODE>group_lines</CODE>[0]-><CODE>get_leading_space_count</CODE>();

        # <COMMENTS>add</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>helpful</COMMENTS>
        my $<CODE>min_ci_gap</CODE> = <CODE>improve_continuation_indentation</CODE>( $<CODE>do_not_align</CODE>,
            $<CODE>group_leader_length</CODE> );

        # <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>lines</COMMENTS>
        for my $<CODE>i</CODE> ( 0 .. $<CODE>maximum_line_index</CODE> ) {
            my $<CODE>line</CODE> = $<CODE>group_lines</CODE>[$<CODE>i</CODE>];
            <CODE>valign_output_step_A</CODE>( $<CODE>line</CODE>, $<CODE>min_ci_gap</CODE>, $<CODE>do_not_align</CODE>,
                $<CODE>group_leader_length</CODE>, $<CODE>extra_leading_spaces</CODE> );
        }
    }
    <CODE>initialize_for_new_group</CODE>();
}

sub <CODE>decide_if_aligned</CODE> {

    # <COMMENTS>Do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>similar</COMMENTS>
    return unless $<CODE>maximum_line_index</CODE> == 1;
    return if ($<CODE>is_matching_terminal_line</CODE>);

    my $<CODE>group_list_type</CODE> = $<CODE>group_lines</CODE>[0]-><CODE>get_list_type</CODE>();

    my $<CODE>do_not_align</CODE> = (

        # <COMMENTS>always</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>lists</COMMENTS>
        !$<CODE>group_list_type</CODE>

          && (

            # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>marginal</COMMENTS> <COMMENTS>match</COMMENTS>
            $<CODE>marginal_match</CODE>

            # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>align</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>big</COMMENTS> <COMMENTS>gap</COMMENTS>
            || $<CODE>group_maximum_gap</CODE> > 12

            # <COMMENTS>or</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>differing</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>tokens</COMMENTS>
            # <COMMENTS>TODO</COMMENTS>: <COMMENTS>this</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>improved</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>occasionally</COMMENTS> <COMMENTS>rejects</COMMENTS>
            # <COMMENTS>good</COMMENTS> <COMMENTS>matches</COMMENTS>.
            || $<CODE>previous_maximum_jmax_seen</CODE> != $<CODE>previous_minimum_jmax_seen</CODE>
          )
    );

    # <COMMENTS>But</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>convert</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>group</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS>
    # <COMMENTS>a</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
    my $<CODE>rfields</CODE>             = $<CODE>group_lines</CODE>[0]-><CODE>get_rfields</CODE>();
    my $<CODE>maximum_field_index</CODE> = $<CODE>group_lines</CODE>[0]-><CODE>get_jmax</CODE>();
    if (   $<CODE>do_not_align</CODE>
        && ( $<CODE>maximum_line_index</CODE> > 0 )
        && ( length( $$<CODE>rfields</CODE>[$<CODE>maximum_field_index</CODE>] ) > 0 ) )
    {
        <CODE>combine_fields</CODE>();
        $<CODE>do_not_align</CODE> = 0;
    }
    return $<CODE>do_not_align</CODE>;
}

sub <CODE>adjust_side_comment</CODE> {

    my $<CODE>do_not_align</CODE> = shift;

    # <COMMENTS>let</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>move</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>little</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>improve</COMMENTS> <COMMENTS>readability</COMMENTS> (<COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>field</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>field</COMMENTS>)
    my $<CODE>have_side_comment</CODE>       = 0;
    my $<CODE>first_side_comment_line</CODE> = -1;
    my $<CODE>maximum_field_index</CODE>     = $<CODE>group_lines</CODE>[0]-><CODE>get_jmax</CODE>();
    for my $<CODE>i</CODE> ( 0 .. $<CODE>maximum_line_index</CODE> ) {
        my $<CODE>line</CODE> = $<CODE>group_lines</CODE>[$<CODE>i</CODE>];

        if ( length( $<CODE>line</CODE>-><CODE>get_rfields</CODE>()->[$<CODE>maximum_field_index</CODE>] ) ) {
            $<CODE>have_side_comment</CODE>       = 1;
            $<CODE>first_side_comment_line</CODE> = $<CODE>i</CODE>;
            last;
        }
    }

    my $<CODE>kmax</CODE> = $<CODE>maximum_field_index</CODE> + 1;

    if ($<CODE>have_side_comment</CODE>) {

        my $<CODE>line</CODE> = $<CODE>group_lines</CODE>[0];

        # <COMMENTS>the</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>exceeding</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>:
        my $<CODE>avail</CODE> = $<CODE>line</CODE>-><CODE>get_available_space_on_right</CODE>();

        # <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>column</COMMENTS>
        my $<CODE>side_comment_column</CODE> = $<CODE>line</CODE>-><CODE>get_column</CODE>( $<CODE>kmax</CODE> - 2 );
        my $<CODE>move</CODE>                = $<CODE>last_comment_column</CODE> - $<CODE>side_comment_column</CODE>;

##        <COMMENTS>my</COMMENTS> <COMMENTS>$sc_line0</COMMENTS> = <COMMENTS>$side_comment_history</COMMENTS>[<COMMENTS>0</COMMENTS>]->[<COMMENTS>0</COMMENTS>];
##        <COMMENTS>my</COMMENTS> <COMMENTS>$sc_col0</COMMENTS>  = <COMMENTS>$side_comment_history</COMMENTS>[<COMMENTS>0</COMMENTS>]->[<COMMENTS>1</COMMENTS>];
##        <COMMENTS>my</COMMENTS> <COMMENTS>$sc_line1</COMMENTS> = <COMMENTS>$side_comment_history</COMMENTS>[<COMMENTS>1</COMMENTS>]->[<COMMENTS>0</COMMENTS>];
##        <COMMENTS>my</COMMENTS> <COMMENTS>$sc_col1</COMMENTS>  = <COMMENTS>$side_comment_history</COMMENTS>[<COMMENTS>1</COMMENTS>]->[<COMMENTS>1</COMMENTS>];
##        <COMMENTS>my</COMMENTS> <COMMENTS>$sc_line2</COMMENTS> = <COMMENTS>$side_comment_history</COMMENTS>[<COMMENTS>2</COMMENTS>]->[<COMMENTS>0</COMMENTS>];
##        <COMMENTS>my</COMMENTS> <COMMENTS>$sc_col2</COMMENTS>  = <COMMENTS>$side_comment_history</COMMENTS>[<COMMENTS>2</COMMENTS>]->[<COMMENTS>1</COMMENTS>];
##
##        # <COMMENTS>FUTURE</COMMENTS> <COMMENTS>UPDATES</COMMENTS>:
##        # <COMMENTS>Be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>ignore</COMMENTS> '<COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>align</COMMENTS>' <COMMENTS>and</COMMENTS>  '} # <COMMENTS>end</COMMENTS> <COMMENTS>comments</COMMENTS>'
##        # <COMMENTS>Find</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>$move</COMMENTS> > <COMMENTS>0</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>$move</COMMENTS> <= <COMMENTS>$avail</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>follows</COMMENTS>:
##        # <COMMENTS>1</COMMENTS>. <COMMENTS>try</COMMENTS> <COMMENTS>sc_col1</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>sc_col1</COMMENTS> == <COMMENTS>sc_col0</COMMENTS> && (<COMMENTS>line</COMMENTS>-<COMMENTS>sc_line0</COMMENTS>) < <COMMENTS>12</COMMENTS>
##        # <COMMENTS>2</COMMENTS>. <COMMENTS>try</COMMENTS> <COMMENTS>sc_col2</COMMENTS> <COMMENTS>if</COMMENTS> (<COMMENTS>line</COMMENTS>-<COMMENTS>sc_line2</COMMENTS>) < <COMMENTS>12</COMMENTS>
##        # <COMMENTS>3</COMMENTS>. <COMMENTS>try</COMMENTS> <COMMENTS>min</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>space</COMMENTS>, <COMMENTS>plus</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>8</COMMENTS>,
##        # <COMMENTS>4</COMMENTS>. <COMMENTS>try</COMMENTS> <COMMENTS>min</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>space</COMMENTS>

        if ( $<CODE>kmax</CODE> > 0 && !$<CODE>do_not_align</CODE> ) {

            # <COMMENTS>but</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS>, <COMMENTS>give</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>minimum</COMMENTS> <COMMENTS>space</COMMENTS>
            if ( $<CODE>move</CODE> > $<CODE>avail</CODE> ) {
                $<CODE>move</CODE> = $<CODE>rOpts_minimum_space_to_comment</CODE> - 1;
            }

            # <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>minimum</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>comment</COMMENTS>
            my $<CODE>min_move</CODE> = $<CODE>rOpts_minimum_space_to_comment</CODE> - 1;
            if (   $<CODE>move</CODE> >= 0
                && $<CODE>last_side_comment_length</CODE> > 0
                && ( $<CODE>first_side_comment_line</CODE> == 0 )
                && $<CODE>group_level</CODE> == $<CODE>last_level_written</CODE> )
            {
                $<CODE>min_move</CODE> = 0;
            }

            if ( $<CODE>move</CODE> < $<CODE>min_move</CODE> ) {
                $<CODE>move</CODE> = $<CODE>min_move</CODE>;
            }

            # <COMMENTS>previously</COMMENTS>, <COMMENTS>an</COMMENTS> <COMMENTS>upper</COMMENTS> <COMMENTS>bound</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>placed</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>$move</COMMENTS> <COMMENTS>here</COMMENTS>,
            # (<COMMENTS>maximum_space_to_comment</COMMENTS>), <COMMENTS>but</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>helpful</COMMENTS>

            # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>exceed</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>available</COMMENTS> <COMMENTS>space</COMMENTS>
            if ( $<CODE>move</CODE> > $<CODE>avail</CODE> ) { $<CODE>move</CODE> = $<CODE>avail</CODE> }

            # <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>increase</COMMENTS> <COMMENTS>space</COMMENTS>, <COMMENTS>never</COMMENTS> <COMMENTS>decrease</COMMENTS>
            if ( $<CODE>move</CODE> > 0 ) {
                $<CODE>line</CODE>-><CODE>increase_field_width</CODE>( $<CODE>maximum_field_index</CODE> - 1, $<CODE>move</CODE> );
            }

            # <COMMENTS>remember</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>group</COMMENTS>
            $<CODE>last_comment_column</CODE> = $<CODE>line</CODE>-><CODE>get_column</CODE>( $<CODE>kmax</CODE> - 2 );
        }
        else {

            # <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>existing</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>location</COMMENTS>
            if ( $<CODE>kmax</CODE> > 0 && $<CODE>move</CODE> > 0 && $<CODE>move</CODE> < $<CODE>avail</CODE> ) {
                $<CODE>line</CODE>-><CODE>increase_field_width</CODE>( $<CODE>maximum_field_index</CODE> - 1, $<CODE>move</CODE> );
                $<CODE>do_not_align</CODE> = 0;
            }

            # <COMMENTS>reset</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>column</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>align</COMMENTS>
            else {
                <CODE>forget_side_comment</CODE>();
            }
        }
    }
    return $<CODE>do_not_align</CODE>;
}

sub <CODE>improve_continuation_indentation</CODE> {
    my ( $<CODE>do_not_align</CODE>, $<CODE>group_leader_length</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>See</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>increase</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>move</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>closer</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>field</COMMENTS>
    # (<COMMENTS>unless</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comment</COMMENTS>).
    #
    # '<COMMENTS>$min_ci_gap</COMMENTS>'<COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>introduce</COMMENTS>.
    # <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>introduce</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>ci</COMMENTS>.
    # <COMMENTS>Without</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>variable</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>occasionally</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>
    # (<COMMENTS>Complex</COMMENTS>.<COMMENTS>pm</COMMENTS>):
    #
    # <COMMENTS>use</COMMENTS> <COMMENTS>overload</COMMENTS> '+' => \&<COMMENTS>plus</COMMENTS>,
    #   '-'            => \&<COMMENTS>minus</COMMENTS>,
    #   '*'            => \&<COMMENTS>multiply</COMMENTS>,
    #   ...
    #   '<COMMENTS>tan</COMMENTS>'          => \&<COMMENTS>tan</COMMENTS>,
    #   '<COMMENTS>atan2</COMMENTS>'        => \&<COMMENTS>atan2</COMMENTS>,
    #
    # <COMMENTS>Whereas</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>variable</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>shift</COMMENTS> <COMMENTS>variables</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>this</COMMENTS>:
    #
    # <COMMENTS>use</COMMENTS> <COMMENTS>overload</COMMENTS> '+' => \&<COMMENTS>plus</COMMENTS>,
    #          '-'     => \&<COMMENTS>minus</COMMENTS>,
    #          '*'     => \&<COMMENTS>multiply</COMMENTS>,
    #          ...
    #          '<COMMENTS>tan</COMMENTS>'   => \&<COMMENTS>tan</COMMENTS>,
    #          '<COMMENTS>atan2</COMMENTS>' => \&<COMMENTS>atan2</COMMENTS>,

    ## <COMMENTS>Deactivated</COMMENTS>####################
    # <COMMENTS>The</COMMENTS> <COMMENTS>trouble</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>patch</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>may</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>,
    # <COMMENTS>move</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>some</COMMENTS> '<COMMENTS>or</COMMENTS>'<COMMENTS>s</COMMENTS>  <COMMENTS>or</COMMENTS> ':'<COMMENTS>s</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>leave</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>out</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>left</COMMENTS> <COMMENTS>edge</COMMENTS> <COMMENTS>alignment</COMMENTS> <COMMENTS>suffers</COMMENTS>.
    return 0;
    ###########################################

    my $<CODE>maximum_field_index</CODE> = $<CODE>group_lines</CODE>[0]-><CODE>get_jmax</CODE>();

    my $<CODE>min_ci_gap</CODE> = <CODE>maximum_line_length_for_level</CODE>($<CODE>group_level</CODE>);
    if ( $<CODE>maximum_field_index</CODE> > 1 && !$<CODE>do_not_align</CODE> ) {

        for my $<CODE>i</CODE> ( 0 .. $<CODE>maximum_line_index</CODE> ) {
            my $<CODE>line</CODE>                = $<CODE>group_lines</CODE>[$<CODE>i</CODE>];
            my $<CODE>leading_space_count</CODE> = $<CODE>line</CODE>-><CODE>get_leading_space_count</CODE>();
            my $<CODE>rfields</CODE>             = $<CODE>line</CODE>-><CODE>get_rfields</CODE>();

            my $<CODE>gap</CODE> =
              $<CODE>line</CODE>-><CODE>get_column</CODE>(0) -
              $<CODE>leading_space_count</CODE> -
              length( $$<CODE>rfields</CODE>[0] );

            if ( $<CODE>leading_space_count</CODE> > $<CODE>group_leader_length</CODE> ) {
                if ( $<CODE>gap</CODE> < $<CODE>min_ci_gap</CODE> ) { $<CODE>min_ci_gap</CODE> = $<CODE>gap</CODE> }
            }
        }

        if ( $<CODE>min_ci_gap</CODE> >= <CODE>maximum_line_length_for_level</CODE>($<CODE>group_level</CODE>) ) {
            $<CODE>min_ci_gap</CODE> = 0;
        }
    }
    else {
        $<CODE>min_ci_gap</CODE> = 0;
    }
    return $<CODE>min_ci_gap</CODE>;
}

sub <CODE>valign_output_step_A</CODE> {

    ###############################################################
    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>Step</COMMENTS> <COMMENTS>A</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>writing</COMMENTS> <COMMENTS>vertically</COMMENTS> <COMMENTS>aligned</COMMENTS> <COMMENTS>lines</COMMENTS>.
    # <COMMENTS>The</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>prepared</COMMENTS> <COMMENTS>according</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>alignments</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>have</COMMENTS>
    # <COMMENTS>been</COMMENTS> <COMMENTS>found</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>shipped</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>step</COMMENTS>.
    ###############################################################

    my ( $<CODE>line</CODE>, $<CODE>min_ci_gap</CODE>, $<CODE>do_not_align</CODE>, $<CODE>group_leader_length</CODE>,
        $<CODE>extra_leading_spaces</CODE> )
      = @<CODE>_</CODE>;
    my $<CODE>rfields</CODE>                   = $<CODE>line</CODE>-><CODE>get_rfields</CODE>();
    my $<CODE>leading_space_count</CODE>       = $<CODE>line</CODE>-><CODE>get_leading_space_count</CODE>();
    my $<CODE>outdent_long_lines</CODE>        = $<CODE>line</CODE>-><CODE>get_outdent_long_lines</CODE>();
    my $<CODE>maximum_field_index</CODE>       = $<CODE>line</CODE>-><CODE>get_jmax</CODE>();
    my $<CODE>rvertical_tightness_flags</CODE> = $<CODE>line</CODE>-><CODE>get_rvertical_tightness_flags</CODE>();

    # <COMMENTS>add</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>spaces</COMMENTS>
    if ( $<CODE>leading_space_count</CODE> > $<CODE>group_leader_length</CODE> ) {
        $<CODE>leading_space_count</CODE> += $<CODE>min_ci_gap</CODE>;
    }

    my $<CODE>str</CODE> = $$<CODE>rfields</CODE>[0];

    # <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>concatenate</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>padding</COMMENTS>
    my $<CODE>total_pad_count</CODE> = 0;
    my ( $<CODE>j</CODE>, $<CODE>pad</CODE> );
    for $<CODE>j</CODE> ( 1 .. $<CODE>maximum_field_index</CODE> ) {

        # <COMMENTS>skip</COMMENTS> <COMMENTS>zero</COMMENTS>-<COMMENTS>length</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>
        last
          if ( ( $<CODE>j</CODE> == $<CODE>maximum_field_index</CODE> )
            && ( !defined( $$<CODE>rfields</CODE>[$<CODE>j</CODE>] ) || ( length( $$<CODE>rfields</CODE>[$<CODE>j</CODE>] ) == 0 ) )
          );

        # <COMMENTS>compute</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>field</COMMENTS>
        my $<CODE>col</CODE> = $<CODE>line</CODE>-><CODE>get_column</CODE>( $<CODE>j</CODE> - 1 );
        $<CODE>pad</CODE> = $<CODE>col</CODE> - ( length($<CODE>str</CODE>) + $<CODE>leading_space_count</CODE> );

        if ($<CODE>do_not_align</CODE>) {
            $<CODE>pad</CODE> =
              ( $<CODE>j</CODE> < $<CODE>maximum_field_index</CODE> )
              ? 0
              : $<CODE>rOpts_minimum_space_to_comment</CODE> - 1;
        }

        # <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>fpsc</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>set</COMMENTS>, <COMMENTS>move</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>selected</COMMENTS>
        # <COMMENTS>column</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>possible</COMMENTS>, <COMMENTS>ignoring</COMMENTS> <COMMENTS>constraints</COMMENTS> <COMMENTS>on</COMMENTS>
        # <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>minimum</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>comment</COMMENTS>
        if ( $<CODE>rOpts_fixed_position_side_comment</CODE> && $<CODE>j</CODE> == $<CODE>maximum_field_index</CODE> )
        {
            my $<CODE>newpad</CODE> = $<CODE>pad</CODE> + $<CODE>rOpts_fixed_position_side_comment</CODE> - $<CODE>col</CODE> - 1;
            if ( $<CODE>newpad</CODE> >= 0 ) { $<CODE>pad</CODE> = $<CODE>newpad</CODE>; }
        }

        # <COMMENTS>accumulate</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>padding</COMMENTS>
        if ( $<CODE>pad</CODE> > 0 ) { $<CODE>total_pad_count</CODE> += $<CODE>pad</CODE>; }

        # <COMMENTS>add</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>field</COMMENTS>
        if ( !defined $$<CODE>rfields</CODE>[$<CODE>j</CODE>] ) {
            <CODE>write_diagnostics</CODE>("<LITERALS>UNDEFined</LITERALS> <LITERALS>field</LITERALS> <LITERALS>at</LITERALS> <LITERALS>j</LITERALS>=$<CODE>j</CODE>\n");
        }

        # <COMMENTS>only</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>finite</COMMENTS> <COMMENTS>field</COMMENTS>;
        # <COMMENTS>this</COMMENTS> <COMMENTS>avoids</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>fields</COMMENTS>
        if ( length( $$<CODE>rfields</CODE>[$<CODE>j</CODE>] ) > 0 ) {
            $<CODE>str</CODE> .= ' ' x $<CODE>total_pad_count</CODE>;
            $<CODE>total_pad_count</CODE> = 0;
            $<CODE>str</CODE> .= $$<CODE>rfields</CODE>[$<CODE>j</CODE>];
        }
        else {
            $<CODE>total_pad_count</CODE> = 0;
        }

        # <COMMENTS>update</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>history</COMMENTS> <COMMENTS>buffer</COMMENTS>
        if ( $<CODE>j</CODE> == $<CODE>maximum_field_index</CODE> ) {
            my $<CODE>lineno</CODE> = $<CODE>file_writer_object</CODE>-><CODE>get_output_line_number</CODE>();
            shift @<CODE>side_comment_history</CODE>;
            push @<CODE>side_comment_history</CODE>, [ $<CODE>lineno</CODE>, $<CODE>col</CODE> ];
        }
    }

    my $<CODE>side_comment_length</CODE> = ( length( $$<CODE>rfields</CODE>[$<CODE>maximum_field_index</CODE>] ) );

    # <COMMENTS>ship</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>off</COMMENTS>
    <CODE>valign_output_step_B</CODE>( $<CODE>leading_space_count</CODE> + $<CODE>extra_leading_spaces</CODE>,
        $<CODE>str</CODE>, $<CODE>side_comment_length</CODE>, $<CODE>outdent_long_lines</CODE>,
        $<CODE>rvertical_tightness_flags</CODE>, $<CODE>group_level</CODE> );
}

sub <CODE>get_extra_leading_spaces</CODE> {

    #----------------------------------------------------------
    # <COMMENTS>Define</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>space</COMMENTS> (<COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>option</COMMENTS>).
    # <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>why</COMMENTS>:
    # <COMMENTS>If</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comments</COMMENTS>, <COMMENTS>sub</COMMENTS> <COMMENTS>scan_list</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>dump</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>list</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>sees</COMMENTS> <COMMENTS>everything</COMMENTS>.  <COMMENTS>When</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>happens</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>sets</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>scheme</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>notes</COMMENTS> <COMMENTS>how</COMMENTS>
    # <COMMENTS>many</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>liked</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>able</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>recover</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>event</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>lines</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>together</COMMENTS> <COMMENTS>again</COMMENTS>.
    #----------------------------------------------------------

    my $<CODE>extra_leading_spaces</CODE> = 0;
    if ($<CODE>extra_indent_ok</CODE>) {
        my $<CODE>object</CODE> = $<CODE>group_lines</CODE>[0]-><CODE>get_indentation</CODE>();
        if ( ref($<CODE>object</CODE>) ) {
            my $<CODE>extra_indentation_spaces_wanted</CODE> =
              <CODE>get_RECOVERABLE_SPACES</CODE>($<CODE>object</CODE>);

            # <COMMENTS>all</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>objects</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS>
            my $<CODE>i</CODE>;
            for $<CODE>i</CODE> ( 1 .. $<CODE>maximum_line_index</CODE> ) {
                if ( $<CODE>object</CODE> != $<CODE>group_lines</CODE>[$<CODE>i</CODE>]-><CODE>get_indentation</CODE>() ) {
                    $<CODE>extra_indentation_spaces_wanted</CODE> = 0;
                    last;
                }
            }

            if ($<CODE>extra_indentation_spaces_wanted</CODE>) {

                # <COMMENTS>the</COMMENTS> <COMMENTS>maximum</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>exceeding</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS>:
                my $<CODE>avail</CODE> = $<CODE>group_lines</CODE>[0]-><CODE>get_available_space_on_right</CODE>();
                $<CODE>extra_leading_spaces</CODE> =
                  ( $<CODE>avail</CODE> > $<CODE>extra_indentation_spaces_wanted</CODE> )
                  ? $<CODE>extra_indentation_spaces_wanted</CODE>
                  : $<CODE>avail</CODE>;

                # <COMMENTS>update</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>icp</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>terminal</COMMENTS>
                # ');' <COMMENTS>will</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>adjustment</COMMENTS>.
                $<CODE>object</CODE>-><CODE>permanently_decrease_AVAILABLE_SPACES</CODE>(
                    -$<CODE>extra_leading_spaces</CODE> );
            }
        }
    }
    return $<CODE>extra_leading_spaces</CODE>;
}

sub <CODE>combine_fields</CODE> {

    # <COMMENTS>combine</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>fields</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>field</COMMENTS>  ( <COMMENTS>sidecmt</COMMENTS>.<COMMENTS>t</COMMENTS> )
    # <COMMENTS>Uses</COMMENTS> <COMMENTS>global</COMMENTS> <COMMENTS>variables</COMMENTS>:
    #  @<COMMENTS>group_lines</COMMENTS>
    #  <COMMENTS>$maximum_line_index</COMMENTS>
    my ( $<CODE>j</CODE>, $<CODE>k</CODE> );
    my $<CODE>maximum_field_index</CODE> = $<CODE>group_lines</CODE>[0]-><CODE>get_jmax</CODE>();
    for ( $<CODE>j</CODE> = 0 ; $<CODE>j</CODE> <= $<CODE>maximum_line_index</CODE> ; $<CODE>j</CODE>++ ) {
        my $<CODE>line</CODE>    = $<CODE>group_lines</CODE>[$<CODE>j</CODE>];
        my $<CODE>rfields</CODE> = $<CODE>line</CODE>-><CODE>get_rfields</CODE>();
        foreach ( 1 .. $<CODE>maximum_field_index</CODE> - 1 ) {
            $$<CODE>rfields</CODE>[0] .= $$<CODE>rfields</CODE>[$<CODE>_</CODE>];
        }
        $$<CODE>rfields</CODE>[1] = $$<CODE>rfields</CODE>[$<CODE>maximum_field_index</CODE>];

        $<CODE>line</CODE>-><CODE>set_jmax</CODE>(1);
        $<CODE>line</CODE>-><CODE>set_column</CODE>( 0, 0 );
        $<CODE>line</CODE>-><CODE>set_column</CODE>( 1, 0 );

    }
    $<CODE>maximum_field_index</CODE> = 1;

    for $<CODE>j</CODE> ( 0 .. $<CODE>maximum_line_index</CODE> ) {
        my $<CODE>line</CODE>    = $<CODE>group_lines</CODE>[$<CODE>j</CODE>];
        my $<CODE>rfields</CODE> = $<CODE>line</CODE>-><CODE>get_rfields</CODE>();
        for $<CODE>k</CODE> ( 0 .. $<CODE>maximum_field_index</CODE> ) {
            my $<CODE>pad</CODE> = length( $$<CODE>rfields</CODE>[$<CODE>k</CODE>] ) - $<CODE>line</CODE>-><CODE>current_field_width</CODE>($<CODE>k</CODE>);
            if ( $<CODE>k</CODE> == 0 ) {
                $<CODE>pad</CODE> += $<CODE>group_lines</CODE>[$<CODE>j</CODE>]-><CODE>get_leading_space_count</CODE>();
            }

            if ( $<CODE>pad</CODE> > 0 ) { $<CODE>line</CODE>-><CODE>increase_field_width</CODE>( $<CODE>k</CODE>, $<CODE>pad</CODE> ) }

        }
    }
}

sub <CODE>get_output_line_number</CODE> {

    # <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>reported</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>caller</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>items</COMMENTS>
    # <COMMENTS>written</COMMENTS> <COMMENTS>plus</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>items</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>buffer</COMMENTS>
    my $<CODE>self</CODE> = shift;
    1 + $<CODE>maximum_line_index</CODE> + $<CODE>file_writer_object</CODE>-><CODE>get_output_line_number</CODE>();
}

sub <CODE>valign_output_step_B</CODE> {

    ###############################################################
    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>Step</COMMENTS> <COMMENTS>B</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>writing</COMMENTS> <COMMENTS>vertically</COMMENTS> <COMMENTS>aligned</COMMENTS> <COMMENTS>lines</COMMENTS>.
    # <COMMENTS>Vertical</COMMENTS> <COMMENTS>tightness</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>applied</COMMENTS> <COMMENTS>according</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>preset</COMMENTS> <COMMENTS>flags</COMMENTS>.
    # <COMMENTS>In</COMMENTS> <COMMENTS>particular</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>handles</COMMENTS> <COMMENTS>stacking</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>opening</COMMENTS>
    # <COMMENTS>and</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS>.
    ###############################################################

    my ( $<CODE>leading_space_count</CODE>, $<CODE>str</CODE>, $<CODE>side_comment_length</CODE>, $<CODE>outdent_long_lines</CODE>,
        $<CODE>rvertical_tightness_flags</CODE>, $<CODE>level</CODE> )
      = @<CODE>_</CODE>;

    # <COMMENTS>handle</COMMENTS> <COMMENTS>outdenting</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>lines</COMMENTS>:
    if ($<CODE>outdent_long_lines</CODE>) {
        my $<CODE>excess</CODE> =
          length($<CODE>str</CODE>) -
          $<CODE>side_comment_length</CODE> +
          $<CODE>leading_space_count</CODE> -
          <CODE>maximum_line_length_for_level</CODE>($<CODE>level</CODE>);
        if ( $<CODE>excess</CODE> > 0 ) {
            $<CODE>leading_space_count</CODE> = 0;
            $<CODE>last_outdented_line_at</CODE> =
              $<CODE>file_writer_object</CODE>-><CODE>get_output_line_number</CODE>();

            unless ($<CODE>outdented_line_count</CODE>) {
                $<CODE>first_outdented_line_at</CODE> = $<CODE>last_outdented_line_at</CODE>;
            }
            $<CODE>outdented_line_count</CODE>++;
        }
    }

    # <COMMENTS>Make</COMMENTS> <COMMENTS>preliminary</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>changed</COMMENTS>
    # <COMMENTS>later</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>entabbing</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>track</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>changes</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading_space_count</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>on</COMMENTS>.
    my $<CODE>leading_string</CODE> =
      $<CODE>leading_space_count</CODE> > 0 ? ( ' ' x $<CODE>leading_space_count</CODE> ) : "";

    # <COMMENTS>Unpack</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>recombination</COMMENTS> <COMMENTS>data</COMMENTS>; <COMMENTS>it</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>packed</COMMENTS> <COMMENTS>by</COMMENTS>
    # <COMMENTS>sub</COMMENTS> <COMMENTS>send_lines_to_vertical_aligner</COMMENTS>. <COMMENTS>Contents</COMMENTS>:
    #
    #   [<COMMENTS>0</COMMENTS>] <COMMENTS>type</COMMENTS>: <COMMENTS>1</COMMENTS>=<COMMENTS>opening</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>block</COMMENTS>    <COMMENTS>2</COMMENTS>=<COMMENTS>closing</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>block</COMMENTS>
    #             <COMMENTS>3</COMMENTS>=<COMMENTS>opening</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>brace</COMMENTS>  <COMMENTS>4</COMMENTS>=<COMMENTS>closing</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>brace</COMMENTS>
    #   [<COMMENTS>1</COMMENTS>] <COMMENTS>flag</COMMENTS>: <COMMENTS>if</COMMENTS> <COMMENTS>opening</COMMENTS>: <COMMENTS>1</COMMENTS>=<COMMENTS>no</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>steps</COMMENTS>, <COMMENTS>2</COMMENTS>=<COMMENTS>multiple</COMMENTS> <COMMENTS>steps</COMMENTS> <COMMENTS>ok</COMMENTS>
    #             <COMMENTS>if</COMMENTS> <COMMENTS>closing</COMMENTS>: <COMMENTS>spaces</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>padding</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS>
    #   [<COMMENTS>2</COMMENTS>] <COMMENTS>sequence</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>container</COMMENTS>
    #   [<COMMENTS>3</COMMENTS>] <COMMENTS>valid</COMMENTS> <COMMENTS>flag</COMMENTS>: <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>false</COMMENTS>
    #
    my ( $<CODE>open_or_close</CODE>, $<CODE>tightness_flag</CODE>, $<CODE>seqno</CODE>, $<CODE>valid</CODE>, $<CODE>seqno_beg</CODE>,
        $<CODE>seqno_end</CODE> );
    if ($<CODE>rvertical_tightness_flags</CODE>) {
        (
            $<CODE>open_or_close</CODE>, $<CODE>tightness_flag</CODE>, $<CODE>seqno</CODE>, $<CODE>valid</CODE>, $<CODE>seqno_beg</CODE>,
            $<CODE>seqno_end</CODE>
        ) = @{$<CODE>rvertical_tightness_flags</CODE>};
    }

    $<CODE>seqno_string</CODE> = $<CODE>seqno_end</CODE>;

    # <COMMENTS>handle</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>cached</COMMENTS> <COMMENTS>line</COMMENTS> ..
    # <COMMENTS>either</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>out</COMMENTS>
    if ( length($<CODE>cached_line_text</CODE>) ) {

        # <COMMENTS>Dump</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>invalid</COMMENTS> <COMMENTS>cached</COMMENTS> <COMMENTS>line</COMMENTS>
        if ( !$<CODE>cached_line_valid</CODE> ) {
            <CODE>valign_output_step_C</CODE>( $<CODE>cached_line_text</CODE>,
                $<CODE>cached_line_leading_space_count</CODE>,
                $<CODE>last_level_written</CODE> );
        }

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>cached</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>OPENING</COMMENTS> <COMMENTS>tokens</COMMENTS>
        elsif ( $<CODE>cached_line_type</CODE> == 1 || $<CODE>cached_line_type</CODE> == 3 ) {

            my $<CODE>gap</CODE> = $<CODE>leading_space_count</CODE> - length($<CODE>cached_line_text</CODE>);

            # <COMMENTS>handle</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>tight</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>per</COMMENTS> <COMMENTS>line</COMMENTS>:
            if ( $<CODE>cached_line_flag</CODE> == 1 ) {
                if ( defined($<CODE>open_or_close</CODE>) && $<CODE>open_or_close</CODE> == 1 ) {
                    $<CODE>gap</CODE> = -1;
                }
            }

            if ( $<CODE>gap</CODE> >= 0 && defined($<CODE>seqno_beg</CODE>) ) {
                $<CODE>leading_string</CODE>      = $<CODE>cached_line_text</CODE> . ' ' x $<CODE>gap</CODE>;
                $<CODE>leading_space_count</CODE> = $<CODE>cached_line_leading_space_count</CODE>;
                $<CODE>seqno_string</CODE>        = $<CODE>cached_seqno_string</CODE> . ':' . $<CODE>seqno_beg</CODE>;
                $<CODE>level</CODE>               = $<CODE>last_level_written</CODE>;
            }
            else {
                <CODE>valign_output_step_C</CODE>( $<CODE>cached_line_text</CODE>,
                    $<CODE>cached_line_leading_space_count</CODE>,
                    $<CODE>last_level_written</CODE> );
            }
        }

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>cached</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>CLOSING</COMMENTS> <COMMENTS>tokens</COMMENTS>
        else {
            my $<CODE>test_line</CODE> = $<CODE>cached_line_text</CODE> . ' ' x $<CODE>cached_line_flag</CODE> . $<CODE>str</CODE>;
            if (

                # <COMMENTS>The</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>container</COMMENTS>
                $<CODE>seqno_beg</CODE>

                # <COMMENTS>The</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>combination</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>okay</COMMENTS>..
                && (

                    # <COMMENTS>okay</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>combine</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>types</COMMENTS>
                    ( $<CODE>open_or_close</CODE> == $<CODE>cached_line_type</CODE> )

                    # <COMMENTS>closing</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>block</COMMENTS>
                    || ( $<CODE>cached_line_type</CODE> == 2 && $<CODE>open_or_close</CODE> == 4 )

                    # <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> ');'
                    || ( !$<CODE>open_or_close</CODE> && $<CODE>cached_line_type</CODE> == 2 )

                )

                # <COMMENTS>The</COMMENTS> <COMMENTS>combined</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>fit</COMMENTS>
                && (
                    length($<CODE>test_line</CODE>) <=
                    <CODE>maximum_line_length_for_level</CODE>($<CODE>last_level_written</CODE>) )
              )
            {

                $<CODE>seqno_string</CODE> = $<CODE>cached_seqno_string</CODE> . ':' . $<CODE>seqno_beg</CODE>;

                # <COMMENTS>Patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>outdent</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>ending</COMMENTS> # <COMMENTS>in</COMMENTS> ');'
                # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>joining</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>like</COMMENTS> ');' <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>stacked</COMMENTS>
                # <COMMENTS>set</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>outdent</COMMENTS> <COMMENTS>the</COMMENTS>
                # <COMMENTS>combined</COMMENTS> <COMMENTS>stack</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> ');'.  <COMMENTS>Since</COMMENTS> <COMMENTS>we</COMMENTS>
                # <COMMENTS>should</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>normally</COMMENTS> <COMMENTS>outdent</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>than</COMMENTS>
                # <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>contained</COMMENTS> <COMMENTS>them</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS>
                # <COMMENTS>only</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>corresponding</COMMENTS> <COMMENTS>opening</COMMENTS>
                # <COMMENTS>tokens</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>with</COMMENTS>
                # -<COMMENTS>sot</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>sct</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>here</COMMENTS>:
                #   <COMMENTS>__PACKAGE__</COMMENTS>-><COMMENTS>load_components</COMMENTS>( <COMMENTS>qw</COMMENTS>(
                #         <COMMENTS>PK</COMMENTS>::<COMMENTS>Auto</COMMENTS>
                #         <COMMENTS>Core</COMMENTS>
                #   ));
                #
                #   <COMMENTS>But</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>outdent</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>because</COMMENTS>
                #   <COMMENTS>that</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>put</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>farther</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS>
                #   <COMMENTS>opening</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>brace</COMMENTS>:
                #
                #   <COMMENTS>perltidy</COMMENTS> -<COMMENTS>sot</COMMENTS> -<COMMENTS>sct</COMMENTS>
                #   <COMMENTS>$c</COMMENTS>-><COMMENTS>Tk</COMMENTS>::<COMMENTS>bind</COMMENTS>(
                #       '<<COMMENTS>Control</COMMENTS>-<COMMENTS>f</COMMENTS>>' => <COMMENTS>sub</COMMENTS> {
                #           <COMMENTS>my</COMMENTS> (<COMMENTS>$c</COMMENTS>) = @<COMMENTS>_</COMMENTS>;
                #           <COMMENTS>my</COMMENTS> <COMMENTS>$e</COMMENTS> = <COMMENTS>$c</COMMENTS>-><COMMENTS>XEvent</COMMENTS>;
                #           <COMMENTS>itemsUnderArea</COMMENTS> <COMMENTS>$c</COMMENTS>;
                #       } );
                #
                if ( $<CODE>str</CODE> =~ /^\);/ && $<CODE>cached_line_text</CODE> =~ /^[\)\}\]\s]*$/ ) {

                    # <COMMENTS>The</COMMENTS> <COMMENTS>way</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>tell</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>stacked</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>numbers</COMMENTS>
                    # <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>reverse</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>stacked</COMMENTS>
                    # <COMMENTS>sequence</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS>
                    # <COMMENTS>sequence</COMMENTS> <COMMENTS>numbers</COMMENTS>.  <COMMENTS>So</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>join</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS>
                    # <COMMENTS>nonblank</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>mirror</COMMENTS> <COMMENTS>image</COMMENTS>.  <COMMENTS>For</COMMENTS>
                    # <COMMENTS>example</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>stack</COMMENTS> )}] <COMMENTS>is</COMMENTS> <COMMENTS>13</COMMENTS>:<COMMENTS>8</COMMENTS>:<COMMENTS>6</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS>
                    # <COMMENTS>leading</COMMENTS> <COMMENTS>stack</COMMENTS> <COMMENTS>like</COMMENTS> [{( <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>6</COMMENTS>:<COMMENTS>8</COMMENTS>:<COMMENTS>13</COMMENTS> <COMMENTS>We</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS>
                    # <COMMENTS>check</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>ends</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>intermediate</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>must</COMMENTS>
                    # <COMMENTS>fall</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>order</COMMENTS>.  <COMMENTS>Note</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>speed</COMMENTS>: <COMMENTS>having</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>split</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>colons</COMMENTS>
                    # <COMMENTS>and</COMMENTS> <COMMENTS>eliminate</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>colons</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>appear</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>slow</COMMENTS>,
                    # <COMMENTS>but</COMMENTS> <COMMENTS>it</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>issue</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>almost</COMMENTS> <COMMENTS>never</COMMENTS> <COMMENTS>come</COMMENTS>
                    # <COMMENTS>through</COMMENTS> <COMMENTS>here</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>typical</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS>.
                    $<CODE>seqno_string</CODE> =~ s/^:+//;
                    $<CODE>last_nonblank_seqno_string</CODE> =~ s/^:+//;
                    $<CODE>seqno_string</CODE> =~ s/:+/:/g;
                    $<CODE>last_nonblank_seqno_string</CODE> =~ s/:+/:/g;

                    # <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>outdent</COMMENTS>?
                    my $<CODE>diff</CODE> =
                      $<CODE>cached_line_leading_space_count</CODE> - $<CODE>leading_space_count</CODE>;
                    if (   $<CODE>diff</CODE> > 0
                        && length($<CODE>seqno_string</CODE>)
                        && length($<CODE>last_nonblank_seqno_string</CODE>) ==
                        length($<CODE>seqno_string</CODE>) )
                    {
                        my @<CODE>seqno_last</CODE> =
                          ( split ':', $<CODE>last_nonblank_seqno_string</CODE> );
                        my @<CODE>seqno_now</CODE> = ( split ':', $<CODE>seqno_string</CODE> );
                        if (   $<CODE>seqno_now</CODE>[-1] == $<CODE>seqno_last</CODE>[0]
                            && $<CODE>seqno_now</CODE>[0] == $<CODE>seqno_last</CODE>[-1] )
                        {

                            # <COMMENTS>OK</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>outdent</COMMENTS> ..
                            # <COMMENTS>for</COMMENTS> <COMMENTS>absolute</COMMENTS> <COMMENTS>safety</COMMENTS>, <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>remove</COMMENTS>
                            # <COMMENTS>whitespace</COMMENTS>
                            my $<CODE>ws</CODE> = substr( $<CODE>test_line</CODE>, 0, $<CODE>diff</CODE> );
                            if ( ( length($<CODE>ws</CODE>) == $<CODE>diff</CODE> ) && $<CODE>ws</CODE> =~ /^\s+$/ ) {

                                $<CODE>test_line</CODE> = substr( $<CODE>test_line</CODE>, $<CODE>diff</CODE> );
                                $<CODE>cached_line_leading_space_count</CODE> -= $<CODE>diff</CODE>;
                                $<CODE>last_level_written</CODE> =
                                  <CODE>level_change</CODE>(
                                    $<CODE>cached_line_leading_space_count</CODE>,
                                    $<CODE>diff</CODE>, $<CODE>last_level_written</CODE> );
                                <CODE>reduce_valign_buffer_indentation</CODE>($<CODE>diff</CODE>);
                            }

                            # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>critical</COMMENTS>:
                            ##<COMMENTS>else</COMMENTS> {
                            ## <COMMENTS>ERROR</COMMENTS> <COMMENTS>transferring</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>here</COMMENTS>
                            ##}
                        }
                    }
                }

                $<CODE>str</CODE>                 = $<CODE>test_line</CODE>;
                $<CODE>leading_string</CODE>      = "";
                $<CODE>leading_space_count</CODE> = $<CODE>cached_line_leading_space_count</CODE>;
                $<CODE>level</CODE>               = $<CODE>last_level_written</CODE>;
            }
            else {
                <CODE>valign_output_step_C</CODE>( $<CODE>cached_line_text</CODE>,
                    $<CODE>cached_line_leading_space_count</CODE>,
                    $<CODE>last_level_written</CODE> );
            }
        }
    }
    $<CODE>cached_line_type</CODE> = 0;
    $<CODE>cached_line_text</CODE> = "";

    # <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>written</COMMENTS>
    my $<CODE>line</CODE> = $<CODE>leading_string</CODE> . $<CODE>str</CODE>;

    # <COMMENTS>write</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>cache</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
    if ( !$<CODE>open_or_close</CODE> || $<CODE>side_comment_length</CODE> > 0 ) {
        <CODE>valign_output_step_C</CODE>( $<CODE>line</CODE>, $<CODE>leading_space_count</CODE>, $<CODE>level</CODE> );
    }
    else {
        $<CODE>cached_line_text</CODE>                = $<CODE>line</CODE>;
        $<CODE>cached_line_type</CODE>                = $<CODE>open_or_close</CODE>;
        $<CODE>cached_line_flag</CODE>                = $<CODE>tightness_flag</CODE>;
        $<CODE>cached_seqno</CODE>                    = $<CODE>seqno</CODE>;
        $<CODE>cached_line_valid</CODE>               = $<CODE>valid</CODE>;
        $<CODE>cached_line_leading_space_count</CODE> = $<CODE>leading_space_count</CODE>;
        $<CODE>cached_seqno_string</CODE>             = $<CODE>seqno_string</CODE>;
    }

    $<CODE>last_level_written</CODE>       = $<CODE>level</CODE>;
    $<CODE>last_side_comment_length</CODE> = $<CODE>side_comment_length</CODE>;
    $<CODE>extra_indent_ok</CODE>          = 0;
}

sub <CODE>valign_output_step_C</CODE> {

    ###############################################################
    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>Step</COMMENTS> <COMMENTS>C</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>writing</COMMENTS> <COMMENTS>vertically</COMMENTS> <COMMENTS>aligned</COMMENTS> <COMMENTS>lines</COMMENTS>.
    # <COMMENTS>Lines</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>stored</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>buffer</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>passed</COMMENTS> <COMMENTS>along</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>step</COMMENTS>.
    # <COMMENTS>The</COMMENTS> <COMMENTS>reason</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>storing</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>reduce</COMMENTS> <COMMENTS>their</COMMENTS>
    # <COMMENTS>indentation</COMMENTS> <COMMENTS>when</COMMENTS> -<COMMENTS>sot</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>sct</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>used</COMMENTS>.
    ###############################################################
    my @<CODE>args</CODE> = @<CODE>_</CODE>;

    # <COMMENTS>Dump</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>saved</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>unbalanced</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>or</COMMENTS>
    # <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS>.
    <CODE>dump_valign_buffer</CODE>() if ( $<CODE>seqno_string</CODE> && $<CODE>valign_buffer_filling</CODE> );

    # <COMMENTS>Either</COMMENTS> <COMMENTS>store</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>
    if ($<CODE>valign_buffer_filling</CODE>) {
        push @<CODE>valign_buffer</CODE>, [@<CODE>args</CODE>];
    }
    else {
        <CODE>valign_output_step_D</CODE>(@<CODE>args</CODE>);
    }

    # <COMMENTS>For</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS>..
    if ($<CODE>seqno_string</CODE>) {
        $<CODE>last_nonblank_seqno_string</CODE> = $<CODE>seqno_string</CODE>;

        # <COMMENTS>Start</COMMENTS> <COMMENTS>storing</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>stacked</COMMENTS> <COMMENTS>opening</COMMENTS>
        # <COMMENTS>tokens</COMMENTS>.
        # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>RT</COMMENTS> #<COMMENTS>94354</COMMENTS>, <COMMENTS>requested</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>Colin</COMMENTS> <COMMENTS>Williams</COMMENTS>
        if ( $<CODE>seqno_string</CODE> =~ /^\d+(\:+\d+)+$/ && $<CODE>args</CODE>[0] !~ /^[\}\)\]\:\?]/ )
        {

            # <COMMENTS>This</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>efficient</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>little</COMMENTS> <COMMENTS>subtle</COMMENTS>: <COMMENTS>The</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>says</COMMENTS>
            # <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>hence</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>opening</COMMENTS>
            # <COMMENTS>or</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>part</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>test</COMMENTS>
            # <COMMENTS>rejects</COMMENTS> <COMMENTS>stacked</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>ternary</COMMENTS> <COMMENTS>tokens</COMMENTS>.  <COMMENTS>So</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>here</COMMENTS>
            # <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>stacked</COMMENTS> <COMMENTS>unbalanced</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>tokens</COMMENTS>.

            # <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>complex</COMMENTS> <COMMENTS>example</COMMENTS>:

            # <COMMENTS>Foo</COMMENTS>(<COMMENTS>$Bar</COMMENTS>[<COMMENTS>0</COMMENTS>], {  # (<COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>)
            #   <COMMENTS>baz</COMMENTS> => <COMMENTS>1</COMMENTS>,
            # });

            # <COMMENTS>The</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>6</COMMENTS>::<COMMENTS>4</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>begin</COMMENTS> <COMMENTS>with</COMMENTS>
            # <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>ternary</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>passes</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS>
            # <COMMENTS>stacked</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>tokens</COMMENTS>.

            # <COMMENTS>The</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>4</COMMENTS>:<COMMENTS>6</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>stack</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>tokens</COMMENTS>,
            # <COMMENTS>so</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>gets</COMMENTS> <COMMENTS>rejected</COMMENTS>.

            # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>quote</COMMENTS>
            # <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>negative</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>rejected</COMMENTS>.
            # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>line</COMMENTS>:
            #    <COMMENTS>skip_symbols</COMMENTS>([<COMMENTS>qw</COMMENTS>(
            # <COMMENTS>$seqno_string</COMMENTS>='<COMMENTS>10</COMMENTS>:<COMMENTS>5</COMMENTS>:-<COMMENTS>1</COMMENTS>'.  <COMMENTS>It</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>okay</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>accept</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>but</COMMENTS>
            # <COMMENTS>I</COMMENTS> <COMMENTS>decided</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>testing</COMMENTS>.

            $<CODE>valign_buffer_filling</CODE> = $<CODE>seqno_string</CODE>;

        }
    }
}

sub <CODE>valign_output_step_D</CODE> {

    ###############################################################
    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>Step</COMMENTS> <COMMENTS>D</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>writing</COMMENTS> <COMMENTS>vertically</COMMENTS> <COMMENTS>aligned</COMMENTS> <COMMENTS>lines</COMMENTS>.
    # <COMMENTS>Write</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>vertically</COMMENTS> <COMMENTS>aligned</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>object</COMMENTS>.
    ###############################################################

    my ( $<CODE>line</CODE>, $<CODE>leading_space_count</CODE>, $<CODE>level</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>The</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>currently</COMMENTS> <COMMENTS>correct</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>tabbing</COMMENTS> (<COMMENTS>recommended</COMMENTS>!)
    # <COMMENTS>We</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>lop</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>replace</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>tabs</COMMENTS>.
    if ( $<CODE>leading_space_count</CODE> > 0 ) {

        # <COMMENTS>Nothing</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>tabs</COMMENTS>
        if ( !( $<CODE>rOpts_tabs</CODE> || $<CODE>rOpts_entab_leading_whitespace</CODE> )
            || $<CODE>rOpts_indent_columns</CODE> <= 0 )
        {

            # <COMMENTS>nothing</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS>
        }

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>entab</COMMENTS> <COMMENTS>option</COMMENTS>
        elsif ($<CODE>rOpts_entab_leading_whitespace</CODE>) {
            my $<CODE>space_count</CODE> =
              $<CODE>leading_space_count</CODE> % $<CODE>rOpts_entab_leading_whitespace</CODE>;
            my $<CODE>tab_count</CODE> =
              int( $<CODE>leading_space_count</CODE> / $<CODE>rOpts_entab_leading_whitespace</CODE> );
            my $<CODE>leading_string</CODE> = "\t" x $<CODE>tab_count</CODE> . ' ' x $<CODE>space_count</CODE>;
            if ( $<CODE>line</CODE> =~ /^\s{$<CODE>leading_space_count</CODE>,$<CODE>leading_space_count</CODE>}/ ) {
                substr( $<CODE>line</CODE>, 0, $<CODE>leading_space_count</CODE> ) = $<CODE>leading_string</CODE>;
            }
            else {

                # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS> - <COMMENTS>program</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>counting</COMMENTS> <COMMENTS>whitespace</COMMENTS>
                # - <COMMENTS>skip</COMMENTS> <COMMENTS>entabbing</COMMENTS>
                <CODE>VALIGN_DEBUG_FLAG_TABS</CODE>
                  && <CODE>warning</CODE>(
"<LITERALS>Error</LITERALS> <LITERALS>entabbing</LITERALS> <LITERALS>in</LITERALS> <LITERALS>valign_output_step_D</LITERALS>: <LITERALS>expected</LITERALS> <LITERALS>count</LITERALS>=$<CODE>leading_space_count</CODE>\n"
                  );
            }
        }

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>tab</COMMENTS> <COMMENTS>per</COMMENTS> <COMMENTS>level</COMMENTS>
        else {
            my $<CODE>leading_string</CODE> = ( "\t" x $<CODE>level</CODE> );
            my $<CODE>space_count</CODE> =
              $<CODE>leading_space_count</CODE> - $<CODE>level</CODE> * $<CODE>rOpts_indent_columns</CODE>;

            # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>:
            if ( $<CODE>space_count</CODE> < 0 ) {

                # <COMMENTS>But</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>outdented</COMMENTS> <COMMENTS>comment</COMMENTS>
                if ( $<CODE>line</CODE> !~ /^\s*#/ ) {
                    <CODE>VALIGN_DEBUG_FLAG_TABS</CODE>
                      && <CODE>warning</CODE>(
"<LITERALS>Error</LITERALS> <LITERALS>entabbing</LITERALS> <LITERALS>in</LITERALS> <LITERALS>valign_output_step_D</LITERALS>: <LITERALS>for</LITERALS> <LITERALS>level</LITERALS>=$<CODE>group_level</CODE> <LITERALS>count</LITERALS>=$<CODE>leading_space_count</CODE>\n"
                      );
                }
                $<CODE>leading_string</CODE> = ( ' ' x $<CODE>leading_space_count</CODE> );
            }
            else {
                $<CODE>leading_string</CODE> .= ( ' ' x $<CODE>space_count</CODE> );
            }
            if ( $<CODE>line</CODE> =~ /^\s{$<CODE>leading_space_count</CODE>,$<CODE>leading_space_count</CODE>}/ ) {
                substr( $<CODE>line</CODE>, 0, $<CODE>leading_space_count</CODE> ) = $<CODE>leading_string</CODE>;
            }
            else {

                # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS> - <COMMENTS>program</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>counting</COMMENTS> <COMMENTS>whitespace</COMMENTS>
                # <COMMENTS>we</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>skip</COMMENTS> <COMMENTS>entabbing</COMMENTS>
                <CODE>VALIGN_DEBUG_FLAG_TABS</CODE>
                  && <CODE>warning</CODE>(
"<LITERALS>Error</LITERALS> <LITERALS>entabbing</LITERALS> <LITERALS>in</LITERALS> <LITERALS>valign_output_step_D</LITERALS>: <LITERALS>expected</LITERALS> <LITERALS>count</LITERALS>=$<CODE>leading_space_count</CODE>\n"
                  );
            }
        }
    }
    $<CODE>file_writer_object</CODE>-><CODE>write_code_line</CODE>( $<CODE>line</CODE> . "\n" );
}

{    # <COMMENTS>begin</COMMENTS> <COMMENTS>get_leading_string</COMMENTS>

    my @<CODE>leading_string_cache</CODE>;

    sub <CODE>get_leading_string</CODE> {

        # <COMMENTS>define</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>..
        my $<CODE>leading_whitespace_count</CODE> = shift;

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>zero</COMMENTS> <COMMENTS>whitespace</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>includes</COMMENTS> <COMMENTS>multi</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>quotes</COMMENTS>
        # (<COMMENTS>which</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>finite</COMMENTS> <COMMENTS>level</COMMENTS>; <COMMENTS>this</COMMENTS> <COMMENTS>prevents</COMMENTS> <COMMENTS>tab</COMMENTS> <COMMENTS>problems</COMMENTS>)
        if ( $<CODE>leading_whitespace_count</CODE> <= 0 ) {
            return "";
        }

        # <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>result</COMMENTS>
        elsif ( $<CODE>leading_string_cache</CODE>[$<CODE>leading_whitespace_count</CODE>] ) {
            return $<CODE>leading_string_cache</CODE>[$<CODE>leading_whitespace_count</CODE>];
        }

        # <COMMENTS>must</COMMENTS> <COMMENTS>compute</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>spaces</COMMENTS>
        my $<CODE>leading_string</CODE>;

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>tabs</COMMENTS>
        if ( !( $<CODE>rOpts_tabs</CODE> || $<CODE>rOpts_entab_leading_whitespace</CODE> )
            || $<CODE>rOpts_indent_columns</CODE> <= 0 )
        {
            $<CODE>leading_string</CODE> = ( ' ' x $<CODE>leading_whitespace_count</CODE> );
        }

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>entab</COMMENTS> <COMMENTS>option</COMMENTS>
        elsif ($<CODE>rOpts_entab_leading_whitespace</CODE>) {
            my $<CODE>space_count</CODE> =
              $<CODE>leading_whitespace_count</CODE> % $<CODE>rOpts_entab_leading_whitespace</CODE>;
            my $<CODE>tab_count</CODE> = int(
                $<CODE>leading_whitespace_count</CODE> / $<CODE>rOpts_entab_leading_whitespace</CODE> );
            $<CODE>leading_string</CODE> = "\t" x $<CODE>tab_count</CODE> . ' ' x $<CODE>space_count</CODE>;
        }

        # <COMMENTS>Handle</COMMENTS> <COMMENTS>option</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>tab</COMMENTS> <COMMENTS>per</COMMENTS> <COMMENTS>level</COMMENTS>
        else {
            $<CODE>leading_string</CODE> = ( "\t" x $<CODE>group_level</CODE> );
            my $<CODE>space_count</CODE> =
              $<CODE>leading_whitespace_count</CODE> - $<CODE>group_level</CODE> * $<CODE>rOpts_indent_columns</CODE>;

            # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>:
            if ( $<CODE>space_count</CODE> < 0 ) {
                <CODE>VALIGN_DEBUG_FLAG_TABS</CODE>
                  && <CODE>warning</CODE>(
"<LITERALS>Error</LITERALS> <LITERALS>in</LITERALS> <LITERALS>get_leading_string</LITERALS>: <LITERALS>for</LITERALS> <LITERALS>level</LITERALS>=$<CODE>group_level</CODE> <LITERALS>count</LITERALS>=$<CODE>leading_whitespace_count</CODE>\n"
                  );

                # -- <COMMENTS>skip</COMMENTS> <COMMENTS>entabbing</COMMENTS>
                $<CODE>leading_string</CODE> = ( ' ' x $<CODE>leading_whitespace_count</CODE> );
            }
            else {
                $<CODE>leading_string</CODE> .= ( ' ' x $<CODE>space_count</CODE> );
            }
        }
        $<CODE>leading_string_cache</CODE>[$<CODE>leading_whitespace_count</CODE>] = $<CODE>leading_string</CODE>;
        return $<CODE>leading_string</CODE>;
    }
}    # <COMMENTS>end</COMMENTS> <COMMENTS>get_leading_string</COMMENTS>

sub <CODE>report_anything_unusual</CODE> {
    my $<CODE>self</CODE> = shift;
    if ( $<CODE>outdented_line_count</CODE> > 0 ) {
        <CODE>write_logfile_entry</CODE>(
            "$<CODE>outdented_line_count</CODE> <LITERALS>long</LITERALS> <LITERALS>lines</LITERALS> <LITERALS>were</LITERALS> <LITERALS>outdented</LITERALS>:\n");
        <CODE>write_logfile_entry</CODE>(
            "  <LITERALS>First</LITERALS> <LITERALS>at</LITERALS> <LITERALS>output</LITERALS> <LITERALS>line</LITERALS> $<CODE>first_outdented_line_at</CODE>\n");

        if ( $<CODE>outdented_line_count</CODE> > 1 ) {
            <CODE>write_logfile_entry</CODE>(
                "   <LITERALS>Last</LITERALS> <LITERALS>at</LITERALS> <LITERALS>output</LITERALS> <LITERALS>line</LITERALS> $<CODE>last_outdented_line_at</CODE>\n");
        }
        <CODE>write_logfile_entry</CODE>(
            "  <LITERALS>use</LITERALS> -<LITERALS>noll</LITERALS> <LITERALS>to</LITERALS> <LITERALS>prevent</LITERALS> <LITERALS>outdenting</LITERALS>, -<LITERALS>l</LITERALS>=<LITERALS>n</LITERALS> <LITERALS>to</LITERALS> <LITERALS>increase</LITERALS> <LITERALS>line</LITERALS> <LITERALS>length</LITERALS>\n"
        );
        <CODE>write_logfile_entry</CODE>("\n");
    }
}

#####################################################################
#
# <COMMENTS>the</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>FileWriter</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>writes</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>file</COMMENTS>
#
#####################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>FileWriter</CODE>;

# <COMMENTS>Maximum</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>little</COMMENTS> <COMMENTS>messages</COMMENTS>; <COMMENTS>probably</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>changed</COMMENTS>.
use <CODE>constant</CODE> <LITERALS>MAX_NAG_MESSAGES</LITERALS> => 6;

sub <CODE>write_logfile_entry</CODE> {
    my $<CODE>self</CODE>          = shift;
    my $<CODE>logger_object</CODE> = $<CODE>self</CODE>->{<LITERALS>_logger_object</LITERALS>};
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>new</CODE> {
    my $<CODE>class</CODE> = shift;
    my ( $<CODE>line_sink_object</CODE>, $<CODE>rOpts</CODE>, $<CODE>logger_object</CODE> ) = @<CODE>_</CODE>;

    bless {
        <LITERALS>_line_sink_object</LITERALS>           => $<CODE>line_sink_object</CODE>,
        <LITERALS>_logger_object</LITERALS>              => $<CODE>logger_object</CODE>,
        <LITERALS>_rOpts</LITERALS>                      => $<CODE>rOpts</CODE>,
        <LITERALS>_output_line_number</LITERALS>         => 1,
        <LITERALS>_consecutive_blank_lines</LITERALS>    => 0,
        <LITERALS>_consecutive_nonblank_lines</LITERALS> => 0,
        <LITERALS>_first_line_length_error</LITERALS>    => 0,
        <LITERALS>_max_line_length_error</LITERALS>      => 0,
        <LITERALS>_last_line_length_error</LITERALS>     => 0,
        <LITERALS>_first_line_length_error_at</LITERALS> => 0,
        <LITERALS>_max_line_length_error_at</LITERALS>   => 0,
        <LITERALS>_last_line_length_error_at</LITERALS>  => 0,
        <LITERALS>_line_length_error_count</LITERALS>    => 0,
        <LITERALS>_max_output_line_length</LITERALS>     => 0,
        <LITERALS>_max_output_line_length_at</LITERALS>  => 0,
    }, $<CODE>class</CODE>;
}

sub <CODE>tee_on</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>->{<LITERALS>_line_sink_object</LITERALS>}-><CODE>tee_on</CODE>();
}

sub <CODE>tee_off</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>->{<LITERALS>_line_sink_object</LITERALS>}-><CODE>tee_off</CODE>();
}

sub <CODE>get_output_line_number</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->{<LITERALS>_output_line_number</LITERALS>};
}

sub <CODE>decrement_output_line_number</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>->{<LITERALS>_output_line_number</LITERALS>}--;
}

sub <CODE>get_consecutive_nonblank_lines</CODE> {
    my $<CODE>self</CODE> = shift;
    return $<CODE>self</CODE>->{<LITERALS>_consecutive_nonblank_lines</LITERALS>};
}

sub <CODE>reset_consecutive_blank_lines</CODE> {
    my $<CODE>self</CODE> = shift;
    $<CODE>self</CODE>->{<LITERALS>_consecutive_blank_lines</LITERALS>} = 0;
}

sub <CODE>want_blank_line</CODE> {
    my $<CODE>self</CODE> = shift;
    unless ( $<CODE>self</CODE>->{<LITERALS>_consecutive_blank_lines</LITERALS>} ) {
        $<CODE>self</CODE>-><CODE>write_blank_code_line</CODE>();
    }
}

sub <CODE>require_blank_code_lines</CODE> {

    # <COMMENTS>write</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>requested</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>blanks</COMMENTS> <COMMENTS>regardless</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>of</COMMENTS> -<COMMENTS>mbl</COMMENTS>
    # <COMMENTS>unless</COMMENTS> -<COMMENTS>mbl</COMMENTS>=<COMMENTS>0</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>allows</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>written</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>subs</COMMENTS> <COMMENTS>and</COMMENTS>
    # <COMMENTS>packages</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS> -<COMMENTS>mbl</COMMENTS>=<COMMENTS>1</COMMENTS>
    my $<CODE>self</CODE>   = shift;
    my $<CODE>count</CODE>  = shift;
    my $<CODE>need</CODE>   = $<CODE>count</CODE> - $<CODE>self</CODE>->{<LITERALS>_consecutive_blank_lines</LITERALS>};
    my $<CODE>rOpts</CODE>  = $<CODE>self</CODE>->{<LITERALS>_rOpts</LITERALS>};
    my $<CODE>forced</CODE> = $<CODE>rOpts</CODE>->{'<LITERALS>maximum</LITERALS>-<LITERALS>consecutive</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>'} > 0;
    for ( my $<CODE>i</CODE> = 0 ; $<CODE>i</CODE> < $<CODE>need</CODE> ; $<CODE>i</CODE>++ ) {
        $<CODE>self</CODE>-><CODE>write_blank_code_line</CODE>($<CODE>forced</CODE>);
    }
}

sub <CODE>write_blank_code_line</CODE> {
    my $<CODE>self</CODE>   = shift;
    my $<CODE>forced</CODE> = shift;
    my $<CODE>rOpts</CODE>  = $<CODE>self</CODE>->{<LITERALS>_rOpts</LITERALS>};
    return
      if (!$<CODE>forced</CODE>
        && $<CODE>self</CODE>->{<LITERALS>_consecutive_blank_lines</LITERALS>} >=
        $<CODE>rOpts</CODE>->{'<LITERALS>maximum</LITERALS>-<LITERALS>consecutive</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>'} );
    $<CODE>self</CODE>->{<LITERALS>_consecutive_blank_lines</LITERALS>}++;
    $<CODE>self</CODE>->{<LITERALS>_consecutive_nonblank_lines</LITERALS>} = 0;
    $<CODE>self</CODE>-><CODE>write_line</CODE>("\n");
}

sub <CODE>write_code_line</CODE> {
    my $<CODE>self</CODE> = shift;
    my $<CODE>a</CODE>    = shift;

    if ( $<CODE>a</CODE> =~ /^\s*$/ ) {
        my $<CODE>rOpts</CODE> = $<CODE>self</CODE>->{<LITERALS>_rOpts</LITERALS>};
        return
          if ( $<CODE>self</CODE>->{<LITERALS>_consecutive_blank_lines</LITERALS>} >=
            $<CODE>rOpts</CODE>->{'<LITERALS>maximum</LITERALS>-<LITERALS>consecutive</LITERALS>-<LITERALS>blank</LITERALS>-<LITERALS>lines</LITERALS>'} );
        $<CODE>self</CODE>->{<LITERALS>_consecutive_blank_lines</LITERALS>}++;
        $<CODE>self</CODE>->{<LITERALS>_consecutive_nonblank_lines</LITERALS>} = 0;
    }
    else {
        $<CODE>self</CODE>->{<LITERALS>_consecutive_blank_lines</LITERALS>} = 0;
        $<CODE>self</CODE>->{<LITERALS>_consecutive_nonblank_lines</LITERALS>}++;
    }
    $<CODE>self</CODE>-><CODE>write_line</CODE>($<CODE>a</CODE>);
}

sub <CODE>write_line</CODE> {
    my $<CODE>self</CODE> = shift;
    my $<CODE>a</CODE>    = shift;

    # <COMMENTS>TODO</COMMENTS>: <COMMENTS>go</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>here</COMMENTS>
    if ( $<CODE>a</CODE> =~ /\n$/ ) { $<CODE>self</CODE>->{<LITERALS>_output_line_number</LITERALS>}++; }

    $<CODE>self</CODE>->{<LITERALS>_line_sink_object</LITERALS>}-><CODE>write_line</CODE>($<CODE>a</CODE>);

    # <COMMENTS>This</COMMENTS> <COMMENTS>calculation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>excess</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>ignores</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>internal</COMMENTS> <COMMENTS>tabs</COMMENTS>
    my $<CODE>rOpts</CODE>  = $<CODE>self</CODE>->{<LITERALS>_rOpts</LITERALS>};
    my $<CODE>exceed</CODE> = length($<CODE>a</CODE>) - $<CODE>rOpts</CODE>->{'<LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>'} - 1;
    if ( $<CODE>a</CODE> =~ /^\t+/g ) {
        $<CODE>exceed</CODE> += pos($<CODE>a</CODE>) * ( $<CODE>rOpts</CODE>->{'<LITERALS>indent</LITERALS>-<LITERALS>columns</LITERALS>'} - 1 );
    }

    # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>incremented</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>future</COMMENTS> <COMMENTS>value</COMMENTS>
    # <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>subtract</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS>
    if ( length($<CODE>a</CODE>) > 1 + $<CODE>self</CODE>->{<LITERALS>_max_output_line_length</LITERALS>} ) {
        $<CODE>self</CODE>->{<LITERALS>_max_output_line_length</LITERALS>}    = length($<CODE>a</CODE>) - 1;
        $<CODE>self</CODE>->{<LITERALS>_max_output_line_length_at</LITERALS>} = $<CODE>self</CODE>->{<LITERALS>_output_line_number</LITERALS>} - 1;
    }

    if ( $<CODE>exceed</CODE> > 0 ) {
        my $<CODE>output_line_number</CODE> = $<CODE>self</CODE>->{<LITERALS>_output_line_number</LITERALS>};
        $<CODE>self</CODE>->{<LITERALS>_last_line_length_error</LITERALS>}    = $<CODE>exceed</CODE>;
        $<CODE>self</CODE>->{<LITERALS>_last_line_length_error_at</LITERALS>} = $<CODE>output_line_number</CODE> - 1;
        if ( $<CODE>self</CODE>->{<LITERALS>_line_length_error_count</LITERALS>} == 0 ) {
            $<CODE>self</CODE>->{<LITERALS>_first_line_length_error</LITERALS>}    = $<CODE>exceed</CODE>;
            $<CODE>self</CODE>->{<LITERALS>_first_line_length_error_at</LITERALS>} = $<CODE>output_line_number</CODE> - 1;
        }

        if (
            $<CODE>self</CODE>->{<LITERALS>_last_line_length_error</LITERALS>} > $<CODE>self</CODE>->{<LITERALS>_max_line_length_error</LITERALS>} )
        {
            $<CODE>self</CODE>->{<LITERALS>_max_line_length_error</LITERALS>}    = $<CODE>exceed</CODE>;
            $<CODE>self</CODE>->{<LITERALS>_max_line_length_error_at</LITERALS>} = $<CODE>output_line_number</CODE> - 1;
        }

        if ( $<CODE>self</CODE>->{<LITERALS>_line_length_error_count</LITERALS>} < <CODE>MAX_NAG_MESSAGES</CODE> ) {
            $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>(
                "<LITERALS>Line</LITERALS> <LITERALS>length</LITERALS> <LITERALS>exceeded</LITERALS> <LITERALS>by</LITERALS> $<CODE>exceed</CODE> <LITERALS>characters</LITERALS>\n");
        }
        $<CODE>self</CODE>->{<LITERALS>_line_length_error_count</LITERALS>}++;
    }

}

sub <CODE>report_line_length_errors</CODE> {
    my $<CODE>self</CODE>                    = shift;
    my $<CODE>rOpts</CODE>                   = $<CODE>self</CODE>->{<LITERALS>_rOpts</LITERALS>};
    my $<CODE>line_length_error_count</CODE> = $<CODE>self</CODE>->{<LITERALS>_line_length_error_count</LITERALS>};
    if ( $<CODE>line_length_error_count</CODE> == 0 ) {
        $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>(
            "<LITERALS>No</LITERALS> <LITERALS>lines</LITERALS> <LITERALS>exceeded</LITERALS> $<CODE>rOpts</CODE>->{'<LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>'} <LITERALS>characters</LITERALS>\n");
        my $<CODE>max_output_line_length</CODE>    = $<CODE>self</CODE>->{<LITERALS>_max_output_line_length</LITERALS>};
        my $<CODE>max_output_line_length_at</CODE> = $<CODE>self</CODE>->{<LITERALS>_max_output_line_length_at</LITERALS>};
        $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>(
"  <LITERALS>Maximum</LITERALS> <LITERALS>output</LITERALS> <LITERALS>line</LITERALS> <LITERALS>length</LITERALS> <LITERALS>was</LITERALS> $<CODE>max_output_line_length</CODE> <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> $<CODE>max_output_line_length_at</CODE>\n"
        );

    }
    else {

        my $<CODE>word</CODE> = ( $<CODE>line_length_error_count</CODE> > 1 ) ? "<LITERALS>s</LITERALS>" : "";
        $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>(
"$<CODE>line_length_error_count</CODE> <LITERALS>output</LITERALS> <LITERALS>line</LITERALS>$<CODE>word</CODE> <LITERALS>exceeded</LITERALS> $<CODE>rOpts</CODE>->{'<LITERALS>maximum</LITERALS>-<LITERALS>line</LITERALS>-<LITERALS>length</LITERALS>'} <LITERALS>characters</LITERALS>:\n"
        );

        $<CODE>word</CODE> = ( $<CODE>line_length_error_count</CODE> > 1 ) ? "<LITERALS>First</LITERALS>" : "";
        my $<CODE>first_line_length_error</CODE>    = $<CODE>self</CODE>->{<LITERALS>_first_line_length_error</LITERALS>};
        my $<CODE>first_line_length_error_at</CODE> = $<CODE>self</CODE>->{<LITERALS>_first_line_length_error_at</LITERALS>};
        $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>(
" $<CODE>word</CODE> <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> $<CODE>first_line_length_error_at</CODE> <LITERALS>by</LITERALS> $<CODE>first_line_length_error</CODE> <LITERALS>characters</LITERALS>\n"
        );

        if ( $<CODE>line_length_error_count</CODE> > 1 ) {
            my $<CODE>max_line_length_error</CODE>     = $<CODE>self</CODE>->{<LITERALS>_max_line_length_error</LITERALS>};
            my $<CODE>max_line_length_error_at</CODE>  = $<CODE>self</CODE>->{<LITERALS>_max_line_length_error_at</LITERALS>};
            my $<CODE>last_line_length_error</CODE>    = $<CODE>self</CODE>->{<LITERALS>_last_line_length_error</LITERALS>};
            my $<CODE>last_line_length_error_at</CODE> = $<CODE>self</CODE>->{<LITERALS>_last_line_length_error_at</LITERALS>};
            $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>(
" <LITERALS>Maximum</LITERALS> <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> $<CODE>max_line_length_error_at</CODE> <LITERALS>by</LITERALS> $<CODE>max_line_length_error</CODE> <LITERALS>characters</LITERALS>\n"
            );
            $<CODE>self</CODE>-><CODE>write_logfile_entry</CODE>(
" <LITERALS>Last</LITERALS> <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> $<CODE>last_line_length_error_at</CODE> <LITERALS>by</LITERALS> $<CODE>last_line_length_error</CODE> <LITERALS>characters</LITERALS>\n"
            );
        }
    }
}

#####################################################################
#
# <COMMENTS>The</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Debugger</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>shows</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>tokenization</COMMENTS>
#
#####################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Debugger</CODE>;

sub <CODE>new</CODE> {

    my ( $<CODE>class</CODE>, $<CODE>filename</CODE> ) = @<CODE>_</CODE>;

    bless {
        <LITERALS>_debug_file</LITERALS>        => $<CODE>filename</CODE>,
        <LITERALS>_debug_file_opened</LITERALS> => 0,
        <LITERALS>_fh</LITERALS>                => undef,
    }, $<CODE>class</CODE>;
}

sub <CODE>really_open_debug_file</CODE> {

    my $<CODE>self</CODE>       = shift;
    my $<CODE>debug_file</CODE> = $<CODE>self</CODE>->{<LITERALS>_debug_file</LITERALS>};
    my $<CODE>fh</CODE>;
    unless ( $<CODE>fh</CODE> = <CODE>IO</CODE>::<CODE>File</CODE>-><CODE>new</CODE>("> $<CODE>debug_file</CODE>") ) {
        <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Warn</CODE>("<LITERALS>can</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>open</LITERALS> $<CODE>debug_file</CODE>: $!\n");
    }
    $<CODE>self</CODE>->{<LITERALS>_debug_file_opened</LITERALS>} = 1;
    $<CODE>self</CODE>->{<LITERALS>_fh</LITERALS>}                = $<CODE>fh</CODE>;
    print $<CODE>fh</CODE>
      "<LITERALS>Use</LITERALS> -<LITERALS>dump</LITERALS>-<LITERALS>token</LITERALS>-<LITERALS>types</LITERALS> (-<LITERALS>dtt</LITERALS>) <LITERALS>to</LITERALS> <LITERALS>get</LITERALS> <LITERALS>a</LITERALS> <LITERALS>list</LITERALS> <LITERALS>of</LITERALS> <LITERALS>token</LITERALS> <LITERALS>type</LITERALS> <LITERALS>codes</LITERALS>\n";
}

sub <CODE>close_debug_file</CODE> {

    my $<CODE>self</CODE> = shift;
    my $<CODE>fh</CODE>   = $<CODE>self</CODE>->{<LITERALS>_fh</LITERALS>};
    if ( $<CODE>self</CODE>->{<LITERALS>_debug_file_opened</LITERALS>} ) {

        eval { $<CODE>self</CODE>->{<LITERALS>_fh</LITERALS>}-><CODE>close</CODE>() };
    }
}

sub <CODE>write_debug_entry</CODE> {

    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>debug</COMMENTS> <COMMENTS>dump</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>modified</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>necessary</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>dump</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>-<COMMENTS>by</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>basis</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>written</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> .<COMMENTS>DEBUG</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>D</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>entered</COMMENTS>.
    my $<CODE>self</CODE>           = shift;
    my $<CODE>line_of_tokens</CODE> = shift;

    my $<CODE>input_line</CODE>        = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_text</LITERALS>};
    my $<CODE>rtoken_type</CODE>       = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rtoken_type</LITERALS>};
    my $<CODE>rtokens</CODE>           = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rtokens</LITERALS>};
    my $<CODE>rlevels</CODE>           = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rlevels</LITERALS>};
    my $<CODE>rslevels</CODE>          = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rslevels</LITERALS>};
    my $<CODE>rblock_type</CODE>       = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rblock_type</LITERALS>};
    my $<CODE>input_line_number</CODE> = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_number</LITERALS>};
    my $<CODE>line_type</CODE>         = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>};

    my ( $<CODE>j</CODE>, $<CODE>num</CODE> );

    my $<CODE>token_str</CODE>              = "$<CODE>input_line_number</CODE>: ";
    my $<CODE>reconstructed_original</CODE> = "$<CODE>input_line_number</CODE>: ";
    my $<CODE>block_str</CODE>              = "$<CODE>input_line_number</CODE>: ";

    #<COMMENTS>$token_str</COMMENTS> .= "<COMMENTS>$line_type</COMMENTS>: ";
    #<COMMENTS>$reconstructed_original</COMMENTS> .= "<COMMENTS>$line_type</COMMENTS>: ";

    my $<CODE>pattern</CODE>   = "";
    my @<CODE>next_char</CODE> = ( '"', '"' );
    my $<CODE>i_next</CODE>    = 0;
    unless ( $<CODE>self</CODE>->{<LITERALS>_debug_file_opened</LITERALS>} ) { $<CODE>self</CODE>-><CODE>really_open_debug_file</CODE>() }
    my $<CODE>fh</CODE> = $<CODE>self</CODE>->{<LITERALS>_fh</LITERALS>};

    for ( $<CODE>j</CODE> = 0 ; $<CODE>j</CODE> < @$<CODE>rtoken_type</CODE> ; $<CODE>j</CODE>++ ) {

        # <COMMENTS>testing</COMMENTS> <COMMENTS>patterns</COMMENTS>
        if ( $$<CODE>rtoken_type</CODE>[$<CODE>j</CODE>] eq '<LITERALS>k</LITERALS>' ) {
            $<CODE>pattern</CODE> .= $$<CODE>rtokens</CODE>[$<CODE>j</CODE>];
        }
        else {
            $<CODE>pattern</CODE> .= $$<CODE>rtoken_type</CODE>[$<CODE>j</CODE>];
        }
        $<CODE>reconstructed_original</CODE> .= $$<CODE>rtokens</CODE>[$<CODE>j</CODE>];
        $<CODE>block_str</CODE> .= "($$<CODE>rblock_type</CODE>[$<CODE>j</CODE>])";
        $<CODE>num</CODE> = length( $$<CODE>rtokens</CODE>[$<CODE>j</CODE>] );
        my $<CODE>type_str</CODE> = $$<CODE>rtoken_type</CODE>[$<CODE>j</CODE>];

        # <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>tokens</COMMENTS> (<COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>)
        # <COMMENTS>This</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>programming</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>made</COMMENTS>
        # <COMMENTS>because</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS>
        if ( $<CODE>type_str</CODE> eq ' ' ) {
            print $<CODE>fh</CODE> "<LITERALS>BLANK</LITERALS> <LITERALS>TOKEN</LITERALS> <LITERALS>on</LITERALS> <LITERALS>the</LITERALS> <LITERALS>next</LITERALS> <LITERALS>line</LITERALS>\n";
            $<CODE>type_str</CODE> = $<CODE>next_char</CODE>[$<CODE>i_next</CODE>];
            $<CODE>i_next</CODE>   = 1 - $<CODE>i_next</CODE>;
        }

        if ( length($<CODE>type_str</CODE>) == 1 ) {
            $<CODE>type_str</CODE> = $<CODE>type_str</CODE> x $<CODE>num</CODE>;
        }
        $<CODE>token_str</CODE> .= $<CODE>type_str</CODE>;
    }

    # <COMMENTS>Write</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>here</COMMENTS> ...
    # <COMMENTS>print</COMMENTS> <COMMENTS>$fh</COMMENTS> "<COMMENTS>$input_line</COMMENTS>\<COMMENTS>n</COMMENTS>";
    # <COMMENTS>print</COMMENTS> <COMMENTS>$fh</COMMENTS> "<COMMENTS>$pattern</COMMENTS>\<COMMENTS>n</COMMENTS>";
    print $<CODE>fh</CODE> "$<CODE>reconstructed_original</CODE>\n";
    print $<CODE>fh</CODE> "$<CODE>token_str</CODE>\n";

    #<COMMENTS>print</COMMENTS> <COMMENTS>$fh</COMMENTS> "<COMMENTS>$block_str</COMMENTS>\<COMMENTS>n</COMMENTS>";
}

#####################################################################
#
# <COMMENTS>The</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>LineBuffer</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>supplies</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>get_line</COMMENTS>()'
# <COMMENTS>method</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>returning</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>parsed</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>well</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS>
# '<COMMENTS>peek_ahead</COMMENTS>()' <COMMENTS>method</COMMENTS>
#
# <COMMENTS>The</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>parameter</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>get_line</COMMENTS>()' <COMMENTS>method</COMMENTS>
# <COMMENTS>which</COMMENTS> <COMMENTS>returns</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>parsed</COMMENTS>
#
#####################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineBuffer</CODE>;

sub <CODE>new</CODE> {

    my $<CODE>class</CODE>              = shift;
    my $<CODE>line_source_object</CODE> = shift;

    return bless {
        <LITERALS>_line_source_object</LITERALS> => $<CODE>line_source_object</CODE>,
        <LITERALS>_rlookahead_buffer</LITERALS>  => [],
    }, $<CODE>class</CODE>;
}

sub <CODE>peek_ahead</CODE> {
    my $<CODE>self</CODE>               = shift;
    my $<CODE>buffer_index</CODE>       = shift;
    my $<CODE>line</CODE>               = undef;
    my $<CODE>line_source_object</CODE> = $<CODE>self</CODE>->{<LITERALS>_line_source_object</LITERALS>};
    my $<CODE>rlookahead_buffer</CODE>  = $<CODE>self</CODE>->{<LITERALS>_rlookahead_buffer</LITERALS>};
    if ( $<CODE>buffer_index</CODE> < scalar(@$<CODE>rlookahead_buffer</CODE>) ) {
        $<CODE>line</CODE> = $$<CODE>rlookahead_buffer</CODE>[$<CODE>buffer_index</CODE>];
    }
    else {
        $<CODE>line</CODE> = $<CODE>line_source_object</CODE>-><CODE>get_line</CODE>();
        push( @$<CODE>rlookahead_buffer</CODE>, $<CODE>line</CODE> );
    }
    return $<CODE>line</CODE>;
}

sub <CODE>get_line</CODE> {
    my $<CODE>self</CODE>               = shift;
    my $<CODE>line</CODE>               = undef;
    my $<CODE>line_source_object</CODE> = $<CODE>self</CODE>->{<LITERALS>_line_source_object</LITERALS>};
    my $<CODE>rlookahead_buffer</CODE>  = $<CODE>self</CODE>->{<LITERALS>_rlookahead_buffer</LITERALS>};

    if ( scalar(@$<CODE>rlookahead_buffer</CODE>) ) {
        $<CODE>line</CODE> = shift @$<CODE>rlookahead_buffer</CODE>;
    }
    else {
        $<CODE>line</CODE> = $<CODE>line_source_object</CODE>-><CODE>get_line</CODE>();
    }
    return $<CODE>line</CODE>;
}

########################################################################
#
# <COMMENTS>the</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Tokenizer</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>essentially</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>filter</COMMENTS> <COMMENTS>which</COMMENTS>
# <COMMENTS>reads</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>provides</COMMENTS>
# <COMMENTS>corresponding</COMMENTS> <COMMENTS>tokenized</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>get_line</COMMENTS>() <COMMENTS>method</COMMENTS>.  <COMMENTS>Lines</COMMENTS>
# <COMMENTS>flow</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>source_object</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>caller</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
#
# <COMMENTS>source_object</COMMENTS> --> <COMMENTS>LineBuffer_object</COMMENTS> --> <COMMENTS>Tokenizer</COMMENTS> -->  <COMMENTS>calling</COMMENTS> <COMMENTS>routine</COMMENTS>
#   <COMMENTS>get_line</COMMENTS>()         <COMMENTS>get_line</COMMENTS>()           <COMMENTS>get_line</COMMENTS>()     <COMMENTS>line_of_tokens</COMMENTS>
#
# <COMMENTS>The</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>get_line</COMMENTS>() <COMMENTS>method</COMMENTS> <COMMENTS>which</COMMENTS>
# <COMMENTS>supplies</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> (<COMMENTS>a</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>string</COMMENTS>) <COMMENTS>perl</COMMENTS> <COMMENTS>call</COMMENTS>.
# <COMMENTS>The</COMMENTS> <COMMENTS>LineBuffer</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>created</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>Tokenizer</COMMENTS>.
# <COMMENTS>The</COMMENTS> <COMMENTS>Tokenizer</COMMENTS> <COMMENTS>returns</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>data</COMMENTS> <COMMENTS>structure</COMMENTS> '<COMMENTS>line_of_tokens</COMMENTS>'
# <COMMENTS>containing</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>tokenized</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>get_line</COMMENTS>() <COMMENTS>method</COMMENTS>.
#
# <COMMENTS>WARNING</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>real</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>yet</COMMENTS>.  <COMMENTS>Only</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS>.
#
########################################################################

package <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Tokenizer</CODE>;

<CODE>BEGIN</CODE> {

    # <COMMENTS>Caution</COMMENTS>: <COMMENTS>these</COMMENTS> <COMMENTS>debug</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>produce</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>lot</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>output</COMMENTS>
    # <COMMENTS>They</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>0</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>debugging</COMMENTS> <COMMENTS>small</COMMENTS> <COMMENTS>scripts</COMMENTS>

    use <CODE>constant</CODE> <LITERALS>TOKENIZER_DEBUG_FLAG_EXPECT</LITERALS>   => 0;
    use <CODE>constant</CODE> <LITERALS>TOKENIZER_DEBUG_FLAG_NSCAN</LITERALS>    => 0;
    use <CODE>constant</CODE> <LITERALS>TOKENIZER_DEBUG_FLAG_QUOTE</LITERALS>    => 0;
    use <CODE>constant</CODE> <LITERALS>TOKENIZER_DEBUG_FLAG_SCAN_ID</LITERALS>  => 0;
    use <CODE>constant</CODE> <LITERALS>TOKENIZER_DEBUG_FLAG_TOKENIZE</LITERALS> => 0;

    my $<CODE>debug_warning</CODE> = sub {
        print <CODE>STDOUT</CODE> "<LITERALS>TOKENIZER_DEBUGGING</LITERALS> <LITERALS>with</LITERALS> <LITERALS>key</LITERALS> $<CODE>_</CODE>[0]\n";
    };

    <CODE>TOKENIZER_DEBUG_FLAG_EXPECT</CODE>   && $<CODE>debug_warning</CODE>->('<LITERALS>EXPECT</LITERALS>');
    <CODE>TOKENIZER_DEBUG_FLAG_NSCAN</CODE>    && $<CODE>debug_warning</CODE>->('<LITERALS>NSCAN</LITERALS>');
    <CODE>TOKENIZER_DEBUG_FLAG_QUOTE</CODE>    && $<CODE>debug_warning</CODE>->('<LITERALS>QUOTE</LITERALS>');
    <CODE>TOKENIZER_DEBUG_FLAG_SCAN_ID</CODE>  && $<CODE>debug_warning</CODE>->('<LITERALS>SCAN_ID</LITERALS>');
    <CODE>TOKENIZER_DEBUG_FLAG_TOKENIZE</CODE> && $<CODE>debug_warning</CODE>->('<LITERALS>TOKENIZE</LITERALS>');

}

use <CODE>Carp</CODE>;

# <COMMENTS>PACKAGE</COMMENTS> <COMMENTS>VARIABLES</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>processing</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>entire</COMMENTS> <COMMENTS>FILE</COMMENTS>.
use <CODE>vars</CODE> qw{
  $<CODE>tokenizer_self</CODE>

  $<CODE>last_nonblank_token</CODE>
  $<CODE>last_nonblank_type</CODE>
  $<CODE>last_nonblank_block_type</CODE>
  $<CODE>statement_type</CODE>
  $<CODE>in_attribute_list</CODE>
  $<CODE>current_package</CODE>
  $<CODE>context</CODE>

  %<CODE>is_constant</CODE>
  %<CODE>is_user_function</CODE>
  %<CODE>user_function_prototype</CODE>
  %<CODE>is_block_function</CODE>
  %<CODE>is_block_list_function</CODE>
  %<CODE>saw_function_definition</CODE>

  $<CODE>brace_depth</CODE>
  $<CODE>paren_depth</CODE>
  $<CODE>square_bracket_depth</CODE>

  @<CODE>current_depth</CODE>
  @<CODE>total_depth</CODE>
  $<CODE>total_depth</CODE>
  @<CODE>nesting_sequence_number</CODE>
  @<CODE>current_sequence_number</CODE>
  @<CODE>paren_type</CODE>
  @<CODE>paren_semicolon_count</CODE>
  @<CODE>paren_structural_type</CODE>
  @<CODE>brace_type</CODE>
  @<CODE>brace_structural_type</CODE>
  @<CODE>brace_context</CODE>
  @<CODE>brace_package</CODE>
  @<CODE>square_bracket_type</CODE>
  @<CODE>square_bracket_structural_type</CODE>
  @<CODE>depth_array</CODE>
  @<CODE>nested_ternary_flag</CODE>
  @<CODE>nested_statement_type</CODE>
  @<CODE>starting_line_of_current_depth</CODE>
};

# <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>CONSTANTS</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>routines</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>package</COMMENTS>
use <CODE>vars</CODE> qw{
  %<CODE>is_indirect_object_taker</CODE>
  %<CODE>is_block_operator</CODE>
  %<CODE>expecting_operator_token</CODE>
  %<CODE>expecting_operator_types</CODE>
  %<CODE>expecting_term_types</CODE>
  %<CODE>expecting_term_token</CODE>
  %<CODE>is_digraph</CODE>
  %<CODE>is_file_test_operator</CODE>
  %<CODE>is_trigraph</CODE>
  %<CODE>is_valid_token_type</CODE>
  %<CODE>is_keyword</CODE>
  %<CODE>is_code_block_token</CODE>
  %<CODE>really_want_term</CODE>
  @<CODE>opening_brace_names</CODE>
  @<CODE>closing_brace_names</CODE>
  %<CODE>is_keyword_taking_list</CODE>
  %<CODE>is_q_qq_qw_qx_qr_s_y_tr_m</CODE>
};

# <COMMENTS>possible</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>operator_expected</COMMENTS>()
use <CODE>constant</CODE> <LITERALS>TERM</LITERALS>     => -1;
use <CODE>constant</CODE> <LITERALS>UNKNOWN</LITERALS>  => 0;
use <CODE>constant</CODE> <LITERALS>OPERATOR</LITERALS> => 1;

# <COMMENTS>possible</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>context</COMMENTS>
use <CODE>constant</CODE> <LITERALS>SCALAR_CONTEXT</LITERALS>  => -1;
use <CODE>constant</CODE> <LITERALS>UNKNOWN_CONTEXT</LITERALS> => 0;
use <CODE>constant</CODE> <LITERALS>LIST_CONTEXT</LITERALS>    => 1;

# <COMMENTS>Maximum</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>little</COMMENTS> <COMMENTS>messages</COMMENTS>; <COMMENTS>probably</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>changed</COMMENTS>.
use <CODE>constant</CODE> <LITERALS>MAX_NAG_MESSAGES</LITERALS> => 6;

{

    # <COMMENTS>methods</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>instances</COMMENTS>
    my $<CODE>_count</CODE> = 0;
    sub <CODE>get_count</CODE>        { $<CODE>_count</CODE>; }
    sub <CODE>_increment_count</CODE> { ++$<CODE>_count</CODE> }
    sub <CODE>_decrement_count</CODE> { --$<CODE>_count</CODE> }
}

sub <CODE>DESTROY</CODE> {
    $<CODE>_</CODE>[0]-><CODE>_decrement_count</CODE>();
}

sub <CODE>new</CODE> {

    my $<CODE>class</CODE> = shift;

    # <COMMENTS>Note</COMMENTS>: '<COMMENTS>tabs</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>indent_columns</COMMENTS>' <COMMENTS>are</COMMENTS> <COMMENTS>temporary</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>removed</COMMENTS> <COMMENTS>asap</COMMENTS>
    my %<CODE>defaults</CODE> = (
        <LITERALS>source_object</LITERALS>        => undef,
        <LITERALS>debugger_object</LITERALS>      => undef,
        <LITERALS>diagnostics_object</LITERALS>   => undef,
        <LITERALS>logger_object</LITERALS>        => undef,
        <LITERALS>starting_level</LITERALS>       => undef,
        <LITERALS>indent_columns</LITERALS>       => 4,
        <LITERALS>tabsize</LITERALS>              => 8,
        <LITERALS>look_for_hash_bang</LITERALS>   => 0,
        <LITERALS>trim_qw</LITERALS>              => 1,
        <LITERALS>look_for_autoloader</LITERALS>  => 1,
        <LITERALS>look_for_selfloader</LITERALS>  => 1,
        <LITERALS>starting_line_number</LITERALS> => 1,
        <LITERALS>extended_syntax</LITERALS>      => 0,
    );
    my %<CODE>args</CODE> = ( %<CODE>defaults</CODE>, @<CODE>_</CODE> );

    # <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>get_line</COMMENTS>() <COMMENTS>method</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>supply</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>lines</COMMENTS>
    my $<CODE>source_object</CODE> = $<CODE>args</CODE>{<LITERALS>source_object</LITERALS>};

    # <COMMENTS>we</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>get_line</COMMENTS>() <COMMENTS>and</COMMENTS> <COMMENTS>peek_ahead</COMMENTS>() <COMMENTS>method</COMMENTS>
    my $<CODE>line_buffer_object</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineBuffer</CODE>-><CODE>new</CODE>($<CODE>source_object</CODE>);

    # <COMMENTS>Tokenizer</COMMENTS> <COMMENTS>state</COMMENTS> <COMMENTS>data</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>follows</COMMENTS>:
    # <COMMENTS>_rhere_target_list</COMMENTS>    <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS> <COMMENTS>targets</COMMENTS>
    # <COMMENTS>_here_doc_target</COMMENTS>      <COMMENTS>the</COMMENTS> <COMMENTS>target</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>document</COMMENTS>
    # <COMMENTS>_here_quote_character</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS> <COMMENTS>quoting</COMMENTS> (" ' ` <COMMENTS>or</COMMENTS> <COMMENTS>none</COMMENTS>)
    #                       <COMMENTS>to</COMMENTS> <COMMENTS>determine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>interpolation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>done</COMMENTS>
    # <COMMENTS>_quote_target</COMMENTS>         <COMMENTS>character</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>seek</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>chasing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS>
    # <COMMENTS>_line_start_quote</COMMENTS>     <COMMENTS>line</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>started</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>quote</COMMENTS>
    # <COMMENTS>_in_here_doc</COMMENTS>          <COMMENTS>flag</COMMENTS> <COMMENTS>indicating</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS>
    # <COMMENTS>_in_pod</COMMENTS>               <COMMENTS>flag</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>documentation</COMMENTS>
    # <COMMENTS>_in_error</COMMENTS>             <COMMENTS>flag</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>saw</COMMENTS> <COMMENTS>severe</COMMENTS> <COMMENTS>error</COMMENTS> (<COMMENTS>binary</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>script</COMMENTS>)
    # <COMMENTS>_in_data</COMMENTS>              <COMMENTS>flag</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>__DATA__</COMMENTS> <COMMENTS>section</COMMENTS>
    # <COMMENTS>_in_end</COMMENTS>               <COMMENTS>flag</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>__END__</COMMENTS> <COMMENTS>section</COMMENTS>
    # <COMMENTS>_in_format</COMMENTS>            <COMMENTS>flag</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>format</COMMENTS> <COMMENTS>description</COMMENTS>
    # <COMMENTS>_in_attribute_list</COMMENTS>    <COMMENTS>flag</COMMENTS> <COMMENTS>telling</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>attributes</COMMENTS>
    # <COMMENTS>_in_quote</COMMENTS>             <COMMENTS>flag</COMMENTS> <COMMENTS>telling</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>chasing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS>
    # <COMMENTS>_starting_level</COMMENTS>       <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS>
    # <COMMENTS>_line_buffer_object</COMMENTS>   <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>get_line</COMMENTS>() <COMMENTS>method</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>supply</COMMENTS> <COMMENTS>source</COMMENTS> <COMMENTS>code</COMMENTS>
    # <COMMENTS>_diagnostics_object</COMMENTS>   <COMMENTS>place</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>debugging</COMMENTS> <COMMENTS>information</COMMENTS>
    # <COMMENTS>_unexpected_error_count</COMMENTS>  <COMMENTS>error</COMMENTS> <COMMENTS>count</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>limit</COMMENTS> <COMMENTS>output</COMMENTS>
    # <COMMENTS>_lower_case_labels_at</COMMENTS>  <COMMENTS>line</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>lower</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>labels</COMMENTS> <COMMENTS>seen</COMMENTS>
    $<CODE>tokenizer_self</CODE> = {
        <LITERALS>_rhere_target_list</LITERALS>                  => [],
        <LITERALS>_in_here_doc</LITERALS>                        => 0,
        <LITERALS>_here_doc_target</LITERALS>                    => "",
        <LITERALS>_here_quote_character</LITERALS>               => "",
        <LITERALS>_in_data</LITERALS>                            => 0,
        <LITERALS>_in_end</LITERALS>                             => 0,
        <LITERALS>_in_format</LITERALS>                          => 0,
        <LITERALS>_in_error</LITERALS>                           => 0,
        <LITERALS>_in_pod</LITERALS>                             => 0,
        <LITERALS>_in_attribute_list</LITERALS>                  => 0,
        <LITERALS>_in_quote</LITERALS>                           => 0,
        <LITERALS>_quote_target</LITERALS>                       => "",
        <LITERALS>_line_start_quote</LITERALS>                   => -1,
        <LITERALS>_starting_level</LITERALS>                     => $<CODE>args</CODE>{<LITERALS>starting_level</LITERALS>},
        <LITERALS>_know_starting_level</LITERALS>                => defined( $<CODE>args</CODE>{<LITERALS>starting_level</LITERALS>} ),
        <LITERALS>_tabsize</LITERALS>                            => $<CODE>args</CODE>{<LITERALS>tabsize</LITERALS>},
        <LITERALS>_indent_columns</LITERALS>                     => $<CODE>args</CODE>{<LITERALS>indent_columns</LITERALS>},
        <LITERALS>_look_for_hash_bang</LITERALS>                 => $<CODE>args</CODE>{<LITERALS>look_for_hash_bang</LITERALS>},
        <LITERALS>_trim_qw</LITERALS>                            => $<CODE>args</CODE>{<LITERALS>trim_qw</LITERALS>},
        <LITERALS>_continuation_indentation</LITERALS>           => $<CODE>args</CODE>{<LITERALS>continuation_indentation</LITERALS>},
        <LITERALS>_outdent_labels</LITERALS>                     => $<CODE>args</CODE>{<LITERALS>outdent_labels</LITERALS>},
        <LITERALS>_last_line_number</LITERALS>                   => $<CODE>args</CODE>{<LITERALS>starting_line_number</LITERALS>} - 1,
        <LITERALS>_saw_perl_dash_P</LITERALS>                    => 0,
        <LITERALS>_saw_perl_dash_w</LITERALS>                    => 0,
        <LITERALS>_saw_use_strict</LITERALS>                     => 0,
        <LITERALS>_saw_v_string</LITERALS>                       => 0,
        <LITERALS>_look_for_autoloader</LITERALS>                => $<CODE>args</CODE>{<LITERALS>look_for_autoloader</LITERALS>},
        <LITERALS>_look_for_selfloader</LITERALS>                => $<CODE>args</CODE>{<LITERALS>look_for_selfloader</LITERALS>},
        <LITERALS>_saw_autoloader</LITERALS>                     => 0,
        <LITERALS>_saw_selfloader</LITERALS>                     => 0,
        <LITERALS>_saw_hash_bang</LITERALS>                      => 0,
        <LITERALS>_saw_end</LITERALS>                            => 0,
        <LITERALS>_saw_data</LITERALS>                           => 0,
        <LITERALS>_saw_negative_indentation</LITERALS>           => 0,
        <LITERALS>_started_tokenizing</LITERALS>                 => 0,
        <LITERALS>_line_buffer_object</LITERALS>                 => $<CODE>line_buffer_object</CODE>,
        <LITERALS>_debugger_object</LITERALS>                    => $<CODE>args</CODE>{<LITERALS>debugger_object</LITERALS>},
        <LITERALS>_diagnostics_object</LITERALS>                 => $<CODE>args</CODE>{<LITERALS>diagnostics_object</LITERALS>},
        <LITERALS>_logger_object</LITERALS>                      => $<CODE>args</CODE>{<LITERALS>logger_object</LITERALS>},
        <LITERALS>_unexpected_error_count</LITERALS>             => 0,
        <LITERALS>_started_looking_for_here_target_at</LITERALS> => 0,
        <LITERALS>_nearly_matched_here_target_at</LITERALS>      => undef,
        <LITERALS>_line_text</LITERALS>                          => "",
        <LITERALS>_rlower_case_labels_at</LITERALS>              => undef,
        <LITERALS>_extended_syntax</LITERALS>                    => $<CODE>args</CODE>{<LITERALS>extended_syntax</LITERALS>},
    };

    <CODE>prepare_for_a_new_file</CODE>();
    <CODE>find_starting_indentation_level</CODE>();

    bless $<CODE>tokenizer_self</CODE>, $<CODE>class</CODE>;

    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>full</COMMENTS> <COMMENTS>class</COMMENTS> <COMMENTS>yet</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>die</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>attempt</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>made</COMMENTS> <COMMENTS>to</COMMENTS>
    # <COMMENTS>create</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>object</COMMENTS>.

    if ( <CODE>_increment_count</CODE>() > 1 ) {
        <CODE>confess</CODE>
"<LITERALS>Attempt</LITERALS> <LITERALS>to</LITERALS> <LITERALS>create</LITERALS> <LITERALS>more</LITERALS> <LITERALS>than</LITERALS> <LITERALS>1</LITERALS> <LITERALS>object</LITERALS> <LITERALS>in</LITERALS> $<CODE>class</CODE>, <LITERALS>which</LITERALS> <LITERALS>is</LITERALS> <LITERALS>not</LITERALS> <LITERALS>a</LITERALS> <LITERALS>true</LITERALS> <LITERALS>class</LITERALS> <LITERALS>yet</LITERALS>\n";
    }

    return $<CODE>tokenizer_self</CODE>;

}

# <COMMENTS>interface</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Logger</COMMENTS> <COMMENTS>routines</COMMENTS>
sub <CODE>warning</CODE> {
    my $<CODE>logger_object</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_logger_object</LITERALS>};
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>warning</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>complain</CODE> {
    my $<CODE>logger_object</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_logger_object</LITERALS>};
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>complain</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>write_logfile_entry</CODE> {
    my $<CODE>logger_object</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_logger_object</LITERALS>};
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>write_logfile_entry</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>interrupt_logfile</CODE> {
    my $<CODE>logger_object</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_logger_object</LITERALS>};
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>interrupt_logfile</CODE>();
    }
}

sub <CODE>resume_logfile</CODE> {
    my $<CODE>logger_object</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_logger_object</LITERALS>};
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>resume_logfile</CODE>();
    }
}

sub <CODE>increment_brace_error</CODE> {
    my $<CODE>logger_object</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_logger_object</LITERALS>};
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>increment_brace_error</CODE>();
    }
}

sub <CODE>report_definite_bug</CODE> {
    my $<CODE>logger_object</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_logger_object</LITERALS>};
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>report_definite_bug</CODE>();
    }
}

sub <CODE>brace_warning</CODE> {
    my $<CODE>logger_object</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_logger_object</LITERALS>};
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>brace_warning</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>get_saw_brace_error</CODE> {
    my $<CODE>logger_object</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_logger_object</LITERALS>};
    if ($<CODE>logger_object</CODE>) {
        $<CODE>logger_object</CODE>-><CODE>get_saw_brace_error</CODE>();
    }
    else {
        0;
    }
}

# <COMMENTS>interface</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Diagnostics</COMMENTS> <COMMENTS>routines</COMMENTS>
sub <CODE>write_diagnostics</CODE> {
    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_diagnostics_object</LITERALS>} ) {
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_diagnostics_object</LITERALS>}-><CODE>write_diagnostics</CODE>(@<CODE>_</CODE>);
    }
}

sub <CODE>report_tokenization_errors</CODE> {

    my $<CODE>self</CODE> = shift;

    my $<CODE>level</CODE> = <CODE>get_indentation_level</CODE>();
    if ( $<CODE>level</CODE> != $<CODE>tokenizer_self</CODE>->{<LITERALS>_starting_level</LITERALS>} ) {
        <CODE>warning</CODE>("<LITERALS>final</LITERALS> <LITERALS>indentation</LITERALS> <LITERALS>level</LITERALS>: $<CODE>level</CODE>\n");
    }

    <CODE>check_final_nesting_depths</CODE>();

    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_look_for_hash_bang</LITERALS>}
        && !$<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_hash_bang</LITERALS>} )
    {
        <CODE>warning</CODE>(
            "<LITERALS>hit</LITERALS> <LITERALS>EOF</LITERALS> <LITERALS>without</LITERALS> <LITERALS>seeing</LITERALS> <LITERALS>hash</LITERALS>-<LITERALS>bang</LITERALS> <LITERALS>line</LITERALS>; <LITERALS>maybe</LITERALS> <LITERALS>don</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>need</LITERALS> -<LITERALS>x</LITERALS>?\n");
    }

    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_format</LITERALS>} ) {
        <CODE>warning</CODE>("<LITERALS>hit</LITERALS> <LITERALS>EOF</LITERALS> <LITERALS>while</LITERALS> <LITERALS>in</LITERALS> <LITERALS>format</LITERALS> <LITERALS>description</LITERALS>\n");
    }

    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_pod</LITERALS>} ) {

        # <COMMENTS>Just</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>log</COMMENTS> <COMMENTS>entry</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>__END__</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>__DATA__</COMMENTS>
        # <COMMENTS>because</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>happens</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>often</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>likely</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS>
        # <COMMENTS>a</COMMENTS> <COMMENTS>parsing</COMMENTS> <COMMENTS>error</COMMENTS>.
        if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_data</LITERALS>} || $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_end</LITERALS>} ) {
            <CODE>write_logfile_entry</CODE>(
"<LITERALS>hit</LITERALS> <LITERALS>eof</LITERALS> <LITERALS>while</LITERALS> <LITERALS>in</LITERALS> <LITERALS>pod</LITERALS> <LITERALS>documentation</LITERALS> (<LITERALS>no</LITERALS> =<LITERALS>cut</LITERALS> <LITERALS>seen</LITERALS>)\n\t<LITERALS>this</LITERALS> <LITERALS>can</LITERALS> <LITERALS>cause</LITERALS> <LITERALS>trouble</LITERALS> <LITERALS>with</LITERALS> <LITERALS>some</LITERALS> <LITERALS>pod</LITERALS> <LITERALS>utilities</LITERALS>\n"
            );
        }

        else {
            <CODE>complain</CODE>(
"<LITERALS>hit</LITERALS> <LITERALS>eof</LITERALS> <LITERALS>while</LITERALS> <LITERALS>in</LITERALS> <LITERALS>pod</LITERALS> <LITERALS>documentation</LITERALS> (<LITERALS>no</LITERALS> =<LITERALS>cut</LITERALS> <LITERALS>seen</LITERALS>)\n\t<LITERALS>this</LITERALS> <LITERALS>can</LITERALS> <LITERALS>cause</LITERALS> <LITERALS>trouble</LITERALS> <LITERALS>with</LITERALS> <LITERALS>some</LITERALS> <LITERALS>pod</LITERALS> <LITERALS>utilities</LITERALS>\n"
            );
        }

    }

    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_here_doc</LITERALS>} ) {
        my $<CODE>here_doc_target</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_here_doc_target</LITERALS>};
        my $<CODE>started_looking_for_here_target_at</CODE> =
          $<CODE>tokenizer_self</CODE>->{<LITERALS>_started_looking_for_here_target_at</LITERALS>};
        if ($<CODE>here_doc_target</CODE>) {
            <CODE>warning</CODE>(
"<LITERALS>hit</LITERALS> <LITERALS>EOF</LITERALS> <LITERALS>in</LITERALS> <LITERALS>here</LITERALS> <LITERALS>document</LITERALS> <LITERALS>starting</LITERALS> <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> $<CODE>started_looking_for_here_target_at</CODE> <LITERALS>with</LITERALS> <LITERALS>target</LITERALS>: $<CODE>here_doc_target</CODE>\n"
            );
        }
        else {
            <CODE>warning</CODE>(
"<LITERALS>hit</LITERALS> <LITERALS>EOF</LITERALS> <LITERALS>in</LITERALS> <LITERALS>here</LITERALS> <LITERALS>document</LITERALS> <LITERALS>starting</LITERALS> <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> $<CODE>started_looking_for_here_target_at</CODE> <LITERALS>with</LITERALS> <LITERALS>empty</LITERALS> <LITERALS>target</LITERALS> <LITERALS>string</LITERALS>\n"
            );
        }
        my $<CODE>nearly_matched_here_target_at</CODE> =
          $<CODE>tokenizer_self</CODE>->{<LITERALS>_nearly_matched_here_target_at</LITERALS>};
        if ($<CODE>nearly_matched_here_target_at</CODE>) {
            <CODE>warning</CODE>(
"<LITERALS>NOTE</LITERALS>: <LITERALS>almost</LITERALS> <LITERALS>matched</LITERALS> <LITERALS>at</LITERALS> <LITERALS>input</LITERALS> <LITERALS>line</LITERALS> $<CODE>nearly_matched_here_target_at</CODE> <LITERALS>except</LITERALS> <LITERALS>for</LITERALS> <LITERALS>whitespace</LITERALS>\n"
            );
        }
    }

    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_quote</LITERALS>} ) {
        my $<CODE>line_start_quote</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_start_quote</LITERALS>};
        my $<CODE>quote_target</CODE>     = $<CODE>tokenizer_self</CODE>->{<LITERALS>_quote_target</LITERALS>};
        my $<CODE>what</CODE> =
          ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_attribute_list</LITERALS>} )
          ? "<LITERALS>attribute</LITERALS> <LITERALS>list</LITERALS>"
          : "<LITERALS>quote</LITERALS>/<LITERALS>pattern</LITERALS>";
        <CODE>warning</CODE>(
"<LITERALS>hit</LITERALS> <LITERALS>EOF</LITERALS> <LITERALS>seeking</LITERALS> <LITERALS>end</LITERALS> <LITERALS>of</LITERALS> $<CODE>what</CODE> <LITERALS>starting</LITERALS> <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> $<CODE>line_start_quote</CODE> <LITERALS>ending</LITERALS> <LITERALS>in</LITERALS> $<CODE>quote_target</CODE>\n"
        );
    }

    unless ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_perl_dash_w</LITERALS>} ) {
        if ( $] < 5.006 ) {
            <CODE>write_logfile_entry</CODE>("<LITERALS>Suggest</LITERALS> <LITERALS>including</LITERALS> '-<LITERALS>w</LITERALS> <LITERALS>parameter</LITERALS>'\n");
        }
        else {
            <CODE>write_logfile_entry</CODE>("<LITERALS>Suggest</LITERALS> <LITERALS>including</LITERALS> '<LITERALS>use</LITERALS> <LITERALS>warnings</LITERALS>;'\n");
        }
    }

    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_perl_dash_P</LITERALS>} ) {
        <CODE>write_logfile_entry</CODE>("<LITERALS>Use</LITERALS> <LITERALS>of</LITERALS> -<LITERALS>P</LITERALS> <LITERALS>parameter</LITERALS> <LITERALS>for</LITERALS> <LITERALS>defines</LITERALS> <LITERALS>is</LITERALS> <LITERALS>discouraged</LITERALS>\n");
    }

    unless ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_use_strict</LITERALS>} ) {
        <CODE>write_logfile_entry</CODE>("<LITERALS>Suggest</LITERALS> <LITERALS>including</LITERALS> '<LITERALS>use</LITERALS> <LITERALS>strict</LITERALS>;'\n");
    }

    # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>suggested</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>labels</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>upper</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>character</COMMENTS>
    # <COMMENTS>for</COMMENTS> <COMMENTS>legibility</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>breakage</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>introduced</COMMENTS>
    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_rlower_case_labels_at</LITERALS>} ) {
        my @<CODE>lower_case_labels_at</CODE> =
          @{ $<CODE>tokenizer_self</CODE>->{<LITERALS>_rlower_case_labels_at</LITERALS>} };
        <CODE>write_logfile_entry</CODE>(
            "<LITERALS>Suggest</LITERALS> <LITERALS>using</LITERALS> <LITERALS>upper</LITERALS> <LITERALS>case</LITERALS> <LITERALS>characters</LITERALS> <LITERALS>in</LITERALS> <LITERALS>label</LITERALS>(<LITERALS>s</LITERALS>)\n");
        local $" = ')(';
        <CODE>write_logfile_entry</CODE>("  <LITERALS>defined</LITERALS> <LITERALS>at</LITERALS> <LITERALS>line</LITERALS>(<LITERALS>s</LITERALS>): (@<CODE>lower_case_labels_at</CODE>)\n");
    }
}

sub <CODE>report_v_string</CODE> {

    # <COMMENTS>warn</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS>
    my $<CODE>tok</CODE> = shift;
    unless ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_v_string</LITERALS>} ) {
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_v_string</LITERALS>} = $<CODE>tokenizer_self</CODE>->{<LITERALS>_last_line_number</LITERALS>};
    }
    if ( $] < 5.006 ) {
        <CODE>warning</CODE>(
"<LITERALS>Found</LITERALS> <LITERALS>v</LITERALS>-<LITERALS>string</LITERALS> '$<CODE>tok</CODE>' <LITERALS>but</LITERALS> <LITERALS>v</LITERALS>-<LITERALS>strings</LITERALS> <LITERALS>are</LITERALS> <LITERALS>not</LITERALS> <LITERALS>implemented</LITERALS> <LITERALS>in</LITERALS> <LITERALS>your</LITERALS> <LITERALS>version</LITERALS> <LITERALS>of</LITERALS> <LITERALS>perl</LITERALS>; <LITERALS>see</LITERALS> <LITERALS>Camel</LITERALS> <LITERALS>3</LITERALS> <LITERALS>book</LITERALS> <LITERALS>ch</LITERALS> <LITERALS>2</LITERALS>\n"
        );
    }
}

sub <CODE>get_input_line_number</CODE> {
    return $<CODE>tokenizer_self</CODE>->{<LITERALS>_last_line_number</LITERALS>};
}

# <COMMENTS>returns</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>tokenized</COMMENTS> <COMMENTS>line</COMMENTS>
sub <CODE>get_line</CODE> {

    my $<CODE>self</CODE> = shift;

    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$tokenizer_self</COMMENTS>, <COMMENTS>$brace_depth</COMMENTS>,
    # <COMMENTS>$square_bracket_depth</COMMENTS>, <COMMENTS>$paren_depth</COMMENTS>

    my $<CODE>input_line</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_buffer_object</LITERALS>}-><CODE>get_line</CODE>();
    $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_text</LITERALS>} = $<CODE>input_line</CODE>;

    return undef unless ($<CODE>input_line</CODE>);

    my $<CODE>input_line_number</CODE> = ++$<CODE>tokenizer_self</CODE>->{<LITERALS>_last_line_number</LITERALS>};

    # <COMMENTS>Find</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>terminate</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>including</COMMENTS> <COMMENTS>any</COMMENTS>
    # <COMMENTS>control</COMMENTS> <COMMENTS>r</COMMENTS>
    my $<CODE>input_line_separator</CODE> = "";
    if ( chomp($<CODE>input_line</CODE>) ) { $<CODE>input_line_separator</CODE> = $/ }

    # <COMMENTS>TODO</COMMENTS>: <COMMENTS>what</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>included</COMMENTS> <COMMENTS>here</COMMENTS>?
    if ( $<CODE>input_line</CODE> =~ s/((\r|\035|\032)+)$// ) {
        $<CODE>input_line_separator</CODE> = $<CODE>2</CODE> . $<CODE>input_line_separator</CODE>;
    }

    # <COMMENTS>for</COMMENTS> <COMMENTS>backwards</COMMENTS> <COMMENTS>compatibility</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>terminated</COMMENTS> <COMMENTS>with</COMMENTS>
    # <COMMENTS>a</COMMENTS> <COMMENTS>newline</COMMENTS> <COMMENTS>character</COMMENTS>
    $<CODE>input_line</CODE> .= "\n";
    $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_text</LITERALS>} = $<CODE>input_line</CODE>;    # <COMMENTS>update</COMMENTS>

    # <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>data</COMMENTS> <COMMENTS>structure</COMMENTS> <COMMENTS>describing</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>returned</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>caller</COMMENTS>.

    # <COMMENTS>_line_type</COMMENTS> <COMMENTS>codes</COMMENTS> <COMMENTS>are</COMMENTS>:
    #   <COMMENTS>SYSTEM</COMMENTS>         - <COMMENTS>system</COMMENTS>-<COMMENTS>specific</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>hash</COMMENTS>-<COMMENTS>bang</COMMENTS> <COMMENTS>line</COMMENTS>
    #   <COMMENTS>CODE</COMMENTS>           - <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>code</COMMENTS> (<COMMENTS>including</COMMENTS> <COMMENTS>comments</COMMENTS>)
    #   <COMMENTS>POD_START</COMMENTS>      - <COMMENTS>line</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>pod</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> '=<COMMENTS>head</COMMENTS>'
    #   <COMMENTS>POD</COMMENTS>            - <COMMENTS>pod</COMMENTS> <COMMENTS>documentation</COMMENTS> <COMMENTS>text</COMMENTS>
    #   <COMMENTS>POD_END</COMMENTS>        - <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>section</COMMENTS>, '=<COMMENTS>cut</COMMENTS>'
    #   <COMMENTS>HERE</COMMENTS>           - <COMMENTS>text</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>document</COMMENTS>
    #   <COMMENTS>HERE_END</COMMENTS>       - <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS> (<COMMENTS>target</COMMENTS> <COMMENTS>word</COMMENTS>)
    #   <COMMENTS>FORMAT</COMMENTS>         - <COMMENTS>format</COMMENTS> <COMMENTS>section</COMMENTS>
    #   <COMMENTS>FORMAT_END</COMMENTS>     - <COMMENTS>last</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>format</COMMENTS> <COMMENTS>section</COMMENTS>, '.'
    #   <COMMENTS>DATA_START</COMMENTS>     - <COMMENTS>__DATA__</COMMENTS> <COMMENTS>line</COMMENTS>
    #   <COMMENTS>DATA</COMMENTS>           - <COMMENTS>unidentified</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>__DATA__</COMMENTS>
    #   <COMMENTS>END_START</COMMENTS>      - <COMMENTS>__END__</COMMENTS> <COMMENTS>line</COMMENTS>
    #   <COMMENTS>END</COMMENTS>            - <COMMENTS>unidentified</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>__END__</COMMENTS>
    #   <COMMENTS>ERROR</COMMENTS>          - <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>big</COMMENTS> <COMMENTS>trouble</COMMENTS>, <COMMENTS>probably</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>script</COMMENTS>

    # <COMMENTS>Other</COMMENTS> <COMMENTS>variables</COMMENTS>:
    #   <COMMENTS>_curly_brace_depth</COMMENTS>     - <COMMENTS>depth</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS>
    #   <COMMENTS>_square_bracket_depth</COMMENTS>  - <COMMENTS>depth</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>square</COMMENTS> <COMMENTS>brackets</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS>
    #   <COMMENTS>_paren_depth</COMMENTS>           - <COMMENTS>depth</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS>
    #   <COMMENTS>_starting_in_quote</COMMENTS>     - <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>continues</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>multi</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>quote</COMMENTS>
    #                            (<COMMENTS>so</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>trim</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>blanks</COMMENTS>!)
    #   <COMMENTS>_ending_in_quote</COMMENTS>       - <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>multi</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>quote</COMMENTS>
    #                            (<COMMENTS>so</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>trim</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>blanks</COMMENTS>!)
    my $<CODE>line_of_tokens</CODE> = {
        <LITERALS>_line_type</LITERALS>                 => '<LITERALS>EOF</LITERALS>',
        <LITERALS>_line_text</LITERALS>                 => $<CODE>input_line</CODE>,
        <LITERALS>_line_number</LITERALS>               => $<CODE>input_line_number</CODE>,
        <LITERALS>_rtoken_type</LITERALS>               => undef,
        <LITERALS>_rtokens</LITERALS>                   => undef,
        <LITERALS>_rlevels</LITERALS>                   => undef,
        <LITERALS>_rslevels</LITERALS>                  => undef,
        <LITERALS>_rblock_type</LITERALS>               => undef,
        <LITERALS>_rcontainer_type</LITERALS>           => undef,
        <LITERALS>_rcontainer_environment</LITERALS>    => undef,
        <LITERALS>_rtype_sequence</LITERALS>            => undef,
        <LITERALS>_rnesting_tokens</LITERALS>           => undef,
        <LITERALS>_rci_levels</LITERALS>                => undef,
        <LITERALS>_rnesting_blocks</LITERALS>           => undef,
        <LITERALS>_guessed_indentation_level</LITERALS> => 0,
        <LITERALS>_starting_in_quote</LITERALS>    => 0,                    # <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>subroutine</COMMENTS>
        <LITERALS>_ending_in_quote</LITERALS>      => 0,
        <LITERALS>_curly_brace_depth</LITERALS>    => $<CODE>brace_depth</CODE>,
        <LITERALS>_square_bracket_depth</LITERALS> => $<CODE>square_bracket_depth</CODE>,
        <LITERALS>_paren_depth</LITERALS>          => $<CODE>paren_depth</CODE>,
        <LITERALS>_quote_character</LITERALS>      => '',
    };

    # <COMMENTS>must</COMMENTS> <COMMENTS>print</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>unchanged</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>document</COMMENTS>
    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_here_doc</LITERALS>} ) {

        $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>HERE</LITERALS>';
        my $<CODE>here_doc_target</CODE>      = $<CODE>tokenizer_self</CODE>->{<LITERALS>_here_doc_target</LITERALS>};
        my $<CODE>here_quote_character</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_here_quote_character</LITERALS>};
        my $<CODE>candidate_target</CODE>     = $<CODE>input_line</CODE>;
        chomp $<CODE>candidate_target</CODE>;
        if ( $<CODE>candidate_target</CODE> eq $<CODE>here_doc_target</CODE> ) {
            $<CODE>tokenizer_self</CODE>->{<LITERALS>_nearly_matched_here_target_at</LITERALS>} = undef;
            $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>}                     = '<LITERALS>HERE_END</LITERALS>';
            <CODE>write_logfile_entry</CODE>("<LITERALS>Exiting</LITERALS> <LITERALS>HERE</LITERALS> <LITERALS>document</LITERALS> $<CODE>here_doc_target</CODE>\n");

            my $<CODE>rhere_target_list</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_rhere_target_list</LITERALS>};
            if (@$<CODE>rhere_target_list</CODE>) {    # <COMMENTS>there</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>targets</COMMENTS>
                ( $<CODE>here_doc_target</CODE>, $<CODE>here_quote_character</CODE> ) =
                  @{ shift @$<CODE>rhere_target_list</CODE> };
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_here_doc_target</LITERALS>} = $<CODE>here_doc_target</CODE>;
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_here_quote_character</LITERALS>} =
                  $<CODE>here_quote_character</CODE>;
                <CODE>write_logfile_entry</CODE>(
                    "<LITERALS>Entering</LITERALS> <LITERALS>HERE</LITERALS> <LITERALS>document</LITERALS> $<CODE>here_doc_target</CODE>\n");
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_nearly_matched_here_target_at</LITERALS>} = undef;
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_started_looking_for_here_target_at</LITERALS>} =
                  $<CODE>input_line_number</CODE>;
            }
            else {
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_here_doc</LITERALS>}          = 0;
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_here_doc_target</LITERALS>}      = "";
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_here_quote_character</LITERALS>} = "";
            }
        }

        # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>whitespace</COMMENTS>
        # <COMMENTS>note</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>PERL6</COMMENTS>: <COMMENTS>leading</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>allowed</COMMENTS>
        else {
            $<CODE>candidate_target</CODE> =~ s/\s*$//;
            $<CODE>candidate_target</CODE> =~ s/^\s*//;
            if ( $<CODE>candidate_target</CODE> eq $<CODE>here_doc_target</CODE> ) {
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_nearly_matched_here_target_at</LITERALS>} =
                  $<CODE>input_line_number</CODE>;
            }
        }
        return $<CODE>line_of_tokens</CODE>;
    }

    # <COMMENTS>must</COMMENTS> <COMMENTS>print</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>unchanged</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>format</COMMENTS> <COMMENTS>section</COMMENTS>
    elsif ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_format</LITERALS>} ) {

        if ( $<CODE>input_line</CODE> =~ /^\.[\s#]*$/ ) {
            <CODE>write_logfile_entry</CODE>("<LITERALS>Exiting</LITERALS> <LITERALS>format</LITERALS> <LITERALS>section</LITERALS>\n");
            $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_format</LITERALS>} = 0;
            $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>FORMAT_END</LITERALS>';
        }
        else {
            $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>FORMAT</LITERALS>';
        }
        return $<CODE>line_of_tokens</CODE>;
    }

    # <COMMENTS>must</COMMENTS> <COMMENTS>print</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>unchanged</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>documentation</COMMENTS>
    elsif ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_pod</LITERALS>} ) {

        $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>POD</LITERALS>';
        if ( $<CODE>input_line</CODE> =~ /^=cut/ ) {
            $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>POD_END</LITERALS>';
            <CODE>write_logfile_entry</CODE>("<LITERALS>Exiting</LITERALS> <LITERALS>POD</LITERALS> <LITERALS>section</LITERALS>\n");
            $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_pod</LITERALS>} = 0;
        }
        if ( $<CODE>input_line</CODE> =~ /^\#\!.*perl\b/ ) {
            <CODE>warning</CODE>(
                "<LITERALS>Hash</LITERALS>-<LITERALS>bang</LITERALS> <LITERALS>in</LITERALS> <LITERALS>pod</LITERALS> <LITERALS>can</LITERALS> <LITERALS>cause</LITERALS> <LITERALS>older</LITERALS> <LITERALS>versions</LITERALS> <LITERALS>of</LITERALS> <LITERALS>perl</LITERALS> <LITERALS>to</LITERALS> <LITERALS>fail</LITERALS>! \n"
            );
        }

        return $<CODE>line_of_tokens</CODE>;
    }

    # <COMMENTS>must</COMMENTS> <COMMENTS>print</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>unchanged</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>seen</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>severe</COMMENTS> <COMMENTS>error</COMMENTS> (<COMMENTS>i</COMMENTS>.<COMMENTS>e</COMMENTS>., <COMMENTS>we</COMMENTS>
    # <COMMENTS>are</COMMENTS> <COMMENTS>seeing</COMMENTS> <COMMENTS>illegal</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>cannot</COMMENTS> <COMMENTS>continue</COMMENTS>.  <COMMENTS>Syntax</COMMENTS> <COMMENTS>errors</COMMENTS> <COMMENTS>do</COMMENTS>
    # <COMMENTS>not</COMMENTS> <COMMENTS>pass</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>route</COMMENTS>).  <COMMENTS>Calling</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS>, <COMMENTS>but</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>pass</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>__END__</COMMENTS>
    elsif ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_error</LITERALS>} ) {
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>ERROR</LITERALS>';
        return $<CODE>line_of_tokens</CODE>;
    }

    # <COMMENTS>print</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>unchanged</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>__DATA__</COMMENTS> <COMMENTS>section</COMMENTS>
    elsif ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_data</LITERALS>} ) {

        # ...<COMMENTS>but</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>POD</COMMENTS>
        # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>_in_data</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>_in_end</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>remain</COMMENTS> <COMMENTS>set</COMMENTS>
        # <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>state</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>seeing</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>section</COMMENTS>
        if ( $<CODE>input_line</CODE> =~ /^=(?!cut)/ ) {
            $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>POD_START</LITERALS>';
            <CODE>write_logfile_entry</CODE>("<LITERALS>Entering</LITERALS> <LITERALS>POD</LITERALS> <LITERALS>section</LITERALS>\n");
            $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_pod</LITERALS>} = 1;
            return $<CODE>line_of_tokens</CODE>;
        }
        else {
            $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>DATA</LITERALS>';
            return $<CODE>line_of_tokens</CODE>;
        }
    }

    # <COMMENTS>print</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>unchanged</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>__END__</COMMENTS> <COMMENTS>section</COMMENTS>
    elsif ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_end</LITERALS>} ) {

        # ...<COMMENTS>but</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>POD</COMMENTS>
        # <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>_in_data</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>_in_end</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>remain</COMMENTS> <COMMENTS>set</COMMENTS>
        # <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>state</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>seeing</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>section</COMMENTS>
        if ( $<CODE>input_line</CODE> =~ /^=(?!cut)/ ) {
            $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>POD_START</LITERALS>';
            <CODE>write_logfile_entry</CODE>("<LITERALS>Entering</LITERALS> <LITERALS>POD</LITERALS> <LITERALS>section</LITERALS>\n");
            $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_pod</LITERALS>} = 1;
            return $<CODE>line_of_tokens</CODE>;
        }
        else {
            $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>END</LITERALS>';
            return $<CODE>line_of_tokens</CODE>;
        }
    }

    # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS>-<COMMENTS>bang</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>haven</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>seen</COMMENTS> <COMMENTS>one</COMMENTS>
    if ( !$<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_hash_bang</LITERALS>} ) {
        if ( $<CODE>input_line</CODE> =~ /^\#\!.*perl\b/ ) {
            $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_hash_bang</LITERALS>} = $<CODE>input_line_number</CODE>;

            # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> -<COMMENTS>w</COMMENTS> <COMMENTS>and</COMMENTS> -<COMMENTS>P</COMMENTS> <COMMENTS>flags</COMMENTS>
            if ( $<CODE>input_line</CODE> =~ /^\#\!.*perl\s.*-.*P/ ) {
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_perl_dash_P</LITERALS>} = 1;
            }

            if ( $<CODE>input_line</CODE> =~ /^\#\!.*perl\s.*-.*w/ ) {
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_perl_dash_w</LITERALS>} = 1;
            }

            if (   ( $<CODE>input_line_number</CODE> > 1 )
                && ( !$<CODE>tokenizer_self</CODE>->{<LITERALS>_look_for_hash_bang</LITERALS>} ) )
            {

                # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>helpful</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>VMS</COMMENTS> <COMMENTS>systems</COMMENTS>; <COMMENTS>we</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>accidentally</COMMENTS>
                # <COMMENTS>tokenized</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>DCL</COMMENTS> <COMMENTS>commands</COMMENTS>
                if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_started_tokenizing</LITERALS>} ) {
                    <CODE>warning</CODE>(
"<LITERALS>There</LITERALS> <LITERALS>seems</LITERALS> <LITERALS>to</LITERALS> <LITERALS>be</LITERALS> <LITERALS>a</LITERALS> <LITERALS>hash</LITERALS>-<LITERALS>bang</LITERALS> <LITERALS>after</LITERALS> <LITERALS>line</LITERALS> <LITERALS>1</LITERALS>; <LITERALS>do</LITERALS> <LITERALS>you</LITERALS> <LITERALS>need</LITERALS> <LITERALS>to</LITERALS> <LITERALS>run</LITERALS> <LITERALS>with</LITERALS> -<LITERALS>x</LITERALS> ?\n"
                    );
                }
                else {
                    <CODE>complain</CODE>("<LITERALS>Useless</LITERALS> <LITERALS>hash</LITERALS>-<LITERALS>bang</LITERALS> <LITERALS>after</LITERALS> <LITERALS>line</LITERALS> <LITERALS>1</LITERALS>\n");
                }
            }

            # <COMMENTS>Report</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>hash</COMMENTS>-<COMMENTS>bang</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>system</COMMENTS> <COMMENTS>line</COMMENTS>
            # <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>prevent</COMMENTS> -<COMMENTS>dac</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>deleting</COMMENTS> <COMMENTS>it</COMMENTS>
            else {
                $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>SYSTEM</LITERALS>';
                return $<CODE>line_of_tokens</CODE>;
            }
        }
    }

    # <COMMENTS>wait</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS>-<COMMENTS>bang</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>parsing</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>invoked</COMMENTS> <COMMENTS>us</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>x</COMMENTS>
    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_look_for_hash_bang</LITERALS>}
        && !$<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_hash_bang</LITERALS>} )
    {
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>SYSTEM</LITERALS>';
        return $<CODE>line_of_tokens</CODE>;
    }

    # <COMMENTS>a</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>form</COMMENTS> ': #' <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>marked</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>SYSTEM</COMMENTS>
    # <COMMENTS>since</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>form</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>tcsh</COMMENTS>
    if ( $<CODE>input_line_number</CODE> == 1 && $<CODE>input_line</CODE> =~ /^\s*\:\s*\#/ ) {
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>SYSTEM</LITERALS>';
        return $<CODE>line_of_tokens</CODE>;
    }

    # <COMMENTS>now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>tokenize</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>...
    # <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>modify</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>private</COMMENTS> <COMMENTS>variables</COMMENTS>:
    #        <COMMENTS>_rhere_target_list</COMMENTS>
    #        <COMMENTS>_in_data</COMMENTS>
    #        <COMMENTS>_in_end</COMMENTS>
    #        <COMMENTS>_in_format</COMMENTS>
    #        <COMMENTS>_in_error</COMMENTS>
    #        <COMMENTS>_in_pod</COMMENTS>
    #        <COMMENTS>_in_quote</COMMENTS>
    my $<CODE>ending_in_quote_last</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_quote</LITERALS>};
    <CODE>tokenize_this_line</CODE>($<CODE>line_of_tokens</CODE>);

    # <COMMENTS>Now</COMMENTS> <COMMENTS>finish</COMMENTS> <COMMENTS>defining</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>structure</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>it</COMMENTS>
    $<CODE>line_of_tokens</CODE>->{<LITERALS>_ending_in_quote</LITERALS>} = $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_quote</LITERALS>};

    # <COMMENTS>handle</COMMENTS> <COMMENTS>severe</COMMENTS> <COMMENTS>error</COMMENTS> (<COMMENTS>binary</COMMENTS> <COMMENTS>data</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>script</COMMENTS>)
    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_error</LITERALS>} ) {
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_quote</LITERALS>} = 0;    # <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>messages</COMMENTS>
        <CODE>warning</CODE>("<LITERALS>Giving</LITERALS> <LITERALS>up</LITERALS> <LITERALS>after</LITERALS> <LITERALS>error</LITERALS>\n");
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>ERROR</LITERALS>';
        <CODE>reset_indentation_level</CODE>(0);          # <COMMENTS>avoid</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>messages</COMMENTS>
        return $<CODE>line_of_tokens</CODE>;
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>documentation</COMMENTS>
    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_pod</LITERALS>} ) {

        # <COMMENTS>This</COMMENTS> <COMMENTS>gets</COMMENTS> <COMMENTS>tricky</COMMENTS>..<COMMENTS>above</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>__DATA__</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>__END__</COMMENTS> <COMMENTS>section</COMMENTS>, <COMMENTS>perl</COMMENTS>
        # <COMMENTS>accepts</COMMENTS> '=<COMMENTS>cut</COMMENTS>' <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>section</COMMENTS>. <COMMENTS>But</COMMENTS> <COMMENTS>afterwards</COMMENTS>,
        # <COMMENTS>only</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>utilities</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>ignore</COMMENTS> <COMMENTS>an</COMMENTS> =<COMMENTS>cut</COMMENTS> <COMMENTS>without</COMMENTS>
        # <COMMENTS>leading</COMMENTS> =<COMMENTS>head</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>case</COMMENTS>, <COMMENTS>this</COMMENTS> <COMMENTS>isn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>good</COMMENTS>.
        if ( $<CODE>input_line</CODE> =~ /^=cut\b/ ) {
            if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_data</LITERALS>} || $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_end</LITERALS>} ) {
                <CODE>complain</CODE>("=<LITERALS>cut</LITERALS> <LITERALS>while</LITERALS> <LITERALS>not</LITERALS> <LITERALS>in</LITERALS> <LITERALS>pod</LITERALS> <LITERALS>ignored</LITERALS>\n");
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_pod</LITERALS>}    = 0;
                $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>POD_END</LITERALS>';
            }
            else {
                $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>POD_START</LITERALS>';
                <CODE>complain</CODE>(
"=<LITERALS>cut</LITERALS> <LITERALS>starts</LITERALS> <LITERALS>a</LITERALS> <LITERALS>pod</LITERALS> <LITERALS>section</LITERALS> .. <LITERALS>this</LITERALS> <LITERALS>can</LITERALS> <LITERALS>fool</LITERALS> <LITERALS>pod</LITERALS> <LITERALS>utilities</LITERALS>.\n"
                );
                <CODE>write_logfile_entry</CODE>("<LITERALS>Entering</LITERALS> <LITERALS>POD</LITERALS> <LITERALS>section</LITERALS>\n");
            }
        }

        else {
            $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>POD_START</LITERALS>';
            <CODE>write_logfile_entry</CODE>("<LITERALS>Entering</LITERALS> <LITERALS>POD</LITERALS> <LITERALS>section</LITERALS>\n");
        }

        return $<CODE>line_of_tokens</CODE>;
    }

    # <COMMENTS>update</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>levels</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>log</COMMENTS> <COMMENTS>messages</COMMENTS>
    if ( $<CODE>input_line</CODE> !~ /^\s*$/ ) {
        my $<CODE>rlevels</CODE> = $<CODE>line_of_tokens</CODE>->{<LITERALS>_rlevels</LITERALS>};
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_guessed_indentation_level</LITERALS>} =
          <CODE>guess_old_indentation_level</CODE>($<CODE>input_line</CODE>);
    }

    # <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>contains</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>doc</COMMENTS> <COMMENTS>targets</COMMENTS>
    my $<CODE>rhere_target_list</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_rhere_target_list</LITERALS>};
    if (@$<CODE>rhere_target_list</CODE>) {

        my ( $<CODE>here_doc_target</CODE>, $<CODE>here_quote_character</CODE> ) =
          @{ shift @$<CODE>rhere_target_list</CODE> };
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_here_doc</LITERALS>}          = 1;
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_here_doc_target</LITERALS>}      = $<CODE>here_doc_target</CODE>;
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_here_quote_character</LITERALS>} = $<CODE>here_quote_character</CODE>;
        <CODE>write_logfile_entry</CODE>("<LITERALS>Entering</LITERALS> <LITERALS>HERE</LITERALS> <LITERALS>document</LITERALS> $<CODE>here_doc_target</CODE>\n");
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_started_looking_for_here_target_at</LITERALS>} =
          $<CODE>input_line_number</CODE>;
    }

    # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>__END__</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>__DATA__</COMMENTS> <COMMENTS>statements</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>written</COMMENTS> <COMMENTS>unformatted</COMMENTS>
    # <COMMENTS>because</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>theoretically</COMMENTS> <COMMENTS>contain</COMMENTS> <COMMENTS>additional</COMMENTS> <COMMENTS>characters</COMMENTS>
    # <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>tokenized</COMMENTS> (<COMMENTS>and</COMMENTS> <COMMENTS>cannot</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>read</COMMENTS> <COMMENTS>with</COMMENTS> <<COMMENTS>DATA</COMMENTS>> <COMMENTS>either</COMMENTS>!).
    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_data</LITERALS>} ) {
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>DATA_START</LITERALS>';
        <CODE>write_logfile_entry</CODE>("<LITERALS>Starting</LITERALS> <LITERALS>__DATA__</LITERALS> <LITERALS>section</LITERALS>\n");
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_data</LITERALS>} = 1;

        # <COMMENTS>keep</COMMENTS> <COMMENTS>parsing</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>__DATA__</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>SelfLoader</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>seen</COMMENTS>
        if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_selfloader</LITERALS>} ) {
            $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_data</LITERALS>} = 0;
            <CODE>write_logfile_entry</CODE>(
                "<LITERALS>SelfLoader</LITERALS> <LITERALS>seen</LITERALS>, <LITERALS>continuing</LITERALS>; -<LITERALS>nlsl</LITERALS> <LITERALS>deactivates</LITERALS>\n");
        }

        return $<CODE>line_of_tokens</CODE>;
    }

    elsif ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_end</LITERALS>} ) {
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>END_START</LITERALS>';
        <CODE>write_logfile_entry</CODE>("<LITERALS>Starting</LITERALS> <LITERALS>__END__</LITERALS> <LITERALS>section</LITERALS>\n");
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_end</LITERALS>} = 1;

        # <COMMENTS>keep</COMMENTS> <COMMENTS>parsing</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>__END__</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>AutoLoader</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>seen</COMMENTS>
        if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_autoloader</LITERALS>} ) {
            $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_end</LITERALS>} = 0;
            <CODE>write_logfile_entry</CODE>(
                "<LITERALS>AutoLoader</LITERALS> <LITERALS>seen</LITERALS>, <LITERALS>continuing</LITERALS>; -<LITERALS>nlal</LITERALS> <LITERALS>deactivates</LITERALS>\n");
        }
        return $<CODE>line_of_tokens</CODE>;
    }

    # <COMMENTS>now</COMMENTS>, <COMMENTS>finally</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>CODE</COMMENTS>'
    $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_type</LITERALS>} = '<LITERALS>CODE</LITERALS>';

    # <COMMENTS>remember</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>seen</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>real</COMMENTS> <COMMENTS>code</COMMENTS>
    if (  !$<CODE>tokenizer_self</CODE>->{<LITERALS>_started_tokenizing</LITERALS>}
        && $<CODE>input_line</CODE> !~ /^\s*$/
        && $<CODE>input_line</CODE> !~ /^\s*#/ )
    {
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_started_tokenizing</LITERALS>} = 1;
    }

    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_debugger_object</LITERALS>} ) {
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_debugger_object</LITERALS>}-><CODE>write_debug_entry</CODE>($<CODE>line_of_tokens</CODE>);
    }

    # <COMMENTS>Note</COMMENTS>: <COMMENTS>if</COMMENTS> <COMMENTS>keyword</COMMENTS> '<COMMENTS>format</COMMENTS>' <COMMENTS>occurs</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>code</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>CODE</COMMENTS>
    # (<COMMENTS>keyword</COMMENTS> '<COMMENTS>format</COMMENTS>' <COMMENTS>need</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>)
    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_format</LITERALS>} ) {
        <CODE>write_logfile_entry</CODE>("<LITERALS>Entering</LITERALS> <LITERALS>format</LITERALS> <LITERALS>section</LITERALS>\n");
    }

    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_quote</LITERALS>}
        and ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_start_quote</LITERALS>} < 0 ) )
    {

        #<COMMENTS>if</COMMENTS> ( ( <COMMENTS>my</COMMENTS> <COMMENTS>$quote_target</COMMENTS> = <COMMENTS>get_quote_target</COMMENTS>() ) !~ /^\<COMMENTS>s</COMMENTS>*<COMMENTS>$</COMMENTS>/ ) {
        if (
            ( my $<CODE>quote_target</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_quote_target</LITERALS>} ) !~ /^\s*$/ )
        {
            $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_start_quote</LITERALS>} = $<CODE>input_line_number</CODE>;
            <CODE>write_logfile_entry</CODE>(
                "<LITERALS>Start</LITERALS> <LITERALS>multi</LITERALS>-<LITERALS>line</LITERALS> <LITERALS>quote</LITERALS> <LITERALS>or</LITERALS> <LITERALS>pattern</LITERALS> <LITERALS>ending</LITERALS> <LITERALS>in</LITERALS> $<CODE>quote_target</CODE>\n");
        }
    }
    elsif ( ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_start_quote</LITERALS>} >= 0 )
        and !$<CODE>tokenizer_self</CODE>->{<LITERALS>_in_quote</LITERALS>} )
    {
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_start_quote</LITERALS>} = -1;
        <CODE>write_logfile_entry</CODE>("<LITERALS>End</LITERALS> <LITERALS>of</LITERALS> <LITERALS>multi</LITERALS>-<LITERALS>line</LITERALS> <LITERALS>quote</LITERALS> <LITERALS>or</LITERALS> <LITERALS>pattern</LITERALS>\n");
    }

    # <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>returning</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>CODE</COMMENTS>
    return $<CODE>line_of_tokens</CODE>;
}

sub <CODE>find_starting_indentation_level</CODE> {

    # <COMMENTS>We</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>script</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>formatted</COMMENTS>.  <COMMENTS>Often</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>zero</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>entire</COMMENTS> <COMMENTS>file</COMMENTS>,
    # <COMMENTS>but</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>formatting</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>local</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> (<COMMENTS>within</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>editor</COMMENTS> <COMMENTS>for</COMMENTS>
    # <COMMENTS>example</COMMENTS>) <COMMENTS>it</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>zero</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>specify</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS>
    # -<COMMENTS>sil</COMMENTS>=<COMMENTS>n</COMMENTS> <COMMENTS>parameter</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>normally</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>guess</COMMENTS>.
    #
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$tokenizer_self</COMMENTS>
    my $<CODE>starting_level</CODE> = 0;

    # <COMMENTS>use</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>parameter</COMMENTS>
    if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_know_starting_level</LITERALS>} ) {
        $<CODE>starting_level</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_starting_level</LITERALS>};
    }

    # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hash_bang</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>zero</COMMENTS>
    elsif ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_look_for_hash_bang</LITERALS>} ) {
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_know_starting_level</LITERALS>} = 1;
    }

    # <COMMENTS>otherwise</COMMENTS> <COMMENTS>figure</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>file</COMMENTS>
    else {
        my $<CODE>line</CODE>;
        my $<CODE>i</CODE> = 0;

        # <COMMENTS>keep</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>until</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>bang</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>piece</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS>
        my $<CODE>msg</CODE> = "";
        while ( $<CODE>line</CODE> =
            $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_buffer_object</LITERALS>}-><CODE>peek_ahead</CODE>( $<CODE>i</CODE>++ ) )
        {

            # <COMMENTS>if</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> #! <COMMENTS>then</COMMENTS> <COMMENTS>assume</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>zero</COMMENTS>
            if ( $<CODE>i</CODE> == 1 && $<CODE>line</CODE> =~ /^\#\!/ ) {
                $<CODE>starting_level</CODE> = 0;
                last;
            }
            next if ( $<CODE>line</CODE> =~ /^\s*#/ );    # <COMMENTS>skip</COMMENTS> <COMMENTS>past</COMMENTS> <COMMENTS>comments</COMMENTS>
            next if ( $<CODE>line</CODE> =~ /^\s*$/ );    # <COMMENTS>skip</COMMENTS> <COMMENTS>past</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>lines</COMMENTS>
            $<CODE>starting_level</CODE> = <CODE>guess_old_indentation_level</CODE>($<CODE>line</CODE>);
            last;
        }
        $<CODE>msg</CODE> = "<LITERALS>Line</LITERALS> $<CODE>i</CODE> <LITERALS>implies</LITERALS> <LITERALS>starting</LITERALS>-<LITERALS>indentation</LITERALS>-<LITERALS>level</LITERALS> = $<CODE>starting_level</CODE>\n";
        <CODE>write_logfile_entry</CODE>("$<CODE>msg</CODE>");
    }
    $<CODE>tokenizer_self</CODE>->{<LITERALS>_starting_level</LITERALS>} = $<CODE>starting_level</CODE>;
    <CODE>reset_indentation_level</CODE>($<CODE>starting_level</CODE>);
}

sub <CODE>guess_old_indentation_level</CODE> {
    my ($<CODE>line</CODE>) = @<CODE>_</CODE>;

    # <COMMENTS>Guess</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>line</COMMENTS>.
    #
    # <COMMENTS>For</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>result</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>define</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>starting</COMMENTS>
    # <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>mainly</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>zero</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>applied</COMMENTS>
    # <COMMENTS>within</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>editor</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>local</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS>.
    #
    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>impossible</COMMENTS> <COMMENTS>task</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>general</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>tabs</COMMENTS>
    # <COMMENTS>meant</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>script</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS>
    # <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>script</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS>
    # <COMMENTS>been</COMMENTS> <COMMENTS>previously</COMMENTS> <COMMENTS>formatted</COMMENTS> <COMMENTS>with</COMMENTS> -<COMMENTS>i</COMMENTS>=<COMMENTS>7</COMMENTS> -<COMMENTS>et</COMMENTS>=<COMMENTS>3</COMMENTS>.  <COMMENTS>But</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS>
    # <COMMENTS>make</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>guesses</COMMENTS> <COMMENTS>correctly</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>applied</COMMENTS> <COMMENTS>repeatedly</COMMENTS> <COMMENTS>to</COMMENTS>
    # <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>editor</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>stays</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS>
    # <COMMENTS>level</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>applied</COMMENTS> <COMMENTS>repeatedly</COMMENTS>.
    #
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$tokenizer_self</COMMENTS>
    my $<CODE>level</CODE> = 0;

    # <COMMENTS>find</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>tabs</COMMENTS>, <COMMENTS>spaces</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>label</COMMENTS>
    my $<CODE>spaces</CODE> = 0;
    if ( $<CODE>line</CODE> =~ /^(\t+)?(\s+)?(\w+:[^:])?/ ) {

        # <COMMENTS>If</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>tabs</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tab</COMMENTS> <COMMENTS>scheme</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>run</COMMENTS>, <COMMENTS>if</COMMENTS>
        # <COMMENTS>any</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>remain</COMMENTS> <COMMENTS>stable</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>editing</COMMENTS>.
        if ($<CODE>1</CODE>) { $<CODE>spaces</CODE> += length($<CODE>1</CODE>) * $<CODE>tokenizer_self</CODE>->{<LITERALS>_tabsize</LITERALS>} }

        if ($<CODE>2</CODE>) { $<CODE>spaces</CODE> += length($<CODE>2</CODE>) }

        # <COMMENTS>correct</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>outdented</COMMENTS> <COMMENTS>labels</COMMENTS>
        if ( $<CODE>3</CODE> && $<CODE>tokenizer_self</CODE>->{'<LITERALS>_outdent_labels</LITERALS>'} ) {
            $<CODE>spaces</CODE> += $<CODE>tokenizer_self</CODE>->{<LITERALS>_continuation_indentation</LITERALS>};
        }
    }

    # <COMMENTS>compute</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>using</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>of</COMMENTS> -<COMMENTS>i</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>run</COMMENTS>.
    # <COMMENTS>If</COMMENTS> -<COMMENTS>i</COMMENTS>=<COMMENTS>0</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>run</COMMENTS> (<COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>possible</COMMENTS>) <COMMENTS>it</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>matter</COMMENTS>
    # <COMMENTS>what</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>guess</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>run</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>4</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>per</COMMENTS> <COMMENTS>level</COMMENTS>.
    my $<CODE>indent_columns</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_indent_columns</LITERALS>};
    $<CODE>indent_columns</CODE> = 4 if ( !$<CODE>indent_columns</CODE> );
    $<CODE>level</CODE> = int( $<CODE>spaces</CODE> / $<CODE>indent_columns</CODE> );
    return ($<CODE>level</CODE>);
}

# <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>currently</COMMENTS> <COMMENTS>unused</COMMENTS> <COMMENTS>debug</COMMENTS> <COMMENTS>routine</COMMENTS>
sub <CODE>dump_functions</CODE> {

    my $<CODE>fh</CODE> = *<CODE>STDOUT</CODE>;
    my ( $<CODE>pkg</CODE>, $<CODE>sub</CODE> );
    foreach $<CODE>pkg</CODE> ( keys %<CODE>is_user_function</CODE> ) {
        print $<CODE>fh</CODE> "\n<LITERALS>non</LITERALS>-<LITERALS>constant</LITERALS> <LITERALS>subs</LITERALS> <LITERALS>in</LITERALS> <LITERALS>package</LITERALS> $<CODE>pkg</CODE>\n";

        foreach $<CODE>sub</CODE> ( keys %{ $<CODE>is_user_function</CODE>{$<CODE>pkg</CODE>} } ) {
            my $<CODE>msg</CODE> = "";
            if ( $<CODE>is_block_list_function</CODE>{$<CODE>pkg</CODE>}{$<CODE>sub</CODE>} ) {
                $<CODE>msg</CODE> = '<LITERALS>block_list</LITERALS>';
            }

            if ( $<CODE>is_block_function</CODE>{$<CODE>pkg</CODE>}{$<CODE>sub</CODE>} ) {
                $<CODE>msg</CODE> = '<LITERALS>block</LITERALS>';
            }
            print $<CODE>fh</CODE> "$<CODE>sub</CODE> $<CODE>msg</CODE>\n";
        }
    }

    foreach $<CODE>pkg</CODE> ( keys %<CODE>is_constant</CODE> ) {
        print $<CODE>fh</CODE> "\n<LITERALS>constants</LITERALS> <LITERALS>and</LITERALS> <LITERALS>constant</LITERALS> <LITERALS>subs</LITERALS> <LITERALS>in</LITERALS> <LITERALS>package</LITERALS> $<CODE>pkg</CODE>\n";

        foreach $<CODE>sub</CODE> ( keys %{ $<CODE>is_constant</CODE>{$<CODE>pkg</CODE>} } ) {
            print $<CODE>fh</CODE> "$<CODE>sub</CODE>\n";
        }
    }
}

sub <CODE>ones_count</CODE> {

    # <COMMENTS>count</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>1</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>1</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>0</COMMENTS>'<COMMENTS>s</COMMENTS>
    # <COMMENTS>example</COMMENTS>: <COMMENTS>ones_count</COMMENTS>("<COMMENTS>010101010101</COMMENTS>") <COMMENTS>gives</COMMENTS> <COMMENTS>6</COMMENTS>
    return ( my $<CODE>cis</CODE> = $<CODE>_</CODE>[0] ) =~ tr/<LITERALS>1</LITERALS>/<LITERALS>0</LITERALS>/;
}

sub <CODE>prepare_for_a_new_file</CODE> {

    # <COMMENTS>previous</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>determine</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>expect</COMMENTS> <COMMENTS>next</COMMENTS>
    $<CODE>last_nonblank_token</CODE>      = ';';    # <COMMENTS>the</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>state</COMMENTS> <COMMENTS>which</COMMENTS>
    $<CODE>last_nonblank_type</CODE>       = ';';    # <COMMENTS>will</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>
    $<CODE>last_nonblank_block_type</CODE> = '';

    # <COMMENTS>scalars</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>remembering</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>across</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>lines</COMMENTS>
    $<CODE>statement_type</CODE>    = '';            # '' <COMMENTS>or</COMMENTS> '<COMMENTS>use</COMMENTS>' <COMMENTS>or</COMMENTS> '<COMMENTS>sub</COMMENTS>..' <COMMENTS>or</COMMENTS> '<COMMENTS>case</COMMENTS>..'
    $<CODE>in_attribute_list</CODE> = 0;

    # <COMMENTS>scalars</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>remembering</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>file</COMMENTS>
    $<CODE>current_package</CODE> = "<LITERALS>main</LITERALS>";
    $<CODE>context</CODE>         = <CODE>UNKNOWN_CONTEXT</CODE>;

    # <COMMENTS>hashes</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>remember</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>information</COMMENTS>
    %<CODE>is_constant</CODE>             = ();      # <COMMENTS>user</COMMENTS>-<COMMENTS>defined</COMMENTS> <COMMENTS>constants</COMMENTS>
    %<CODE>is_user_function</CODE>        = ();      # <COMMENTS>user</COMMENTS>-<COMMENTS>defined</COMMENTS> <COMMENTS>functions</COMMENTS>
    %<CODE>user_function_prototype</CODE> = ();      # <COMMENTS>their</COMMENTS> <COMMENTS>prototypes</COMMENTS>
    %<CODE>is_block_function</CODE>       = ();
    %<CODE>is_block_list_function</CODE>  = ();
    %<CODE>saw_function_definition</CODE> = ();

    # <COMMENTS>variables</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>track</COMMENTS> <COMMENTS>depths</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>various</COMMENTS> <COMMENTS>containers</COMMENTS>
    # <COMMENTS>and</COMMENTS> <COMMENTS>report</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>errors</COMMENTS>
    $<CODE>paren_depth</CODE>          = 0;
    $<CODE>brace_depth</CODE>          = 0;
    $<CODE>square_bracket_depth</CODE> = 0;
    @<CODE>current_depth</CODE>[ 0 .. $#<CODE>closing_brace_names</CODE> ] =
      (0) x scalar @<CODE>closing_brace_names</CODE>;
    $<CODE>total_depth</CODE> = 0;
    @<CODE>total_depth</CODE> = ();
    @<CODE>nesting_sequence_number</CODE>[ 0 .. $#<CODE>closing_brace_names</CODE> ] =
      ( 0 .. $#<CODE>closing_brace_names</CODE> );
    @<CODE>current_sequence_number</CODE>             = ();
    $<CODE>paren_type</CODE>[$<CODE>paren_depth</CODE>]            = '';
    $<CODE>paren_semicolon_count</CODE>[$<CODE>paren_depth</CODE>] = 0;
    $<CODE>paren_structural_type</CODE>[$<CODE>brace_depth</CODE>] = '';
    $<CODE>brace_type</CODE>[$<CODE>brace_depth</CODE>] = ';';    # <COMMENTS>identify</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>
    $<CODE>brace_structural_type</CODE>[$<CODE>brace_depth</CODE>]                   = '';
    $<CODE>brace_context</CODE>[$<CODE>brace_depth</CODE>]                           = <CODE>UNKNOWN_CONTEXT</CODE>;
    $<CODE>brace_package</CODE>[$<CODE>paren_depth</CODE>]                           = $<CODE>current_package</CODE>;
    $<CODE>square_bracket_type</CODE>[$<CODE>square_bracket_depth</CODE>]            = '';
    $<CODE>square_bracket_structural_type</CODE>[$<CODE>square_bracket_depth</CODE>] = '';

    <CODE>initialize_tokenizer_state</CODE>();
}

{                                       # <COMMENTS>begin</COMMENTS> <COMMENTS>tokenize_this_line</COMMENTS>

    use <CODE>constant</CODE> <LITERALS>BRACE</LITERALS>          => 0;
    use <CODE>constant</CODE> <LITERALS>SQUARE_BRACKET</LITERALS> => 1;
    use <CODE>constant</CODE> <LITERALS>PAREN</LITERALS>          => 2;
    use <CODE>constant</CODE> <LITERALS>QUESTION_COLON</LITERALS> => 3;

    # <COMMENTS>TV1</COMMENTS>: <COMMENTS>scalars</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>processing</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>LINE</COMMENTS>.
    # <COMMENTS>Re</COMMENTS>-<COMMENTS>initialized</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>entry</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>tokenize_this_line</COMMENTS>.
    my (
        $<CODE>block_type</CODE>,        $<CODE>container_type</CODE>,    $<CODE>expecting</CODE>,
        $<CODE>i</CODE>,                 $<CODE>i_tok</CODE>,             $<CODE>input_line</CODE>,
        $<CODE>input_line_number</CODE>, $<CODE>last_nonblank_i</CODE>,   $<CODE>max_token_index</CODE>,
        $<CODE>next_tok</CODE>,          $<CODE>next_type</CODE>,         $<CODE>peeked_ahead</CODE>,
        $<CODE>prototype</CODE>,         $<CODE>rhere_target_list</CODE>, $<CODE>rtoken_map</CODE>,
        $<CODE>rtoken_type</CODE>,       $<CODE>rtokens</CODE>,           $<CODE>tok</CODE>,
        $<CODE>type</CODE>,              $<CODE>type_sequence</CODE>,     $<CODE>indent_flag</CODE>,
    );

    # <COMMENTS>TV2</COMMENTS>: <COMMENTS>refs</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>ARRAYS</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>processing</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>LINE</COMMENTS>
    # <COMMENTS>Re</COMMENTS>-<COMMENTS>initialized</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>call</COMMENTS>.
    my $<CODE>routput_token_list</CODE>     = [];    # <COMMENTS>stack</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>indexes</COMMENTS>
    my $<CODE>routput_token_type</CODE>     = [];    # <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>
    my $<CODE>routput_block_type</CODE>     = [];    # <COMMENTS>types</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>
    my $<CODE>routput_container_type</CODE> = [];    # <COMMENTS>paren</COMMENTS> <COMMENTS>types</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>if</COMMENTS>, <COMMENTS>elsif</COMMENTS>, ..
    my $<CODE>routput_type_sequence</CODE>  = [];    # <COMMENTS>nesting</COMMENTS> <COMMENTS>sequential</COMMENTS> <COMMENTS>number</COMMENTS>
    my $<CODE>routput_indent_flag</CODE>    = [];    #

    # <COMMENTS>TV3</COMMENTS>: <COMMENTS>SCALARS</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>variables</COMMENTS>.  <COMMENTS>These</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>initialized</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS>
    # <COMMENTS>subroutine</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>continually</COMMENTS> <COMMENTS>updated</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>processed</COMMENTS>.
    my ( $<CODE>in_quote</CODE>, $<CODE>quote_type</CODE>, $<CODE>quote_character</CODE>, $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>,
        $<CODE>quoted_string_1</CODE>, $<CODE>quoted_string_2</CODE>, $<CODE>allowed_quote_modifiers</CODE>, );

    # <COMMENTS>TV4</COMMENTS>: <COMMENTS>SCALARS</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>multi</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>identifiers</COMMENTS> <COMMENTS>and</COMMENTS>
    # <COMMENTS>statements</COMMENTS>. <COMMENTS>These</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>initialized</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>subroutine</COMMENTS> <COMMENTS>call</COMMENTS>
    # <COMMENTS>and</COMMENTS> <COMMENTS>continually</COMMENTS> <COMMENTS>updated</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>processed</COMMENTS>.
    my ( $<CODE>id_scan_state</CODE>, $<CODE>identifier</CODE>, $<CODE>want_paren</CODE>, $<CODE>indented_if_level</CODE> );

    # <COMMENTS>TV5</COMMENTS>: <COMMENTS>SCALARS</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>tracking</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS>.
    # <COMMENTS>Initialized</COMMENTS> <COMMENTS>once</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>continually</COMMENTS> <COMMENTS>updated</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>are</COMMENTS>
    # <COMMENTS>processed</COMMENTS>.
    my (
        $<CODE>nesting_token_string</CODE>,      $<CODE>nesting_type_string</CODE>,
        $<CODE>nesting_block_string</CODE>,      $<CODE>nesting_block_flag</CODE>,
        $<CODE>nesting_list_string</CODE>,       $<CODE>nesting_list_flag</CODE>,
        $<CODE>ci_string_in_tokenizer</CODE>,    $<CODE>continuation_string_in_tokenizer</CODE>,
        $<CODE>in_statement_continuation</CODE>, $<CODE>level_in_tokenizer</CODE>,
        $<CODE>slevel_in_tokenizer</CODE>,       $<CODE>rslevel_stack</CODE>,
    );

    # <COMMENTS>TV6</COMMENTS>: <COMMENTS>SCALARS</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>remembering</COMMENTS> <COMMENTS>several</COMMENTS> <COMMENTS>previous</COMMENTS>
    # <COMMENTS>tokens</COMMENTS>. <COMMENTS>Initialized</COMMENTS> <COMMENTS>once</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>continually</COMMENTS> <COMMENTS>updated</COMMENTS> <COMMENTS>as</COMMENTS>
    # <COMMENTS>lines</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>processed</COMMENTS>.
    my (
        $<CODE>last_nonblank_container_type</CODE>,     $<CODE>last_nonblank_type_sequence</CODE>,
        $<CODE>last_last_nonblank_token</CODE>,         $<CODE>last_last_nonblank_type</CODE>,
        $<CODE>last_last_nonblank_block_type</CODE>,    $<CODE>last_last_nonblank_container_type</CODE>,
        $<CODE>last_last_nonblank_type_sequence</CODE>, $<CODE>last_nonblank_prototype</CODE>,
    );

    # ----------------------------------------------------------------
    # <COMMENTS>beginning</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>variable</COMMENTS> <COMMENTS>access</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>manipulation</COMMENTS> <COMMENTS>routines</COMMENTS>
    # ----------------------------------------------------------------

    sub <CODE>initialize_tokenizer_state</CODE> {

        # <COMMENTS>TV1</COMMENTS>: <COMMENTS>initialized</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>call</COMMENTS>
        # <COMMENTS>TV2</COMMENTS>: <COMMENTS>initialized</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>call</COMMENTS>
        # <COMMENTS>TV3</COMMENTS>:
        $<CODE>in_quote</CODE>                = 0;
        $<CODE>quote_type</CODE>              = '<LITERALS>Q</LITERALS>';
        $<CODE>quote_character</CODE>         = "";
        $<CODE>quote_pos</CODE>               = 0;
        $<CODE>quote_depth</CODE>             = 0;
        $<CODE>quoted_string_1</CODE>         = "";
        $<CODE>quoted_string_2</CODE>         = "";
        $<CODE>allowed_quote_modifiers</CODE> = "";

        # <COMMENTS>TV4</COMMENTS>:
        $<CODE>id_scan_state</CODE>     = '';
        $<CODE>identifier</CODE>        = '';
        $<CODE>want_paren</CODE>        = "";
        $<CODE>indented_if_level</CODE> = 0;

        # <COMMENTS>TV5</COMMENTS>:
        $<CODE>nesting_token_string</CODE>             = "";
        $<CODE>nesting_type_string</CODE>              = "";
        $<CODE>nesting_block_string</CODE>             = '<LITERALS>1</LITERALS>';    # <COMMENTS>initially</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS>
        $<CODE>nesting_block_flag</CODE>               = 1;
        $<CODE>nesting_list_string</CODE>              = '<LITERALS>0</LITERALS>';    # <COMMENTS>initially</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS>
        $<CODE>nesting_list_flag</CODE>                = 0;      # <COMMENTS>initially</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS>
        $<CODE>ci_string_in_tokenizer</CODE>           = "";
        $<CODE>continuation_string_in_tokenizer</CODE> = "<LITERALS>0</LITERALS>";
        $<CODE>in_statement_continuation</CODE>        = 0;
        $<CODE>level_in_tokenizer</CODE>               = 0;
        $<CODE>slevel_in_tokenizer</CODE>              = 0;
        $<CODE>rslevel_stack</CODE>                    = [];

        # <COMMENTS>TV6</COMMENTS>:
        $<CODE>last_nonblank_container_type</CODE>      = '';
        $<CODE>last_nonblank_type_sequence</CODE>       = '';
        $<CODE>last_last_nonblank_token</CODE>          = ';';
        $<CODE>last_last_nonblank_type</CODE>           = ';';
        $<CODE>last_last_nonblank_block_type</CODE>     = '';
        $<CODE>last_last_nonblank_container_type</CODE> = '';
        $<CODE>last_last_nonblank_type_sequence</CODE>  = '';
        $<CODE>last_nonblank_prototype</CODE>           = "";
    }

    sub <CODE>save_tokenizer_state</CODE> {

        my $<CODE>rTV1</CODE> = [
            $<CODE>block_type</CODE>,        $<CODE>container_type</CODE>,    $<CODE>expecting</CODE>,
            $<CODE>i</CODE>,                 $<CODE>i_tok</CODE>,             $<CODE>input_line</CODE>,
            $<CODE>input_line_number</CODE>, $<CODE>last_nonblank_i</CODE>,   $<CODE>max_token_index</CODE>,
            $<CODE>next_tok</CODE>,          $<CODE>next_type</CODE>,         $<CODE>peeked_ahead</CODE>,
            $<CODE>prototype</CODE>,         $<CODE>rhere_target_list</CODE>, $<CODE>rtoken_map</CODE>,
            $<CODE>rtoken_type</CODE>,       $<CODE>rtokens</CODE>,           $<CODE>tok</CODE>,
            $<CODE>type</CODE>,              $<CODE>type_sequence</CODE>,     $<CODE>indent_flag</CODE>,
        ];

        my $<CODE>rTV2</CODE> = [
            $<CODE>routput_token_list</CODE>,    $<CODE>routput_token_type</CODE>,
            $<CODE>routput_block_type</CODE>,    $<CODE>routput_container_type</CODE>,
            $<CODE>routput_type_sequence</CODE>, $<CODE>routput_indent_flag</CODE>,
        ];

        my $<CODE>rTV3</CODE> = [
            $<CODE>in_quote</CODE>,        $<CODE>quote_type</CODE>,
            $<CODE>quote_character</CODE>, $<CODE>quote_pos</CODE>,
            $<CODE>quote_depth</CODE>,     $<CODE>quoted_string_1</CODE>,
            $<CODE>quoted_string_2</CODE>, $<CODE>allowed_quote_modifiers</CODE>,
        ];

        my $<CODE>rTV4</CODE> =
          [ $<CODE>id_scan_state</CODE>, $<CODE>identifier</CODE>, $<CODE>want_paren</CODE>, $<CODE>indented_if_level</CODE> ];

        my $<CODE>rTV5</CODE> = [
            $<CODE>nesting_token_string</CODE>,      $<CODE>nesting_type_string</CODE>,
            $<CODE>nesting_block_string</CODE>,      $<CODE>nesting_block_flag</CODE>,
            $<CODE>nesting_list_string</CODE>,       $<CODE>nesting_list_flag</CODE>,
            $<CODE>ci_string_in_tokenizer</CODE>,    $<CODE>continuation_string_in_tokenizer</CODE>,
            $<CODE>in_statement_continuation</CODE>, $<CODE>level_in_tokenizer</CODE>,
            $<CODE>slevel_in_tokenizer</CODE>,       $<CODE>rslevel_stack</CODE>,
        ];

        my $<CODE>rTV6</CODE> = [
            $<CODE>last_nonblank_container_type</CODE>,
            $<CODE>last_nonblank_type_sequence</CODE>,
            $<CODE>last_last_nonblank_token</CODE>,
            $<CODE>last_last_nonblank_type</CODE>,
            $<CODE>last_last_nonblank_block_type</CODE>,
            $<CODE>last_last_nonblank_container_type</CODE>,
            $<CODE>last_last_nonblank_type_sequence</CODE>,
            $<CODE>last_nonblank_prototype</CODE>,
        ];
        return [ $<CODE>rTV1</CODE>, $<CODE>rTV2</CODE>, $<CODE>rTV3</CODE>, $<CODE>rTV4</CODE>, $<CODE>rTV5</CODE>, $<CODE>rTV6</CODE> ];
    }

    sub <CODE>restore_tokenizer_state</CODE> {
        my ($<CODE>rstate</CODE>) = @<CODE>_</CODE>;
        my ( $<CODE>rTV1</CODE>, $<CODE>rTV2</CODE>, $<CODE>rTV3</CODE>, $<CODE>rTV4</CODE>, $<CODE>rTV5</CODE>, $<CODE>rTV6</CODE> ) = @{$<CODE>rstate</CODE>};
        (
            $<CODE>block_type</CODE>,        $<CODE>container_type</CODE>,    $<CODE>expecting</CODE>,
            $<CODE>i</CODE>,                 $<CODE>i_tok</CODE>,             $<CODE>input_line</CODE>,
            $<CODE>input_line_number</CODE>, $<CODE>last_nonblank_i</CODE>,   $<CODE>max_token_index</CODE>,
            $<CODE>next_tok</CODE>,          $<CODE>next_type</CODE>,         $<CODE>peeked_ahead</CODE>,
            $<CODE>prototype</CODE>,         $<CODE>rhere_target_list</CODE>, $<CODE>rtoken_map</CODE>,
            $<CODE>rtoken_type</CODE>,       $<CODE>rtokens</CODE>,           $<CODE>tok</CODE>,
            $<CODE>type</CODE>,              $<CODE>type_sequence</CODE>,     $<CODE>indent_flag</CODE>,
        ) = @{$<CODE>rTV1</CODE>};

        (
            $<CODE>routput_token_list</CODE>,    $<CODE>routput_token_type</CODE>,
            $<CODE>routput_block_type</CODE>,    $<CODE>routput_container_type</CODE>,
            $<CODE>routput_type_sequence</CODE>, $<CODE>routput_type_sequence</CODE>,
        ) = @{$<CODE>rTV2</CODE>};

        (
            $<CODE>in_quote</CODE>, $<CODE>quote_type</CODE>, $<CODE>quote_character</CODE>, $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>,
            $<CODE>quoted_string_1</CODE>, $<CODE>quoted_string_2</CODE>, $<CODE>allowed_quote_modifiers</CODE>,
        ) = @{$<CODE>rTV3</CODE>};

        ( $<CODE>id_scan_state</CODE>, $<CODE>identifier</CODE>, $<CODE>want_paren</CODE>, $<CODE>indented_if_level</CODE> ) =
          @{$<CODE>rTV4</CODE>};

        (
            $<CODE>nesting_token_string</CODE>,      $<CODE>nesting_type_string</CODE>,
            $<CODE>nesting_block_string</CODE>,      $<CODE>nesting_block_flag</CODE>,
            $<CODE>nesting_list_string</CODE>,       $<CODE>nesting_list_flag</CODE>,
            $<CODE>ci_string_in_tokenizer</CODE>,    $<CODE>continuation_string_in_tokenizer</CODE>,
            $<CODE>in_statement_continuation</CODE>, $<CODE>level_in_tokenizer</CODE>,
            $<CODE>slevel_in_tokenizer</CODE>,       $<CODE>rslevel_stack</CODE>,
        ) = @{$<CODE>rTV5</CODE>};

        (
            $<CODE>last_nonblank_container_type</CODE>,
            $<CODE>last_nonblank_type_sequence</CODE>,
            $<CODE>last_last_nonblank_token</CODE>,
            $<CODE>last_last_nonblank_type</CODE>,
            $<CODE>last_last_nonblank_block_type</CODE>,
            $<CODE>last_last_nonblank_container_type</CODE>,
            $<CODE>last_last_nonblank_type_sequence</CODE>,
            $<CODE>last_nonblank_prototype</CODE>,
        ) = @{$<CODE>rTV6</CODE>};
    }

    sub <CODE>get_indentation_level</CODE> {

        # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>reporting</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>indented</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>terminated</COMMENTS>
        if ($<CODE>indented_if_level</CODE>) { return $<CODE>level_in_tokenizer</CODE> - 1 }
        return $<CODE>level_in_tokenizer</CODE>;
    }

    sub <CODE>reset_indentation_level</CODE> {
        $<CODE>level_in_tokenizer</CODE>  = $<CODE>_</CODE>[0];
        $<CODE>slevel_in_tokenizer</CODE> = $<CODE>_</CODE>[0];
        push @{$<CODE>rslevel_stack</CODE>}, $<CODE>slevel_in_tokenizer</CODE>;
    }

    sub <CODE>peeked_ahead</CODE> {
        $<CODE>peeked_ahead</CODE> = defined( $<CODE>_</CODE>[0] ) ? $<CODE>_</CODE>[0] : $<CODE>peeked_ahead</CODE>;
    }

    # ------------------------------------------------------------
    # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>variable</COMMENTS> <COMMENTS>access</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>manipulation</COMMENTS> <COMMENTS>routines</COMMENTS>
    # ------------------------------------------------------------

    # ------------------------------------------------------------
    # <COMMENTS>beginning</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>various</COMMENTS> <COMMENTS>scanner</COMMENTS> <COMMENTS>interface</COMMENTS> <COMMENTS>routines</COMMENTS>
    # ------------------------------------------------------------
    sub <CODE>scan_replacement_text</CODE> {

        # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>docs</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>replacement</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>invoked</COMMENTS> <COMMENTS>by</COMMENTS>
        # <COMMENTS>a</COMMENTS> <COMMENTS>substitution</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>executable</COMMENTS> <COMMENTS>modifier</COMMENTS> '<COMMENTS>e</COMMENTS>'.
        #
        # <COMMENTS>given</COMMENTS>:
        #  <COMMENTS>$replacement_text</COMMENTS>
        # <COMMENTS>return</COMMENTS>:
        #  <COMMENTS>$rht</COMMENTS> = <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS> <COMMENTS>targets</COMMENTS>
        my ($<CODE>replacement_text</CODE>) = @<CODE>_</CODE>;

        # <COMMENTS>quick</COMMENTS> <COMMENTS>check</COMMENTS>
        return undef unless ( $<CODE>replacement_text</CODE> =~ /<</ );

        <CODE>write_logfile_entry</CODE>("<LITERALS>scanning</LITERALS> <LITERALS>replacement</LITERALS> <LITERALS>text</LITERALS> <LITERALS>for</LITERALS> <LITERALS>here</LITERALS>-<LITERALS>doc</LITERALS> <LITERALS>targets</LITERALS>\n");

        # <COMMENTS>save</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>logger</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>messages</COMMENTS>
        my $<CODE>logger_object</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_logger_object</LITERALS>};

        # <COMMENTS>localize</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>variables</COMMENTS>
        local (
            $<CODE>tokenizer_self</CODE>,                 $<CODE>last_nonblank_token</CODE>,
            $<CODE>last_nonblank_type</CODE>,             $<CODE>last_nonblank_block_type</CODE>,
            $<CODE>statement_type</CODE>,                 $<CODE>in_attribute_list</CODE>,
            $<CODE>current_package</CODE>,                $<CODE>context</CODE>,
            %<CODE>is_constant</CODE>,                    %<CODE>is_user_function</CODE>,
            %<CODE>user_function_prototype</CODE>,        %<CODE>is_block_function</CODE>,
            %<CODE>is_block_list_function</CODE>,         %<CODE>saw_function_definition</CODE>,
            $<CODE>brace_depth</CODE>,                    $<CODE>paren_depth</CODE>,
            $<CODE>square_bracket_depth</CODE>,           @<CODE>current_depth</CODE>,
            @<CODE>total_depth</CODE>,                    $<CODE>total_depth</CODE>,
            @<CODE>nesting_sequence_number</CODE>,        @<CODE>current_sequence_number</CODE>,
            @<CODE>paren_type</CODE>,                     @<CODE>paren_semicolon_count</CODE>,
            @<CODE>paren_structural_type</CODE>,          @<CODE>brace_type</CODE>,
            @<CODE>brace_structural_type</CODE>,          @<CODE>brace_context</CODE>,
            @<CODE>brace_package</CODE>,                  @<CODE>square_bracket_type</CODE>,
            @<CODE>square_bracket_structural_type</CODE>, @<CODE>depth_array</CODE>,
            @<CODE>starting_line_of_current_depth</CODE>, @<CODE>nested_ternary_flag</CODE>,
            @<CODE>nested_statement_type</CODE>,
        );

        # <COMMENTS>save</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>lexical</COMMENTS> <COMMENTS>variables</COMMENTS>
        my $<CODE>rstate</CODE> = <CODE>save_tokenizer_state</CODE>();
        <CODE>_decrement_count</CODE>();    # <COMMENTS>avoid</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>tokenizers</COMMENTS>

        # <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>tokenizer</COMMENTS>
        my $<CODE>rOpts</CODE> = {};
        my $<CODE>rpending_logfile_message</CODE>;
        my $<CODE>source_object</CODE> =
          <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>LineSource</CODE>-><CODE>new</CODE>( \$<CODE>replacement_text</CODE>, $<CODE>rOpts</CODE>,
            $<CODE>rpending_logfile_message</CODE> );
        my $<CODE>tokenizer</CODE> = <CODE>Perl</CODE>::<CODE>Tidy</CODE>::<CODE>Tokenizer</CODE>-><CODE>new</CODE>(
            <LITERALS>source_object</LITERALS>        => $<CODE>source_object</CODE>,
            <LITERALS>logger_object</LITERALS>        => $<CODE>logger_object</CODE>,
            <LITERALS>starting_line_number</LITERALS> => $<CODE>input_line_number</CODE>,
        );

        # <COMMENTS>scan</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>replacement</COMMENTS> <COMMENTS>text</COMMENTS>
        1 while ( $<CODE>tokenizer</CODE>-><CODE>get_line</CODE>() );

        # <COMMENTS>remove</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>doc</COMMENTS> <COMMENTS>targets</COMMENTS>
        my $<CODE>rht</CODE> = undef;
        if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_here_doc</LITERALS>} ) {
            $<CODE>rht</CODE> = [];
            push @{$<CODE>rht</CODE>},
              [
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_here_doc_target</LITERALS>},
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_here_quote_character</LITERALS>}
              ];
            if ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_rhere_target_list</LITERALS>} ) {
                push @{$<CODE>rht</CODE>}, @{ $<CODE>tokenizer_self</CODE>->{<LITERALS>_rhere_target_list</LITERALS>} };
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_rhere_target_list</LITERALS>} = undef;
            }
            $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_here_doc</LITERALS>} = undef;
        }

        # <COMMENTS>now</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>safe</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>report</COMMENTS> <COMMENTS>errors</COMMENTS>
        $<CODE>tokenizer</CODE>-><CODE>report_tokenization_errors</CODE>();

        # <COMMENTS>restore</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>lexical</COMMENTS> <COMMENTS>variables</COMMENTS>
        <CODE>restore_tokenizer_state</CODE>($<CODE>rstate</CODE>);

        # <COMMENTS>return</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>doc</COMMENTS> <COMMENTS>targets</COMMENTS>
        return $<CODE>rht</CODE>;
    }

    sub <CODE>scan_bare_identifier</CODE> {
        ( $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE>, $<CODE>prototype</CODE> ) =
          <CODE>scan_bare_identifier_do</CODE>( $<CODE>input_line</CODE>, $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE>, $<CODE>prototype</CODE>,
            $<CODE>rtoken_map</CODE>, $<CODE>max_token_index</CODE> );
    }

    sub <CODE>scan_identifier</CODE> {
        ( $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE>, $<CODE>id_scan_state</CODE>, $<CODE>identifier</CODE> ) =
          <CODE>scan_identifier_do</CODE>( $<CODE>i</CODE>, $<CODE>id_scan_state</CODE>, $<CODE>identifier</CODE>, $<CODE>rtokens</CODE>,
            $<CODE>max_token_index</CODE>, $<CODE>expecting</CODE>, $<CODE>paren_type</CODE>[$<CODE>paren_depth</CODE>] );
    }

    sub <CODE>scan_id</CODE> {
        ( $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE>, $<CODE>id_scan_state</CODE> ) =
          <CODE>scan_id_do</CODE>( $<CODE>input_line</CODE>, $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_map</CODE>,
            $<CODE>id_scan_state</CODE>, $<CODE>max_token_index</CODE> );
    }

    sub <CODE>scan_number</CODE> {
        my $<CODE>number</CODE>;
        ( $<CODE>i</CODE>, $<CODE>type</CODE>, $<CODE>number</CODE> ) =
          <CODE>scan_number_do</CODE>( $<CODE>input_line</CODE>, $<CODE>i</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>type</CODE>,
            $<CODE>max_token_index</CODE> );
        return $<CODE>number</CODE>;
    }

    # <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>warn</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>found</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>expected</COMMENTS>
    sub <CODE>error_if_expecting_TERM</CODE> {
        if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) {
            if ( $<CODE>really_want_term</CODE>{$<CODE>last_nonblank_type</CODE>} ) {
                <CODE>unexpected</CODE>( $<CODE>tok</CODE>, "<LITERALS>term</LITERALS>", $<CODE>i_tok</CODE>, $<CODE>last_nonblank_i</CODE>, $<CODE>rtoken_map</CODE>,
                    $<CODE>rtoken_type</CODE>, $<CODE>input_line</CODE> );
                1;
            }
        }
    }

    # <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>warn</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>found</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>expected</COMMENTS>
    sub <CODE>error_if_expecting_OPERATOR</CODE> {
        if ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> ) {
            my $<CODE>thing</CODE> = defined $<CODE>_</CODE>[0] ? $<CODE>_</CODE>[0] : $<CODE>tok</CODE>;
            <CODE>unexpected</CODE>( $<CODE>thing</CODE>, "<LITERALS>operator</LITERALS>", $<CODE>i_tok</CODE>, $<CODE>last_nonblank_i</CODE>,
                $<CODE>rtoken_map</CODE>, $<CODE>rtoken_type</CODE>, $<CODE>input_line</CODE> );
            if ( $<CODE>i_tok</CODE> == 0 ) {
                <CODE>interrupt_logfile</CODE>();
                <CODE>warning</CODE>("<LITERALS>Missing</LITERALS> ';' <LITERALS>above</LITERALS>?\n");
                <CODE>resume_logfile</CODE>();
            }
            1;
        }
    }

    # ------------------------------------------------------------
    # <COMMENTS>end</COMMENTS> <COMMENTS>scanner</COMMENTS> <COMMENTS>interfaces</COMMENTS>
    # ------------------------------------------------------------

    my %<CODE>is_for_foreach</CODE>;
    @<CODE>_</CODE> = qw(<LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS>);
    @<CODE>is_for_foreach</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    my %<CODE>is_my_our</CODE>;
    @<CODE>_</CODE> = qw(<LITERALS>my</LITERALS> <LITERALS>our</LITERALS>);
    @<CODE>is_my_our</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>These</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>introduce</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>parenthesized</COMMENTS> <COMMENTS>expressions</COMMENTS>,
    # <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>form</COMMENTS>:
    # <COMMENTS>keyword</COMMENTS> ( .... ) { <COMMENTS>BLOCK</COMMENTS> }
    # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS>: <COMMENTS>added</COMMENTS> '<COMMENTS>switch</COMMENTS>' '<COMMENTS>case</COMMENTS>' '<COMMENTS>given</COMMENTS>' '<COMMENTS>when</COMMENTS>'
    my %<CODE>is_blocktype_with_paren</CODE>;
    @<CODE>_</CODE> =
      qw(<LITERALS>if</LITERALS> <LITERALS>elsif</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>while</LITERALS> <LITERALS>until</LITERALS> <LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS> <LITERALS>switch</LITERALS> <LITERALS>case</LITERALS> <LITERALS>given</LITERALS> <LITERALS>when</LITERALS> <LITERALS>catch</LITERALS>);
    @<CODE>is_blocktype_with_paren</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # ------------------------------------------------------------
    # <COMMENTS>begin</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>handling</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>
    # ------------------------------------------------------------
    my $<CODE>tokenization_code</CODE> = {

        # <COMMENTS>no</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>yet</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>checks</COMMENTS>
        # <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>added</COMMENTS>

##      '!'   => <COMMENTS>undef</COMMENTS>,
##      '!='  => <COMMENTS>undef</COMMENTS>,
##      '!~'  => <COMMENTS>undef</COMMENTS>,
##      '%='  => <COMMENTS>undef</COMMENTS>,
##      '&&=' => <COMMENTS>undef</COMMENTS>,
##      '&='  => <COMMENTS>undef</COMMENTS>,
##      '+='  => <COMMENTS>undef</COMMENTS>,
##      '-='  => <COMMENTS>undef</COMMENTS>,
##      '..'  => <COMMENTS>undef</COMMENTS>,
##      '..'  => <COMMENTS>undef</COMMENTS>,
##      '...' => <COMMENTS>undef</COMMENTS>,
##      '.='  => <COMMENTS>undef</COMMENTS>,
##      '<<=' => <COMMENTS>undef</COMMENTS>,
##      '<='  => <COMMENTS>undef</COMMENTS>,
##      '<=>' => <COMMENTS>undef</COMMENTS>,
##      '<>'  => <COMMENTS>undef</COMMENTS>,
##      '='   => <COMMENTS>undef</COMMENTS>,
##      '=='  => <COMMENTS>undef</COMMENTS>,
##      '=~'  => <COMMENTS>undef</COMMENTS>,
##      '>='  => <COMMENTS>undef</COMMENTS>,
##      '>>'  => <COMMENTS>undef</COMMENTS>,
##      '>>=' => <COMMENTS>undef</COMMENTS>,
##      '\\'  => <COMMENTS>undef</COMMENTS>,
##      '^='  => <COMMENTS>undef</COMMENTS>,
##      '|='  => <COMMENTS>undef</COMMENTS>,
##      '||=' => <COMMENTS>undef</COMMENTS>,
##      '//=' => <COMMENTS>undef</COMMENTS>,
##      '~'   => <COMMENTS>undef</COMMENTS>,
##      '~~'  => <COMMENTS>undef</COMMENTS>,
##      '!~~'  => <COMMENTS>undef</COMMENTS>,

        '>' => sub {
            <CODE>error_if_expecting_TERM</CODE>()
              if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> );
        },
        '|' => sub {
            <CODE>error_if_expecting_TERM</CODE>()
              if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> );
        },
        '<LITERALS>$</LITERALS>' => sub {

            # <COMMENTS>start</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>scalar</COMMENTS>
            <CODE>error_if_expecting_OPERATOR</CODE>("<LITERALS>Scalar</LITERALS>")
              if ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> );
            <CODE>scan_identifier</CODE>();

            if ( $<CODE>identifier</CODE> eq '<LITERALS>$</LITERALS>^<LITERALS>W</LITERALS>' ) {
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_perl_dash_w</LITERALS>} = 1;
            }

            # <COMMENTS>Check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>identifier</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>indirect</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>slot</COMMENTS>
            # (<COMMENTS>vorboard</COMMENTS>.<COMMENTS>pl</COMMENTS>, <COMMENTS>sort</COMMENTS>.<COMMENTS>t</COMMENTS>).  <COMMENTS>Something</COMMENTS> <COMMENTS>like</COMMENTS>:
            #   /^(<COMMENTS>print</COMMENTS>|<COMMENTS>printf</COMMENTS>|<COMMENTS>sort</COMMENTS>|<COMMENTS>exec</COMMENTS>|<COMMENTS>system</COMMENTS>)<COMMENTS>$</COMMENTS>/
            if (
                $<CODE>is_indirect_object_taker</CODE>{$<CODE>last_nonblank_token</CODE>}

                || ( ( $<CODE>last_nonblank_token</CODE> eq '(' )
                    && $<CODE>is_indirect_object_taker</CODE>{ $<CODE>paren_type</CODE>[$<CODE>paren_depth</CODE>] } )
                || ( $<CODE>last_nonblank_type</CODE> =~ /^[Uw]$/ )    # <COMMENTS>possible</COMMENTS> <COMMENTS>object</COMMENTS>
              )
            {
                $<CODE>type</CODE> = '<LITERALS>Z</LITERALS>';
            }
        },
        '(' => sub {

            ++$<CODE>paren_depth</CODE>;
            $<CODE>paren_semicolon_count</CODE>[$<CODE>paren_depth</CODE>] = 0;
            if ($<CODE>want_paren</CODE>) {
                $<CODE>container_type</CODE> = $<CODE>want_paren</CODE>;
                $<CODE>want_paren</CODE>     = "";
            }
            elsif ( $<CODE>statement_type</CODE> =~ /^sub/ ) {
                $<CODE>container_type</CODE> = $<CODE>statement_type</CODE>;
            }
            else {
                $<CODE>container_type</CODE> = $<CODE>last_nonblank_token</CODE>;

                # <COMMENTS>We</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>unexpected</COMMENTS> '(',
                # <COMMENTS>but</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>going</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>messy</COMMENTS>...
                if (
                    $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE>

                    # <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>form</COMMENTS>
                    # &<COMMENTS>method</COMMENTS>(...), <COMMENTS>$method</COMMENTS>->(..), &{<COMMENTS>method</COMMENTS>}(...),
                    # <COMMENTS>$ref</COMMENTS>[<COMMENTS>2</COMMENTS>](<COMMENTS>list</COMMENTS>) <COMMENTS>is</COMMENTS> <COMMENTS>ok</COMMENTS> & <COMMENTS>short</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>$ref</COMMENTS>[<COMMENTS>2</COMMENTS>]->(<COMMENTS>list</COMMENTS>)
                    # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>at</COMMENTS> <COMMENTS>present</COMMENTS>, <COMMENTS>braces</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> &{ <COMMENTS>xxx</COMMENTS> }
                    # <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>marked</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>call</COMMENTS>
                    && $<CODE>last_nonblank_token</CODE> !~ /^([\]\}\&]|\-\>)/

                  )
                {

                    # <COMMENTS>ref</COMMENTS>: <COMMENTS>camel</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>p</COMMENTS> <COMMENTS>703</COMMENTS>.
                    if ( $<CODE>last_last_nonblank_token</CODE> eq '<LITERALS>do</LITERALS>' ) {
                        <CODE>complain</CODE>(
"<LITERALS>do</LITERALS> <LITERALS>SUBROUTINE</LITERALS> <LITERALS>is</LITERALS> <LITERALS>deprecated</LITERALS>; <LITERALS>consider</LITERALS> & <LITERALS>or</LITERALS> -> <LITERALS>notation</LITERALS>\n"
                        );
                    }
                    else {

                        # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>list</COMMENTS>, (), <COMMENTS>then</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>an</COMMENTS>
                        # <COMMENTS>error</COMMENTS>; <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>constant</COMMENTS> <COMMENTS>pi</COMMENTS> <COMMENTS>and</COMMENTS>
                        # <COMMENTS>invoke</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>pi</COMMENTS>() <COMMENTS>or</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>pi</COMMENTS>;
                        my ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_next</CODE> ) =
                          <CODE>find_next_nonblank_token</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>,
                            $<CODE>max_token_index</CODE> );
                        if ( $<CODE>next_nonblank_token</CODE> ne ')' ) {
                            my $<CODE>hint</CODE>;
                            <CODE>error_if_expecting_OPERATOR</CODE>('(');

                            if ( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>C</LITERALS>' ) {
                                $<CODE>hint</CODE> =
                                  "$<CODE>last_nonblank_token</CODE> <LITERALS>has</LITERALS> <LITERALS>a</LITERALS> <LITERALS>void</LITERALS> <LITERALS>prototype</LITERALS>\n";
                            }
                            elsif ( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>i</LITERALS>' ) {
                                if (   $<CODE>i_tok</CODE> > 0
                                    && $<CODE>last_nonblank_token</CODE> =~ /^\$/ )
                                {
                                    $<CODE>hint</CODE> =
"<LITERALS>Do</LITERALS> <LITERALS>you</LITERALS> <LITERALS>mean</LITERALS> '$<CODE>last_nonblank_token</CODE>->(' ?\n";
                                }
                            }
                            if ($<CODE>hint</CODE>) {
                                <CODE>interrupt_logfile</CODE>();
                                <CODE>warning</CODE>($<CODE>hint</CODE>);
                                <CODE>resume_logfile</CODE>();
                            }
                        } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$next_nonblank_token</COMMENTS>...
                    } ## <COMMENTS>end</COMMENTS> <COMMENTS>else</COMMENTS> [ <COMMENTS>if</COMMENTS> ( <COMMENTS>$last_last_nonblank_token</COMMENTS>...
                } ## <COMMENTS>end</COMMENTS> <COMMENTS>if</COMMENTS> ( <COMMENTS>$expecting</COMMENTS> == <COMMENTS>OPERATOR</COMMENTS>...
            }
            $<CODE>paren_type</CODE>[$<CODE>paren_depth</CODE>] = $<CODE>container_type</CODE>;
            ( $<CODE>type_sequence</CODE>, $<CODE>indent_flag</CODE> ) =
              <CODE>increase_nesting_depth</CODE>( <CODE>PAREN</CODE>, $$<CODE>rtoken_map</CODE>[$<CODE>i_tok</CODE>] );

            # <COMMENTS>propagate</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>down</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>nested</COMMENTS> <COMMENTS>parens</COMMENTS>
            # <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>: <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>in</COMMENTS> '<COMMENTS>if</COMMENTS> ((' <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>structural</COMMENTS>
            # <COMMENTS>since</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>is</COMMENTS>.

            if ( $<CODE>last_nonblank_token</CODE> eq '(' ) {
                $<CODE>type</CODE> = $<CODE>last_nonblank_type</CODE>;
            }

            #     <COMMENTS>We</COMMENTS> <COMMENTS>exclude</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> ',' <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS>
            #     <COMMENTS>causes</COMMENTS> <COMMENTS>subtle</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>for</COMMENTS>
            #     <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>, <COMMENTS>where</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> '<COMMENTS>or</COMMENTS>' <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>get</COMMENTS>
            #     <COMMENTS>indented</COMMENTS>.
            #
            #         <COMMENTS>assert</COMMENTS>(
            #             <COMMENTS>__LINE__</COMMENTS>,
            #             ( <COMMENTS>not</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>$check</COMMENTS> )
            #               <COMMENTS>or</COMMENTS> <COMMENTS>ref</COMMENTS> <COMMENTS>$check</COMMENTS>
            #               <COMMENTS>or</COMMENTS> <COMMENTS>$check</COMMENTS> <COMMENTS>eq</COMMENTS> "<COMMENTS>new</COMMENTS>"
            #               <COMMENTS>or</COMMENTS> <COMMENTS>$check</COMMENTS> <COMMENTS>eq</COMMENTS> "<COMMENTS>old</COMMENTS>",
            #         );
            #
            #     <COMMENTS>Likewise</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>exclude</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>start</COMMENTS>
            #     <COMMENTS>because</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>problems</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS>, <COMMENTS>like</COMMENTS>
            #     <COMMENTS>these</COMMENTS>:
            #
            #         (<COMMENTS>$firstline</COMMENTS> =~ /^#\!.*<COMMENTS>perl</COMMENTS>/)
            #         <COMMENTS>and</COMMENTS> (<COMMENTS>print</COMMENTS> <COMMENTS>$File</COMMENTS>::<COMMENTS>Find</COMMENTS>::<COMMENTS>name</COMMENTS>, "\<COMMENTS>n</COMMENTS>")
            #           <COMMENTS>and</COMMENTS> (<COMMENTS>return</COMMENTS> <COMMENTS>1</COMMENTS>);
            #
            #         (<COMMENTS>ref</COMMENTS>(<COMMENTS>$usage_fref</COMMENTS>) =~ /<COMMENTS>CODE</COMMENTS>/)
            #         ? &<COMMENTS>$usage_fref</COMMENTS>
            #           : (&<COMMENTS>blast_usage</COMMENTS>, &<COMMENTS>blast_params</COMMENTS>, &<COMMENTS>blast_general_params</COMMENTS>);

            else {
                $<CODE>type</CODE> = '{';
            }

            if ( $<CODE>last_nonblank_type</CODE> eq ')' ) {
                <CODE>warning</CODE>(
                    "<LITERALS>Syntax</LITERALS> <LITERALS>error</LITERALS>? <LITERALS>found</LITERALS> <LITERALS>token</LITERALS> '$<CODE>last_nonblank_type</CODE>' <LITERALS>then</LITERALS> '('\n"
                );
            }
            $<CODE>paren_structural_type</CODE>[$<CODE>paren_depth</CODE>] = $<CODE>type</CODE>;

        },
        ')' => sub {
            ( $<CODE>type_sequence</CODE>, $<CODE>indent_flag</CODE> ) =
              <CODE>decrease_nesting_depth</CODE>( <CODE>PAREN</CODE>, $$<CODE>rtoken_map</CODE>[$<CODE>i_tok</CODE>] );

            if ( $<CODE>paren_structural_type</CODE>[$<CODE>paren_depth</CODE>] eq '{' ) {
                $<CODE>type</CODE> = '}';
            }

            $<CODE>container_type</CODE> = $<CODE>paren_type</CODE>[$<CODE>paren_depth</CODE>];

            #    /^(<COMMENTS>for</COMMENTS>|<COMMENTS>foreach</COMMENTS>)<COMMENTS>$</COMMENTS>/
            if ( $<CODE>is_for_foreach</CODE>{ $<CODE>paren_type</CODE>[$<CODE>paren_depth</CODE>] } ) {
                my $<CODE>num_sc</CODE> = $<CODE>paren_semicolon_count</CODE>[$<CODE>paren_depth</CODE>];
                if ( $<CODE>num_sc</CODE> > 0 && $<CODE>num_sc</CODE> != 2 ) {
                    <CODE>warning</CODE>("<LITERALS>Expected</LITERALS> <LITERALS>2</LITERALS> ';' <LITERALS>in</LITERALS> '<LITERALS>for</LITERALS>(;;)' <LITERALS>but</LITERALS> <LITERALS>saw</LITERALS> $<CODE>num_sc</CODE>\n");
                }
            }

            if ( $<CODE>paren_depth</CODE> > 0 ) { $<CODE>paren_depth</CODE>-- }
        },
        ',' => sub {
            if ( $<CODE>last_nonblank_type</CODE> eq ',' ) {
                <CODE>complain</CODE>("<LITERALS>Repeated</LITERALS> ','<LITERALS>s</LITERALS> \n");
            }

            # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>operator_expected</COMMENTS>: <COMMENTS>note</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> (<COMMENTS>use</COMMENTS>.<COMMENTS>t</COMMENTS>)
            if ( $<CODE>statement_type</CODE> eq '<LITERALS>use</LITERALS>' ) { $<CODE>statement_type</CODE> = '<LITERALS>_use</LITERALS>' }
##                <COMMENTS>FIXME</COMMENTS>: <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>move</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>elsewhere</COMMENTS>, <COMMENTS>perhaps</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> '('
##                <COMMENTS>elsif</COMMENTS> (<COMMENTS>$last_nonblank_token</COMMENTS> <COMMENTS>eq</COMMENTS> '(') {
##                    <COMMENTS>warning</COMMENTS>("<COMMENTS>Leading</COMMENTS> ','<COMMENTS>s</COMMENTS> <COMMENTS>illegal</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>versions</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS>\<COMMENTS>n</COMMENTS>");
##                }
        },
        ';' => sub {
            $<CODE>context</CODE>        = <CODE>UNKNOWN_CONTEXT</CODE>;
            $<CODE>statement_type</CODE> = '';
            $<CODE>want_paren</CODE>     = "";

            #    /^(<COMMENTS>for</COMMENTS>|<COMMENTS>foreach</COMMENTS>)<COMMENTS>$</COMMENTS>/
            if ( $<CODE>is_for_foreach</CODE>{ $<CODE>paren_type</CODE>[$<CODE>paren_depth</CODE>] } )
            {    # <COMMENTS>mark</COMMENTS> ; <COMMENTS>in</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>loop</COMMENTS>

                # <COMMENTS>Be</COMMENTS> <COMMENTS>careful</COMMENTS>: <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>semicolon</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS>
                # <COMMENTS>following</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>included</COMMENTS>:
                #
                #    <COMMENTS>for</COMMENTS> (<COMMENTS>sort</COMMENTS> {<COMMENTS>strcoll</COMMENTS>(<COMMENTS>$a</COMMENTS>,<COMMENTS>$b</COMMENTS>);} <COMMENTS>keys</COMMENTS> %<COMMENTS>investments</COMMENTS>) {

                if (   $<CODE>brace_depth</CODE> == $<CODE>depth_array</CODE>[<CODE>PAREN</CODE>][<CODE>BRACE</CODE>][$<CODE>paren_depth</CODE>]
                    && $<CODE>square_bracket_depth</CODE> ==
                    $<CODE>depth_array</CODE>[<CODE>PAREN</CODE>][<CODE>SQUARE_BRACKET</CODE>][$<CODE>paren_depth</CODE>] )
                {

                    $<CODE>type</CODE> = '<LITERALS>f</LITERALS>';
                    $<CODE>paren_semicolon_count</CODE>[$<CODE>paren_depth</CODE>]++;
                }
            }

        },
        '"' => sub {
            <CODE>error_if_expecting_OPERATOR</CODE>("<LITERALS>String</LITERALS>")
              if ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> );
            $<CODE>in_quote</CODE>                = 1;
            $<CODE>type</CODE>                    = '<LITERALS>Q</LITERALS>';
            $<CODE>allowed_quote_modifiers</CODE> = "";
        },
        "'" => sub {
            <CODE>error_if_expecting_OPERATOR</CODE>("<LITERALS>String</LITERALS>")
              if ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> );
            $<CODE>in_quote</CODE>                = 1;
            $<CODE>type</CODE>                    = '<LITERALS>Q</LITERALS>';
            $<CODE>allowed_quote_modifiers</CODE> = "";
        },
        '`' => sub {
            <CODE>error_if_expecting_OPERATOR</CODE>("<LITERALS>String</LITERALS>")
              if ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> );
            $<CODE>in_quote</CODE>                = 1;
            $<CODE>type</CODE>                    = '<LITERALS>Q</LITERALS>';
            $<CODE>allowed_quote_modifiers</CODE> = "";
        },
        '/' => sub {
            my $<CODE>is_pattern</CODE>;

            if ( $<CODE>expecting</CODE> == <CODE>UNKNOWN</CODE> ) {    # <COMMENTS>indeterminate</COMMENTS>, <COMMENTS>must</COMMENTS> <COMMENTS>guess</COMMENTS>..
                my $<CODE>msg</CODE>;
                ( $<CODE>is_pattern</CODE>, $<CODE>msg</CODE> ) =
                  <CODE>guess_if_pattern_or_division</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_map</CODE>,
                    $<CODE>max_token_index</CODE> );

                if ($<CODE>msg</CODE>) {
                    <CODE>write_diagnostics</CODE>("<LITERALS>DIVIDE</LITERALS>:$<CODE>msg</CODE>\n");
                    <CODE>write_logfile_entry</CODE>($<CODE>msg</CODE>);
                }
            }
            else { $<CODE>is_pattern</CODE> = ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) }

            if ($<CODE>is_pattern</CODE>) {
                $<CODE>in_quote</CODE>                = 1;
                $<CODE>type</CODE>                    = '<LITERALS>Q</LITERALS>';
                $<CODE>allowed_quote_modifiers</CODE> = '[<LITERALS>msixpodualngc</LITERALS>]';
            }
            else {    # <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS>; <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> /= <COMMENTS>token</COMMENTS>

                if ( $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ] eq '=' ) {    # <COMMENTS>form</COMMENTS> <COMMENTS>token</COMMENTS> /=
                    $<CODE>i</CODE>++;
                    $<CODE>tok</CODE>  = '/=';
                    $<CODE>type</CODE> = $<CODE>tok</CODE>;
                }

              #<COMMENTS>DEBUG</COMMENTS> - <COMMENTS>collecting</COMMENTS> <COMMENTS>info</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>divide</COMMENTS>
              # <COMMENTS>for</COMMENTS> <COMMENTS>development</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>guessing</COMMENTS> <COMMENTS>algorithm</COMMENTS>
              #<COMMENTS>if</COMMENTS> ( <COMMENTS>numerator_expected</COMMENTS>( <COMMENTS>$i</COMMENTS>, <COMMENTS>$rtokens</COMMENTS>, <COMMENTS>$max_token_index</COMMENTS> ) < <COMMENTS>0</COMMENTS> ) {
              #    #<COMMENTS>write_diagnostics</COMMENTS>( "<COMMENTS>DIVIDE</COMMENTS>? <COMMENTS>$input_line</COMMENTS>\<COMMENTS>n</COMMENTS>" );
              #}
            }
        },
        '{' => sub {

            # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>saw</COMMENTS> <COMMENTS>a</COMMENTS> ')', <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>label</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>with</COMMENTS>
            # <COMMENTS>its</COMMENTS> <COMMENTS>type</COMMENTS>.  <COMMENTS>We</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>sub</COMMENTS>
            # <COMMENTS>code_block_type</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>determine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>starts</COMMENTS> <COMMENTS>a</COMMENTS>
            # <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS>.  (<COMMENTS>The</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>paren</COMMENTS>
            # <COMMENTS>pair</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>preceding</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> '<COMMENTS>if</COMMENTS>', '<COMMENTS>else</COMMENTS>',
            # <COMMENTS>etc</COMMENTS>).
            $<CODE>container_type</CODE> = "";

            # <COMMENTS>ATTRS</COMMENTS>: <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> '{' <COMMENTS>following</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>attribute</COMMENTS> <COMMENTS>list</COMMENTS>, <COMMENTS>reset</COMMENTS>
            # <COMMENTS>things</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>saw</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>name</COMMENTS>
            if ( $<CODE>statement_type</CODE> =~ /^sub/ ) {
                $<CODE>last_nonblank_token</CODE> = $<CODE>statement_type</CODE>;
                $<CODE>last_nonblank_type</CODE>  = '<LITERALS>i</LITERALS>';
                $<CODE>statement_type</CODE>      = "";
            }

            # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS>: <COMMENTS>hide</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>immediately</COMMENTS>
            # <COMMENTS>following</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS>
            elsif ( ( $<CODE>statement_type</CODE> eq '<LITERALS>case</LITERALS>' || $<CODE>statement_type</CODE> eq '<LITERALS>when</LITERALS>' )
                && $<CODE>statement_type</CODE> eq $<CODE>last_nonblank_token</CODE> )
            {
                $<CODE>last_nonblank_token</CODE> = ";";
            }

            elsif ( $<CODE>last_nonblank_token</CODE> eq ')' ) {
                $<CODE>last_nonblank_token</CODE> = $<CODE>paren_type</CODE>[ $<CODE>paren_depth</CODE> + 1 ];

                # <COMMENTS>defensive</COMMENTS> <COMMENTS>move</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>error</COMMENTS> (<COMMENTS>pbug</COMMENTS>.<COMMENTS>t</COMMENTS>)
                # <COMMENTS>in</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>this</COMMENTS> ')' <COMMENTS>had</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>previous</COMMENTS> '('
                # <COMMENTS>this</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>caught</COMMENTS>
                if ( !defined($<CODE>last_nonblank_token</CODE>) ) {
                    $<CODE>last_nonblank_token</CODE> = '<LITERALS>if</LITERALS>';
                }

                # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>here</COMMENTS>;
                unless ( $<CODE>is_blocktype_with_paren</CODE>{$<CODE>last_nonblank_token</CODE>} ) {
                    if ( $<CODE>tokenizer_self</CODE>->{'<LITERALS>_extended_syntax</LITERALS>'} ) {

                        # <COMMENTS>we</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>trailing</COMMENTS> () <COMMENTS>to</COMMENTS> <COMMENTS>mark</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>unknown</COMMENTS>
                        # <COMMENTS>block</COMMENTS> <COMMENTS>type</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>allows</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>format</COMMENTS> <COMMENTS>some</COMMENTS>
                        # <COMMENTS>common</COMMENTS> <COMMENTS>extensions</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>syntax</COMMENTS>.
                        # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>code_block_type</COMMENTS>
                        $<CODE>last_nonblank_token</CODE> .= '()';
                    }
                    else {
                        my $<CODE>list</CODE> =
                          join( ' ', sort keys %<CODE>is_blocktype_with_paren</CODE> );
                        <CODE>warning</CODE>(
"<LITERALS>syntax</LITERALS> <LITERALS>error</LITERALS> <LITERALS>at</LITERALS> ') {', <LITERALS>didn</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>see</LITERALS> <LITERALS>one</LITERALS> <LITERALS>of</LITERALS>: <<$<CODE>list</CODE>>>; <LITERALS>If</LITERALS> <LITERALS>this</LITERALS> <LITERALS>code</LITERALS> <LITERALS>is</LITERALS> <LITERALS>okay</LITERALS> <LITERALS>try</LITERALS> <LITERALS>using</LITERALS> <LITERALS>the</LITERALS> -<LITERALS>xs</LITERALS> <LITERALS>flag</LITERALS>\n"
                        );
                    }
                }
            }

            # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>paren</COMMENTS>-<COMMENTS>less</COMMENTS> <COMMENTS>for</COMMENTS>/<COMMENTS>foreach</COMMENTS> <COMMENTS>glitch</COMMENTS>, <COMMENTS>part</COMMENTS> <COMMENTS>2</COMMENTS>.
            # <COMMENTS>see</COMMENTS> <COMMENTS>note</COMMENTS> <COMMENTS>below</COMMENTS> <COMMENTS>under</COMMENTS> '<COMMENTS>qw</COMMENTS>'
            elsif ($<CODE>last_nonblank_token</CODE> eq '<LITERALS>qw</LITERALS>'
                && $<CODE>is_for_foreach</CODE>{$<CODE>want_paren</CODE>} )
            {
                $<CODE>last_nonblank_token</CODE> = $<CODE>want_paren</CODE>;
                if ( $<CODE>last_last_nonblank_token</CODE> eq $<CODE>want_paren</CODE> ) {
                    <CODE>warning</CODE>(
"<LITERALS>syntax</LITERALS> <LITERALS>error</LITERALS> <LITERALS>at</LITERALS> '$<CODE>want_paren</CODE> .. {' -- <LITERALS>missing</LITERALS> \<LITERALS>$</LITERALS> <LITERALS>loop</LITERALS> <LITERALS>variable</LITERALS>\n"
                    );

                }
                $<CODE>want_paren</CODE> = "";
            }

            # <COMMENTS>now</COMMENTS> <COMMENTS>identify</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>three</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>of</COMMENTS>
            # <COMMENTS>curly</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS>: <COMMENTS>hash</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>container</COMMENTS>, <COMMENTS>anonymous</COMMENTS>
            # <COMMENTS>hash</COMMENTS> <COMMENTS>reference</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>.

            # <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS> (<COMMENTS>hash</COMMENTS> <COMMENTS>index</COMMENTS>) <COMMENTS>curly</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>pair</COMMENTS>
            # <COMMENTS>get</COMMENTS> <COMMENTS>marked</COMMENTS> '<COMMENTS>L</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>R</COMMENTS>'
            if ( <CODE>is_non_structural_brace</CODE>() ) {
                $<CODE>type</CODE> = '<LITERALS>L</LITERALS>';

                # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS>:
                # <COMMENTS>allow</COMMENTS> <COMMENTS>paren</COMMENTS>-<COMMENTS>less</COMMENTS> <COMMENTS>identifier</COMMENTS> <COMMENTS>after</COMMENTS> '<COMMENTS>when</COMMENTS>'
                # <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>preceded</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS>
                if (   $<CODE>statement_type</CODE> eq '<LITERALS>when</LITERALS>'
                    && $<CODE>last_nonblank_type</CODE> eq '<LITERALS>i</LITERALS>'
                    && $<CODE>last_last_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>'
                    && ( $<CODE>i_tok</CODE> == 0 || $<CODE>rtoken_type</CODE>->[ $<CODE>i_tok</CODE> - 1 ] eq '<LITERALS>b</LITERALS>' ) )
                {
                    $<CODE>type</CODE>       = '{';
                    $<CODE>block_type</CODE> = $<CODE>statement_type</CODE>;
                }
            }

            # <COMMENTS>code</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>type</COMMENTS>, '{', <COMMENTS>but</COMMENTS> <COMMENTS>are</COMMENTS>
            # <COMMENTS>distinguished</COMMENTS> <COMMENTS>by</COMMENTS> '<COMMENTS>block_type</COMMENTS>',
            # <COMMENTS>which</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS>
            else {

                $<CODE>block_type</CODE> = <CODE>code_block_type</CODE>( $<CODE>i_tok</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>,
                    $<CODE>max_token_index</CODE> );

                # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>promote</COMMENTS> <COMMENTS>bareword</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>taking</COMMENTS> <COMMENTS>block</COMMENTS>
                if (   $<CODE>block_type</CODE>
                    && $<CODE>last_nonblank_type</CODE> eq '<LITERALS>w</LITERALS>'
                    && $<CODE>last_nonblank_i</CODE> >= 0 )
                {
                    if ( $<CODE>routput_token_type</CODE>->[$<CODE>last_nonblank_i</CODE>] eq '<LITERALS>w</LITERALS>' ) {
                        $<CODE>routput_token_type</CODE>->[$<CODE>last_nonblank_i</CODE>] = '<LITERALS>G</LITERALS>';
                    }
                }

                # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS>: <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>stray</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>brace</COMMENTS>
                # <COMMENTS>where</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>accept</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>case</COMMENTS>' <COMMENTS>or</COMMENTS> '<COMMENTS>when</COMMENTS>' <COMMENTS>block</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>take</COMMENTS> <COMMENTS>it</COMMENTS>
                if (   $<CODE>statement_type</CODE> eq '<LITERALS>case</LITERALS>'
                    || $<CODE>statement_type</CODE> eq '<LITERALS>when</LITERALS>' )
                {
                    if ( !$<CODE>block_type</CODE> || $<CODE>block_type</CODE> eq '}' ) {
                        $<CODE>block_type</CODE> = $<CODE>statement_type</CODE>;
                    }
                }
            }

            $<CODE>brace_type</CODE>[ ++$<CODE>brace_depth</CODE> ]        = $<CODE>block_type</CODE>;
            $<CODE>brace_package</CODE>[$<CODE>brace_depth</CODE>]         = $<CODE>current_package</CODE>;
            $<CODE>brace_structural_type</CODE>[$<CODE>brace_depth</CODE>] = $<CODE>type</CODE>;
            $<CODE>brace_context</CODE>[$<CODE>brace_depth</CODE>]         = $<CODE>context</CODE>;
            ( $<CODE>type_sequence</CODE>, $<CODE>indent_flag</CODE> ) =
              <CODE>increase_nesting_depth</CODE>( <CODE>BRACE</CODE>, $$<CODE>rtoken_map</CODE>[$<CODE>i_tok</CODE>] );
        },
        '}' => sub {
            $<CODE>block_type</CODE> = $<CODE>brace_type</CODE>[$<CODE>brace_depth</CODE>];
            if ($<CODE>block_type</CODE>) { $<CODE>statement_type</CODE> = '' }
            if ( defined( $<CODE>brace_package</CODE>[$<CODE>brace_depth</CODE>] ) ) {
                $<CODE>current_package</CODE> = $<CODE>brace_package</CODE>[$<CODE>brace_depth</CODE>];
            }

            # <COMMENTS>can</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>error</COMMENTS> (<COMMENTS>caught</COMMENTS> <COMMENTS>elsewhere</COMMENTS>)
            else {
            }
            ( $<CODE>type_sequence</CODE>, $<CODE>indent_flag</CODE> ) =
              <CODE>decrease_nesting_depth</CODE>( <CODE>BRACE</CODE>, $$<CODE>rtoken_map</CODE>[$<CODE>i_tok</CODE>] );

            if ( $<CODE>brace_structural_type</CODE>[$<CODE>brace_depth</CODE>] eq '<LITERALS>L</LITERALS>' ) {
                $<CODE>type</CODE> = '<LITERALS>R</LITERALS>';
            }

            # <COMMENTS>propagate</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>information</COMMENTS> <COMMENTS>for</COMMENTS> '<COMMENTS>do</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>eval</COMMENTS>' <COMMENTS>blocks</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>also</COMMENTS>
            # <COMMENTS>for</COMMENTS> <COMMENTS>smartmatch</COMMENTS> <COMMENTS>operator</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>enable</COMMENTS> <COMMENTS>us</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>know</COMMENTS>
            # <COMMENTS>if</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>expected</COMMENTS> <COMMENTS>next</COMMENTS>.
            if ( $<CODE>is_block_operator</CODE>{$<CODE>block_type</CODE>} ) {
                $<CODE>tok</CODE> = $<CODE>block_type</CODE>;
            }

            $<CODE>context</CODE> = $<CODE>brace_context</CODE>[$<CODE>brace_depth</CODE>];
            if ( $<CODE>brace_depth</CODE> > 0 ) { $<CODE>brace_depth</CODE>--; }
        },
        '&' => sub {    # <COMMENTS>maybe</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>call</COMMENTS>? <COMMENTS>start</COMMENTS> <COMMENTS>looking</COMMENTS>

            # <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS>
            # <COMMENTS>are</COMMENTS> <COMMENTS>expecting</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>s2p</COMMENTS>
            # <COMMENTS>got</COMMENTS> <COMMENTS>mistaken</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>q</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>early</COMMENTS> <COMMENTS>version</COMMENTS>:
            #   <COMMENTS>print</COMMENTS> <COMMENTS>BODY</COMMENTS> &<COMMENTS>q</COMMENTS>(<<'<COMMENTS>EOT</COMMENTS>');
            if ( $<CODE>expecting</CODE> != <CODE>OPERATOR</CODE> ) {

                # <COMMENTS>But</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>expecting</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>or</COMMENTS>
                # <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>existing</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> &.
                # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>want</COMMENTS> & <COMMENTS>as</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>here</COMMENTS>:
                #    <COMMENTS>Fcntl</COMMENTS>::<COMMENTS>S_IRUSR</COMMENTS> & <COMMENTS>$mode</COMMENTS>;
                if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> || $<CODE>next_type</CODE> ne '<LITERALS>b</LITERALS>' ) {
                    <CODE>scan_identifier</CODE>();
                }
            }
            else {
            }
        },
        '<' => sub {    # <COMMENTS>angle</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>less</COMMENTS> <COMMENTS>than</COMMENTS>?

            if ( $<CODE>expecting</CODE> != <CODE>OPERATOR</CODE> ) {
                ( $<CODE>i</CODE>, $<CODE>type</CODE> ) =
                  <CODE>find_angle_operator_termination</CODE>( $<CODE>input_line</CODE>, $<CODE>i</CODE>, $<CODE>rtoken_map</CODE>,
                    $<CODE>expecting</CODE>, $<CODE>max_token_index</CODE> );

                if ( $<CODE>type</CODE> eq '<' && $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) {
                    <CODE>error_if_expecting_TERM</CODE>();
                    <CODE>interrupt_logfile</CODE>();
                    <CODE>warning</CODE>("<LITERALS>Unterminated</LITERALS> <> <LITERALS>operator</LITERALS>?\n");
                    <CODE>resume_logfile</CODE>();
                }
            }
            else {
            }
        },
        '?' => sub {    # ?: <COMMENTS>conditional</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>pattern</COMMENTS>?

            my $<CODE>is_pattern</CODE>;

            if ( $<CODE>expecting</CODE> == <CODE>UNKNOWN</CODE> ) {

                my $<CODE>msg</CODE>;
                ( $<CODE>is_pattern</CODE>, $<CODE>msg</CODE> ) =
                  <CODE>guess_if_pattern_or_conditional</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_map</CODE>,
                    $<CODE>max_token_index</CODE> );

                if ($<CODE>msg</CODE>) { <CODE>write_logfile_entry</CODE>($<CODE>msg</CODE>) }
            }
            else { $<CODE>is_pattern</CODE> = ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) }

            if ($<CODE>is_pattern</CODE>) {
                $<CODE>in_quote</CODE>                = 1;
                $<CODE>type</CODE>                    = '<LITERALS>Q</LITERALS>';
                $<CODE>allowed_quote_modifiers</CODE> = '[<LITERALS>msixpodualngc</LITERALS>]';
            }
            else {
                ( $<CODE>type_sequence</CODE>, $<CODE>indent_flag</CODE> ) =
                  <CODE>increase_nesting_depth</CODE>( <CODE>QUESTION_COLON</CODE>,
                    $$<CODE>rtoken_map</CODE>[$<CODE>i_tok</CODE>] );
            }
        },
        '*' => sub {    # <COMMENTS>typeglob</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>multiply</COMMENTS>?

            if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) {
                <CODE>scan_identifier</CODE>();
            }
            else {

                if ( $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ] eq '=' ) {
                    $<CODE>tok</CODE>  = '*=';
                    $<CODE>type</CODE> = $<CODE>tok</CODE>;
                    $<CODE>i</CODE>++;
                }
                elsif ( $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ] eq '*' ) {
                    $<CODE>tok</CODE>  = '**';
                    $<CODE>type</CODE> = $<CODE>tok</CODE>;
                    $<CODE>i</CODE>++;
                    if ( $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ] eq '=' ) {
                        $<CODE>tok</CODE>  = '**=';
                        $<CODE>type</CODE> = $<CODE>tok</CODE>;
                        $<CODE>i</CODE>++;
                    }
                }
            }
        },
        '.' => sub {    # <COMMENTS>what</COMMENTS> <COMMENTS>kind</COMMENTS> <COMMENTS>of</COMMENTS> . ?

            if ( $<CODE>expecting</CODE> != <CODE>OPERATOR</CODE> ) {
                <CODE>scan_number</CODE>();
                if ( $<CODE>type</CODE> eq '.' ) {
                    <CODE>error_if_expecting_TERM</CODE>()
                      if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> );
                }
            }
            else {
            }
        },
        ':' => sub {

            # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>character</COMMENTS>, <COMMENTS>call</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>label</COMMENTS>
            # <COMMENTS>since</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>swallow</COMMENTS> <COMMENTS>it</COMMENTS>
            if ( $<CODE>input_line_number</CODE> == 1 && $<CODE>last_nonblank_i</CODE> == -1 ) {
                $<CODE>type</CODE> = '<LITERALS>J</LITERALS>';
            }

            # <COMMENTS>ATTRS</COMMENTS>: <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> ':' <COMMENTS>which</COMMENTS> <COMMENTS>introduces</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>attribute</COMMENTS> <COMMENTS>list</COMMENTS>
            # (<COMMENTS>this</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>eventually</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>own</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS>)
            elsif ( $<CODE>statement_type</CODE> =~ /^sub/ ) {
                $<CODE>type</CODE>              = '<LITERALS>A</LITERALS>';
                $<CODE>in_attribute_list</CODE> = 1;
            }

            # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>scalar</COMMENTS> <COMMENTS>attribute</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS>
            # <COMMENTS>my</COMMENTS> <COMMENTS>$foo</COMMENTS> : <COMMENTS>shared</COMMENTS> = <COMMENTS>1</COMMENTS>;
            elsif ($<CODE>is_my_our</CODE>{$<CODE>statement_type</CODE>}
                && $<CODE>current_depth</CODE>[<CODE>QUESTION_COLON</CODE>] == 0 )
            {
                $<CODE>type</CODE>              = '<LITERALS>A</LITERALS>';
                $<CODE>in_attribute_list</CODE> = 1;
            }

            # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>part</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> ?/: <COMMENTS>operator</COMMENTS>
            else {
                ( $<CODE>type_sequence</CODE>, $<CODE>indent_flag</CODE> ) =
                  <CODE>decrease_nesting_depth</CODE>( <CODE>QUESTION_COLON</CODE>,
                    $$<CODE>rtoken_map</CODE>[$<CODE>i_tok</CODE>] );
                if ( $<CODE>last_nonblank_token</CODE> eq '?' ) {
                    <CODE>warning</CODE>("<LITERALS>Syntax</LITERALS> <LITERALS>error</LITERALS> <LITERALS>near</LITERALS> ? :\n");
                }
            }
        },
        '+' => sub {    # <COMMENTS>what</COMMENTS> <COMMENTS>kind</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>plus</COMMENTS>?

            if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) {
                my $<CODE>number</CODE> = <CODE>scan_number</CODE>();

                # <COMMENTS>unary</COMMENTS> <COMMENTS>plus</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>safest</COMMENTS> <COMMENTS>assumption</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>number</COMMENTS>
                if ( !defined($<CODE>number</CODE>) ) { $<CODE>type</CODE> = '<LITERALS>p</LITERALS>'; }
            }
            elsif ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> ) {
            }
            else {
                if ( $<CODE>next_type</CODE> eq '<LITERALS>w</LITERALS>' ) { $<CODE>type</CODE> = '<LITERALS>p</LITERALS>' }
            }
        },
        '@' => sub {

            <CODE>error_if_expecting_OPERATOR</CODE>("<LITERALS>Array</LITERALS>")
              if ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> );
            <CODE>scan_identifier</CODE>();
        },
        '%' => sub {    # <COMMENTS>hash</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>modulo</COMMENTS>?

            # <COMMENTS>first</COMMENTS> <COMMENTS>guess</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>blank</COMMENTS>
            if ( $<CODE>expecting</CODE> == <CODE>UNKNOWN</CODE> ) {
                if ( $<CODE>next_type</CODE> ne '<LITERALS>b</LITERALS>' ) { $<CODE>expecting</CODE> = <CODE>TERM</CODE> }
            }
            if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) {
                <CODE>scan_identifier</CODE>();
            }
        },
        '[' => sub {
            $<CODE>square_bracket_type</CODE>[ ++$<CODE>square_bracket_depth</CODE> ] =
              $<CODE>last_nonblank_token</CODE>;
            ( $<CODE>type_sequence</CODE>, $<CODE>indent_flag</CODE> ) =
              <CODE>increase_nesting_depth</CODE>( <CODE>SQUARE_BRACKET</CODE>, $$<CODE>rtoken_map</CODE>[$<CODE>i_tok</CODE>] );

            # <COMMENTS>It</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>seem</COMMENTS> <COMMENTS>odd</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>square</COMMENTS> <COMMENTS>brackets</COMMENTS> <COMMENTS>have</COMMENTS>
            # <COMMENTS>type</COMMENTS> '{' <COMMENTS>and</COMMENTS> '}'.  <COMMENTS>This</COMMENTS> <COMMENTS>simplifies</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>logic</COMMENTS>.
            if ( !<CODE>is_non_structural_brace</CODE>() ) {
                $<CODE>type</CODE> = '{';
            }
            $<CODE>square_bracket_structural_type</CODE>[$<CODE>square_bracket_depth</CODE>] = $<CODE>type</CODE>;
        },
        ']' => sub {
            ( $<CODE>type_sequence</CODE>, $<CODE>indent_flag</CODE> ) =
              <CODE>decrease_nesting_depth</CODE>( <CODE>SQUARE_BRACKET</CODE>, $$<CODE>rtoken_map</CODE>[$<CODE>i_tok</CODE>] );

            if ( $<CODE>square_bracket_structural_type</CODE>[$<CODE>square_bracket_depth</CODE>] eq '{' )
            {
                $<CODE>type</CODE> = '}';
            }

            # <COMMENTS>propagate</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>information</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>smartmatch</COMMENTS> <COMMENTS>operator</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS>
            # <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>enable</COMMENTS> <COMMENTS>us</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>expected</COMMENTS>
            # <COMMENTS>next</COMMENTS>.
            if ( $<CODE>square_bracket_type</CODE>[$<CODE>square_bracket_depth</CODE>] eq '~~' ) {
                $<CODE>tok</CODE> = $<CODE>square_bracket_type</CODE>[$<CODE>square_bracket_depth</CODE>];
            }

            if ( $<CODE>square_bracket_depth</CODE> > 0 ) { $<CODE>square_bracket_depth</CODE>--; }
        },
        '-' => sub {    # <COMMENTS>what</COMMENTS> <COMMENTS>kind</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>minus</COMMENTS>?

            if ( ( $<CODE>expecting</CODE> != <CODE>OPERATOR</CODE> )
                && $<CODE>is_file_test_operator</CODE>{$<CODE>next_tok</CODE>} )
            {
                my ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_next</CODE> ) =
                  <CODE>find_next_nonblank_token</CODE>( $<CODE>i</CODE> + 1, $<CODE>rtokens</CODE>,
                    $<CODE>max_token_index</CODE> );

                # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>like</COMMENTS> "-<COMMENTS>w</COMMENTS>=><COMMENTS>xx</COMMENTS>";
                # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>sufficient</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>following</COMMENTS> '='
                if ( $<CODE>next_nonblank_token</CODE> eq '=' ) {
                    $<CODE>type</CODE> = '<LITERALS>m</LITERALS>';
                }
                else {
                    $<CODE>i</CODE>++;
                    $<CODE>tok</CODE> .= $<CODE>next_tok</CODE>;
                    $<CODE>type</CODE> = '<LITERALS>F</LITERALS>';
                }
            }
            elsif ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) {
                my $<CODE>number</CODE> = <CODE>scan_number</CODE>();

                # <COMMENTS>maybe</COMMENTS> <COMMENTS>part</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>bareword</COMMENTS> <COMMENTS>token</COMMENTS>? <COMMENTS>unary</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>safest</COMMENTS>
                if ( !defined($<CODE>number</CODE>) ) { $<CODE>type</CODE> = '<LITERALS>m</LITERALS>'; }

            }
            elsif ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> ) {
            }
            else {

                if ( $<CODE>next_type</CODE> eq '<LITERALS>w</LITERALS>' ) {
                    $<CODE>type</CODE> = '<LITERALS>m</LITERALS>';
                }
            }
        },

        '^' => sub {

            # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>variables</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>$</COMMENTS>{^<COMMENTS>WARNING_BITS</COMMENTS>}
            if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) {

                # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>this</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>catch</COMMENTS> <COMMENTS>errors</COMMENTS>
                # <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>is</COMMENTS>
                # <COMMENTS>a</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>character</COMMENTS> (<COMMENTS>$</COMMENTS>,@,%).
                if ( $<CODE>last_nonblank_token</CODE> eq '{'
                    && ( $<CODE>next_tok</CODE> =~ /^[A-Za-z_]/ ) )
                {

                    if ( $<CODE>next_tok</CODE> eq '<LITERALS>W</LITERALS>' ) {
                        $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_perl_dash_w</LITERALS>} = 1;
                    }
                    $<CODE>tok</CODE>  = $<CODE>tok</CODE> . $<CODE>next_tok</CODE>;
                    $<CODE>i</CODE>    = $<CODE>i</CODE> + 1;
                    $<CODE>type</CODE> = '<LITERALS>w</LITERALS>';
                }

                else {
                    unless ( <CODE>error_if_expecting_TERM</CODE>() ) {

                        # <COMMENTS>Something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>strange</COMMENTS>:
                        # <COMMENTS>undef</COMMENTS> ^<COMMENTS>I</COMMENTS>;
                        <CODE>complain</CODE>("<LITERALS>The</LITERALS> '^' <LITERALS>seems</LITERALS> <LITERALS>unusual</LITERALS> <LITERALS>here</LITERALS>\n");
                    }
                }
            }
        },

        '::' => sub {    # <COMMENTS>probably</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>call</COMMENTS>
            <CODE>scan_bare_identifier</CODE>();
        },
        '<<' => sub {    # <COMMENTS>maybe</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS>?
            return
              unless ( $<CODE>i</CODE> < $<CODE>max_token_index</CODE> )
              ;          # <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS>

            if ( $<CODE>expecting</CODE> != <CODE>OPERATOR</CODE> ) {
                my ( $<CODE>found_target</CODE>, $<CODE>here_doc_target</CODE>, $<CODE>here_quote_character</CODE>,
                    $<CODE>saw_error</CODE> );
                (
                    $<CODE>found_target</CODE>, $<CODE>here_doc_target</CODE>, $<CODE>here_quote_character</CODE>, $<CODE>i</CODE>,
                    $<CODE>saw_error</CODE>
                  )
                  = <CODE>find_here_doc</CODE>( $<CODE>expecting</CODE>, $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_map</CODE>,
                    $<CODE>max_token_index</CODE> );

                if ($<CODE>found_target</CODE>) {
                    push @{$<CODE>rhere_target_list</CODE>},
                      [ $<CODE>here_doc_target</CODE>, $<CODE>here_quote_character</CODE> ];
                    $<CODE>type</CODE> = '<LITERALS>h</LITERALS>';
                    if ( length($<CODE>here_doc_target</CODE>) > 80 ) {
                        my $<CODE>truncated</CODE> = substr( $<CODE>here_doc_target</CODE>, 0, 80 );
                        <CODE>complain</CODE>("<LITERALS>Long</LITERALS> <LITERALS>here</LITERALS>-<LITERALS>target</LITERALS>: '$<CODE>truncated</CODE>' ...\n");
                    }
                    elsif ( $<CODE>here_doc_target</CODE> !~ /^[A-Z_]\w+$/ ) {
                        <CODE>complain</CODE>(
                            "<LITERALS>Unconventional</LITERALS> <LITERALS>here</LITERALS>-<LITERALS>target</LITERALS>: '$<CODE>here_doc_target</CODE>'\n"
                        );
                    }
                }
                elsif ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) {
                    unless ($<CODE>saw_error</CODE>) {

                        # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>..
                        <CODE>warning</CODE>("<LITERALS>Program</LITERALS> <LITERALS>bug</LITERALS>; <LITERALS>didn</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>find</LITERALS> <LITERALS>here</LITERALS> <LITERALS>doc</LITERALS> <LITERALS>target</LITERALS>\n");
                        <CODE>report_definite_bug</CODE>();
                    }
                }
            }
            else {
            }
        },
        '->' => sub {

            # <COMMENTS>if</COMMENTS> -> <COMMENTS>points</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>scan</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>identifier</COMMENTS>,
            # <COMMENTS>otherwise</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> -><COMMENTS>y</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>y</COMMENTS> <COMMENTS>operator</COMMENTS>
            <CODE>scan_identifier</CODE>();
        },

        # <COMMENTS>type</COMMENTS> = '<COMMENTS>pp</COMMENTS>' <COMMENTS>for</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>increment</COMMENTS>, '++' <COMMENTS>for</COMMENTS> <COMMENTS>post</COMMENTS>-<COMMENTS>increment</COMMENTS>
        '++' => sub {
            if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) { $<CODE>type</CODE> = '<LITERALS>pp</LITERALS>' }
            elsif ( $<CODE>expecting</CODE> == <CODE>UNKNOWN</CODE> ) {
                my ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_next</CODE> ) =
                  <CODE>find_next_nonblank_token</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> );
                if ( $<CODE>next_nonblank_token</CODE> eq '<LITERALS>$</LITERALS>' ) { $<CODE>type</CODE> = '<LITERALS>pp</LITERALS>' }
            }
        },

        '=>' => sub {
            if ( $<CODE>last_nonblank_type</CODE> eq $<CODE>tok</CODE> ) {
                <CODE>complain</CODE>("<LITERALS>Repeated</LITERALS> '=>'<LITERALS>s</LITERALS> \n");
            }

            # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>operator_expected</COMMENTS>: <COMMENTS>note</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> (<COMMENTS>use</COMMENTS>.<COMMENTS>t</COMMENTS>)
            # <COMMENTS>TODO</COMMENTS>: <COMMENTS>make</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS>
            if ( $<CODE>statement_type</CODE> eq '<LITERALS>use</LITERALS>' ) { $<CODE>statement_type</CODE> = '<LITERALS>_use</LITERALS>' }
        },

        # <COMMENTS>type</COMMENTS> = '<COMMENTS>mm</COMMENTS>' <COMMENTS>for</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>decrement</COMMENTS>, '--' <COMMENTS>for</COMMENTS> <COMMENTS>post</COMMENTS>-<COMMENTS>decrement</COMMENTS>
        '--' => sub {

            if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) { $<CODE>type</CODE> = '<LITERALS>mm</LITERALS>' }
            elsif ( $<CODE>expecting</CODE> == <CODE>UNKNOWN</CODE> ) {
                my ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_next</CODE> ) =
                  <CODE>find_next_nonblank_token</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> );
                if ( $<CODE>next_nonblank_token</CODE> eq '<LITERALS>$</LITERALS>' ) { $<CODE>type</CODE> = '<LITERALS>mm</LITERALS>' }
            }
        },

        '&&' => sub {
            <CODE>error_if_expecting_TERM</CODE>()
              if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> );
        },

        '||' => sub {
            <CODE>error_if_expecting_TERM</CODE>()
              if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> );
        },

        '//' => sub {
            <CODE>error_if_expecting_TERM</CODE>()
              if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> );
        },
    };

    # ------------------------------------------------------------
    # <COMMENTS>end</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>handling</COMMENTS> <COMMENTS>individual</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>
    # ------------------------------------------------------------

    my %<CODE>matching_start_token</CODE> = ( '}' => '{', ']' => '[', ')' => '(' );

    # <COMMENTS>These</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>terminate</COMMENTS> <COMMENTS>statements</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>trailing</COMMENTS>
    # <COMMENTS>semicolon</COMMENTS>
    # <COMMENTS>patched</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS>/
    my %<CODE>is_zero_continuation_block_type</CODE>;
    @<CODE>_</CODE> = qw( } { <LITERALS>BEGIN</LITERALS> <LITERALS>END</LITERALS> <LITERALS>CHECK</LITERALS> <LITERALS>INIT</LITERALS> <LITERALS>AUTOLOAD</LITERALS> <LITERALS>DESTROY</LITERALS> <LITERALS>UNITCHECK</LITERALS> <LITERALS>continue</LITERALS> ;
      <LITERALS>if</LITERALS> <LITERALS>elsif</LITERALS> <LITERALS>else</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>while</LITERALS> <LITERALS>until</LITERALS> <LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS> <LITERALS>switch</LITERALS> <LITERALS>case</LITERALS> <LITERALS>given</LITERALS> <LITERALS>when</LITERALS>);
    @<CODE>is_zero_continuation_block_type</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    my %<CODE>is_not_zero_continuation_block_type</CODE>;
    @<CODE>_</CODE> = qw(<LITERALS>sort</LITERALS> <LITERALS>grep</LITERALS> <LITERALS>map</LITERALS> <LITERALS>do</LITERALS> <LITERALS>eval</LITERALS>);
    @<CODE>is_not_zero_continuation_block_type</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    my %<CODE>is_logical_container</CODE>;
    @<CODE>_</CODE> = qw(<LITERALS>if</LITERALS> <LITERALS>elsif</LITERALS> <LITERALS>unless</LITERALS> <LITERALS>while</LITERALS> <LITERALS>and</LITERALS> <LITERALS>or</LITERALS> <LITERALS>err</LITERALS> <LITERALS>not</LITERALS> && !  || <LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS>);
    @<CODE>is_logical_container</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    my %<CODE>is_binary_type</CODE>;
    @<CODE>_</CODE> = qw(|| &&);
    @<CODE>is_binary_type</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    my %<CODE>is_binary_keyword</CODE>;
    @<CODE>_</CODE> = qw(<LITERALS>and</LITERALS> <LITERALS>or</LITERALS> <LITERALS>err</LITERALS> <LITERALS>eq</LITERALS> <LITERALS>ne</LITERALS> <LITERALS>cmp</LITERALS>);
    @<CODE>is_binary_keyword</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # '<COMMENTS>L</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>opening</COMMENTS> { <COMMENTS>at</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>key</COMMENTS>
    my %<CODE>is_opening_type</CODE>;
    @<CODE>_</CODE> = qw" <LITERALS>L</LITERALS> { ( [ ";
    @<CODE>is_opening_type</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # '<COMMENTS>R</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>closing</COMMENTS> } <COMMENTS>at</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>key</COMMENTS>
    my %<CODE>is_closing_type</CODE>;
    @<CODE>_</CODE> = qw" <LITERALS>R</LITERALS> } ) ] ";
    @<CODE>is_closing_type</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    my %<CODE>is_redo_last_next_goto</CODE>;
    @<CODE>_</CODE> = qw(<LITERALS>redo</LITERALS> <LITERALS>last</LITERALS> <LITERALS>next</LITERALS> <LITERALS>goto</LITERALS>);
    @<CODE>is_redo_last_next_goto</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    my %<CODE>is_use_require</CODE>;
    @<CODE>_</CODE> = qw(<LITERALS>use</LITERALS> <LITERALS>require</LITERALS>);
    @<CODE>is_use_require</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    my %<CODE>is_sub_package</CODE>;
    @<CODE>_</CODE> = qw(<LITERALS>sub</LITERALS> <LITERALS>package</LITERALS>);
    @<CODE>is_sub_package</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>This</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>holds</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>key</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>$tokenizer_self</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>keywords</COMMENTS>:
    my %<CODE>is_format_END_DATA</CODE> = (
        '<LITERALS>format</LITERALS>'   => '<LITERALS>_in_format</LITERALS>',
        '<LITERALS>__END__</LITERALS>'  => '<LITERALS>_in_end</LITERALS>',
        '<LITERALS>__DATA__</LITERALS>' => '<LITERALS>_in_data</LITERALS>',
    );

    # <COMMENTS>original</COMMENTS> <COMMENTS>ref</COMMENTS>: <COMMENTS>camel</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>p</COMMENTS> <COMMENTS>147</COMMENTS>,
    # <COMMENTS>but</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>accept</COMMENTS> <COMMENTS>undocumented</COMMENTS> <COMMENTS>flags</COMMENTS>
    # <COMMENTS>perl</COMMENTS> <COMMENTS>5</COMMENTS>.<COMMENTS>10</COMMENTS> <COMMENTS>adds</COMMENTS> '<COMMENTS>p</COMMENTS>' (<COMMENTS>preserve</COMMENTS>)
    # <COMMENTS>Perl</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>5</COMMENTS>.<COMMENTS>22</COMMENTS> <COMMENTS>added</COMMENTS> '<COMMENTS>n</COMMENTS>'
    # <COMMENTS>From</COMMENTS> <COMMENTS>http</COMMENTS>://<COMMENTS>perldoc</COMMENTS>.<COMMENTS>perl</COMMENTS>.<COMMENTS>org</COMMENTS>/<COMMENTS>perlop</COMMENTS>.<COMMENTS>html</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS>
    # /<COMMENTS>PATTERN</COMMENTS>/<COMMENTS>msixpodualngc</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>m</COMMENTS>?<COMMENTS>PATTERN</COMMENTS>?<COMMENTS>msixpodualngc</COMMENTS>
    # <COMMENTS>s</COMMENTS>/<COMMENTS>PATTERN</COMMENTS>/<COMMENTS>REPLACEMENT</COMMENTS>/<COMMENTS>msixpodualngcer</COMMENTS>
    # <COMMENTS>y</COMMENTS>/<COMMENTS>SEARCHLIST</COMMENTS>/<COMMENTS>REPLACEMENTLIST</COMMENTS>/<COMMENTS>cdsr</COMMENTS>
    # <COMMENTS>tr</COMMENTS>/<COMMENTS>SEARCHLIST</COMMENTS>/<COMMENTS>REPLACEMENTLIST</COMMENTS>/<COMMENTS>cdsr</COMMENTS>
    # <COMMENTS>qr</COMMENTS>/<COMMENTS>STRING</COMMENTS>/<COMMENTS>msixpodualn</COMMENTS>
    my %<CODE>quote_modifiers</CODE> = (
        '<LITERALS>s</LITERALS>'  => '[<LITERALS>msixpodualngcer</LITERALS>]',
        '<LITERALS>y</LITERALS>'  => '[<LITERALS>cdsr</LITERALS>]',
        '<LITERALS>tr</LITERALS>' => '[<LITERALS>cdsr</LITERALS>]',
        '<LITERALS>m</LITERALS>'  => '[<LITERALS>msixpodualngc</LITERALS>]',
        '<LITERALS>qr</LITERALS>' => '[<LITERALS>msixpodualn</LITERALS>]',
        '<LITERALS>q</LITERALS>'  => "",
        '<LITERALS>qq</LITERALS>' => "",
        '<LITERALS>qw</LITERALS>' => "",
        '<LITERALS>qx</LITERALS>' => "",
    );

    # <COMMENTS>table</COMMENTS> <COMMENTS>showing</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>operator</COMMENTS>..
    # <COMMENTS>s</COMMENTS>, <COMMENTS>y</COMMENTS>, <COMMENTS>tr</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>2</COMMENTS> (<COMMENTS>pattern</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>replacement</COMMENTS>)
    # <COMMENTS>others</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>1</COMMENTS> (<COMMENTS>pattern</COMMENTS> <COMMENTS>only</COMMENTS>)
    my %<CODE>quote_items</CODE> = (
        '<LITERALS>s</LITERALS>'  => 2,
        '<LITERALS>y</LITERALS>'  => 2,
        '<LITERALS>tr</LITERALS>' => 2,
        '<LITERALS>m</LITERALS>'  => 1,
        '<LITERALS>qr</LITERALS>' => 1,
        '<LITERALS>q</LITERALS>'  => 1,
        '<LITERALS>qq</LITERALS>' => 1,
        '<LITERALS>qw</LITERALS>' => 1,
        '<LITERALS>qx</LITERALS>' => 1,
    );

    sub <CODE>tokenize_this_line</CODE> {

  # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>in</COMMENTS>
  # <COMMENTS>indentation</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>reformatting</COMMENTS>.  <COMMENTS>One</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>goals</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>define</COMMENTS> <COMMENTS>tokens</COMMENTS>
  # <COMMENTS>such</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>newline</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>inserted</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>pair</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>without</COMMENTS>
  # <COMMENTS>changing</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>invalidating</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>program</COMMENTS>. <COMMENTS>This</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>comes</COMMENTS> <COMMENTS>close</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>this</COMMENTS>,
  # <COMMENTS>although</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>necessarily</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>few</COMMENTS> <COMMENTS>exceptions</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>caught</COMMENTS> <COMMENTS>by</COMMENTS>
  # <COMMENTS>the</COMMENTS> <COMMENTS>formatter</COMMENTS>.  <COMMENTS>Many</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>involve</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>treatment</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>words</COMMENTS>.
  #
  # <COMMENTS>The</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>returned</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>arrays</COMMENTS>.  <COMMENTS>See</COMMENTS> <COMMENTS>previous</COMMENTS>
  # <COMMENTS>routine</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>names</COMMENTS>.
  #
  # <COMMENTS>See</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>array</COMMENTS> "<COMMENTS>valid_token_types</COMMENTS>" <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>BEGIN</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>an</COMMENTS>
  # <COMMENTS>up</COMMENTS>-<COMMENTS>to</COMMENTS>-<COMMENTS>date</COMMENTS> <COMMENTS>list</COMMENTS>.
  #
  # <COMMENTS>To</COMMENTS> <COMMENTS>simplify</COMMENTS> <COMMENTS>things</COMMENTS>, <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>character</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>they</COMMENTS>
  # <COMMENTS>are</COMMENTS> <COMMENTS>identical</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>themselves</COMMENTS>.
  #
  # <COMMENTS>As</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>debugging</COMMENTS> <COMMENTS>aid</COMMENTS>, <COMMENTS>the</COMMENTS> -<COMMENTS>D</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>creates</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>containing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS>-<COMMENTS>by</COMMENTS>-<COMMENTS>side</COMMENTS>
  # <COMMENTS>comparison</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>tokenization</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>file</COMMENTS>.
  # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>invaluable</COMMENTS> <COMMENTS>debugging</COMMENTS> <COMMENTS>aid</COMMENTS>.
  #
  # <COMMENTS>In</COMMENTS> <COMMENTS>addition</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>tokens</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>associated</COMMENTS> <COMMENTS>quantities</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS>
  # <COMMENTS>also</COMMENTS> <COMMENTS>returns</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>indication</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>types</COMMENTS>.  <COMMENTS>These</COMMENTS> <COMMENTS>include</COMMENTS>
  # <COMMENTS>quotes</COMMENTS>, <COMMENTS>here_docs</COMMENTS>, <COMMENTS>formats</COMMENTS>.
  #
  # -----------------------------------------------------------------------
  #
  # <COMMENTS>How</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>NEW_TOKENS</COMMENTS>:
  #
  # <COMMENTS>New</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>undoubtedly</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>future</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>up</COMMENTS>
  # <COMMENTS>with</COMMENTS> <COMMENTS>changes</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>help</COMMENTS> <COMMENTS>adapt</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>applications</COMMENTS>.
  #
  # <COMMENTS>Here</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>notes</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>minimal</COMMENTS> <COMMENTS>steps</COMMENTS>.  <COMMENTS>I</COMMENTS> <COMMENTS>wrote</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>notes</COMMENTS> <COMMENTS>while</COMMENTS>
  # <COMMENTS>adding</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>v</COMMENTS>' <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>version</COMMENTS>
  # <COMMENTS>numbers</COMMENTS> <COMMENTS>5</COMMENTS>.<COMMENTS>6</COMMENTS>.<COMMENTS>0</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>ip</COMMENTS> <COMMENTS>addresses</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS>.  ( <COMMENTS>You</COMMENTS>
  # <COMMENTS>can</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>your</COMMENTS> <COMMENTS>editor</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>search</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>string</COMMENTS> "<COMMENTS>NEW_TOKENS</COMMENTS>" <COMMENTS>to</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS>
  # <COMMENTS>appropriate</COMMENTS> <COMMENTS>sections</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>change</COMMENTS>):
  #
  # *. <COMMENTS>Try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>talk</COMMENTS> <COMMENTS>somebody</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>doing</COMMENTS> <COMMENTS>it</COMMENTS>!  <COMMENTS>If</COMMENTS> <COMMENTS>not</COMMENTS>, ..
  #
  # *. <COMMENTS>Make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>backup</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>your</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>out</COMMENTS>!
  #
  # *. <COMMENTS>Think</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS>, <COMMENTS>unused</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>to</COMMENTS>
  # <COMMENTS>the</COMMENTS> <COMMENTS>array</COMMENTS> @<COMMENTS>valid_token_types</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>BEGIN</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>package</COMMENTS>.
  # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>I</COMMENTS> <COMMENTS>used</COMMENTS> '<COMMENTS>v</COMMENTS>' <COMMENTS>for</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS>.
  #
  # *. <COMMENTS>Implement</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>recognize</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>$type</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS>.
  # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>hardest</COMMENTS> <COMMENTS>part</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>imitating</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>modifying</COMMENTS>
  # <COMMENTS>some</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>existing</COMMENTS> <COMMENTS>coding</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>recognize</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS>, <COMMENTS>I</COMMENTS>
  # <COMMENTS>patched</COMMENTS> '<COMMENTS>sub</COMMENTS> <COMMENTS>scan_bare_identifier</COMMENTS>' <COMMENTS>to</COMMENTS> <COMMENTS>recognize</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS> <COMMENTS>beginning</COMMENTS> <COMMENTS>with</COMMENTS>
  # '<COMMENTS>v</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>sub</COMMENTS> <COMMENTS>scan_number</COMMENTS>' <COMMENTS>to</COMMENTS> <COMMENTS>recognize</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> '<COMMENTS>v</COMMENTS>'.
  #
  # *. <COMMENTS>Update</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>operator_expected</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>update</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>critically</COMMENTS> <COMMENTS>important</COMMENTS> <COMMENTS>but</COMMENTS>
  # <COMMENTS>the</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>trivial</COMMENTS>.  <COMMENTS>Look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>help</COMMENTS>.
  # <COMMENTS>For</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>behave</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>numbers</COMMENTS>, <COMMENTS>I</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>added</COMMENTS> '<COMMENTS>v</COMMENTS>' <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS>
  # <COMMENTS>regex</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>strings</COMMENTS> (<COMMENTS>types</COMMENTS> '<COMMENTS>n</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>Q</COMMENTS>').
  #
  # *. <COMMENTS>Implement</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>bond</COMMENTS> <COMMENTS>strength</COMMENTS>' <COMMENTS>rule</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>set_bond_strengths</COMMENTS> <COMMENTS>in</COMMENTS>
  # <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Formatter</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>breaking</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>around</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS>.  <COMMENTS>You</COMMENTS> <COMMENTS>can</COMMENTS>
  # <COMMENTS>skip</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>step</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>take</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>first</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>adjust</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS>
  # <COMMENTS>desired</COMMENTS> <COMMENTS>results</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>v</COMMENTS>', <COMMENTS>I</COMMENTS> <COMMENTS>looked</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>bond_strength</COMMENTS> <COMMENTS>and</COMMENTS>
  # <COMMENTS>saw</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>n</COMMENTS>' <COMMENTS>was</COMMENTS> <COMMENTS>using</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>strengths</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>I</COMMENTS> <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>do</COMMENTS>
  # <COMMENTS>anything</COMMENTS>.  <COMMENTS>I</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>tune</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>someday</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>I</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>way</COMMENTS> <COMMENTS>line</COMMENTS>
  # <COMMENTS>breaks</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS> <COMMENTS>look</COMMENTS>.
  #
  # *. <COMMENTS>Implement</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>whitespace</COMMENTS>' <COMMENTS>rule</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>set_white_space_flag</COMMENTS> <COMMENTS>in</COMMENTS>
  # <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Formatter</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>v</COMMENTS>', <COMMENTS>I</COMMENTS> <COMMENTS>looked</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS>
  # <COMMENTS>and</COMMENTS> <COMMENTS>saw</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>n</COMMENTS>' <COMMENTS>used</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>sides</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>I</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>added</COMMENTS> '<COMMENTS>v</COMMENTS>'
  # <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>array</COMMENTS> @<COMMENTS>spaces_both_sides</COMMENTS>.
  #
  # *. <COMMENTS>Update</COMMENTS> <COMMENTS>HtmlWriter</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>users</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>colorize</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>as</COMMENTS>
  # <COMMENTS>desired</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>quite</COMMENTS> <COMMENTS>easy</COMMENTS>; <COMMENTS>see</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>identified</COMMENTS> <COMMENTS>by</COMMENTS> '<COMMENTS>NEW_TOKENS</COMMENTS>' <COMMENTS>in</COMMENTS>
  # <COMMENTS>that</COMMENTS> <COMMENTS>package</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS>, <COMMENTS>I</COMMENTS> <COMMENTS>initially</COMMENTS> <COMMENTS>chose</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>color</COMMENTS>
  # <COMMENTS>equal</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>default</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>numbers</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>nice</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>that</COMMENTS>
  # <COMMENTS>eventually</COMMENTS>.
  #
  # *. <COMMENTS>Update</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Tokenizer</COMMENTS>::<COMMENTS>dump_token_types</COMMENTS>.
  #
  # *. <COMMENTS>Run</COMMENTS> <COMMENTS>lots</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>lots</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>debug</COMMENTS> <COMMENTS>tests</COMMENTS>.  <COMMENTS>Start</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>designed</COMMENTS>
  # <COMMENTS>to</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS>.  <COMMENTS>Run</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>D</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> .<COMMENTS>DEBUG</COMMENTS>
  # <COMMENTS>file</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>shows</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokenization</COMMENTS>.  <COMMENTS>When</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>work</COMMENTS> <COMMENTS>ok</COMMENTS>, <COMMENTS>test</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>old</COMMENTS>
  # <COMMENTS>scripts</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>possible</COMMENTS>.  <COMMENTS>Start</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> '.<COMMENTS>t</COMMENTS>' <COMMENTS>files</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>test</COMMENTS>'
  # <COMMENTS>directory</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>distribution</COMMENTS> <COMMENTS>file</COMMENTS>.  <COMMENTS>Compare</COMMENTS> .<COMMENTS>tdy</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>previous</COMMENTS>
  # <COMMENTS>version</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>updated</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>differences</COMMENTS>.  <COMMENTS>Then</COMMENTS> <COMMENTS>include</COMMENTS> <COMMENTS>as</COMMENTS>
  # <COMMENTS>many</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>files</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>possible</COMMENTS>. <COMMENTS>My</COMMENTS> <COMMENTS>own</COMMENTS> <COMMENTS>technique</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>collect</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>huge</COMMENTS>
  # <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>scripts</COMMENTS> (<COMMENTS>thousands</COMMENTS>!) <COMMENTS>into</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>directory</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>run</COMMENTS> <COMMENTS>perltidy</COMMENTS>
  # *, <COMMENTS>then</COMMENTS> <COMMENTS>run</COMMENTS> <COMMENTS>diff</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS>
  # <COMMENTS>current</COMMENTS> <COMMENTS>version</COMMENTS>.
  #
  # *. <COMMENTS>For</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>search</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>smartmatch</COMMENTS> <COMMENTS>operator</COMMENTS> '~~'
  # <COMMENTS>with</COMMENTS> <COMMENTS>your</COMMENTS> <COMMENTS>editor</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>updates</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>made</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>it</COMMENTS>.
  #
  # -----------------------------------------------------------------------

        my $<CODE>line_of_tokens</CODE> = shift;
        my ($<CODE>untrimmed_input_line</CODE>) = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_text</LITERALS>};

        # <COMMENTS>patch</COMMENTS> <COMMENTS>while</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>underway</COMMENTS>
        # <COMMENTS>make</COMMENTS> <COMMENTS>callers</COMMENTS> <COMMENTS>private</COMMENTS> <COMMENTS>data</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>access</COMMENTS>
        # <COMMENTS>$tokenizer_self</COMMENTS> = <COMMENTS>$caller_tokenizer_self</COMMENTS>;

        # <COMMENTS>extract</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>messages</COMMENTS>
        $<CODE>input_line_number</CODE> = $<CODE>line_of_tokens</CODE>->{<LITERALS>_line_number</LITERALS>};

        # <COMMENTS>reinitialize</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>multi</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>quote</COMMENTS>
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_starting_in_quote</LITERALS>} = $<CODE>in_quote</CODE> && $<CODE>quote_type</CODE> eq '<LITERALS>Q</LITERALS>';

        # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>pod</COMMENTS> <COMMENTS>documentation</COMMENTS>
        if ( ( $<CODE>untrimmed_input_line</CODE> =~ /^=[A-Za-z_]/ ) ) {

            # <COMMENTS>must</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>multi</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>quote</COMMENTS>
            # <COMMENTS>and</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>equation</COMMENTS>
            if ( !$<CODE>in_quote</CODE> and ( <CODE>operator_expected</CODE>( '<LITERALS>b</LITERALS>', '=', '<LITERALS>b</LITERALS>' ) == <CODE>TERM</CODE> ) )
            {
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_pod</LITERALS>} = 1;
                return;
            }
        }

        $<CODE>input_line</CODE> = $<CODE>untrimmed_input_line</CODE>;

        chomp $<CODE>input_line</CODE>;

        # <COMMENTS>trim</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>continuing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>line</COMMENTS>
        # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>trim</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS> (<COMMENTS>test</COMMENTS>: <COMMENTS>deken4</COMMENTS>.<COMMENTS>pl</COMMENTS>)
        # <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS>::<COMMENTS>Formatter</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>delete</COMMENTS> <COMMENTS>needless</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>blanks</COMMENTS>
        unless ( $<CODE>in_quote</CODE> && ( $<CODE>quote_type</CODE> eq '<LITERALS>Q</LITERALS>' ) ) {
            $<CODE>input_line</CODE> =~ s/^\s*//;    # <COMMENTS>trim</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>end</COMMENTS>
        }

        # <COMMENTS>update</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>copy</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>messages</COMMENTS>
        # <COMMENTS>This</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>exactly</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pre_tokenizer</COMMENTS>
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_text</LITERALS>} = $<CODE>input_line</CODE>;

        # <COMMENTS>re</COMMENTS>-<COMMENTS>initialize</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>loop</COMMENTS>
        $<CODE>routput_token_list</CODE>     = [];    # <COMMENTS>stack</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>indexes</COMMENTS>
        $<CODE>routput_token_type</CODE>     = [];    # <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>
        $<CODE>routput_block_type</CODE>     = [];    # <COMMENTS>types</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>
        $<CODE>routput_container_type</CODE> = [];    # <COMMENTS>paren</COMMENTS> <COMMENTS>types</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>if</COMMENTS>, <COMMENTS>elsif</COMMENTS>, ..
        $<CODE>routput_type_sequence</CODE>  = [];    # <COMMENTS>nesting</COMMENTS> <COMMENTS>sequential</COMMENTS> <COMMENTS>number</COMMENTS>

        $<CODE>rhere_target_list</CODE> = [];

        $<CODE>tok</CODE>             = $<CODE>last_nonblank_token</CODE>;
        $<CODE>type</CODE>            = $<CODE>last_nonblank_type</CODE>;
        $<CODE>prototype</CODE>       = $<CODE>last_nonblank_prototype</CODE>;
        $<CODE>last_nonblank_i</CODE> = -1;
        $<CODE>block_type</CODE>      = $<CODE>last_nonblank_block_type</CODE>;
        $<CODE>container_type</CODE>  = $<CODE>last_nonblank_container_type</CODE>;
        $<CODE>type_sequence</CODE>   = $<CODE>last_nonblank_type_sequence</CODE>;
        $<CODE>indent_flag</CODE>     = 0;
        $<CODE>peeked_ahead</CODE>    = 0;

        # <COMMENTS>tokenization</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>stages</COMMENTS>..
        # <COMMENTS>stage</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>tokenization</COMMENTS>
        my $<CODE>max_tokens_wanted</CODE> = 0; # <COMMENTS>this</COMMENTS> <COMMENTS>signals</COMMENTS> <COMMENTS>pre_tokenize</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS>

        # <COMMENTS>a</COMMENTS> <COMMENTS>little</COMMENTS> <COMMENTS>optimization</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>full</COMMENTS>-<COMMENTS>line</COMMENTS> <COMMENTS>comment</COMMENTS>
        if ( !$<CODE>in_quote</CODE> && ( $<CODE>input_line</CODE> =~ /^#/ ) ) {
            $<CODE>max_tokens_wanted</CODE> = 1    # <COMMENTS>no</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>tokenizing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comment</COMMENTS>
        }

        # <COMMENTS>start</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>breaking</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>tokens</COMMENTS>
        ( $<CODE>rtokens</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>rtoken_type</CODE> ) =
          <CODE>pre_tokenize</CODE>( $<CODE>input_line</CODE>, $<CODE>max_tokens_wanted</CODE> );

        $<CODE>max_token_index</CODE> = scalar(@$<CODE>rtokens</CODE>) - 1;
        push( @$<CODE>rtokens</CODE>,    ' ', ' ', ' ' ); # <COMMENTS>extra</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>simplifies</COMMENTS> <COMMENTS>logic</COMMENTS>
        push( @$<CODE>rtoken_map</CODE>, 0,   0,   0 );   # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>referenced</COMMENTS>
        push( @$<CODE>rtoken_type</CODE>, '<LITERALS>b</LITERALS>', '<LITERALS>b</LITERALS>', '<LITERALS>b</LITERALS>' );

        # <COMMENTS>initialize</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>loop</COMMENTS>
        for $<CODE>i</CODE> ( 0 .. $<CODE>max_token_index</CODE> + 3 ) {
            $<CODE>routput_token_type</CODE>->[$<CODE>i</CODE>]     = "";
            $<CODE>routput_block_type</CODE>->[$<CODE>i</CODE>]     = "";
            $<CODE>routput_container_type</CODE>->[$<CODE>i</CODE>] = "";
            $<CODE>routput_type_sequence</CODE>->[$<CODE>i</CODE>]  = "";
            $<CODE>routput_indent_flag</CODE>->[$<CODE>i</CODE>]    = 0;
        }
        $<CODE>i</CODE>     = -1;
        $<CODE>i_tok</CODE> = -1;

        # ------------------------------------------------------------
        # <COMMENTS>begin</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>tokenization</COMMENTS> <COMMENTS>loop</COMMENTS>
        # ------------------------------------------------------------

        # <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>combining</COMMENTS> <COMMENTS>them</COMMENTS>
        # <COMMENTS>into</COMMENTS> <COMMENTS>tokens</COMMENTS>
        while ( ++$<CODE>i</CODE> <= $<CODE>max_token_index</CODE> ) {

            if ($<CODE>in_quote</CODE>) {    # <COMMENTS>continue</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS>
                $<CODE>type</CODE> = $<CODE>quote_type</CODE>;

                unless ( @{$<CODE>routput_token_list</CODE>} )
                {               # <COMMENTS>initialize</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>line</COMMENTS>
                    push( @{$<CODE>routput_token_list</CODE>}, $<CODE>i</CODE> );
                    $<CODE>routput_token_type</CODE>->[$<CODE>i</CODE>] = $<CODE>type</CODE>;

                }
                $<CODE>tok</CODE> = $<CODE>quote_character</CODE> unless ( $<CODE>quote_character</CODE> =~ /^\s*$/ );

                # <COMMENTS>scan</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>pattern</COMMENTS>
                (
                    $<CODE>i</CODE>, $<CODE>in_quote</CODE>, $<CODE>quote_character</CODE>, $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>,
                    $<CODE>quoted_string_1</CODE>, $<CODE>quoted_string_2</CODE>
                  )
                  = <CODE>do_quote</CODE>(
                    $<CODE>i</CODE>,               $<CODE>in_quote</CODE>,    $<CODE>quote_character</CODE>,
                    $<CODE>quote_pos</CODE>,       $<CODE>quote_depth</CODE>, $<CODE>quoted_string_1</CODE>,
                    $<CODE>quoted_string_2</CODE>, $<CODE>rtokens</CODE>,     $<CODE>rtoken_map</CODE>,
                    $<CODE>max_token_index</CODE>
                  );

                # <COMMENTS>all</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>it</COMMENTS>
                last if ($<CODE>in_quote</CODE>);

                # <COMMENTS>save</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>replacement</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>rescanning</COMMENTS>
                my $<CODE>qs1</CODE> = $<CODE>quoted_string_1</CODE>;
                my $<CODE>qs2</CODE> = $<CODE>quoted_string_2</CODE>;

                # <COMMENTS>re</COMMENTS>-<COMMENTS>initialize</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>search</COMMENTS>
                $<CODE>quote_character</CODE> = '';
                $<CODE>quote_pos</CODE>       = 0;
                $<CODE>quote_type</CODE>      = '<LITERALS>Q</LITERALS>';
                $<CODE>quoted_string_1</CODE> = "";
                $<CODE>quoted_string_2</CODE> = "";
                last if ( ++$<CODE>i</CODE> > $<CODE>max_token_index</CODE> );

                # <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>modifiers</COMMENTS>
                if ($<CODE>allowed_quote_modifiers</CODE>) {

                    # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>exact</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>modifiers</COMMENTS>
                    if ( $$<CODE>rtokens</CODE>[$<CODE>i</CODE>] =~ /^[A-Za-z_]/ ) {
                        my $<CODE>str</CODE> = $$<CODE>rtokens</CODE>[$<CODE>i</CODE>];
                        my $<CODE>saw_modifier_e</CODE>;
                        while ( $<CODE>str</CODE> =~ /\G$<CODE>allowed_quote_modifiers</CODE>/gc ) {
                            my $<CODE>pos</CODE> = pos($<CODE>str</CODE>);
                            my $<CODE>char</CODE> = substr( $<CODE>str</CODE>, $<CODE>pos</CODE> - 1, 1 );
                            $<CODE>saw_modifier_e</CODE> ||= ( $<CODE>char</CODE> eq '<LITERALS>e</LITERALS>' );
                        }

                        # <COMMENTS>For</COMMENTS> <COMMENTS>an</COMMENTS> '<COMMENTS>e</COMMENTS>' <COMMENTS>quote</COMMENTS> <COMMENTS>modifier</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>scan</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>replacement</COMMENTS>
                        # <COMMENTS>text</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS> <COMMENTS>targets</COMMENTS>.
                        if ($<CODE>saw_modifier_e</CODE>) {

                            my $<CODE>rht</CODE> = <CODE>scan_replacement_text</CODE>($<CODE>qs1</CODE>);

                            # <COMMENTS>Change</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>from</COMMENTS> '<COMMENTS>Q</COMMENTS>' <COMMENTS>to</COMMENTS> '<COMMENTS>h</COMMENTS>' <COMMENTS>for</COMMENTS> <COMMENTS>quotes</COMMENTS> <COMMENTS>with</COMMENTS>
                            # <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS> <COMMENTS>targets</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>formatter</COMMENTS> (<COMMENTS>see</COMMENTS> <COMMENTS>sub</COMMENTS>
                            # <COMMENTS>print_line_of_tokens</COMMENTS>) <COMMENTS>will</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>line</COMMENTS>
                            # <COMMENTS>breaks</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>point</COMMENTS>.
                            if ($<CODE>rht</CODE>) {
                                push @{$<CODE>rhere_target_list</CODE>}, @{$<CODE>rht</CODE>};
                                $<CODE>type</CODE> = '<LITERALS>h</LITERALS>';
                                if ( $<CODE>i_tok</CODE> < 0 ) {
                                    my $<CODE>ilast</CODE> = $<CODE>routput_token_list</CODE>->[-1];
                                    $<CODE>routput_token_type</CODE>->[$<CODE>ilast</CODE>] = $<CODE>type</CODE>;
                                }
                            }
                        }

                        if ( defined( pos($<CODE>str</CODE>) ) ) {

                            # <COMMENTS>matched</COMMENTS>
                            if ( pos($<CODE>str</CODE>) == length($<CODE>str</CODE>) ) {
                                last if ( ++$<CODE>i</CODE> > $<CODE>max_token_index</CODE> );
                            }

                            # <COMMENTS>Looks</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>joined</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>modifier</COMMENTS>
                            # <COMMENTS>and</COMMENTS> <COMMENTS>keyword</COMMENTS>, <COMMENTS>maybe</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS>
                            # <COMMENTS>s</COMMENTS>/<COMMENTS>xxx</COMMENTS>/<COMMENTS>yyy</COMMENTS>/<COMMENTS>gefor</COMMENTS> @<COMMENTS>k</COMMENTS>=...
                            # <COMMENTS>Example</COMMENTS> <COMMENTS>is</COMMENTS> "<COMMENTS>galgen</COMMENTS>.<COMMENTS>pl</COMMENTS>".  <COMMENTS>Would</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>split</COMMENTS>
                            # <COMMENTS>the</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>insert</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS>
                            # <COMMENTS>pre</COMMENTS>-<COMMENTS>token</COMMENTS> <COMMENTS>list</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>rare</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>I</COMMENTS> <COMMENTS>haven</COMMENTS>'<COMMENTS>t</COMMENTS>
                            # <COMMENTS>done</COMMENTS> <COMMENTS>it</COMMENTS>.  <COMMENTS>Will</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>issue</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>warning</COMMENTS> <COMMENTS>citation</COMMENTS>.

                            # <COMMENTS>This</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>triggered</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>quote</COMMENTS>
                            # <COMMENTS>modifier</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>incomplete</COMMENTS>
                            else {
                                <CODE>warning</CODE>(<<<LITERALS>EOM</LITERALS>);

<LITERALS>Partial</LITERALS> <LITERALS>match</LITERALS> <LITERALS>to</LITERALS> <LITERALS>quote</LITERALS> <LITERALS>modifier</LITERALS> $<CODE>allowed_quote_modifiers</CODE> <LITERALS>at</LITERALS> <LITERALS>word</LITERALS>: '$<CODE>str</CODE>'
<LITERALS>Please</LITERALS> <LITERALS>put</LITERALS> <LITERALS>a</LITERALS> <LITERALS>space</LITERALS> <LITERALS>between</LITERALS> <LITERALS>quote</LITERALS> <LITERALS>modifiers</LITERALS> <LITERALS>and</LITERALS> <LITERALS>trailing</LITERALS> <LITERALS>keywords</LITERALS>.
<CODE>EOM</CODE>

                           # <COMMENTS>print</COMMENTS> "<COMMENTS>token</COMMENTS> <COMMENTS>$$rtokens</COMMENTS>[<COMMENTS>$i</COMMENTS>]\<COMMENTS>n</COMMENTS>";
                           # <COMMENTS>my</COMMENTS> <COMMENTS>$num</COMMENTS> = <COMMENTS>length</COMMENTS>(<COMMENTS>$str</COMMENTS>) - <COMMENTS>pos</COMMENTS>(<COMMENTS>$str</COMMENTS>);
                           # <COMMENTS>$$rtokens</COMMENTS>[<COMMENTS>$i</COMMENTS>]=<COMMENTS>substr</COMMENTS>(<COMMENTS>$$rtokens</COMMENTS>[<COMMENTS>$i</COMMENTS>],<COMMENTS>pos</COMMENTS>(<COMMENTS>$str</COMMENTS>),<COMMENTS>$num</COMMENTS>);
                           # <COMMENTS>print</COMMENTS> "<COMMENTS>continuing</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>$$rtokens</COMMENTS>[<COMMENTS>$i</COMMENTS>]\<COMMENTS>n</COMMENTS>";

                                # <COMMENTS>skipping</COMMENTS> <COMMENTS>past</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>damage</COMMENTS>
                                last if ( ++$<CODE>i</CODE> > $<CODE>max_token_index</CODE> );
                            }
                        }
                        else {

                            # <COMMENTS>example</COMMENTS> <COMMENTS>file</COMMENTS>: <COMMENTS>rokicki4</COMMENTS>.<COMMENTS>pl</COMMENTS>
                            # <COMMENTS>This</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>triggered</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>quote</COMMENTS>
                            # <COMMENTS>modifier</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>incomplete</COMMENTS>
                            <CODE>write_logfile_entry</CODE>(
"<LITERALS>Note</LITERALS>: <LITERALS>found</LITERALS> <LITERALS>word</LITERALS> $<CODE>str</CODE> <LITERALS>at</LITERALS> <LITERALS>quote</LITERALS> <LITERALS>modifier</LITERALS> <LITERALS>location</LITERALS>\n"
                            );
                        }
                    }

                    # <COMMENTS>re</COMMENTS>-<COMMENTS>initialize</COMMENTS>
                    $<CODE>allowed_quote_modifiers</CODE> = "";
                }
            }

            unless ( $<CODE>tok</CODE> =~ /^\s*$/ || $<CODE>tok</CODE> eq '<LITERALS>CORE</LITERALS>::' ) {

                # <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>catch</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>errors</COMMENTS>
                if ( ( $<CODE>type</CODE> eq '<LITERALS>n</LITERALS>' ) && ( $<CODE>tok</CODE> ne '<LITERALS>0</LITERALS>' ) ) {

                    if ( $<CODE>last_nonblank_token</CODE> eq '<LITERALS>eq</LITERALS>' ) {
                        <CODE>complain</CODE>("<LITERALS>Should</LITERALS> '<LITERALS>eq</LITERALS>' <LITERALS>be</LITERALS> '==' <LITERALS>here</LITERALS> ?\n");
                    }
                    elsif ( $<CODE>last_nonblank_token</CODE> eq '<LITERALS>ne</LITERALS>' ) {
                        <CODE>complain</CODE>("<LITERALS>Should</LITERALS> '<LITERALS>ne</LITERALS>' <LITERALS>be</LITERALS> '!=' <LITERALS>here</LITERALS> ?\n");
                    }
                }

                $<CODE>last_last_nonblank_token</CODE>      = $<CODE>last_nonblank_token</CODE>;
                $<CODE>last_last_nonblank_type</CODE>       = $<CODE>last_nonblank_type</CODE>;
                $<CODE>last_last_nonblank_block_type</CODE> = $<CODE>last_nonblank_block_type</CODE>;
                $<CODE>last_last_nonblank_container_type</CODE> =
                  $<CODE>last_nonblank_container_type</CODE>;
                $<CODE>last_last_nonblank_type_sequence</CODE> =
                  $<CODE>last_nonblank_type_sequence</CODE>;
                $<CODE>last_nonblank_token</CODE>          = $<CODE>tok</CODE>;
                $<CODE>last_nonblank_type</CODE>           = $<CODE>type</CODE>;
                $<CODE>last_nonblank_prototype</CODE>      = $<CODE>prototype</CODE>;
                $<CODE>last_nonblank_block_type</CODE>     = $<CODE>block_type</CODE>;
                $<CODE>last_nonblank_container_type</CODE> = $<CODE>container_type</CODE>;
                $<CODE>last_nonblank_type_sequence</CODE>  = $<CODE>type_sequence</CODE>;
                $<CODE>last_nonblank_i</CODE>              = $<CODE>i_tok</CODE>;
            }

            # <COMMENTS>store</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS>
            if ( $<CODE>i_tok</CODE> >= 0 ) {
                $<CODE>routput_token_type</CODE>->[$<CODE>i_tok</CODE>]     = $<CODE>type</CODE>;
                $<CODE>routput_block_type</CODE>->[$<CODE>i_tok</CODE>]     = $<CODE>block_type</CODE>;
                $<CODE>routput_container_type</CODE>->[$<CODE>i_tok</CODE>] = $<CODE>container_type</CODE>;
                $<CODE>routput_type_sequence</CODE>->[$<CODE>i_tok</CODE>]  = $<CODE>type_sequence</CODE>;
                $<CODE>routput_indent_flag</CODE>->[$<CODE>i_tok</CODE>]    = $<CODE>indent_flag</CODE>;
            }
            my $<CODE>pre_tok</CODE>  = $$<CODE>rtokens</CODE>[$<CODE>i</CODE>];        # <COMMENTS>get</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>token</COMMENTS>
            my $<CODE>pre_type</CODE> = $$<CODE>rtoken_type</CODE>[$<CODE>i</CODE>];    # <COMMENTS>and</COMMENTS> <COMMENTS>type</COMMENTS>
            $<CODE>tok</CODE>  = $<CODE>pre_tok</CODE>;
            $<CODE>type</CODE> = $<CODE>pre_type</CODE>;                   # <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>modified</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>necessary</COMMENTS>
            $<CODE>block_type</CODE> = "";    # <COMMENTS>blank</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>braces</COMMENTS>
            $<CODE>container_type</CODE> = "";    # <COMMENTS>blank</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>parens</COMMENTS>
            $<CODE>type_sequence</CODE>  = "";    # <COMMENTS>blank</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>except</COMMENTS> ?/:
            $<CODE>indent_flag</CODE>    = 0;
            $<CODE>prototype</CODE> = "";    # <COMMENTS>blank</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>subs</COMMENTS>
            $<CODE>i_tok</CODE>     = $<CODE>i</CODE>;

            # <COMMENTS>this</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>token</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>token</COMMENTS>
            push( @{$<CODE>routput_token_list</CODE>}, $<CODE>i_tok</CODE> );

            # <COMMENTS>continue</COMMENTS> <COMMENTS>gathering</COMMENTS> <COMMENTS>identifier</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
            # <COMMENTS>but</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>blanks</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>comments</COMMENTS>
            if ( $<CODE>id_scan_state</CODE> && $<CODE>pre_type</CODE> !~ /[b#]/ ) {

                if ( $<CODE>id_scan_state</CODE> =~ /^(sub|package)/ ) {
                    <CODE>scan_id</CODE>();
                }
                else {
                    <CODE>scan_identifier</CODE>();
                }

                last if ($<CODE>id_scan_state</CODE>);
                next if ( ( $<CODE>i</CODE> > 0 ) || $<CODE>type</CODE> );

                # <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>token</COMMENTS>; <COMMENTS>start</COMMENTS> <COMMENTS>over</COMMENTS>
                $<CODE>type</CODE> = $<CODE>pre_type</CODE>;
                $<CODE>tok</CODE>  = $<CODE>pre_tok</CODE>;
            }

            # <COMMENTS>handle</COMMENTS> <COMMENTS>whitespace</COMMENTS> <COMMENTS>tokens</COMMENTS>..
            next if ( $<CODE>type</CODE> eq '<LITERALS>b</LITERALS>' );
            my $<CODE>prev_tok</CODE>  = $<CODE>i</CODE> > 0 ? $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> - 1 ]     : ' ';
            my $<CODE>prev_type</CODE> = $<CODE>i</CODE> > 0 ? $$<CODE>rtoken_type</CODE>[ $<CODE>i</CODE> - 1 ] : '<LITERALS>b</LITERALS>';

            # <COMMENTS>Build</COMMENTS> <COMMENTS>larger</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>possible</COMMENTS>, <COMMENTS>since</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS>.
            #
            # <COMMENTS>First</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>assemble</COMMENTS> <COMMENTS>digraphs</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>are</COMMENTS>
            # <COMMENTS>excluded</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>specially</COMMENTS>:
            # '/=' <COMMENTS>is</COMMENTS> <COMMENTS>excluded</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> / <COMMENTS>might</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS>.
            # '<COMMENTS>x</COMMENTS>=' <COMMENTS>is</COMMENTS> <COMMENTS>excluded</COMMENTS> <COMMENTS>since</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>$x</COMMENTS>=, <COMMENTS>with</COMMENTS> <COMMENTS>$</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>line</COMMENTS>
            # '**' <COMMENTS>and</COMMENTS> *= <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>typeglobs</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>punctuation</COMMENTS> <COMMENTS>variables</COMMENTS>
            # <COMMENTS>I</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>allowed</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>with</COMMENTS> <, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <=,
            # <COMMENTS>because</COMMENTS> <COMMENTS>I</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>think</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>angle</COMMENTS> <COMMENTS>operators</COMMENTS>.
            # <COMMENTS>test</COMMENTS> <COMMENTS>file</COMMENTS>: <COMMENTS>storrs4</COMMENTS>.<COMMENTS>pl</COMMENTS>
            my $<CODE>test_tok</CODE>   = $<CODE>tok</CODE> . $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ];
            my $<CODE>combine_ok</CODE> = $<CODE>is_digraph</CODE>{$<CODE>test_tok</CODE>};

            # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>cases</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>cannot</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>combined</COMMENTS>
            if ($<CODE>combine_ok</CODE>) {

                # '//' <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>defined_or</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>expected</COMMENTS>.
                # <COMMENTS>TODO</COMMENTS>: <COMMENTS>Code</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>ambiguous</COMMENTS> <COMMENTS>digraphs</COMMENTS> (/=, <COMMENTS>x</COMMENTS>=, **, *=)
                # <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>migrated</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>clarity</COMMENTS>

              # <COMMENTS>Patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>RT</COMMENTS>#<COMMENTS>102371</COMMENTS>, <COMMENTS>misparsing</COMMENTS> <COMMENTS>a</COMMENTS> // <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>snippet</COMMENTS>:
              #     <COMMENTS>state</COMMENTS> <COMMENTS>$b</COMMENTS> //= <COMMENTS>ccc</COMMENTS>();
              # <COMMENTS>The</COMMENTS> <COMMENTS>solution</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>accept</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>digraph</COMMENTS> (<COMMENTS>or</COMMENTS> <COMMENTS>trigraph</COMMENTS>) <COMMENTS>after</COMMENTS>
              # <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>Z</COMMENTS>' (<COMMENTS>possible</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>handle</COMMENTS>).  <COMMENTS>The</COMMENTS> <COMMENTS>reason</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS>
              # <COMMENTS>sub</COMMENTS> <COMMENTS>operator_expected</COMMENTS> <COMMENTS>gives</COMMENTS> <COMMENTS>TERM</COMMENTS> <COMMENTS>expected</COMMENTS> <COMMENTS>here</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS>
              # <COMMENTS>wrong</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>case</COMMENTS>.
                if ( $<CODE>test_tok</CODE> eq '//' && $<CODE>last_nonblank_type</CODE> ne '<LITERALS>Z</LITERALS>' ) {
                    my $<CODE>next_type</CODE> = $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ];
                    my $<CODE>expecting</CODE> =
                      <CODE>operator_expected</CODE>( $<CODE>prev_type</CODE>, $<CODE>tok</CODE>, $<CODE>next_type</CODE> );

                    # <COMMENTS>Patched</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>RT</COMMENTS>#<COMMENTS>101547</COMMENTS>, <COMMENTS>was</COMMENTS> '<COMMENTS>unless</COMMENTS> (<COMMENTS>$expecting</COMMENTS>==<COMMENTS>OPERATOR</COMMENTS>)'
                    $<CODE>combine_ok</CODE> = 0 if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> );
                }
            }

            if (
                $<CODE>combine_ok</CODE>
                && ( $<CODE>test_tok</CODE> ne '/=' )    # <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>pattern</COMMENTS>
                && ( $<CODE>test_tok</CODE> ne '<LITERALS>x</LITERALS>=' )    # <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>$x</COMMENTS>
                && ( $<CODE>test_tok</CODE> ne '**' )    # <COMMENTS>typeglob</COMMENTS>?
                && ( $<CODE>test_tok</CODE> ne '*=' )    # <COMMENTS>typeglob</COMMENTS>?
              )
            {
                $<CODE>tok</CODE> = $<CODE>test_tok</CODE>;
                $<CODE>i</CODE>++;

                # <COMMENTS>Now</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>assemble</COMMENTS> <COMMENTS>trigraphs</COMMENTS>.  <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>possible</COMMENTS>
                # <COMMENTS>perl</COMMENTS> <COMMENTS>trigraphs</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>constructed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>appending</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>character</COMMENTS>
                # <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>digraph</COMMENTS>.
                $<CODE>test_tok</CODE> = $<CODE>tok</CODE> . $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ];

                if ( $<CODE>is_trigraph</CODE>{$<CODE>test_tok</CODE>} ) {
                    $<CODE>tok</CODE> = $<CODE>test_tok</CODE>;
                    $<CODE>i</CODE>++;
                }
            }

            $<CODE>type</CODE>      = $<CODE>tok</CODE>;
            $<CODE>next_tok</CODE>  = $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ];
            $<CODE>next_type</CODE> = $$<CODE>rtoken_type</CODE>[ $<CODE>i</CODE> + 1 ];

            <CODE>TOKENIZER_DEBUG_FLAG_TOKENIZE</CODE> && do {
                local $" = ')(';
                my @<CODE>debug_list</CODE> = (
                    $<CODE>last_nonblank_token</CODE>,      $<CODE>tok</CODE>,
                    $<CODE>next_tok</CODE>,                 $<CODE>brace_depth</CODE>,
                    $<CODE>brace_type</CODE>[$<CODE>brace_depth</CODE>], $<CODE>paren_depth</CODE>,
                    $<CODE>paren_type</CODE>[$<CODE>paren_depth</CODE>]
                );
                print <CODE>STDOUT</CODE> "<LITERALS>TOKENIZE</LITERALS>:(@<CODE>debug_list</CODE>)\n";
            };

            # <COMMENTS>turn</COMMENTS> <COMMENTS>off</COMMENTS> <COMMENTS>attribute</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS>, <COMMENTS>non</COMMENTS>-<COMMENTS>bareword</COMMENTS>
            if ( $<CODE>pre_type</CODE> ne '<LITERALS>w</LITERALS>' ) { $<CODE>in_attribute_list</CODE> = 0 }

            ###############################################################
            # <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>$tok</COMMENTS>.
            # <COMMENTS>Now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>examine</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS>
            # <COMMENTS>and</COMMENTS> <COMMENTS>define</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>$type</COMMENTS>
            #
            # <COMMENTS>section</COMMENTS> <COMMENTS>1</COMMENTS>: <COMMENTS>bare</COMMENTS> <COMMENTS>words</COMMENTS>
            ###############################################################

            if ( $<CODE>pre_type</CODE> eq '<LITERALS>w</LITERALS>' ) {
                $<CODE>expecting</CODE> = <CODE>operator_expected</CODE>( $<CODE>prev_type</CODE>, $<CODE>tok</CODE>, $<CODE>next_type</CODE> );
                my ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_next</CODE> ) =
                  <CODE>find_next_nonblank_token</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> );

                # <COMMENTS>ATTRS</COMMENTS>: <COMMENTS>handle</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>variable</COMMENTS> <COMMENTS>attributes</COMMENTS>
                if ($<CODE>in_attribute_list</CODE>) {

                    # <COMMENTS>treat</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>qw</COMMENTS>(
                    if ( $<CODE>next_nonblank_token</CODE> eq '(' ) {
                        $<CODE>in_quote</CODE>                = $<CODE>quote_items</CODE>{'<LITERALS>q</LITERALS>'};
                        $<CODE>allowed_quote_modifiers</CODE> = $<CODE>quote_modifiers</CODE>{'<LITERALS>q</LITERALS>'};
                        $<CODE>type</CODE>                    = '<LITERALS>q</LITERALS>';
                        $<CODE>quote_type</CODE>              = '<LITERALS>q</LITERALS>';
                        next;
                    }

                    # <COMMENTS>handle</COMMENTS> <COMMENTS>bareword</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>paren</COMMENTS>
                    else {
                        $<CODE>type</CODE> = '<LITERALS>w</LITERALS>';
                        next;
                    }
                }

                # <COMMENTS>quote</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> => <COMMENTS>operator</COMMENTS>
                if ( $<CODE>next_nonblank_token</CODE> eq '=' ) {

                    if ( $$<CODE>rtokens</CODE>[ $<CODE>i_next</CODE> + 1 ] eq '>' ) {
                        if ( $<CODE>is_constant</CODE>{$<CODE>current_package</CODE>}{$<CODE>tok</CODE>} ) {
                            $<CODE>type</CODE> = '<LITERALS>C</LITERALS>';
                        }
                        elsif ( $<CODE>is_user_function</CODE>{$<CODE>current_package</CODE>}{$<CODE>tok</CODE>} ) {
                            $<CODE>type</CODE> = '<LITERALS>U</LITERALS>';
                            $<CODE>prototype</CODE> =
                              $<CODE>user_function_prototype</CODE>{$<CODE>current_package</CODE>}{$<CODE>tok</CODE>};
                        }
                        elsif ( $<CODE>tok</CODE> =~ /^v\d+$/ ) {
                            $<CODE>type</CODE> = '<LITERALS>v</LITERALS>';
                            <CODE>report_v_string</CODE>($<CODE>tok</CODE>);
                        }
                        else { $<CODE>type</CODE> = '<LITERALS>w</LITERALS>' }

                        next;
                    }
                }

     # <COMMENTS>quote</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>braces</COMMENTS>..<COMMENTS>like</COMMENTS> <COMMENTS>xxx</COMMENTS>->{<COMMENTS>s</COMMENTS>}; <COMMENTS>note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS>
     # <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>brace</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS>
     # <COMMENTS>mistaking</COMMENTS> {<COMMENTS>s</COMMENTS>} <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS>:
     #     <COMMENTS>for</COMMENTS>(@[){<COMMENTS>s</COMMENTS>}<COMMENTS>bla</COMMENTS>}<COMMENTS>BLA</COMMENTS>}
     # <COMMENTS>Also</COMMENTS> <COMMENTS>treat</COMMENTS> <COMMENTS>q</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>var</COMMENTS>{-<COMMENTS>q</COMMENTS>} <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS>, <COMMENTS>not</COMMENTS> <COMMENTS>qoute</COMMENTS> <COMMENTS>operator</COMMENTS>
                if (
                    $<CODE>next_nonblank_token</CODE> eq '}'
                    && (
                        $<CODE>last_nonblank_type</CODE> eq '<LITERALS>L</LITERALS>'
                        || (   $<CODE>last_nonblank_type</CODE> eq '<LITERALS>m</LITERALS>'
                            && $<CODE>last_last_nonblank_type</CODE> eq '<LITERALS>L</LITERALS>' )
                    )
                  )
                {
                    $<CODE>type</CODE> = '<LITERALS>w</LITERALS>';
                    next;
                }

                # <COMMENTS>a</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>immediately</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> :: <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>keyword</COMMENTS>;
                # <COMMENTS>use</COMMENTS> <COMMENTS>$tok_kw</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>testing</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>mistake</COMMENTS>
                my $<CODE>tok_kw</CODE> = $<CODE>tok</CODE>;
                if ( $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ] eq ':' && $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 2 ] eq ':' )
                {
                    $<CODE>tok_kw</CODE> .= '::';
                }

                # <COMMENTS>handle</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>x</COMMENTS> (<COMMENTS>now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>isn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>$x</COMMENTS>=)
                if ( ( $<CODE>tok</CODE> =~ /^x\d*$/ ) && ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> ) ) {
                    if ( $<CODE>tok</CODE> eq '<LITERALS>x</LITERALS>' ) {

                        if ( $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ] eq '=' ) {    # <COMMENTS>x</COMMENTS>=
                            $<CODE>tok</CODE>  = '<LITERALS>x</LITERALS>=';
                            $<CODE>type</CODE> = $<CODE>tok</CODE>;
                            $<CODE>i</CODE>++;
                        }
                        else {
                            $<CODE>type</CODE> = '<LITERALS>x</LITERALS>';
                        }
                    }

                    # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>Patch</COMMENTS>: <COMMENTS>mark</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>x4</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>integer</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>now</COMMENTS>
                    # <COMMENTS>It</COMMENTS> <COMMENTS>gets</COMMENTS> <COMMENTS>fixed</COMMENTS> <COMMENTS>downstream</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>easier</COMMENTS> <COMMENTS>than</COMMENTS>
                    # <COMMENTS>splitting</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pretoken</COMMENTS>.
                    else {
                        $<CODE>type</CODE> = '<LITERALS>n</LITERALS>';
                    }
                }
                elsif ( $<CODE>tok_kw</CODE> eq '<LITERALS>CORE</LITERALS>::' ) {
                    $<CODE>type</CODE> = $<CODE>tok</CODE> = $<CODE>tok_kw</CODE>;
                    $<CODE>i</CODE> += 2;
                }
                elsif ( ( $<CODE>tok</CODE> eq '<LITERALS>strict</LITERALS>' )
                    and ( $<CODE>last_nonblank_token</CODE> eq '<LITERALS>use</LITERALS>' ) )
                {
                    $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_use_strict</LITERALS>} = 1;
                    <CODE>scan_bare_identifier</CODE>();
                }

                elsif ( ( $<CODE>tok</CODE> eq '<LITERALS>warnings</LITERALS>' )
                    and ( $<CODE>last_nonblank_token</CODE> eq '<LITERALS>use</LITERALS>' ) )
                {
                    $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_perl_dash_w</LITERALS>} = 1;

                    # <COMMENTS>scan</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>identifier</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>pick</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS>:
                    # <COMMENTS>use</COMMENTS> <COMMENTS>warnings</COMMENTS>::<COMMENTS>register</COMMENTS>
                    <CODE>scan_bare_identifier</CODE>();
                }

                elsif (
                       $<CODE>tok</CODE> eq '<LITERALS>AutoLoader</LITERALS>'
                    && $<CODE>tokenizer_self</CODE>->{<LITERALS>_look_for_autoloader</LITERALS>}
                    && (
                        $<CODE>last_nonblank_token</CODE> eq '<LITERALS>use</LITERALS>'

                        # <COMMENTS>these</COMMENTS> <COMMENTS>regexes</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>AutoSplit</COMMENTS>.<COMMENTS>pm</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS>
                        # <COMMENTS>to</COMMENTS> <COMMENTS>mimic</COMMENTS>
                        || $<CODE>input_line</CODE> =~ /^\s*(use|require)\s+AutoLoader\b/
                        || $<CODE>input_line</CODE> =~ /\bISA\s*=.*\bAutoLoader\b/
                    )
                  )
                {
                    <CODE>write_logfile_entry</CODE>("<LITERALS>AutoLoader</LITERALS> <LITERALS>seen</LITERALS>, -<LITERALS>nlal</LITERALS> <LITERALS>deactivates</LITERALS>\n");
                    $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_autoloader</LITERALS>}      = 1;
                    $<CODE>tokenizer_self</CODE>->{<LITERALS>_look_for_autoloader</LITERALS>} = 0;
                    <CODE>scan_bare_identifier</CODE>();
                }

                elsif (
                       $<CODE>tok</CODE> eq '<LITERALS>SelfLoader</LITERALS>'
                    && $<CODE>tokenizer_self</CODE>->{<LITERALS>_look_for_selfloader</LITERALS>}
                    && (   $<CODE>last_nonblank_token</CODE> eq '<LITERALS>use</LITERALS>'
                        || $<CODE>input_line</CODE> =~ /^\s*(use|require)\s+SelfLoader\b/
                        || $<CODE>input_line</CODE> =~ /\bISA\s*=.*\bSelfLoader\b/ )
                  )
                {
                    <CODE>write_logfile_entry</CODE>("<LITERALS>SelfLoader</LITERALS> <LITERALS>seen</LITERALS>, -<LITERALS>nlsl</LITERALS> <LITERALS>deactivates</LITERALS>\n");
                    $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_selfloader</LITERALS>}      = 1;
                    $<CODE>tokenizer_self</CODE>->{<LITERALS>_look_for_selfloader</LITERALS>} = 0;
                    <CODE>scan_bare_identifier</CODE>();
                }

                elsif ( ( $<CODE>tok</CODE> eq '<LITERALS>constant</LITERALS>' )
                    and ( $<CODE>last_nonblank_token</CODE> eq '<LITERALS>use</LITERALS>' ) )
                {
                    <CODE>scan_bare_identifier</CODE>();
                    my ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_next</CODE> ) =
                      <CODE>find_next_nonblank_token</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>,
                        $<CODE>max_token_index</CODE> );

                    if ($<CODE>next_nonblank_token</CODE>) {

                        if ( $<CODE>is_keyword</CODE>{$<CODE>next_nonblank_token</CODE>} ) {

                            # <COMMENTS>Assume</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>okay</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS>:
                            #  <COMMENTS>use</COMMENTS> <COMMENTS>constant</COMMENTS> <COMMENTS>qw</COMMENTS>{ <COMMENTS>DEBUG</COMMENTS> <COMMENTS>0</COMMENTS> };
                            # <COMMENTS>Not</COMMENTS> <COMMENTS>worth</COMMENTS> <COMMENTS>trying</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>parse</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>warning</COMMENTS>

                            # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>warning</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>deactivated</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>recent</COMMENTS>
                            # <COMMENTS>versions</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>complain</COMMENTS> <COMMENTS>here</COMMENTS>, <COMMENTS>but</COMMENTS>
                            # <COMMENTS>the</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>retained</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>reference</COMMENTS>.
                            if ( 0 && $<CODE>next_nonblank_token</CODE> ne '<LITERALS>qw</LITERALS>' ) {
                                <CODE>warning</CODE>(
"<LITERALS>Attempting</LITERALS> <LITERALS>to</LITERALS> <LITERALS>define</LITERALS> <LITERALS>constant</LITERALS> '$<CODE>next_nonblank_token</CODE>' <LITERALS>which</LITERALS> <LITERALS>is</LITERALS> <LITERALS>a</LITERALS> <LITERALS>perl</LITERALS> <LITERALS>keyword</LITERALS>\n"
                                );
                            }
                        }

                        # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>could</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>is</COMMENTS>
                        # <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>word</COMMENTS> (<COMMENTS>number</COMMENTS>, <COMMENTS>punctuation</COMMENTS>, ..)
                        else {
                            $<CODE>is_constant</CODE>{$<CODE>current_package</CODE>}{$<CODE>next_nonblank_token</CODE>}
                              = 1;
                        }
                    }
                }

                # <COMMENTS>various</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>operators</COMMENTS>
                elsif ( $<CODE>is_q_qq_qw_qx_qr_s_y_tr_m</CODE>{$<CODE>tok</CODE>} ) {
##<COMMENTS>NICOL</COMMENTS> <COMMENTS>PATCH</COMMENTS>
                    if ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> ) {

                        # <COMMENTS>Be</COMMENTS> <COMMENTS>careful</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>quote</COMMENTS>
                        # <COMMENTS>where</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>parenthesized</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>allowed</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>,
                        # <COMMENTS>it</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>for</COMMENTS>/<COMMENTS>foreach</COMMENTS> <COMMENTS>construct</COMMENTS> <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS>
                        #
                        #    <COMMENTS>foreach</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>$key</COMMENTS> <COMMENTS>qw</COMMENTS>\<COMMENTS>Uno</COMMENTS> <COMMENTS>Due</COMMENTS> <COMMENTS>Tres</COMMENTS> <COMMENTS>Quadro</COMMENTS>\ {
                        #        <COMMENTS>print</COMMENTS> "<COMMENTS>Set</COMMENTS> <COMMENTS>$key</COMMENTS>\<COMMENTS>n</COMMENTS>";
                        #    }
                        #

                        # <COMMENTS>Or</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>call</COMMENTS>.
                        # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>Braces</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> &{ <COMMENTS>xxx</COMMENTS> } <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS>
                        # <COMMENTS>marked</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>method</COMMENTS> <COMMENTS>call</COMMENTS>.
                        # &<COMMENTS>method</COMMENTS>(...), <COMMENTS>$method</COMMENTS>->(..), &{<COMMENTS>method</COMMENTS>}(...),
                        # <COMMENTS>$ref</COMMENTS>[<COMMENTS>2</COMMENTS>](<COMMENTS>list</COMMENTS>) <COMMENTS>is</COMMENTS> <COMMENTS>ok</COMMENTS> & <COMMENTS>short</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>$ref</COMMENTS>[<COMMENTS>2</COMMENTS>]->(<COMMENTS>list</COMMENTS>)
                        #
                        # <COMMENTS>See</COMMENTS> <COMMENTS>notes</COMMENTS> <COMMENTS>in</COMMENTS> '<COMMENTS>sub</COMMENTS> <COMMENTS>code_block_type</COMMENTS>' <COMMENTS>and</COMMENTS>
                        # '<COMMENTS>sub</COMMENTS> <COMMENTS>is_non_structural_brace</COMMENTS>'

                        unless (
                            $<CODE>tok</CODE> eq '<LITERALS>qw</LITERALS>'
                            && (   $<CODE>last_nonblank_token</CODE> =~ /^([\]\}\&]|\-\>)/
                                || $<CODE>is_for_foreach</CODE>{$<CODE>want_paren</CODE>} )
                          )
                        {
                            <CODE>error_if_expecting_OPERATOR</CODE>();
                        }
                    }
                    $<CODE>in_quote</CODE>                = $<CODE>quote_items</CODE>{$<CODE>tok</CODE>};
                    $<CODE>allowed_quote_modifiers</CODE> = $<CODE>quote_modifiers</CODE>{$<CODE>tok</CODE>};

                   # <COMMENTS>All</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>are</COMMENTS> '<COMMENTS>Q</COMMENTS>' <COMMENTS>except</COMMENTS> <COMMENTS>possibly</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>quotes</COMMENTS>.
                   # <COMMENTS>qw</COMMENTS> <COMMENTS>quotes</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>generally</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>trimmed</COMMENTS>
                   # <COMMENTS>of</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>whitespace</COMMENTS>.  <COMMENTS>So</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>a</COMMENTS>
                   # <COMMENTS>separate</COMMENTS> <COMMENTS>type</COMMENTS>, '<COMMENTS>q</COMMENTS>', <COMMENTS>unless</COMMENTS> <COMMENTS>requested</COMMENTS> <COMMENTS>otherwise</COMMENTS>.
                    $<CODE>type</CODE> =
                      ( $<CODE>tok</CODE> eq '<LITERALS>qw</LITERALS>' && $<CODE>tokenizer_self</CODE>->{<LITERALS>_trim_qw</LITERALS>} )
                      ? '<LITERALS>q</LITERALS>'
                      : '<LITERALS>Q</LITERALS>';
                    $<CODE>quote_type</CODE> = $<CODE>type</CODE>;
                }

                # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>label</COMMENTS>
                elsif (
                       ( $<CODE>next_nonblank_token</CODE> eq ':' )
                    && ( $$<CODE>rtokens</CODE>[ $<CODE>i_next</CODE> + 1 ] ne ':' )
                    && ( $<CODE>i_next</CODE> <= $<CODE>max_token_index</CODE> )      # <COMMENTS>colon</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>line</COMMENTS>
                    && <CODE>label_ok</CODE>()
                  )
                {
                    if ( $<CODE>tok</CODE> !~ /[A-Z]/ ) {
                        push @{ $<CODE>tokenizer_self</CODE>->{<LITERALS>_rlower_case_labels_at</LITERALS>} },
                          $<CODE>input_line_number</CODE>;
                    }
                    $<CODE>type</CODE> = '<LITERALS>J</LITERALS>';
                    $<CODE>tok</CODE> .= ':';
                    $<CODE>i</CODE> = $<CODE>i_next</CODE>;
                    next;
                }

                #      '<COMMENTS>sub</COMMENTS>' || '<COMMENTS>package</COMMENTS>'
                elsif ( $<CODE>is_sub_package</CODE>{$<CODE>tok_kw</CODE>} ) {
                    <CODE>error_if_expecting_OPERATOR</CODE>()
                      if ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> );
                    <CODE>scan_id</CODE>();
                }

                # <COMMENTS>Note</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>format</COMMENTS>, <COMMENTS>__DATA__</COMMENTS>, <COMMENTS>__END__</COMMENTS>:
                # <COMMENTS>It</COMMENTS> <COMMENTS>simplifies</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>type</COMMENTS> ';', <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>we</COMMENTS>
                # <COMMENTS>start</COMMENTS> <COMMENTS>rescanning</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>expecting</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>TERM</COMMENTS>.
                # <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>switch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>k</COMMENTS>' <COMMENTS>before</COMMENTS> <COMMENTS>outputting</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokens</COMMENTS>.
                elsif ( $<CODE>is_format_END_DATA</CODE>{$<CODE>tok_kw</CODE>} ) {
                    $<CODE>type</CODE> = ';';    # <COMMENTS>make</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>TERM</COMMENTS> <COMMENTS>next</COMMENTS>
                    $<CODE>tokenizer_self</CODE>->{ $<CODE>is_format_END_DATA</CODE>{$<CODE>tok_kw</CODE>} } = 1;
                    last;
                }

                elsif ( $<CODE>is_keyword</CODE>{$<CODE>tok_kw</CODE>} ) {
                    $<CODE>type</CODE> = '<LITERALS>k</LITERALS>';

                    # <COMMENTS>Since</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>foreach</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>immediately</COMMENTS>
                    # <COMMENTS>by</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>remember</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>keyword</COMMENTS>
                    # <COMMENTS>is</COMMENTS> <COMMENTS>associated</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> '('
                    if ( $<CODE>is_for_foreach</CODE>{$<CODE>tok</CODE>} ) {
                        if ( <CODE>new_statement_ok</CODE>() ) {
                            $<CODE>want_paren</CODE> = $<CODE>tok</CODE>;
                        }
                    }

                    # <COMMENTS>recognize</COMMENTS> '<COMMENTS>use</COMMENTS>' <COMMENTS>statements</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>special</COMMENTS>
                    elsif ( $<CODE>is_use_require</CODE>{$<CODE>tok</CODE>} ) {
                        $<CODE>statement_type</CODE> = $<CODE>tok</CODE>;
                        <CODE>error_if_expecting_OPERATOR</CODE>()
                          if ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> );
                    }

                    # <COMMENTS>remember</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>our</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>trailing</COMMENTS> ": <COMMENTS>shared</COMMENTS>"
                    elsif ( $<CODE>is_my_our</CODE>{$<CODE>tok</CODE>} ) {
                        $<CODE>statement_type</CODE> = $<CODE>tok</CODE>;
                    }

                    # <COMMENTS>Check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>misplaced</COMMENTS> '<COMMENTS>elsif</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>else</COMMENTS>', <COMMENTS>but</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>isolated</COMMENTS>
                    # <COMMENTS>else</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>elsif</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>formatted</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>indicated</COMMENTS>
                    # <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>noblank</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> ';'
                    elsif ( $<CODE>tok</CODE> eq '<LITERALS>elsif</LITERALS>' ) {
                        if (   $<CODE>last_nonblank_token</CODE> ne ';'
                            && $<CODE>last_nonblank_block_type</CODE> !~
                            /^(if|elsif|unless)$/ )
                        {
                            <CODE>warning</CODE>(
"<LITERALS>expecting</LITERALS> '$<CODE>tok</CODE>' <LITERALS>to</LITERALS> <LITERALS>follow</LITERALS> <LITERALS>one</LITERALS> <LITERALS>of</LITERALS> '<LITERALS>if</LITERALS>|<LITERALS>elsif</LITERALS>|<LITERALS>unless</LITERALS>'\n"
                            );
                        }
                    }
                    elsif ( $<CODE>tok</CODE> eq '<LITERALS>else</LITERALS>' ) {

                        # <COMMENTS>patched</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS>
                        if (
                               $<CODE>last_nonblank_token</CODE> ne ';'
                            && $<CODE>last_nonblank_block_type</CODE> !~
                            /^(if|elsif|unless|case|when)$/

                            # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>message</COMMENTS> <COMMENTS>for</COMMENTS>
                            # <COMMENTS>the</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>parenless</COMMENTS> '<COMMENTS>case</COMMENTS>' (<COMMENTS>RT</COMMENTS> <COMMENTS>105484</COMMENTS>):
                            # <COMMENTS>switch</COMMENTS> ( <COMMENTS>1</COMMENTS> ) { <COMMENTS>case</COMMENTS> <COMMENTS>x</COMMENTS> { <COMMENTS>2</COMMENTS> } <COMMENTS>else</COMMENTS> { } }
                            && $<CODE>statement_type</CODE> !~
                            /^(if|elsif|unless|case|when)$/
                          )
                        {
                            <CODE>warning</CODE>(
"<LITERALS>expecting</LITERALS> '$<CODE>tok</CODE>' <LITERALS>to</LITERALS> <LITERALS>follow</LITERALS> <LITERALS>one</LITERALS> <LITERALS>of</LITERALS> '<LITERALS>if</LITERALS>|<LITERALS>elsif</LITERALS>|<LITERALS>unless</LITERALS>|<LITERALS>case</LITERALS>|<LITERALS>when</LITERALS>'\n"
                            );
                        }
                    }
                    elsif ( $<CODE>tok</CODE> eq '<LITERALS>continue</LITERALS>' ) {
                        if (   $<CODE>last_nonblank_token</CODE> ne ';'
                            && $<CODE>last_nonblank_block_type</CODE> !~
                            /(^(\{|\}|;|while|until|for|foreach)|:$)/ )
                        {

                            # <COMMENTS>note</COMMENTS>: ';' '{' <COMMENTS>and</COMMENTS> '}' <COMMENTS>in</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>above</COMMENTS>
                            # <COMMENTS>because</COMMENTS> <COMMENTS>continues</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>blocks</COMMENTS>;
                            # ':' <COMMENTS>is</COMMENTS> <COMMENTS>labeled</COMMENTS> <COMMENTS>block</COMMENTS>
                            #
                            ############################################
                            # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>deactivated</COMMENTS> <COMMENTS>because</COMMENTS>
                            # <COMMENTS>continue</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>alternative</COMMENTS> <COMMENTS>usage</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>given</COMMENTS>/<COMMENTS>when</COMMENTS>
                            # <COMMENTS>blocks</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>5</COMMENTS>.<COMMENTS>10</COMMENTS>
                            ## <COMMENTS>warning</COMMENTS>("'<COMMENTS>$tok</COMMENTS>' <COMMENTS>should</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS>\<COMMENTS>n</COMMENTS>");
                            ############################################
                        }
                    }

                    # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS> <COMMENTS>if</COMMENTS> '<COMMENTS>case</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>when</COMMENTS> <COMMENTS>are</COMMENTS>
                    # <COMMENTS>treated</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>keywords</COMMENTS>.
                    elsif ( $<CODE>tok</CODE> eq '<LITERALS>when</LITERALS>' || $<CODE>tok</CODE> eq '<LITERALS>case</LITERALS>' ) {
                        $<CODE>statement_type</CODE> = $<CODE>tok</CODE>;    # <COMMENTS>next</COMMENTS> '{' <COMMENTS>is</COMMENTS> <COMMENTS>block</COMMENTS>
                    }

                    #
                    # <COMMENTS>indent</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>if</COMMENTS>/<COMMENTS>unless</COMMENTS>/<COMMENTS>while</COMMENTS>/<COMMENTS>until</COMMENTS>
                    # <COMMENTS>outdenting</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>loop</COMMENTS>
## <COMMENTS>DEACTIVATED</COMMENTS>: <COMMENTS>unfortunately</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>like</COMMENTS>:
##<COMMENTS>$opt_o</COMMENTS> = <COMMENTS>1</COMMENTS>
##  <COMMENTS>if</COMMENTS> !(
##             <COMMENTS>$opt_b</COMMENTS>
##          || <COMMENTS>$opt_c</COMMENTS>
##          || <COMMENTS>$opt_d</COMMENTS>
##          || <COMMENTS>$opt_f</COMMENTS>
##          || <COMMENTS>$opt_i</COMMENTS>
##          || <COMMENTS>$opt_l</COMMENTS>
##          || <COMMENTS>$opt_o</COMMENTS>
##          || <COMMENTS>$opt_x</COMMENTS>
##  );
##                    <COMMENTS>if</COMMENTS> (   <COMMENTS>$tok</COMMENTS> =~ /^(<COMMENTS>if</COMMENTS>|<COMMENTS>unless</COMMENTS>|<COMMENTS>while</COMMENTS>|<COMMENTS>until</COMMENTS>)<COMMENTS>$</COMMENTS>/
##                        && <COMMENTS>$next_nonblank_token</COMMENTS> <COMMENTS>ne</COMMENTS> '(' )
##                    {
##                        <COMMENTS>$indent_flag</COMMENTS> = <COMMENTS>1</COMMENTS>;
##                    }
                }

                # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>inline</COMMENTS> <COMMENTS>label</COMMENTS> <COMMENTS>following</COMMENTS>
                #         /^(<COMMENTS>redo</COMMENTS>|<COMMENTS>last</COMMENTS>|<COMMENTS>next</COMMENTS>|<COMMENTS>goto</COMMENTS>)<COMMENTS>$</COMMENTS>/
                elsif (( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>' )
                    && ( $<CODE>is_redo_last_next_goto</CODE>{$<CODE>last_nonblank_token</CODE>} ) )
                {
                    $<CODE>type</CODE> = '<LITERALS>j</LITERALS>';
                    next;
                }

                # <COMMENTS>something</COMMENTS> <COMMENTS>else</COMMENTS> --
                else {

                    <CODE>scan_bare_identifier</CODE>();
                    if ( $<CODE>type</CODE> eq '<LITERALS>w</LITERALS>' ) {

                        if ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> ) {

                            # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>complain</COMMENTS> <COMMENTS>about</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>indirect</COMMENTS> <COMMENTS>object</COMMENTS>
                            # <COMMENTS>notation</COMMENTS>.
                            # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>:
                            #   <COMMENTS>package</COMMENTS> <COMMENTS>main</COMMENTS>;
                            #   <COMMENTS>sub</COMMENTS> <COMMENTS>new</COMMENTS>(<COMMENTS>$</COMMENTS>) { ... }
                            #   <COMMENTS>$b</COMMENTS> = <COMMENTS>new</COMMENTS> <COMMENTS>A</COMMENTS>::;  # <COMMENTS>calls</COMMENTS> <COMMENTS>A</COMMENTS>::<COMMENTS>new</COMMENTS>
                            #   <COMMENTS>$c</COMMENTS> = <COMMENTS>new</COMMENTS> <COMMENTS>A</COMMENTS>;    # <COMMENTS>same</COMMENTS> <COMMENTS>thing</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>suspicious</COMMENTS>
                            # <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>A</COMMENTS>::<COMMENTS>new</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>new</COMMENTS>' <COMMENTS>in</COMMENTS>
                            # <COMMENTS>main</COMMENTS>:: <COMMENTS>which</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>constant</COMMENTS>.
                            #
                            if ( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>C</LITERALS>' ) {
                                if ( $<CODE>tok</CODE> !~ /::$/ ) {
                                    <CODE>complain</CODE>(<<<LITERALS>EOM</LITERALS>);
<LITERALS>Expecting</LITERALS> <LITERALS>operator</LITERALS> <LITERALS>after</LITERALS> '$<CODE>last_nonblank_token</CODE>' <LITERALS>but</LITERALS> <LITERALS>found</LITERALS> <LITERALS>bare</LITERALS> <LITERALS>word</LITERALS> '$<CODE>tok</CODE>'
       <LITERALS>Maybe</LITERALS> <LITERALS>indirectet</LITERALS> <LITERALS>object</LITERALS> <LITERALS>notation</LITERALS>?
<CODE>EOM</CODE>
                                }
                            }
                            else {
                                <CODE>error_if_expecting_OPERATOR</CODE>("<LITERALS>bareword</LITERALS>");
                            }
                        }

                        # <COMMENTS>mark</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>words</COMMENTS> <COMMENTS>immediately</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>as</COMMENTS>
                        # <COMMENTS>functions</COMMENTS>
                        $<CODE>next_tok</CODE> = $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ];
                        if ( $<CODE>next_tok</CODE> eq '(' ) {
                            $<CODE>type</CODE> = '<LITERALS>U</LITERALS>';
                        }

                        # <COMMENTS>underscore</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>handle</COMMENTS>
                        if ( $<CODE>tok</CODE> eq '<LITERALS>_</LITERALS>' && $<CODE>last_nonblank_type</CODE> eq '<LITERALS>F</LITERALS>' ) {
                            $<CODE>type</CODE> = '<LITERALS>Z</LITERALS>';
                        }

                        # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS> <COMMENTS>if</COMMENTS> '<COMMENTS>case</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>when</COMMENTS> <COMMENTS>are</COMMENTS>
                        # <COMMENTS>not</COMMENTS> <COMMENTS>treated</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>keywords</COMMENTS>:
                        if (
                            (
                                   $<CODE>tok</CODE> eq '<LITERALS>case</LITERALS>'
                                && $<CODE>brace_type</CODE>[$<CODE>brace_depth</CODE>] eq '<LITERALS>switch</LITERALS>'
                            )
                            || (   $<CODE>tok</CODE> eq '<LITERALS>when</LITERALS>'
                                && $<CODE>brace_type</CODE>[$<CODE>brace_depth</CODE>] eq '<LITERALS>given</LITERALS>' )
                          )
                        {
                            $<CODE>statement_type</CODE> = $<CODE>tok</CODE>;    # <COMMENTS>next</COMMENTS> '{' <COMMENTS>is</COMMENTS> <COMMENTS>block</COMMENTS>
                            $<CODE>type</CODE> = '<LITERALS>k</LITERALS>';    # <COMMENTS>for</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>coloring</COMMENTS>
                        }

                        # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>switch</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>keywords</COMMENTS>
                        # <COMMENTS>Switch</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>5</COMMENTS> <COMMENTS>keyword</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>gamble</COMMENTS>
                        # <COMMENTS>and</COMMENTS> <COMMENTS>mark</COMMENTS> <COMMENTS>switch</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>keyword</COMMENTS>.  <COMMENTS>This</COMMENTS>
                        # <COMMENTS>is</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>coloring</COMMENTS> <COMMENTS>nice</COMMENTS>,
                        # <COMMENTS>and</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>commit</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>switch</COMMENTS>/<COMMENTS>case</COMMENTS>.
                        if ( $<CODE>next_nonblank_token</CODE> eq '('
                            && ( $<CODE>tok</CODE> eq '<LITERALS>switch</LITERALS>' || $<CODE>tok</CODE> eq '<LITERALS>given</LITERALS>' ) )
                        {
                            $<CODE>type</CODE> = '<LITERALS>k</LITERALS>';    # <COMMENTS>for</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>coloring</COMMENTS>
                        }
                    }
                }
            }

            ###############################################################
            # <COMMENTS>section</COMMENTS> <COMMENTS>2</COMMENTS>: <COMMENTS>strings</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>digits</COMMENTS>
            ###############################################################
            elsif ( $<CODE>pre_type</CODE> eq '<LITERALS>d</LITERALS>' ) {
                $<CODE>expecting</CODE> = <CODE>operator_expected</CODE>( $<CODE>prev_type</CODE>, $<CODE>tok</CODE>, $<CODE>next_type</CODE> );
                <CODE>error_if_expecting_OPERATOR</CODE>("<LITERALS>Number</LITERALS>")
                  if ( $<CODE>expecting</CODE> == <CODE>OPERATOR</CODE> );
                my $<CODE>number</CODE> = <CODE>scan_number</CODE>();
                if ( !defined($<CODE>number</CODE>) ) {

                    # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS> - <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>number</COMMENTS>
                    <CODE>warning</CODE>("<LITERALS>non</LITERALS>-<LITERALS>number</LITERALS> <LITERALS>beginning</LITERALS> <LITERALS>with</LITERALS> <LITERALS>digit</LITERALS>--<LITERALS>program</LITERALS> <LITERALS>bug</LITERALS>\n");
                    <CODE>report_definite_bug</CODE>();
                }
            }

            ###############################################################
            # <COMMENTS>section</COMMENTS> <COMMENTS>3</COMMENTS>: <COMMENTS>all</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>tokens</COMMENTS>
            ###############################################################

            else {
                last if ( $<CODE>tok</CODE> eq '#' );
                my $<CODE>code</CODE> = $<CODE>tokenization_code</CODE>->{$<CODE>tok</CODE>};
                if ($<CODE>code</CODE>) {
                    $<CODE>expecting</CODE> =
                      <CODE>operator_expected</CODE>( $<CODE>prev_type</CODE>, $<CODE>tok</CODE>, $<CODE>next_type</CODE> );
                    $<CODE>code</CODE>->();
                    redo if $<CODE>in_quote</CODE>;
                }
            }
        }

        # -----------------------------
        # <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>main</COMMENTS> <COMMENTS>tokenization</COMMENTS> <COMMENTS>loop</COMMENTS>
        # -----------------------------

        if ( $<CODE>i_tok</CODE> >= 0 ) {
            $<CODE>routput_token_type</CODE>->[$<CODE>i_tok</CODE>]     = $<CODE>type</CODE>;
            $<CODE>routput_block_type</CODE>->[$<CODE>i_tok</CODE>]     = $<CODE>block_type</CODE>;
            $<CODE>routput_container_type</CODE>->[$<CODE>i_tok</CODE>] = $<CODE>container_type</CODE>;
            $<CODE>routput_type_sequence</CODE>->[$<CODE>i_tok</CODE>]  = $<CODE>type_sequence</CODE>;
            $<CODE>routput_indent_flag</CODE>->[$<CODE>i_tok</CODE>]    = $<CODE>indent_flag</CODE>;
        }

        unless ( ( $<CODE>type</CODE> eq '<LITERALS>b</LITERALS>' ) || ( $<CODE>type</CODE> eq '#' ) ) {
            $<CODE>last_last_nonblank_token</CODE>          = $<CODE>last_nonblank_token</CODE>;
            $<CODE>last_last_nonblank_type</CODE>           = $<CODE>last_nonblank_type</CODE>;
            $<CODE>last_last_nonblank_block_type</CODE>     = $<CODE>last_nonblank_block_type</CODE>;
            $<CODE>last_last_nonblank_container_type</CODE> = $<CODE>last_nonblank_container_type</CODE>;
            $<CODE>last_last_nonblank_type_sequence</CODE>  = $<CODE>last_nonblank_type_sequence</CODE>;
            $<CODE>last_nonblank_token</CODE>               = $<CODE>tok</CODE>;
            $<CODE>last_nonblank_type</CODE>                = $<CODE>type</CODE>;
            $<CODE>last_nonblank_block_type</CODE>          = $<CODE>block_type</CODE>;
            $<CODE>last_nonblank_container_type</CODE>      = $<CODE>container_type</CODE>;
            $<CODE>last_nonblank_type_sequence</CODE>       = $<CODE>type_sequence</CODE>;
            $<CODE>last_nonblank_prototype</CODE>           = $<CODE>prototype</CODE>;
        }

        # <COMMENTS>reset</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>package</COMMENTS>
        # <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>attempt</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>recover</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>error</COMMENTS>
        if ( $<CODE>level_in_tokenizer</CODE> < 0 ) {
            if ( $<CODE>input_line</CODE> =~ /^\s*(sub|package)\s+(\w+)/ ) {
                <CODE>reset_indentation_level</CODE>(0);
                <CODE>brace_warning</CODE>("<LITERALS>resetting</LITERALS> <LITERALS>level</LITERALS> <LITERALS>to</LITERALS> <LITERALS>0</LITERALS> <LITERALS>at</LITERALS> $<CODE>1</CODE> $<CODE>2</CODE>\n");
            }
        }

        # <COMMENTS>all</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>tokenizing</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> ...
        # <COMMENTS>now</COMMENTS> <COMMENTS>prepare</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>final</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>types</COMMENTS>

        my @<CODE>token_type</CODE>     = ();   # <COMMENTS>stack</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>
        my @<CODE>block_type</CODE>     = ();   # <COMMENTS>stack</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS>
        my @<CODE>container_type</CODE> = ();   # <COMMENTS>stack</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>types</COMMENTS>
        my @<CODE>type_sequence</CODE>  = ();   # <COMMENTS>stack</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>numbers</COMMENTS>
        my @<CODE>tokens</CODE>         = ();   # <COMMENTS>output</COMMENTS> <COMMENTS>tokens</COMMENTS>
        my @<CODE>levels</CODE>         = ();   # <COMMENTS>structural</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>levels</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>tokens</COMMENTS>
        my @<CODE>slevels</CODE>        = ();   # <COMMENTS>secondary</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>levels</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>output</COMMENTS> <COMMENTS>tokens</COMMENTS>
        my @<CODE>nesting_tokens</CODE> = ();   # <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>depth</COMMENTS>
        my @<CODE>nesting_types</CODE>  = ();   # <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>depth</COMMENTS>
        my @<CODE>nesting_blocks</CODE> = ();   # <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>depth</COMMENTS>
        my @<CODE>nesting_lists</CODE>  = ();   # <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>depth</COMMENTS>
        my @<CODE>ci_string</CODE> = ();  # <COMMENTS>string</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>compute</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS>
        my @<CODE>container_environment</CODE> = ();    # <COMMENTS>BLOCK</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>LIST</COMMENTS>
        my $<CODE>container_environment</CODE> = '';
        my $<CODE>im</CODE>                    = -1;    # <COMMENTS>previous</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>value</COMMENTS>
        my $<CODE>num</CODE>;
        my $<CODE>ci_string_sum</CODE> = <CODE>ones_count</CODE>($<CODE>ci_string_in_tokenizer</CODE>);

# <COMMENTS>Computing</COMMENTS> <COMMENTS>Token</COMMENTS> <COMMENTS>Indentation</COMMENTS>
#
#     <COMMENTS>The</COMMENTS> <COMMENTS>final</COMMENTS> <COMMENTS>section</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>forms</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>computes</COMMENTS>
#     <COMMENTS>parameters</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>indentation</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>much</COMMENTS> <COMMENTS>easier</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>it</COMMENTS>
#     <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>elsewhere</COMMENTS>.  <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>brief</COMMENTS> <COMMENTS>description</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>how</COMMENTS>
#     <COMMENTS>indentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>computed</COMMENTS>.  <COMMENTS>Perl</COMMENTS>::<COMMENTS>Tidy</COMMENTS> <COMMENTS>computes</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>sum</COMMENTS>
#     <COMMENTS>of</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>terms</COMMENTS>:
#
#     (<COMMENTS>1</COMMENTS>) <COMMENTS>structural</COMMENTS> <COMMENTS>indentation</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>if</COMMENTS>/<COMMENTS>else</COMMENTS>/<COMMENTS>elsif</COMMENTS> <COMMENTS>blocks</COMMENTS>
#     (<COMMENTS>2</COMMENTS>) <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>parameter</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>lists</COMMENTS>.
#
#     <COMMENTS>These</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>occasionally</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>primary</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>secondary</COMMENTS> <COMMENTS>indentation</COMMENTS>.
#
#     <COMMENTS>Structural</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>introduced</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>type</COMMENTS> '{', <COMMENTS>although</COMMENTS>
#     <COMMENTS>the</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> '{', '(', <COMMENTS>or</COMMENTS> '['.  <COMMENTS>Structural</COMMENTS> <COMMENTS>indentation</COMMENTS>
#     <COMMENTS>is</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>types</COMMENTS>: <COMMENTS>BLOCK</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>BLOCK</COMMENTS>.  <COMMENTS>Default</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>indentation</COMMENTS>
#     <COMMENTS>is</COMMENTS> <COMMENTS>4</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>scheme</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>.
#
#     <COMMENTS>Continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>introduced</COMMENTS> <COMMENTS>whenever</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>BLOCK</COMMENTS> <COMMENTS>level</COMMENTS>
#     <COMMENTS>is</COMMENTS> <COMMENTS>broken</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>termination</COMMENTS>.  <COMMENTS>Default</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS>
#     <COMMENTS>is</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>scheme</COMMENTS>.
#
#     <COMMENTS>Both</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>nested</COMMENTS> <COMMENTS>arbitrarily</COMMENTS> <COMMENTS>deep</COMMENTS> <COMMENTS>and</COMMENTS>
#     <COMMENTS>interlaced</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>distinction</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>somewhat</COMMENTS> <COMMENTS>arbitrary</COMMENTS>.
#
#     <COMMENTS>For</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>define</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>variables</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>apply</COMMENTS> <COMMENTS>if</COMMENTS>
#     <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>were</COMMENTS> <COMMENTS>broken</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS>
#     <COMMENTS>that</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>started</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>line</COMMENTS>:
#
#     <COMMENTS>$level</COMMENTS> = <COMMENTS>the</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS>,
#     <COMMENTS>$ci_level</COMMENTS> = <COMMENTS>the</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS>
#
#     <COMMENTS>The</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>$level</COMMENTS> * (<COMMENTS>4</COMMENTS> <COMMENTS>spaces</COMMENTS>) + <COMMENTS>$ci_level</COMMENTS> * (<COMMENTS>2</COMMENTS> <COMMENTS>spaces</COMMENTS>),
#     <COMMENTS>assuming</COMMENTS> <COMMENTS>defaults</COMMENTS>.  <COMMENTS>However</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>cases</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>customary</COMMENTS>
#     <COMMENTS>to</COMMENTS> <COMMENTS>modify</COMMENTS> <COMMENTS>$ci_level</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>strict</COMMENTS> <COMMENTS>value</COMMENTS>.
#
#     <COMMENTS>The</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>easy</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>compute</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>adding</COMMENTS> <COMMENTS>and</COMMENTS>
#     <COMMENTS>subtracting</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>saved</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>types</COMMENTS> '{' <COMMENTS>and</COMMENTS> '}' <COMMENTS>are</COMMENTS> <COMMENTS>seen</COMMENTS>.  <COMMENTS>The</COMMENTS>
#     <COMMENTS>running</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>variable</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>$level_in_tokenizer</COMMENTS>.
#
#     <COMMENTS>The</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>much</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>difficult</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>compute</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>requires</COMMENTS>
#     <COMMENTS>several</COMMENTS> <COMMENTS>variables</COMMENTS>.  <COMMENTS>These</COMMENTS> <COMMENTS>variables</COMMENTS> <COMMENTS>are</COMMENTS>:
#
#     <COMMENTS>$ci_string_in_tokenizer</COMMENTS> = <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>1</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>0</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>indicating</COMMENTS>, <COMMENTS>for</COMMENTS>
#       <COMMENTS>each</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>intervening</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>secondary</COMMENTS>
#       <COMMENTS>structures</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>prior</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>level</COMMENTS>.
#     <COMMENTS>$continuation_string_in_tokenizer</COMMENTS> = <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>1</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>0</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>indicating</COMMENTS>
#       <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>is</COMMENTS> "<COMMENTS>continued</COMMENTS>", <COMMENTS>meaning</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>it</COMMENTS>
#       <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>expression</COMMENTS>.
#     <COMMENTS>$nesting_block_string</COMMENTS> = <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>1</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>0</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>indicating</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS>
#       <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>BLOCK</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>not</COMMENTS>.
#     <COMMENTS>$nesting_block_flag</COMMENTS> = <COMMENTS>the</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>recent</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>0</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>$nesting_block_string</COMMENTS>
#     <COMMENTS>$nesting_list_string</COMMENTS> = <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>1</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>0</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>indicating</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS>
#       <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>appropriate</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>formatting</COMMENTS>.
#       <COMMENTS>If</COMMENTS> <COMMENTS>so</COMMENTS>, <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>indent</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>items</COMMENTS>.
#     <COMMENTS>$nesting_list_flag</COMMENTS> = <COMMENTS>the</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>recent</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>0</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>$nesting_list_string</COMMENTS>
#     @{<COMMENTS>$rslevel_stack</COMMENTS>} = <COMMENTS>a</COMMENTS> <COMMENTS>stack</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depths</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>each</COMMENTS>
#       <COMMENTS>structural</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>level</COMMENTS>, <COMMENTS>where</COMMENTS> "<COMMENTS>total</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depth</COMMENTS>" <COMMENTS>means</COMMENTS>
#       <COMMENTS>the</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>occur</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>every</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>token</COMMENTS> -- '{', '[',
#       <COMMENTS>and</COMMENTS> '(' -- , <COMMENTS>regardless</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>context</COMMENTS>, <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>compute</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>nesting</COMMENTS>
#       <COMMENTS>depth</COMMENTS>.

        #<COMMENTS>my</COMMENTS> <COMMENTS>$nesting_block_flag</COMMENTS> = (<COMMENTS>$nesting_block_string</COMMENTS> =~ /<COMMENTS>1$</COMMENTS>/);
        #<COMMENTS>my</COMMENTS> <COMMENTS>$nesting_list_flag</COMMENTS> = (<COMMENTS>$nesting_list_string</COMMENTS> =~ /<COMMENTS>1$</COMMENTS>/);

        my ( $<CODE>ci_string_i</CODE>, $<CODE>level_i</CODE>, $<CODE>nesting_block_string_i</CODE>,
            $<CODE>nesting_list_string_i</CODE>, $<CODE>nesting_token_string_i</CODE>,
            $<CODE>nesting_type_string_i</CODE>, );

        foreach $<CODE>i</CODE> ( @{$<CODE>routput_token_list</CODE>} )
        {    # <COMMENTS>scan</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>tokens</COMMENTS> <COMMENTS>indexes</COMMENTS>

            # <COMMENTS>self</COMMENTS>-<COMMENTS>checking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>
            my $<CODE>type</CODE>                    = $<CODE>routput_token_type</CODE>->[$<CODE>i</CODE>];
            my $<CODE>forced_indentation_flag</CODE> = $<CODE>routput_indent_flag</CODE>->[$<CODE>i</CODE>];

            # <COMMENTS>See</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>undo</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>$forced_indentation_flag</COMMENTS>.
            # <COMMENTS>Forced</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>after</COMMENTS> '<COMMENTS>if</COMMENTS>', '<COMMENTS>unless</COMMENTS>', '<COMMENTS>while</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>until</COMMENTS>'
            # <COMMENTS>expressions</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>optional</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS>
            # <COMMENTS>always</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>good</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>okay</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>logical</COMMENTS>
            # <COMMENTS>expression</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>expression</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>call</COMMENTS>, <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>,
            # <COMMENTS>or</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>kind</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>puts</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>unwanted</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>indentation</COMMENTS>
            # <COMMENTS>level</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>hard</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>remove</COMMENTS>.
            #
            # <COMMENTS>Example</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>ok</COMMENTS>:
            # <COMMENTS>return</COMMENTS> <COMMENTS>1</COMMENTS>
            #   <COMMENTS>if</COMMENTS> <COMMENTS>$det_a</COMMENTS> < <COMMENTS>0</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>$det_b</COMMENTS> > <COMMENTS>0</COMMENTS>
            #       <COMMENTS>or</COMMENTS> <COMMENTS>$det_a</COMMENTS> > <COMMENTS>0</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>$det_b</COMMENTS> < <COMMENTS>0</COMMENTS>;
            #
            # <COMMENTS>Example</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>because</COMMENTS>
            # <COMMENTS>the</COMMENTS> <COMMENTS>eval</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>provides</COMMENTS> <COMMENTS>indentation</COMMENTS>:
            # <COMMENTS>print</COMMENTS> "<COMMENTS>not</COMMENTS> " <COMMENTS>if</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>eval</COMMENTS> {
            #     <COMMENTS>reduce</COMMENTS> { <COMMENTS>die</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>$b</COMMENTS> > <COMMENTS>2</COMMENTS>; <COMMENTS>$a</COMMENTS> + <COMMENTS>$b</COMMENTS> } <COMMENTS>0</COMMENTS>, <COMMENTS>1</COMMENTS>, <COMMENTS>2</COMMENTS>, <COMMENTS>3</COMMENTS>, <COMMENTS>4</COMMENTS>;
            # };
            #
            # <COMMENTS>The</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>rule</COMMENTS> <COMMENTS>works</COMMENTS> <COMMENTS>fairly</COMMENTS> <COMMENTS>well</COMMENTS>:
            #   <COMMENTS>Undo</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS>
            #   <COMMENTS>line</COMMENTS>, <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS>.
            # <COMMENTS>This</COMMENTS> <COMMENTS>almost</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>works</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>pass</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>will</COMMENTS>
            # <COMMENTS>be</COMMENTS> <COMMENTS>stable</COMMENTS>.
            if ( $<CODE>forced_indentation_flag</CODE> && $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>' ) {
                my $<CODE>ixlast</CODE>  = -1;
                my $<CODE>ilast</CODE>   = $<CODE>routput_token_list</CODE>->[$<CODE>ixlast</CODE>];
                my $<CODE>toklast</CODE> = $<CODE>routput_token_type</CODE>->[$<CODE>ilast</CODE>];
                if ( $<CODE>toklast</CODE> eq '#' ) {
                    $<CODE>ixlast</CODE>--;
                    $<CODE>ilast</CODE>   = $<CODE>routput_token_list</CODE>->[$<CODE>ixlast</CODE>];
                    $<CODE>toklast</CODE> = $<CODE>routput_token_type</CODE>->[$<CODE>ilast</CODE>];
                }
                if ( $<CODE>toklast</CODE> eq '<LITERALS>b</LITERALS>' ) {
                    $<CODE>ixlast</CODE>--;
                    $<CODE>ilast</CODE>   = $<CODE>routput_token_list</CODE>->[$<CODE>ixlast</CODE>];
                    $<CODE>toklast</CODE> = $<CODE>routput_token_type</CODE>->[$<CODE>ilast</CODE>];
                }
                if ( $<CODE>toklast</CODE> =~ /^[\{,]$/ ) {
                    $<CODE>forced_indentation_flag</CODE> = 0;
                }
                else {
                    ( $<CODE>toklast</CODE>, my $<CODE>i_next</CODE> ) =
                      <CODE>find_next_nonblank_token</CODE>( $<CODE>max_token_index</CODE>, $<CODE>rtokens</CODE>,
                        $<CODE>max_token_index</CODE> );
                    if ( $<CODE>toklast</CODE> =~ /^[\{,]$/ ) {
                        $<CODE>forced_indentation_flag</CODE> = 0;
                    }
                }
            }

            # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>indented</COMMENTS> <COMMENTS>if</COMMENTS>, <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>outdent</COMMENTS>
            if ($<CODE>indented_if_level</CODE>) {

                # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>nest</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>if</COMMENTS>'<COMMENTS>s</COMMENTS> - <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>
                if ( $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>' ) {
                    $<CODE>forced_indentation_flag</CODE> = 0;
                }

                # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>normal</COMMENTS> <COMMENTS>case</COMMENTS> - <COMMENTS>outdenting</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>next</COMMENTS> ';'
                elsif ( $<CODE>type</CODE> eq ';' ) {
                    if ( $<CODE>level_in_tokenizer</CODE> == $<CODE>indented_if_level</CODE> ) {
                        $<CODE>forced_indentation_flag</CODE> = -1;
                        $<CODE>indented_if_level</CODE>       = 0;
                    }
                }

                # <COMMENTS>handle</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>missing</COMMENTS> <COMMENTS>semicolon</COMMENTS>
                elsif ( $<CODE>type</CODE> eq '}' ) {
                    if ( $<CODE>level_in_tokenizer</CODE> == $<CODE>indented_if_level</CODE> ) {
                        $<CODE>indented_if_level</CODE> = 0;

                        # <COMMENTS>TBD</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>subroutine</COMMENTS> <COMMENTS>call</COMMENTS>
                        $<CODE>level_in_tokenizer</CODE>--;
                        if ( @{$<CODE>rslevel_stack</CODE>} > 1 ) {
                            pop( @{$<CODE>rslevel_stack</CODE>} );
                        }
                        if ( length($<CODE>nesting_block_string</CODE>) > 1 )
                        {    # <COMMENTS>true</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>script</COMMENTS>
                            chop $<CODE>nesting_block_string</CODE>;
                            chop $<CODE>nesting_list_string</CODE>;
                        }

                    }
                }
            }

            my $<CODE>tok</CODE> = $$<CODE>rtokens</CODE>[$<CODE>i</CODE>];   # <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>ONLY</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>pretoken</COMMENTS>
            $<CODE>level_i</CODE> = $<CODE>level_in_tokenizer</CODE>;

            # <COMMENTS>This</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>running</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>scripts</COMMENTS>
            # <COMMENTS>although</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>bug</COMMENTS> <COMMENTS>introduced</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>programming</COMMENTS> <COMMENTS>change</COMMENTS>.
            # <COMMENTS>Perl</COMMENTS> <COMMENTS>silently</COMMENTS> <COMMENTS>accepts</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>032</COMMENTS> (^<COMMENTS>Z</COMMENTS>) <COMMENTS>and</COMMENTS> <COMMENTS>takes</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS>
            if ( !$<CODE>is_valid_token_type</CODE>{$<CODE>type</CODE>} ) {
                my $<CODE>val</CODE> = ord($<CODE>type</CODE>);
                <CODE>warning</CODE>(
                    "<LITERALS>unexpected</LITERALS> <LITERALS>character</LITERALS> <LITERALS>decimal</LITERALS> $<CODE>val</CODE> ($<CODE>type</CODE>) <LITERALS>in</LITERALS> <LITERALS>script</LITERALS>\n");
                $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_error</LITERALS>} = 1;
            }

            # ----------------------------------------------------------------
            # <COMMENTS>TOKEN</COMMENTS> <COMMENTS>TYPE</COMMENTS> <COMMENTS>PATCHES</COMMENTS>
            #  <COMMENTS>output</COMMENTS> <COMMENTS>__END__</COMMENTS>, <COMMENTS>__DATA__</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>format</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>k</COMMENTS>' <COMMENTS>instead</COMMENTS> <COMMENTS>of</COMMENTS> ';'
            # <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>html</COMMENTS> <COMMENTS>colors</COMMENTS> <COMMENTS>correct</COMMENTS>, <COMMENTS>etc</COMMENTS>.
            my $<CODE>fix_type</CODE> = $<CODE>type</CODE>;
            if ( $<CODE>type</CODE> eq ';' && $<CODE>tok</CODE> =~ /\w/ ) { $<CODE>fix_type</CODE> = '<LITERALS>k</LITERALS>' }

            # <COMMENTS>output</COMMENTS> <COMMENTS>anonymous</COMMENTS> '<COMMENTS>sub</COMMENTS>' <COMMENTS>as</COMMENTS> <COMMENTS>keyword</COMMENTS>
            if ( $<CODE>type</CODE> eq '<LITERALS>t</LITERALS>' && $<CODE>tok</CODE> eq '<LITERALS>sub</LITERALS>' ) { $<CODE>fix_type</CODE> = '<LITERALS>k</LITERALS>' }

            # -----------------------------------------------------------------

            $<CODE>nesting_token_string_i</CODE> = $<CODE>nesting_token_string</CODE>;
            $<CODE>nesting_type_string_i</CODE>  = $<CODE>nesting_type_string</CODE>;
            $<CODE>nesting_block_string_i</CODE> = $<CODE>nesting_block_string</CODE>;
            $<CODE>nesting_list_string_i</CODE>  = $<CODE>nesting_list_string</CODE>;

            # <COMMENTS>set</COMMENTS> <COMMENTS>primary</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>levels</COMMENTS> <COMMENTS>based</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>braces</COMMENTS>
            # <COMMENTS>Note</COMMENTS>: <COMMENTS>these</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>HIGHER</COMMENTS>
            # <COMMENTS>level</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>CONTENTS</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>convenient</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>indentation</COMMENTS>
            # <COMMENTS>Also</COMMENTS>, <COMMENTS>define</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>token</COMMENTS>.
            if ( $<CODE>type</CODE> eq '{' || $<CODE>type</CODE> eq '<LITERALS>L</LITERALS>' || $<CODE>forced_indentation_flag</CODE> > 0 )
            {

                # <COMMENTS>use</COMMENTS> <COMMENTS>environment</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>updating</COMMENTS>
                $<CODE>container_environment</CODE> =
                    $<CODE>nesting_block_flag</CODE> ? '<LITERALS>BLOCK</LITERALS>'
                  : $<CODE>nesting_list_flag</CODE>  ? '<LITERALS>LIST</LITERALS>'
                  :                       "";

                # <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>difference</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>total</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>levels</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>1</COMMENTS>,
                # <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>intervening</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>between</COMMENTS>
                # <COMMENTS>this</COMMENTS> '{' <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>unclosed</COMMENTS> '{'
                my $<CODE>intervening_secondary_structure</CODE> = 0;
                if ( @{$<CODE>rslevel_stack</CODE>} ) {
                    $<CODE>intervening_secondary_structure</CODE> =
                      $<CODE>slevel_in_tokenizer</CODE> - $<CODE>rslevel_stack</CODE>->[-1];
                }

     # <COMMENTS>Continuation</COMMENTS> <COMMENTS>Indentation</COMMENTS>
     #
     # <COMMENTS>Having</COMMENTS> <COMMENTS>tried</COMMENTS> <COMMENTS>setting</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>both</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>formatter</COMMENTS> <COMMENTS>and</COMMENTS>
     # <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS>, <COMMENTS>I</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>say</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>setting</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>much</COMMENTS>,
     # <COMMENTS>much</COMMENTS> <COMMENTS>easier</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>formatter</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>much</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS>
     # <COMMENTS>make</COMMENTS> <COMMENTS>decisions</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>knowing</COMMENTS> <COMMENTS>what</COMMENTS> '<COMMENTS>ci</COMMENTS>' <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>at</COMMENTS>
     # <COMMENTS>arbitrary</COMMENTS> <COMMENTS>locations</COMMENTS>.
     #
     # <COMMENTS>But</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>setting</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> (<COMMENTS>ci</COMMENTS>) <COMMENTS>here</COMMENTS>
     # <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>breaks</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>actually</COMMENTS>
     # <COMMENTS>be</COMMENTS>.  <COMMENTS>As</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>result</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>propagate</COMMENTS> <COMMENTS>continuation</COMMENTS>
     # <COMMENTS>indentation</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>higher</COMMENTS> <COMMENTS>levels</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>structure</COMMENTS>.
     #
     # <COMMENTS>For</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>indentation</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>never</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS>.
     # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>long</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>statement</COMMENTS>, <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>
     #
     #   <COMMENTS>if</COMMENTS> ( !<COMMENTS>$output_block_type</COMMENTS>[<COMMENTS>$i</COMMENTS>]
     #     && (<COMMENTS>$in_statement_continuation</COMMENTS>) )
     #   {           <--<COMMENTS>outdented</COMMENTS>
     #       <COMMENTS>do_something</COMMENTS>();
     #   }
     #
     # <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>ci</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>normally</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>BLOCK</COMMENTS>
     # <COMMENTS>any</COMMENTS> <COMMENTS>ci</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>true</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>had</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>nested</COMMENTS> <COMMENTS>arbitrarily</COMMENTS> <COMMENTS>deeply</COMMENTS>.
     #
     # <COMMENTS>But</COMMENTS> <COMMENTS>consider</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>, <COMMENTS>where</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>created</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>after</COMMENTS>
     # <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>1</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> (<COMMENTS>currently</COMMENTS>) <COMMENTS>a</COMMENTS>
     # <COMMENTS>structural</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>token</COMMENTS>:
     #
     # <COMMENTS>my</COMMENTS> <COMMENTS>$file</COMMENTS> = <COMMENTS>$menubar</COMMENTS>-><COMMENTS>Menubutton</COMMENTS>(
     #   <COMMENTS>qw</COMMENTS>/-<COMMENTS>text</COMMENTS> <COMMENTS>File</COMMENTS> -<COMMENTS>underline</COMMENTS> <COMMENTS>0</COMMENTS> -<COMMENTS>menuitems</COMMENTS>/ => [
     #       [
     #           <COMMENTS>Cascade</COMMENTS>    => '~<COMMENTS>View</COMMENTS>',
     #           -<COMMENTS>menuitems</COMMENTS> => [
     #           ...
     #
     # <COMMENTS>The</COMMENTS> <COMMENTS>second</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>ci</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>seem</COMMENTS> <COMMENTS>reasonable</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>propagate</COMMENTS> <COMMENTS>it</COMMENTS>
     # <COMMENTS>down</COMMENTS>, <COMMENTS>giving</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>third</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>ci</COMMENTS> + <COMMENTS>1</COMMENTS> <COMMENTS>indentation</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>suggests</COMMENTS> <COMMENTS>the</COMMENTS>
     # <COMMENTS>following</COMMENTS> <COMMENTS>rule</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>currently</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>propagating</COMMENTS> <COMMENTS>ci</COMMENTS> <COMMENTS>down</COMMENTS>: <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS>
     # <COMMENTS>are</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>parens</COMMENTS> (<COMMENTS>or</COMMENTS> <COMMENTS>brackets</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>braces</COMMENTS>), <COMMENTS>before</COMMENTS>
     # <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>brace</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>ci</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>propagated</COMMENTS> <COMMENTS>down</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>otherwise</COMMENTS>
     # <COMMENTS>not</COMMENTS>.  <COMMENTS>The</COMMENTS> <COMMENTS>variable</COMMENTS> <COMMENTS>$intervening_secondary_structure</COMMENTS> <COMMENTS>contains</COMMENTS> <COMMENTS>this</COMMENTS>
     # <COMMENTS>information</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>string</COMMENTS>
     # "<COMMENTS>$ci_string_in_tokenizer</COMMENTS>" <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>stack</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS>
     # <COMMENTS>variable</COMMENTS>.

                # <COMMENTS>save</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>states</COMMENTS>
                push( @{$<CODE>rslevel_stack</CODE>}, 1 + $<CODE>slevel_in_tokenizer</CODE> );
                $<CODE>level_in_tokenizer</CODE>++;

                if ($<CODE>forced_indentation_flag</CODE>) {

                    # <COMMENTS>break</COMMENTS> <COMMENTS>BEFORE</COMMENTS> '?' <COMMENTS>when</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>forced</COMMENTS> <COMMENTS>indentation</COMMENTS>
                    if ( $<CODE>type</CODE> eq '?' ) { $<CODE>level_i</CODE> = $<CODE>level_in_tokenizer</CODE>; }
                    if ( $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>' ) {
                        $<CODE>indented_if_level</CODE> = $<CODE>level_in_tokenizer</CODE>;
                    }

                    # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>environment</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS>
                    # <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>real</COMMENTS> <COMMENTS>list</COMMENTS>. <COMMENTS>Adding</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>prevents</COMMENTS> "<COMMENTS>blinkers</COMMENTS>"
                    # <COMMENTS>often</COMMENTS> <COMMENTS>near</COMMENTS> '<COMMENTS>unless</COMMENTS>" <COMMENTS>clauses</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>
                    # <COMMENTS>code</COMMENTS>:
##          <COMMENTS>next</COMMENTS>
##            <COMMENTS>unless</COMMENTS> -<COMMENTS>e</COMMENTS> (
##                    <COMMENTS>$archive</COMMENTS> =
##                      <COMMENTS>File</COMMENTS>::<COMMENTS>Spec</COMMENTS>-><COMMENTS>catdir</COMMENTS>( <COMMENTS>$_</COMMENTS>, "<COMMENTS>auto</COMMENTS>", <COMMENTS>$root</COMMENTS>, "<COMMENTS>$sub$lib_ext</COMMENTS>" )
##            );

                    $<CODE>nesting_block_string</CODE> .= "$<CODE>nesting_block_flag</CODE>";
                }
                else {

                    if ( $<CODE>routput_block_type</CODE>->[$<CODE>i</CODE>] ) {
                        $<CODE>nesting_block_flag</CODE> = 1;
                        $<CODE>nesting_block_string</CODE> .= '<LITERALS>1</LITERALS>';
                    }
                    else {
                        $<CODE>nesting_block_flag</CODE> = 0;
                        $<CODE>nesting_block_string</CODE> .= '<LITERALS>0</LITERALS>';
                    }
                }

                # <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>containers</COMMENTS>
                # <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>expressions</COMMENTS>
                my $<CODE>bit</CODE> = 0;
                if ( !$<CODE>routput_block_type</CODE>->[$<CODE>i</CODE>] ) {

                    # <COMMENTS>propagate</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>down</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>nested</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>parens</COMMENTS>
                    if ( $<CODE>routput_container_type</CODE>->[$<CODE>i</CODE>] eq '(' ) {
                        $<CODE>bit</CODE> = 1 if $<CODE>nesting_list_flag</CODE>;
                    }

                  # <COMMENTS>use</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>logical</COMMENTS> <COMMENTS>grouping</COMMENTS>
                  # /^(<COMMENTS>if</COMMENTS>|<COMMENTS>elsif</COMMENTS>|<COMMENTS>unless</COMMENTS>|<COMMENTS>while</COMMENTS>|<COMMENTS>and</COMMENTS>|<COMMENTS>or</COMMENTS>|<COMMENTS>not</COMMENTS>|&&|!|\|\||<COMMENTS>for</COMMENTS>|<COMMENTS>foreach</COMMENTS>)<COMMENTS>$</COMMENTS>/
                    else {
                        $<CODE>bit</CODE> = 1
                          unless
                          $<CODE>is_logical_container</CODE>{ $<CODE>routput_container_type</CODE>->[$<CODE>i</CODE>]
                          };
                    }
                }
                $<CODE>nesting_list_string</CODE> .= $<CODE>bit</CODE>;
                $<CODE>nesting_list_flag</CODE> = $<CODE>bit</CODE>;

                $<CODE>ci_string_in_tokenizer</CODE> .=
                  ( $<CODE>intervening_secondary_structure</CODE> != 0 ) ? '<LITERALS>1</LITERALS>' : '<LITERALS>0</LITERALS>';
                $<CODE>ci_string_sum</CODE> = <CODE>ones_count</CODE>($<CODE>ci_string_in_tokenizer</CODE>);
                $<CODE>continuation_string_in_tokenizer</CODE> .=
                  ( $<CODE>in_statement_continuation</CODE> > 0 ) ? '<LITERALS>1</LITERALS>' : '<LITERALS>0</LITERALS>';

   #  <COMMENTS>Sometimes</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS>,
   #  <COMMENTS>and</COMMENTS> <COMMENTS>sometimes</COMMENTS> <COMMENTS>not</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>blocks</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>it</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS>
   #  '{' <COMMENTS>gets</COMMENTS> <COMMENTS>outdented</COMMENTS>, <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS>:
   #
   #   <COMMENTS>if</COMMENTS> ( !<COMMENTS>$output_block_type</COMMENTS>[<COMMENTS>$i</COMMENTS>]
   #     && (<COMMENTS>$in_statement_continuation</COMMENTS>) )
   #   {           <--<COMMENTS>outdented</COMMENTS>
   #
   #  <COMMENTS>For</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>types</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>,
   #  <COMMENTS>here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>indented</COMMENTS>:
   #
   #     @<COMMENTS>LoL</COMMENTS> =
   #       ( [ "<COMMENTS>fred</COMMENTS>", "<COMMENTS>barney</COMMENTS>" ], [ "<COMMENTS>george</COMMENTS>", "<COMMENTS>jane</COMMENTS>", "<COMMENTS>elroy</COMMENTS>" ],
   #         [ "<COMMENTS>homer</COMMENTS>", "<COMMENTS>marge</COMMENTS>", "<COMMENTS>bart</COMMENTS>" ], );
   #
   #  <COMMENTS>This</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>best</COMMENTS> <COMMENTS>when</COMMENTS> '<COMMENTS>ci</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>one</COMMENTS>-<COMMENTS>half</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS>  (<COMMENTS>i</COMMENTS>.<COMMENTS>e</COMMENTS>., <COMMENTS>2</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>4</COMMENTS>)

                my $<CODE>total_ci</CODE> = $<CODE>ci_string_sum</CODE>;
                if (
                    !$<CODE>routput_block_type</CODE>->[$<CODE>i</CODE>]    # <COMMENTS>patch</COMMENTS>: <COMMENTS>skip</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>BLOCK</COMMENTS>
                    && ($<CODE>in_statement_continuation</CODE>)
                    && !( $<CODE>forced_indentation_flag</CODE> && $<CODE>type</CODE> eq ':' )
                  )
                {
                    $<CODE>total_ci</CODE> += $<CODE>in_statement_continuation</CODE>
                      unless ( $<CODE>ci_string_in_tokenizer</CODE> =~ /1$/ );
                }

                $<CODE>ci_string_i</CODE>               = $<CODE>total_ci</CODE>;
                $<CODE>in_statement_continuation</CODE> = 0;
            }

            elsif ($<CODE>type</CODE> eq '}'
                || $<CODE>type</CODE> eq '<LITERALS>R</LITERALS>'
                || $<CODE>forced_indentation_flag</CODE> < 0 )
            {

                # <COMMENTS>only</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>script</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>prevent</COMMENTS> <COMMENTS>popping</COMMENTS> <COMMENTS>here</COMMENTS>
                if ( @{$<CODE>rslevel_stack</CODE>} > 1 ) { pop( @{$<CODE>rslevel_stack</CODE>} ); }

                $<CODE>level_i</CODE> = --$<CODE>level_in_tokenizer</CODE>;

                # <COMMENTS>restore</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>values</COMMENTS>
                if ( length($<CODE>nesting_block_string</CODE>) > 1 )
                {    # <COMMENTS>true</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>script</COMMENTS>
                    chop $<CODE>nesting_block_string</CODE>;
                    $<CODE>nesting_block_flag</CODE> = ( $<CODE>nesting_block_string</CODE> =~ /1$/ );
                    chop $<CODE>nesting_list_string</CODE>;
                    $<CODE>nesting_list_flag</CODE> = ( $<CODE>nesting_list_string</CODE> =~ /1$/ );

                    chop $<CODE>ci_string_in_tokenizer</CODE>;
                    $<CODE>ci_string_sum</CODE> = <CODE>ones_count</CODE>($<CODE>ci_string_in_tokenizer</CODE>);

                    $<CODE>in_statement_continuation</CODE> =
                      chop $<CODE>continuation_string_in_tokenizer</CODE>;

                    # <COMMENTS>zero</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>BLOCK</COMMENTS> '}' <COMMENTS>which</COMMENTS>
                    # <COMMENTS>ends</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>statement</COMMENTS>.
                    if ( $<CODE>routput_block_type</CODE>->[$<CODE>i</CODE>] ) {

                        # ...<COMMENTS>These</COMMENTS> <COMMENTS>include</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>anonymous</COMMENTS> <COMMENTS>subs</COMMENTS>
                        # <COMMENTS>note</COMMENTS>: <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sub</COMMENTS> ::<COMMENTS>abc</COMMENTS> { <COMMENTS>or</COMMENTS> <COMMENTS>sub</COMMENTS> '<COMMENTS>abc</COMMENTS>
                        if ( $<CODE>routput_block_type</CODE>->[$<CODE>i</CODE>] =~ m/^sub\s*/gc ) {

                         # <COMMENTS>note</COMMENTS>: <COMMENTS>older</COMMENTS> <COMMENTS>versions</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>require</COMMENTS> <COMMENTS>the</COMMENTS> /<COMMENTS>gc</COMMENTS> <COMMENTS>modifier</COMMENTS>
                         # <COMMENTS>here</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>the</COMMENTS> \<COMMENTS>G</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>work</COMMENTS>.
                            if ( $<CODE>routput_block_type</CODE>->[$<CODE>i</CODE>] =~ /\G('|::|\w)/gc )
                            {
                                $<CODE>in_statement_continuation</CODE> = 0;
                            }
                        }

# ...<COMMENTS>and</COMMENTS> <COMMENTS>include</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>subs</COMMENTS> <COMMENTS>with</COMMENTS>
# <COMMENTS>block</COMMENTS> <COMMENTS>prototypes</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>these</COMMENTS>: (<COMMENTS>sort</COMMENTS>|<COMMENTS>grep</COMMENTS>|<COMMENTS>map</COMMENTS>|<COMMENTS>do</COMMENTS>|<COMMENTS>eval</COMMENTS>)
# /^(\}|\{|<COMMENTS>BEGIN</COMMENTS>|<COMMENTS>END</COMMENTS>|<COMMENTS>CHECK</COMMENTS>|<COMMENTS>INIT</COMMENTS>|<COMMENTS>AUTOLOAD</COMMENTS>|<COMMENTS>DESTROY</COMMENTS>|<COMMENTS>UNITCHECK</COMMENTS>|<COMMENTS>continue</COMMENTS>|;|<COMMENTS>if</COMMENTS>|<COMMENTS>elsif</COMMENTS>|<COMMENTS>else</COMMENTS>|<COMMENTS>unless</COMMENTS>|<COMMENTS>while</COMMENTS>|<COMMENTS>until</COMMENTS>|<COMMENTS>for</COMMENTS>|<COMMENTS>foreach</COMMENTS>)<COMMENTS>$</COMMENTS>/
                        elsif (
                            $<CODE>is_zero_continuation_block_type</CODE>{
                                $<CODE>routput_block_type</CODE>->[$<CODE>i</CODE>]
                            } )
                        {
                            $<CODE>in_statement_continuation</CODE> = 0;
                        }

                        # ..<COMMENTS>but</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>terminal</COMMENTS> <COMMENTS>types</COMMENTS>:
                        #     /^(<COMMENTS>sort</COMMENTS>|<COMMENTS>grep</COMMENTS>|<COMMENTS>map</COMMENTS>|<COMMENTS>do</COMMENTS>|<COMMENTS>eval</COMMENTS>)<COMMENTS>$</COMMENTS>/ )
                        elsif (
                            $<CODE>is_not_zero_continuation_block_type</CODE>{
                                $<CODE>routput_block_type</CODE>->[$<CODE>i</CODE>]
                            } )
                        {
                        }

                        # ..<COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>introduced</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>label</COMMENTS>
                        # /^\<COMMENTS>w</COMMENTS>+\<COMMENTS>s</COMMENTS>*:<COMMENTS>$</COMMENTS>/<COMMENTS>gc</COMMENTS> ) {
                        elsif ( $<CODE>routput_block_type</CODE>->[$<CODE>i</CODE>] =~ /:$/ ) {
                            $<CODE>in_statement_continuation</CODE> = 0;
                        }

                        # <COMMENTS>user</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>prototype</COMMENTS>
                        else {
                            $<CODE>in_statement_continuation</CODE> = 0;
                        }
                    }

                    # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS>, <COMMENTS>then</COMMENTS>
                    # <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS>
                    # <COMMENTS>paren</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>this</COMMENTS> (<COMMENTS>paren</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>$check</COMMENTS>):
                    #     <COMMENTS>assert</COMMENTS>(
                    #         <COMMENTS>__LINE__</COMMENTS>,
                    #         ( <COMMENTS>not</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>$check</COMMENTS> )
                    #           <COMMENTS>or</COMMENTS> <COMMENTS>ref</COMMENTS> <COMMENTS>$check</COMMENTS>
                    #           <COMMENTS>or</COMMENTS> <COMMENTS>$check</COMMENTS> <COMMENTS>eq</COMMENTS> "<COMMENTS>new</COMMENTS>"
                    #           <COMMENTS>or</COMMENTS> <COMMENTS>$check</COMMENTS> <COMMENTS>eq</COMMENTS> "<COMMENTS>old</COMMENTS>",
                    #     );
                    elsif ( $<CODE>tok</CODE> eq ')' ) {
                        $<CODE>in_statement_continuation</CODE> = 1
                          if $<CODE>routput_container_type</CODE>->[$<CODE>i</CODE>] =~ /^[;,\{\}]$/;
                    }

                    elsif ( $<CODE>tok</CODE> eq ';' ) { $<CODE>in_statement_continuation</CODE> = 0 }
                }

                # <COMMENTS>use</COMMENTS> <COMMENTS>environment</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>updating</COMMENTS>
                $<CODE>container_environment</CODE> =
                    $<CODE>nesting_block_flag</CODE> ? '<LITERALS>BLOCK</LITERALS>'
                  : $<CODE>nesting_list_flag</CODE>  ? '<LITERALS>LIST</LITERALS>'
                  :                       "";
                $<CODE>ci_string_i</CODE> = $<CODE>ci_string_sum</CODE> + $<CODE>in_statement_continuation</CODE>;
                $<CODE>nesting_block_string_i</CODE> = $<CODE>nesting_block_string</CODE>;
                $<CODE>nesting_list_string_i</CODE>  = $<CODE>nesting_list_string</CODE>;
            }

            # <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>type</COMMENTS>..
            else {

                $<CODE>container_environment</CODE> =
                    $<CODE>nesting_block_flag</CODE> ? '<LITERALS>BLOCK</LITERALS>'
                  : $<CODE>nesting_list_flag</CODE>  ? '<LITERALS>LIST</LITERALS>'
                  :                       "";

                # <COMMENTS>zero</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>so</COMMENTS>
                # <COMMENTS>that</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>level</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>container</COMMENTS>.  <COMMENTS>For</COMMENTS>
                # <COMMENTS>commas</COMMENTS>, <COMMENTS>this</COMMENTS> <COMMENTS>simplifies</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>lp</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>logic</COMMENTS>, <COMMENTS>which</COMMENTS>
                # <COMMENTS>counts</COMMENTS> <COMMENTS>commas</COMMENTS>.  <COMMENTS>For</COMMENTS> ?: <COMMENTS>it</COMMENTS> <COMMENTS>makes</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>stand</COMMENTS> <COMMENTS>out</COMMENTS>.
                if ($<CODE>nesting_list_flag</CODE>) {
                    if ( $<CODE>type</CODE> =~ /^[,\?\:]$/ ) {
                        $<CODE>in_statement_continuation</CODE> = 0;
                    }
                }

                # <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>binary</COMMENTS> <COMMENTS>operators</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS>
                if (
                    $<CODE>container_environment</CODE>
                    && (   $<CODE>type</CODE> eq '<LITERALS>k</LITERALS>' && $<CODE>is_binary_keyword</CODE>{$<CODE>tok</CODE>}
                        || $<CODE>is_binary_type</CODE>{$<CODE>type</CODE>} )
                  )
                {
                    $<CODE>in_statement_continuation</CODE> = 1;
                }

                # <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>sum</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>ci</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>previous</COMMENTS>
                # <COMMENTS>levels</COMMENTS> <COMMENTS>plus</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>level</COMMENTS>
                $<CODE>ci_string_i</CODE> = $<CODE>ci_string_sum</CODE> + $<CODE>in_statement_continuation</CODE>;

                # <COMMENTS>update</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>flag</COMMENTS> ...
                # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>isn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>comment</COMMENTS>..
                if ( $<CODE>type</CODE> ne '<LITERALS>b</LITERALS>' && $<CODE>type</CODE> ne '#' ) {

                    # <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>BLOCK</COMMENTS>
                    if ($<CODE>nesting_block_flag</CODE>) {

                        # <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> ';' <COMMENTS>and</COMMENTS> <COMMENTS>label</COMMENTS> <COMMENTS>starts</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>stmt</COMMENTS>
                        if ( $<CODE>type</CODE> eq ';' || $<CODE>type</CODE> eq '<LITERALS>J</LITERALS>' ) {
                            $<CODE>in_statement_continuation</CODE> = 0;
                        }

                        # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>continuing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>statement</COMMENTS>
                        else {
                            $<CODE>in_statement_continuation</CODE> = 1;
                        }
                    }

                    # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>BLOCK</COMMENTS>..
                    else {

                        # <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>indentation</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>list</COMMENTS>
                        # <COMMENTS>environment</COMMENTS> (<COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>if</COMMENTS>/<COMMENTS>elsif</COMMENTS> <COMMENTS>clause</COMMENTS>)
                        if ( !$<CODE>nesting_list_flag</CODE> ) {
                            $<CODE>in_statement_continuation</CODE> = 0;
                        }

                        # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> ',' <COMMENTS>starts</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>term</COMMENTS>

                        # <COMMENTS>Patch</COMMENTS> <COMMENTS>FOR</COMMENTS> <COMMENTS>RT</COMMENTS>#<COMMENTS>99961</COMMENTS>; <COMMENTS>no</COMMENTS> <COMMENTS>continuation</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> ';'
                        # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>currently</COMMENTS> <COMMENTS>marks</COMMENTS>
                        # <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>preceded</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>like</COMMENTS> % <COMMENTS>or</COMMENTS> @
                        # <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS> <COMMENTS>block</COMMENTS>, <COMMENTS>to</COMMENTS> <COMMENTS>simplify</COMMENTS> <COMMENTS>formatting</COMMENTS>. <COMMENTS>But</COMMENTS> <COMMENTS>these</COMMENTS>
                        # <COMMENTS>are</COMMENTS> <COMMENTS>actually</COMMENTS> <COMMENTS>blocks</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>semicolons</COMMENTS>.
                        # <COMMENTS>See</COMMENTS> <COMMENTS>code_block_type</COMMENTS>() <COMMENTS>and</COMMENTS> <COMMENTS>is_non_structural_brace</COMMENTS>().
                        elsif ( $<CODE>type</CODE> eq ',' || $<CODE>type</CODE> eq ';' ) {
                            $<CODE>in_statement_continuation</CODE> = 0;
                        }

                        # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>continuing</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>term</COMMENTS>
                        else {
                            $<CODE>in_statement_continuation</CODE> = 1;
                        }
                    }
                }
            }

            if ( $<CODE>level_in_tokenizer</CODE> < 0 ) {
                unless ( $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_negative_indentation</LITERALS>} ) {
                    $<CODE>tokenizer_self</CODE>->{<LITERALS>_saw_negative_indentation</LITERALS>} = 1;
                    <CODE>warning</CODE>("<LITERALS>Starting</LITERALS> <LITERALS>negative</LITERALS> <LITERALS>indentation</LITERALS>\n");
                }
            }

            # <COMMENTS>set</COMMENTS> <COMMENTS>secondary</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>levels</COMMENTS> <COMMENTS>based</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>containment</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>
            # <COMMENTS>Note</COMMENTS>: <COMMENTS>these</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>depth</COMMENTS>
            # <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>PREVIOUS</COMMENTS> <COMMENTS>TOKEN</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>convenient</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>setting</COMMENTS>
            # <COMMENTS>the</COMMENTS> <COMMENTS>strength</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>bonds</COMMENTS>
            my $<CODE>slevel_i</CODE> = $<CODE>slevel_in_tokenizer</CODE>;

            #    /^[<COMMENTS>L</COMMENTS>\{\(\[]<COMMENTS>$</COMMENTS>/
            if ( $<CODE>is_opening_type</CODE>{$<CODE>type</CODE>} ) {
                $<CODE>slevel_in_tokenizer</CODE>++;
                $<CODE>nesting_token_string</CODE> .= $<CODE>tok</CODE>;
                $<CODE>nesting_type_string</CODE>  .= $<CODE>type</CODE>;
            }

            #       /^[<COMMENTS>R</COMMENTS>\}\)\]]<COMMENTS>$</COMMENTS>/
            elsif ( $<CODE>is_closing_type</CODE>{$<CODE>type</CODE>} ) {
                $<CODE>slevel_in_tokenizer</CODE>--;
                my $<CODE>char</CODE> = chop $<CODE>nesting_token_string</CODE>;

                if ( $<CODE>char</CODE> ne $<CODE>matching_start_token</CODE>{$<CODE>tok</CODE>} ) {
                    $<CODE>nesting_token_string</CODE> .= $<CODE>char</CODE> . $<CODE>tok</CODE>;
                    $<CODE>nesting_type_string</CODE>  .= $<CODE>type</CODE>;
                }
                else {
                    chop $<CODE>nesting_type_string</CODE>;
                }
            }

            push( @<CODE>block_type</CODE>,            $<CODE>routput_block_type</CODE>->[$<CODE>i</CODE>] );
            push( @<CODE>ci_string</CODE>,             $<CODE>ci_string_i</CODE> );
            push( @<CODE>container_environment</CODE>, $<CODE>container_environment</CODE> );
            push( @<CODE>container_type</CODE>,        $<CODE>routput_container_type</CODE>->[$<CODE>i</CODE>] );
            push( @<CODE>levels</CODE>,                $<CODE>level_i</CODE> );
            push( @<CODE>nesting_tokens</CODE>,        $<CODE>nesting_token_string_i</CODE> );
            push( @<CODE>nesting_types</CODE>,         $<CODE>nesting_type_string_i</CODE> );
            push( @<CODE>slevels</CODE>,               $<CODE>slevel_i</CODE> );
            push( @<CODE>token_type</CODE>,            $<CODE>fix_type</CODE> );
            push( @<CODE>type_sequence</CODE>,         $<CODE>routput_type_sequence</CODE>->[$<CODE>i</CODE>] );
            push( @<CODE>nesting_blocks</CODE>,        $<CODE>nesting_block_string</CODE> );
            push( @<CODE>nesting_lists</CODE>,         $<CODE>nesting_list_string</CODE> );

            # <COMMENTS>now</COMMENTS> <COMMENTS>form</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS>
            if ( $<CODE>im</CODE> >= 0 ) {
                $<CODE>num</CODE> =
                  $$<CODE>rtoken_map</CODE>[$<CODE>i</CODE>] - $$<CODE>rtoken_map</CODE>[$<CODE>im</CODE>];    # <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>characters</COMMENTS>

                if ( $<CODE>num</CODE> > 0 ) {
                    push( @<CODE>tokens</CODE>,
                        substr( $<CODE>input_line</CODE>, $$<CODE>rtoken_map</CODE>[$<CODE>im</CODE>], $<CODE>num</CODE> ) );
                }
            }
            $<CODE>im</CODE> = $<CODE>i</CODE>;
        }

        $<CODE>num</CODE> = length($<CODE>input_line</CODE>) - $$<CODE>rtoken_map</CODE>[$<CODE>im</CODE>];    # <COMMENTS>make</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS>
        if ( $<CODE>num</CODE> > 0 ) {
            push( @<CODE>tokens</CODE>, substr( $<CODE>input_line</CODE>, $$<CODE>rtoken_map</CODE>[$<CODE>im</CODE>], $<CODE>num</CODE> ) );
        }

        $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_attribute_list</LITERALS>} = $<CODE>in_attribute_list</CODE>;
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_in_quote</LITERALS>}          = $<CODE>in_quote</CODE>;
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_quote_target</LITERALS>} =
          $<CODE>in_quote</CODE> ? <CODE>matching_end_token</CODE>($<CODE>quote_character</CODE>) : "";
        $<CODE>tokenizer_self</CODE>->{<LITERALS>_rhere_target_list</LITERALS>} = $<CODE>rhere_target_list</CODE>;

        $<CODE>line_of_tokens</CODE>->{<LITERALS>_rtoken_type</LITERALS>}            = \@<CODE>token_type</CODE>;
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_rtokens</LITERALS>}                = \@<CODE>tokens</CODE>;
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_rblock_type</LITERALS>}            = \@<CODE>block_type</CODE>;
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_rcontainer_type</LITERALS>}        = \@<CODE>container_type</CODE>;
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_rcontainer_environment</LITERALS>} = \@<CODE>container_environment</CODE>;
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_rtype_sequence</LITERALS>}         = \@<CODE>type_sequence</CODE>;
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_rlevels</LITERALS>}                = \@<CODE>levels</CODE>;
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_rslevels</LITERALS>}               = \@<CODE>slevels</CODE>;
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_rnesting_tokens</LITERALS>}        = \@<CODE>nesting_tokens</CODE>;
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_rci_levels</LITERALS>}             = \@<CODE>ci_string</CODE>;
        $<CODE>line_of_tokens</CODE>->{<LITERALS>_rnesting_blocks</LITERALS>}        = \@<CODE>nesting_blocks</CODE>;

        return;
    }
}    # <COMMENTS>end</COMMENTS> <COMMENTS>tokenize_this_line</COMMENTS>

#########<COMMENTS>i</COMMENTS>#############################################################
# <COMMENTS>Tokenizer</COMMENTS> <COMMENTS>routines</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>assist</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>identifying</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS>
#######################################################################

sub <CODE>operator_expected</CODE> {

    # <COMMENTS>Many</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>symbols</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>meanings</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, '<<'
    # <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>shift</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS> <COMMENTS>operator</COMMENTS>.  <COMMENTS>The</COMMENTS>
    # <COMMENTS>interpretation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>symbols</COMMENTS> <COMMENTS>depends</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>state</COMMENTS> <COMMENTS>of</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>expecting</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>an</COMMENTS>
    # <COMMENTS>operator</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>a</COMMENTS> << <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>shift</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS>
    # <COMMENTS>is</COMMENTS> <COMMENTS>expected</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>expected</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS>
    # <COMMENTS>is</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>decision</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>token</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>returns</COMMENTS>
    # <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>three</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>values</COMMENTS>:
    #
    #     <COMMENTS>OPERATOR</COMMENTS> - <COMMENTS>operator</COMMENTS> <COMMENTS>expected</COMMENTS> (<COMMENTS>or</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS>, <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>term</COMMENTS>)
    #     <COMMENTS>UNKNOWN</COMMENTS>  - <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>tell</COMMENTS>
    #     <COMMENTS>TERM</COMMENTS>     - <COMMENTS>a</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>expected</COMMENTS> (<COMMENTS>or</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS>, <COMMENTS>not</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS>)
    #
    # <COMMENTS>The</COMMENTS> <COMMENTS>decision</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>based</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>seen</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>far</COMMENTS>.  <COMMENTS>This</COMMENTS>
    # <COMMENTS>information</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>stored</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> "<COMMENTS>$last_nonblank_type</COMMENTS>" <COMMENTS>and</COMMENTS>
    # "<COMMENTS>$last_nonblank_token</COMMENTS>" <COMMENTS>variables</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>$last_nonblank_type</COMMENTS> <COMMENTS>is</COMMENTS> '=~', <COMMENTS>then</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>expecting</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>TERM</COMMENTS>, <COMMENTS>whereas</COMMENTS>
    # <COMMENTS>if</COMMENTS> <COMMENTS>$last_nonblank_type</COMMENTS> <COMMENTS>is</COMMENTS> '<COMMENTS>n</COMMENTS>' (<COMMENTS>numeric</COMMENTS>), <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>expecting</COMMENTS> <COMMENTS>an</COMMENTS>
    # <COMMENTS>OPERATOR</COMMENTS>.
    #
    # <COMMENTS>If</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>UNKNOWN</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>returned</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>calling</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>guess</COMMENTS>. <COMMENTS>A</COMMENTS> <COMMENTS>major</COMMENTS>
    # <COMMENTS>goal</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>minimize</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>possibility</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>returning</COMMENTS>
    # <COMMENTS>UNKNOWN</COMMENTS>, <COMMENTS>because</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>wrong</COMMENTS> <COMMENTS>guess</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>spoil</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>formatting</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS>
    # <COMMENTS>script</COMMENTS>.
    #
    # <COMMENTS>adding</COMMENTS> <COMMENTS>NEW_TOKENS</COMMENTS>: <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>critically</COMMENTS> <COMMENTS>important</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>updated</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>determine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>expected</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>token</COMMENTS>.  <COMMENTS>Doing</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>simply</COMMENTS> <COMMENTS>involves</COMMENTS> <COMMENTS>adding</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>regexes</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>or</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>lists</COMMENTS>
    # <COMMENTS>that</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>uses</COMMENTS>, <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>initialized</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>BEGIN</COMMENTS> <COMMENTS>section</COMMENTS>.
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$last_nonblank_type</COMMENTS>, <COMMENTS>$last_nonblank_token</COMMENTS>,
    # <COMMENTS>$statement_type</COMMENTS>

    my ( $<CODE>prev_type</CODE>, $<CODE>tok</CODE>, $<CODE>next_type</CODE> ) = @<CODE>_</CODE>;

    my $<CODE>op_expected</CODE> = <CODE>UNKNOWN</CODE>;

##<COMMENTS>print</COMMENTS> "<COMMENTS>tok</COMMENTS>=<COMMENTS>$tok</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>type</COMMENTS>=<COMMENTS>$last_nonblank_type</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>tok</COMMENTS>=<COMMENTS>$last_nonblank_token</COMMENTS>\<COMMENTS>n</COMMENTS>";

# <COMMENTS>Note</COMMENTS>: <COMMENTS>function</COMMENTS> <COMMENTS>prototype</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>available</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>U</COMMENTS>' <COMMENTS>for</COMMENTS> <COMMENTS>future</COMMENTS>
# <COMMENTS>program</COMMENTS> <COMMENTS>development</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>contains</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>parens</COMMENTS>,
# <COMMENTS>and</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>blanks</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>eliminate</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>C</COMMENTS>', <COMMENTS>for</COMMENTS>
# <COMMENTS>example</COMMENTS> (<COMMENTS>prototype</COMMENTS> = '()'). <COMMENTS>Thus</COMMENTS>:
# <COMMENTS>if</COMMENTS> (<COMMENTS>$last_nonblank_type</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>U</COMMENTS>') {
#     <COMMENTS>print</COMMENTS> "<COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS>=<COMMENTS>$last_nonblank_token</COMMENTS>  <COMMENTS>type</COMMENTS>=<COMMENTS>$last_nonblank_type</COMMENTS> <COMMENTS>prototype</COMMENTS>=<COMMENTS>$last_nonblank_prototype</COMMENTS>\<COMMENTS>n</COMMENTS>";
# }

    # <COMMENTS>A</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>filehandle</COMMENTS> (<COMMENTS>or</COMMENTS> <COMMENTS>object</COMMENTS>) <COMMENTS>requires</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>care</COMMENTS>...
    if ( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>Z</LITERALS>' ) {

        # <COMMENTS>angle</COMMENTS>.<COMMENTS>t</COMMENTS>
        if ( $<CODE>last_nonblank_token</CODE> =~ /^[A-Za-z_]/ ) {
            $<CODE>op_expected</CODE> = <CODE>UNKNOWN</CODE>;
        }

        # <COMMENTS>For</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>like</COMMENTS> "<COMMENTS>$a</COMMENTS>", <COMMENTS>Perl</COMMENTS> <COMMENTS>uses</COMMENTS> <COMMENTS>weird</COMMENTS> <COMMENTS>parsing</COMMENTS> <COMMENTS>rules</COMMENTS>.
        # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>:
        # <COMMENTS>print</COMMENTS> <COMMENTS>$a</COMMENTS>/<COMMENTS>2</COMMENTS>,"/<COMMENTS>hi</COMMENTS>";   - <COMMENTS>division</COMMENTS>
        # <COMMENTS>print</COMMENTS> <COMMENTS>$a</COMMENTS> / <COMMENTS>2</COMMENTS>,"/<COMMENTS>hi</COMMENTS>"; - <COMMENTS>division</COMMENTS>
        # <COMMENTS>print</COMMENTS> <COMMENTS>$a</COMMENTS>/ <COMMENTS>2</COMMENTS>,"/<COMMENTS>hi</COMMENTS>";  - <COMMENTS>division</COMMENTS>
        # <COMMENTS>print</COMMENTS> <COMMENTS>$a</COMMENTS> /<COMMENTS>2</COMMENTS>,"/<COMMENTS>hi</COMMENTS>";  - <COMMENTS>pattern</COMMENTS> (<COMMENTS>and</COMMENTS> <COMMENTS>error</COMMENTS>)!
        elsif ( ( $<CODE>prev_type</CODE> eq '<LITERALS>b</LITERALS>' ) && ( $<CODE>next_type</CODE> ne '<LITERALS>b</LITERALS>' ) ) {
            $<CODE>op_expected</CODE> = <CODE>TERM</CODE>;
        }

        # <COMMENTS>Note</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>done</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>a</COMMENTS>
        # <COMMENTS>filehandle</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>expected</COMMENTS>, <COMMENTS>since</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>whitespace</COMMENTS>
        # <COMMENTS>could</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>interpretation</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>statement</COMMENTS>.
        else {
            if ( $<CODE>tok</CODE> =~ /^([x\/\+\-\*\%\&\.\?\<]|\>\>)$/ ) {
                <CODE>complain</CODE>("<LITERALS>operator</LITERALS> <LITERALS>in</LITERALS> <LITERALS>print</LITERALS> <LITERALS>statement</LITERALS> <LITERALS>not</LITERALS> <LITERALS>recommended</LITERALS>\n");
                $<CODE>op_expected</CODE> = <CODE>OPERATOR</CODE>;
            }
        }
    }

    # <COMMENTS>Check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>smartmatch</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>preceding</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>square</COMMENTS> <COMMENTS>bracket</COMMENTS>.
    # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> ? <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> ] <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>expressions</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS>
    # <COMMENTS>expecting</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS>:
    #
    # <COMMENTS>qr</COMMENTS>/<COMMENTS>3</COMMENTS>/ ~~ ['<COMMENTS>1234</COMMENTS>'] ? <COMMENTS>1</COMMENTS> : <COMMENTS>0</COMMENTS>;
    # <COMMENTS>map</COMMENTS> { <COMMENTS>$_</COMMENTS> ~~ [ '<COMMENTS>0</COMMENTS>', '<COMMENTS>1</COMMENTS>' ] ? '<COMMENTS>x</COMMENTS>' : '<COMMENTS>o</COMMENTS>' } @<COMMENTS>a</COMMENTS>;
    elsif ( $<CODE>last_nonblank_type</CODE> eq '}' && $<CODE>last_nonblank_token</CODE> eq '~~' ) {
        $<CODE>op_expected</CODE> = <CODE>OPERATOR</CODE>;
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>after</COMMENTS> '<COMMENTS>do</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>eval</COMMENTS>'
    elsif ( $<CODE>is_block_operator</CODE>{$<CODE>last_nonblank_token</CODE>} ) {

        # <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>$a</COMMENTS> = <COMMENTS>eval</COMMENTS> "<COMMENTS>expression</COMMENTS>";
        #                          ^
        if ( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>' ) {
            $<CODE>op_expected</CODE> = <CODE>TERM</CODE>;    # <COMMENTS>expression</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>mode</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>keyword</COMMENTS>
        }

        # <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>$a</COMMENTS> = <COMMENTS>do</COMMENTS> { <COMMENTS>BLOCK</COMMENTS> } / <COMMENTS>2</COMMENTS>;
        # <COMMENTS>or</COMMENTS> <COMMENTS>this</COMMENTS> ? <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>smartmatch</COMMENTS> <COMMENTS>anonynmous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>reference</COMMENTS>:
        #   <COMMENTS>qr</COMMENTS>/<COMMENTS>3</COMMENTS>/ ~~ ['<COMMENTS>1234</COMMENTS>'] ? <COMMENTS>1</COMMENTS> : <COMMENTS>0</COMMENTS>;
        #                                  ^
        else {
            $<CODE>op_expected</CODE> = <CODE>OPERATOR</CODE>;    # <COMMENTS>block</COMMENTS> <COMMENTS>mode</COMMENTS> <COMMENTS>following</COMMENTS> }
        }
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS>..
    elsif ( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>w</LITERALS>' ) {

        # <COMMENTS>unfortunately</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>tell</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>expect</COMMENTS> <COMMENTS>next</COMMENTS>
        # <COMMENTS>after</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>words</COMMENTS>
        $<CODE>op_expected</CODE> = <CODE>UNKNOWN</CODE>;
    }

    # <COMMENTS>operator</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>types</COMMENTS>
    # <COMMENTS>Note</COMMENTS>: <COMMENTS>moved</COMMENTS> ')' <COMMENTS>from</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>parens</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>context</COMMENTS>
    # <COMMENTS>get</COMMENTS> <COMMENTS>marked</COMMENTS> <COMMENTS>as</COMMENTS> '{' '}' <COMMENTS>now</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>minor</COMMENTS> <COMMENTS>glitch</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>:
    #    <COMMENTS>my</COMMENTS> %<COMMENTS>opts</COMMENTS> = (<COMMENTS>ref</COMMENTS> <COMMENTS>$_</COMMENTS>[<COMMENTS>0</COMMENTS>] <COMMENTS>eq</COMMENTS> '<COMMENTS>HASH</COMMENTS>') ? %{<COMMENTS>shift</COMMENTS>()} : ();
    #
    elsif (( $<CODE>last_nonblank_type</CODE> =~ /^[\]RnviQh]$/ )
        || ( $<CODE>last_nonblank_token</CODE> =~ /^(\)|\$|\-\>)/ ) )
    {
        $<CODE>op_expected</CODE> = <CODE>OPERATOR</CODE>;

        # <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>use</COMMENTS>' <COMMENTS>statement</COMMENTS>, <COMMENTS>numbers</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>true</COMMENTS>
        # <COMMENTS>numbers</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>avoid</COMMENTS> <COMMENTS>incorrect</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>messages</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS>
        # <COMMENTS>mark</COMMENTS> <COMMENTS>them</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>unknown</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>now</COMMENTS> (<COMMENTS>use</COMMENTS>.<COMMENTS>t</COMMENTS>)
        # <COMMENTS>TODO</COMMENTS>: <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>much</COMMENTS> <COMMENTS>nicer</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>V</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>VERSION</COMMENTS>
        # <COMMENTS>number</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>statement</COMMENTS>.  <COMMENTS>Then</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>V</COMMENTS>
        # <COMMENTS>and</COMMENTS> <COMMENTS>related</COMMENTS> <COMMENTS>patches</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>$statement_type</COMMENTS> <COMMENTS>for</COMMENTS> '=>'
        # <COMMENTS>and</COMMENTS> ',' <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>removed</COMMENTS>.  <COMMENTS>Further</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>clean</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>to</COMMENTS>
        # <COMMENTS>scan</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>use</COMMENTS>' <COMMENTS>statement</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>subroutine</COMMENTS>.
        if (   ( $<CODE>statement_type</CODE> eq '<LITERALS>use</LITERALS>' )
            && ( $<CODE>last_nonblank_type</CODE> =~ /^[nv]$/ ) )
        {
            $<CODE>op_expected</CODE> = <CODE>UNKNOWN</CODE>;
        }

        # <COMMENTS>expecting</COMMENTS> <COMMENTS>VERSION</COMMENTS> <COMMENTS>or</COMMENTS> {} <COMMENTS>after</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>NAMESPACE</COMMENTS>
        elsif ($<CODE>statement_type</CODE> =~ /^package\b/
            && $<CODE>last_nonblank_token</CODE> =~ /^package\b/ )
        {
            $<CODE>op_expected</CODE> = <CODE>TERM</CODE>;
        }
    }

    # <COMMENTS>no</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>keywords</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> "<COMMENTS>die</COMMENTS>", "<COMMENTS>warn</COMMENTS>", <COMMENTS>etc</COMMENTS>
    elsif ( $<CODE>expecting_term_token</CODE>{$<CODE>last_nonblank_token</CODE>} ) {

        # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>dor</COMMENTS>.<COMMENTS>t</COMMENTS> (<COMMENTS>defined</COMMENTS> <COMMENTS>or</COMMENTS>).
        # <COMMENTS>perl</COMMENTS> <COMMENTS>functions</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>unary</COMMENTS> <COMMENTS>operators</COMMENTS>
        # <COMMENTS>TODO</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>incomplete</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>put</COMMENTS>
        # <COMMENTS>into</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS>.
        if (   $<CODE>tok</CODE> eq '/'
            && $<CODE>next_type</CODE> eq '/'
            && $<CODE>last_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>'
            && $<CODE>last_nonblank_token</CODE> =~ /^eof|undef|shift|pop$/ )
        {
            $<CODE>op_expected</CODE> = <CODE>OPERATOR</CODE>;
        }
        else {
            $<CODE>op_expected</CODE> = <CODE>TERM</CODE>;
        }
    }

    # <COMMENTS>no</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>like</COMMENTS> + - **  (<COMMENTS>i</COMMENTS>.<COMMENTS>e</COMMENTS>., <COMMENTS>other</COMMENTS> <COMMENTS>operators</COMMENTS>)
    elsif ( $<CODE>expecting_term_types</CODE>{$<CODE>last_nonblank_type</CODE>} ) {
        $<CODE>op_expected</CODE> = <CODE>TERM</CODE>;
    }

    # <COMMENTS>a</COMMENTS> <COMMENTS>few</COMMENTS> <COMMENTS>operators</COMMENTS>, <COMMENTS>like</COMMENTS> "<COMMENTS>time</COMMENTS>", <COMMENTS>have</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>prototype</COMMENTS> () <COMMENTS>and</COMMENTS> <COMMENTS>so</COMMENTS>
    # <COMMENTS>take</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>parameters</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>produce</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>operate</COMMENTS> <COMMENTS>on</COMMENTS>
    elsif ( $<CODE>expecting_operator_token</CODE>{$<CODE>last_nonblank_token</CODE>} ) {
        $<CODE>op_expected</CODE> = <CODE>OPERATOR</CODE>;
    }

    # <COMMENTS>post</COMMENTS>-<COMMENTS>increment</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>decrement</COMMENTS> <COMMENTS>produce</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>operated</COMMENTS> <COMMENTS>on</COMMENTS>
    elsif ( $<CODE>expecting_operator_types</CODE>{$<CODE>last_nonblank_type</CODE>} ) {
        $<CODE>op_expected</CODE> = <CODE>OPERATOR</CODE>;
    }

    # <COMMENTS>no</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>operate</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>block</COMMENTS>
    elsif ( $<CODE>last_nonblank_token</CODE> =~ /^sub\s/ ) { $<CODE>op_expected</CODE> = <CODE>TERM</CODE>; }

    # <COMMENTS>a</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>indicates</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>block</COMMENTS>.
    # <COMMENTS>all</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS> <COMMENTS>right</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>R</COMMENTS>'
    # <COMMENTS>all</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>associated</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>those</COMMENTS>
    # <COMMENTS>keywords</COMMENTS> <COMMENTS>as</COMMENTS> "<COMMENTS>last_nonblank_token</COMMENTS>" <COMMENTS>and</COMMENTS> <COMMENTS>caught</COMMENTS> <COMMENTS>above</COMMENTS>.
    # (<COMMENTS>This</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>order</COMMENTS> <COMMENTS>dependent</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>come</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>checking</COMMENTS>
    # <COMMENTS>$last_nonblank_token</COMMENTS>).
    elsif ( $<CODE>last_nonblank_type</CODE> eq '}' ) {

        # <COMMENTS>patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>dor</COMMENTS>.<COMMENTS>t</COMMENTS> (<COMMENTS>defined</COMMENTS> <COMMENTS>or</COMMENTS>).
        if (   $<CODE>tok</CODE> eq '/'
            && $<CODE>next_type</CODE> eq '/'
            && $<CODE>last_nonblank_token</CODE> eq ']' )
        {
            $<CODE>op_expected</CODE> = <CODE>OPERATOR</CODE>;
        }
        else {
            $<CODE>op_expected</CODE> = <CODE>TERM</CODE>;
        }
    }

    # <COMMENTS>something</COMMENTS> <COMMENTS>else</COMMENTS>..<COMMENTS>what</COMMENTS> <COMMENTS>did</COMMENTS> <COMMENTS>I</COMMENTS> <COMMENTS>forget</COMMENTS>?
    else {

        # <COMMENTS>collecting</COMMENTS> <COMMENTS>diagnostics</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>unknown</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>types</COMMENTS>..<COMMENTS>see</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>missed</COMMENTS>
        $<CODE>op_expected</CODE> = <CODE>UNKNOWN</CODE>;
        <CODE>write_diagnostics</CODE>(
"<LITERALS>OP</LITERALS>: <LITERALS>unknown</LITERALS> <LITERALS>after</LITERALS> <LITERALS>type</LITERALS>=$<CODE>last_nonblank_type</CODE>  <LITERALS>token</LITERALS>=$<CODE>last_nonblank_token</CODE>\n"
        );
    }

    <CODE>TOKENIZER_DEBUG_FLAG_EXPECT</CODE> && do {
        print <CODE>STDOUT</CODE>
"<LITERALS>EXPECT</LITERALS>: <LITERALS>returns</LITERALS> $<CODE>op_expected</CODE> <LITERALS>for</LITERALS> <LITERALS>last</LITERALS> <LITERALS>type</LITERALS> $<CODE>last_nonblank_type</CODE> <LITERALS>token</LITERALS> $<CODE>last_nonblank_token</CODE>\n";
    };
    return $<CODE>op_expected</CODE>;
}

sub <CODE>new_statement_ok</CODE> {

    # <COMMENTS>return</COMMENTS> <COMMENTS>true</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>statement</COMMENTS>
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$last_nonblank_type</COMMENTS>

    return <CODE>label_ok</CODE>()    # <COMMENTS>a</COMMENTS> <COMMENTS>label</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>here</COMMENTS>

      || $<CODE>last_nonblank_type</CODE> eq '<LITERALS>J</LITERALS>';    # <COMMENTS>or</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>label</COMMENTS>

}

sub <CODE>label_ok</CODE> {

    # <COMMENTS>Decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bare</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>colon</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>label</COMMENTS>
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$last_nonblank_token</COMMENTS>, <COMMENTS>$last_nonblank_type</COMMENTS>,
    # <COMMENTS>$brace_depth</COMMENTS>, @<COMMENTS>brace_type</COMMENTS>

    # <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>follows</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>brace</COMMENTS>..
    if ( ( $<CODE>last_nonblank_token</CODE> eq '{' || $<CODE>last_nonblank_token</CODE> eq '}' )
        && $<CODE>last_nonblank_type</CODE> eq $<CODE>last_nonblank_token</CODE> )
    {

        # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>label</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>encloses</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>
        return $<CODE>brace_type</CODE>[$<CODE>brace_depth</CODE>];
    }

    # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>label</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>follows</COMMENTS> <COMMENTS>a</COMMENTS> ';' (<COMMENTS>real</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>fake</COMMENTS>)
    # <COMMENTS>or</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>label</COMMENTS>
    else {
        return ( $<CODE>last_nonblank_type</CODE> eq ';' || $<CODE>last_nonblank_type</CODE> eq '<LITERALS>J</LITERALS>' );
    }
}

sub <CODE>code_block_type</CODE> {

    # <COMMENTS>Decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>type</COMMENTS>.
    # <COMMENTS>Must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>$type</COMMENTS> = <COMMENTS>$token</COMMENTS> = '{'
    # <COMMENTS>The</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>distinguish</COMMENTS> <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS>
    # <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>reference</COMMENTS>
    # <COMMENTS>Returns</COMMENTS> "" <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>, <COMMENTS>otherwise</COMMENTS> <COMMENTS>returns</COMMENTS> '<COMMENTS>last_nonblank_token</COMMENTS>'
    # <COMMENTS>to</COMMENTS> <COMMENTS>indicate</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>.  (<COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, '<COMMENTS>last_nonblank_token</COMMENTS>'
    # <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>for</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>block</COMMENTS>, '<COMMENTS>else</COMMENTS>' <COMMENTS>for</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>block</COMMENTS>, <COMMENTS>etc</COMMENTS>).
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$last_nonblank_token</COMMENTS>, <COMMENTS>$last_nonblank_type</COMMENTS>,
    # <COMMENTS>$last_nonblank_block_type</COMMENTS>, <COMMENTS>$brace_depth</COMMENTS>, @<COMMENTS>brace_type</COMMENTS>

    # <COMMENTS>handle</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>multiple</COMMENTS> '{'<COMMENTS>s</COMMENTS>

# <COMMENTS>print</COMMENTS> "<COMMENTS>BLOCK_TYPE</COMMENTS> <COMMENTS>EXAMINING</COMMENTS>: <COMMENTS>type</COMMENTS>=<COMMENTS>$last_nonblank_type</COMMENTS> <COMMENTS>tok</COMMENTS>=<COMMENTS>$last_nonblank_token</COMMENTS>\<COMMENTS>n</COMMENTS>";

    my ( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;
    if (   $<CODE>last_nonblank_token</CODE> eq '{'
        && $<CODE>last_nonblank_type</CODE> eq $<CODE>last_nonblank_token</CODE> )
    {

        # <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>appear</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>probably</COMMENTS>
        # <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>reference</COMMENTS>
        if ( $<CODE>brace_type</CODE>[$<CODE>brace_depth</CODE>] ) {
            return <CODE>decide_if_code_block</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>,
                $<CODE>max_token_index</CODE> );
        }

        # <COMMENTS>cannot</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS>
        else {
            return "";
        }
    }

    elsif ( $<CODE>last_nonblank_token</CODE> eq ';' ) {

        # <COMMENTS>an</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>appear</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>probably</COMMENTS>
        # <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>reference</COMMENTS>
        return <CODE>decide_if_code_block</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>,
            $<CODE>max_token_index</CODE> );
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> '}{'
    elsif ($<CODE>last_nonblank_token</CODE> eq '}'
        && $<CODE>last_nonblank_type</CODE> eq $<CODE>last_nonblank_token</CODE> )
    {

        # <COMMENTS>a</COMMENTS> } { <COMMENTS>situation</COMMENTS> ...
        # <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>reference</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>..(<COMMENTS>blktype1</COMMENTS>.<COMMENTS>t</COMMENTS>)
        if ($<CODE>last_nonblank_block_type</CODE>) {
            return <CODE>decide_if_code_block</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>,
                $<CODE>max_token_index</CODE> );
        }

        # <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>follows</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>reference</COMMENTS>
        else {
            return $<CODE>last_nonblank_token</CODE>;
        }
    }

    ################################################################
    # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>braces</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>blocks</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>for</COMMENTS>
    # <COMMENTS>simplicity</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>identified</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>such</COMMENTS>.  <COMMENTS>See</COMMENTS> <COMMENTS>also</COMMENTS>
    # <COMMENTS>sub</COMMENTS> <COMMENTS>is_non_structural_brace</COMMENTS>.
    ################################################################

##    <COMMENTS>elsif</COMMENTS> ( <COMMENTS>$last_nonblank_type</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>t</COMMENTS>' ) {
##       <COMMENTS>return</COMMENTS> <COMMENTS>$last_nonblank_token</COMMENTS>;
##    }

    # <COMMENTS>brace</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>label</COMMENTS>:
    elsif ( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>J</LITERALS>' ) {
        return $<CODE>last_nonblank_token</CODE>;
    }

# <COMMENTS>otherwise</COMMENTS>, <COMMENTS>look</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>if</COMMENTS>
# <COMMENTS>it</COMMENTS> <COMMENTS>follows</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS>:
# /^(<COMMENTS>BEGIN</COMMENTS>|<COMMENTS>END</COMMENTS>|<COMMENTS>CHECK</COMMENTS>|<COMMENTS>INIT</COMMENTS>|<COMMENTS>AUTOLOAD</COMMENTS>|<COMMENTS>DESTROY</COMMENTS>|<COMMENTS>UNITCHECK</COMMENTS>|<COMMENTS>continue</COMMENTS>|<COMMENTS>if</COMMENTS>|<COMMENTS>elsif</COMMENTS>|<COMMENTS>else</COMMENTS>|<COMMENTS>unless</COMMENTS>|<COMMENTS>do</COMMENTS>|<COMMENTS>while</COMMENTS>|<COMMENTS>until</COMMENTS>|<COMMENTS>eval</COMMENTS>|<COMMENTS>for</COMMENTS>|<COMMENTS>foreach</COMMENTS>|<COMMENTS>map</COMMENTS>|<COMMENTS>grep</COMMENTS>|<COMMENTS>sort</COMMENTS>)<COMMENTS>$</COMMENTS>/
    elsif ( $<CODE>is_code_block_token</CODE>{$<CODE>last_nonblank_token</CODE>} ) {

        # <COMMENTS>Bug</COMMENTS> <COMMENTS>Patch</COMMENTS>: <COMMENTS>Note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>if</COMMENTS>' <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>
        # <COMMENTS>snippet</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>ref</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>!
        #   <COMMENTS>print</COMMENTS> '<COMMENTS>hi</COMMENTS>' <COMMENTS>if</COMMENTS> { <COMMENTS>x</COMMENTS> => <COMMENTS>1</COMMENTS>, }->{<COMMENTS>x</COMMENTS>};
        # <COMMENTS>We</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>identify</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>situation</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>type</COMMENTS>
        # <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>keyword</COMMENTS> (<COMMENTS>instead</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>peren</COMMENTS>)
        if (   $<CODE>last_nonblank_token</CODE> =~ /^(if|unless)$/
            && $<CODE>last_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>' )
        {
            return "";
        }
        else {
            return $<CODE>last_nonblank_token</CODE>;
        }
    }

    # <COMMENTS>or</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>BLOCK</COMMENTS>
    elsif ( ( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>i</LITERALS>' || $<CODE>last_nonblank_type</CODE> eq '<LITERALS>t</LITERALS>' )
        && $<CODE>last_nonblank_token</CODE> =~ /^(sub|package)\b/ )
    {
        return $<CODE>last_nonblank_token</CODE>;
    }

    elsif ( $<CODE>statement_type</CODE> =~ /^(sub|package)\b/ ) {
        return $<CODE>statement_type</CODE>;
    }

    # <COMMENTS>user</COMMENTS>-<COMMENTS>defined</COMMENTS> <COMMENTS>subs</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>parameters</COMMENTS> (<COMMENTS>like</COMMENTS> <COMMENTS>grep</COMMENTS>/<COMMENTS>map</COMMENTS>/<COMMENTS>eval</COMMENTS>)
    elsif ( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>G</LITERALS>' ) {
        return $<CODE>last_nonblank_token</CODE>;
    }

    # <COMMENTS>check</COMMENTS> <COMMENTS>bareword</COMMENTS>
    elsif ( $<CODE>last_nonblank_type</CODE> eq '<LITERALS>w</LITERALS>' ) {
        return <CODE>decide_if_code_block</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>,
            $<CODE>max_token_index</CODE> );
    }

    # <COMMENTS>Patch</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>bug</COMMENTS> # <COMMENTS>RT</COMMENTS> #<COMMENTS>94338</COMMENTS> <COMMENTS>reported</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>Daniel</COMMENTS> <COMMENTS>Trizen</COMMENTS>
    # <COMMENTS>for</COMMENTS>-<COMMENTS>loop</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>parenthesized</COMMENTS> <COMMENTS>block</COMMENTS>-<COMMENTS>map</COMMENTS> <COMMENTS>triggering</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>message</COMMENTS>:
    #    <COMMENTS>map</COMMENTS>( { <COMMENTS>foreach</COMMENTS> <COMMENTS>my</COMMENTS> <COMMENTS>$item</COMMENTS> ( '<COMMENTS>0</COMMENTS>', '<COMMENTS>1</COMMENTS>' ) { <COMMENTS>print</COMMENTS> <COMMENTS>$item</COMMENTS>} } <COMMENTS>qw</COMMENTS>(<COMMENTS>a</COMMENTS> <COMMENTS>b</COMMENTS> <COMMENTS>c</COMMENTS>) );
    # <COMMENTS>Check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>parenthesized</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>call</COMMENTS>
    elsif ( $<CODE>last_nonblank_token</CODE> eq '(' ) {
        my $<CODE>paren_type</CODE> = $<CODE>paren_type</CODE>[$<CODE>paren_depth</CODE>];
        if ( $<CODE>paren_type</CODE> && $<CODE>paren_type</CODE> =~ /^(map|grep|sort)$/ ) {

            # <COMMENTS>We</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>mark</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>t</COMMENTS>' <COMMENTS>instead</COMMENTS>
            # <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>contining</COMMENTS> <COMMENTS>function</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>for</COMMENTS>
            # <COMMENTS>correct</COMMENTS> <COMMENTS>parsing</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>produce</COMMENTS> <COMMENTS>better</COMMENTS> <COMMENTS>formatting</COMMENTS>.
            # <COMMENTS>Braces</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>t</COMMENTS>' <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>broken</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>automatically</COMMENTS>
            # <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>formatter</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>types</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>usually</COMMENTS>
            # <COMMENTS>works</COMMENTS> <COMMENTS>best</COMMENTS>.
            return '<LITERALS>t</LITERALS>';    # (<COMMENTS>Not</COMMENTS> <COMMENTS>$paren_type</COMMENTS>)
        }
        else {
            return "";
        }
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>unknown</COMMENTS> <COMMENTS>syntax</COMMENTS> ') {'
    # <COMMENTS>we</COMMENTS> <COMMENTS>previously</COMMENTS> <COMMENTS>appended</COMMENTS> <COMMENTS>a</COMMENTS> '()' <COMMENTS>to</COMMENTS> <COMMENTS>mark</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>case</COMMENTS>
    elsif ( $<CODE>last_nonblank_token</CODE> =~ /\(\)$/ ) {
        return $<CODE>last_nonblank_token</CODE>;
    }

    # <COMMENTS>anything</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>reference</COMMENTS>
    else {
        return "";
    }
}

sub <CODE>decide_if_code_block</CODE> {

    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$last_nonblank_token</COMMENTS>
    my ( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_type</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;

    my ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_next</CODE> ) =
      <CODE>find_next_nonblank_token</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> );

    # <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> '{' <COMMENTS>where</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>appear</COMMENTS>.
    # <COMMENTS>We</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>starts</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS>
    # <COMMENTS>block</COMMENTS>.
    # <COMMENTS>return</COMMENTS> "" <COMMENTS>if</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>$last_nonblank_token</COMMENTS> <COMMENTS>otherwise</COMMENTS>

    # <COMMENTS>initialize</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>BLOCK</COMMENTS>
    my $<CODE>code_block_type</CODE> = $<CODE>last_nonblank_token</CODE>;

    # <COMMENTS>Check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>reference</COMMENTS>:
    # <COMMENTS>Maybe</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>sub</COMMENTS> { { } }
    if ( $<CODE>next_nonblank_token</CODE> eq '}' ) {
        $<CODE>code_block_type</CODE> = "";
    }

    else {

        # <COMMENTS>To</COMMENTS> <COMMENTS>guess</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> '{' <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>reference</COMMENTS>, <COMMENTS>look</COMMENTS> <COMMENTS>ahead</COMMENTS>
        # <COMMENTS>and</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>follows</COMMENTS>:
        #
        # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>reference</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>come</COMMENTS>:
        #   - <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>digit</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>or</COMMENTS> =>
        #   - <COMMENTS>bareword</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> =>
        # <COMMENTS>otherwise</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>
        #
        # <COMMENTS>Examples</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>ref</COMMENTS>:
        # {'<COMMENTS>aa</COMMENTS>',};
        # {<COMMENTS>1</COMMENTS>,<COMMENTS>2</COMMENTS>}
        #
        # <COMMENTS>Examples</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>blocks</COMMENTS>:
        # {<COMMENTS>1</COMMENTS>; <COMMENTS>print</COMMENTS> "<COMMENTS>hello</COMMENTS>\<COMMENTS>n</COMMENTS>", <COMMENTS>1</COMMENTS>;}
        # {<COMMENTS>$a</COMMENTS>,<COMMENTS>1</COMMENTS>};

        # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>going</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>ahead</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>more</COMMENTS> (<COMMENTS>nonblank</COMMENTS>/<COMMENTS>comment</COMMENTS>) <COMMENTS>line</COMMENTS>.
        # <COMMENTS>Strange</COMMENTS> <COMMENTS>formatting</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>guess</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>that</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>unlikely</COMMENTS>.
        my @<CODE>pre_types</CODE>;
        my @<CODE>pre_tokens</CODE>;

        # <COMMENTS>Ignore</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>rest</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
        if ( $<CODE>next_nonblank_token</CODE> ne '#' ) {
            @<CODE>pre_types</CODE>  = @$<CODE>rtoken_type</CODE>[ $<CODE>i</CODE> + 1 .. $<CODE>max_token_index</CODE> ];
            @<CODE>pre_tokens</CODE> = @$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 .. $<CODE>max_token_index</CODE> ];
        }
        my ( $<CODE>rpre_tokens</CODE>, $<CODE>rpre_types</CODE> ) =
          <CODE>peek_ahead_for_n_nonblank_pre_tokens</CODE>(20);    # <COMMENTS>20</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>arbitrary</COMMENTS> <COMMENTS>but</COMMENTS>
                                                       # <COMMENTS>generous</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>prevents</COMMENTS>
                                                       # <COMMENTS>wasting</COMMENTS> <COMMENTS>lots</COMMENTS> <COMMENTS>of</COMMENTS>
                                                       # <COMMENTS>time</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>mangled</COMMENTS> <COMMENTS>files</COMMENTS>
        if ( defined($<CODE>rpre_types</CODE>) && @$<CODE>rpre_types</CODE> ) {
            push @<CODE>pre_types</CODE>,  @$<CODE>rpre_types</CODE>;
            push @<CODE>pre_tokens</CODE>, @$<CODE>rpre_tokens</CODE>;
        }

        # <COMMENTS>put</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sentinel</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>simplify</COMMENTS> <COMMENTS>stopping</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>search</COMMENTS>
        push @<CODE>pre_types</CODE>, '}';
        push @<CODE>pre_types</CODE>, '}';

        my $<CODE>jbeg</CODE> = 0;
        $<CODE>jbeg</CODE> = 1 if $<CODE>pre_types</CODE>[0] eq '<LITERALS>b</LITERALS>';

        # <COMMENTS>first</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>these</COMMENTS>
        #  - <COMMENTS>bareword</COMMENTS>
        #  - <COMMENTS>bareword</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> -
        #  - <COMMENTS>digit</COMMENTS>
        #  - <COMMENTS>quoted</COMMENTS> <COMMENTS>string</COMMENTS>
        my $<CODE>j</CODE> = $<CODE>jbeg</CODE>;
        if ( $<CODE>pre_types</CODE>[$<CODE>j</CODE>] =~ /^[\'\"]/ ) {

            # <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>quote</COMMENTS>; <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>worry</COMMENTS> <COMMENTS>about</COMMENTS> <COMMENTS>escapes</COMMENTS>
            my $<CODE>quote_mark</CODE> = $<CODE>pre_types</CODE>[$<CODE>j</CODE>];
            for ( my $<CODE>k</CODE> = $<CODE>j</CODE> + 1 ; $<CODE>k</CODE> < $#<CODE>pre_types</CODE> ; $<CODE>k</CODE>++ ) {
                if ( $<CODE>pre_types</CODE>[$<CODE>k</CODE>] eq $<CODE>quote_mark</CODE> ) {
                    $<CODE>j</CODE> = $<CODE>k</CODE> + 1;
                    my $<CODE>next</CODE> = $<CODE>pre_types</CODE>[$<CODE>j</CODE>];
                    last;
                }
            }
        }
        elsif ( $<CODE>pre_types</CODE>[$<CODE>j</CODE>] eq '<LITERALS>d</LITERALS>' ) {
            $<CODE>j</CODE>++;
        }
        elsif ( $<CODE>pre_types</CODE>[$<CODE>j</CODE>] eq '<LITERALS>w</LITERALS>' ) {
            $<CODE>j</CODE>++;
        }
        elsif ( $<CODE>pre_types</CODE>[$<CODE>j</CODE>] eq '-' && $<CODE>pre_types</CODE>[ ++$<CODE>j</CODE> ] eq '<LITERALS>w</LITERALS>' ) {
            $<CODE>j</CODE>++;
        }
        if ( $<CODE>j</CODE> > $<CODE>jbeg</CODE> ) {

            $<CODE>j</CODE>++ if $<CODE>pre_types</CODE>[$<CODE>j</CODE>] eq '<LITERALS>b</LITERALS>';

            # <COMMENTS>Patched</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>RT</COMMENTS> #<COMMENTS>95708</COMMENTS>
            if (

                # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comma</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>delimeter</COMMENTS> <COMMENTS>except</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>qw</COMMENTS>
                (
                       $<CODE>pre_types</CODE>[$<CODE>j</CODE>] eq ','
                    && $<CODE>pre_tokens</CODE>[$<CODE>jbeg</CODE>] !~ /^(s|m|y|tr|qr|q|qq|qx)$/
                )

                # <COMMENTS>or</COMMENTS> <COMMENTS>a</COMMENTS> =>
                || ( $<CODE>pre_types</CODE>[$<CODE>j</CODE>] eq '=' && $<CODE>pre_types</CODE>[ ++$<CODE>j</CODE> ] eq '>' )
              )
            {
                $<CODE>code_block_type</CODE> = "";
            }
        }
    }

    return $<CODE>code_block_type</CODE>;
}

sub <CODE>unexpected</CODE> {

    # <COMMENTS>report</COMMENTS> <COMMENTS>unexpected</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>show</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS>
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$tokenizer_self</COMMENTS>
    my ( $<CODE>found</CODE>, $<CODE>expecting</CODE>, $<CODE>i_tok</CODE>, $<CODE>last_nonblank_i</CODE>, $<CODE>rpretoken_map</CODE>,
        $<CODE>rpretoken_type</CODE>, $<CODE>input_line</CODE> )
      = @<CODE>_</CODE>;

    if ( ++$<CODE>tokenizer_self</CODE>->{<LITERALS>_unexpected_error_count</LITERALS>} <= <CODE>MAX_NAG_MESSAGES</CODE> ) {
        my $<CODE>msg</CODE> = "<LITERALS>found</LITERALS> $<CODE>found</CODE> <LITERALS>where</LITERALS> $<CODE>expecting</CODE> <LITERALS>expected</LITERALS>";
        my $<CODE>pos</CODE> = $$<CODE>rpretoken_map</CODE>[$<CODE>i_tok</CODE>];
        <CODE>interrupt_logfile</CODE>();
        my $<CODE>input_line_number</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_last_line_number</LITERALS>};
        my ( $<CODE>offset</CODE>, $<CODE>numbered_line</CODE>, $<CODE>underline</CODE> ) =
          <CODE>make_numbered_line</CODE>( $<CODE>input_line_number</CODE>, $<CODE>input_line</CODE>, $<CODE>pos</CODE> );
        $<CODE>underline</CODE> = <CODE>write_on_underline</CODE>( $<CODE>underline</CODE>, $<CODE>pos</CODE> - $<CODE>offset</CODE>, '^' );

        my $<CODE>trailer</CODE> = "";
        if ( ( $<CODE>i_tok</CODE> > 0 ) && ( $<CODE>last_nonblank_i</CODE> >= 0 ) ) {
            my $<CODE>pos_prev</CODE> = $$<CODE>rpretoken_map</CODE>[$<CODE>last_nonblank_i</CODE>];
            my $<CODE>num</CODE>;
            if ( $$<CODE>rpretoken_type</CODE>[ $<CODE>i_tok</CODE> - 1 ] eq '<LITERALS>b</LITERALS>' ) {
                $<CODE>num</CODE> = $$<CODE>rpretoken_map</CODE>[ $<CODE>i_tok</CODE> - 1 ] - $<CODE>pos_prev</CODE>;
            }
            else {
                $<CODE>num</CODE> = $<CODE>pos</CODE> - $<CODE>pos_prev</CODE>;
            }
            if ( $<CODE>num</CODE> > 40 ) { $<CODE>num</CODE> = 40; $<CODE>pos_prev</CODE> = $<CODE>pos</CODE> - 40; }

            $<CODE>underline</CODE> =
              <CODE>write_on_underline</CODE>( $<CODE>underline</CODE>, $<CODE>pos_prev</CODE> - $<CODE>offset</CODE>, '-' x $<CODE>num</CODE> );
            $<CODE>trailer</CODE> = " (<LITERALS>previous</LITERALS> <LITERALS>token</LITERALS> <LITERALS>underlined</LITERALS>)";
        }
        <CODE>warning</CODE>( $<CODE>numbered_line</CODE> . "\n" );
        <CODE>warning</CODE>( $<CODE>underline</CODE> . "\n" );
        <CODE>warning</CODE>( $<CODE>msg</CODE> . $<CODE>trailer</CODE> . "\n" );
        <CODE>resume_logfile</CODE>();
    }
}

sub <CODE>is_non_structural_brace</CODE> {

    # <COMMENTS>Decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>bracket</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>structural</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS>
    # <COMMENTS>by</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>previous</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>type</COMMENTS>
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$last_nonblank_type</COMMENTS>, <COMMENTS>$last_nonblank_token</COMMENTS>

    # <COMMENTS>EXPERIMENTAL</COMMENTS>: <COMMENTS>Mark</COMMENTS> <COMMENTS>slices</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>structural</COMMENTS>; <COMMENTS>idea</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>improve</COMMENTS> <COMMENTS>formatting</COMMENTS>.
    # <COMMENTS>Tentatively</COMMENTS> <COMMENTS>deactivated</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>caused</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>wrong</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>expectation</COMMENTS>
    # <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>code</COMMENTS>:
    #      <COMMENTS>$user</COMMENTS> = @<COMMENTS>vars</COMMENTS>[<COMMENTS>1</COMMENTS>] / <COMMENTS>100</COMMENTS>;
    # <COMMENTS>Must</COMMENTS> <COMMENTS>update</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>operator_expected</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>re</COMMENTS>-<COMMENTS>implementing</COMMENTS>.
    # <COMMENTS>if</COMMENTS> ( <COMMENTS>$last_nonblank_type</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>i</COMMENTS>' && <COMMENTS>$last_nonblank_token</COMMENTS> =~ /^@/ ) {
    #    <COMMENTS>return</COMMENTS> <COMMENTS>0</COMMENTS>;
    # }

    ################################################################
    # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>braces</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>blocks</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>for</COMMENTS>
    # <COMMENTS>simplicity</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>identified</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>such</COMMENTS>.  <COMMENTS>See</COMMENTS> <COMMENTS>also</COMMENTS>
    # <COMMENTS>sub</COMMENTS> <COMMENTS>code_block_type</COMMENTS>
    ################################################################

    ##<COMMENTS>if</COMMENTS> (<COMMENTS>$last_nonblank_type</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>t</COMMENTS>') {<COMMENTS>return</COMMENTS> <COMMENTS>0</COMMENTS>}

    # <COMMENTS>otherwise</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>decorated</COMMENTS>
    # <COMMENTS>by</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>information</COMMENTS>.
    # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>the</COMMENTS> '{' <COMMENTS>here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS>:   <COMMENTS>$</COMMENTS>{<COMMENTS>xxx</COMMENTS>}
    (
        $<CODE>last_nonblank_token</CODE> =~ /^([\$\@\*\&\%\)]|->|::)/

          # <COMMENTS>or</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>bracket</COMMENTS>
          # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> '{' <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>structural</COMMENTS>: <COMMENTS>$a</COMMENTS>{'<COMMENTS>x</COMMENTS>'}{'<COMMENTS>y</COMMENTS>'}
          # <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> '}' <COMMENTS>would</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>R</COMMENTS>'
          || $<CODE>last_nonblank_type</CODE> =~ /^([R\]])$/
    );
}

#########<COMMENTS>i</COMMENTS>#############################################################
# <COMMENTS>Tokenizer</COMMENTS> <COMMENTS>routines</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>tracking</COMMENTS> <COMMENTS>container</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depths</COMMENTS>
#######################################################################

# <COMMENTS>The</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>routines</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>track</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depths</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>nesting</COMMENTS>
# <COMMENTS>types</COMMENTS>, ( [ { <COMMENTS>and</COMMENTS> ?.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>determining</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indentation</COMMENTS>
# <COMMENTS>level</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>debugging</COMMENTS> <COMMENTS>programs</COMMENTS>.  <COMMENTS>Not</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>track</COMMENTS> <COMMENTS>of</COMMENTS>
# <COMMENTS>nesting</COMMENTS> <COMMENTS>depths</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>individual</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>types</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>each</COMMENTS>
# <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>balanced</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>matching</COMMENTS> <COMMENTS>pairs</COMMENTS>.  <COMMENTS>For</COMMENTS>
# <COMMENTS>example</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>program</COMMENTS> <COMMENTS>sees</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>sequence</COMMENTS>:
#
#         {  ( ( ) }
#
# <COMMENTS>then</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>determine</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>extra</COMMENTS> <COMMENTS>left</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>somewhere</COMMENTS>
# <COMMENTS>between</COMMENTS> <COMMENTS>the</COMMENTS> { <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> }.  <COMMENTS>And</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>every</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>possible</COMMENTS>
# <COMMENTS>combination</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>outer</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>inner</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>types</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>another</COMMENTS>
# <COMMENTS>example</COMMENTS>:
#
#         ( [ ..... ]  ] )
#
# <COMMENTS>which</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>extra</COMMENTS> ] <COMMENTS>within</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>parens</COMMENTS>.
#
# <COMMENTS>The</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>0</COMMENTS> .. <COMMENTS>3</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>indexes</COMMENTS> <COMMENTS>into</COMMENTS>
# <COMMENTS>the</COMMENTS> <COMMENTS>matrices</COMMENTS>.
#
# <COMMENTS>The</COMMENTS> <COMMENTS>pair</COMMENTS> ? : <COMMENTS>are</COMMENTS> <COMMENTS>treated</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>type</COMMENTS>, <COMMENTS>with</COMMENTS> ? <COMMENTS>acting</COMMENTS>
# <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>and</COMMENTS> : <COMMENTS>acting</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>brace</COMMENTS>.
#
# <COMMENTS>The</COMMENTS> <COMMENTS>matrix</COMMENTS>
#
#         <COMMENTS>$depth_array</COMMENTS>[<COMMENTS>$a</COMMENTS>][<COMMENTS>$b</COMMENTS>][ <COMMENTS>$current_depth</COMMENTS>[<COMMENTS>$a</COMMENTS>] ] = <COMMENTS>$current_depth</COMMENTS>[<COMMENTS>$b</COMMENTS>];
#
# <COMMENTS>saves</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>$b</COMMENTS> (<COMMENTS>where</COMMENTS> <COMMENTS>$b</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>either</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>other</COMMENTS>
# <COMMENTS>nesting</COMMENTS> <COMMENTS>types</COMMENTS>) <COMMENTS>when</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>$a</COMMENTS> <COMMENTS>enters</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>depth</COMMENTS>.  <COMMENTS>When</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>depth</COMMENTS>
# <COMMENTS>decreases</COMMENTS>, <COMMENTS>a</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>made</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>depth</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>$b</COMMENTS> <COMMENTS>is</COMMENTS>
# <COMMENTS>unchanged</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>otherwise</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>can</COMMENTS>
# <COMMENTS>be</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>useful</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>localizing</COMMENTS> <COMMENTS>errors</COMMENTS>, <COMMENTS>particularly</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>runs</COMMENTS> <COMMENTS>to</COMMENTS>
# <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>large</COMMENTS> <COMMENTS>file</COMMENTS> (<COMMENTS>such</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>one</COMMENTS>) <COMMENTS>and</COMMENTS> <COMMENTS>announces</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>there</COMMENTS>
# <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>problem</COMMENTS> <COMMENTS>somewhere</COMMENTS>.
#
# <COMMENTS>A</COMMENTS> <COMMENTS>numerical</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>maintained</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>every</COMMENTS> <COMMENTS>nesting</COMMENTS> <COMMENTS>type</COMMENTS>,
# <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>matching</COMMENTS> <COMMENTS>pair</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>uniquely</COMMENTS> <COMMENTS>identified</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>simple</COMMENTS>
# <COMMENTS>way</COMMENTS>.

sub <CODE>increase_nesting_depth</CODE> {
    my ( $<CODE>aa</CODE>, $<CODE>pos</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$tokenizer_self</COMMENTS>, @<COMMENTS>current_depth</COMMENTS>,
    # @<COMMENTS>current_sequence_number</COMMENTS>, @<COMMENTS>depth_array</COMMENTS>, @<COMMENTS>starting_line_of_current_depth</COMMENTS>,
    # <COMMENTS>$statement_type</COMMENTS>
    my $<CODE>bb</CODE>;
    $<CODE>current_depth</CODE>[$<CODE>aa</CODE>]++;
    $<CODE>total_depth</CODE>++;
    $<CODE>total_depth</CODE>[$<CODE>aa</CODE>][ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ] = $<CODE>total_depth</CODE>;
    my $<CODE>input_line_number</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_last_line_number</LITERALS>};
    my $<CODE>input_line</CODE>        = $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_text</LITERALS>};

    # <COMMENTS>Sequence</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>increment</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>items</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>keeps</COMMENTS>
    # <COMMENTS>a</COMMENTS> <COMMENTS>unique</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>numbers</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>still</COMMENTS> <COMMENTS>allows</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>relative</COMMENTS> <COMMENTS>location</COMMENTS>
    # <COMMENTS>of</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>determined</COMMENTS>.
    $<CODE>nesting_sequence_number</CODE>[$<CODE>aa</CODE>] += scalar(@<CODE>closing_brace_names</CODE>);
    my $<CODE>seqno</CODE> = $<CODE>nesting_sequence_number</CODE>[$<CODE>aa</CODE>];
    $<CODE>current_sequence_number</CODE>[$<CODE>aa</CODE>][ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ] = $<CODE>seqno</CODE>;

    $<CODE>starting_line_of_current_depth</CODE>[$<CODE>aa</CODE>][ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ] =
      [ $<CODE>input_line_number</CODE>, $<CODE>input_line</CODE>, $<CODE>pos</CODE> ];

    for $<CODE>bb</CODE> ( 0 .. $#<CODE>closing_brace_names</CODE> ) {
        next if ( $<CODE>bb</CODE> == $<CODE>aa</CODE> );
        $<CODE>depth_array</CODE>[$<CODE>aa</CODE>][$<CODE>bb</CODE>][ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ] = $<CODE>current_depth</CODE>[$<CODE>bb</CODE>];
    }

    # <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>indenting</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>nested</COMMENTS> <COMMENTS>ternary</COMMENTS> <COMMENTS>statement</COMMENTS>
    my $<CODE>indent</CODE> = 0;
    if ( $<CODE>aa</CODE> == <CODE>QUESTION_COLON</CODE> ) {
        $<CODE>nested_ternary_flag</CODE>[ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ] = 0;
        if ( $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] > 1 ) {
            if ( $<CODE>nested_ternary_flag</CODE>[ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] - 1 ] == 0 ) {
                my $<CODE>pdepth</CODE> = $<CODE>total_depth</CODE>[$<CODE>aa</CODE>][ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] - 1 ];
                if ( $<CODE>pdepth</CODE> == $<CODE>total_depth</CODE> - 1 ) {
                    $<CODE>indent</CODE> = 1;
                    $<CODE>nested_ternary_flag</CODE>[ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] - 1 ] = -1;
                }
            }
        }
    }
    $<CODE>nested_statement_type</CODE>[$<CODE>aa</CODE>][ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ] = $<CODE>statement_type</CODE>;
    $<CODE>statement_type</CODE> = "";
    return ( $<CODE>seqno</CODE>, $<CODE>indent</CODE> );
}

sub <CODE>decrease_nesting_depth</CODE> {

    my ( $<CODE>aa</CODE>, $<CODE>pos</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$tokenizer_self</COMMENTS>, @<COMMENTS>current_depth</COMMENTS>,
    # @<COMMENTS>current_sequence_number</COMMENTS>, @<COMMENTS>depth_array</COMMENTS>, @<COMMENTS>starting_line_of_current_depth</COMMENTS>
    # <COMMENTS>$statement_type</COMMENTS>
    my $<CODE>bb</CODE>;
    my $<CODE>seqno</CODE>             = 0;
    my $<CODE>input_line_number</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_last_line_number</LITERALS>};
    my $<CODE>input_line</CODE>        = $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_text</LITERALS>};

    my $<CODE>outdent</CODE> = 0;
    $<CODE>total_depth</CODE>--;
    if ( $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] > 0 ) {

        # <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>un</COMMENTS>-<COMMENTS>indenting</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>seeing</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>nested</COMMENTS> <COMMENTS>ternary</COMMENTS> <COMMENTS>statement</COMMENTS>
        $<CODE>seqno</CODE> = $<CODE>current_sequence_number</CODE>[$<CODE>aa</CODE>][ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ];
        if ( $<CODE>aa</CODE> == <CODE>QUESTION_COLON</CODE> ) {
            $<CODE>outdent</CODE> = $<CODE>nested_ternary_flag</CODE>[ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ];
        }
        $<CODE>statement_type</CODE> = $<CODE>nested_statement_type</CODE>[$<CODE>aa</CODE>][ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ];

        # <COMMENTS>check</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>$bb</COMMENTS> <COMMENTS>contained</COMMENTS> <COMMENTS>within</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>balanced</COMMENTS>
        for $<CODE>bb</CODE> ( 0 .. $#<CODE>closing_brace_names</CODE> ) {
            next if ( $<CODE>bb</CODE> == $<CODE>aa</CODE> );

            unless ( $<CODE>depth_array</CODE>[$<CODE>aa</CODE>][$<CODE>bb</CODE>][ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ] ==
                $<CODE>current_depth</CODE>[$<CODE>bb</CODE>] )
            {
                my $<CODE>diff</CODE> =
                  $<CODE>current_depth</CODE>[$<CODE>bb</CODE>] -
                  $<CODE>depth_array</CODE>[$<CODE>aa</CODE>][$<CODE>bb</CODE>][ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ];

                # <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>whine</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>times</COMMENTS>
                my $<CODE>saw_brace_error</CODE> = <CODE>get_saw_brace_error</CODE>();
                if (
                    $<CODE>saw_brace_error</CODE> <= <CODE>MAX_NAG_MESSAGES</CODE>

                    # <COMMENTS>if</COMMENTS> <COMMENTS>too</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>occurred</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>probably</COMMENTS>
                    # <COMMENTS>already</COMMENTS> <COMMENTS>caught</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>error</COMMENTS>
                    && ( ( $<CODE>diff</CODE> > 0 ) || ( $<CODE>saw_brace_error</CODE> <= 0 ) )
                  )
                {
                    <CODE>interrupt_logfile</CODE>();
                    my $<CODE>rsl</CODE> =
                      $<CODE>starting_line_of_current_depth</CODE>[$<CODE>aa</CODE>]
                      [ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ];
                    my $<CODE>sl</CODE>  = $$<CODE>rsl</CODE>[0];
                    my $<CODE>rel</CODE> = [ $<CODE>input_line_number</CODE>, $<CODE>input_line</CODE>, $<CODE>pos</CODE> ];
                    my $<CODE>el</CODE>  = $$<CODE>rel</CODE>[0];
                    my ($<CODE>ess</CODE>);

                    if ( $<CODE>diff</CODE> == 1 || $<CODE>diff</CODE> == -1 ) {
                        $<CODE>ess</CODE> = '';
                    }
                    else {
                        $<CODE>ess</CODE> = '<LITERALS>s</LITERALS>';
                    }
                    my $<CODE>bname</CODE> =
                      ( $<CODE>diff</CODE> > 0 )
                      ? $<CODE>opening_brace_names</CODE>[$<CODE>bb</CODE>]
                      : $<CODE>closing_brace_names</CODE>[$<CODE>bb</CODE>];
                    <CODE>write_error_indicator_pair</CODE>( @$<CODE>rsl</CODE>, '^' );
                    my $<CODE>msg</CODE> = <<"<LITERALS>EOM</LITERALS>";
<LITERALS>Found</LITERALS> $<CODE>diff</CODE> <LITERALS>extra</LITERALS> $<CODE>bname</CODE>$<CODE>ess</CODE> <LITERALS>between</LITERALS> $<CODE>opening_brace_names</CODE>[$<CODE>aa</CODE>] <LITERALS>on</LITERALS> <LITERALS>line</LITERALS> $<CODE>sl</CODE> <LITERALS>and</LITERALS> $<CODE>closing_brace_names</CODE>[$<CODE>aa</CODE>] <LITERALS>on</LITERALS> <LITERALS>line</LITERALS> $<CODE>el</CODE>
<CODE>EOM</CODE>

                    if ( $<CODE>diff</CODE> > 0 ) {
                        my $<CODE>rml</CODE> =
                          $<CODE>starting_line_of_current_depth</CODE>[$<CODE>bb</CODE>]
                          [ $<CODE>current_depth</CODE>[$<CODE>bb</CODE>] ];
                        my $<CODE>ml</CODE> = $$<CODE>rml</CODE>[0];
                        $<CODE>msg</CODE> .=
"    <LITERALS>The</LITERALS> <LITERALS>most</LITERALS> <LITERALS>recent</LITERALS> <LITERALS>un</LITERALS>-<LITERALS>matched</LITERALS> $<CODE>bname</CODE> <LITERALS>is</LITERALS> <LITERALS>on</LITERALS> <LITERALS>line</LITERALS> $<CODE>ml</CODE>\n";
                        <CODE>write_error_indicator_pair</CODE>( @$<CODE>rml</CODE>, '^' );
                    }
                    <CODE>write_error_indicator_pair</CODE>( @$<CODE>rel</CODE>, '^' );
                    <CODE>warning</CODE>($<CODE>msg</CODE>);
                    <CODE>resume_logfile</CODE>();
                }
                <CODE>increment_brace_error</CODE>();
            }
        }
        $<CODE>current_depth</CODE>[$<CODE>aa</CODE>]--;
    }
    else {

        my $<CODE>saw_brace_error</CODE> = <CODE>get_saw_brace_error</CODE>();
        if ( $<CODE>saw_brace_error</CODE> <= <CODE>MAX_NAG_MESSAGES</CODE> ) {
            my $<CODE>msg</CODE> = <<"<LITERALS>EOM</LITERALS>";
<LITERALS>There</LITERALS> <LITERALS>is</LITERALS> <LITERALS>no</LITERALS> <LITERALS>previous</LITERALS> $<CODE>opening_brace_names</CODE>[$<CODE>aa</CODE>] <LITERALS>to</LITERALS> <LITERALS>match</LITERALS> <LITERALS>a</LITERALS> $<CODE>closing_brace_names</CODE>[$<CODE>aa</CODE>] <LITERALS>on</LITERALS> <LITERALS>line</LITERALS> $<CODE>input_line_number</CODE>
<CODE>EOM</CODE>
            <CODE>indicate_error</CODE>( $<CODE>msg</CODE>, $<CODE>input_line_number</CODE>, $<CODE>input_line</CODE>, $<CODE>pos</CODE>, '^' );
        }
        <CODE>increment_brace_error</CODE>();
    }
    return ( $<CODE>seqno</CODE>, $<CODE>outdent</CODE> );
}

sub <CODE>check_final_nesting_depths</CODE> {
    my ($<CODE>aa</CODE>);

    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: @<COMMENTS>current_depth</COMMENTS>, @<COMMENTS>starting_line_of_current_depth</COMMENTS>

    for $<CODE>aa</CODE> ( 0 .. $#<CODE>closing_brace_names</CODE> ) {

        if ( $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ) {
            my $<CODE>rsl</CODE> =
              $<CODE>starting_line_of_current_depth</CODE>[$<CODE>aa</CODE>][ $<CODE>current_depth</CODE>[$<CODE>aa</CODE>] ];
            my $<CODE>sl</CODE>  = $$<CODE>rsl</CODE>[0];
            my $<CODE>msg</CODE> = <<"<LITERALS>EOM</LITERALS>";
<LITERALS>Final</LITERALS> <LITERALS>nesting</LITERALS> <LITERALS>depth</LITERALS> <LITERALS>of</LITERALS> $<CODE>opening_brace_names</CODE>[$<CODE>aa</CODE>]<LITERALS>s</LITERALS> <LITERALS>is</LITERALS> $<CODE>current_depth</CODE>[$<CODE>aa</CODE>]
<LITERALS>The</LITERALS> <LITERALS>most</LITERALS> <LITERALS>recent</LITERALS> <LITERALS>un</LITERALS>-<LITERALS>matched</LITERALS> $<CODE>opening_brace_names</CODE>[$<CODE>aa</CODE>] <LITERALS>is</LITERALS> <LITERALS>on</LITERALS> <LITERALS>line</LITERALS> $<CODE>sl</CODE>
<CODE>EOM</CODE>
            <CODE>indicate_error</CODE>( $<CODE>msg</CODE>, @$<CODE>rsl</CODE>, '^' );
            <CODE>increment_brace_error</CODE>();
        }
    }
}

#########<COMMENTS>i</COMMENTS>#############################################################
# <COMMENTS>Tokenizer</COMMENTS> <COMMENTS>routines</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>ahead</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>stream</COMMENTS>
#######################################################################

sub <CODE>peek_ahead_for_n_nonblank_pre_tokens</CODE> {

    # <COMMENTS>returns</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>n</COMMENTS> <COMMENTS>pretokens</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>exist</COMMENTS>
    # <COMMENTS>returns</COMMENTS> <COMMENTS>undef</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>hits</COMMENTS> <COMMENTS>eof</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>seeing</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>pretokens</COMMENTS>
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$tokenizer_self</COMMENTS>
    my $<CODE>max_pretokens</CODE> = shift;
    my $<CODE>line</CODE>;
    my $<CODE>i</CODE> = 0;
    my ( $<CODE>rpre_tokens</CODE>, $<CODE>rmap</CODE>, $<CODE>rpre_types</CODE> );

    while ( $<CODE>line</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_buffer_object</LITERALS>}-><CODE>peek_ahead</CODE>( $<CODE>i</CODE>++ ) )
    {
        $<CODE>line</CODE> =~ s/^\s*//;    # <COMMENTS>trim</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>blanks</COMMENTS>
        next if ( length($<CODE>line</CODE>) <= 0 );    # <COMMENTS>skip</COMMENTS> <COMMENTS>blank</COMMENTS>
        next if ( $<CODE>line</CODE> =~ /^#/ );         # <COMMENTS>skip</COMMENTS> <COMMENTS>comment</COMMENTS>
        ( $<CODE>rpre_tokens</CODE>, $<CODE>rmap</CODE>, $<CODE>rpre_types</CODE> ) =
          <CODE>pre_tokenize</CODE>( $<CODE>line</CODE>, $<CODE>max_pretokens</CODE> );
        last;
    }
    return ( $<CODE>rpre_tokens</CODE>, $<CODE>rpre_types</CODE> );
}

# <COMMENTS>look</COMMENTS> <COMMENTS>ahead</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS>, <COMMENTS>non</COMMENTS>-<COMMENTS>comment</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>code</COMMENTS>
sub <CODE>peek_ahead_for_nonblank_token</CODE> {

    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$tokenizer_self</COMMENTS>
    my ( $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>line</CODE>;
    my $<CODE>i</CODE> = 0;

    while ( $<CODE>line</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_buffer_object</LITERALS>}-><CODE>peek_ahead</CODE>( $<CODE>i</CODE>++ ) )
    {
        $<CODE>line</CODE> =~ s/^\s*//;    # <COMMENTS>trim</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>blanks</COMMENTS>
        next if ( length($<CODE>line</CODE>) <= 0 );    # <COMMENTS>skip</COMMENTS> <COMMENTS>blank</COMMENTS>
        next if ( $<CODE>line</CODE> =~ /^#/ );         # <COMMENTS>skip</COMMENTS> <COMMENTS>comment</COMMENTS>
        my ( $<CODE>rtok</CODE>, $<CODE>rmap</CODE>, $<CODE>rtype</CODE> ) =
          <CODE>pre_tokenize</CODE>( $<CODE>line</CODE>, 2 );        # <COMMENTS>only</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>tokens</COMMENTS>
        my $<CODE>j</CODE> = $<CODE>max_token_index</CODE> + 1;
        my $<CODE>tok</CODE>;

        foreach $<CODE>tok</CODE> (@$<CODE>rtok</CODE>) {
            last if ( $<CODE>tok</CODE> =~ "\n" );
            $$<CODE>rtokens</CODE>[ ++$<CODE>j</CODE> ] = $<CODE>tok</CODE>;
        }
        last;
    }
    return $<CODE>rtokens</CODE>;
}

#########<COMMENTS>i</COMMENTS>#############################################################
# <COMMENTS>Tokenizer</COMMENTS> <COMMENTS>guessing</COMMENTS> <COMMENTS>routines</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>ambiguous</COMMENTS> <COMMENTS>situations</COMMENTS>
#######################################################################

sub <CODE>guess_if_pattern_or_conditional</CODE> {

    # <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>encountered</COMMENTS> <COMMENTS>a</COMMENTS> ? <COMMENTS>following</COMMENTS> <COMMENTS>an</COMMENTS>
    # <COMMENTS>unknown</COMMENTS> <COMMENTS>bareword</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>starts</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>not</COMMENTS>
    # <COMMENTS>input</COMMENTS> <COMMENTS>parameters</COMMENTS>:
    #   <COMMENTS>$i</COMMENTS> - <COMMENTS>token</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> ? <COMMENTS>starting</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>pattern</COMMENTS>
    # <COMMENTS>output</COMMENTS> <COMMENTS>parameters</COMMENTS>:
    #   <COMMENTS>$is_pattern</COMMENTS> = <COMMENTS>0</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>pattern</COMMENTS>,  =<COMMENTS>1</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS>
    #   <COMMENTS>msg</COMMENTS> = <COMMENTS>a</COMMENTS> <COMMENTS>warning</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>diagnostic</COMMENTS> <COMMENTS>message</COMMENTS>
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$last_nonblank_token</COMMENTS>
    my ( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>is_pattern</CODE> = 0;
    my $<CODE>msg</CODE>        = "<LITERALS>guessing</LITERALS> <LITERALS>that</LITERALS> ? <LITERALS>after</LITERALS> $<CODE>last_nonblank_token</CODE> <LITERALS>starts</LITERALS> <LITERALS>a</LITERALS> ";

    if ( $<CODE>i</CODE> >= $<CODE>max_token_index</CODE> ) {
        $<CODE>msg</CODE> .= "<LITERALS>conditional</LITERALS> (<LITERALS>no</LITERALS> <LITERALS>end</LITERALS> <LITERALS>to</LITERALS> <LITERALS>pattern</LITERALS> <LITERALS>found</LITERALS> <LITERALS>on</LITERALS> <LITERALS>the</LITERALS> <LITERALS>line</LITERALS>)\n";
    }
    else {
        my $<CODE>ibeg</CODE> = $<CODE>i</CODE>;
        $<CODE>i</CODE> = $<CODE>ibeg</CODE> + 1;
        my $<CODE>next_token</CODE> = $$<CODE>rtokens</CODE>[$<CODE>i</CODE>];    # <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>after</COMMENTS> ?

        # <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>ending</COMMENTS> ? <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>..
        my $<CODE>in_quote</CODE>        = 1;
        my $<CODE>quote_depth</CODE>     = 0;
        my $<CODE>quote_character</CODE> = '';
        my $<CODE>quote_pos</CODE>       = 0;
        my $<CODE>quoted_string</CODE>;
        (
            $<CODE>i</CODE>, $<CODE>in_quote</CODE>, $<CODE>quote_character</CODE>, $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>,
            $<CODE>quoted_string</CODE>
          )
          = <CODE>follow_quoted_string</CODE>( $<CODE>ibeg</CODE>, $<CODE>in_quote</CODE>, $<CODE>rtokens</CODE>, $<CODE>quote_character</CODE>,
            $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>, $<CODE>max_token_index</CODE> );

        if ($<CODE>in_quote</CODE>) {

            # <COMMENTS>we</COMMENTS> <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>ending</COMMENTS> ? <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>,
            # <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>bias</COMMENTS> <COMMENTS>towards</COMMENTS> <COMMENTS>conditional</COMMENTS>
            $<CODE>is_pattern</CODE> = 0;
            $<CODE>msg</CODE> .= "<LITERALS>conditional</LITERALS> (<LITERALS>no</LITERALS> <LITERALS>ending</LITERALS> ? <LITERALS>on</LITERALS> <LITERALS>this</LITERALS> <LITERALS>line</LITERALS>)\n";

            # <COMMENTS>we</COMMENTS> <COMMENTS>found</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>ending</COMMENTS> ?, <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>bias</COMMENTS> <COMMENTS>towards</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS>
        }
        else {

            if ( <CODE>pattern_expected</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> ) >= 0 ) {
                $<CODE>is_pattern</CODE> = 1;
                $<CODE>msg</CODE> .= "<LITERALS>pattern</LITERALS> (<LITERALS>found</LITERALS> <LITERALS>ending</LITERALS> ? <LITERALS>and</LITERALS> <LITERALS>pattern</LITERALS> <LITERALS>expected</LITERALS>)\n";
            }
            else {
                $<CODE>msg</CODE> .= "<LITERALS>pattern</LITERALS> (<LITERALS>uncertain</LITERALS>, <LITERALS>but</LITERALS> <LITERALS>found</LITERALS> <LITERALS>ending</LITERALS> ?)\n";
            }
        }
    }
    return ( $<CODE>is_pattern</CODE>, $<CODE>msg</CODE> );
}

sub <CODE>guess_if_pattern_or_division</CODE> {

    # <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>encountered</COMMENTS> <COMMENTS>a</COMMENTS> / <COMMENTS>following</COMMENTS> <COMMENTS>an</COMMENTS>
    # <COMMENTS>unknown</COMMENTS> <COMMENTS>bareword</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>decide</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>starts</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS>
    # <COMMENTS>division</COMMENTS>
    # <COMMENTS>input</COMMENTS> <COMMENTS>parameters</COMMENTS>:
    #   <COMMENTS>$i</COMMENTS> - <COMMENTS>token</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> / <COMMENTS>starting</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>pattern</COMMENTS>
    # <COMMENTS>output</COMMENTS> <COMMENTS>parameters</COMMENTS>:
    #   <COMMENTS>$is_pattern</COMMENTS> = <COMMENTS>0</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>division</COMMENTS>,  =<COMMENTS>1</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS>
    #   <COMMENTS>msg</COMMENTS> = <COMMENTS>a</COMMENTS> <COMMENTS>warning</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>diagnostic</COMMENTS> <COMMENTS>message</COMMENTS>
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$last_nonblank_token</COMMENTS>
    my ( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>is_pattern</CODE> = 0;
    my $<CODE>msg</CODE>        = "<LITERALS>guessing</LITERALS> <LITERALS>that</LITERALS> / <LITERALS>after</LITERALS> $<CODE>last_nonblank_token</CODE> <LITERALS>starts</LITERALS> <LITERALS>a</LITERALS> ";

    if ( $<CODE>i</CODE> >= $<CODE>max_token_index</CODE> ) {
        $<CODE>msg</CODE> .= "<LITERALS>division</LITERALS> (<LITERALS>no</LITERALS> <LITERALS>end</LITERALS> <LITERALS>to</LITERALS> <LITERALS>pattern</LITERALS> <LITERALS>found</LITERALS> <LITERALS>on</LITERALS> <LITERALS>the</LITERALS> <LITERALS>line</LITERALS>)\n";
    }
    else {
        my $<CODE>ibeg</CODE> = $<CODE>i</CODE>;
        my $<CODE>divide_expected</CODE> =
          <CODE>numerator_expected</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> );
        $<CODE>i</CODE> = $<CODE>ibeg</CODE> + 1;
        my $<CODE>next_token</CODE> = $$<CODE>rtokens</CODE>[$<CODE>i</CODE>];    # <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>slash</COMMENTS>

        # <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>ending</COMMENTS> / <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>..
        my $<CODE>in_quote</CODE>        = 1;
        my $<CODE>quote_depth</CODE>     = 0;
        my $<CODE>quote_character</CODE> = '';
        my $<CODE>quote_pos</CODE>       = 0;
        my $<CODE>quoted_string</CODE>;
        (
            $<CODE>i</CODE>, $<CODE>in_quote</CODE>, $<CODE>quote_character</CODE>, $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>,
            $<CODE>quoted_string</CODE>
          )
          = <CODE>follow_quoted_string</CODE>( $<CODE>ibeg</CODE>, $<CODE>in_quote</CODE>, $<CODE>rtokens</CODE>, $<CODE>quote_character</CODE>,
            $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>, $<CODE>max_token_index</CODE> );

        if ($<CODE>in_quote</CODE>) {

            # <COMMENTS>we</COMMENTS> <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>ending</COMMENTS> / <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS>,
            # <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>bias</COMMENTS> <COMMENTS>towards</COMMENTS> <COMMENTS>division</COMMENTS>
            if ( $<CODE>divide_expected</CODE> >= 0 ) {
                $<CODE>is_pattern</CODE> = 0;
                $<CODE>msg</CODE> .= "<LITERALS>division</LITERALS> (<LITERALS>no</LITERALS> <LITERALS>ending</LITERALS> / <LITERALS>on</LITERALS> <LITERALS>this</LITERALS> <LITERALS>line</LITERALS>)\n";
            }
            else {
                $<CODE>msg</CODE>        = "<LITERALS>multi</LITERALS>-<LITERALS>line</LITERALS> <LITERALS>pattern</LITERALS> (<LITERALS>division</LITERALS> <LITERALS>not</LITERALS> <LITERALS>possible</LITERALS>)\n";
                $<CODE>is_pattern</CODE> = 1;
            }

        }

        # <COMMENTS>we</COMMENTS> <COMMENTS>found</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>ending</COMMENTS> /, <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>bias</COMMENTS> <COMMENTS>towards</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS>
        else {

            if ( <CODE>pattern_expected</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> ) >= 0 ) {

                if ( $<CODE>divide_expected</CODE> >= 0 ) {

                    if ( $<CODE>i</CODE> - $<CODE>ibeg</CODE> > 60 ) {
                        $<CODE>msg</CODE> .= "<LITERALS>division</LITERALS> (<LITERALS>matching</LITERALS> / <LITERALS>too</LITERALS> <LITERALS>distant</LITERALS>)\n";
                        $<CODE>is_pattern</CODE> = 0;
                    }
                    else {
                        $<CODE>msg</CODE> .= "<LITERALS>pattern</LITERALS> (<LITERALS>but</LITERALS> <LITERALS>division</LITERALS> <LITERALS>possible</LITERALS> <LITERALS>too</LITERALS>)\n";
                        $<CODE>is_pattern</CODE> = 1;
                    }
                }
                else {
                    $<CODE>is_pattern</CODE> = 1;
                    $<CODE>msg</CODE> .= "<LITERALS>pattern</LITERALS> (<LITERALS>division</LITERALS> <LITERALS>not</LITERALS> <LITERALS>possible</LITERALS>)\n";
                }
            }
            else {

                if ( $<CODE>divide_expected</CODE> >= 0 ) {
                    $<CODE>is_pattern</CODE> = 0;
                    $<CODE>msg</CODE> .= "<LITERALS>division</LITERALS> (<LITERALS>pattern</LITERALS> <LITERALS>not</LITERALS> <LITERALS>possible</LITERALS>)\n";
                }
                else {
                    $<CODE>is_pattern</CODE> = 1;
                    $<CODE>msg</CODE> .=
                      "<LITERALS>pattern</LITERALS> (<LITERALS>uncertain</LITERALS>, <LITERALS>but</LITERALS> <LITERALS>division</LITERALS> <LITERALS>would</LITERALS> <LITERALS>not</LITERALS> <LITERALS>work</LITERALS> <LITERALS>here</LITERALS>)\n";
                }
            }
        }
    }
    return ( $<CODE>is_pattern</CODE>, $<CODE>msg</CODE> );
}

# <COMMENTS>try</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>resolve</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS> <COMMENTS>vs</COMMENTS>. <COMMENTS>shift</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>ahead</COMMENTS> <COMMENTS>for</COMMENTS>
# <COMMENTS>non</COMMENTS>-<COMMENTS>code</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>token</COMMENTS> (<COMMENTS>currently</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>token</COMMENTS>)
# <COMMENTS>returns</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>doc</COMMENTS>, <COMMENTS>0</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS>
sub <CODE>guess_if_here_doc</CODE> {

    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>how</COMMENTS> <COMMENTS>many</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>search</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>target</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>part</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS>
    # <COMMENTS>guessing</COMMENTS> <COMMENTS>strategy</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>constant</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>probably</COMMENTS>
    # <COMMENTS>little</COMMENTS> <COMMENTS>reason</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>change</COMMENTS> <COMMENTS>it</COMMENTS>.
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$tokenizer_self</COMMENTS>, <COMMENTS>$current_package</COMMENTS>
    # %<COMMENTS>is_constant</COMMENTS>,
    use <CODE>constant</CODE> <LITERALS>HERE_DOC_WINDOW</LITERALS> => 40;

    my $<CODE>next_token</CODE>        = shift;
    my $<CODE>here_doc_expected</CODE> = 0;
    my $<CODE>line</CODE>;
    my $<CODE>k</CODE>   = 0;
    my $<CODE>msg</CODE> = "<LITERALS>checking</LITERALS> <<";

    while ( $<CODE>line</CODE> = $<CODE>tokenizer_self</CODE>->{<LITERALS>_line_buffer_object</LITERALS>}-><CODE>peek_ahead</CODE>( $<CODE>k</CODE>++ ) )
    {
        chomp $<CODE>line</CODE>;

        if ( $<CODE>line</CODE> =~ /^$<CODE>next_token</CODE>$/ ) {
            $<CODE>msg</CODE> .= " -- <LITERALS>found</LITERALS> <LITERALS>target</LITERALS> $<CODE>next_token</CODE> <LITERALS>ahead</LITERALS> $<CODE>k</CODE> <LITERALS>lines</LITERALS>\n";
            $<CODE>here_doc_expected</CODE> = 1;    # <COMMENTS>got</COMMENTS> <COMMENTS>it</COMMENTS>
            last;
        }
        last if ( $<CODE>k</CODE> >= <CODE>HERE_DOC_WINDOW</CODE> );
    }

    unless ($<CODE>here_doc_expected</CODE>) {

        if ( !defined($<CODE>line</CODE>) ) {
            $<CODE>here_doc_expected</CODE> = -1;    # <COMMENTS>hit</COMMENTS> <COMMENTS>eof</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>seeing</COMMENTS> <COMMENTS>target</COMMENTS>
            $<CODE>msg</CODE> .= " -- <LITERALS>must</LITERALS> <LITERALS>be</LITERALS> <LITERALS>shift</LITERALS>; <LITERALS>target</LITERALS> $<CODE>next_token</CODE> <LITERALS>not</LITERALS> <LITERALS>in</LITERALS> <LITERALS>file</LITERALS>\n";

        }
        else {                          # <COMMENTS>still</COMMENTS> <COMMENTS>unsure</COMMENTS>..<COMMENTS>taking</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>wild</COMMENTS> <COMMENTS>guess</COMMENTS>

            if ( !$<CODE>is_constant</CODE>{$<CODE>current_package</CODE>}{$<CODE>next_token</CODE>} ) {
                $<CODE>here_doc_expected</CODE> = 1;
                $<CODE>msg</CODE> .=
                  " -- <LITERALS>guessing</LITERALS> <LITERALS>it</LITERALS>'<LITERALS>s</LITERALS> <LITERALS>a</LITERALS> <LITERALS>here</LITERALS>-<LITERALS>doc</LITERALS> ($<CODE>next_token</CODE> <LITERALS>not</LITERALS> <LITERALS>a</LITERALS> <LITERALS>constant</LITERALS>)\n";
            }
            else {
                $<CODE>msg</CODE> .=
                  " -- <LITERALS>guessing</LITERALS> <LITERALS>it</LITERALS>'<LITERALS>s</LITERALS> <LITERALS>a</LITERALS> <LITERALS>shift</LITERALS> ($<CODE>next_token</CODE> <LITERALS>is</LITERALS> <LITERALS>a</LITERALS> <LITERALS>constant</LITERALS>)\n";
            }
        }
    }
    <CODE>write_logfile_entry</CODE>($<CODE>msg</CODE>);
    return $<CODE>here_doc_expected</CODE>;
}

#########<COMMENTS>i</COMMENTS>#############################################################
# <COMMENTS>Tokenizer</COMMENTS> <COMMENTS>Routines</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>scanning</COMMENTS> <COMMENTS>identifiers</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>related</COMMENTS> <COMMENTS>items</COMMENTS>
#######################################################################

sub <CODE>scan_bare_identifier_do</CODE> {

    # <COMMENTS>this</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>scan</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>alphanumeric</COMMENTS>
    # <COMMENTS>variable</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>separator</COMMENTS>, :: <COMMENTS>or</COMMENTS> '.
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$current_package</COMMENTS>, <COMMENTS>$last_nonblank_token</COMMENTS>,
    # <COMMENTS>$last_nonblank_type</COMMENTS>,@<COMMENTS>paren_type</COMMENTS>, <COMMENTS>$paren_depth</COMMENTS>

    my ( $<CODE>input_line</CODE>, $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE>, $<CODE>prototype</CODE>, $<CODE>rtoken_map</CODE>,
        $<CODE>max_token_index</CODE> )
      = @<CODE>_</CODE>;
    my $<CODE>i_begin</CODE> = $<CODE>i</CODE>;
    my $<CODE>package</CODE> = undef;

    my $<CODE>i_beg</CODE> = $<CODE>i</CODE>;

    # <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>pretoken</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> :: <COMMENTS>since</COMMENTS> <COMMENTS>each</COMMENTS> : <COMMENTS>is</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>pretoken</COMMENTS>
    if ( $<CODE>tok</CODE> eq '::' ) { $<CODE>i_beg</CODE>-- }
    if ( $<CODE>tok</CODE> eq '->' ) { $<CODE>i_beg</CODE>-- }
    my $<CODE>pos_beg</CODE> = $$<CODE>rtoken_map</CODE>[$<CODE>i_beg</CODE>];
    pos($<CODE>input_line</CODE>) = $<CODE>pos_beg</CODE>;

    #  <COMMENTS>Examples</COMMENTS>:
    #   <COMMENTS>A</COMMENTS>::<COMMENTS>B</COMMENTS>::<COMMENTS>C</COMMENTS>
    #   <COMMENTS>A</COMMENTS>::
    #   ::<COMMENTS>A</COMMENTS>
    #   <COMMENTS>A</COMMENTS>'<COMMENTS>B</COMMENTS>
    if ( $<CODE>input_line</CODE> =~ m/\G\s*((?:\w*(?:'|::)))*(?:(?:->)?(\w+))?/gc ) {

        my $<CODE>pos</CODE>  = pos($<CODE>input_line</CODE>);
        my $<CODE>numc</CODE> = $<CODE>pos</CODE> - $<CODE>pos_beg</CODE>;
        $<CODE>tok</CODE> = substr( $<CODE>input_line</CODE>, $<CODE>pos_beg</CODE>, $<CODE>numc</CODE> );

        # <COMMENTS>type</COMMENTS> '<COMMENTS>w</COMMENTS>' <COMMENTS>includes</COMMENTS> <COMMENTS>anything</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>info</COMMENTS>
        # (<COMMENTS>$</COMMENTS>,%,@,*) <COMMENTS>including</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>abc</COMMENTS>::<COMMENTS>def</COMMENTS>::<COMMENTS>ghi</COMMENTS>
        $<CODE>type</CODE> = '<LITERALS>w</LITERALS>';

        my $<CODE>sub_name</CODE> = "";
        if ( defined($<CODE>2</CODE>) ) { $<CODE>sub_name</CODE> = $<CODE>2</CODE>; }
        if ( defined($<CODE>1</CODE>) ) {
            $<CODE>package</CODE> = $<CODE>1</CODE>;

            # <COMMENTS>patch</COMMENTS>: <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>isolated</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>ends</COMMENTS>
            # <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>style</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>separator</COMMENTS> (<COMMENTS>single</COMMENTS> <COMMENTS>quote</COMMENTS>).  <COMMENTS>Example</COMMENTS>:
            #   <COMMENTS>use</COMMENTS> <COMMENTS>CGI</COMMENTS>':<COMMENTS>all</COMMENTS>';
            if ( !($<CODE>sub_name</CODE>) && substr( $<CODE>package</CODE>, -1, 1 ) eq '\'' ) {
                $<CODE>pos</CODE>--;
            }

            $<CODE>package</CODE> =~ s/\'/::/g;
            if ( $<CODE>package</CODE> =~ /^\:/ ) { $<CODE>package</CODE> = '<LITERALS>main</LITERALS>' . $<CODE>package</CODE> }
            $<CODE>package</CODE> =~ s/::$//;
        }
        else {
            $<CODE>package</CODE> = $<CODE>current_package</CODE>;

            if ( $<CODE>is_keyword</CODE>{$<CODE>tok</CODE>} ) {
                $<CODE>type</CODE> = '<LITERALS>k</LITERALS>';
            }
        }

        # <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bareword</COMMENTS>..
        if ( $<CODE>type</CODE> eq '<LITERALS>w</LITERALS>' ) {

            # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>string</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> '<COMMENTS>v</COMMENTS>' <COMMENTS>type</COMMENTS> <COMMENTS>character</COMMENTS>
            # (<COMMENTS>This</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>precedence</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>filehandle</COMMENTS>, <COMMENTS>type</COMMENTS> '<COMMENTS>Y</COMMENTS>')
            if ( $<CODE>tok</CODE> =~ /^v\d[_\d]*$/ ) {

                # <COMMENTS>we</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>part</COMMENTS> - <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> '<COMMENTS>v101</COMMENTS>' -
                # <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>more</COMMENTS>
                if ( $<CODE>input_line</CODE> =~ m/\G(\.\d[_\d]*)+/gc ) {
                    $<CODE>pos</CODE>  = pos($<CODE>input_line</CODE>);
                    $<CODE>numc</CODE> = $<CODE>pos</CODE> - $<CODE>pos_beg</CODE>;
                    $<CODE>tok</CODE>  = substr( $<CODE>input_line</CODE>, $<CODE>pos_beg</CODE>, $<CODE>numc</CODE> );
                }
                $<CODE>type</CODE> = '<LITERALS>v</LITERALS>';

                # <COMMENTS>warn</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS>
                <CODE>report_v_string</CODE>($<CODE>tok</CODE>);
            }

            elsif ( $<CODE>is_constant</CODE>{$<CODE>package</CODE>}{$<CODE>sub_name</CODE>} ) {
                $<CODE>type</CODE> = '<LITERALS>C</LITERALS>';
            }

            # <COMMENTS>bareword</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>sort</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>implied</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>prototype</COMMENTS>; <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>:
            # @<COMMENTS>sorted</COMMENTS> = <COMMENTS>sort</COMMENTS> <COMMENTS>numerically</COMMENTS> ( <COMMENTS>53</COMMENTS>, <COMMENTS>29</COMMENTS>, <COMMENTS>11</COMMENTS>, <COMMENTS>32</COMMENTS>, <COMMENTS>7</COMMENTS> );
            # <COMMENTS>This</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>priority</COMMENTS> <COMMENTS>over</COMMENTS> <COMMENTS>whatever</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>specified</COMMENTS>.
            elsif ($<CODE>last_nonblank_token</CODE> eq '<LITERALS>sort</LITERALS>'
                && $<CODE>last_nonblank_type</CODE> eq '<LITERALS>k</LITERALS>' )
            {
                $<CODE>type</CODE> = '<LITERALS>Z</LITERALS>';
            }

            # <COMMENTS>Note</COMMENTS>: <COMMENTS>strangely</COMMENTS>, <COMMENTS>perl</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>seem</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>create</COMMENTS>
            # <COMMENTS>functions</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>act</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>eval</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>do</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>sense</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>eval</COMMENTS>
            # <COMMENTS>and</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>operators</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>final</COMMENTS> }, <COMMENTS>but</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>operators</COMMENTS>
            # <COMMENTS>that</COMMENTS> <COMMENTS>you</COMMENTS> <COMMENTS>create</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>prototype</COMMENTS> (&) <COMMENTS>apparently</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>allow</COMMENTS>
            # <COMMENTS>trailing</COMMENTS> <COMMENTS>operators</COMMENTS>, <COMMENTS>only</COMMENTS> <COMMENTS>terms</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>strange</COMMENTS>.
            # <COMMENTS>If</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>ever</COMMENTS> <COMMENTS>changes</COMMENTS>, <COMMENTS>here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>update</COMMENTS>
            # <COMMENTS>to</COMMENTS> <COMMENTS>make</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>behave</COMMENTS> <COMMENTS>accordingly</COMMENTS>:

            # <COMMENTS>elsif</COMMENTS> ( <COMMENTS>$is_block_function</COMMENTS>{<COMMENTS>$package</COMMENTS>}{<COMMENTS>$tok</COMMENTS>} ) {
            #    <COMMENTS>$tok</COMMENTS>='<COMMENTS>eval</COMMENTS>'; # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>eval</COMMENTS>  - <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS>
            #    <COMMENTS>$type</COMMENTS> = '<COMMENTS>k</COMMENTS>';
            #}
            # <COMMENTS>FIXME</COMMENTS>: <COMMENTS>This</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>become</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>different</COMMENTS>
            # <COMMENTS>future</COMMENTS> <COMMENTS>behavior</COMMENTS>:
            elsif ( $<CODE>is_block_function</CODE>{$<CODE>package</CODE>}{$<CODE>sub_name</CODE>} ) {
                $<CODE>type</CODE> = '<LITERALS>G</LITERALS>';
            }

            elsif ( $<CODE>is_block_list_function</CODE>{$<CODE>package</CODE>}{$<CODE>sub_name</CODE>} ) {
                $<CODE>type</CODE> = '<LITERALS>G</LITERALS>';
            }
            elsif ( $<CODE>is_user_function</CODE>{$<CODE>package</CODE>}{$<CODE>sub_name</CODE>} ) {
                $<CODE>type</CODE>      = '<LITERALS>U</LITERALS>';
                $<CODE>prototype</CODE> = $<CODE>user_function_prototype</CODE>{$<CODE>package</CODE>}{$<CODE>sub_name</CODE>};
            }

            # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>indirect</COMMENTS> <COMMENTS>object</COMMENTS>
            elsif (

                # <COMMENTS>added</COMMENTS> <COMMENTS>2001</COMMENTS>-<COMMENTS>03</COMMENTS>-<COMMENTS>27</COMMENTS>: <COMMENTS>must</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>immediately</COMMENTS> <COMMENTS>by</COMMENTS> '('
                # <COMMENTS>see</COMMENTS> <COMMENTS>fhandle</COMMENTS>.<COMMENTS>t</COMMENTS>
                ( $<CODE>input_line</CODE> !~ m/\G\(/gc )

                # <COMMENTS>and</COMMENTS>
                && (

                    # <COMMENTS>preceded</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>keyword</COMMENTS> <COMMENTS>like</COMMENTS> '<COMMENTS>print</COMMENTS>', '<COMMENTS>printf</COMMENTS>' <COMMENTS>and</COMMENTS> <COMMENTS>friends</COMMENTS>
                    $<CODE>is_indirect_object_taker</CODE>{$<CODE>last_nonblank_token</CODE>}

                    # <COMMENTS>or</COMMENTS> <COMMENTS>preceded</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> '<COMMENTS>print</COMMENTS>(' <COMMENTS>or</COMMENTS> '<COMMENTS>printf</COMMENTS>('
                    || (
                        ( $<CODE>last_nonblank_token</CODE> eq '(' )
                        && $<CODE>is_indirect_object_taker</CODE>{ $<CODE>paren_type</CODE>[$<CODE>paren_depth</CODE>]
                        }

                    )
                )
              )
            {

                # <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>indirect</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS>
                if ( $<CODE>input_line</CODE> =~ m/\G\s+/gc ) {
                    $<CODE>type</CODE> = '<LITERALS>Y</LITERALS>';

                    # <COMMENTS>Abandon</COMMENTS> <COMMENTS>Hope</COMMENTS> ...
                    # <COMMENTS>Perl</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>indirect</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>notation</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>very</COMMENTS> <COMMENTS>bad</COMMENTS>
                    # <COMMENTS>thing</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>cause</COMMENTS> <COMMENTS>subtle</COMMENTS> <COMMENTS>bugs</COMMENTS>, <COMMENTS>especially</COMMENTS> <COMMENTS>for</COMMENTS>
                    # <COMMENTS>beginning</COMMENTS> <COMMENTS>programmers</COMMENTS>.  <COMMENTS>And</COMMENTS> <COMMENTS>I</COMMENTS> <COMMENTS>haven</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>even</COMMENTS> <COMMENTS>been</COMMENTS>
                    # <COMMENTS>able</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>figure</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sane</COMMENTS> <COMMENTS>warning</COMMENTS> <COMMENTS>scheme</COMMENTS> <COMMENTS>which</COMMENTS>
                    # <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>way</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>scripts</COMMENTS>.

                    # <COMMENTS>Complain</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>filehandle</COMMENTS> <COMMENTS>has</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>lower</COMMENTS> <COMMENTS>case</COMMENTS>
                    # <COMMENTS>letters</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>suggested</COMMENTS> <COMMENTS>good</COMMENTS> <COMMENTS>practice</COMMENTS>.
                    # <COMMENTS>Use</COMMENTS> '<COMMENTS>sub_name</COMMENTS>' <COMMENTS>because</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS>
                    # <COMMENTS>main</COMMENTS>::<COMMENTS>MYHANDLE</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>filehandle</COMMENTS>
                    if ( $<CODE>sub_name</CODE> =~ /[a-z]/ ) {

                        # <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>bug</COMMENTS> <COMMENTS>caused</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>older</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>if</COMMENTS>
                        # <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> '('
                        if ( $<CODE>input_line</CODE> =~ m/\G\s*\(/gc ) {
                            <CODE>complain</CODE>(
"<LITERALS>Caution</LITERALS>: <LITERALS>unknown</LITERALS> <LITERALS>word</LITERALS> '$<CODE>tok</CODE>' <LITERALS>in</LITERALS> <LITERALS>indirect</LITERALS> <LITERALS>object</LITERALS> <LITERALS>slot</LITERALS>\n"
                            );
                        }
                    }
                }

                # <COMMENTS>bareword</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> -- <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>filehandle</COMMENTS>
                # (<COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>use</COMMENTS>' <COMMENTS>statement</COMMENTS>)
                else {
                    $<CODE>type</CODE> = '<LITERALS>Z</LITERALS>';
                }
            }
        }

        # <COMMENTS>Now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>convert</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>position</COMMENTS>
        # <COMMENTS>to</COMMENTS> <COMMENTS>pre_token</COMMENTS> <COMMENTS>index</COMMENTS>.
        # <COMMENTS>I</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>think</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>occur</COMMENTS> <COMMENTS>here</COMMENTS> ..<COMMENTS>but</COMMENTS> <COMMENTS>who</COMMENTS> <COMMENTS>knows</COMMENTS>
        my $<CODE>error</CODE>;
        ( $<CODE>i</CODE>, $<CODE>error</CODE> ) =
          <CODE>inverse_pretoken_map</CODE>( $<CODE>i</CODE>, $<CODE>pos</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>max_token_index</CODE> );
        if ($<CODE>error</CODE>) {
            <CODE>warning</CODE>("<LITERALS>scan_bare_identifier</LITERALS>: <LITERALS>Possibly</LITERALS> <LITERALS>invalid</LITERALS> <LITERALS>tokenization</LITERALS>\n");
        }
    }

    # <COMMENTS>no</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>blank</COMMENTS> - <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>error</COMMENTS>
    # <COMMENTS>perl</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>take</COMMENTS> '::' <COMMENTS>alone</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>complaint</COMMENTS>
    else {
        $<CODE>type</CODE> = '<LITERALS>w</LITERALS>';

        # <COMMENTS>change</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>warning</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>log</COMMENTS> <COMMENTS>message</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>becomes</COMMENTS> <COMMENTS>annoying</COMMENTS>
        <CODE>warning</CODE>("<LITERALS>didn</LITERALS>'<LITERALS>t</LITERALS> <LITERALS>find</LITERALS> <LITERALS>identifier</LITERALS> <LITERALS>after</LITERALS> <LITERALS>leading</LITERALS> ::\n");
    }
    return ( $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE>, $<CODE>prototype</CODE> );
}

sub <CODE>scan_id_do</CODE> {

# <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>scanner</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>eventually</COMMENTS> <COMMENTS>replace</COMMENTS> <COMMENTS>scan_identifier</COMMENTS>.
# <COMMENTS>Only</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>sub</COMMENTS>' <COMMENTS>and</COMMENTS> '<COMMENTS>package</COMMENTS>' <COMMENTS>are</COMMENTS> <COMMENTS>implemented</COMMENTS>.
# <COMMENTS>Token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>$</COMMENTS> * % @ & -> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>yet</COMMENTS> <COMMENTS>implemented</COMMENTS>.
#
# <COMMENTS>Scan</COMMENTS> <COMMENTS>identifier</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>token</COMMENTS>.
# <COMMENTS>The</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>depends</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>$id_scan_state</COMMENTS>: <COMMENTS>$id_scan_state</COMMENTS> = ''
# <COMMENTS>for</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>call</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>$tok</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>defining</COMMENTS>
# <COMMENTS>the</COMMENTS> <COMMENTS>type</COMMENTS>.
#
# <COMMENTS>If</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>a</COMMENTS> <COMMENTS>value</COMMENTS>
# <COMMENTS>of</COMMENTS> <COMMENTS>$id_scan_state</COMMENTS> = <COMMENTS>$tok</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>returned</COMMENTS>, <COMMENTS>indicating</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>further</COMMENTS>
# <COMMENTS>calls</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>made</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>identifier</COMMENTS>.  <COMMENTS>If</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>is</COMMENTS>
# <COMMENTS>not</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>the</COMMENTS> <COMMENTS>identifier</COMMENTS> <COMMENTS>is</COMMENTS>
# <COMMENTS>scanned</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>of</COMMENTS> '' <COMMENTS>is</COMMENTS> <COMMENTS>returned</COMMENTS>.
# <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$current_package</COMMENTS>, <COMMENTS>$last_nonblank_token</COMMENTS>, <COMMENTS>$in_attribute_list</COMMENTS>,
# <COMMENTS>$statement_type</COMMENTS>, <COMMENTS>$tokenizer_self</COMMENTS>

    my ( $<CODE>input_line</CODE>, $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>id_scan_state</CODE>,
        $<CODE>max_token_index</CODE> )
      = @<CODE>_</CODE>;
    my $<CODE>type</CODE> = '';
    my ( $<CODE>i_beg</CODE>, $<CODE>pos_beg</CODE> );

    #<COMMENTS>print</COMMENTS> "<COMMENTS>NSCAN</COMMENTS>:<COMMENTS>entering</COMMENTS> <COMMENTS>i</COMMENTS>=<COMMENTS>$i</COMMENTS>, <COMMENTS>tok</COMMENTS>=<COMMENTS>$tok</COMMENTS>, <COMMENTS>type</COMMENTS>=<COMMENTS>$type</COMMENTS>, <COMMENTS>state</COMMENTS>=<COMMENTS>$id_scan_state</COMMENTS>\<COMMENTS>n</COMMENTS>";
    #<COMMENTS>my</COMMENTS> (<COMMENTS>$a</COMMENTS>,<COMMENTS>$b</COMMENTS>,<COMMENTS>$c</COMMENTS>) = <COMMENTS>caller</COMMENTS>;
    #<COMMENTS>print</COMMENTS> "<COMMENTS>NSCAN</COMMENTS>: <COMMENTS>scan_id</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>tok</COMMENTS>=<COMMENTS>$tok</COMMENTS> <COMMENTS>$a</COMMENTS> <COMMENTS>$b</COMMENTS> <COMMENTS>$c</COMMENTS>\<COMMENTS>n</COMMENTS>";

    # <COMMENTS>on</COMMENTS> <COMMENTS>re</COMMENTS>-<COMMENTS>entry</COMMENTS>, <COMMENTS>start</COMMENTS> <COMMENTS>scanning</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>
    if ($<CODE>id_scan_state</CODE>) {
        $<CODE>i_beg</CODE> = $<CODE>i</CODE>;
        $<CODE>type</CODE>  = '';
    }

    # <COMMENTS>on</COMMENTS> <COMMENTS>initial</COMMENTS> <COMMENTS>entry</COMMENTS>, <COMMENTS>start</COMMENTS> <COMMENTS>scanning</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>token</COMMENTS>
    else {
        $<CODE>i_beg</CODE>         = $<CODE>i</CODE> + 1;
        $<CODE>id_scan_state</CODE> = $<CODE>tok</CODE>;
        $<CODE>type</CODE>          = '<LITERALS>t</LITERALS>';
    }

    # <COMMENTS>find</COMMENTS> <COMMENTS>$i_beg</COMMENTS> = <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>nonblank</COMMENTS> <COMMENTS>token</COMMENTS>,
    # <COMMENTS>and</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>lines</COMMENTS>
    my $<CODE>blank_line</CODE>          = 0;
    my $<CODE>next_nonblank_token</CODE> = $$<CODE>rtokens</CODE>[$<CODE>i_beg</CODE>];
    if ( $<CODE>i_beg</CODE> > $<CODE>max_token_index</CODE> ) {
        $<CODE>blank_line</CODE> = 1;
    }
    else {

        # <COMMENTS>only</COMMENTS> <COMMENTS>a</COMMENTS> '#' <COMMENTS>immediately</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>$</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comment</COMMENTS>
        if ( $<CODE>next_nonblank_token</CODE> eq '#' ) {
            unless ( $<CODE>tok</CODE> eq '<LITERALS>$</LITERALS>' ) {
                $<CODE>blank_line</CODE> = 1;
            }
        }

        if ( $<CODE>next_nonblank_token</CODE> =~ /^\s/ ) {
            ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_beg</CODE> ) =
              <CODE>find_next_nonblank_token_on_this_line</CODE>( $<CODE>i_beg</CODE>, $<CODE>rtokens</CODE>,
                $<CODE>max_token_index</CODE> );
            if ( $<CODE>next_nonblank_token</CODE> =~ /(^#|^\s*$)/ ) {
                $<CODE>blank_line</CODE> = 1;
            }
        }
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS>; <COMMENTS>identifier</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS>, <COMMENTS>must</COMMENTS> <COMMENTS>follow</COMMENTS>
    unless ($<CODE>blank_line</CODE>) {

        if ( $<CODE>id_scan_state</CODE> eq '<LITERALS>sub</LITERALS>' ) {
            ( $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE>, $<CODE>id_scan_state</CODE> ) = <CODE>do_scan_sub</CODE>(
                $<CODE>input_line</CODE>, $<CODE>i</CODE>,             $<CODE>i_beg</CODE>,
                $<CODE>tok</CODE>,        $<CODE>type</CODE>,          $<CODE>rtokens</CODE>,
                $<CODE>rtoken_map</CODE>, $<CODE>id_scan_state</CODE>, $<CODE>max_token_index</CODE>
            );
        }

        elsif ( $<CODE>id_scan_state</CODE> eq '<LITERALS>package</LITERALS>' ) {
            ( $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE> ) =
              <CODE>do_scan_package</CODE>( $<CODE>input_line</CODE>, $<CODE>i</CODE>, $<CODE>i_beg</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE>, $<CODE>rtokens</CODE>,
                $<CODE>rtoken_map</CODE>, $<CODE>max_token_index</CODE> );
            $<CODE>id_scan_state</CODE> = '';
        }

        else {
            <CODE>warning</CODE>("<LITERALS>invalid</LITERALS> <LITERALS>token</LITERALS> <LITERALS>in</LITERALS> <LITERALS>scan_id</LITERALS>: $<CODE>tok</CODE>\n");
            $<CODE>id_scan_state</CODE> = '';
        }
    }

    if ( $<CODE>id_scan_state</CODE> && ( !defined($<CODE>type</CODE>) || !$<CODE>type</CODE> ) ) {

        # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>:
        <CODE>warning</CODE>(
"<LITERALS>Program</LITERALS> <LITERALS>bug</LITERALS> <LITERALS>in</LITERALS> <LITERALS>scan_id</LITERALS>: <LITERALS>undefined</LITERALS> <LITERALS>type</LITERALS> <LITERALS>but</LITERALS> <LITERALS>scan_state</LITERALS>=$<CODE>id_scan_state</CODE>\n"
        );
        <CODE>report_definite_bug</CODE>();
    }

    <CODE>TOKENIZER_DEBUG_FLAG_NSCAN</CODE> && do {
        print <CODE>STDOUT</CODE>
          "<LITERALS>NSCAN</LITERALS>: <LITERALS>returns</LITERALS> <LITERALS>i</LITERALS>=$<CODE>i</CODE>, <LITERALS>tok</LITERALS>=$<CODE>tok</CODE>, <LITERALS>type</LITERALS>=$<CODE>type</CODE>, <LITERALS>state</LITERALS>=$<CODE>id_scan_state</CODE>\n";
    };
    return ( $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE>, $<CODE>id_scan_state</CODE> );
}

sub <CODE>check_prototype</CODE> {
    my ( $<CODE>proto</CODE>, $<CODE>package</CODE>, $<CODE>subname</CODE> ) = @<CODE>_</CODE>;
    return unless ( defined($<CODE>package</CODE>) && defined($<CODE>subname</CODE>) );
    if ( defined($<CODE>proto</CODE>) ) {
        $<CODE>proto</CODE> =~ s/^\s*\(\s*//;
        $<CODE>proto</CODE> =~ s/\s*\)$//;
        if ($<CODE>proto</CODE>) {
            $<CODE>is_user_function</CODE>{$<CODE>package</CODE>}{$<CODE>subname</CODE>}        = 1;
            $<CODE>user_function_prototype</CODE>{$<CODE>package</CODE>}{$<CODE>subname</CODE>} = "($<CODE>proto</CODE>)";

            # <COMMENTS>prototypes</COMMENTS> <COMMENTS>containing</COMMENTS> '&' <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>treated</COMMENTS> <COMMENTS>specially</COMMENTS>..
            if ( $<CODE>proto</CODE> =~ /\&/ ) {

                # <COMMENTS>right</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>prototypes</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS>
                # '&' <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS>
                if ( $<CODE>proto</CODE> =~ /\&$/ ) {
                    $<CODE>is_block_function</CODE>{$<CODE>package</CODE>}{$<CODE>subname</CODE>} = 1;
                }

                # <COMMENTS>right</COMMENTS> <COMMENTS>curly</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>prototypes</COMMENTS> <COMMENTS>NOT</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS>
                # '&' <COMMENTS>may</COMMENTS> <COMMENTS>NOT</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS>
                elsif ( $<CODE>proto</CODE> !~ /\&$/ ) {
                    $<CODE>is_block_list_function</CODE>{$<CODE>package</CODE>}{$<CODE>subname</CODE>} = 1;
                }
            }
        }
        else {
            $<CODE>is_constant</CODE>{$<CODE>package</CODE>}{$<CODE>subname</CODE>} = 1;
        }
    }
    else {
        $<CODE>is_user_function</CODE>{$<CODE>package</CODE>}{$<CODE>subname</CODE>} = 1;
    }
}

sub <CODE>do_scan_package</CODE> {

    # <COMMENTS>do_scan_package</COMMENTS> <COMMENTS>parses</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>name</COMMENTS>
    # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>$i_beg</COMMENTS> <COMMENTS>equal</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>nonblank</COMMENTS>
    # <COMMENTS>token</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>package</COMMENTS>' <COMMENTS>token</COMMENTS>.
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$current_package</COMMENTS>,

    # <COMMENTS>package</COMMENTS> <COMMENTS>NAMESPACE</COMMENTS>
    # <COMMENTS>package</COMMENTS> <COMMENTS>NAMESPACE</COMMENTS> <COMMENTS>VERSION</COMMENTS>
    # <COMMENTS>package</COMMENTS> <COMMENTS>NAMESPACE</COMMENTS> <COMMENTS>BLOCK</COMMENTS>
    # <COMMENTS>package</COMMENTS> <COMMENTS>NAMESPACE</COMMENTS> <COMMENTS>VERSION</COMMENTS> <COMMENTS>BLOCK</COMMENTS>
    #
    # <COMMENTS>If</COMMENTS> <COMMENTS>VERSION</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>provided</COMMENTS>, <COMMENTS>package</COMMENTS> <COMMENTS>sets</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>$VERSION</COMMENTS> <COMMENTS>variable</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>given</COMMENTS>
    # <COMMENTS>namespace</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>VERSION</COMMENTS> <COMMENTS>provided</COMMENTS>. <COMMENTS>VERSION</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS>
    # <COMMENTS>a</COMMENTS> "<COMMENTS>strict</COMMENTS>" <COMMENTS>style</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>defined</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>module</COMMENTS>: <COMMENTS>a</COMMENTS>
    # <COMMENTS>positive</COMMENTS> <COMMENTS>decimal</COMMENTS> <COMMENTS>number</COMMENTS> (<COMMENTS>integer</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>decimal</COMMENTS>-<COMMENTS>fraction</COMMENTS>) <COMMENTS>without</COMMENTS>
    # <COMMENTS>exponentiation</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>else</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>dotted</COMMENTS>-<COMMENTS>decimal</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>string</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>leading</COMMENTS> '<COMMENTS>v</COMMENTS>'
    # <COMMENTS>character</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>three</COMMENTS> <COMMENTS>components</COMMENTS>.
    # <COMMENTS>reference</COMMENTS> <COMMENTS>http</COMMENTS>://<COMMENTS>perldoc</COMMENTS>.<COMMENTS>perl</COMMENTS>.<COMMENTS>org</COMMENTS>/<COMMENTS>functions</COMMENTS>/<COMMENTS>package</COMMENTS>.<COMMENTS>html</COMMENTS>

    my ( $<CODE>input_line</CODE>, $<CODE>i</CODE>, $<CODE>i_beg</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_map</CODE>,
        $<CODE>max_token_index</CODE> )
      = @<CODE>_</CODE>;
    my $<CODE>package</CODE> = undef;
    my $<CODE>pos_beg</CODE> = $$<CODE>rtoken_map</CODE>[$<CODE>i_beg</CODE>];
    pos($<CODE>input_line</CODE>) = $<CODE>pos_beg</CODE>;

    # <COMMENTS>handle</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS> <COMMENTS>line</COMMENTS>; <COMMENTS>package</COMMENTS> <COMMENTS>name</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS>, <COMMENTS>must</COMMENTS> <COMMENTS>follow</COMMENTS>
    if ( $<CODE>input_line</CODE> =~ m/\G\s*((?:\w*(?:'|::))*\w+)/gc ) {
        $<CODE>package</CODE> = $<CODE>1</CODE>;
        $<CODE>package</CODE> = ( defined($<CODE>1</CODE>) && $<CODE>1</CODE> ) ? $<CODE>1</CODE> : '<LITERALS>main</LITERALS>';
        $<CODE>package</CODE> =~ s/\'/::/g;
        if ( $<CODE>package</CODE> =~ /^\:/ ) { $<CODE>package</CODE> = '<LITERALS>main</LITERALS>' . $<CODE>package</CODE> }
        $<CODE>package</CODE> =~ s/::$//;
        my $<CODE>pos</CODE>  = pos($<CODE>input_line</CODE>);
        my $<CODE>numc</CODE> = $<CODE>pos</CODE> - $<CODE>pos_beg</CODE>;
        $<CODE>tok</CODE> = '<LITERALS>package</LITERALS> ' . substr( $<CODE>input_line</CODE>, $<CODE>pos_beg</CODE>, $<CODE>numc</CODE> );
        $<CODE>type</CODE> = '<LITERALS>i</LITERALS>';

        # <COMMENTS>Now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>convert</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>position</COMMENTS>
        # <COMMENTS>to</COMMENTS> <COMMENTS>pre_token</COMMENTS> <COMMENTS>index</COMMENTS>.
        # <COMMENTS>I</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>think</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>occur</COMMENTS> <COMMENTS>here</COMMENTS> ..<COMMENTS>but</COMMENTS> ?
        my $<CODE>error</CODE>;
        ( $<CODE>i</CODE>, $<CODE>error</CODE> ) =
          <CODE>inverse_pretoken_map</CODE>( $<CODE>i</CODE>, $<CODE>pos</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>max_token_index</CODE> );
        if ($<CODE>error</CODE>) { <CODE>warning</CODE>("<LITERALS>Possibly</LITERALS> <LITERALS>invalid</LITERALS> <LITERALS>package</LITERALS>\n") }
        $<CODE>current_package</CODE> = $<CODE>package</CODE>;

        # <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>now</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>NAMESPACE</COMMENTS>
        # <COMMENTS>now</COMMENTS> <COMMENTS>expecting</COMMENTS> <COMMENTS>VERSION</COMMENTS>, <COMMENTS>BLOCK</COMMENTS>, <COMMENTS>or</COMMENTS> ; <COMMENTS>to</COMMENTS> <COMMENTS>follow</COMMENTS> ...
        # <COMMENTS>package</COMMENTS> <COMMENTS>NAMESPACE</COMMENTS> <COMMENTS>VERSION</COMMENTS>
        # <COMMENTS>package</COMMENTS> <COMMENTS>NAMESPACE</COMMENTS> <COMMENTS>BLOCK</COMMENTS>
        # <COMMENTS>package</COMMENTS> <COMMENTS>NAMESPACE</COMMENTS> <COMMENTS>VERSION</COMMENTS> <COMMENTS>BLOCK</COMMENTS>
        my ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_next</CODE> ) =
          <CODE>find_next_nonblank_token</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> );

        # <COMMENTS>check</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>recognizable</COMMENTS> <COMMENTS>follows</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>parse</COMMENTS>.
        # <COMMENTS>A</COMMENTS> <COMMENTS>VERSION</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>parsed</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>string</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS>
        # <COMMENTS>normal</COMMENTS> <COMMENTS>way</COMMENTS>.  <COMMENTS>What</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>important</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>statement</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>if</COMMENTS>
        # <COMMENTS>everything</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>okay</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>operator_expected</COMMENTS>() <COMMENTS>routine</COMMENTS>
        # <COMMENTS>knows</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>statement</COMMENTS>.
        # <COMMENTS>Examples</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>primitive</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>are</COMMENTS>:
        #  <COMMENTS>1235</COMMENTS>  . ; { } <COMMENTS>v3</COMMENTS>  <COMMENTS>v</COMMENTS>
        if ( $<CODE>next_nonblank_token</CODE> =~ /^([v\.\d;\{\}])|v\d|\d+$/ ) {
            $<CODE>statement_type</CODE> = $<CODE>tok</CODE>;
        }
        else {
            <CODE>warning</CODE>(
                "<LITERALS>Unexpected</LITERALS> '$<CODE>next_nonblank_token</CODE>' <LITERALS>after</LITERALS> <LITERALS>package</LITERALS> <LITERALS>name</LITERALS> '$<CODE>tok</CODE>'\n"
            );
        }
    }

    # <COMMENTS>no</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>blank</COMMENTS> --
    # <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>label</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>package</COMMENTS>, <COMMENTS>like</COMMENTS> <COMMENTS>package</COMMENTS>:  , <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>.
    else {
        $<CODE>type</CODE> = '<LITERALS>k</LITERALS>';
    }

    return ( $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE> );
}

sub <CODE>scan_identifier_do</CODE> {

    # <COMMENTS>This</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>assembles</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>identifiers</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>maintains</COMMENTS> <COMMENTS>a</COMMENTS>
    # <COMMENTS>scan</COMMENTS> <COMMENTS>state</COMMENTS>, <COMMENTS>id_scan_state</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>updates</COMMENTS> <COMMENTS>id_scan_state</COMMENTS> <COMMENTS>based</COMMENTS> <COMMENTS>upon</COMMENTS>
    # <COMMENTS>current</COMMENTS> <COMMENTS>id_scan_state</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>returns</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>updated</COMMENTS>
    # <COMMENTS>id_scan_state</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>identifier</COMMENTS>.
    # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARIABLES</COMMENTS>: <COMMENTS>$context</COMMENTS>, <COMMENTS>$last_nonblank_token</COMMENTS>,
    # <COMMENTS>$last_nonblank_type</COMMENTS>

    my ( $<CODE>i</CODE>, $<CODE>id_scan_state</CODE>, $<CODE>identifier</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE>,
        $<CODE>expecting</CODE>, $<CODE>container_type</CODE> )
      = @<CODE>_</CODE>;
    my $<CODE>i_begin</CODE>   = $<CODE>i</CODE>;
    my $<CODE>type</CODE>      = '';
    my $<CODE>tok_begin</CODE> = $$<CODE>rtokens</CODE>[$<CODE>i_begin</CODE>];
    if ( $<CODE>tok_begin</CODE> eq ':' ) { $<CODE>tok_begin</CODE> = '::' }
    my $<CODE>id_scan_state_begin</CODE> = $<CODE>id_scan_state</CODE>;
    my $<CODE>identifier_begin</CODE>    = $<CODE>identifier</CODE>;
    my $<CODE>tok</CODE>                 = $<CODE>tok_begin</CODE>;
    my $<CODE>message</CODE>             = "";

    my $<CODE>in_prototype_or_signature</CODE> = $<CODE>container_type</CODE> =~ /^sub/;

    # <COMMENTS>these</COMMENTS> <COMMENTS>flags</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>help</COMMENTS> <COMMENTS>figure</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>type</COMMENTS>:
    my $<CODE>saw_alpha</CODE> = ( $<CODE>tok</CODE> =~ /^[A-Za-z_]/ );
    my $<CODE>saw_type</CODE>;

    # <COMMENTS>allow</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>separator</COMMENTS> (') <COMMENTS>except</COMMENTS> <COMMENTS>in</COMMENTS> '<COMMENTS>use</COMMENTS>' <COMMENTS>statement</COMMENTS>
    my $<CODE>allow_tick</CODE> = ( $<CODE>last_nonblank_token</CODE> ne '<LITERALS>use</LITERALS>' );

    # <COMMENTS>get</COMMENTS> <COMMENTS>started</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>defining</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>state</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>necessary</COMMENTS>
    unless ($<CODE>id_scan_state</CODE>) {
        $<CODE>context</CODE> = <CODE>UNKNOWN_CONTEXT</CODE>;

        # <COMMENTS>fixup</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>digraph</COMMENTS>
        if ( $<CODE>tok</CODE> eq '>' ) {
            $<CODE>tok</CODE>       = '->';
            $<CODE>tok_begin</CODE> = $<CODE>tok</CODE>;
        }
        $<CODE>identifier</CODE> = $<CODE>tok</CODE>;

        if ( $<CODE>tok</CODE> eq '<LITERALS>$</LITERALS>' || $<CODE>tok</CODE> eq '*' ) {
            $<CODE>id_scan_state</CODE> = '<LITERALS>$</LITERALS>';
            $<CODE>context</CODE>       = <CODE>SCALAR_CONTEXT</CODE>;
        }
        elsif ( $<CODE>tok</CODE> eq '%' || $<CODE>tok</CODE> eq '@' ) {
            $<CODE>id_scan_state</CODE> = '<LITERALS>$</LITERALS>';
            $<CODE>context</CODE>       = <CODE>LIST_CONTEXT</CODE>;
        }
        elsif ( $<CODE>tok</CODE> eq '&' ) {
            $<CODE>id_scan_state</CODE> = '&';
        }
        elsif ( $<CODE>tok</CODE> eq '<LITERALS>sub</LITERALS>' or $<CODE>tok</CODE> eq '<LITERALS>package</LITERALS>' ) {
            $<CODE>saw_alpha</CODE>     = 0;     # '<COMMENTS>sub</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>considered</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>info</COMMENTS> <COMMENTS>here</COMMENTS>
            $<CODE>id_scan_state</CODE> = '<LITERALS>$</LITERALS>';
            $<CODE>identifier</CODE> .= ' ';     # <COMMENTS>need</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>name</COMMENTS>
        }
        elsif ( $<CODE>tok</CODE> eq '::' ) {
            $<CODE>id_scan_state</CODE> = '<LITERALS>A</LITERALS>';
        }
        elsif ( $<CODE>tok</CODE> =~ /^[A-Za-z_]/ ) {
            $<CODE>id_scan_state</CODE> = ':';
        }
        elsif ( $<CODE>tok</CODE> eq '->' ) {
            $<CODE>id_scan_state</CODE> = '<LITERALS>$</LITERALS>';
        }
        else {

            # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>
            my ( $<CODE>a</CODE>, $<CODE>b</CODE>, $<CODE>c</CODE> ) = caller;
            <CODE>warning</CODE>("<LITERALS>Program</LITERALS> <LITERALS>Bug</LITERALS>: <LITERALS>scan_identifier</LITERALS> <LITERALS>given</LITERALS> <LITERALS>bad</LITERALS> <LITERALS>token</LITERALS> = $<CODE>tok</CODE> \n");
            <CODE>warning</CODE>("   <LITERALS>called</LITERALS> <LITERALS>from</LITERALS> <LITERALS>sub</LITERALS> $<CODE>a</CODE>  <LITERALS>line</LITERALS>: $<CODE>c</CODE>\n");
            <CODE>report_definite_bug</CODE>();
        }
        $<CODE>saw_type</CODE> = !$<CODE>saw_alpha</CODE>;
    }
    else {
        $<CODE>i</CODE>--;
        $<CODE>saw_type</CODE> = ( $<CODE>tok</CODE> =~ /([\$\%\@\*\&])/ );
    }

    # <COMMENTS>now</COMMENTS> <COMMENTS>loop</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>gather</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>identifier</COMMENTS>
    my $<CODE>i_save</CODE> = $<CODE>i</CODE>;

    while ( $<CODE>i</CODE> < $<CODE>max_token_index</CODE> ) {
        $<CODE>i_save</CODE> = $<CODE>i</CODE> unless ( $<CODE>tok</CODE> =~ /^\s*$/ );
        $<CODE>tok</CODE> = $$<CODE>rtokens</CODE>[ ++$<CODE>i</CODE> ];

        if ( ( $<CODE>tok</CODE> eq ':' ) && ( $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ] eq ':' ) ) {
            $<CODE>tok</CODE> = '::';
            $<CODE>i</CODE>++;
        }

        if ( $<CODE>id_scan_state</CODE> eq '<LITERALS>$</LITERALS>' ) {    # <COMMENTS>starting</COMMENTS> <COMMENTS>variable</COMMENTS> <COMMENTS>name</COMMENTS>

            if ( $<CODE>tok</CODE> eq '<LITERALS>$</LITERALS>' ) {

                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;

                # <COMMENTS>we</COMMENTS>'<COMMENTS>ve</COMMENTS> <COMMENTS>got</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>punctuation</COMMENTS> <COMMENTS>variable</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS> (<COMMENTS>punct</COMMENTS>.<COMMENTS>t</COMMENTS>)
                if ( $<CODE>i</CODE> == $<CODE>max_token_index</CODE> ) {
                    $<CODE>type</CODE>          = '<LITERALS>i</LITERALS>';
                    $<CODE>id_scan_state</CODE> = '';
                    last;
                }
            }

            # <COMMENTS>POSTDEFREF</COMMENTS> ->@ ->% ->& ->*
            elsif ( ( $<CODE>tok</CODE> =~ /^[\@\%\&\*]$/ ) && $<CODE>identifier</CODE> =~ /\-\>$/ ) {
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            elsif ( $<CODE>tok</CODE> =~ /^[A-Za-z_]/ ) {    # <COMMENTS>alphanumeric</COMMENTS> ..
                $<CODE>saw_alpha</CODE>     = 1;
                $<CODE>id_scan_state</CODE> = ':';           # <COMMENTS>now</COMMENTS> <COMMENTS>need</COMMENTS> ::
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            elsif ( $<CODE>tok</CODE> eq "'" && $<CODE>allow_tick</CODE> ) {    # <COMMENTS>alphanumeric</COMMENTS> ..
                $<CODE>saw_alpha</CODE>     = 1;
                $<CODE>id_scan_state</CODE> = ':';                 # <COMMENTS>now</COMMENTS> <COMMENTS>need</COMMENTS> ::
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;

                # <COMMENTS>Perl</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>accept</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>digits</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>identifiers</COMMENTS>,
                # <COMMENTS>although</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>always</COMMENTS> <COMMENTS>produce</COMMENTS> <COMMENTS>useful</COMMENTS> <COMMENTS>results</COMMENTS>.
                # <COMMENTS>Something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>$main</COMMENTS>::<COMMENTS>0</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>ok</COMMENTS>.  <COMMENTS>But</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>works</COMMENTS>:
                #
                #  <COMMENTS>sub</COMMENTS> <COMMENTS>howdy</COMMENTS>::<COMMENTS>123</COMMENTS>::<COMMENTS>bubba</COMMENTS>{ <COMMENTS>print</COMMENTS> "<COMMENTS>bubba</COMMENTS> <COMMENTS>$54321</COMMENTS>!\<COMMENTS>n</COMMENTS>" }
                #  <COMMENTS>howdy</COMMENTS>::<COMMENTS>123</COMMENTS>::<COMMENTS>bubba</COMMENTS>();
                #
            }
            elsif ( $<CODE>tok</CODE> =~ /^[0-9]/ ) {    # <COMMENTS>numeric</COMMENTS>
                $<CODE>saw_alpha</CODE>     = 1;
                $<CODE>id_scan_state</CODE> = ':';       # <COMMENTS>now</COMMENTS> <COMMENTS>need</COMMENTS> ::
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            elsif ( $<CODE>tok</CODE> eq '::' ) {
                $<CODE>id_scan_state</CODE> = '<LITERALS>A</LITERALS>';
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }

            # <COMMENTS>$</COMMENTS># <COMMENTS>and</COMMENTS> <COMMENTS>POSTDEFREF</COMMENTS> -><COMMENTS>$</COMMENTS>#
            elsif ( ( $<CODE>tok</CODE> eq '#' ) && ( $<CODE>identifier</CODE> =~ /\$$/ ) ) {    # <COMMENTS>$</COMMENTS>#<COMMENTS>array</COMMENTS>
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;    # <COMMENTS>keep</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>state</COMMENTS>, <COMMENTS>a</COMMENTS> <COMMENTS>$</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>follow</COMMENTS>
            }
            elsif ( $<CODE>tok</CODE> eq '{' ) {

                # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>$</COMMENTS>{#} <COMMENTS>or</COMMENTS> <COMMENTS>$</COMMENTS>{}
                ##<COMMENTS>if</COMMENTS> (   <COMMENTS>$identifier</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>$</COMMENTS>'
                if (
                    (
                           $<CODE>identifier</CODE> eq '<LITERALS>$</LITERALS>'
                        || $<CODE>identifier</CODE> eq '@'
                        || $<CODE>identifier</CODE> eq '<LITERALS>$</LITERALS>#'
                    )
                    && $<CODE>i</CODE> + 2 <= $<CODE>max_token_index</CODE>
                    && $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 2 ] eq '}'
                    && $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ] !~ /[\s\w]/
                  )
                {
                    my $<CODE>next2</CODE> = $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 2 ];
                    my $<CODE>next1</CODE> = $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ];
                    $<CODE>identifier</CODE> .= $<CODE>tok</CODE> . $<CODE>next1</CODE> . $<CODE>next2</CODE>;
                    $<CODE>i</CODE> += 2;
                    $<CODE>id_scan_state</CODE> = '';
                    last;
                }

                # <COMMENTS>skip</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>$</COMMENTS>{<COMMENTS>xxx</COMMENTS>} <COMMENTS>or</COMMENTS> ->{
                $<CODE>id_scan_state</CODE> = '';

                # <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>any</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>this</COMMENTS>
                # <COMMENTS>identifier</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>already</COMMENTS> <COMMENTS>been</COMMENTS> <COMMENTS>accumulated</COMMENTS>
                if ( $<CODE>identifier</CODE> eq '<LITERALS>$</LITERALS>' || $<CODE>i</CODE> == 0 ) { $<CODE>identifier</CODE> = ''; }
                $<CODE>i</CODE> = $<CODE>i_save</CODE>;
                last;
            }

            # <COMMENTS>space</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>$</COMMENTS> % * & @
            elsif ( $<CODE>tok</CODE> =~ /^\s*$/ ) {

                if ( $<CODE>identifier</CODE> =~ /^[\$\%\*\&\@]/ ) {

                    if ( length($<CODE>identifier</CODE>) > 1 ) {
                        $<CODE>id_scan_state</CODE> = '';
                        $<CODE>i</CODE>             = $<CODE>i_save</CODE>;
                        $<CODE>type</CODE>          = '<LITERALS>i</LITERALS>';    # <COMMENTS>probably</COMMENTS> <COMMENTS>punctuation</COMMENTS> <COMMENTS>variable</COMMENTS>
                        last;
                    }
                    else {

                        # <COMMENTS>spaces</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>$</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>common</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>after</COMMENTS> @
                        # <COMMENTS>is</COMMENTS> <COMMENTS>harmless</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>complain</COMMENTS> <COMMENTS>about</COMMENTS> <COMMENTS>space</COMMENTS>
                        # <COMMENTS>after</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>characters</COMMENTS>. <COMMENTS>Space</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>$</COMMENTS> <COMMENTS>and</COMMENTS>
                        # @ <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>removed</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>formatting</COMMENTS>.  <COMMENTS>Report</COMMENTS> <COMMENTS>space</COMMENTS>
                        # <COMMENTS>after</COMMENTS> % <COMMENTS>and</COMMENTS> * <COMMENTS>because</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>indicate</COMMENTS> <COMMENTS>a</COMMENTS>
                        # <COMMENTS>parsing</COMMENTS> <COMMENTS>error</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>words</COMMENTS> '% ' <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS>
                        # <COMMENTS>modulo</COMMENTS> <COMMENTS>operator</COMMENTS>.  <COMMENTS>Delete</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>warning</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS>
                        # <COMMENTS>gets</COMMENTS> <COMMENTS>annoying</COMMENTS>.
                        if ( $<CODE>identifier</CODE> !~ /^[\@\$]$/ ) {
                            $<CODE>message</CODE> =
                              "<LITERALS>Space</LITERALS> <LITERALS>in</LITERALS> <LITERALS>identifier</LITERALS>, <LITERALS>following</LITERALS> $<CODE>identifier</CODE>\n";
                        }
                    }
                }

                # <COMMENTS>else</COMMENTS>:
                # <COMMENTS>space</COMMENTS> <COMMENTS>after</COMMENTS> '->' <COMMENTS>is</COMMENTS> <COMMENTS>ok</COMMENTS>
            }
            elsif ( $<CODE>tok</CODE> eq '^' ) {

                # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>variables</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>$</COMMENTS>^<COMMENTS>W</COMMENTS>
                if ( $<CODE>identifier</CODE> =~ /^[\$\*\@\%]$/ ) {
                    $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                    $<CODE>id_scan_state</CODE> = '<LITERALS>A</LITERALS>';

                    # <COMMENTS>Perl</COMMENTS> <COMMENTS>accepts</COMMENTS> '<COMMENTS>$</COMMENTS>^]' <COMMENTS>or</COMMENTS> '@^]', <COMMENTS>but</COMMENTS>
                    # <COMMENTS>there</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>space</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> ']'.
                    my $<CODE>next1</CODE> = $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ];
                    if ( $<CODE>next1</CODE> eq ']' ) {
                        $<CODE>i</CODE>++;
                        $<CODE>identifier</CODE> .= $<CODE>next1</CODE>;
                        $<CODE>id_scan_state</CODE> = "";
                        last;
                    }
                }
                else {
                    $<CODE>id_scan_state</CODE> = '';
                }
            }
            else {    # <COMMENTS>something</COMMENTS> <COMMENTS>else</COMMENTS>

                if ( $<CODE>in_prototype_or_signature</CODE> && $<CODE>tok</CODE> =~ /^[\),=]/ ) {
                    $<CODE>id_scan_state</CODE> = '';
                    $<CODE>i</CODE>             = $<CODE>i_save</CODE>;
                    $<CODE>type</CODE>          = '<LITERALS>i</LITERALS>';       # <COMMENTS>probably</COMMENTS> <COMMENTS>punctuation</COMMENTS> <COMMENTS>variable</COMMENTS>
                    last;
                }

                # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>various</COMMENTS> <COMMENTS>punctuation</COMMENTS> <COMMENTS>variables</COMMENTS>
                if ( $<CODE>identifier</CODE> =~ /^[\$\*\@\%]$/ ) {
                    $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                }

                # <COMMENTS>POSTDEFREF</COMMENTS>: <COMMENTS>Postfix</COMMENTS> <COMMENTS>reference</COMMENTS> -><COMMENTS>$</COMMENTS>* ->%*  ->@* ->** ->&* -><COMMENTS>$</COMMENTS>#*
                elsif ( $<CODE>tok</CODE> eq '*' && $<CODE>identifier</CODE> =~ /([\@\%\$\*\&]|\$\#)$/ ) {
                    $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                }

                elsif ( $<CODE>identifier</CODE> eq '<LITERALS>$</LITERALS>#' ) {

                    if ( $<CODE>tok</CODE> eq '{' ) { $<CODE>type</CODE> = '<LITERALS>i</LITERALS>'; $<CODE>i</CODE> = $<CODE>i_save</CODE> }

                    # <COMMENTS>perl</COMMENTS> <COMMENTS>seems</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>these</COMMENTS>: <COMMENTS>$</COMMENTS>#: <COMMENTS>$</COMMENTS>#- <COMMENTS>$</COMMENTS>#+
                    elsif ( $<CODE>tok</CODE> =~ /^[\:\-\+]$/ ) {
                        $<CODE>type</CODE> = '<LITERALS>i</LITERALS>';
                        $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                    }
                    else {
                        $<CODE>i</CODE> = $<CODE>i_save</CODE>;
                        <CODE>write_logfile_entry</CODE>( '<LITERALS>Use</LITERALS> <LITERALS>of</LITERALS> <LITERALS>$</LITERALS># <LITERALS>is</LITERALS> <LITERALS>deprecated</LITERALS>' . "\n" );
                    }
                }
                elsif ( $<CODE>identifier</CODE> eq '<LITERALS>$$</LITERALS>' ) {

                    # <COMMENTS>perl</COMMENTS> <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>references</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>punctuation</COMMENTS>
                    # <COMMENTS>variables</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>braces</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>this</COMMENTS>
                    # <COMMENTS>won</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>work</COMMENTS>:
                    #  <COMMENTS>$</COMMENTS>:=\<COMMENTS>4</COMMENTS>;
                    #  <COMMENTS>$a</COMMENTS> = <COMMENTS>$$</COMMENTS>:;
                    # <COMMENTS>You</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>use</COMMENTS>
                    #  <COMMENTS>$a</COMMENTS> = <COMMENTS>$</COMMENTS>{<COMMENTS>$</COMMENTS>:};

                    $<CODE>i</CODE> = $<CODE>i_save</CODE>;
                    if   ( $<CODE>tok</CODE> eq '{' ) { $<CODE>type</CODE> = '<LITERALS>t</LITERALS>' }
                    else                 { $<CODE>type</CODE> = '<LITERALS>i</LITERALS>' }
                }
                elsif ( $<CODE>identifier</CODE> eq '->' ) {
                    $<CODE>i</CODE> = $<CODE>i_save</CODE>;
                }
                else {
                    $<CODE>i</CODE> = $<CODE>i_save</CODE>;
                    if ( length($<CODE>identifier</CODE>) == 1 ) { $<CODE>identifier</CODE> = ''; }
                }
                $<CODE>id_scan_state</CODE> = '';
                last;
            }
        }
        elsif ( $<CODE>id_scan_state</CODE> eq '&' ) {    # <COMMENTS>starting</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>call</COMMENTS>?

            if ( $<CODE>tok</CODE> =~ /^[\$A-Za-z_]/ ) {    # <COMMENTS>alphanumeric</COMMENTS> ..
                $<CODE>id_scan_state</CODE> = ':';          # <COMMENTS>now</COMMENTS> <COMMENTS>need</COMMENTS> ::
                $<CODE>saw_alpha</CODE>     = 1;
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            elsif ( $<CODE>tok</CODE> eq "'" && $<CODE>allow_tick</CODE> ) {    # <COMMENTS>alphanumeric</COMMENTS> ..
                $<CODE>id_scan_state</CODE> = ':';                 # <COMMENTS>now</COMMENTS> <COMMENTS>need</COMMENTS> ::
                $<CODE>saw_alpha</CODE>     = 1;
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            elsif ( $<CODE>tok</CODE> =~ /^[0-9]/ ) {    # <COMMENTS>numeric</COMMENTS>..<COMMENTS>see</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>above</COMMENTS>
                $<CODE>id_scan_state</CODE> = ':';       # <COMMENTS>now</COMMENTS> <COMMENTS>need</COMMENTS> ::
                $<CODE>saw_alpha</CODE>     = 1;
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            elsif ( $<CODE>tok</CODE> =~ /^\s*$/ ) {     # <COMMENTS>allow</COMMENTS> <COMMENTS>space</COMMENTS>
            }
            elsif ( $<CODE>tok</CODE> eq '::' ) {        # <COMMENTS>leading</COMMENTS> ::
                $<CODE>id_scan_state</CODE> = '<LITERALS>A</LITERALS>';       # <COMMENTS>accept</COMMENTS> <COMMENTS>alpha</COMMENTS> <COMMENTS>next</COMMENTS>
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            elsif ( $<CODE>tok</CODE> eq '{' ) {
                if ( $<CODE>identifier</CODE> eq '&' || $<CODE>i</CODE> == 0 ) { $<CODE>identifier</CODE> = ''; }
                $<CODE>i</CODE>             = $<CODE>i_save</CODE>;
                $<CODE>id_scan_state</CODE> = '';
                last;
            }
            else {

                # <COMMENTS>punctuation</COMMENTS> <COMMENTS>variable</COMMENTS>?
                # <COMMENTS>testfile</COMMENTS>: <COMMENTS>cunningham4</COMMENTS>.<COMMENTS>pl</COMMENTS>
                #
                # <COMMENTS>We</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>careful</COMMENTS> <COMMENTS>here</COMMENTS>.  <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>unknown</COMMENTS> <COMMENTS>state</COMMENTS>,
                # <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>reject</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>punctuation</COMMENTS> <COMMENTS>variable</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS>
                # <COMMENTS>example</COMMENTS> <COMMENTS>the</COMMENTS> '&' <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>binary</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>unknown</COMMENTS>
                # <COMMENTS>state</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>sigil</COMMENTS> <COMMENTS>on</COMMENTS> '<COMMENTS>Prima</COMMENTS>', <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS>
                # <COMMENTS>know</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS>.  <COMMENTS>But</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>guess</COMMENTS> <COMMENTS>that</COMMENTS>
                # '&~' <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>function</COMMENTS> <COMMENTS>variable</COMMENTS>.
                # <COMMENTS>$self</COMMENTS>->{<COMMENTS>text</COMMENTS>}->{<COMMENTS>colorMap</COMMENTS>}->[
                #   <COMMENTS>Prima</COMMENTS>::<COMMENTS>PodView</COMMENTS>::<COMMENTS>COLOR_CODE_FOREGROUND</COMMENTS>
                #   & ~<COMMENTS>tb</COMMENTS>::<COMMENTS>COLOR_INDEX</COMMENTS> ] =
                #   <COMMENTS>$sec</COMMENTS>->{<COMMENTS>ColorCode</COMMENTS>}
                if ( $<CODE>identifier</CODE> eq '&' && $<CODE>expecting</CODE> ) {
                    $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                }
                else {
                    $<CODE>identifier</CODE> = '';
                    $<CODE>i</CODE>          = $<CODE>i_save</CODE>;
                    $<CODE>type</CODE>       = '&';
                }
                $<CODE>id_scan_state</CODE> = '';
                last;
            }
        }
        elsif ( $<CODE>id_scan_state</CODE> eq '<LITERALS>A</LITERALS>' ) {    # <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>alpha</COMMENTS> (<COMMENTS>after</COMMENTS> ::)

            if ( $<CODE>tok</CODE> =~ /^[A-Za-z_]/ ) {    # <COMMENTS>found</COMMENTS> <COMMENTS>it</COMMENTS>
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                $<CODE>id_scan_state</CODE> = ':';        # <COMMENTS>now</COMMENTS> <COMMENTS>need</COMMENTS> ::
                $<CODE>saw_alpha</CODE>     = 1;
            }
            elsif ( $<CODE>tok</CODE> eq "'" && $<CODE>allow_tick</CODE> ) {
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                $<CODE>id_scan_state</CODE> = ':';        # <COMMENTS>now</COMMENTS> <COMMENTS>need</COMMENTS> ::
                $<CODE>saw_alpha</CODE>     = 1;
            }
            elsif ( $<CODE>tok</CODE> =~ /^[0-9]/ ) {     # <COMMENTS>numeric</COMMENTS>..<COMMENTS>see</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>above</COMMENTS>
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                $<CODE>id_scan_state</CODE> = ':';        # <COMMENTS>now</COMMENTS> <COMMENTS>need</COMMENTS> ::
                $<CODE>saw_alpha</CODE>     = 1;
            }
            elsif ( ( $<CODE>identifier</CODE> =~ /^sub / ) && ( $<CODE>tok</CODE> =~ /^\s*$/ ) ) {
                $<CODE>id_scan_state</CODE> = '(';
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            elsif ( ( $<CODE>identifier</CODE> =~ /^sub / ) && ( $<CODE>tok</CODE> eq '(' ) ) {
                $<CODE>id_scan_state</CODE> = ')';
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            else {
                $<CODE>id_scan_state</CODE> = '';
                $<CODE>i</CODE>             = $<CODE>i_save</CODE>;
                last;
            }
        }
        elsif ( $<CODE>id_scan_state</CODE> eq ':' ) {    # <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> :: <COMMENTS>after</COMMENTS> <COMMENTS>alpha</COMMENTS>

            if ( $<CODE>tok</CODE> eq '::' ) {            # <COMMENTS>got</COMMENTS> <COMMENTS>it</COMMENTS>
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                $<CODE>id_scan_state</CODE> = '<LITERALS>A</LITERALS>';        # <COMMENTS>now</COMMENTS> <COMMENTS>require</COMMENTS> <COMMENTS>alpha</COMMENTS>
            }
            elsif ( $<CODE>tok</CODE> =~ /^[A-Za-z_]/ ) {    # <COMMENTS>more</COMMENTS> <COMMENTS>alphanumeric</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>here</COMMENTS>
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                $<CODE>id_scan_state</CODE> = ':';           # <COMMENTS>now</COMMENTS> <COMMENTS>need</COMMENTS> ::
                $<CODE>saw_alpha</CODE>     = 1;
            }
            elsif ( $<CODE>tok</CODE> =~ /^[0-9]/ ) {        # <COMMENTS>numeric</COMMENTS>..<COMMENTS>see</COMMENTS> <COMMENTS>comments</COMMENTS> <COMMENTS>above</COMMENTS>
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                $<CODE>id_scan_state</CODE> = ':';           # <COMMENTS>now</COMMENTS> <COMMENTS>need</COMMENTS> ::
                $<CODE>saw_alpha</CODE>     = 1;
            }
            elsif ( $<CODE>tok</CODE> eq "'" && $<CODE>allow_tick</CODE> ) {    # <COMMENTS>tick</COMMENTS>

                if ( $<CODE>is_keyword</CODE>{$<CODE>identifier</CODE>} ) {
                    $<CODE>id_scan_state</CODE> = '';              # <COMMENTS>that</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>all</COMMENTS>
                    $<CODE>i</CODE>             = $<CODE>i_save</CODE>;
                }
                else {
                    $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                }
            }
            elsif ( ( $<CODE>identifier</CODE> =~ /^sub / ) && ( $<CODE>tok</CODE> =~ /^\s*$/ ) ) {
                $<CODE>id_scan_state</CODE> = '(';
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            elsif ( ( $<CODE>identifier</CODE> =~ /^sub / ) && ( $<CODE>tok</CODE> eq '(' ) ) {
                $<CODE>id_scan_state</CODE> = ')';
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            else {
                $<CODE>id_scan_state</CODE> = '';        # <COMMENTS>that</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>all</COMMENTS>
                $<CODE>i</CODE>             = $<CODE>i_save</CODE>;
                last;
            }
        }
        elsif ( $<CODE>id_scan_state</CODE> eq '(' ) {    # <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> ( <COMMENTS>of</COMMENTS> <COMMENTS>prototype</COMMENTS>

            if ( $<CODE>tok</CODE> eq '(' ) {             # <COMMENTS>got</COMMENTS> <COMMENTS>it</COMMENTS>
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                $<CODE>id_scan_state</CODE> = ')';        # <COMMENTS>now</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>it</COMMENTS>
            }
            elsif ( $<CODE>tok</CODE> =~ /^\s*$/ ) {      # <COMMENTS>blank</COMMENTS> - <COMMENTS>keep</COMMENTS> <COMMENTS>going</COMMENTS>
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            else {
                $<CODE>id_scan_state</CODE> = '';         # <COMMENTS>that</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>all</COMMENTS> - <COMMENTS>no</COMMENTS> <COMMENTS>prototype</COMMENTS>
                $<CODE>i</CODE>             = $<CODE>i_save</CODE>;
                last;
            }
        }
        elsif ( $<CODE>id_scan_state</CODE> eq ')' ) {    # <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> ) <COMMENTS>to</COMMENTS> <COMMENTS>end</COMMENTS>

            if ( $<CODE>tok</CODE> eq ')' ) {             # <COMMENTS>got</COMMENTS> <COMMENTS>it</COMMENTS>
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
                $<CODE>id_scan_state</CODE> = '';         # <COMMENTS>all</COMMENTS> <COMMENTS>done</COMMENTS>
                last;
            }
            elsif ( $<CODE>tok</CODE> =~ /^[\s\$\%\\\*\@\&\;]/ ) {
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
            else {    # <COMMENTS>probable</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>script</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>going</COMMENTS>
                <CODE>warning</CODE>("<LITERALS>Unexpected</LITERALS> '$<CODE>tok</CODE>' <LITERALS>while</LITERALS> <LITERALS>seeking</LITERALS> <LITERALS>end</LITERALS> <LITERALS>of</LITERALS> <LITERALS>prototype</LITERALS>\n");
                $<CODE>identifier</CODE> .= $<CODE>tok</CODE>;
            }
        }
        else {        # <COMMENTS>can</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>due</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>initialization</COMMENTS>
            $<CODE>id_scan_state</CODE> = '';
            $<CODE>i</CODE>             = $<CODE>i_save</CODE>;
            last;
        }
    }

    if ( $<CODE>id_scan_state</CODE> eq ')' ) {
        <CODE>warning</CODE>("<LITERALS>Hit</LITERALS> <LITERALS>end</LITERALS> <LITERALS>of</LITERALS> <LITERALS>line</LITERALS> <LITERALS>while</LITERALS> <LITERALS>seeking</LITERALS> ) <LITERALS>to</LITERALS> <LITERALS>end</LITERALS> <LITERALS>prototype</LITERALS>\n");
    }

    # <COMMENTS>once</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>enter</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>actual</COMMENTS> <COMMENTS>identifier</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>extend</COMMENTS> <COMMENTS>beyond</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>line</COMMENTS>
    if ( $<CODE>id_scan_state</CODE> =~ /^[A\:\(\)]/ ) {
        $<CODE>id_scan_state</CODE> = '';
    }
    if ( $<CODE>i</CODE> < 0 ) { $<CODE>i</CODE> = 0 }

    unless ($<CODE>type</CODE>) {

        if ($<CODE>saw_type</CODE>) {

            if ($<CODE>saw_alpha</CODE>) {
                if ( $<CODE>identifier</CODE> =~ /^->/ && $<CODE>last_nonblank_type</CODE> eq '<LITERALS>w</LITERALS>' ) {
                    $<CODE>type</CODE> = '<LITERALS>w</LITERALS>';
                }
                else { $<CODE>type</CODE> = '<LITERALS>i</LITERALS>' }
            }
            elsif ( $<CODE>identifier</CODE> eq '->' ) {
                $<CODE>type</CODE> = '->';
            }
            elsif (
                ( length($<CODE>identifier</CODE>) > 1 )

                # <COMMENTS>In</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> '@<COMMENTS>$</COMMENTS>=' <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>identifier</COMMENTS> '@<COMMENTS>$</COMMENTS>'
                # <COMMENTS>In</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> '<COMMENTS>$$</COMMENTS>{' <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>type</COMMENTS> '<COMMENTS>$$</COMMENTS>' (<COMMENTS>and</COMMENTS> <COMMENTS>only</COMMENTS>
                # <COMMENTS>part</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>identifier</COMMENTS>)
                && !( $<CODE>identifier</CODE> =~ /\$$/ && $<CODE>tok</CODE> eq '{' )
                && ( $<CODE>identifier</CODE> !~ /^(sub |package )$/ )
              )
            {
                $<CODE>type</CODE> = '<LITERALS>i</LITERALS>';
            }
            else { $<CODE>type</CODE> = '<LITERALS>t</LITERALS>' }
        }
        elsif ($<CODE>saw_alpha</CODE>) {

            # <COMMENTS>type</COMMENTS> '<COMMENTS>w</COMMENTS>' <COMMENTS>includes</COMMENTS> <COMMENTS>anything</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>type</COMMENTS> <COMMENTS>info</COMMENTS>
            # (<COMMENTS>$</COMMENTS>,%,@,*) <COMMENTS>including</COMMENTS> <COMMENTS>something</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>abc</COMMENTS>::<COMMENTS>def</COMMENTS>::<COMMENTS>ghi</COMMENTS>
            $<CODE>type</CODE> = '<LITERALS>w</LITERALS>';
        }
        else {
            $<CODE>type</CODE> = '';
        }    # <COMMENTS>this</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>restart</COMMENTS>
    }

    if ($<CODE>identifier</CODE>) {
        $<CODE>tok</CODE> = $<CODE>identifier</CODE>;
        if ($<CODE>message</CODE>) { <CODE>write_logfile_entry</CODE>($<CODE>message</CODE>) }
    }
    else {
        $<CODE>tok</CODE> = $<CODE>tok_begin</CODE>;
        $<CODE>i</CODE>   = $<CODE>i_begin</CODE>;
    }

    <CODE>TOKENIZER_DEBUG_FLAG_SCAN_ID</CODE> && do {
        my ( $<CODE>a</CODE>, $<CODE>b</CODE>, $<CODE>c</CODE> ) = caller;
        print <CODE>STDOUT</CODE>
"<LITERALS>SCANID</LITERALS>: <LITERALS>called</LITERALS> <LITERALS>from</LITERALS> $<CODE>a</CODE> $<CODE>b</CODE> $<CODE>c</CODE> <LITERALS>with</LITERALS> <LITERALS>tok</LITERALS>, <LITERALS>i</LITERALS>, <LITERALS>state</LITERALS>, <LITERALS>identifier</LITERALS> =$<CODE>tok_begin</CODE>, $<CODE>i_begin</CODE>, $<CODE>id_scan_state_begin</CODE>, $<CODE>identifier_begin</CODE>\n";
        print <CODE>STDOUT</CODE>
"<LITERALS>SCANID</LITERALS>: <LITERALS>returned</LITERALS> <LITERALS>with</LITERALS> <LITERALS>tok</LITERALS>, <LITERALS>i</LITERALS>, <LITERALS>state</LITERALS>, <LITERALS>identifier</LITERALS> =$<CODE>tok</CODE>, $<CODE>i</CODE>, $<CODE>id_scan_state</CODE>, $<CODE>identifier</CODE>\n";
    };
    return ( $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE>, $<CODE>id_scan_state</CODE>, $<CODE>identifier</CODE> );
}

{

    # <COMMENTS>saved</COMMENTS> <COMMENTS>package</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>subnames</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>prototype</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>line</COMMENTS>
    my ( $<CODE>package_saved</CODE>, $<CODE>subname_saved</CODE> );

    sub <CODE>do_scan_sub</CODE> {

        # <COMMENTS>do_scan_sub</COMMENTS> <COMMENTS>parses</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>prototype</COMMENTS>
        # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>called</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>$i_beg</COMMENTS> <COMMENTS>equal</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>nonblank</COMMENTS>
        # <COMMENTS>token</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>a</COMMENTS> '<COMMENTS>sub</COMMENTS>' <COMMENTS>token</COMMENTS>.

        # <COMMENTS>TODO</COMMENTS>: <COMMENTS>add</COMMENTS> <COMMENTS>future</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>checks</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>valid</COMMENTS>
        # <COMMENTS>sub</COMMENTS> <COMMENTS>name</COMMENTS>.  <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, '<COMMENTS>sub</COMMENTS> &<COMMENTS>doit</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>wrong</COMMENTS>.  <COMMENTS>Also</COMMENTS>, <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS>
        # <COMMENTS>a</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>anonymous</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>is</COMMENTS>
        # <COMMENTS>appropriate</COMMENTS>.
        # <COMMENTS>USES</COMMENTS> <COMMENTS>GLOBAL</COMMENTS> <COMMENTS>VARS</COMMENTS>: <COMMENTS>$current_package</COMMENTS>, <COMMENTS>$last_nonblank_token</COMMENTS>,
        # <COMMENTS>$in_attribute_list</COMMENTS>, %<COMMENTS>saw_function_definition</COMMENTS>,
        # <COMMENTS>$statement_type</COMMENTS>

        my (
            $<CODE>input_line</CODE>, $<CODE>i</CODE>,             $<CODE>i_beg</CODE>,
            $<CODE>tok</CODE>,        $<CODE>type</CODE>,          $<CODE>rtokens</CODE>,
            $<CODE>rtoken_map</CODE>, $<CODE>id_scan_state</CODE>, $<CODE>max_token_index</CODE>
        ) = @<CODE>_</CODE>;
        $<CODE>id_scan_state</CODE> = "";    # <COMMENTS>normally</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>everything</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>call</COMMENTS>
        my $<CODE>subname</CODE> = undef;
        my $<CODE>package</CODE> = undef;
        my $<CODE>proto</CODE>   = undef;
        my $<CODE>attrs</CODE>   = undef;
        my $<CODE>match</CODE>;

        my $<CODE>pos_beg</CODE> = $$<CODE>rtoken_map</CODE>[$<CODE>i_beg</CODE>];
        pos($<CODE>input_line</CODE>) = $<CODE>pos_beg</CODE>;

        # <COMMENTS>Look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>NAME</COMMENTS>
        if (
            $<CODE>input_line</CODE> =~ m/\G\s*
        ((?:\w*(?:'|::))*)  # <COMMENTS>package</COMMENTS> - <COMMENTS>something</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>in</COMMENTS> :: <COMMENTS>or</COMMENTS> '
        (\w+)               # <COMMENTS>NAME</COMMENTS>    - <COMMENTS>required</COMMENTS>
        /gcx
          )
        {
            $<CODE>match</CODE>   = 1;
            $<CODE>subname</CODE> = $<CODE>2</CODE>;

            $<CODE>package</CODE> = ( defined($<CODE>1</CODE>) && $<CODE>1</CODE> ) ? $<CODE>1</CODE> : $<CODE>current_package</CODE>;
            $<CODE>package</CODE> =~ s/\'/::/g;
            if ( $<CODE>package</CODE> =~ /^\:/ ) { $<CODE>package</CODE> = '<LITERALS>main</LITERALS>' . $<CODE>package</CODE> }
            $<CODE>package</CODE> =~ s/::$//;
            my $<CODE>pos</CODE>  = pos($<CODE>input_line</CODE>);
            my $<CODE>numc</CODE> = $<CODE>pos</CODE> - $<CODE>pos_beg</CODE>;
            $<CODE>tok</CODE> = '<LITERALS>sub</LITERALS> ' . substr( $<CODE>input_line</CODE>, $<CODE>pos_beg</CODE>, $<CODE>numc</CODE> );
            $<CODE>type</CODE> = '<LITERALS>i</LITERALS>';
        }

        # <COMMENTS>Now</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>PROTO</COMMENTS> <COMMENTS>ATTRS</COMMENTS>
        # <COMMENTS>Look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>prototype</COMMENTS>/<COMMENTS>attributes</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>usually</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS>
        # <COMMENTS>line</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>line</COMMENTS>.
        # <COMMENTS>For</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>attributes</COMMENTS>,
        # <COMMENTS>or</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>prototype</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>its</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>name</COMMENTS>

        # <COMMENTS>NOTE</COMMENTS>: <COMMENTS>We</COMMENTS> <COMMENTS>only</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>parse</COMMENTS> <COMMENTS>PROTOTYPES</COMMENTS> <COMMENTS>here</COMMENTS>. <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>anything</COMMENTS> <COMMENTS>that</COMMENTS>
        # <COMMENTS>does</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>prototype</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>assume</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>SIGNATURE</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS>
        # <COMMENTS>will</COMMENTS> <COMMENTS>stop</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>standard</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>it</COMMENTS>.  <COMMENTS>In</COMMENTS>
        # <COMMENTS>particular</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>stop</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>nested</COMMENTS> <COMMENTS>parens</COMMENTS>, <COMMENTS>braces</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>commas</COMMENTS>.
        my $<CODE>saw_opening_paren</CODE> = $<CODE>input_line</CODE> =~ /\G\s*\(/;
        if (
            $<CODE>input_line</CODE> =~ m/\G(\s*\([^\)\(\}\{\,]*\))?  # <COMMENTS>PROTO</COMMENTS>
            (\s*:)?                              # <COMMENTS>ATTRS</COMMENTS> <COMMENTS>leading</COMMENTS> ':'
            /gcx
            && ( $<CODE>1</CODE> || $<CODE>2</CODE> )
          )
        {
            $<CODE>proto</CODE> = $<CODE>1</CODE>;
            $<CODE>attrs</CODE> = $<CODE>2</CODE>;

            # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>also</COMMENTS> <COMMENTS>found</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>call</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>append</COMMENTS> <COMMENTS>PROTO</COMMENTS>.
            # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>compatability</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>previous</COMMENTS>
            # <COMMENTS>versions</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>the</COMMENTS> -<COMMENTS>csc</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>used</COMMENTS>:
            if ( $<CODE>match</CODE> && $<CODE>proto</CODE> ) {
                $<CODE>tok</CODE> .= $<CODE>proto</CODE>;
            }
            $<CODE>match</CODE> ||= 1;

            # <COMMENTS>Handle</COMMENTS> <COMMENTS>prototype</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>separate</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>subname</COMMENTS>
            if ($<CODE>subname_saved</CODE>) {
                $<CODE>package</CODE> = $<CODE>package_saved</CODE>;
                $<CODE>subname</CODE> = $<CODE>subname_saved</CODE>;
                $<CODE>tok</CODE>     = $<CODE>last_nonblank_token</CODE>;
            }
            $<CODE>type</CODE> = '<LITERALS>i</LITERALS>';
        }

        if ($<CODE>match</CODE>) {

            # <COMMENTS>ATTRS</COMMENTS>: <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>attributes</COMMENTS>, <COMMENTS>back</COMMENTS> <COMMENTS>up</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>the</COMMENTS> ':' <COMMENTS>be</COMMENTS>
            # <COMMENTS>found</COMMENTS> <COMMENTS>later</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>scanner</COMMENTS>.
            my $<CODE>pos</CODE> = pos($<CODE>input_line</CODE>);
            if ($<CODE>attrs</CODE>) {
                $<CODE>pos</CODE> -= length($<CODE>attrs</CODE>);
            }

            my $<CODE>next_nonblank_token</CODE> = $<CODE>tok</CODE>;

            # <COMMENTS>catch</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>leading</COMMENTS> <COMMENTS>ATTR</COMMENTS> ':' <COMMENTS>after</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>sub</COMMENTS>
            if ( $<CODE>pos</CODE> == $<CODE>pos_beg</CODE> && $<CODE>tok</CODE> eq ':' ) {
                $<CODE>type</CODE>              = '<LITERALS>A</LITERALS>';
                $<CODE>in_attribute_list</CODE> = 1;
            }

            # <COMMENTS>Otherwise</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>found</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>convert</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>from</COMMENTS>
            # <COMMENTS>string</COMMENTS> <COMMENTS>position</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pre_token</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>continued</COMMENTS> <COMMENTS>parsing</COMMENTS>.
            else {

                # <COMMENTS>I</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>think</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>occur</COMMENTS> <COMMENTS>here</COMMENTS> ..<COMMENTS>but</COMMENTS> ?
                my $<CODE>error</CODE>;
                ( $<CODE>i</CODE>, $<CODE>error</CODE> ) = <CODE>inverse_pretoken_map</CODE>( $<CODE>i</CODE>, $<CODE>pos</CODE>, $<CODE>rtoken_map</CODE>,
                    $<CODE>max_token_index</CODE> );
                if ($<CODE>error</CODE>) { <CODE>warning</CODE>("<LITERALS>Possibly</LITERALS> <LITERALS>invalid</LITERALS> <LITERALS>sub</LITERALS>\n") }

                # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>definitions</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS>
                ( $<CODE>next_nonblank_token</CODE>, my $<CODE>i_next</CODE> ) =
                  <CODE>find_next_nonblank_token_on_this_line</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>,
                    $<CODE>max_token_index</CODE> );
            }

            if ( $<CODE>next_nonblank_token</CODE> =~ /^(\s*|#)$/ )
            {    # <COMMENTS>skip</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>side</COMMENTS> <COMMENTS>comment</COMMENTS>
                my ( $<CODE>rpre_tokens</CODE>, $<CODE>rpre_types</CODE> ) =
                  <CODE>peek_ahead_for_n_nonblank_pre_tokens</CODE>(1);
                if ( defined($<CODE>rpre_tokens</CODE>) && @$<CODE>rpre_tokens</CODE> ) {
                    $<CODE>next_nonblank_token</CODE> = $<CODE>rpre_tokens</CODE>->[0];
                }
                else {
                    $<CODE>next_nonblank_token</CODE> = '}';
                }
            }
            $<CODE>package_saved</CODE> = "";
            $<CODE>subname_saved</CODE> = "";

            # <COMMENTS>See</COMMENTS> <COMMENTS>what</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>next</COMMENTS>...
            if ( $<CODE>next_nonblank_token</CODE> eq '{' ) {
                if ($<CODE>subname</CODE>) {

                    # <COMMENTS>Check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>definitions</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sub</COMMENTS>, <COMMENTS>but</COMMENTS>
                    # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>BEGIN</COMMENTS>, <COMMENTS>etc</COMMENTS>,
                    # <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>complain</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>name</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>caps</COMMENTS>
                    if (   $<CODE>saw_function_definition</CODE>{$<CODE>package</CODE>}{$<CODE>subname</CODE>}
                        && $<CODE>subname</CODE> !~ /^[A-Z]+$/ )
                    {
                        my $<CODE>lno</CODE> = $<CODE>saw_function_definition</CODE>{$<CODE>package</CODE>}{$<CODE>subname</CODE>};
                        <CODE>warning</CODE>(
"<LITERALS>already</LITERALS> <LITERALS>saw</LITERALS> <LITERALS>definition</LITERALS> <LITERALS>of</LITERALS> '<LITERALS>sub</LITERALS> $<CODE>subname</CODE>' <LITERALS>in</LITERALS> <LITERALS>package</LITERALS> '$<CODE>package</CODE>' <LITERALS>at</LITERALS> <LITERALS>line</LITERALS> $<CODE>lno</CODE>\n"
                        );
                    }
                    $<CODE>saw_function_definition</CODE>{$<CODE>package</CODE>}{$<CODE>subname</CODE>} =
                      $<CODE>tokenizer_self</CODE>->{<LITERALS>_last_line_number</LITERALS>};
                }
            }
            elsif ( $<CODE>next_nonblank_token</CODE> eq ';' ) {
            }
            elsif ( $<CODE>next_nonblank_token</CODE> eq '}' ) {
            }

            # <COMMENTS>ATTRS</COMMENTS> - <COMMENTS>if</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>attribute</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>follows</COMMENTS>, <COMMENTS>remember</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>name</COMMENTS>
            # <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>opening</COMMENTS> <COMMENTS>brace</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>labeled</COMMENTS>.
            # <COMMENTS>Setting</COMMENTS> '<COMMENTS>statement_type</COMMENTS>' <COMMENTS>causes</COMMENTS> <COMMENTS>any</COMMENTS> ':'<COMMENTS>s</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>introduce</COMMENTS>
            # <COMMENTS>attributes</COMMENTS>.
            elsif ( $<CODE>next_nonblank_token</CODE> eq ':' ) {
                $<CODE>statement_type</CODE> = $<CODE>tok</CODE>;
            }

            # <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>stopped</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>open</COMMENTS> <COMMENTS>paren</COMMENTS> ...
            elsif ( $<CODE>next_nonblank_token</CODE> eq '(' ) {

                # <COMMENTS>If</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>DID</COMMENTS> <COMMENTS>NOT</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>paren</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>then</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>the</COMMENTS>
                # <COMMENTS>next</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>so</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>set</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>flag</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>come</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>if</COMMENTS>
                # <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>PROTOTYPE</COMMENTS>

                # <COMMENTS>Otherwise</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>assume</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>SIGNATURE</COMMENTS> <COMMENTS>rather</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>a</COMMENTS>
                # <COMMENTS>PROTOTYPE</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>normal</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS>
                if ( !$<CODE>saw_opening_paren</CODE> ) {
                    $<CODE>id_scan_state</CODE> = '<LITERALS>sub</LITERALS>';     # <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>come</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>proto</COMMENTS>
                    $<CODE>package_saved</CODE> = $<CODE>package</CODE>;
                    $<CODE>subname_saved</CODE> = $<CODE>subname</CODE>;
                }
                $<CODE>statement_type</CODE> = $<CODE>tok</CODE>;
            }
            elsif ($<CODE>next_nonblank_token</CODE>) {      # <COMMENTS>EOF</COMMENTS> <COMMENTS>technically</COMMENTS> <COMMENTS>ok</COMMENTS>
                <CODE>warning</CODE>(
"<LITERALS>expecting</LITERALS> ':' <LITERALS>or</LITERALS> ';' <LITERALS>or</LITERALS> '{' <LITERALS>after</LITERALS> <LITERALS>definition</LITERALS> <LITERALS>or</LITERALS> <LITERALS>declaration</LITERALS> <LITERALS>of</LITERALS> <LITERALS>sub</LITERALS> '$<CODE>subname</CODE>' <LITERALS>but</LITERALS> <LITERALS>saw</LITERALS> '$<CODE>next_nonblank_token</CODE>'\n"
                );
            }
            <CODE>check_prototype</CODE>( $<CODE>proto</CODE>, $<CODE>package</CODE>, $<CODE>subname</CODE> );
        }

        # <COMMENTS>no</COMMENTS> <COMMENTS>match</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>blank</COMMENTS>
        else {
        }
        return ( $<CODE>i</CODE>, $<CODE>tok</CODE>, $<CODE>type</CODE>, $<CODE>id_scan_state</CODE> );
    }
}

#########<COMMENTS>i</COMMENTS>###############################################################
# <COMMENTS>Tokenizer</COMMENTS> <COMMENTS>utility</COMMENTS> <COMMENTS>routines</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>CONSTANTS</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>GLOBALS</COMMENTS>
#########################################################################

sub <CODE>find_next_nonblank_token</CODE> {
    my ( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;

    if ( $<CODE>i</CODE> >= $<CODE>max_token_index</CODE> ) {
        if ( !<CODE>peeked_ahead</CODE>() ) {
            <CODE>peeked_ahead</CODE>(1);
            $<CODE>rtokens</CODE> =
              <CODE>peek_ahead_for_nonblank_token</CODE>( $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> );
        }
    }
    my $<CODE>next_nonblank_token</CODE> = $$<CODE>rtokens</CODE>[ ++$<CODE>i</CODE> ];

    if ( $<CODE>next_nonblank_token</CODE> =~ /^\s*$/ ) {
        $<CODE>next_nonblank_token</CODE> = $$<CODE>rtokens</CODE>[ ++$<CODE>i</CODE> ];
    }
    return ( $<CODE>next_nonblank_token</CODE>, $<CODE>i</CODE> );
}

sub <CODE>numerator_expected</CODE> {

    # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>filter</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>numerator</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>support</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>guessing</COMMENTS>
    # <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> / <COMMENTS>pattern</COMMENTS> <COMMENTS>delimiter</COMMENTS> <COMMENTS>token</COMMENTS>.
    # <COMMENTS>returns</COMMENTS> -
    #   <COMMENTS>1</COMMENTS> - <COMMENTS>yes</COMMENTS>
    #   <COMMENTS>0</COMMENTS> - <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>tell</COMMENTS>
    #  -<COMMENTS>1</COMMENTS> - <COMMENTS>no</COMMENTS>
    # <COMMENTS>Note</COMMENTS>: <COMMENTS>I</COMMENTS> <COMMENTS>am</COMMENTS> <COMMENTS>using</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>convention</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>variables</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>in</COMMENTS>
    # <COMMENTS>_expected</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>values</COMMENTS>.
    my ( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>next_token</CODE> = $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ];
    if ( $<CODE>next_token</CODE> eq '=' ) { $<CODE>i</CODE>++; }    # <COMMENTS>handle</COMMENTS> /=
    my ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_next</CODE> ) =
      <CODE>find_next_nonblank_token</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> );

    if ( $<CODE>next_nonblank_token</CODE> =~ /(\(|\$|\w|\.|\@)/ ) {
        1;
    }
    else {

        if ( $<CODE>next_nonblank_token</CODE> =~ /^\s*$/ ) {
            0;
        }
        else {
            -1;
        }
    }
}

sub <CODE>pattern_expected</CODE> {

    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>filter</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>pattern</COMMENTS>.
    # <COMMENTS>It</COMMENTS> <COMMENTS>looks</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>tries</COMMENTS> <COMMENTS>to</COMMENTS>
    # <COMMENTS>determine</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS>.
    # <COMMENTS>returns</COMMENTS> -
    #   <COMMENTS>1</COMMENTS> - <COMMENTS>yes</COMMENTS>
    #   <COMMENTS>0</COMMENTS> - <COMMENTS>can</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>tell</COMMENTS>
    #  -<COMMENTS>1</COMMENTS> - <COMMENTS>no</COMMENTS>
    my ( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>next_token</CODE> = $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ];
    if ( $<CODE>next_token</CODE> =~ /^[msixpodualgc]/ ) { $<CODE>i</CODE>++; }   # <COMMENTS>skip</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>modifier</COMMENTS>
    my ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_next</CODE> ) =
      <CODE>find_next_nonblank_token</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> );

    # <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>follow</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS>
    # (<COMMENTS>can</COMMENTS> <COMMENTS>probably</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>expanded</COMMENTS>)
    if ( $<CODE>next_nonblank_token</CODE> =~ /(\)|\}|\;|\&\&|\|\||and|or|while|if|unless)/ )
    {
        1;
    }
    else {

        if ( $<CODE>next_nonblank_token</CODE> =~ /^\s*$/ ) {
            0;
        }
        else {
            -1;
        }
    }
}

sub <CODE>find_next_nonblank_token_on_this_line</CODE> {
    my ( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>next_nonblank_token</CODE>;

    if ( $<CODE>i</CODE> < $<CODE>max_token_index</CODE> ) {
        $<CODE>next_nonblank_token</CODE> = $$<CODE>rtokens</CODE>[ ++$<CODE>i</CODE> ];

        if ( $<CODE>next_nonblank_token</CODE> =~ /^\s*$/ ) {

            if ( $<CODE>i</CODE> < $<CODE>max_token_index</CODE> ) {
                $<CODE>next_nonblank_token</CODE> = $$<CODE>rtokens</CODE>[ ++$<CODE>i</CODE> ];
            }
        }
    }
    else {
        $<CODE>next_nonblank_token</CODE> = "";
    }
    return ( $<CODE>next_nonblank_token</CODE>, $<CODE>i</CODE> );
}

sub <CODE>find_angle_operator_termination</CODE> {

    # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>a</COMMENTS> '<' <COMMENTS>and</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>angle</COMMENTS> <COMMENTS>operator</COMMENTS>.
    # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>return</COMMENTS>:
    #   <COMMENTS>$i</COMMENTS> = <COMMENTS>pretoken</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>ending</COMMENTS> '>' <COMMENTS>if</COMMENTS> <COMMENTS>found</COMMENTS>, <COMMENTS>current</COMMENTS> <COMMENTS>$i</COMMENTS> <COMMENTS>otherwise</COMMENTS>
    #   <COMMENTS>$type</COMMENTS> = '<COMMENTS>Q</COMMENTS>' <COMMENTS>if</COMMENTS> <COMMENTS>found</COMMENTS>, '>' <COMMENTS>otherwise</COMMENTS>
    my ( $<CODE>input_line</CODE>, $<CODE>i_beg</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>expecting</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>i</CODE>    = $<CODE>i_beg</CODE>;
    my $<CODE>type</CODE> = '<';
    pos($<CODE>input_line</CODE>) = 1 + $$<CODE>rtoken_map</CODE>[$<CODE>i</CODE>];

    my $<CODE>filter</CODE>;

    # <COMMENTS>we</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> '>' <COMMENTS>if</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>term</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>expected</COMMENTS>
    if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) { $<CODE>filter</CODE> = '[\>]' }

    # <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>guess</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>don</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>know</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>expected</COMMENTS>
    elsif ( $<CODE>expecting</CODE> == <CODE>UNKNOWN</CODE> ) { $<CODE>filter</CODE> = '[\>\;\=\#\|\<]' }

    # <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS> - <COMMENTS>we</COMMENTS> <COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>expected</COMMENTS>
    else { <CODE>warning</CODE>("<LITERALS>Program</LITERALS> <LITERALS>Bug</LITERALS> <LITERALS>in</LITERALS> <LITERALS>find_angle_operator_termination</LITERALS>\n") }

    # <COMMENTS>To</COMMENTS> <COMMENTS>illustrate</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>at</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>are</COMMENTS>
    # <COMMENTS>guessing</COMMENTS>, <COMMENTS>here</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>examples</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>angle</COMMENTS> <COMMENTS>operators</COMMENTS>
    # (<COMMENTS>or</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>globs</COMMENTS>):
    #  <<COMMENTS>tmp_imp</COMMENTS>/*>
    #  <<COMMENTS>FH</COMMENTS>>
    #  <<COMMENTS>$fh</COMMENTS>>
    #  <*.<COMMENTS>c</COMMENTS> *.<COMMENTS>h</COMMENTS>>
    #  <<COMMENTS>_</COMMENTS>>
    #  <<COMMENTS>jskdfjskdfj</COMMENTS>* <COMMENTS>op</COMMENTS>/* <COMMENTS>jskdjfjkosvk</COMMENTS>*> ( <COMMENTS>glob</COMMENTS>.<COMMENTS>t</COMMENTS>)
    #  <<COMMENTS>$</COMMENTS>{<COMMENTS>PREFIX</COMMENTS>}*<COMMENTS>img</COMMENTS>*.<COMMENTS>$IMAGE_TYPE</COMMENTS>>
    #  <<COMMENTS>img</COMMENTS>*.<COMMENTS>$IMAGE_TYPE</COMMENTS>>
    #  <<COMMENTS>Timg</COMMENTS>*.<COMMENTS>$IMAGE_TYPE</COMMENTS>>
    #  <<COMMENTS>$LATEX2HTMLVERSIONS$</COMMENTS>{<COMMENTS>dd</COMMENTS>}<COMMENTS>html</COMMENTS>[<COMMENTS>1</COMMENTS>-<COMMENTS>9</COMMENTS>].[<COMMENTS>0</COMMENTS>-<COMMENTS>9</COMMENTS>].<COMMENTS>pl</COMMENTS>>
    #
    # <COMMENTS>Here</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>examples</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>lines</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>angle</COMMENTS> <COMMENTS>operators</COMMENTS>:
    #  <COMMENTS>return</COMMENTS> <COMMENTS>undef</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>$self</COMMENTS>->[<COMMENTS>2</COMMENTS>]++ < <COMMENTS>$</COMMENTS>#{<COMMENTS>$self</COMMENTS>->[<COMMENTS>1</COMMENTS>]};
    #  < <COMMENTS>2</COMMENTS>  || @<COMMENTS>$t</COMMENTS> >
    #
    # <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>dlister</COMMENTS>.<COMMENTS>pl</COMMENTS> <COMMENTS>caused</COMMENTS> <COMMENTS>trouble</COMMENTS>:
    #  <COMMENTS>print</COMMENTS>'~'<COMMENTS>x79</COMMENTS>,"\<COMMENTS>n</COMMENTS>",<COMMENTS>$D</COMMENTS><<COMMENTS>1024</COMMENTS>?"<COMMENTS>0</COMMENTS>.<COMMENTS>$D</COMMENTS>":<COMMENTS>$D</COMMENTS>>><COMMENTS>10</COMMENTS>,"<COMMENTS>K</COMMENTS>, <COMMENTS>$C</COMMENTS> <COMMENTS>files</COMMENTS>\<COMMENTS>n</COMMENTS>\<COMMENTS>n</COMMENTS>\<COMMENTS>n</COMMENTS>";
    #
    # <COMMENTS>If</COMMENTS> <COMMENTS>the</COMMENTS> '<' <COMMENTS>starts</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>angle</COMMENTS> <COMMENTS>operator</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>and</COMMENTS>
    # <COMMENTS>it</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>certain</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>like</COMMENTS> ';' <COMMENTS>and</COMMENTS> '=' <COMMENTS>in</COMMENTS> <COMMENTS>it</COMMENTS>.  <COMMENTS>I</COMMENTS> <COMMENTS>use</COMMENTS>
    # <COMMENTS>this</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>limit</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>testing</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>filter</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>improved</COMMENTS> <COMMENTS>if</COMMENTS>
    # <COMMENTS>possible</COMMENTS>.

    if ( $<CODE>input_line</CODE> =~ /($<CODE>filter</CODE>)/g ) {

        if ( $<CODE>1</CODE> eq '>' ) {

            # <COMMENTS>We</COMMENTS> <COMMENTS>MAY</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>found</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>angle</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>termination</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>get</COMMENTS>
            # <COMMENTS>here</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>need</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>sure</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>haven</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>been</COMMENTS>
            # <COMMENTS>fooled</COMMENTS>.
            my $<CODE>pos</CODE> = pos($<CODE>input_line</CODE>);

            my $<CODE>pos_beg</CODE> = $$<CODE>rtoken_map</CODE>[$<CODE>i</CODE>];
            my $<CODE>str</CODE> = substr( $<CODE>input_line</CODE>, $<CODE>pos_beg</CODE>, ( $<CODE>pos</CODE> - $<CODE>pos_beg</CODE> ) );

            # <COMMENTS>Reject</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>closing</COMMENTS> '>' <COMMENTS>follows</COMMENTS> <COMMENTS>a</COMMENTS> '-' <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS>:
            # <COMMENTS>if</COMMENTS> ( <COMMENTS>VERSION</COMMENTS> < <COMMENTS>5</COMMENTS>.<COMMENTS>009</COMMENTS> && <COMMENTS>$op</COMMENTS>-> <COMMENTS>name</COMMENTS> <COMMENTS>eq</COMMENTS> '<COMMENTS>assign</COMMENTS>' ) { }
            if ( $<CODE>expecting</CODE> eq <CODE>UNKNOWN</CODE> ) {
                my $<CODE>check</CODE> = substr( $<CODE>input_line</CODE>, $<CODE>pos</CODE> - 2, 1 );
                if ( $<CODE>check</CODE> eq '-' ) {
                    return ( $<CODE>i</CODE>, $<CODE>type</CODE> );
                }
            }

            ######################################<COMMENTS>debug</COMMENTS>#####
            #<COMMENTS>write_diagnostics</COMMENTS>( "<COMMENTS>ANGLE</COMMENTS>? :<COMMENTS>$str</COMMENTS>\<COMMENTS>n</COMMENTS>");
            #<COMMENTS>print</COMMENTS> "<COMMENTS>ANGLE</COMMENTS>: <COMMENTS>found</COMMENTS> <COMMENTS>$1</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>pos</COMMENTS>=<COMMENTS>$pos</COMMENTS> <COMMENTS>str</COMMENTS>=<COMMENTS>$str</COMMENTS> <COMMENTS>check</COMMENTS>=<COMMENTS>$check</COMMENTS>\<COMMENTS>n</COMMENTS>";
            ######################################<COMMENTS>debug</COMMENTS>#####
            $<CODE>type</CODE> = '<LITERALS>Q</LITERALS>';
            my $<CODE>error</CODE>;
            ( $<CODE>i</CODE>, $<CODE>error</CODE> ) =
              <CODE>inverse_pretoken_map</CODE>( $<CODE>i</CODE>, $<CODE>pos</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>max_token_index</CODE> );

            # <COMMENTS>It</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>ends</COMMENTS> <COMMENTS>midway</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pretoken</COMMENTS>.
            # <COMMENTS>If</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>happens</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>necessary</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>split</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pretoken</COMMENTS>.
            if ($<CODE>error</CODE>) {
                <CODE>warning</CODE>(
                    "<LITERALS>Possible</LITERALS> <LITERALS>tokinization</LITERALS> <LITERALS>error</LITERALS>..<LITERALS>please</LITERALS> <LITERALS>check</LITERALS> <LITERALS>this</LITERALS> <LITERALS>line</LITERALS>\n");
                <CODE>report_possible_bug</CODE>();
            }

            # <COMMENTS>Now</COMMENTS> <COMMENTS>let</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>see</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>stand</COMMENTS>....
            # <COMMENTS>OK</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>math</COMMENTS> <COMMENTS>op</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>possible</COMMENTS>
            if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) {
            }

            # <COMMENTS>OK</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>tokens</COMMENTS> <COMMENTS>inside</COMMENTS>
            # (<COMMENTS>not</COMMENTS> <COMMENTS>possible</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>math</COMMENTS> <COMMENTS>between</COMMENTS> < <COMMENTS>and</COMMENTS> >)
            # <COMMENTS>This</COMMENTS> <COMMENTS>catches</COMMENTS> <COMMENTS>most</COMMENTS> <COMMENTS>common</COMMENTS> <COMMENTS>cases</COMMENTS>
            elsif ( $<CODE>i</CODE> <= $<CODE>i_beg</CODE> + 3 ) {
                <CODE>write_diagnostics</CODE>("<LITERALS>ANGLE</LITERALS>(<LITERALS>1</LITERALS> <LITERALS>or</LITERALS> <LITERALS>2</LITERALS> <LITERALS>tokens</LITERALS>): $<CODE>str</CODE>\n");
            }

            # <COMMENTS>Not</COMMENTS> <COMMENTS>sure</COMMENTS>..
            else {

                # <COMMENTS>Let</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>try</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>Brace</COMMENTS> <COMMENTS>Test</COMMENTS>: <COMMENTS>any</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>inside</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>balance</COMMENTS>
                my $<CODE>br</CODE> = 0;
                while ( $<CODE>str</CODE> =~ /\{/g ) { $<CODE>br</CODE>++ }
                while ( $<CODE>str</CODE> =~ /\}/g ) { $<CODE>br</CODE>-- }
                my $<CODE>sb</CODE> = 0;
                while ( $<CODE>str</CODE> =~ /\[/g ) { $<CODE>sb</CODE>++ }
                while ( $<CODE>str</CODE> =~ /\]/g ) { $<CODE>sb</CODE>-- }
                my $<CODE>pr</CODE> = 0;
                while ( $<CODE>str</CODE> =~ /\(/g ) { $<CODE>pr</CODE>++ }
                while ( $<CODE>str</CODE> =~ /\)/g ) { $<CODE>pr</CODE>-- }

                # <COMMENTS>if</COMMENTS> <COMMENTS>braces</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>balance</COMMENTS> - <COMMENTS>not</COMMENTS> <COMMENTS>angle</COMMENTS> <COMMENTS>operator</COMMENTS>
                if ( $<CODE>br</CODE> || $<CODE>sb</CODE> || $<CODE>pr</CODE> ) {
                    $<CODE>i</CODE>    = $<CODE>i_beg</CODE>;
                    $<CODE>type</CODE> = '<';
                    <CODE>write_diagnostics</CODE>(
                        "<LITERALS>NOT</LITERALS> <LITERALS>ANGLE</LITERALS> (<LITERALS>BRACE</LITERALS>={$<CODE>br</CODE> ($<CODE>pr</CODE> [$<CODE>sb</CODE> ):$<CODE>str</CODE>\n");
                }

                # <COMMENTS>we</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>keep</COMMENTS> <COMMENTS>doing</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>checks</COMMENTS> <COMMENTS>here</COMMENTS>...<COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>continued</COMMENTS>
                # <COMMENTS>Tentatively</COMMENTS> <COMMENTS>accepting</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>angle</COMMENTS> <COMMENTS>operator</COMMENTS>.
                # <COMMENTS>There</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>lots</COMMENTS> <COMMENTS>more</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>checked</COMMENTS>.
                else {
                    <CODE>write_diagnostics</CODE>(
                        "<LITERALS>ANGLE</LITERALS>-<LITERALS>Guessing</LITERALS> <LITERALS>yes</LITERALS>: $<CODE>str</CODE> <LITERALS>expecting</LITERALS>=$<CODE>expecting</CODE>\n");
                    <CODE>write_logfile_entry</CODE>("<LITERALS>Guessing</LITERALS> <LITERALS>angle</LITERALS> <LITERALS>operator</LITERALS> <LITERALS>here</LITERALS>: $<CODE>str</CODE>\n");
                }
            }
        }

        # <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>ending</COMMENTS> >
        else {
            if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) {
                <CODE>warning</CODE>("<LITERALS>No</LITERALS> <LITERALS>ending</LITERALS> > <LITERALS>for</LITERALS> <LITERALS>angle</LITERALS> <LITERALS>operator</LITERALS>\n");
            }
        }
    }
    return ( $<CODE>i</CODE>, $<CODE>type</CODE> );
}

sub <CODE>scan_number_do</CODE> {

    #  <COMMENTS>scan</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>formats</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>Perl</COMMENTS> <COMMENTS>accepts</COMMENTS>
    #  <COMMENTS>Underbars</COMMENTS> (<COMMENTS>_</COMMENTS>) <COMMENTS>are</COMMENTS> <COMMENTS>allowed</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>decimal</COMMENTS> <COMMENTS>numbers</COMMENTS>.
    #  <COMMENTS>input</COMMENTS> <COMMENTS>parameters</COMMENTS> -
    #      <COMMENTS>$input_line</COMMENTS>  - <COMMENTS>the</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>scan</COMMENTS>
    #      <COMMENTS>$i</COMMENTS>           - <COMMENTS>pre_token</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>scanning</COMMENTS>
    #    <COMMENTS>$rtoken_map</COMMENTS>    - <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>pre_token</COMMENTS> <COMMENTS>map</COMMENTS> <COMMENTS>giving</COMMENTS> <COMMENTS>starting</COMMENTS>
    #                    <COMMENTS>character</COMMENTS> <COMMENTS>position</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>$input_line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>$i</COMMENTS>
    #  <COMMENTS>output</COMMENTS> <COMMENTS>parameters</COMMENTS> -
    #    <COMMENTS>$i</COMMENTS>            - <COMMENTS>last</COMMENTS> <COMMENTS>pre_token</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>just</COMMENTS> <COMMENTS>scanned</COMMENTS>
    #    <COMMENTS>number</COMMENTS>        - <COMMENTS>the</COMMENTS> <COMMENTS>number</COMMENTS> (<COMMENTS>characters</COMMENTS>); <COMMENTS>or</COMMENTS> <COMMENTS>undef</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>number</COMMENTS>

    my ( $<CODE>input_line</CODE>, $<CODE>i</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>input_type</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>pos_beg</CODE> = $$<CODE>rtoken_map</CODE>[$<CODE>i</CODE>];
    my $<CODE>pos</CODE>;
    my $<CODE>i_begin</CODE> = $<CODE>i</CODE>;
    my $<CODE>number</CODE>  = undef;
    my $<CODE>type</CODE>    = $<CODE>input_type</CODE>;

    my $<CODE>first_char</CODE> = substr( $<CODE>input_line</CODE>, $<CODE>pos_beg</CODE>, 1 );

    # <COMMENTS>Look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>characters</COMMENTS>; <COMMENTS>Shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>..
    if ( $<CODE>first_char</CODE> !~ /[\d\.\+\-Ee]/ ) {
        <CODE>warning</CODE>("<LITERALS>Program</LITERALS> <LITERALS>bug</LITERALS> - <LITERALS>scan_number</LITERALS> <LITERALS>given</LITERALS> <LITERALS>character</LITERALS> $<CODE>first_char</CODE>\n");
        <CODE>report_definite_bug</CODE>();
        return ( $<CODE>i</CODE>, $<CODE>type</CODE>, $<CODE>number</CODE> );
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>v</COMMENTS>-<COMMENTS>string</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>leading</COMMENTS> '<COMMENTS>v</COMMENTS>' <COMMENTS>character</COMMENTS> ('<COMMENTS>Two</COMMENTS> <COMMENTS>Dot</COMMENTS>' <COMMENTS>rule</COMMENTS>)
    # (<COMMENTS>vstring</COMMENTS>.<COMMENTS>t</COMMENTS>)
    # <COMMENTS>TODO</COMMENTS>: <COMMENTS>v</COMMENTS>-<COMMENTS>strings</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>contain</COMMENTS> <COMMENTS>underscores</COMMENTS>
    pos($<CODE>input_line</CODE>) = $<CODE>pos_beg</CODE>;
    if ( $<CODE>input_line</CODE> =~ /\G((\d+)?\.\d+(\.\d+)+)/g ) {
        $<CODE>pos</CODE> = pos($<CODE>input_line</CODE>);
        my $<CODE>numc</CODE> = $<CODE>pos</CODE> - $<CODE>pos_beg</CODE>;
        $<CODE>number</CODE> = substr( $<CODE>input_line</CODE>, $<CODE>pos_beg</CODE>, $<CODE>numc</CODE> );
        $<CODE>type</CODE> = '<LITERALS>v</LITERALS>';
        <CODE>report_v_string</CODE>($<CODE>number</CODE>);
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>octal</COMMENTS>, <COMMENTS>hex</COMMENTS>, <COMMENTS>binary</COMMENTS>
    if ( !defined($<CODE>number</CODE>) ) {
        pos($<CODE>input_line</CODE>) = $<CODE>pos_beg</CODE>;
        if ( $<CODE>input_line</CODE> =~
            /\G[+-]?0(([xX][0-9a-fA-F_]+)|([0-7_]+)|([bB][01_]+))/g )
        {
            $<CODE>pos</CODE> = pos($<CODE>input_line</CODE>);
            my $<CODE>numc</CODE> = $<CODE>pos</CODE> - $<CODE>pos_beg</CODE>;
            $<CODE>number</CODE> = substr( $<CODE>input_line</CODE>, $<CODE>pos_beg</CODE>, $<CODE>numc</CODE> );
            $<CODE>type</CODE> = '<LITERALS>n</LITERALS>';
        }
    }

    # <COMMENTS>handle</COMMENTS> <COMMENTS>decimal</COMMENTS>
    if ( !defined($<CODE>number</CODE>) ) {
        pos($<CODE>input_line</CODE>) = $<CODE>pos_beg</CODE>;

        if ( $<CODE>input_line</CODE> =~ /\G([+-]?[\d_]*(\.[\d_]*)?([Ee][+-]?(\d+))?)/g ) {
            $<CODE>pos</CODE> = pos($<CODE>input_line</CODE>);

            # <COMMENTS>watch</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>things</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>0</COMMENTS>..<COMMENTS>40</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>give</COMMENTS> <COMMENTS>0</COMMENTS>. <COMMENTS>by</COMMENTS> <COMMENTS>this</COMMENTS>;
            if (   ( substr( $<CODE>input_line</CODE>, $<CODE>pos</CODE> - 1, 1 ) eq '.' )
                && ( substr( $<CODE>input_line</CODE>, $<CODE>pos</CODE>, 1 ) eq '.' ) )
            {
                $<CODE>pos</CODE>--;
            }
            my $<CODE>numc</CODE> = $<CODE>pos</CODE> - $<CODE>pos_beg</CODE>;
            $<CODE>number</CODE> = substr( $<CODE>input_line</CODE>, $<CODE>pos_beg</CODE>, $<CODE>numc</CODE> );
            $<CODE>type</CODE> = '<LITERALS>n</LITERALS>';
        }
    }

    # <COMMENTS>filter</COMMENTS> <COMMENTS>out</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>numbers</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>e</COMMENTS> + - . <COMMENTS>e2</COMMENTS>  .<COMMENTS>e3</COMMENTS> +<COMMENTS>e6</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>rule</COMMENTS>: <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>one</COMMENTS> <COMMENTS>digit</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>any</COMMENTS> '<COMMENTS>e</COMMENTS>' <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>preceded</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>digit</COMMENTS>
    if (
        $<CODE>number</CODE> !~ /\d/    # <COMMENTS>no</COMMENTS> <COMMENTS>digits</COMMENTS>
        || (   $<CODE>number</CODE> =~ /^(.*)[eE]/
            && $<CODE>1</CODE> !~ /\d/ )    # <COMMENTS>or</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>digits</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> '<COMMENTS>e</COMMENTS>'
      )
    {
        $<CODE>number</CODE> = undef;
        $<CODE>type</CODE>   = $<CODE>input_type</CODE>;
        return ( $<CODE>i</CODE>, $<CODE>type</CODE>, $<CODE>number</CODE> );
    }

    # <COMMENTS>Found</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>number</COMMENTS>; <COMMENTS>now</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>convert</COMMENTS> <COMMENTS>back</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>position</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>pre_token</COMMENTS> <COMMENTS>index</COMMENTS>. <COMMENTS>An</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>implies</COMMENTS> <COMMENTS>user</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>error</COMMENTS>.
    # <COMMENTS>An</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>would</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>invalid</COMMENTS> <COMMENTS>octal</COMMENTS> <COMMENTS>number</COMMENTS> <COMMENTS>like</COMMENTS> '<COMMENTS>009</COMMENTS>'.
    my $<CODE>error</CODE>;
    ( $<CODE>i</CODE>, $<CODE>error</CODE> ) =
      <CODE>inverse_pretoken_map</CODE>( $<CODE>i</CODE>, $<CODE>pos</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>max_token_index</CODE> );
    if ($<CODE>error</CODE>) { <CODE>warning</CODE>("<LITERALS>Possibly</LITERALS> <LITERALS>invalid</LITERALS> <LITERALS>number</LITERALS>\n") }

    return ( $<CODE>i</CODE>, $<CODE>type</CODE>, $<CODE>number</CODE> );
}

sub <CODE>inverse_pretoken_map</CODE> {

    # <COMMENTS>Starting</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>pre_token</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>$i</COMMENTS>, <COMMENTS>scan</COMMENTS> <COMMENTS>forward</COMMENTS> <COMMENTS>until</COMMENTS>
    # <COMMENTS>finding</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>pre_token</COMMENTS> <COMMENTS>whose</COMMENTS> <COMMENTS>position</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>$pos</COMMENTS>.
    my ( $<CODE>i</CODE>, $<CODE>pos</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>error</CODE> = 0;

    while ( ++$<CODE>i</CODE> <= $<CODE>max_token_index</CODE> ) {

        if ( $<CODE>pos</CODE> <= $$<CODE>rtoken_map</CODE>[$<CODE>i</CODE>] ) {

            # <COMMENTS>Let</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>calling</COMMENTS> <COMMENTS>routine</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>errors</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS>
            # <COMMENTS>land</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>token</COMMENTS> <COMMENTS>boundary</COMMENTS>.  <COMMENTS>It</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>happen</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>running</COMMENTS>
            # <COMMENTS>perltidy</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>some</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>perl</COMMENTS> <COMMENTS>scripts</COMMENTS>, <COMMENTS>for</COMMENTS> <COMMENTS>example</COMMENTS>.
            if ( $<CODE>pos</CODE> < $$<CODE>rtoken_map</CODE>[$<CODE>i</CODE>] ) { $<CODE>error</CODE> = 1 }
            $<CODE>i</CODE>--;
            last;
        }
    }
    return ( $<CODE>i</CODE>, $<CODE>error</CODE> );
}

sub <CODE>find_here_doc</CODE> {

    # <COMMENTS>find</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>target</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>document</COMMENTS>, <COMMENTS>if</COMMENTS> <COMMENTS>any</COMMENTS>
    # <COMMENTS>input</COMMENTS> <COMMENTS>parameters</COMMENTS>:
    #   <COMMENTS>$i</COMMENTS> - <COMMENTS>token</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>second</COMMENTS> < <COMMENTS>of</COMMENTS> <<
    #   (<COMMENTS>$i</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>less</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>called</COMMENTS>)
    # <COMMENTS>output</COMMENTS> <COMMENTS>parameters</COMMENTS>:
    #   <COMMENTS>$found_target</COMMENTS> = <COMMENTS>0</COMMENTS> <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>target</COMMENTS>; =<COMMENTS>1</COMMENTS> <COMMENTS>found</COMMENTS> <COMMENTS>target</COMMENTS>
    #   <COMMENTS>HERE_TARGET</COMMENTS> - <COMMENTS>the</COMMENTS> <COMMENTS>target</COMMENTS> <COMMENTS>string</COMMENTS> (<COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>empty</COMMENTS> <COMMENTS>string</COMMENTS>)
    #   <COMMENTS>$i</COMMENTS> - <COMMENTS>unchanged</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>doc</COMMENTS>,
    #    <COMMENTS>or</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>last</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>target</COMMENTS>
    #   <COMMENTS>$saw_error</COMMENTS> - <COMMENTS>flag</COMMENTS> <COMMENTS>noting</COMMENTS> <COMMENTS>unbalanced</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>target</COMMENTS>
    my ( $<CODE>expecting</CODE>, $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>rtoken_map</CODE>, $<CODE>max_token_index</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>ibeg</CODE>                 = $<CODE>i</CODE>;
    my $<CODE>found_target</CODE>         = 0;
    my $<CODE>here_doc_target</CODE>      = '';
    my $<CODE>here_quote_character</CODE> = '';
    my $<CODE>saw_error</CODE>            = 0;
    my ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_next_nonblank</CODE>, $<CODE>next_token</CODE> );
    $<CODE>next_token</CODE> = $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ];

    # <COMMENTS>perl</COMMENTS> <COMMENTS>allows</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>backslash</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>target</COMMENTS> <COMMENTS>string</COMMENTS> (<COMMENTS>heredoc</COMMENTS>.<COMMENTS>t</COMMENTS>)
    my $<CODE>backslash</CODE> = 0;
    if ( $<CODE>next_token</CODE> eq '\\' ) {
        $<CODE>backslash</CODE>  = 1;
        $<CODE>next_token</CODE> = $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 2 ];
    }

    ( $<CODE>next_nonblank_token</CODE>, $<CODE>i_next_nonblank</CODE> ) =
      <CODE>find_next_nonblank_token_on_this_line</CODE>( $<CODE>i</CODE>, $<CODE>rtokens</CODE>, $<CODE>max_token_index</CODE> );

    if ( $<CODE>next_nonblank_token</CODE> =~ /[\'\"\`]/ ) {

        my $<CODE>in_quote</CODE>    = 1;
        my $<CODE>quote_depth</CODE> = 0;
        my $<CODE>quote_pos</CODE>   = 0;
        my $<CODE>quoted_string</CODE>;

        (
            $<CODE>i</CODE>, $<CODE>in_quote</CODE>, $<CODE>here_quote_character</CODE>, $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>,
            $<CODE>quoted_string</CODE>
          )
          = <CODE>follow_quoted_string</CODE>( $<CODE>i_next_nonblank</CODE>, $<CODE>in_quote</CODE>, $<CODE>rtokens</CODE>,
            $<CODE>here_quote_character</CODE>, $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>, $<CODE>max_token_index</CODE> );

        if ($<CODE>in_quote</CODE>) {    # <COMMENTS>didn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>quote</COMMENTS>, <COMMENTS>so</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>target</COMMENTS> <COMMENTS>found</COMMENTS>
            $<CODE>i</CODE> = $<CODE>ibeg</CODE>;
            if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) {
                <CODE>warning</CODE>(
"<LITERALS>Did</LITERALS> <LITERALS>not</LITERALS> <LITERALS>find</LITERALS> <LITERALS>here</LITERALS>-<LITERALS>doc</LITERALS> <LITERALS>string</LITERALS> <LITERALS>terminator</LITERALS> ($<CODE>here_quote_character</CODE>) <LITERALS>before</LITERALS> <LITERALS>end</LITERALS> <LITERALS>of</LITERALS> <LITERALS>line</LITERALS> \n"
                );
                $<CODE>saw_error</CODE> = 1;
            }
        }
        else {              # <COMMENTS>found</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>quote</COMMENTS>
            my $<CODE>j</CODE>;
            $<CODE>found_target</CODE> = 1;

            my $<CODE>tokj</CODE>;
            for ( $<CODE>j</CODE> = $<CODE>i_next_nonblank</CODE> + 1 ; $<CODE>j</CODE> < $<CODE>i</CODE> ; $<CODE>j</CODE>++ ) {
                $<CODE>tokj</CODE> = $$<CODE>rtokens</CODE>[$<CODE>j</CODE>];

                # <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>remove</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>backslash</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>character</COMMENTS>
                # <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>here</COMMENTS>-<COMMENTS>doc</COMMENTS>-<COMMENTS>target</COMMENTS> <COMMENTS>exactly</COMMENTS> <COMMENTS>matches</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>string</COMMENTS>
                next
                  if ( $<CODE>tokj</CODE> eq "\\"
                    && $<CODE>j</CODE> < $<CODE>i</CODE> - 1
                    && $$<CODE>rtokens</CODE>[ $<CODE>j</CODE> + 1 ] eq $<CODE>here_quote_character</CODE> );
                $<CODE>here_doc_target</CODE> .= $<CODE>tokj</CODE>;
            }
        }
    }

    elsif ( ( $<CODE>next_token</CODE> =~ /^\s*$/ ) and ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) ) {
        $<CODE>found_target</CODE> = 1;
        <CODE>write_logfile_entry</CODE>(
            "<LITERALS>found</LITERALS> <LITERALS>blank</LITERALS> <LITERALS>here</LITERALS>-<LITERALS>target</LITERALS> <LITERALS>after</LITERALS> <<; <LITERALS>suggest</LITERALS> <LITERALS>using</LITERALS> \"\"\n");
        $<CODE>i</CODE> = $<CODE>ibeg</CODE>;
    }
    elsif ( $<CODE>next_token</CODE> =~ /^\w/ ) {    # <COMMENTS>simple</COMMENTS> <COMMENTS>bareword</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>integer</COMMENTS> <COMMENTS>after</COMMENTS> <<

        my $<CODE>here_doc_expected</CODE>;
        if ( $<CODE>expecting</CODE> == <CODE>UNKNOWN</CODE> ) {
            $<CODE>here_doc_expected</CODE> = <CODE>guess_if_here_doc</CODE>($<CODE>next_token</CODE>);
        }
        else {
            $<CODE>here_doc_expected</CODE> = 1;
        }

        if ($<CODE>here_doc_expected</CODE>) {
            $<CODE>found_target</CODE>    = 1;
            $<CODE>here_doc_target</CODE> = $<CODE>next_token</CODE>;
            $<CODE>i</CODE>               = $<CODE>ibeg</CODE> + 1;
        }

    }
    else {

        if ( $<CODE>expecting</CODE> == <CODE>TERM</CODE> ) {
            $<CODE>found_target</CODE> = 1;
            <CODE>write_logfile_entry</CODE>("<LITERALS>Note</LITERALS>: <LITERALS>bare</LITERALS> <LITERALS>here</LITERALS>-<LITERALS>doc</LITERALS> <LITERALS>operator</LITERALS> <<\n");
        }
        else {
            $<CODE>i</CODE> = $<CODE>ibeg</CODE>;
        }
    }

    # <COMMENTS>patch</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>neglect</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>prepended</COMMENTS> <COMMENTS>backslash</COMMENTS>
    if ( $<CODE>found_target</CODE> && $<CODE>backslash</CODE> ) { $<CODE>i</CODE>++ }

    return ( $<CODE>found_target</CODE>, $<CODE>here_doc_target</CODE>, $<CODE>here_quote_character</CODE>, $<CODE>i</CODE>,
        $<CODE>saw_error</CODE> );
}

sub <CODE>do_quote</CODE> {

    # <COMMENTS>follow</COMMENTS> (<COMMENTS>or</COMMENTS> <COMMENTS>continue</COMMENTS> <COMMENTS>following</COMMENTS>) <COMMENTS>quoted</COMMENTS> <COMMENTS>string</COMMENTS>(<COMMENTS>s</COMMENTS>)
    # <COMMENTS>$in_quote</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>code</COMMENTS>:
    #   <COMMENTS>0</COMMENTS> - <COMMENTS>ok</COMMENTS>, <COMMENTS>found</COMMENTS> <COMMENTS>end</COMMENTS>
    #   <COMMENTS>1</COMMENTS> - <COMMENTS>still</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>whose</COMMENTS> <COMMENTS>target</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>$quote_character</COMMENTS>
    #   <COMMENTS>2</COMMENTS> - <COMMENTS>still</COMMENTS> <COMMENTS>looking</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>quotes</COMMENTS>
    #
    # <COMMENTS>Returns</COMMENTS> <COMMENTS>updated</COMMENTS> <COMMENTS>strings</COMMENTS>:
    #  <COMMENTS>$quoted_string_1</COMMENTS> = <COMMENTS>quoted</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>seen</COMMENTS> <COMMENTS>while</COMMENTS> <COMMENTS>in_quote</COMMENTS>=<COMMENTS>1</COMMENTS>
    #  <COMMENTS>$quoted_string_2</COMMENTS> = <COMMENTS>quoted</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>seen</COMMENTS> <COMMENTS>while</COMMENTS> <COMMENTS>in_quote</COMMENTS>=<COMMENTS>2</COMMENTS>
    my (
        $<CODE>i</CODE>,               $<CODE>in_quote</CODE>,    $<CODE>quote_character</CODE>,
        $<CODE>quote_pos</CODE>,       $<CODE>quote_depth</CODE>, $<CODE>quoted_string_1</CODE>,
        $<CODE>quoted_string_2</CODE>, $<CODE>rtokens</CODE>,     $<CODE>rtoken_map</CODE>,
        $<CODE>max_token_index</CODE>
    ) = @<CODE>_</CODE>;

    my $<CODE>in_quote_starting</CODE> = $<CODE>in_quote</CODE>;

    my $<CODE>quoted_string</CODE>;
    if ( $<CODE>in_quote</CODE> == 2 ) {    # <COMMENTS>two</COMMENTS> <COMMENTS>quotes</COMMENTS>/<COMMENTS>quoted_string_1s</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>follow</COMMENTS>
        my $<CODE>ibeg</CODE> = $<CODE>i</CODE>;
        (
            $<CODE>i</CODE>, $<CODE>in_quote</CODE>, $<CODE>quote_character</CODE>, $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>,
            $<CODE>quoted_string</CODE>
          )
          = <CODE>follow_quoted_string</CODE>( $<CODE>i</CODE>, $<CODE>in_quote</CODE>, $<CODE>rtokens</CODE>, $<CODE>quote_character</CODE>,
            $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>, $<CODE>max_token_index</CODE> );
        $<CODE>quoted_string_2</CODE> .= $<CODE>quoted_string</CODE>;
        if ( $<CODE>in_quote</CODE> == 1 ) {
            if ( $<CODE>quote_character</CODE> =~ /[\{\[\<\(]/ ) { $<CODE>i</CODE>++; }
            $<CODE>quote_character</CODE> = '';
        }
        else {
            $<CODE>quoted_string_2</CODE> .= "\n";
        }
    }

    if ( $<CODE>in_quote</CODE> == 1 ) {    # <COMMENTS>one</COMMENTS> (<COMMENTS>more</COMMENTS>) <COMMENTS>quote</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>follow</COMMENTS>
        my $<CODE>ibeg</CODE> = $<CODE>i</CODE>;
        (
            $<CODE>i</CODE>, $<CODE>in_quote</CODE>, $<CODE>quote_character</CODE>, $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>,
            $<CODE>quoted_string</CODE>
          )
          = <CODE>follow_quoted_string</CODE>( $<CODE>ibeg</CODE>, $<CODE>in_quote</CODE>, $<CODE>rtokens</CODE>, $<CODE>quote_character</CODE>,
            $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>, $<CODE>max_token_index</CODE> );
        $<CODE>quoted_string_1</CODE> .= $<CODE>quoted_string</CODE>;
        if ( $<CODE>in_quote</CODE> == 1 ) {
            $<CODE>quoted_string_1</CODE> .= "\n";
        }
    }
    return ( $<CODE>i</CODE>, $<CODE>in_quote</CODE>, $<CODE>quote_character</CODE>, $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>,
        $<CODE>quoted_string_1</CODE>, $<CODE>quoted_string_2</CODE> );
}

sub <CODE>follow_quoted_string</CODE> {

    # <COMMENTS>scan</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>specific</COMMENTS> <COMMENTS>token</COMMENTS>, <COMMENTS>skipping</COMMENTS> <COMMENTS>escaped</COMMENTS> <COMMENTS>characters</COMMENTS>
    # <COMMENTS>if</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>blank</COMMENTS>, <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS> <COMMENTS>character</COMMENTS>
    # <COMMENTS>input</COMMENTS> <COMMENTS>parameters</COMMENTS>:
    #   <COMMENTS>$rtokens</COMMENTS> = <COMMENTS>reference</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS>
    #   <COMMENTS>$i</COMMENTS> = <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>search</COMMENTS>
    #   <COMMENTS>$in_quote</COMMENTS> = <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>quoted</COMMENTS> <COMMENTS>strings</COMMENTS> <COMMENTS>being</COMMENTS> <COMMENTS>followed</COMMENTS>
    #   <COMMENTS>$beginning_tok</COMMENTS> = <COMMENTS>the</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>character</COMMENTS>
    #   <COMMENTS>$quote_pos</COMMENTS> = <COMMENTS>index</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>alphanumeric</COMMENTS> <COMMENTS>delimiter</COMMENTS>
    # <COMMENTS>output</COMMENTS> <COMMENTS>parameters</COMMENTS>:
    #   <COMMENTS>$i</COMMENTS> = <COMMENTS>the</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>index</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>character</COMMENTS>
    #   <COMMENTS>$in_quote</COMMENTS> = <COMMENTS>decremented</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>found</COMMENTS> <COMMENTS>end</COMMENTS>, <COMMENTS>unchanged</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS>
    #   <COMMENTS>$beginning_tok</COMMENTS> = <COMMENTS>the</COMMENTS> <COMMENTS>starting</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>character</COMMENTS>
    #   <COMMENTS>$quote_pos</COMMENTS> = <COMMENTS>index</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>next</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>alphanumeric</COMMENTS> <COMMENTS>delimiter</COMMENTS>
    #   <COMMENTS>$quote_depth</COMMENTS> = <COMMENTS>nesting</COMMENTS> <COMMENTS>depth</COMMENTS>, <COMMENTS>since</COMMENTS> <COMMENTS>delimiters</COMMENTS> '{ ( [ <' <COMMENTS>can</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>nested</COMMENTS>.
    #   <COMMENTS>$quoted_string</COMMENTS> = <COMMENTS>the</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>quote</COMMENTS> (<COMMENTS>without</COMMENTS> <COMMENTS>quotation</COMMENTS> <COMMENTS>tokens</COMMENTS>)
    my ( $<CODE>i_beg</CODE>, $<CODE>in_quote</CODE>, $<CODE>rtokens</CODE>, $<CODE>beginning_tok</CODE>, $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>,
        $<CODE>max_token_index</CODE> )
      = @<CODE>_</CODE>;
    my ( $<CODE>tok</CODE>, $<CODE>end_tok</CODE> );
    my $<CODE>i</CODE>             = $<CODE>i_beg</CODE> - 1;
    my $<CODE>quoted_string</CODE> = "";

    <CODE>TOKENIZER_DEBUG_FLAG_QUOTE</CODE> && do {
        print <CODE>STDOUT</CODE>
"<LITERALS>QUOTE</LITERALS> <LITERALS>entering</LITERALS> <LITERALS>with</LITERALS> <LITERALS>quote_pos</LITERALS> = $<CODE>quote_pos</CODE> <LITERALS>i</LITERALS>=$<CODE>i</CODE> <LITERALS>beginning_tok</LITERALS> =$<CODE>beginning_tok</CODE>\n";
    };

    # <COMMENTS>get</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>corresponding</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>token</COMMENTS>
    if ( $<CODE>beginning_tok</CODE> !~ /^\s*$/ ) {
        $<CODE>end_tok</CODE> = <CODE>matching_end_token</CODE>($<CODE>beginning_tok</CODE>);
    }

    # <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>means</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>find</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>use</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>first</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>blank</COMMENTS> <COMMENTS>one</COMMENTS>
    else {
        my $<CODE>allow_quote_comments</CODE> = ( $<CODE>i</CODE> < 0 ) ? 1 : 0; # <COMMENTS>i</COMMENTS><<COMMENTS>0</COMMENTS> <COMMENTS>means</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>saw</COMMENTS> <COMMENTS>a</COMMENTS> <<COMMENTS>cr</COMMENTS>>

        while ( $<CODE>i</CODE> < $<CODE>max_token_index</CODE> ) {
            $<CODE>tok</CODE> = $$<CODE>rtokens</CODE>[ ++$<CODE>i</CODE> ];

            if ( $<CODE>tok</CODE> !~ /^\s*$/ ) {

                if ( ( $<CODE>tok</CODE> eq '#' ) && ($<CODE>allow_quote_comments</CODE>) ) {
                    $<CODE>i</CODE> = $<CODE>max_token_index</CODE>;
                }
                else {

                    if ( length($<CODE>tok</CODE>) > 1 ) {
                        if ( $<CODE>quote_pos</CODE> <= 0 ) { $<CODE>quote_pos</CODE> = 1 }
                        $<CODE>beginning_tok</CODE> = substr( $<CODE>tok</CODE>, $<CODE>quote_pos</CODE> - 1, 1 );
                    }
                    else {
                        $<CODE>beginning_tok</CODE> = $<CODE>tok</CODE>;
                        $<CODE>quote_pos</CODE>     = 0;
                    }
                    $<CODE>end_tok</CODE>     = <CODE>matching_end_token</CODE>($<CODE>beginning_tok</CODE>);
                    $<CODE>quote_depth</CODE> = 1;
                    last;
                }
            }
            else {
                $<CODE>allow_quote_comments</CODE> = 1;
            }
        }
    }

    # <COMMENTS>There</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>two</COMMENTS> <COMMENTS>different</COMMENTS> <COMMENTS>loops</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>search</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>ending</COMMENTS> <COMMENTS>quote</COMMENTS>
    # <COMMENTS>character</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>rare</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>alphanumeric</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>delimiter</COMMENTS>, <COMMENTS>we</COMMENTS>
    # <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>through</COMMENTS> <COMMENTS>alphanumeric</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>character</COMMENTS>-<COMMENTS>by</COMMENTS>-<COMMENTS>character</COMMENTS>, <COMMENTS>since</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>tokenization</COMMENTS> <COMMENTS>process</COMMENTS> <COMMENTS>combines</COMMENTS> <COMMENTS>multiple</COMMENTS> <COMMENTS>alphanumeric</COMMENTS>
    # <COMMENTS>characters</COMMENTS>, <COMMENTS>whereas</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>alphanumeric</COMMENTS> <COMMENTS>delimiter</COMMENTS>, <COMMENTS>only</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>of</COMMENTS>
    # <COMMENTS>length</COMMENTS> <COMMENTS>1</COMMENTS> <COMMENTS>can</COMMENTS> <COMMENTS>match</COMMENTS>.

    ###################################################################
    # <COMMENTS>Case</COMMENTS> <COMMENTS>1</COMMENTS> (<COMMENTS>rare</COMMENTS>): <COMMENTS>loop</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>alphanumeric</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>delimiter</COMMENTS>..
    # "<COMMENTS>quote_pos</COMMENTS>" <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>position</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>word</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>begin</COMMENTS> <COMMENTS>searching</COMMENTS>
    ###################################################################
    if ( $<CODE>beginning_tok</CODE> =~ /\w/ ) {

        # <COMMENTS>Note</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>recommended</COMMENTS> <COMMENTS>practice</COMMENTS> <COMMENTS>except</COMMENTS>
        # <COMMENTS>for</COMMENTS> <COMMENTS>obfuscated</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>contests</COMMENTS>
        if ( $<CODE>in_quote</CODE> == 1 ) {
            <CODE>write_logfile_entry</CODE>(
                "<LITERALS>Note</LITERALS>: <LITERALS>alphanumeric</LITERALS> <LITERALS>quote</LITERALS> <LITERALS>delimiter</LITERALS> ($<CODE>beginning_tok</CODE>) \n");
        }

        while ( $<CODE>i</CODE> < $<CODE>max_token_index</CODE> ) {

            if ( $<CODE>quote_pos</CODE> == 0 || ( $<CODE>i</CODE> < 0 ) ) {
                $<CODE>tok</CODE> = $$<CODE>rtokens</CODE>[ ++$<CODE>i</CODE> ];

                if ( $<CODE>tok</CODE> eq '\\' ) {

                    # <COMMENTS>retain</COMMENTS> <COMMENTS>backslash</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>hides</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>token</COMMENTS>
                    $<CODE>quoted_string</CODE> .= $<CODE>tok</CODE>
                      unless $$<CODE>rtokens</CODE>[ $<CODE>i</CODE> + 1 ] eq $<CODE>end_tok</CODE>;
                    $<CODE>quote_pos</CODE>++;
                    last if ( $<CODE>i</CODE> >= $<CODE>max_token_index</CODE> );
                    $<CODE>tok</CODE> = $$<CODE>rtokens</CODE>[ ++$<CODE>i</CODE> ];
                }
            }
            my $<CODE>old_pos</CODE> = $<CODE>quote_pos</CODE>;

            unless ( defined($<CODE>tok</CODE>) && defined($<CODE>end_tok</CODE>) && defined($<CODE>quote_pos</CODE>) )
            {

            }
            $<CODE>quote_pos</CODE> = 1 + index( $<CODE>tok</CODE>, $<CODE>end_tok</CODE>, $<CODE>quote_pos</CODE> );

            if ( $<CODE>quote_pos</CODE> > 0 ) {

                $<CODE>quoted_string</CODE> .=
                  substr( $<CODE>tok</CODE>, $<CODE>old_pos</CODE>, $<CODE>quote_pos</CODE> - $<CODE>old_pos</CODE> - 1 );

                $<CODE>quote_depth</CODE>--;

                if ( $<CODE>quote_depth</CODE> == 0 ) {
                    $<CODE>in_quote</CODE>--;
                    last;
                }
            }
            else {
                $<CODE>quoted_string</CODE> .= substr( $<CODE>tok</CODE>, $<CODE>old_pos</CODE> );
            }
        }
    }

    ########################################################################
    # <COMMENTS>Case</COMMENTS> <COMMENTS>2</COMMENTS> (<COMMENTS>normal</COMMENTS>): <COMMENTS>loop</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>non</COMMENTS>-<COMMENTS>alphanumeric</COMMENTS> <COMMENTS>quote</COMMENTS> <COMMENTS>delimiter</COMMENTS>..
    ########################################################################
    else {

        while ( $<CODE>i</CODE> < $<CODE>max_token_index</CODE> ) {
            $<CODE>tok</CODE> = $$<CODE>rtokens</CODE>[ ++$<CODE>i</CODE> ];

            if ( $<CODE>tok</CODE> eq $<CODE>end_tok</CODE> ) {
                $<CODE>quote_depth</CODE>--;

                if ( $<CODE>quote_depth</CODE> == 0 ) {
                    $<CODE>in_quote</CODE>--;
                    last;
                }
            }
            elsif ( $<CODE>tok</CODE> eq $<CODE>beginning_tok</CODE> ) {
                $<CODE>quote_depth</CODE>++;
            }
            elsif ( $<CODE>tok</CODE> eq '\\' ) {

                # <COMMENTS>retain</COMMENTS> <COMMENTS>backslash</COMMENTS> <COMMENTS>unless</COMMENTS> <COMMENTS>it</COMMENTS> <COMMENTS>hides</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>beginning</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>end</COMMENTS> <COMMENTS>token</COMMENTS>
                $<CODE>tok</CODE> = $$<CODE>rtokens</CODE>[ ++$<CODE>i</CODE> ];
                $<CODE>quoted_string</CODE> .= '\\'
                  unless ( $<CODE>tok</CODE> eq $<CODE>end_tok</CODE> || $<CODE>tok</CODE> eq $<CODE>beginning_tok</CODE> );
            }
            $<CODE>quoted_string</CODE> .= $<CODE>tok</CODE>;
        }
    }
    if ( $<CODE>i</CODE> > $<CODE>max_token_index</CODE> ) { $<CODE>i</CODE> = $<CODE>max_token_index</CODE> }
    return ( $<CODE>i</CODE>, $<CODE>in_quote</CODE>, $<CODE>beginning_tok</CODE>, $<CODE>quote_pos</CODE>, $<CODE>quote_depth</CODE>,
        $<CODE>quoted_string</CODE> );
}

sub <CODE>indicate_error</CODE> {
    my ( $<CODE>msg</CODE>, $<CODE>line_number</CODE>, $<CODE>input_line</CODE>, $<CODE>pos</CODE>, $<CODE>carrat</CODE> ) = @<CODE>_</CODE>;
    <CODE>interrupt_logfile</CODE>();
    <CODE>warning</CODE>($<CODE>msg</CODE>);
    <CODE>write_error_indicator_pair</CODE>( $<CODE>line_number</CODE>, $<CODE>input_line</CODE>, $<CODE>pos</CODE>, $<CODE>carrat</CODE> );
    <CODE>resume_logfile</CODE>();
}

sub <CODE>write_error_indicator_pair</CODE> {
    my ( $<CODE>line_number</CODE>, $<CODE>input_line</CODE>, $<CODE>pos</CODE>, $<CODE>carrat</CODE> ) = @<CODE>_</CODE>;
    my ( $<CODE>offset</CODE>, $<CODE>numbered_line</CODE>, $<CODE>underline</CODE> ) =
      <CODE>make_numbered_line</CODE>( $<CODE>line_number</CODE>, $<CODE>input_line</CODE>, $<CODE>pos</CODE> );
    $<CODE>underline</CODE> = <CODE>write_on_underline</CODE>( $<CODE>underline</CODE>, $<CODE>pos</CODE> - $<CODE>offset</CODE>, $<CODE>carrat</CODE> );
    <CODE>warning</CODE>( $<CODE>numbered_line</CODE> . "\n" );
    $<CODE>underline</CODE> =~ s/\s*$//;
    <CODE>warning</CODE>( $<CODE>underline</CODE> . "\n" );
}

sub <CODE>make_numbered_line</CODE> {

    #  <COMMENTS>Given</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>input</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>its</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>position</COMMENTS> <COMMENTS>of</COMMENTS>
    #  <COMMENTS>interest</COMMENTS>, <COMMENTS>create</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>longer</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>80</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>form</COMMENTS>
    #     <COMMENTS>$lineno</COMMENTS>: <COMMENTS>sub_string</COMMENTS>
    #  <COMMENTS>such</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>sub_string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>$str</COMMENTS> <COMMENTS>contains</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>position</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>interest</COMMENTS>
    #
    #  <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>what</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS>, <COMMENTS>in</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>trailing</COMMENTS>
    #  '...' <COMMENTS>because</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>long</COMMENTS>.
    #
    # <COMMENTS>2</COMMENTS>: (<COMMENTS>One</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>QAML</COMMENTS> <COMMENTS>2</COMMENTS>.<COMMENTS>0</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>authors</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>member</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>World</COMMENTS> <COMMENTS>Wide</COMMENTS> <COMMENTS>Web</COMMENTS> <COMMENTS>Con</COMMENTS> ...
    #
    #  <COMMENTS>Here</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>another</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>this</COMMENTS> <COMMENTS>time</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>leading</COMMENTS> '...'
    #  <COMMENTS>because</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>excessive</COMMENTS> <COMMENTS>length</COMMENTS>:
    #
    # <COMMENTS>2</COMMENTS>: ... <COMMENTS>er</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>World</COMMENTS> <COMMENTS>Wide</COMMENTS> <COMMENTS>Web</COMMENTS> <COMMENTS>Consortium</COMMENTS>'<COMMENTS>s</COMMENTS>
    #
    #  <COMMENTS>input</COMMENTS> <COMMENTS>parameters</COMMENTS> <COMMENTS>are</COMMENTS>:
    #   <COMMENTS>$lineno</COMMENTS> = <COMMENTS>line</COMMENTS> <COMMENTS>number</COMMENTS>
    #   <COMMENTS>$str</COMMENTS> = <COMMENTS>the</COMMENTS> <COMMENTS>text</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS>
    #   <COMMENTS>$pos</COMMENTS> = <COMMENTS>position</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>interest</COMMENTS> (<COMMENTS>the</COMMENTS> <COMMENTS>error</COMMENTS>) : <COMMENTS>0</COMMENTS> = <COMMENTS>first</COMMENTS> <COMMENTS>character</COMMENTS>
    #
    #   <COMMENTS>We</COMMENTS> <COMMENTS>return</COMMENTS> :
    #     - <COMMENTS>$offset</COMMENTS> = <COMMENTS>an</COMMENTS> <COMMENTS>offset</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>corrects</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>position</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>case</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>only</COMMENTS>
    #       <COMMENTS>display</COMMENTS> <COMMENTS>part</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>line</COMMENTS>, <COMMENTS>such</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>$pos</COMMENTS>-<COMMENTS>$offset</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>effective</COMMENTS>
    #       <COMMENTS>position</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>displayed</COMMENTS> <COMMENTS>line</COMMENTS>.
    #     - <COMMENTS>$numbered_line</COMMENTS> = <COMMENTS>the</COMMENTS> <COMMENTS>numbered</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>above</COMMENTS>,
    #     - <COMMENTS>$underline</COMMENTS> = <COMMENTS>a</COMMENTS> <COMMENTS>blank</COMMENTS> '<COMMENTS>underline</COMMENTS>' <COMMENTS>which</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>spaces</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS>
    #       <COMMENTS>number</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>characters</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>numbered</COMMENTS> <COMMENTS>line</COMMENTS>.

    my ( $<CODE>lineno</CODE>, $<CODE>str</CODE>, $<CODE>pos</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>offset</CODE> = ( $<CODE>pos</CODE> < 60 ) ? 0 : $<CODE>pos</CODE> - 40;
    my $<CODE>excess</CODE> = length($<CODE>str</CODE>) - $<CODE>offset</CODE> - 68;
    my $<CODE>numc</CODE>   = ( $<CODE>excess</CODE> > 0 ) ? 68 : undef;

    if ( defined($<CODE>numc</CODE>) ) {
        if ( $<CODE>offset</CODE> == 0 ) {
            $<CODE>str</CODE> = substr( $<CODE>str</CODE>, $<CODE>offset</CODE>, $<CODE>numc</CODE> - 4 ) . " ...";
        }
        else {
            $<CODE>str</CODE> = "... " . substr( $<CODE>str</CODE>, $<CODE>offset</CODE> + 4, $<CODE>numc</CODE> - 4 ) . " ...";
        }
    }
    else {

        if ( $<CODE>offset</CODE> == 0 ) {
        }
        else {
            $<CODE>str</CODE> = "... " . substr( $<CODE>str</CODE>, $<CODE>offset</CODE> + 4 );
        }
    }

    my $<CODE>numbered_line</CODE> = sprintf( "%<LITERALS>d</LITERALS>: ", $<CODE>lineno</CODE> );
    $<CODE>offset</CODE> -= length($<CODE>numbered_line</CODE>);
    $<CODE>numbered_line</CODE> .= $<CODE>str</CODE>;
    my $<CODE>underline</CODE> = " " x length($<CODE>numbered_line</CODE>);
    return ( $<CODE>offset</CODE>, $<CODE>numbered_line</CODE>, $<CODE>underline</CODE> );
}

sub <CODE>write_on_underline</CODE> {

    # <COMMENTS>The</COMMENTS> "<COMMENTS>underline</COMMENTS>" <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>shows</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>is</COMMENTS>; <COMMENTS>it</COMMENTS> <COMMENTS>starts</COMMENTS>
    # <COMMENTS>out</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>blanks</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>length</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>numbered</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS>
    # <COMMENTS>code</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>it</COMMENTS>, <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>marking</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>show</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>is</COMMENTS>.
    # <COMMENTS>In</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>example</COMMENTS> <COMMENTS>below</COMMENTS>, <COMMENTS>we</COMMENTS> <COMMENTS>want</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>string</COMMENTS> '--^' <COMMENTS>just</COMMENTS> <COMMENTS>below</COMMENTS>
    # <COMMENTS>the</COMMENTS> <COMMENTS>line</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>bad</COMMENTS> <COMMENTS>code</COMMENTS>:
    #
    # <COMMENTS>2</COMMENTS>: (<COMMENTS>One</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>QAML</COMMENTS> <COMMENTS>2</COMMENTS>.<COMMENTS>0</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>authors</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>member</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>World</COMMENTS> <COMMENTS>Wide</COMMENTS> <COMMENTS>Web</COMMENTS> <COMMENTS>Con</COMMENTS> ...
    #                 ---^
    # <COMMENTS>We</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>given</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>current</COMMENTS> <COMMENTS>underline</COMMENTS> <COMMENTS>string</COMMENTS>, <COMMENTS>plus</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>position</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>a</COMMENTS>
    # <COMMENTS>string</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>write</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>it</COMMENTS>.
    #
    # <COMMENTS>In</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>example</COMMENTS>, <COMMENTS>there</COMMENTS> <COMMENTS>will</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>2</COMMENTS> <COMMENTS>calls</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>this</COMMENTS>:
    # <COMMENTS>First</COMMENTS> <COMMENTS>call</COMMENTS>:  <COMMENTS>$pos</COMMENTS>=<COMMENTS>19</COMMENTS>, <COMMENTS>pos_chr</COMMENTS>=^
    # <COMMENTS>Second</COMMENTS> <COMMENTS>call</COMMENTS>: <COMMENTS>$pos</COMMENTS>=<COMMENTS>16</COMMENTS>, <COMMENTS>pos_chr</COMMENTS>=---
    #
    # <COMMENTS>This</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>trivial</COMMENTS> <COMMENTS>thing</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>with</COMMENTS> <COMMENTS>substr</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>there</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>some</COMMENTS>
    # <COMMENTS>checking</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>do</COMMENTS>.

    my ( $<CODE>underline</CODE>, $<CODE>pos</CODE>, $<CODE>pos_chr</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>check</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>error</COMMENTS>..<COMMENTS>shouldn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>happen</COMMENTS>
    unless ( ( $<CODE>pos</CODE> >= 0 ) && ( $<CODE>pos</CODE> <= length($<CODE>underline</CODE>) ) ) {
        return $<CODE>underline</CODE>;
    }
    my $<CODE>excess</CODE> = length($<CODE>pos_chr</CODE>) + $<CODE>pos</CODE> - length($<CODE>underline</CODE>);
    if ( $<CODE>excess</CODE> > 0 ) {
        $<CODE>pos_chr</CODE> = substr( $<CODE>pos_chr</CODE>, 0, length($<CODE>pos_chr</CODE>) - $<CODE>excess</CODE> );
    }
    substr( $<CODE>underline</CODE>, $<CODE>pos</CODE>, length($<CODE>pos_chr</CODE>) ) = $<CODE>pos_chr</CODE>;
    return ($<CODE>underline</CODE>);
}

sub <CODE>pre_tokenize</CODE> {

    # <COMMENTS>Break</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>string</COMMENTS>, <COMMENTS>$str</COMMENTS>, <COMMENTS>into</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>sequence</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>preliminary</COMMENTS> <COMMENTS>tokens</COMMENTS>.  <COMMENTS>We</COMMENTS>
    # <COMMENTS>are</COMMENTS> <COMMENTS>interested</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>tokens</COMMENTS>:
    #   <COMMENTS>words</COMMENTS>       (<COMMENTS>type</COMMENTS>='<COMMENTS>w</COMMENTS>'),            <COMMENTS>example</COMMENTS>: '<COMMENTS>max_tokens_wanted</COMMENTS>'
    #   <COMMENTS>digits</COMMENTS>      (<COMMENTS>type</COMMENTS> = '<COMMENTS>d</COMMENTS>'),          <COMMENTS>example</COMMENTS>: '<COMMENTS>0755</COMMENTS>'
    #   <COMMENTS>whitespace</COMMENTS>  (<COMMENTS>type</COMMENTS> = '<COMMENTS>b</COMMENTS>'),          <COMMENTS>example</COMMENTS>: '   '
    #   <COMMENTS>any</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>single</COMMENTS> <COMMENTS>character</COMMENTS> (<COMMENTS>i</COMMENTS>.<COMMENTS>e</COMMENTS>. <COMMENTS>punct</COMMENTS>; <COMMENTS>type</COMMENTS> = <COMMENTS>the</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>itself</COMMENTS>).
    # <COMMENTS>We</COMMENTS> <COMMENTS>cannot</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>better</COMMENTS> <COMMENTS>than</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>yet</COMMENTS> <COMMENTS>because</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>quoted</COMMENTS>
    # <COMMENTS>string</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>pattern</COMMENTS>.  <COMMENTS>Caller</COMMENTS> <COMMENTS>sets</COMMENTS> <COMMENTS>$max_tokens_wanted</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>0</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>get</COMMENTS> <COMMENTS>all</COMMENTS>
    # <COMMENTS>tokens</COMMENTS>.
    my ( $<CODE>str</CODE>, $<CODE>max_tokens_wanted</CODE> ) = @<CODE>_</CODE>;

    # <COMMENTS>we</COMMENTS> <COMMENTS>return</COMMENTS> <COMMENTS>references</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>3</COMMENTS> <COMMENTS>arrays</COMMENTS>:
    my @<CODE>tokens</CODE>    = ();     # <COMMENTS>array</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>themselves</COMMENTS>
    my @<CODE>token_map</CODE> = (0);    # <COMMENTS>string</COMMENTS> <COMMENTS>position</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>start</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>each</COMMENTS> <COMMENTS>token</COMMENTS>
    my @<CODE>type</CODE>      = ();     # '<COMMENTS>b</COMMENTS>'=<COMMENTS>whitespace</COMMENTS>, '<COMMENTS>d</COMMENTS>'=<COMMENTS>digits</COMMENTS>, '<COMMENTS>w</COMMENTS>'=<COMMENTS>alpha</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>punct</COMMENTS>

    do {

        # <COMMENTS>whitespace</COMMENTS>
        if ( $<CODE>str</CODE> =~ /\G(\s+)/gc ) { push @<CODE>type</CODE>, '<LITERALS>b</LITERALS>'; }

        # <COMMENTS>numbers</COMMENTS>
        # <COMMENTS>note</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>must</COMMENTS> <COMMENTS>come</COMMENTS> <COMMENTS>before</COMMENTS> <COMMENTS>words</COMMENTS>!
        elsif ( $<CODE>str</CODE> =~ /\G(\d+)/gc ) { push @<CODE>type</CODE>, '<LITERALS>d</LITERALS>'; }

        # <COMMENTS>words</COMMENTS>
        elsif ( $<CODE>str</CODE> =~ /\G(\w+)/gc ) { push @<CODE>type</CODE>, '<LITERALS>w</LITERALS>'; }

        # <COMMENTS>single</COMMENTS>-<COMMENTS>character</COMMENTS> <COMMENTS>punctuation</COMMENTS>
        elsif ( $<CODE>str</CODE> =~ /\G(\W)/gc ) { push @<CODE>type</CODE>, $<CODE>1</CODE>; }

        # <COMMENTS>that</COMMENTS>'<COMMENTS>s</COMMENTS> <COMMENTS>all</COMMENTS>..
        else {
            return ( \@<CODE>tokens</CODE>, \@<CODE>token_map</CODE>, \@<CODE>type</CODE> );
        }

        push @<CODE>tokens</CODE>,    $<CODE>1</CODE>;
        push @<CODE>token_map</CODE>, pos($<CODE>str</CODE>);

    } while ( --$<CODE>max_tokens_wanted</CODE> != 0 );

    return ( \@<CODE>tokens</CODE>, \@<CODE>token_map</CODE>, \@<CODE>type</CODE> );
}

sub <CODE>show_tokens</CODE> {

    # <COMMENTS>this</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>old</COMMENTS> <COMMENTS>debug</COMMENTS> <COMMENTS>routine</COMMENTS>
    my ( $<CODE>rtokens</CODE>, $<CODE>rtoken_map</CODE> ) = @<CODE>_</CODE>;
    my $<CODE>num</CODE> = scalar(@$<CODE>rtokens</CODE>);
    my $<CODE>i</CODE>;

    for ( $<CODE>i</CODE> = 0 ; $<CODE>i</CODE> < $<CODE>num</CODE> ; $<CODE>i</CODE>++ ) {
        my $<CODE>len</CODE> = length( $$<CODE>rtokens</CODE>[$<CODE>i</CODE>] );
        print <CODE>STDOUT</CODE> "$<CODE>i</CODE>:$<CODE>len</CODE>:$$<CODE>rtoken_map</CODE>[$<CODE>i</CODE>]:$$<CODE>rtokens</CODE>[$<CODE>i</CODE>]:\n";
    }
}

sub <CODE>matching_end_token</CODE> {

    # <COMMENTS>find</COMMENTS> <COMMENTS>closing</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>pattern</COMMENTS>
    my $<CODE>beginning_token</CODE> = shift;

    if ( $<CODE>beginning_token</CODE> eq '{' ) {
        '}';
    }
    elsif ( $<CODE>beginning_token</CODE> eq '[' ) {
        ']';
    }
    elsif ( $<CODE>beginning_token</CODE> eq '<' ) {
        '>';
    }
    elsif ( $<CODE>beginning_token</CODE> eq '(' ) {
        ')';
    }
    else {
        $<CODE>beginning_token</CODE>;
    }
}

sub <CODE>dump_token_types</CODE> {
    my $<CODE>class</CODE> = shift;
    my $<CODE>fh</CODE>    = shift;

    # <COMMENTS>This</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>latest</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>use</COMMENTS>
    # <COMMENTS>adding</COMMENTS> <COMMENTS>NEW_TOKENS</COMMENTS>: <COMMENTS>add</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>comment</COMMENTS> <COMMENTS>here</COMMENTS>
    print $<CODE>fh</CODE> <<'<LITERALS>END_OF_LIST</LITERALS>';

<LITERALS>Here</LITERALS> <LITERALS>is</LITERALS> <LITERALS>a</LITERALS> <LITERALS>list</LITERALS> <LITERALS>of</LITERALS> <LITERALS>the</LITERALS> <LITERALS>token</LITERALS> <LITERALS>types</LITERALS> <LITERALS>currently</LITERALS> <LITERALS>used</LITERALS> <LITERALS>for</LITERALS> <LITERALS>lines</LITERALS> <LITERALS>of</LITERALS> <LITERALS>type</LITERALS> '<LITERALS>CODE</LITERALS>'.
<LITERALS>For</LITERALS> <LITERALS>the</LITERALS> <LITERALS>following</LITERALS> <LITERALS>tokens</LITERALS>, <LITERALS>the</LITERALS> "<LITERALS>type</LITERALS>" <LITERALS>of</LITERALS> <LITERALS>a</LITERALS> <LITERALS>token</LITERALS> <LITERALS>is</LITERALS> <LITERALS>just</LITERALS> <LITERALS>the</LITERALS> <LITERALS>token</LITERALS> <LITERALS>itself</LITERALS>.

.. :: << >> ** && .. || // -> => += -= .= %= &= |= ^= *= <>
( ) <= >= == =~ !~ != ++ -- /= <LITERALS>x</LITERALS>=
... **= <<= >>= &&= ||= //= <=>
, + - / * | % ! <LITERALS>x</LITERALS> ~ = \ ? : . < > ^ &

<LITERALS>The</LITERALS> <LITERALS>following</LITERALS> <LITERALS>additional</LITERALS> <LITERALS>token</LITERALS> <LITERALS>types</LITERALS> <LITERALS>are</LITERALS> <LITERALS>defined</LITERALS>:

 <LITERALS>type</LITERALS>    <LITERALS>meaning</LITERALS>
    <LITERALS>b</LITERALS>    <LITERALS>blank</LITERALS> (<LITERALS>white</LITERALS> <LITERALS>space</LITERALS>)
    {    <LITERALS>indent</LITERALS>: <LITERALS>opening</LITERALS> <LITERALS>structural</LITERALS> <LITERALS>curly</LITERALS> <LITERALS>brace</LITERALS> <LITERALS>or</LITERALS> <LITERALS>square</LITERALS> <LITERALS>bracket</LITERALS> <LITERALS>or</LITERALS> <LITERALS>paren</LITERALS>
         (<LITERALS>code</LITERALS> <LITERALS>block</LITERALS>, <LITERALS>anonymous</LITERALS> <LITERALS>hash</LITERALS> <LITERALS>reference</LITERALS>, <LITERALS>or</LITERALS> <LITERALS>anonymous</LITERALS> <LITERALS>array</LITERALS> <LITERALS>reference</LITERALS>)
    }    <LITERALS>outdent</LITERALS>: <LITERALS>right</LITERALS> <LITERALS>structural</LITERALS> <LITERALS>curly</LITERALS> <LITERALS>brace</LITERALS> <LITERALS>or</LITERALS> <LITERALS>square</LITERALS> <LITERALS>bracket</LITERALS> <LITERALS>or</LITERALS> <LITERALS>paren</LITERALS>
    [    <LITERALS>left</LITERALS> <LITERALS>non</LITERALS>-<LITERALS>structural</LITERALS> <LITERALS>square</LITERALS> <LITERALS>bracket</LITERALS> (<LITERALS>enclosing</LITERALS> <LITERALS>an</LITERALS> <LITERALS>array</LITERALS> <LITERALS>index</LITERALS>)
    ]    <LITERALS>right</LITERALS> <LITERALS>non</LITERALS>-<LITERALS>structural</LITERALS> <LITERALS>square</LITERALS> <LITERALS>bracket</LITERALS>
    (    <LITERALS>left</LITERALS> <LITERALS>non</LITERALS>-<LITERALS>structural</LITERALS> <LITERALS>paren</LITERALS> (<LITERALS>all</LITERALS> <LITERALS>but</LITERALS> <LITERALS>a</LITERALS> <LITERALS>list</LITERALS> <LITERALS>right</LITERALS> <LITERALS>of</LITERALS> <LITERALS>an</LITERALS> =)
    )    <LITERALS>right</LITERALS> <LITERALS>non</LITERALS>-<LITERALS>structural</LITERALS> <LITERALS>paren</LITERALS>
    <LITERALS>L</LITERALS>    <LITERALS>left</LITERALS> <LITERALS>non</LITERALS>-<LITERALS>structural</LITERALS> <LITERALS>curly</LITERALS> <LITERALS>brace</LITERALS> (<LITERALS>enclosing</LITERALS> <LITERALS>a</LITERALS> <LITERALS>key</LITERALS>)
    <LITERALS>R</LITERALS>    <LITERALS>right</LITERALS> <LITERALS>non</LITERALS>-<LITERALS>structural</LITERALS> <LITERALS>curly</LITERALS> <LITERALS>brace</LITERALS>
    ;    <LITERALS>terminal</LITERALS> <LITERALS>semicolon</LITERALS>
    <LITERALS>f</LITERALS>    <LITERALS>indicates</LITERALS> <LITERALS>a</LITERALS> <LITERALS>semicolon</LITERALS> <LITERALS>in</LITERALS> <LITERALS>a</LITERALS> "<LITERALS>for</LITERALS>" <LITERALS>statement</LITERALS>
    <LITERALS>h</LITERALS>    <LITERALS>here_doc</LITERALS> <LITERALS>operator</LITERALS> <<
    #    <LITERALS>a</LITERALS> <LITERALS>comment</LITERALS>
    <LITERALS>Q</LITERALS>    <LITERALS>indicates</LITERALS> <LITERALS>a</LITERALS> <LITERALS>quote</LITERALS> <LITERALS>or</LITERALS> <LITERALS>pattern</LITERALS>
    <LITERALS>q</LITERALS>    <LITERALS>indicates</LITERALS> <LITERALS>a</LITERALS> <LITERALS>qw</LITERALS> <LITERALS>quote</LITERALS> <LITERALS>block</LITERALS>
    <LITERALS>k</LITERALS>    <LITERALS>a</LITERALS> <LITERALS>perl</LITERALS> <LITERALS>keyword</LITERALS>
    <LITERALS>C</LITERALS>    <LITERALS>user</LITERALS>-<LITERALS>defined</LITERALS> <LITERALS>constant</LITERALS> <LITERALS>or</LITERALS> <LITERALS>constant</LITERALS> <LITERALS>function</LITERALS> (<LITERALS>with</LITERALS> <LITERALS>void</LITERALS> <LITERALS>prototype</LITERALS> = ())
    <LITERALS>U</LITERALS>    <LITERALS>user</LITERALS>-<LITERALS>defined</LITERALS> <LITERALS>function</LITERALS> <LITERALS>taking</LITERALS> <LITERALS>parameters</LITERALS>
    <LITERALS>G</LITERALS>    <LITERALS>user</LITERALS>-<LITERALS>defined</LITERALS> <LITERALS>function</LITERALS> <LITERALS>taking</LITERALS> <LITERALS>block</LITERALS> <LITERALS>parameter</LITERALS> (<LITERALS>like</LITERALS> <LITERALS>grep</LITERALS>/<LITERALS>map</LITERALS>/<LITERALS>eval</LITERALS>)
    <LITERALS>M</LITERALS>    (<LITERALS>unused</LITERALS>, <LITERALS>but</LITERALS> <LITERALS>reserved</LITERALS> <LITERALS>for</LITERALS> <LITERALS>subroutine</LITERALS> <LITERALS>definition</LITERALS> <LITERALS>name</LITERALS>)
    <LITERALS>P</LITERALS>    (<LITERALS>unused</LITERALS>, <LITERALS>but</LITERALS> -<LITERALS>html</LITERALS> <LITERALS>uses</LITERALS> <LITERALS>it</LITERALS> <LITERALS>to</LITERALS> <LITERALS>label</LITERALS> <LITERALS>pod</LITERALS> <LITERALS>text</LITERALS>)
    <LITERALS>t</LITERALS>    <LITERALS>type</LITERALS> <LITERALS>indicater</LITERALS> <LITERALS>such</LITERALS> <LITERALS>as</LITERALS> %,<LITERALS>$</LITERALS>,@,*,&,<LITERALS>sub</LITERALS>
    <LITERALS>w</LITERALS>    <LITERALS>bare</LITERALS> <LITERALS>word</LITERALS> (<LITERALS>perhaps</LITERALS> <LITERALS>a</LITERALS> <LITERALS>subroutine</LITERALS> <LITERALS>call</LITERALS>)
    <LITERALS>i</LITERALS>    <LITERALS>identifier</LITERALS> <LITERALS>of</LITERALS> <LITERALS>some</LITERALS> <LITERALS>type</LITERALS> (<LITERALS>with</LITERALS> <LITERALS>leading</LITERALS> %, <LITERALS>$</LITERALS>, @, *, &, <LITERALS>sub</LITERALS>, -> )
    <LITERALS>n</LITERALS>    <LITERALS>a</LITERALS> <LITERALS>number</LITERALS>
    <LITERALS>v</LITERALS>    <LITERALS>a</LITERALS> <LITERALS>v</LITERALS>-<LITERALS>string</LITERALS>
    <LITERALS>F</LITERALS>    <LITERALS>a</LITERALS> <LITERALS>file</LITERALS> <LITERALS>test</LITERALS> <LITERALS>operator</LITERALS> (<LITERALS>like</LITERALS> -<LITERALS>e</LITERALS>)
    <LITERALS>Y</LITERALS>    <LITERALS>File</LITERALS> <LITERALS>handle</LITERALS>
    <LITERALS>Z</LITERALS>    <LITERALS>identifier</LITERALS> <LITERALS>in</LITERALS> <LITERALS>indirect</LITERALS> <LITERALS>object</LITERALS> <LITERALS>slot</LITERALS>: <LITERALS>may</LITERALS> <LITERALS>be</LITERALS> <LITERALS>file</LITERALS> <LITERALS>handle</LITERALS>, <LITERALS>object</LITERALS>
    <LITERALS>J</LITERALS>    <LITERALS>LABEL</LITERALS>:  <LITERALS>code</LITERALS> <LITERALS>block</LITERALS> <LITERALS>label</LITERALS>
    <LITERALS>j</LITERALS>    <LITERALS>LABEL</LITERALS> <LITERALS>after</LITERALS> <LITERALS>next</LITERALS>, <LITERALS>last</LITERALS>, <LITERALS>redo</LITERALS>, <LITERALS>goto</LITERALS>
    <LITERALS>p</LITERALS>    <LITERALS>unary</LITERALS> +
    <LITERALS>m</LITERALS>    <LITERALS>unary</LITERALS> -
    <LITERALS>pp</LITERALS>   <LITERALS>pre</LITERALS>-<LITERALS>increment</LITERALS> <LITERALS>operator</LITERALS> ++
    <LITERALS>mm</LITERALS>   <LITERALS>pre</LITERALS>-<LITERALS>decrement</LITERALS> <LITERALS>operator</LITERALS> --
    <LITERALS>A</LITERALS>    : <LITERALS>used</LITERALS> <LITERALS>as</LITERALS> <LITERALS>attribute</LITERALS> <LITERALS>separator</LITERALS>

    <LITERALS>Here</LITERALS> <LITERALS>are</LITERALS> <LITERALS>the</LITERALS> '<LITERALS>_line_type</LITERALS>' <LITERALS>codes</LITERALS> <LITERALS>used</LITERALS> <LITERALS>internally</LITERALS>:
    <LITERALS>SYSTEM</LITERALS>         - <LITERALS>system</LITERALS>-<LITERALS>specific</LITERALS> <LITERALS>code</LITERALS> <LITERALS>before</LITERALS> <LITERALS>hash</LITERALS>-<LITERALS>bang</LITERALS> <LITERALS>line</LITERALS>
    <LITERALS>CODE</LITERALS>           - <LITERALS>line</LITERALS> <LITERALS>of</LITERALS> <LITERALS>perl</LITERALS> <LITERALS>code</LITERALS> (<LITERALS>including</LITERALS> <LITERALS>comments</LITERALS>)
    <LITERALS>POD_START</LITERALS>      - <LITERALS>line</LITERALS> <LITERALS>starting</LITERALS> <LITERALS>pod</LITERALS>, <LITERALS>such</LITERALS> <LITERALS>as</LITERALS> '=<LITERALS>head</LITERALS>'
    <LITERALS>POD</LITERALS>            - <LITERALS>pod</LITERALS> <LITERALS>documentation</LITERALS> <LITERALS>text</LITERALS>
    <LITERALS>POD_END</LITERALS>        - <LITERALS>last</LITERALS> <LITERALS>line</LITERALS> <LITERALS>of</LITERALS> <LITERALS>pod</LITERALS> <LITERALS>section</LITERALS>, '=<LITERALS>cut</LITERALS>'
    <LITERALS>HERE</LITERALS>           - <LITERALS>text</LITERALS> <LITERALS>of</LITERALS> <LITERALS>here</LITERALS>-<LITERALS>document</LITERALS>
    <LITERALS>HERE_END</LITERALS>       - <LITERALS>last</LITERALS> <LITERALS>line</LITERALS> <LITERALS>of</LITERALS> <LITERALS>here</LITERALS>-<LITERALS>doc</LITERALS> (<LITERALS>target</LITERALS> <LITERALS>word</LITERALS>)
    <LITERALS>FORMAT</LITERALS>         - <LITERALS>format</LITERALS> <LITERALS>section</LITERALS>
    <LITERALS>FORMAT_END</LITERALS>     - <LITERALS>last</LITERALS> <LITERALS>line</LITERALS> <LITERALS>of</LITERALS> <LITERALS>format</LITERALS> <LITERALS>section</LITERALS>, '.'
    <LITERALS>DATA_START</LITERALS>     - <LITERALS>__DATA__</LITERALS> <LITERALS>line</LITERALS>
    <LITERALS>DATA</LITERALS>           - <LITERALS>unidentified</LITERALS> <LITERALS>text</LITERALS> <LITERALS>following</LITERALS> <LITERALS>__DATA__</LITERALS>
    <LITERALS>END_START</LITERALS>      - <LITERALS>__END__</LITERALS> <LITERALS>line</LITERALS>
    <LITERALS>END</LITERALS>            - <LITERALS>unidentified</LITERALS> <LITERALS>text</LITERALS> <LITERALS>following</LITERALS> <LITERALS>__END__</LITERALS>
    <LITERALS>ERROR</LITERALS>          - <LITERALS>we</LITERALS> <LITERALS>are</LITERALS> <LITERALS>in</LITERALS> <LITERALS>big</LITERALS> <LITERALS>trouble</LITERALS>, <LITERALS>probably</LITERALS> <LITERALS>not</LITERALS> <LITERALS>a</LITERALS> <LITERALS>perl</LITERALS> <LITERALS>script</LITERALS>
<CODE>END_OF_LIST</CODE>
}

<CODE>BEGIN</CODE> {

    # <COMMENTS>These</COMMENTS> <COMMENTS>names</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>error</COMMENTS> <COMMENTS>messages</COMMENTS>
    @<CODE>opening_brace_names</CODE> = qw# '{' '[' '(' '?' #;
    @<CODE>closing_brace_names</CODE> = qw# '}' ']' ')' ':' #;

    my @<CODE>digraphs</CODE> = qw(
      .. :: << >> ** && .. || // -> => += -= .= %= &= |= ^= *= <>
      <= >= == =~ !~ != ++ -- /= <LITERALS>x</LITERALS>= ~~ ~. |. &. ^.
    );
    @<CODE>is_digraph</CODE>{@<CODE>digraphs</CODE>} = (1) x scalar(@<CODE>digraphs</CODE>);

    my @<CODE>trigraphs</CODE> = qw( ... **= <<= >>= &&= ||= //= <=> !~~ &.= |.= ^.=);
    @<CODE>is_trigraph</CODE>{@<CODE>trigraphs</CODE>} = (1) x scalar(@<CODE>trigraphs</CODE>);

    # <COMMENTS>make</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>all</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>self</COMMENTS>-<COMMENTS>checking</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS>
    # (<COMMENTS>adding</COMMENTS> <COMMENTS>NEW_TOKENS</COMMENTS> : <COMMENTS>select</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>new</COMMENTS> <COMMENTS>character</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>add</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>list</COMMENTS>)
    my @<CODE>valid_token_types</CODE> = qw#
      <LITERALS>A</LITERALS> <LITERALS>b</LITERALS> <LITERALS>C</LITERALS> <LITERALS>G</LITERALS> <LITERALS>L</LITERALS> <LITERALS>R</LITERALS> <LITERALS>f</LITERALS> <LITERALS>h</LITERALS> <LITERALS>Q</LITERALS> <LITERALS>k</LITERALS> <LITERALS>t</LITERALS> <LITERALS>w</LITERALS> <LITERALS>i</LITERALS> <LITERALS>q</LITERALS> <LITERALS>n</LITERALS> <LITERALS>p</LITERALS> <LITERALS>m</LITERALS> <LITERALS>F</LITERALS> <LITERALS>pp</LITERALS> <LITERALS>mm</LITERALS> <LITERALS>U</LITERALS> <LITERALS>j</LITERALS> <LITERALS>J</LITERALS> <LITERALS>Y</LITERALS> <LITERALS>Z</LITERALS> <LITERALS>v</LITERALS>
      { } ( ) [ ] ; + - / * | % ! <LITERALS>x</LITERALS> ~ = \ ? : . < > ^ &
      #;
    push( @<CODE>valid_token_types</CODE>, @<CODE>digraphs</CODE> );
    push( @<CODE>valid_token_types</CODE>, @<CODE>trigraphs</CODE> );
    push( @<CODE>valid_token_types</CODE>, ( '#', ',', '<LITERALS>CORE</LITERALS>::' ) );
    @<CODE>is_valid_token_type</CODE>{@<CODE>valid_token_types</CODE>} = (1) x scalar(@<CODE>valid_token_types</CODE>);

    # <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>letters</COMMENTS>, <COMMENTS>as</COMMENTS> <COMMENTS>in</COMMENTS> -<COMMENTS>e</COMMENTS> (<COMMENTS>Table</COMMENTS> <COMMENTS>3</COMMENTS>-<COMMENTS>4</COMMENTS> <COMMENTS>of</COMMENTS> '<COMMENTS>camel</COMMENTS> <COMMENTS>3</COMMENTS>')
    my @<CODE>file_test_operators</CODE> =
      qw( <LITERALS>A</LITERALS> <LITERALS>B</LITERALS> <LITERALS>C</LITERALS> <LITERALS>M</LITERALS> <LITERALS>O</LITERALS> <LITERALS>R</LITERALS> <LITERALS>S</LITERALS> <LITERALS>T</LITERALS> <LITERALS>W</LITERALS> <LITERALS>X</LITERALS> <LITERALS>b</LITERALS> <LITERALS>c</LITERALS> <LITERALS>d</LITERALS> <LITERALS>e</LITERALS> <LITERALS>f</LITERALS> <LITERALS>g</LITERALS> <LITERALS>k</LITERALS> <LITERALS>l</LITERALS> <LITERALS>o</LITERALS> <LITERALS>p</LITERALS> <LITERALS>r</LITERALS> <LITERALS>s</LITERALS> <LITERALS>t</LITERALS> <LITERALS>u</LITERALS> <LITERALS>w</LITERALS> <LITERALS>x</LITERALS> <LITERALS>z</LITERALS>);
    @<CODE>is_file_test_operator</CODE>{@<CODE>file_test_operators</CODE>} =
      (1) x scalar(@<CODE>file_test_operators</CODE>);

    # <COMMENTS>these</COMMENTS> <COMMENTS>functions</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>prototypes</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>form</COMMENTS> (&), <COMMENTS>so</COMMENTS> <COMMENTS>when</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS>
    # <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>block</COMMENTS>, <COMMENTS>that</COMMENTS> <COMMENTS>block</COMMENTS> <COMMENTS>MAY</COMMENTS> <COMMENTS>BE</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS>.
    # <COMMENTS>Smartmatch</COMMENTS> <COMMENTS>operator</COMMENTS> ~~ <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>anonymous</COMMENTS> <COMMENTS>hash</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>array</COMMENTS> <COMMENTS>ref</COMMENTS>
    @<CODE>_</CODE> = qw( <LITERALS>do</LITERALS> <LITERALS>eval</LITERALS> );
    @<CODE>is_block_operator</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>these</COMMENTS> <COMMENTS>functions</COMMENTS> <COMMENTS>allow</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>identifier</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>indirect</COMMENTS> <COMMENTS>object</COMMENTS> <COMMENTS>slot</COMMENTS>
    @<CODE>_</CODE> = qw( <LITERALS>print</LITERALS> <LITERALS>printf</LITERALS> <LITERALS>sort</LITERALS> <LITERALS>exec</LITERALS> <LITERALS>system</LITERALS> <LITERALS>say</LITERALS>);
    @<CODE>is_indirect_object_taker</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>These</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>precede</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>code</COMMENTS> <COMMENTS>block</COMMENTS>
    # <COMMENTS>patched</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS>/<COMMENTS>CATCH</COMMENTS>.  <COMMENTS>Actually</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>removed</COMMENTS>
    # <COMMENTS>now</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>we</COMMENTS> <COMMENTS>could</COMMENTS> <COMMENTS>let</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>extended</COMMENTS>-<COMMENTS>syntax</COMMENTS> <COMMENTS>coding</COMMENTS> <COMMENTS>handle</COMMENTS> <COMMENTS>them</COMMENTS>
    @<CODE>_</CODE> =
      qw( <LITERALS>BEGIN</LITERALS> <LITERALS>END</LITERALS> <LITERALS>CHECK</LITERALS> <LITERALS>INIT</LITERALS> <LITERALS>AUTOLOAD</LITERALS> <LITERALS>DESTROY</LITERALS> <LITERALS>UNITCHECK</LITERALS> <LITERALS>continue</LITERALS> <LITERALS>if</LITERALS> <LITERALS>elsif</LITERALS> <LITERALS>else</LITERALS>
      <LITERALS>unless</LITERALS> <LITERALS>do</LITERALS> <LITERALS>while</LITERALS> <LITERALS>until</LITERALS> <LITERALS>eval</LITERALS> <LITERALS>for</LITERALS> <LITERALS>foreach</LITERALS> <LITERALS>map</LITERALS> <LITERALS>grep</LITERALS> <LITERALS>sort</LITERALS>
      <LITERALS>switch</LITERALS> <LITERALS>case</LITERALS> <LITERALS>given</LITERALS> <LITERALS>when</LITERALS> <LITERALS>catch</LITERALS>);
    @<CODE>is_code_block_token</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>I</COMMENTS>'<COMMENTS>ll</COMMENTS> <COMMENTS>build</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>incrementally</COMMENTS>
    my @<CODE>Keywords</CODE> = ();

    # <COMMENTS>keywords</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>tokens</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>value</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>pattern</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>expected</COMMENTS>,
    # <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS>.  <COMMENTS>In</COMMENTS> <COMMENTS>other</COMMENTS> <COMMENTS>words</COMMENTS>, <COMMENTS>these</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>consume</COMMENTS> <COMMENTS>terms</COMMENTS>
    # <COMMENTS>to</COMMENTS> <COMMENTS>their</COMMENTS> <COMMENTS>right</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>expected</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>followed</COMMENTS>
    # <COMMENTS>immediately</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>operators</COMMENTS>.
    my @<CODE>value_requestor</CODE> = qw(
      <LITERALS>AUTOLOAD</LITERALS>
      <LITERALS>BEGIN</LITERALS>
      <LITERALS>CHECK</LITERALS>
      <LITERALS>DESTROY</LITERALS>
      <LITERALS>END</LITERALS>
      <LITERALS>EQ</LITERALS>
      <LITERALS>GE</LITERALS>
      <LITERALS>GT</LITERALS>
      <LITERALS>INIT</LITERALS>
      <LITERALS>LE</LITERALS>
      <LITERALS>LT</LITERALS>
      <LITERALS>NE</LITERALS>
      <LITERALS>UNITCHECK</LITERALS>
      <LITERALS>abs</LITERALS>
      <LITERALS>accept</LITERALS>
      <LITERALS>alarm</LITERALS>
      <LITERALS>and</LITERALS>
      <LITERALS>atan2</LITERALS>
      <LITERALS>bind</LITERALS>
      <LITERALS>binmode</LITERALS>
      <LITERALS>bless</LITERALS>
      <LITERALS>break</LITERALS>
      <LITERALS>caller</LITERALS>
      <LITERALS>chdir</LITERALS>
      <LITERALS>chmod</LITERALS>
      <LITERALS>chomp</LITERALS>
      <LITERALS>chop</LITERALS>
      <LITERALS>chown</LITERALS>
      <LITERALS>chr</LITERALS>
      <LITERALS>chroot</LITERALS>
      <LITERALS>close</LITERALS>
      <LITERALS>closedir</LITERALS>
      <LITERALS>cmp</LITERALS>
      <LITERALS>connect</LITERALS>
      <LITERALS>continue</LITERALS>
      <LITERALS>cos</LITERALS>
      <LITERALS>crypt</LITERALS>
      <LITERALS>dbmclose</LITERALS>
      <LITERALS>dbmopen</LITERALS>
      <LITERALS>defined</LITERALS>
      <LITERALS>delete</LITERALS>
      <LITERALS>die</LITERALS>
      <LITERALS>dump</LITERALS>
      <LITERALS>each</LITERALS>
      <LITERALS>else</LITERALS>
      <LITERALS>elsif</LITERALS>
      <LITERALS>eof</LITERALS>
      <LITERALS>eq</LITERALS>
      <LITERALS>exec</LITERALS>
      <LITERALS>exists</LITERALS>
      <LITERALS>exit</LITERALS>
      <LITERALS>exp</LITERALS>
      <LITERALS>fcntl</LITERALS>
      <LITERALS>fileno</LITERALS>
      <LITERALS>flock</LITERALS>
      <LITERALS>for</LITERALS>
      <LITERALS>foreach</LITERALS>
      <LITERALS>formline</LITERALS>
      <LITERALS>ge</LITERALS>
      <LITERALS>getc</LITERALS>
      <LITERALS>getgrgid</LITERALS>
      <LITERALS>getgrnam</LITERALS>
      <LITERALS>gethostbyaddr</LITERALS>
      <LITERALS>gethostbyname</LITERALS>
      <LITERALS>getnetbyaddr</LITERALS>
      <LITERALS>getnetbyname</LITERALS>
      <LITERALS>getpeername</LITERALS>
      <LITERALS>getpgrp</LITERALS>
      <LITERALS>getpriority</LITERALS>
      <LITERALS>getprotobyname</LITERALS>
      <LITERALS>getprotobynumber</LITERALS>
      <LITERALS>getpwnam</LITERALS>
      <LITERALS>getpwuid</LITERALS>
      <LITERALS>getservbyname</LITERALS>
      <LITERALS>getservbyport</LITERALS>
      <LITERALS>getsockname</LITERALS>
      <LITERALS>getsockopt</LITERALS>
      <LITERALS>glob</LITERALS>
      <LITERALS>gmtime</LITERALS>
      <LITERALS>goto</LITERALS>
      <LITERALS>grep</LITERALS>
      <LITERALS>gt</LITERALS>
      <LITERALS>hex</LITERALS>
      <LITERALS>if</LITERALS>
      <LITERALS>index</LITERALS>
      <LITERALS>int</LITERALS>
      <LITERALS>ioctl</LITERALS>
      <LITERALS>join</LITERALS>
      <LITERALS>keys</LITERALS>
      <LITERALS>kill</LITERALS>
      <LITERALS>last</LITERALS>
      <LITERALS>lc</LITERALS>
      <LITERALS>lcfirst</LITERALS>
      <LITERALS>le</LITERALS>
      <LITERALS>length</LITERALS>
      <LITERALS>link</LITERALS>
      <LITERALS>listen</LITERALS>
      <LITERALS>local</LITERALS>
      <LITERALS>localtime</LITERALS>
      <LITERALS>lock</LITERALS>
      <LITERALS>log</LITERALS>
      <LITERALS>lstat</LITERALS>
      <LITERALS>lt</LITERALS>
      <LITERALS>map</LITERALS>
      <LITERALS>mkdir</LITERALS>
      <LITERALS>msgctl</LITERALS>
      <LITERALS>msgget</LITERALS>
      <LITERALS>msgrcv</LITERALS>
      <LITERALS>msgsnd</LITERALS>
      <LITERALS>my</LITERALS>
      <LITERALS>ne</LITERALS>
      <LITERALS>next</LITERALS>
      <LITERALS>no</LITERALS>
      <LITERALS>not</LITERALS>
      <LITERALS>oct</LITERALS>
      <LITERALS>open</LITERALS>
      <LITERALS>opendir</LITERALS>
      <LITERALS>or</LITERALS>
      <LITERALS>ord</LITERALS>
      <LITERALS>our</LITERALS>
      <LITERALS>pack</LITERALS>
      <LITERALS>pipe</LITERALS>
      <LITERALS>pop</LITERALS>
      <LITERALS>pos</LITERALS>
      <LITERALS>print</LITERALS>
      <LITERALS>printf</LITERALS>
      <LITERALS>prototype</LITERALS>
      <LITERALS>push</LITERALS>
      <LITERALS>quotemeta</LITERALS>
      <LITERALS>rand</LITERALS>
      <LITERALS>read</LITERALS>
      <LITERALS>readdir</LITERALS>
      <LITERALS>readlink</LITERALS>
      <LITERALS>readline</LITERALS>
      <LITERALS>readpipe</LITERALS>
      <LITERALS>recv</LITERALS>
      <LITERALS>redo</LITERALS>
      <LITERALS>ref</LITERALS>
      <LITERALS>rename</LITERALS>
      <LITERALS>require</LITERALS>
      <LITERALS>reset</LITERALS>
      <LITERALS>return</LITERALS>
      <LITERALS>reverse</LITERALS>
      <LITERALS>rewinddir</LITERALS>
      <LITERALS>rindex</LITERALS>
      <LITERALS>rmdir</LITERALS>
      <LITERALS>scalar</LITERALS>
      <LITERALS>seek</LITERALS>
      <LITERALS>seekdir</LITERALS>
      <LITERALS>select</LITERALS>
      <LITERALS>semctl</LITERALS>
      <LITERALS>semget</LITERALS>
      <LITERALS>semop</LITERALS>
      <LITERALS>send</LITERALS>
      <LITERALS>sethostent</LITERALS>
      <LITERALS>setnetent</LITERALS>
      <LITERALS>setpgrp</LITERALS>
      <LITERALS>setpriority</LITERALS>
      <LITERALS>setprotoent</LITERALS>
      <LITERALS>setservent</LITERALS>
      <LITERALS>setsockopt</LITERALS>
      <LITERALS>shift</LITERALS>
      <LITERALS>shmctl</LITERALS>
      <LITERALS>shmget</LITERALS>
      <LITERALS>shmread</LITERALS>
      <LITERALS>shmwrite</LITERALS>
      <LITERALS>shutdown</LITERALS>
      <LITERALS>sin</LITERALS>
      <LITERALS>sleep</LITERALS>
      <LITERALS>socket</LITERALS>
      <LITERALS>socketpair</LITERALS>
      <LITERALS>sort</LITERALS>
      <LITERALS>splice</LITERALS>
      <LITERALS>split</LITERALS>
      <LITERALS>sprintf</LITERALS>
      <LITERALS>sqrt</LITERALS>
      <LITERALS>srand</LITERALS>
      <LITERALS>stat</LITERALS>
      <LITERALS>study</LITERALS>
      <LITERALS>substr</LITERALS>
      <LITERALS>symlink</LITERALS>
      <LITERALS>syscall</LITERALS>
      <LITERALS>sysopen</LITERALS>
      <LITERALS>sysread</LITERALS>
      <LITERALS>sysseek</LITERALS>
      <LITERALS>system</LITERALS>
      <LITERALS>syswrite</LITERALS>
      <LITERALS>tell</LITERALS>
      <LITERALS>telldir</LITERALS>
      <LITERALS>tie</LITERALS>
      <LITERALS>tied</LITERALS>
      <LITERALS>truncate</LITERALS>
      <LITERALS>uc</LITERALS>
      <LITERALS>ucfirst</LITERALS>
      <LITERALS>umask</LITERALS>
      <LITERALS>undef</LITERALS>
      <LITERALS>unless</LITERALS>
      <LITERALS>unlink</LITERALS>
      <LITERALS>unpack</LITERALS>
      <LITERALS>unshift</LITERALS>
      <LITERALS>untie</LITERALS>
      <LITERALS>until</LITERALS>
      <LITERALS>use</LITERALS>
      <LITERALS>utime</LITERALS>
      <LITERALS>values</LITERALS>
      <LITERALS>vec</LITERALS>
      <LITERALS>waitpid</LITERALS>
      <LITERALS>warn</LITERALS>
      <LITERALS>while</LITERALS>
      <LITERALS>write</LITERALS>
      <LITERALS>xor</LITERALS>

      <LITERALS>switch</LITERALS>
      <LITERALS>case</LITERALS>
      <LITERALS>given</LITERALS>
      <LITERALS>when</LITERALS>
      <LITERALS>err</LITERALS>
      <LITERALS>say</LITERALS>
    );

    # <COMMENTS>patched</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>SWITCH</COMMENTS>/<COMMENTS>CASE</COMMENTS> <COMMENTS>given</COMMENTS>/<COMMENTS>when</COMMENTS> <COMMENTS>err</COMMENTS> <COMMENTS>say</COMMENTS>
    # '<COMMENTS>err</COMMENTS>' <COMMENTS>is</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>fairly</COMMENTS> <COMMENTS>safe</COMMENTS> <COMMENTS>addition</COMMENTS>.
    # <COMMENTS>TODO</COMMENTS>: '<COMMENTS>default</COMMENTS>' <COMMENTS>still</COMMENTS> <COMMENTS>needed</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>appropriate</COMMENTS>
    # '<COMMENTS>use</COMMENTS> <COMMENTS>feature</COMMENTS>' <COMMENTS>seen</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>perltidy</COMMENTS> <COMMENTS>works</COMMENTS> <COMMENTS>ok</COMMENTS> <COMMENTS>without</COMMENTS> <COMMENTS>it</COMMENTS>.
    # <COMMENTS>Concerned</COMMENTS> <COMMENTS>that</COMMENTS> '<COMMENTS>default</COMMENTS>' <COMMENTS>could</COMMENTS> <COMMENTS>break</COMMENTS> <COMMENTS>code</COMMENTS>.
    push( @<CODE>Keywords</CODE>, @<CODE>value_requestor</CODE> );

    # <COMMENTS>These</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>treated</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>keywords</COMMENTS>:
    my @<CODE>extra_vr</CODE> = qw(
      <LITERALS>constant</LITERALS>
      <LITERALS>vars</LITERALS>
    );
    push( @<CODE>value_requestor</CODE>, @<CODE>extra_vr</CODE> );

    @<CODE>expecting_term_token</CODE>{@<CODE>value_requestor</CODE>} = (1) x scalar(@<CODE>value_requestor</CODE>);

    # <COMMENTS>this</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>contains</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>look</COMMENTS> <COMMENTS>for</COMMENTS> <COMMENTS>arguments</COMMENTS>,
    # <COMMENTS>so</COMMENTS> <COMMENTS>that</COMMENTS> <COMMENTS>they</COMMENTS> <COMMENTS>might</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>an</COMMENTS> <COMMENTS>operator</COMMENTS>, <COMMENTS>or</COMMENTS> <COMMENTS>at</COMMENTS> <COMMENTS>least</COMMENTS>
    # <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>term</COMMENTS>.
    my @<CODE>operator_requestor</CODE> = qw(
      <LITERALS>endgrent</LITERALS>
      <LITERALS>endhostent</LITERALS>
      <LITERALS>endnetent</LITERALS>
      <LITERALS>endprotoent</LITERALS>
      <LITERALS>endpwent</LITERALS>
      <LITERALS>endservent</LITERALS>
      <LITERALS>fork</LITERALS>
      <LITERALS>getgrent</LITERALS>
      <LITERALS>gethostent</LITERALS>
      <LITERALS>getlogin</LITERALS>
      <LITERALS>getnetent</LITERALS>
      <LITERALS>getppid</LITERALS>
      <LITERALS>getprotoent</LITERALS>
      <LITERALS>getpwent</LITERALS>
      <LITERALS>getservent</LITERALS>
      <LITERALS>setgrent</LITERALS>
      <LITERALS>setpwent</LITERALS>
      <LITERALS>time</LITERALS>
      <LITERALS>times</LITERALS>
      <LITERALS>wait</LITERALS>
      <LITERALS>wantarray</LITERALS>
    );

    push( @<CODE>Keywords</CODE>, @<CODE>operator_requestor</CODE> );

    # <COMMENTS>These</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>treated</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>same</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>considered</COMMENTS> <COMMENTS>keywords</COMMENTS>:
    my @<CODE>extra_or</CODE> = qw(
      <LITERALS>STDERR</LITERALS>
      <LITERALS>STDIN</LITERALS>
      <LITERALS>STDOUT</LITERALS>
    );

    push( @<CODE>operator_requestor</CODE>, @<CODE>extra_or</CODE> );

    @<CODE>expecting_operator_token</CODE>{@<CODE>operator_requestor</CODE>} =
      (1) x scalar(@<CODE>operator_requestor</CODE>);

    # <COMMENTS>these</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>TYPES</COMMENTS> <COMMENTS>expect</COMMENTS> <COMMENTS>trailing</COMMENTS> <COMMENTS>operator</COMMENTS> <COMMENTS>but</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>term</COMMENTS>
    # <COMMENTS>note</COMMENTS>: ++ <COMMENTS>and</COMMENTS> -- <COMMENTS>are</COMMENTS> <COMMENTS>post</COMMENTS>-<COMMENTS>increment</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>decrement</COMMENTS>, '<COMMENTS>C</COMMENTS>' = <COMMENTS>constant</COMMENTS>
    my @<CODE>operator_requestor_types</CODE> = qw( ++ -- <LITERALS>C</LITERALS> <> <LITERALS>q</LITERALS> );
    @<CODE>expecting_operator_types</CODE>{@<CODE>operator_requestor_types</CODE>} =
      (1) x scalar(@<CODE>operator_requestor_types</CODE>);

    # <COMMENTS>these</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>TYPES</COMMENTS> <COMMENTS>consume</COMMENTS> <COMMENTS>values</COMMENTS> (<COMMENTS>terms</COMMENTS>)
    # <COMMENTS>note</COMMENTS>: <COMMENTS>pp</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>mm</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>pre</COMMENTS>-<COMMENTS>increment</COMMENTS> <COMMENTS>and</COMMENTS> <COMMENTS>decrement</COMMENTS>
    # <COMMENTS>f</COMMENTS>=<COMMENTS>semicolon</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>for</COMMENTS>,  <COMMENTS>F</COMMENTS>=<COMMENTS>file</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>operator</COMMENTS>
    my @<CODE>value_requestor_type</CODE> = qw#
      <LITERALS>L</LITERALS> { ( [ ~ !~ =~ ; . .. ... <LITERALS>A</LITERALS> : && ! || // = + - <LITERALS>x</LITERALS>
      **= += -= .= /= *= %= <LITERALS>x</LITERALS>= &= |= ^= <<= >>= &&= ||= //=
      <= >= == != => \ > < % * / ? & | ** <=> ~~ !~~
      <LITERALS>f</LITERALS> <LITERALS>F</LITERALS> <LITERALS>pp</LITERALS> <LITERALS>mm</LITERALS> <LITERALS>Y</LITERALS> <LITERALS>p</LITERALS> <LITERALS>m</LITERALS> <LITERALS>U</LITERALS> <LITERALS>J</LITERALS> <LITERALS>G</LITERALS> <LITERALS>j</LITERALS> >> << ^ <LITERALS>t</LITERALS>
      ~. ^. |. &. ^.= |.= &.=
      #;
    push( @<CODE>value_requestor_type</CODE>, ',' )
      ;    # (<COMMENTS>perl</COMMENTS> <COMMENTS>doesn</COMMENTS>'<COMMENTS>t</COMMENTS> <COMMENTS>like</COMMENTS> <COMMENTS>a</COMMENTS> ',' <COMMENTS>in</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>qw</COMMENTS> <COMMENTS>block</COMMENTS>)
    @<CODE>expecting_term_types</CODE>{@<CODE>value_requestor_type</CODE>} =
      (1) x scalar(@<CODE>value_requestor_type</CODE>);

    # <COMMENTS>Note</COMMENTS>: <COMMENTS>the</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>valid</COMMENTS> <COMMENTS>token</COMMENTS> <COMMENTS>types</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>assigned</COMMENTS> <COMMENTS>here</COMMENTS> <COMMENTS>to</COMMENTS>
    # <COMMENTS>hashes</COMMENTS> <COMMENTS>requesting</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>values</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>terms</COMMENTS>, <COMMENTS>but</COMMENTS> <COMMENTS>are</COMMENTS>
    # <COMMENTS>instead</COMMENTS> <COMMENTS>currently</COMMENTS> <COMMENTS>hard</COMMENTS>-<COMMENTS>coded</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>sub</COMMENTS> <COMMENTS>operator_expected</COMMENTS>:
    # ) -> :: <COMMENTS>Q</COMMENTS> <COMMENTS>R</COMMENTS> <COMMENTS>Z</COMMENTS> ] <COMMENTS>b</COMMENTS> <COMMENTS>h</COMMENTS> <COMMENTS>i</COMMENTS> <COMMENTS>k</COMMENTS> <COMMENTS>n</COMMENTS> <COMMENTS>v</COMMENTS> <COMMENTS>w</COMMENTS> } #

    # <COMMENTS>For</COMMENTS> <COMMENTS>simple</COMMENTS> <COMMENTS>syntax</COMMENTS> <COMMENTS>checking</COMMENTS>, <COMMENTS>it</COMMENTS> <COMMENTS>is</COMMENTS> <COMMENTS>nice</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>have</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>operators</COMMENTS> <COMMENTS>which</COMMENTS>
    # <COMMENTS>will</COMMENTS> <COMMENTS>really</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>unhappy</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>followed</COMMENTS> <COMMENTS>by</COMMENTS> <COMMENTS>a</COMMENTS> <COMMENTS>term</COMMENTS>.  <COMMENTS>This</COMMENTS> <COMMENTS>includes</COMMENTS> <COMMENTS>most</COMMENTS>
    # <COMMENTS>of</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS>...
    %<CODE>really_want_term</CODE> = %<CODE>expecting_term_types</CODE>;

    # <COMMENTS>with</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>exceptions</COMMENTS>...
    delete $<CODE>really_want_term</CODE>{'<LITERALS>U</LITERALS>'}; # <COMMENTS>user</COMMENTS> <COMMENTS>sub</COMMENTS>, <COMMENTS>depends</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>prototype</COMMENTS>
    delete $<CODE>really_want_term</CODE>{'<LITERALS>F</LITERALS>'}; # <COMMENTS>file</COMMENTS> <COMMENTS>test</COMMENTS> <COMMENTS>works</COMMENTS> <COMMENTS>on</COMMENTS> <COMMENTS>$_</COMMENTS> <COMMENTS>if</COMMENTS> <COMMENTS>no</COMMENTS> <COMMENTS>following</COMMENTS> <COMMENTS>term</COMMENTS>
    delete $<CODE>really_want_term</CODE>{'<LITERALS>Y</LITERALS>'}; # <COMMENTS>indirect</COMMENTS> <COMMENTS>object</COMMENTS>, <COMMENTS>too</COMMENTS> <COMMENTS>risky</COMMENTS> <COMMENTS>to</COMMENTS> <COMMENTS>check</COMMENTS> <COMMENTS>syntax</COMMENTS>;
                                   # <COMMENTS>let</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>do</COMMENTS> <COMMENTS>it</COMMENTS>

    @<CODE>_</CODE> = qw(<LITERALS>q</LITERALS> <LITERALS>qq</LITERALS> <LITERALS>qw</LITERALS> <LITERALS>qx</LITERALS> <LITERALS>qr</LITERALS> <LITERALS>s</LITERALS> <LITERALS>y</LITERALS> <LITERALS>tr</LITERALS> <LITERALS>m</LITERALS>);
    @<CODE>is_q_qq_qw_qx_qr_s_y_tr_m</CODE>{@<CODE>_</CODE>} = (1) x scalar(@<CODE>_</CODE>);

    # <COMMENTS>These</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>handled</COMMENTS> <COMMENTS>specially</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>tokenizer</COMMENTS> <COMMENTS>code</COMMENTS>:
    my @<CODE>special_keywords</CODE> = qw(
      <LITERALS>do</LITERALS>
      <LITERALS>eval</LITERALS>
      <LITERALS>format</LITERALS>
      <LITERALS>m</LITERALS>
      <LITERALS>package</LITERALS>
      <LITERALS>q</LITERALS>
      <LITERALS>qq</LITERALS>
      <LITERALS>qr</LITERALS>
      <LITERALS>qw</LITERALS>
      <LITERALS>qx</LITERALS>
      <LITERALS>s</LITERALS>
      <LITERALS>sub</LITERALS>
      <LITERALS>tr</LITERALS>
      <LITERALS>y</LITERALS>
    );
    push( @<CODE>Keywords</CODE>, @<CODE>special_keywords</CODE> );

    # <COMMENTS>Keywords</COMMENTS> <COMMENTS>after</COMMENTS> <COMMENTS>which</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>formatting</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>used</COMMENTS>
    # <COMMENTS>WARNING</COMMENTS>: <COMMENTS>do</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>include</COMMENTS> |<COMMENTS>map</COMMENTS>|<COMMENTS>grep</COMMENTS>|<COMMENTS>eval</COMMENTS> <COMMENTS>or</COMMENTS> <COMMENTS>perl</COMMENTS> <COMMENTS>may</COMMENTS> <COMMENTS>die</COMMENTS> <COMMENTS>on</COMMENTS>
    # <COMMENTS>syntax</COMMENTS> <COMMENTS>errors</COMMENTS> (<COMMENTS>map1</COMMENTS>.<COMMENTS>t</COMMENTS>).
    my @<CODE>keyword_taking_list</CODE> = qw(
      <LITERALS>and</LITERALS>
      <LITERALS>chmod</LITERALS>
      <LITERALS>chomp</LITERALS>
      <LITERALS>chop</LITERALS>
      <LITERALS>chown</LITERALS>
      <LITERALS>dbmopen</LITERALS>
      <LITERALS>die</LITERALS>
      <LITERALS>elsif</LITERALS>
      <LITERALS>exec</LITERALS>
      <LITERALS>fcntl</LITERALS>
      <LITERALS>for</LITERALS>
      <LITERALS>foreach</LITERALS>
      <LITERALS>formline</LITERALS>
      <LITERALS>getsockopt</LITERALS>
      <LITERALS>if</LITERALS>
      <LITERALS>index</LITERALS>
      <LITERALS>ioctl</LITERALS>
      <LITERALS>join</LITERALS>
      <LITERALS>kill</LITERALS>
      <LITERALS>local</LITERALS>
      <LITERALS>msgctl</LITERALS>
      <LITERALS>msgrcv</LITERALS>
      <LITERALS>msgsnd</LITERALS>
      <LITERALS>my</LITERALS>
      <LITERALS>open</LITERALS>
      <LITERALS>or</LITERALS>
      <LITERALS>our</LITERALS>
      <LITERALS>pack</LITERALS>
      <LITERALS>print</LITERALS>
      <LITERALS>printf</LITERALS>
      <LITERALS>push</LITERALS>
      <LITERALS>read</LITERALS>
      <LITERALS>readpipe</LITERALS>
      <LITERALS>recv</LITERALS>
      <LITERALS>return</LITERALS>
      <LITERALS>reverse</LITERALS>
      <LITERALS>rindex</LITERALS>
      <LITERALS>seek</LITERALS>
      <LITERALS>select</LITERALS>
      <LITERALS>semctl</LITERALS>
      <LITERALS>semget</LITERALS>
      <LITERALS>send</LITERALS>
      <LITERALS>setpriority</LITERALS>
      <LITERALS>setsockopt</LITERALS>
      <LITERALS>shmctl</LITERALS>
      <LITERALS>shmget</LITERALS>
      <LITERALS>shmread</LITERALS>
      <LITERALS>shmwrite</LITERALS>
      <LITERALS>socket</LITERALS>
      <LITERALS>socketpair</LITERALS>
      <LITERALS>sort</LITERALS>
      <LITERALS>splice</LITERALS>
      <LITERALS>split</LITERALS>
      <LITERALS>sprintf</LITERALS>
      <LITERALS>substr</LITERALS>
      <LITERALS>syscall</LITERALS>
      <LITERALS>sysopen</LITERALS>
      <LITERALS>sysread</LITERALS>
      <LITERALS>sysseek</LITERALS>
      <LITERALS>system</LITERALS>
      <LITERALS>syswrite</LITERALS>
      <LITERALS>tie</LITERALS>
      <LITERALS>unless</LITERALS>
      <LITERALS>unlink</LITERALS>
      <LITERALS>unpack</LITERALS>
      <LITERALS>unshift</LITERALS>
      <LITERALS>until</LITERALS>
      <LITERALS>vec</LITERALS>
      <LITERALS>warn</LITERALS>
      <LITERALS>while</LITERALS>
      <LITERALS>given</LITERALS>
      <LITERALS>when</LITERALS>
    );
    @<CODE>is_keyword_taking_list</CODE>{@<CODE>keyword_taking_list</CODE>} =
      (1) x scalar(@<CODE>keyword_taking_list</CODE>);

    # <COMMENTS>These</COMMENTS> <COMMENTS>are</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>used</COMMENTS> <COMMENTS>in</COMMENTS> <COMMENTS>any</COMMENTS> <COMMENTS>way</COMMENTS> <COMMENTS>yet</COMMENTS>
    #    <COMMENTS>my</COMMENTS> @<COMMENTS>unused_keywords</COMMENTS> = <COMMENTS>qw</COMMENTS>(
    #     <COMMENTS>__FILE__</COMMENTS>
    #     <COMMENTS>__LINE__</COMMENTS>
    #     <COMMENTS>__PACKAGE__</COMMENTS>
    #     );

    #  <COMMENTS>The</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>of</COMMENTS> <COMMENTS>keywords</COMMENTS> <COMMENTS>was</COMMENTS> <COMMENTS>originally</COMMENTS> <COMMENTS>extracted</COMMENTS> <COMMENTS>from</COMMENTS> <COMMENTS>function</COMMENTS> '<COMMENTS>keyword</COMMENTS>' <COMMENTS>in</COMMENTS>
    #  <COMMENTS>perl</COMMENTS> <COMMENTS>file</COMMENTS> <COMMENTS>toke</COMMENTS>.<COMMENTS>c</COMMENTS> <COMMENTS>version</COMMENTS> <COMMENTS>5</COMMENTS>.<COMMENTS>005</COMMENTS>.<COMMENTS>03</COMMENTS>, <COMMENTS>using</COMMENTS> <COMMENTS>this</COMMENTS> <COMMENTS>utility</COMMENTS>, <COMMENTS>plus</COMMENTS> <COMMENTS>a</COMMENTS>
    #  <COMMENTS>little</COMMENTS> <COMMENTS>editing</COMMENTS>: (<COMMENTS>file</COMMENTS> <COMMENTS>getkwd</COMMENTS>.<COMMENTS>pl</COMMENTS>):
    #  <COMMENTS>while</COMMENTS> (<>) { <COMMENTS>while</COMMENTS> (/\"(.*)\"/<COMMENTS>g</COMMENTS>) { <COMMENTS>print</COMMENTS> "<COMMENTS>$1</COMMENTS>\<COMMENTS>n</COMMENTS>"; } }
    #  <COMMENTS>Add</COMMENTS> '<COMMENTS>get</COMMENTS>' <COMMENTS>prefix</COMMENTS> <COMMENTS>where</COMMENTS> <COMMENTS>necessary</COMMENTS>, <COMMENTS>then</COMMENTS> <COMMENTS>split</COMMENTS> <COMMENTS>into</COMMENTS> <COMMENTS>the</COMMENTS> <COMMENTS>above</COMMENTS> <COMMENTS>lists</COMMENTS>.
    #  <COMMENTS>This</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>be</COMMENTS> <COMMENTS>updated</COMMENTS> <COMMENTS>as</COMMENTS> <COMMENTS>necessary</COMMENTS>.
    #  <COMMENTS>The</COMMENTS> <COMMENTS>list</COMMENTS> <COMMENTS>should</COMMENTS> <COMMENTS>not</COMMENTS> <COMMENTS>contain</COMMENTS> <COMMENTS>these</COMMENTS> <COMMENTS>special</COMMENTS> <COMMENTS>variables</COMMENTS>:
    #  <COMMENTS>ARGV</COMMENTS> <COMMENTS>DATA</COMMENTS> <COMMENTS>ENV</COMMENTS> <COMMENTS>SIG</COMMENTS> <COMMENTS>STDERR</COMMENTS> <COMMENTS>STDIN</COMMENTS> <COMMENTS>STDOUT</COMMENTS>
    #  <COMMENTS>__DATA__</COMMENTS> <COMMENTS>__END__</COMMENTS>

    @<CODE>is_keyword</CODE>{@<CODE>Keywords</CODE>} = (1) x scalar(@<CODE>Keywords</CODE>);
}
1;
__END__
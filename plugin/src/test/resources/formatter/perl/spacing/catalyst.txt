package ScriptTestApp::Controller::Root;
use Moose;
use namespace::clean -except => [ 'meta' ];

BEGIN {extends 'Catalyst::Controller'}

sub default :Chained('/') PathPart('') Args() {}

1;

package ScriptTestApp::TraitFor::Script;
use Moose::Role;
use namespace::clean -except => [ 'meta' ];

around run => sub {
    my ($orig, $self, @args) = @_;
    return 'moo' . $self->$orig(@args);
};

1;
package ScriptTestApp::TraitFor::Script::Bar;
use Moose::Role;
use namespace::clean -except => [ 'meta' ];

around run => sub {
    my ($orig, $self, @args) = @_;
    return $self->$orig(@args) . '23';
};

1;
package ScriptTestApp::TraitFor::Script::Foo;
use Moose::Role;
use namespace::clean -except => [ 'meta' ];

around run => sub {
    my ($orig, $self, @args) = @_;
    return $self->$orig(@args) . '42';
};

1;
package ScriptTestApp::Script::Bar;
use Moose;
use namespace::clean -except => [ 'meta' ];

with 'Catalyst::ScriptRole';

sub run {__PACKAGE__}

1;
package ScriptTestApp::Script::Foo;
use Moose;
use namespace::clean -except => [ 'meta' ];

with 'Catalyst::ScriptRole';

sub run {__PACKAGE__}

1;
package ScriptTestApp::Script::CompileTest;
use Moose;
use namespace::clean -except => [ 'meta' ];

die("Does not compile");

1;
package TestContentNegotiation::Controller::Root;

use Moose;
use MooseX::MethodAttributes;

extends 'Catalyst::Controller';

sub start :Chained(/) PathPrefix CaptureArgs(0) {}

sub is_json :Chained('start') PathPart('') Consumes('application/json') Args(0) {pop->res->body('is_json1')}
sub is_urlencoded :Chained('start') PathPart('') Consumes('application/x-www-form-urlencoded') Args(0) {pop->res->body('is_urlencoded1')}
sub is_multipart :Chained('start') PathPart('') Consumes('multipart/form-data') Args(0) {pop->res->body('is_multipart1')}

sub under :Chained('start') CaptureArgs(0) {}

sub is_json_under :Chained('under') PathPart('') Consumes(JSON) Args(0) {pop->res->body('is_json2')}
sub is_urlencoded_under :Chained('under') PathPart('') Consumes(UrlEncoded) Args(0) {pop->res->body('is_urlencoded2')}
sub is_multipart_under :Chained('under') PathPart('') Consumes(Multipart) Args(0) {pop->res->body('is_multipart2')}

## Or allow more than one type

sub multi :Chained('start') PathPart('') CaptureArgs(0) {}

sub is_more_than_one_1
        :Chained('multi')
        :Consumes('application/x-www-form-urlencoded')
        :Consumes('multipart/form-data')
        :Args(0) {
    pop->res->body('formdata1');
}

sub is_more_than_one_2
        :Chained('multi')
        :Consumes('HTMLForm')
        :Args(0) {
    pop->res->body('formdata2');
}

sub is_more_than_one_3
        :Chained('multi')
        :Consumes('application/x-www-form-urlencoded,multipart/form-data')
        :Args(0) {
    pop->res->body('formdata3');
}

__PACKAGE__->meta->make_immutable;
use strict;
use warnings;

package TestAppPathBug;
use strict;
use warnings;
use Catalyst;

our $VERSION = '0.01';

__PACKAGE__->config(name => 'TestAppPathBug', root => '/some/dir');

__PACKAGE__->log(TestAppPathBug::Log->new);
__PACKAGE__->setup;

sub foo :Path {
    my ($self, $c) = @_;
    $c->res->body('This is the foo method.');
}

package TestAppPathBug::Log;
use strict;
use warnings;
use base qw/Catalyst::Log/;

sub warn {}

1;
package TestMiddlewareFromPlugin;

use Catalyst qw/+TestMiddlewareFromPlugin::SetMiddleware/;

## Proof this is good config
##__PACKAGE__->config( do TestMiddlewareFromConfig->path_to('testmiddlewarefromplugin.pl') );

__PACKAGE__->setup_middleware('Head');
__PACKAGE__->setup;

1;
package TestAppChainedRecursive;

use strict;
use Catalyst qw/
        Test::Errors
        Test::Headers
/;
use Catalyst::Utils;

our $VERSION = '0.01';

TestAppChainedRecursive->config(
        name => 'TestAppChainedRecursive',
        root => '/some/dir'
);

TestAppChainedRecursive->setup;

1;
package TestFromPSGI::Controller::Root;

use Moose;
use MooseX::MethodAttributes;

extends 'Catalyst::Controller';

sub test_psgi_keys :Local {
    my ($self, $c) = @_;
    $c->res->body('ok');
}

sub from_psgi_array :Local {
    my ($self, $c) = @_;
    my $res = sub {
        my ($env) = @_;
        return [ 200, [ 'Content-Type' => 'text/plain' ],
                [ qw/hello world today/ ] ];
    }->($c->req->env);

    $c->res->from_psgi_response($res);
}

sub from_psgi_code :Local {
    my ($self, $c) = @_;

    my $res = sub {
        my ($env) = @_;
        return sub {
            my $responder = shift;
            return $responder->([ 200, [ 'Content-Type' => 'text/plain' ],
                    [ qw/hello world today2/ ] ]);
        };
    }->($c->req->env);

    $c->res->from_psgi_response($res);
}

sub from_psgi_code_itr :Local {
    my ($self, $c) = @_;
    my $res = sub {
        my ($env) = @_;
        return sub {
            my $responder = shift;
            my $writer = $responder->([ 200, [ 'Content-Type' => 'text/plain' ] ]);
            $writer->write('hello');
            $writer->write('world');
            $writer->write('today3');
            $writer->close;
        };
    }->($c->req->env);

    $c->res->from_psgi_response($res);
}

__PACKAGE__->meta->make_immutable;
package TestAppUnicode;
use strict;
use warnings;
use TestLogger;
use base qw/Catalyst/;
use Catalyst;

__PACKAGE__->config(
        'name' => 'TestAppUnicode',
        $ENV{TESTAPP_ENCODING} ? (encoding => $ENV{TESTAPP_ENCODING}) : (),
);

__PACKAGE__->log(TestLogger->new);

__PACKAGE__->setup;

sub handle_unicode_encoding_exception {
    my ($self, $param_value, $error_msg) = @_;
    return $param_value;
}

1;
package TestAppDoubleAutoBug::Controller::Root;

use base 'Catalyst::Controller';

__PACKAGE__->config->{namespace} = '';

sub auto :Private {
    my ($self, $c) = @_;
    ++$c->stash->{auto_count};
    return 1;
}

sub default :Private {
    my ($self, $c) = @_;
    $c->res->body(sprintf 'default, auto=%d', $c->stash->{auto_count});
}

sub end :Private {
    my ($self, $c) = @_;
}

1;
package ACLTestApp;
use Test::More;

use strict;
use warnings;
use MRO::Compat;
use Scalar::Util ();
use TestLogger;

use base qw/Catalyst Catalyst::Controller/;
use Catalyst qw//;

__PACKAGE__->log(TestLogger->new);

sub execute {
    my $c = shift;
    my ($class, $action) = @_;

    if (Scalar::Util::blessed($action)
            and $action->name ne "foobar") {
        eval {$c->detach('foobar', [ $action, 'foo' ])};
    }

    $c->next::method(@_);
}

__PACKAGE__->setup;

1;
package TestAppWithoutUnicode::Controller::Root;

use Moose;
BEGIN {extends 'Catalyst::Controller'}
use Encode qw(encode_utf8 decode_utf8);

__PACKAGE__->config(namespace => q{});

sub default :Private {
    my ($self, $c) = @_;
    my $param = decode_utf8($c->request->parameters->{'myparam'});
    $c->response->body(encode_utf8($param));
}

__PACKAGE__->meta->make_immutable;

1;
package TestPath::Controller::One;
use Moose;
use namespace::clean -except => [ 'meta' ];

BEGIN {extends 'Catalyst::Controller'}

sub one :Path {
    my ($self, $c) = @_;
    $c->response->body('OK');
}

__PACKAGE__->meta->make_immutable;
package TestPath::Controller::Three;
use Moose;
use namespace::clean -except => [ 'meta' ];

BEGIN {extends 'Catalyst::Controller'}

sub three :Path('') {
    my ($self, $c) = @_;
    $c->response->body('OK');
}

__PACKAGE__->meta->make_immutable;
package TestPath::Controller::Four;
use Moose;
use namespace::clean -except => [ 'meta' ];

BEGIN {extends 'Catalyst::Controller'}

sub four :Path('') :Args() {
    my ($self, $c) = @_;
    $c->response->body('OK');
}

__PACKAGE__->meta->make_immutable;
package TestPath::Controller::Two;
use Moose;
use namespace::clean -except => [ 'meta' ];

BEGIN {extends 'Catalyst::Controller'}

sub two :Path() {
    my ($self, $c) = @_;
    $c->response->body('OK');
}

__PACKAGE__->meta->make_immutable;
package TestAppWithMeta;
use strict;
use warnings;
use Catalyst;

no warnings 'redefine';
sub meta {}
use warnings 'redefine';

__PACKAGE__->setup;

1;

package TestMiddleware::Controller::Root;

use Moose;
use MooseX::MethodAttributes;

extends 'Catalyst::Controller';

sub default :Path {}
sub welcome :Path(welcome) {
    pop->res->body('Welcome to Catalyst');
}

__PACKAGE__->meta->make_immutable;
package TestMiddleware::Custom;

use strict;
use warnings;

use parent qw/Plack::Middleware::Static/;

1;
package TestAppMatchSingleArg;
use strict;
use warnings;
use TestLogger;
use Catalyst;

__PACKAGE__->log(TestLogger->new);

__PACKAGE__->setup;

1;
package TestAppChainedAbsolutePathPart::Controller::Foo;

use strict;
use warnings;

use base qw/Catalyst::Controller/;

sub foo :Chained PathPart('/foo/bar') Args(1) {}

1;
package DeprecatedActionsInAppClassTestApp;

use strict;
use warnings;
use Catalyst;

our $VERSION = '0.01';

__PACKAGE__->config(name => 'DeprecatedActionsInAppClassTestApp', root => '/some/dir');
__PACKAGE__->log(DeprecatedActionsInAppClassTestApp::Log->new);
__PACKAGE__->setup;

sub foo :Local {
    my ($self, $c) = @_;
    $c->res->body('OK');
}

package DeprecatedActionsInAppClassTestApp::Log;
use strict;
use warnings;
use base qw/Catalyst::Log/;

our $warnings;

sub warn {
    my ($self, $warning) = @_;
    $warnings++ if $warning =~ /action methods .+ found defined/i;
}

1;
package TestAppEncodingSetInPlugin::Controller::Root;
use Moose;
use namespace::autoclean;

BEGIN {extends 'Catalyst::Controller';}

__PACKAGE__->config(namespace => '');

sub default :Local {
    my ($self, $c) = @_;

    $c->res->body('');
}

1;
package TestAppEncodingSetInPlugin::SetEncoding;
use strict;
use warnings;

sub setup {
    my $c = shift;
    $c->config(encoding => 'UTF-8');
    $c->next::method(@_);
}

1;
package TestAppArgsEmptyParens::Controller::Root;
$INC{'TestAppArgsEmptyParens/Controller/Root.pm'} = __FILE__;
use Moose;
use MooseX::MethodAttributes;

extends 'Catalyst::Controller';

sub chain_base :Chained(/) PathPart('chain_base') CaptureArgs(0) {}

sub args :Chained(chain_base) PathPart('args') Args {$_[1]->res->body('Args')}
sub args_empty :Chained(chain_base) PathPart('args_empty') Args() {$_[1]->res->body('Args()')}

TestAppArgsEmptyParens::Controller::Root->config(namespace => '');

package TestAppArgsEmptyParens;
$INC{'TestAppArgsEmptyParens.pm'} = __FILE__;

use Catalyst;
use TestLogger;

TestAppArgsEmptyParens->setup;
TestAppArgsEmptyParens->log(TestLogger->new);

1;
package TestAppMetaCompat::Controller::Books;

use strict;
use base qw/TestAppMetaCompat::Controller::Base/;

sub edit :Local {}

1;
package TestAppMetaCompat::Controller::Base;

use strict;
use base qw/Catalyst::Controller/;

1;
package TestAppOnDemand::Controller::Body;

use strict;
use base 'Catalyst::Controller';

use Data::Dump ();

sub body_params :Local {
    my ($self, $c) = @_;

    $c->res->body(Data::Dump::dump($c->req->body_parameters));
}

sub query_params :Local {
    my ($self, $c) = @_;

    $c->res->body(Data::Dump::dump($c->req->query_parameters));
}

sub params :Local {
    my ($self, $c) = @_;

    $c->res->body(Data::Dump::dump($c->req->parameters));
}

sub read :Local {
    my ($self, $c) = @_;

    # read some data
    my @chunks;

    while (my $data = $c->read(10_000)) {
        push @chunks, $data;
    }

    $c->res->content_type('text/plain');

    $c->res->body(join('|', map {length $_} @chunks));
}

1;
package PluginTestApp::Controller::Root;
use Test::More;

use base 'Catalyst::Controller';

#use Catalyst qw(
#        Test::Plugin
#        +TestApp::Plugin::FullyQualified
#        );

__PACKAGE__->config->{namespace} = '';

sub compile_time_plugins :Local {
    my ($self, $c) = @_;

    isa_ok $c, 'Catalyst::Plugin::Test::Plugin';
    isa_ok $c, 'TestApp::Plugin::FullyQualified';

    can_ok $c, 'registered_plugins';
    $c->_test_plugins;

    $c->res->body("ok");
}

sub run_time_plugins :Local {
    my ($self, $c) = @_;

    $c->_test_plugins;
    my $faux_plugin = 'Faux::Plugin';

    # Trick perl into thinking the plugin is already loaded
    $INC{'Faux/Plugin.pm'} = 1;

    ref($c)->plugin(faux => $faux_plugin);

    isa_ok $c, 'Catalyst::Plugin::Test::Plugin';

    # applied parameterized role
    if (eval {
        require MooseX::Role::Parameterized;
        1
    }) {
        can_ok $c, 'affe';
        is $c->affe, 'birne', 'right method created by parameterized role';
    }

    isa_ok $c, 'TestApp::Plugin::FullyQualified';
    ok !$c->isa($faux_plugin),
            '... and it should not inherit from the instant plugin';
    can_ok $c, 'faux';
    is $c->faux->count, 1, '... and it should behave correctly';
    is_deeply [ $c->registered_plugins ],
            [
                    qw/Catalyst::Plugin::Test::Plugin
                            Faux::Plugin
                            TestApp::Plugin::FullyQualified/
            ],
            'registered_plugins() should report all plugins';
    ok $c->registered_plugins('Faux::Plugin'),
            '... and even the specific instant plugin';

    $c->res->body("ok");
}

1;
package TestAppEncoding;
use strict;
use warnings;
use base qw/Catalyst/;
use Catalyst;

__PACKAGE__->config(name => __PACKAGE__);
__PACKAGE__->setup;

1;

package TestAppBadlyImmutable;
use Catalyst qw/+TestPluginWithConstructor/;

use base qw/Class::Accessor Catalyst/;

use Test::More;

__PACKAGE__->setup;

__PACKAGE__->meta->make_immutable(inline_constructor => 0);
ok __PACKAGE__->meta->is_immutable, 'Am now immutable';

1;

package TestApp::Action::TestMyAction;

use strict;
use warnings;

use base qw/Catalyst::Action/;

sub execute {
    my $self = shift;
    my ($controller, $c, $test) = @_;
    $c->res->header('X-TestAppActionTestMyAction', 'MyAction works');
    $c->res->header('X-Component-Name-Action', $controller->catalyst_component_name);
    $c->res->header('X-Component-Instance-Name-Action', ref($controller));
    $c->res->header('X-Class-In-Action', $self->class);
    $self->next::method(@_);
}

1;

package TestApp::Action::TestBefore;

use strict;
use warnings;

use base qw/Catalyst::Action/;

sub execute {
    my $self = shift;
    my ($controller, $c, $test) = @_;
    $c->res->header('X-TestAppActionTestBefore', $test);
    $self->next::method(@_);
}

1;
package TestApp::Action::TestActionArgsFromConstructor;

use Moose;
use namespace::clean -except => [ 'meta' ];

extends 'Catalyst::Action';

has [ qw/extra_arg another_extra_arg/ ] => (is => 'ro');

after execute => sub {
    my ($self, $controller, $ctx) = @_;
    $ctx->response->header('X-TestExtraArgsAction' => join q{,} => $self->extra_arg, $self->another_extra_arg);
};

__PACKAGE__->meta->make_immutable;

1;

package TestApp::Action::TestMatchCaptures;

use Moose;

extends 'Catalyst::Action';

sub match_captures {
    my ($self, $c, $cap) = @_;
    if ($cap->[0] eq 'force') {
        $c->res->header('X-TestAppActionTestMatchCaptures', 'forcing');
        return 1;
    }
    else {
        $c->res->header('X-TestAppActionTestMatchCaptures', 'fallthrough');
        return 0;
    }
}

1;
package TestApp::Action::TestExtraArgsAction;

use Moose;
use namespace::clean -except => [ 'meta' ];

extends 'Catalyst::Action';

has [ qw/extra_arg another_extra_arg/ ] => (is => 'ro');

after execute => sub {
    my ($self, $controller, $ctx) = @_;
    $ctx->response->header('X-TestExtraArgsAction' => join q{,} => $self->extra_arg, $self->another_extra_arg);
};

__PACKAGE__->meta->make_immutable;

1;
package TestApp::Role;
use Moose::Role;
use namespace::clean -except => 'meta';

requires 'fully_qualified'; # Comes from TestApp::Plugin::FullyQualified

our $SETUP_FINALIZE = 0;
our $SETUP_DISPATCHER = 0;

before 'setup_finalize' => sub {$SETUP_FINALIZE++};

before 'setup_dispatcher' => sub {$SETUP_DISPATCHER++};

1;

package TestApp::View::Dump::Body;

use strict;
use base qw[TestApp::View::Dump];

sub process {
    my ($self, $c) = @_;
    return $self->SUPER::process($c, $c->request->{_body}); # FIXME, accessor doesn't work?
}

1;
package TestApp::View::Dump::Response;

use strict;
use base qw[TestApp::View::Dump];

sub process {
    my ($self, $c) = @_;
    my $r = $c->response;
    local $r->{_writer};
    local $r->{_reponse_cb};
    return $self->SUPER::process($c, $r);
}

1;
package TestApp::View::Dump::Request;

use strict;
use base qw[TestApp::View::Dump];

sub process {
    my ($self, $c) = @_;
    my $r = $c->request;
    #local $r->{env};
    return $self->SUPER::process($c, $r);
}

1;
package TestApp::View::Dump::Action;

use strict;
use base qw[TestApp::View::Dump];

sub process {
    my ($self, $c) = @_;
    return $self->SUPER::process($c, $c->action, 0);
}

1;
package TestApp::View::Dump::Env;

use strict;
use base qw[TestApp::View::Dump];

sub process {
    my ($self, $c) = @_;
    my $env = $c->stash->{env};
    return $self->SUPER::process($c, {
            map {($_ => $env->{$_})}
                    grep {$_ ne 'psgi.input'}
                            grep {$_ !~ /^Catalyst/}
                                    keys %{$env},
    });
}

## We override Data::Dumper here since its not reliably outputting
## something that is roundtrip-able.

sub dump {
    my ($self, $reference) = @_;
    use Data::Dump ();
    return Data::Dump::dump($reference);
}

1;

package TestApp::View::Dump;

use strict;
use base 'Catalyst::View';

use Data::Dumper ();
use Scalar::Util qw(blessed weaken);

sub dump {
    my ($self, $reference, $purity) = @_;

    return unless $reference;

    $purity = defined $purity ? $purity : 1;

    my $dumper = Data::Dumper->new([ $reference ]);
    $dumper->Indent(1);
    $dumper->Purity($purity);
    $dumper->Useqq(0);
    $dumper->Deepcopy(1);
    $dumper->Quotekeys(1);
    $dumper->Terse(1);

    local $SIG{ __WARN__ } = sub {warn unless $_[ 0 ] =~ m{dummy}};
    return $dumper->Dump;
}

sub process {
    my ($self, $c, $reference, $purity) = @_;

    # Force processing of on-demand data
    $c->prepare_body;

    # Remove body from reference if needed
    $reference->{__body_type} = blessed $reference->body
            if (blessed $reference->{_body});
    my $body = delete $reference->{_body};

    # Remove context from reference if needed
    my $context = delete $reference->{_context};

    my $env = delete $reference->{env};

    if (my $log = $reference->{_log}) {
        $log->clear_psgi if ($log->can('psgienv'));
    }

    if (my $output =
            $self->dump($reference, $purity)) {

        $c->res->headers->content_type('text/plain');
        $c->res->output($output);

        if ($context) {
            # Repair context
            $reference->{_context} = $context;
            weaken($reference->{_context});
        }

        if ($body) {
            # Repair body
            delete $reference->{__body_type};
            $reference->{_body} = $body;
        }

        if ($env) {$reference->{env} = $env}

        return 1;
    }

    return 0;
}

1;
package TestApp::RequestBaseBug;

use base 'Catalyst::Request';

sub uri {
    my $self = shift;

    # this goes into infinite mutual recursion
    $self->base;

    $self->SUPER::uri(@_)
}

1;
package TestApp::Plugin::AddDispatchTypes;
use strict;
use warnings;
use MRO::Compat;

sub setup_dispatcher {
    my $class = shift;

    ### Load custom DispatchTypes, as done by Catalyst::Plugin::Server
    # There should be a waaay less ugly method for doing this,
    # FIXME in 5.9
    $class->next::method(@_);
    $class->dispatcher->preload_dispatch_types(
            @{$class->dispatcher->preload_dispatch_types},
            qw/+TestApp::DispatchType::CustomPreLoad/
    );
    $class->dispatcher->postload_dispatch_types(
            @{$class->dispatcher->postload_dispatch_types},
            qw/+TestApp::DispatchType::CustomPostLoad/
    );

    return $class;
}

1;

package TestApp::Plugin::FullyQualified;

use strict;

sub fully_qualified {
    my $c = shift;

    $c->stash->{fully_qualified} = 1;

    return $c;
}

1;
package TestApp::Plugin::ParameterizedRole;

use MooseX::Role::Parameterized;
use namespace::clean -except => [ 'meta' ];

parameter method_name => (
        isa      => 'Str',
        required => 1,
);

role {
    my $p = shift;
    my $method_name = $p->method_name;

    method $method_name => sub {'birne'};
};

1;
package TestApp::Model;
use Moose;
use namespace::clean -except => 'meta';

extends 'Catalyst::Model';

# Test a closure here, r10394 made this blow up when we clone the config down
# onto the subclass..
__PACKAGE__->config(
        escape_flags => {
                'js' => sub {${$_[0]} =~ s/\'/\\\'/g;},
        }
);

__PACKAGE__->meta->make_immutable;

package TestApp::Controller::Root;
use strict;
use warnings;
use base 'Catalyst::Controller';
use utf8;

__PACKAGE__->config->{namespace} = '';

sub chain_root_index :Chained('/') PathPart('') Args(0) {}

sub zero :Path('0') {
    my ($self, $c) = @_;
    $c->res->header('X-Test-Class' => ref($self));
    $c->response->content_type('text/plain; charset=utf-8');
    $c->forward('TestApp::View::Dump::Request');
}

sub zerobody :Local {
    my ($self, $c) = @_;
    $c->res->body('0');
}

sub emptybody :Local {
    my ($self, $c) = @_;
    $c->res->body('');
}

sub index :Private {
    my ($self, $c) = @_;
    $c->res->body('root index');
}

sub global_action :Private {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub class_forward_test_method :Private {
    my ($self, $c) = @_;
    $c->response->headers->header('X-Class-Forward-Test-Method' => 1);
}

sub loop_test :Local {
    my ($self, $c) = @_;

    for (1 .. 1001) {
        $c->forward('class_forward_test_method');
    }
}

sub recursion_test :Local {
    my ($self, $c) = @_;
    no warnings 'recursion';
    $c->forward('recursion_test');
}

sub base_href_test :Local {
    my ($self, $c) = @_;

    my $body = <<"EndOfBody";
<html>
<head>
    <base href="http://www.example.com/">
</head>
<body>
</body>
</html>
EndOfBody

    $c->response->body($body);
}

sub body_semipredicate :Local {
    my ($self, $c) = @_;
    $c->res->body;                                  # Old code tests length($c->res->body), which causes the value to be built (undef), which causes the predicate
    $c->res->status($c->res->has_body ? 500 : 200); # to return the wrong thing, resulting in a 500.
    $c->res->body('Body');
}

sub test_redirect :Global {
    my ($self, $c) = @_;
    # Don't set content_type
    # Don't set body
    $c->res->redirect('/go_here');
    # route for /go_here doesn't exist
    # it is only for checking HTTP response code, content-type etc.
}

sub test_redirect_uri_for :Global {
    my ($self, $c) = @_;
    # Don't set content_type
    # Don't set body
    $c->res->redirect($c->uri_for('/go_here'));
    # route for /go_here doesn't exist
    # it is only for checking HTTP response code, content-type etc.
}

sub test_redirect_with_contenttype :Global {
    my ($self, $c) = @_;
    # set content_type but don't set body
    $c->res->content_type('image/jpeg');
    $c->res->redirect('/go_here');
    # route for /go_here doesn't exist
    # it is only for checking HTTP response code, content-type etc.
}

sub test_redirect_with_content :Global {
    my ($self, $c) = @_;
    $c->res->content_type('text/plain');
    $c->res->body('Please kind sir, I beg you to go to /go_here.');
    $c->res->redirect('/go_here');
    # route for /go_here doesn't exist
    # it is only for checking HTTP response code, content-type etc.
}

sub test_remove_body_with_304 :Global {
    my ($self, $c) = @_;
    $c->res->status(304);
    $c->res->content_type('text/html');
    $c->res->body("<html><body>Body should not be set</body></html>");
}

sub test_remove_body_with_204 :Global {
    my ($self, $c) = @_;
    $c->res->status(204);
    $c->res->content_type('text/html');
    $c->res->body("<html><body>Body should not be set</body></html>");
}

sub test_remove_body_with_100 :Global {
    my ($self, $c) = @_;
    $c->res->status(100);
    $c->res->body("<html><body>Body should not be set</body></html>");
}

sub test_nobody_with_100 :Global {
    my ($self, $c) = @_;
    $c->res->status(100);
}

sub end :Private {
    my ($self, $c) = @_;
}

1;
package TestApp::Controller::Action::Detach;

use strict;
use base 'TestApp::Controller::Action';

sub one :Local {
    my ($self, $c) = @_;
    $c->detach('two');
    $c->forward('error');
}

sub two :Private {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub error :Local {
    my ($self, $c) = @_;
    $c->res->output('error');
}

sub path :Local {
    my ($self, $c) = @_;
    $c->detach('/action/detach/two');
    $c->forward('error');
}

sub with_args :Local {
    my ($self, $c, $orig) = @_;
    $c->detach('args', [ qq/new/ ]);
}

sub with_method_and_args :Local {
    my ($self, $c, $orig) = @_;
    $c->detach(qw/TestApp::Controller::Action::Detach args/, [ qq/new/ ]);
}

sub args :Local {
    my ($self, $c, $val) = @_;
    die "Expected argument 'new', got '$val'" unless $val eq 'new';
    die "passed argument does not match args" unless $val eq $c->req->args->[0];
    $c->res->body($c->req->args->[0]);
}

1;
package TestApp::Controller::Action::Local;

use strict;
use base 'TestApp::Controller::Action';

sub one :Action Relative {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub two :Action Local Args(2) {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub three :Action Path('three') {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub four :Action Path('four/five/six') {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub five :Action Local Args(1) {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

1;
package TestApp::Controller::Action::Forward;

use strict;
use base 'TestApp::Controller::Action';

sub one :Local {
    my ($self, $c) = @_;
    $c->forward('two');
}

sub two :Private {
    my ($self, $c) = @_;
    $c->forward('three');
}

sub three :Local {
    my ($self, $c) = @_;
    $c->forward($self, 'four');
}

sub four :Private {
    my ($self, $c) = @_;
    $c->forward('/action/forward/five');
}

sub five :Local {
    my ($self, $c) = @_;
    $c->forward('View::Dump::Request');
}

sub jojo :Local {
    my ($self, $c) = @_;
    $c->forward('one');
    $c->forward($c->controller('Action::Forward'), 'three');
}

sub inheritance :Local {
    my ($self, $c) = @_;
    $c->forward('/action/inheritance/a/b/default');
    $c->forward('five');
}

sub global :Local {
    my ($self, $c) = @_;
    $c->forward('/global_action');
}

sub with_args :Local {
    my ($self, $c, $orig) = @_;
    $c->forward('args', [ qq/new/ ]);
    $c->res->body($c->req->args->[0]);
}

sub with_method_and_args :Local {
    my ($self, $c, $orig) = @_;
    $c->forward(qw/TestApp::Controller::Action::Forward args/, [ qq/new/ ]);
    $c->res->body($c->req->args->[0]);
}

sub to_action_object :Local {
    my ($self, $c) = @_;
    $c->forward($self->action_for('embed'), [ qw/mtfnpy/ ]);
}

sub args :Local {
    my ($self, $c, $val) = @_;
    die "Expected argument 'new', got '$val'" unless $val eq 'new';
    die "passed argument does not match args" unless $val eq $c->req->args->[0];
}

sub args_embed_relative :Local {
    my ($self, $c) = @_;
    $c->forward('embed/ok');
}

sub args_embed_absolute :Local {
    my ($self, $c) = @_;
    $c->forward('/action/forward/embed/ok');
}

sub embed :Local {
    my ($self, $c, $ok) = @_;

    $ok ||= 'not ok';
    $c->res->body($ok);
}

sub class_forward_test_action :Local {
    my ($self, $c) = @_;
    $c->forward(qw/TestApp class_forward_test_method/);
}

sub forward_to_uri_check :Local {
    my ($self, $c) = @_;
    $c->forward('Action::ForwardTo', 'uri_check');
}

1;
package TestApp::Controller::Action::Chained;

use strict;
use warnings;

use HTML::Entities;

use base qw/Catalyst::Controller/;

sub begin :Private {}

#
#   TODO
#   :Chained('') means what?
#

#
#   Simple parent/child action test
#
sub foo :PathPart('chained/foo') :CaptureArgs(1) :Chained('/') {
    my ($self, $c, @args) = @_;
    die "missing argument" unless @args;
    die "more than 1 argument: got @args" if @args > 1;
}
sub endpoint :PathPart('end') :Chained('/action/chained/foo') :Args(1) {}

#
#   Parent/child test with two args each
#
sub foo2 :PathPart('chained/foo2') :CaptureArgs(2) :Chained('/') {}
sub endpoint2 :PathPart('end2') :Chained('/action/chained/foo2') :Args(2) {}

#
#   Relative specification of parent action
#
sub bar :PathPart('chained/bar') :Chained('/') :CaptureArgs(0) {}
sub finale :PathPart('') :Chained('bar') :Args {}

#
#   three chain with concurrent endpoints
#
sub one :PathPart('chained/one') :Chained('/') :CaptureArgs(1) {}
sub two :PathPart('two') :Chained('/action/chained/one') :CaptureArgs(2) {}
sub three_end :PathPart('three') :Chained('two') :Args(3) {}
sub one_end :PathPart('chained/one') :Chained('/') :Args(1) {}
sub two_end :PathPart('two') :Chained('one') :Args(2) {}

#
#   Dispatch on number of arguments
#
sub multi1 :PathPart('chained/multi') :Chained('/') :Args(1) {}
sub multi2 :PathPart('chained/multi') :Chained('/') :Args(2) {}

#
#   Roots in an action defined in a higher controller
#
sub higher_root :PathPart('bar') :Chained('/action/chained/foo/higher_root') :Args(1) {}

#
#   Controller -> subcontroller -> controller
#
sub pcp1 :PathPart('chained/pcp1') :Chained('/') :CaptureArgs(1) {}
sub pcp3 :Chained('/action/chained/foo/pcp2') :Args(1) {}

#
#   Dispatch on capture number
#
sub multi_cap1 :PathPart('chained/multi_cap') :Chained('/') :CaptureArgs(1) {}
sub multi_cap2 :PathPart('chained/multi_cap') :Chained('/') :CaptureArgs(2) {}
sub multi_cap_end1 :PathPart('baz') :Chained('multi_cap1') :Args(0) {}
sub multi_cap_end2 :PathPart('baz') :Chained('multi_cap2') :Args(0) {}

#
#   Priority: Slurpy args vs. chained actions
#
sub priority_a1 :PathPart('chained/priority_a') :Chained('/') :Args {}
sub priority_a2 :PathPart('chained/priority_a') :Chained('/') :CaptureArgs(1) {}
sub priority_a2_end :PathPart('end') :Chained('priority_a2') :Args(1) {}


#
#   Priority: Fixed args vs. chained actions
#
sub priority_b1 :PathPart('chained/priority_b') :Chained('/') :Args(3) {}
sub priority_b2 :PathPart('chained/priority_b') :Chained('/') :CaptureArgs(1) {}
sub priority_b2_end :PathPart('end') :Chained('priority_b2') :Args(1) {}

#
#   Priority: With no Args()
#
sub priority_c1 :PathPart('chained/priority_c') :Chained('/') :CaptureArgs(1) {}
sub priority_c2 :PathPart('') :Chained('priority_c1') {}
sub priority_c2_xyz :PathPart('xyz') :Chained('priority_c1') {}


#
#   Optional specification of :Args in endpoint
#
sub opt_args :PathPart('chained/opt_args') :Chained('/') {}

#
#   Optional PathPart test -> /chained/optpp/*/opt_pathpart/*
#
sub opt_pp_start :Chained('/') :PathPart('chained/optpp') :CaptureArgs(1) {}
sub opt_pathpart :Chained('opt_pp_start') :Args(1) {}

#
#   Optional Args *and* PathPart -> /chained/optall/*/oa/...
#
sub opt_all_start :Chained('/') :PathPart('chained/optall') :CaptureArgs(1) {}
sub oa :Chained('opt_all_start') {}

#
#   :Chained is the same as :Chained('/')
#
sub rootdef :Chained :PathPart('chained/rootdef') :Args(1) {}

#
#   the ParentChain controller chains to this action by
#   specifying :Chained('.')
#
sub parentchain :Chained('/') :PathPart('chained/parentchain') :CaptureArgs(1) {}

#
#   This is just for a test that a loose end is not callable
#
sub loose :Chained :PathPart('chained/loose') CaptureArgs(1) {}

#
#   Forwarding out of the middle of a chain.
#
sub chain_fw_a :Chained :PathPart('chained/chain_fw') :CaptureArgs(1) {
    $_[1]->forward('/action/chained/fw_dt_target');
}
sub chain_fw_b :Chained('chain_fw_a') :PathPart('end') :Args(1) {}

#
#   Detaching out of the middle of a chain.
#
sub chain_dt_a :Chained :PathPart('chained/chain_dt') :CaptureArgs(1) {
    $_[1]->detach('/action/chained/fw_dt_target');
}
sub chain_dt_b :Chained('chain_dt_a') :PathPart('end') :Args(1) {}

#
#   Error in the middle of a chain
#
sub chain_error_a :Chained :PathPart('chained/chain_error') :CaptureArgs(1) {
    $_[1]->error('break in the middle of a chain');
}

sub chain_error_b :Chained('chain_error_a') :PathPart('end') :Args(1) {}

#
#   Die in the middle of a chain
#
sub chain_die_a :Chained :PathPart('chained/chain_die') :CaptureArgs(1) {
    die("die in the middle of a chain\n");
}

sub chain_die_b :Chained('chain_die_a') :PathPart('end') :Args(1) {}

#
#   Target for former forward and chain tests.
#
sub fw_dt_target :Private {}

#
#   Test multiple chained actions with no captures
#
sub empty_chain_a :Chained('/') PathPart('chained/empty') CaptureArgs(0) {}
sub empty_chain_b :Chained('empty_chain_a') PathPart('') CaptureArgs(0) {}
sub empty_chain_c :Chained('empty_chain_b') PathPart('') CaptureArgs(0) {}
sub empty_chain_d :Chained('empty_chain_c') PathPart('') CaptureArgs(1) {}
sub empty_chain_e :Chained('empty_chain_d') PathPart('') CaptureArgs(0) {}
sub empty_chain_f :Chained('empty_chain_e') PathPart('') Args(1) {}

sub mult_nopp_base :Chained('/') PathPart('chained/mult_nopp') CaptureArgs(0) {}
sub mult_nopp_all :Chained('mult_nopp_base') PathPart('') Args(0) {}
sub mult_nopp_new :Chained('mult_nopp_base') PathPart('new') Args(0) {}
sub mult_nopp_id :Chained('mult_nopp_base') PathPart('') CaptureArgs(1) {}
sub mult_nopp_idall :Chained('mult_nopp_id') PathPart('') Args(0) {}
sub mult_nopp_idnew :Chained('mult_nopp_id') PathPart('new') Args(0) {}

sub mult_nopp2_base :Chained('/') PathPart('chained/mult_nopp2') CaptureArgs(0) {}
sub mult_nopp2_nocap :Chained('mult_nopp2_base') PathPart('') CaptureArgs(0) {}
sub mult_nopp2_action :Chained('mult_nopp2_nocap') PathPart('action') CaptureArgs(0) {}
sub mult_nopp2_action_default :Chained('mult_nopp2_action') PathPart('') Args(0) {}
sub mult_nopp2_action_with_arg :Chained('mult_nopp2_action') PathPart('') Args(1) {}
sub mult_nopp2_load :Chained('mult_nopp2_base') PathPart('') CaptureArgs(1) {}
sub mult_nopp2_view :Chained('mult_nopp2_load') PathPart('') Args(0) {}

#
#   Test Choice between branches and early return logic
#   Declaration order is important for $children->{$*}, since this is first match best.
#
sub cc_base :Chained('/') PathPart('chained/choose_capture') CaptureArgs(0) {}
sub cc_link :Chained('cc_base') PathPart('') CaptureArgs(0) {}
sub cc_anchor :Chained('cc_link') PathPart('anchor.html') Args(0) {}
sub cc_all :Chained('cc_base') PathPart('') Args() {}

sub cc_a :Chained('cc_base') PathPart('') CaptureArgs(1) {}
sub cc_a_link :Chained('cc_a') PathPart('a') CaptureArgs(0) {}
sub cc_a_anchor :Chained('cc_a_link') PathPart('') Args() {}

sub cc_b :Chained('cc_base') PathPart('b') CaptureArgs(0) {}
sub cc_b_link :Chained('cc_b') PathPart('') CaptureArgs(1) {}
sub cc_b_anchor :Chained('cc_b_link') PathPart('anchor.html') Args() {}

#
#   Test static paths vs. captures
#

sub apan :Chained('/') CaptureArgs(0) PathPrefix {}
sub korv :Chained('apan') CaptureArgs(0) PathPart('') {}
sub wurst :Chained('apan') CaptureArgs(1) PathPart('') {}
sub static_end :Chained('korv') Args(0) {}
sub capture_end :Chained('wurst') Args(0) PathPart('') {}


# */search vs doc/*
sub view :Chained('/') PathPart('chained') CaptureArgs(1) {}
sub star_search :Chained('view') PathPart('search') Args(0) {}
sub doc_star :Chained('/') PathPart('chained/doc') Args(1) {}

sub return_arg :Chained('view') PathPart('return_arg') Args(1) {}

sub return_arg_decoded :Chained('/') PathPart('chained/return_arg_decoded') Args(1) {
    my ($self, $c) = @_;
    $c->req->args([ map {decode_entities($_)} @{$c->req->args} ]);
}

sub roundtrip_urifor :Chained('/') PathPart('chained/roundtrip_urifor') CaptureArgs(1) {}
sub roundtrip_urifor_end :Chained('roundtrip_urifor') PathPart('') Args(1) {
    my ($self, $c) = @_;
    # This should round-trip, always - i.e. the uri you put in should come back out.
    $c->res->body($c->uri_for($c->action, $c->req->captures, @{$c->req->args}, $c->req->parameters));
    $c->stash->{no_end} = 1;
}

sub match_captures :Chained('/') PathPart('chained/match_captures') CaptureArgs(1) ActionClass('+TestApp::Action::TestMatchCaptures') {
    my ($self, $c) = @_;
    $c->res->header('X-TestAppActionTestMatchCapturesHasRan', 'yes');
}

sub match_captures_end :Chained('match_captures') PathPart('bar') Args(0) {}

sub end :Private {
    my ($self, $c) = @_;
    return if $c->stash->{no_end};
    my $out = join('; ', map {join(', ', @$_)}
            ($c->req->captures, $c->req->args));
    $c->res->body($out);
}

1;
package TestApp::Controller::Action::DieInEnd;

use strict;
use base 'TestApp::Controller::Action';

sub end :Private {
    my ($self, $c) = @_;
    die "I'm ending with death";
}

sub default :Private {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

1;
package TestApp::Controller::Action::Path;

use strict;
use base 'TestApp::Controller::Action';

__PACKAGE__->config(
        actions => {
                'one' => { 'Path' => [ 'a path with spaces' ] },
                'two' => { 'Path' => "åäö" },
                'six' => { 'Local' => undef },
        },
);

sub one :Action Path("this_will_be_overriden") {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub two :Action {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub three :Path {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub four :Path( 'spaces_near_parens_singleq' ) {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub five :Path( "spaces_near_parens_doubleq" ) {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub six {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

1;
package TestApp::Controller::Action::ConfigSmashArrayRefs;

use strict;
use base 'Catalyst::Controller';

sub foo :Action {}

# check configuration for an inherited action
__PACKAGE__->config(
        action => {
                foo => { CustomAttr => [ 'Bar' ] }
        }
);

sub _parse_CustomAttr_attr {
    my ($self, $app, $name, $value) = @_;
    return CustomAttr => "PoopInYourShoes";
}

1;

package TestApp::Controller::Action::Default;

use strict;
use base 'TestApp::Controller::Action';

sub default :Private {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

1;
package TestApp::Controller::Action::Private;

use strict;
use base 'TestApp::Controller::Action';

sub default :Private {
    my ($self, $c) = @_;
    $c->res->output('access denied');
}

sub one :Private {
    my ($self, $c) = @_;
    $c->res->output('access allowed');
}

sub two :Private {
    my ($self, $c) = @_;
    $c->res->output('access allowed');
}

sub three :Private {
    my ($self, $c) = @_;
    $c->res->output('access allowed');
}

sub four :Private {
    my ($self, $c) = @_;
    $c->res->output('access allowed');
}

sub five :Private {
    my ($self, $c) = @_;
    $c->res->output('access allowed');
}

1;
package TestApp::Controller::Action::Streaming;

use strict;
use base 'TestApp::Controller::Action';

sub streaming :Global {
    my ($self, $c) = @_;
    for my $line (split "\n", <<'EOF') {
foo
bar
baz
EOF
        $c->res->write("$line\n");
    }
}

sub body :Local {
    my ($self, $c) = @_;

    my $file = "$FindBin::Bin/../lib/TestApp/Controller/Action/Streaming.pm";
    my $fh = IO::File->new($file, 'r');
    if (defined $fh) {
        $c->res->body($fh);
    }
    else {
        $c->res->body("Unable to read $file");
    }
}

sub body_glob :Local {
    my ($self, $c) = @_;

    my $file = "$FindBin::Bin/../lib/TestApp/Controller/Action/Streaming.pm";
    open my $fh, '<', $file;
    if (defined $fh) {
        $c->res->body($fh);
    }
    else {
        $c->res->body("Unable to read $file");
    }
}

sub body_large :Local {
    my ($self, $c) = @_;

    # more than one write with the default chunksize
    my $size = 128 * 1024;

    my $data = "\0" x $size;
    open my $fh, '<', \$data;
    $c->res->content_length($size);
    $c->res->body($fh);
}

1;
package TestApp::Controller::Action::ForwardTo;

use strict;
use base 'TestApp::Controller::Action';

sub uri_check :Private {
    my ($self, $c) = @_;
    $c->res->body($c->uri_for('foo/bar')->rel($c->req->base)->path);
}

1;
package TestApp::Controller::Action::Chained::Root;

use strict;
use warnings;

use base qw(Catalyst::Controller);

__PACKAGE__->config->{namespace} = '';

sub rootsub :PathPart Chained( '/' ) CaptureArgs( 1 ) {}
sub endpointsub :PathPart Chained( 'rootsub' ) Args( 1 ) {}

1;
package TestApp::Controller::Action::Chained::Bar;

use strict;
use warnings;

use base qw/Catalyst::Controller/;

#
#   Redispatching between controllers that are not in a parent/child
#   relation. This is the root.
#
sub cross1 :PathPart('chained/cross') :CaptureArgs(1) :Chained('/') {}

1;
package TestApp::Controller::Action::Chained::CaptureArgs;
use warnings;
use strict;

use base qw(Catalyst::Controller);

#
#   This controller build the following patterns of URI:
#      /captureargs/*/*
#      /captureargs/*/*/edit
#      /captureargs/*
#      /captureargs/*/edit
#      /captureargs/test/*
#   It will output the arguments they got passed to @_ after the
#   context object.
#   /captureargs/one/edit should not dispatch to /captureargs/*/*
#   /captureargs/test/one should not dispatch to /captureargs/*/*

sub base :Chained('/') PathPart('captureargs') CaptureArgs(0) {
    my ($self, $c, $arg) = @_;
    push @{$c->stash->{ passed_args }}, 'base';
}

sub two_args :Chained('base') PathPart('') CaptureArgs(2) {
    my ($self, $c, $arg1, $arg2) = @_;
    push @{$c->stash->{ passed_args }}, 'two_args', $arg1, $arg2;
}

sub one_arg :Chained('base') ParthPart('') CaptureArgs(1) {
    my ($self, $c, $arg) = @_;
    push @{$c->stash->{ passed_args }}, 'one_arg', $arg;
}

sub edit_two_args :Chained('two_args') PathPart('edit') Args(0) {
    my ($self, $c) = @_;
    push @{$c->stash->{ passed_args }}, 'edit_two_args';
}

sub edit_one_arg :Chained('one_arg') PathPart('edit') Args(0) {
    my ($self, $c) = @_;
    push @{$c->stash->{ passed_args }}, 'edit_one_arg';
}

sub view_two_args :Chained('two_args') PathPart('') Args(0) {
    my ($self, $c) = @_;
    push @{$c->stash->{ passed_args }}, 'view_two_args';
}

sub view_one_arg :Chained('one_arg') PathPart('') Args(0) {
    my ($self, $c) = @_;
    push @{$c->stash->{ passed_args }}, 'view_one_arg';
}

sub test_plus_arg :Chained('base') PathPart('test') Args(1) {
    my ($self, $c, $arg) = @_;
    push @{$c->stash->{ passed_args }}, 'test_plus_arg', $arg;
}

sub end :Private {
    my ($self, $c) = @_;
    no warnings 'uninitialized';
    $c->response->body(join '; ', @{$c->stash->{ passed_args }});
}

1;
package TestApp::Controller::Action::Chained::ArgsOrder;
use warnings;
use strict;

use base qw(Catalyst::Controller);

#
#   This controller builds a simple chain of three actions that
#   will output the arguments they got passed to @_ after the
#   context object. We do this to test if that passing works
#   as it should.
#

sub base :Chained('/') PathPart('argsorder') CaptureArgs(0) {
    my ($self, $c, $arg) = @_;
    push @{$c->stash->{ passed_args }}, 'base', $arg;
}

sub index :Chained('base') PathPart('') Args(0) {
    my ($self, $c, $arg) = @_;
    push @{$c->stash->{ passed_args }}, 'index', $arg;
}

sub all :Chained('base') PathPart('') Args() {
    my ($self, $c, $arg) = @_;
    push @{$c->stash->{ passed_args }}, 'all', $arg;
}

sub end :Private {
    my ($self, $c) = @_;
    no warnings 'uninitialized';
    $c->response->body(join '; ', @{$c->stash->{ passed_args }});
}

1;
package TestApp::Controller::Action::Chained::Auto::Detach;
use warnings;
use strict;

use base qw(Catalyst::Controller);

#
#   For testing behaviour of a detaching auto action in a chain.
#
sub auto :Private {
    my ($self, $c) = @_;
    $c->detach('/action/chained/auto/fw3');
    return 1;
}

sub detachend :Chained('/action/chained/auto/dt1') Args(1) {}

1;
package TestApp::Controller::Action::Chained::Auto::Forward;
use warnings;
use strict;

use base qw(Catalyst::Controller);

#
#   For testing behaviour of a forwarding auto action in a chain.
#
sub auto :Private {
    my ($self, $c) = @_;
    $c->forward('/action/chained/auto/fw3');
    return 1;
}

sub forwardend :Chained('/action/chained/auto/fw1') Args(1) {}

1;
package TestApp::Controller::Action::Chained::Auto::Bar;
use warnings;
use strict;

use base qw(Catalyst::Controller);

#
#   Test chain reaction if auto action returns 0.
#
sub auto :Private {0}

sub barend :Chained('.') Args(1) {}

sub crossloose :Chained PathPart('chained/auto_cross') CaptureArgs(1) {}

1;
package TestApp::Controller::Action::Chained::Auto::Foo;
use warnings;
use strict;

use base qw(Catalyst::Controller);

#
#   Test chain reaction if auto action returns 1.
#
sub auto :Private {1}

sub fooend :Chained('.') Args(1) {}

sub crossend :Chained('/action/chained/auto/bar/crossloose') Args(1) {}

1;
package TestApp::Controller::Action::Chained::Foo;

use strict;
use warnings;

use base qw/Catalyst::Controller/;

#
#   Child of current namespace
#
sub spoon :Chained('.') :Args(0) {}

#
#   Root for a action in a "parent" controller
#
sub higher_root :PathPart('chained/higher_root') :Chained('/') :CaptureArgs(1) {}

#
#   Parent controller -> this subcontroller -> parent controller test
#
sub pcp2 :Chained('/action/chained/pcp1') :CaptureArgs(1) {}

#
#   Controllers not in parent/child relation. This tests the end.
#
sub cross2 :PathPart('end') :Chained('/action/chained/bar/cross1') :Args(1) {}

#
#   Create a uri to the root index
#
sub to_root :Chained('/') PathPart('action/chained/to_root') {
    my ($self, $c) = @_;
    my $uri = $c->uri_for_action('/chain_root_index');
    $c->res->body("URI:$uri");
    $c->stash->{no_end}++;
}

1;
package TestApp::Controller::Action::Chained::PathPrefix;

use strict;
use warnings;

use base qw/Catalyst::Controller/;

# this is kinda the same thing as: sub instance : Path {}
# it should respond to: /action/chained/pathprefix/*
sub instance :Chained('/') PathPrefix Args(1) {}

1;
package TestApp::Controller::Action::Chained::PassedArgs;
use warnings;
use strict;

use base qw(Catalyst::Controller);

#
#   This controller builds a simple chain of three actions that
#   will output the arguments they got passed to @_ after the
#   context object. We do this to test if that passing works
#   as it should.
#

sub first :PathPart('chained/passedargs/a') Chained('/') CaptureArgs(1) {
    my ($self, $c, $arg) = @_;
    $c->stash->{ passed_args } = [ $arg ];
}

sub second :PathPart('b') Chained('first') CaptureArgs(1) {
    my ($self, $c, $arg) = @_;
    push @{$c->stash->{ passed_args }}, $arg;
}

sub third :PathPart('c') Chained('second') Args(1) {
    my ($self, $c, $arg) = @_;
    push @{$c->stash->{ passed_args }}, $arg;
}

sub end :Private {
    my ($self, $c) = @_;
    $c->response->body(join '; ', @{$c->stash->{ passed_args }});
}

1;
package TestApp::Controller::Action::Chained::ParentChain::Relative;
use warnings;
use strict;

use base qw/Catalyst::Controller/;

# using ../ to go up more than one level
sub chained_rel_two :Chained('../../one') Args(2) {}

1;
package TestApp::Controller::Action::Chained::ParentChain;
use warnings;
use strict;

use base qw/Catalyst::Controller/;

#
#   Chains to the action /action/chained/parentchain in the
#   Action::Chained controller.
#
sub child :Chained('.') :Args(1) {}

# Should be at /chained/rootdef/*/chained_rel/*/*
sub chained_rel :Chained('../one') Args(2) {
}

# Should chain to loose in parent namespace - i.e. at /chained/loose/*/loose/*/*
sub loose :ChainedParent Args(2) {
}

# Should be at /chained/cross/*/up_down/*
sub up_down :Chained('../bar/cross1') Args(1) {
}

1;
package TestApp::Controller::Action::Chained::Auto;
use warnings;
use strict;

use base qw(Catalyst::Controller);

#
#   Provided for sub-auto tests. This just always returns true.
#
sub auto :Private {1}

#
#   Simple chains with auto actions returning 1 and 0
#
sub foo :Chained PathPart('chained/autochain1') CaptureArgs(1) {}
sub bar :Chained PathPart('chained/autochain2') CaptureArgs(1) {}

#
#   Detaching out of an auto action.
#
sub dt1 :Chained PathPart('chained/auto_detach') CaptureArgs(1) {}

#
#   Forwarding out of an auto action.
#
sub fw1 :Chained PathPart('chained/auto_forward') CaptureArgs(1) {}

#
#   Target for dispatch and forward tests.
#
sub fw3 :Private {}

1;
package TestApp::Controller::Action::TestRelative;

use strict;
use base 'TestApp::Controller::Action';

__PACKAGE__->config(
        path => 'action/relative'
);

sub relative :Local {
    my ($self, $c) = @_;
    $c->forward('/action/forward/one');
}

sub relative_two :Local {
    my ($self, $c) = @_;
    $c->forward('TestApp::Controller::Action::Forward', 'one');
}

sub relative_go :Local {
    my ($self, $c) = @_;
    $c->go('/action/go/one');
}

sub relative_go_two :Local {
    my ($self, $c) = @_;
    $c->go('TestApp::Controller::Action::Go', 'one');
}

sub relative_visit :Local {
    my ($self, $c) = @_;
    $c->visit('/action/visit/one');
}

sub relative_visit_two :Local {
    my ($self, $c) = @_;
    $c->visit('TestApp::Controller::Action::Visit', 'one');
}

1;
package TestApp::Controller::Action::Auto::Detach;

use strict;
use base 'TestApp::Controller::Action';

sub auto :Private {
    my ($self, $c) = @_;
    $c->res->body("detach auto");
    if ($c->req->param("with_forward_detach")) {
        $c->forward("with_forward_detach");
    }
    else {
        $c->detach;
    }
    return 1;
}

sub default :Path {
    my ($self, $c) = @_;
    $c->res->body('detach default');
}

sub with_forward_detach :Private {
    my ($self, $c) = @_;
    $c->res->body("detach with_forward_detach");
    if ($c->req->param("detach_to_action")) {
        $c->detach("detach_action");
    }
    else {
        $c->detach;
    }
}

sub detach_action :Private {
    my ($self, $c) = @_;
    $c->res->body("detach_action");
}

1;
package TestApp::Controller::Action::Auto::Default;

use strict;
use base 'TestApp::Controller::Action';

sub begin :Private {}

sub auto :Private {
    my ($self, $c) = @_;
    $c->stash->{auto_ran}++;
    return 1;
}

sub default :Private {
    my ($self, $c) = @_;
    $c->res->body(sprintf 'default (auto: %d)', $c->stash->{auto_ran});
}

sub end :Private {}

1;

package TestApp::Controller::Action::Auto::Abort;

use strict;
use base 'TestApp::Controller::Action';

sub auto :Private {
    my ($self, $c) = @_;
    return 0;
}

sub default :Private {
    my ($self, $c) = @_;
    $c->res->body('abort default');
}

sub end :Private {
    my ($self, $c) = @_;
    $c->res->body('abort end') unless $c->res->body;
}

sub one :Local {
    my ($self, $c) = @_;
    $c->res->body('abort one');
}

1;
package TestApp::Controller::Action::Auto::Deep;

use strict;
use base 'TestApp::Controller::Action';

sub auto :Private {
    my ($self, $c) = @_;
    return 1;
}

sub default :Private {
    my ($self, $c) = @_;
    $c->res->body('deep default');
}

sub one :Local {
    my ($self, $c) = @_;
    $c->res->body('deep one');
}

1;
package TestApp::Controller::Action::Go;

use strict;
use base 'TestApp::Controller::Action';

sub one :Local {
    my ($self, $c) = @_;
    $c->go('two');
}

sub two :Private {
    my ($self, $c) = @_;
    $c->go('three');
}

sub three :Local {
    my ($self, $c) = @_;
    $c->go($self, 'four');
}

sub four :Private {
    my ($self, $c) = @_;
    $c->go('/action/go/five');
}

sub five :Local {
    my ($self, $c) = @_;
    $c->forward('View::Dump::Request');
}

sub inheritance :Local {
    my ($self, $c) = @_;
    $c->go('/action/inheritance/a/b/default');
}

sub global :Local {
    my ($self, $c) = @_;
    $c->go('/global_action');
}

sub with_args :Local {
    my ($self, $c, $arg) = @_;
    $c->go('args', [ $arg ]);
}

sub with_method_and_args :Local {
    my ($self, $c, $arg) = @_;
    $c->go(qw/TestApp::Controller::Action::Go args/, [ $arg ]);
}

sub args :Local {
    my ($self, $c, $val) = @_;
    die "passed argument does not match args" unless $val eq $c->req->args->[0];
    $c->res->body($val);
}

sub go_die :Local {
    my ($self, $c, $val) = @_;
    eval {$c->go('args', [ qq/new/ ])};
    $c->res->body($@ ? $@ : "go() did not die");
    die $Catalyst::GO;
}

sub go_chained :Local {
    my ($self, $c, $val) = @_;
    $c->go('/action/chained/foo/spoon', [ 'captureme' ], [ qw/arg1 arg2/ ]);
}

sub view :Local {
    my ($self, $c, $val) = @_;
    eval {$c->go('View::Dump')};
    $c->res->body($@ ? $@ : "go() did not die");
}

sub model :Local {
    my ($self, $c, $val) = @_;
    eval {$c->go('Model::Foo')};
    $c->res->body($@ ? $@ : "go() did not die");
}

sub args_embed_relative :Local {
    my ($self, $c) = @_;
    $c->go('embed/ok');
}

sub args_embed_absolute :Local {
    my ($self, $c) = @_;
    $c->go('/action/go/embed/ok');
}

sub embed :Local {
    my ($self, $c, $ok) = @_;
    $ok ||= 'not ok';
    $c->res->body($ok);
}

sub class_go_test_action :Local {
    my ($self, $c) = @_;
    $c->go(qw/TestApp/);
}

1;
package TestApp::Controller::Action::Global;

use strict;
use base 'TestApp::Controller::Action';

sub action_global_one :Action Absolute {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub action_global_two :Action Global {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub action_global_three :Action Path('/action_global_three') {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

1;
package TestApp::Controller::Action::Begin;

use strict;
use base 'TestApp::Controller::Action';

sub begin :Private {
    my ($self, $c) = @_;
    $self->SUPER::begin($c);
}

sub default :Private {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

1;
package TestApp::Controller::Action::TestMultipath;

use strict;
use base 'TestApp::Controller::Action';

__PACKAGE__->config(
        namespace => 'action/multipath'
);

sub multipath :Local :Global :Path('/multipath1') :Path('multipath2') {
    my ($self, $c) = @_;
    for my $line (split "\n", <<'EOF') {
foo
bar
baz
EOF
        $c->res->write("$line\n");
    }
}

1;
package TestApp::Controller::Action::End;

use strict;
use base 'TestApp::Controller::Action';

sub end :Private {
    my ($self, $c) = @_;
}

sub default :Private {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

1;
package TestApp::Controller::Action::Inheritance;

use strict;
use base 'TestApp::Controller::Action';

sub auto :Private {
    my ($self, $c) = @_;
    return 1;
}

sub begin :Private {
    my ($self, $c) = @_;
    $self->SUPER::begin($c);
}

sub default :Private {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub end :Private {
    my ($self, $c) = @_;
}

package TestApp::Controller::Action::Inheritance::A;

use strict;
use base 'TestApp::Controller::Action';

sub auto :Private {
    my ($self, $c) = @_;
    return 1;
}

sub begin :Private {
    my ($self, $c) = @_;
    $self->SUPER::begin($c);
}

sub default :Private {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub end :Private {
    my ($self, $c) = @_;
}

package TestApp::Controller::Action::Inheritance::A::B;

use strict;
use base 'TestApp::Controller::Action';

sub auto :Private {
    my ($self, $c) = @_;
    return 1;
}

sub begin :Private {
    my ($self, $c) = @_;
    $self->SUPER::begin($c);
}

sub default :Private {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub end :Private {
    my ($self, $c) = @_;
}

package TestApp::Controller::Action::Inheritance::B;

use strict;
use base 'TestApp::Controller::Action';

# check configuration for an inherited action
__PACKAGE__->config(
        action => {
                begin => {}
        }
);

1;

package TestApp::Controller::Action::Index;

use strict;
use base 'TestApp::Controller::Action';

sub index :Private {
    my ($self, $c) = @_;
    $c->res->body('Action-Index index');
}

1;
package TestApp::Controller::Action::Visit;

use strict;
use base 'TestApp::Controller::Action';

sub one :Local {
    my ($self, $c) = @_;
    $c->visit('two');
}

sub two :Private {
    my ($self, $c) = @_;
    $c->visit('three');
}

sub three :Local {
    my ($self, $c) = @_;
    $c->visit($self, 'four');
}

sub four :Private {
    my ($self, $c) = @_;
    $c->visit('/action/visit/five');
}

sub five :Local {
    my ($self, $c) = @_;
    $c->forward('View::Dump::Request');
}

sub inheritance :Local {
    my ($self, $c) = @_;
    $c->visit('/action/inheritance/a/b/default');
}

sub global :Local {
    my ($self, $c) = @_;
    $c->visit('/global_action');
}

sub with_args :Local {
    my ($self, $c, $arg) = @_;
    $c->visit('args', [ $arg ]);
}

sub with_method_and_args :Local {
    my ($self, $c, $arg) = @_;
    $c->visit(qw/TestApp::Controller::Action::Visit args/, [ $arg ]);
}

sub args :Local {
    my ($self, $c, $val) = @_;
    die "passed argument does not match args" unless $val eq $c->req->args->[0];
    $c->res->body($val);
}

sub visit_die :Local {
    my ($self, $c, $val) = @_;
    eval {$c->visit('args', [ qq/new/ ])};
    $c->res->body($@ ? $@ : "visit() doesn't die");
}

sub visit_chained :Local {
    my ($self, $c, $val, $capture, @args) = @_;
    my @cap_and_args = ([ $capture ], [ @args ]);
    $val eq 1 ? $c->visit('/action/chained/foo/spoon', @cap_and_args)
            : $val eq 2 ? $c->visit(qw/Action::Chained::Foo spoon/, @cap_and_args)
            : $c->visit($c->controller('Action::Chained::Foo')->action_for('spoon'), @cap_and_args)
}

sub view :Local {
    my ($self, $c, $val) = @_;
    eval {$c->visit('View::Dump')};
    $c->res->body($@ ? $@ : "visit() did not die");
}

sub model :Local {
    my ($self, $c, $val) = @_;
    eval {$c->visit('Model::Foo')};
    $c->res->body($@ ? $@ : "visit() did not die");
}

sub args_embed_relative :Local {
    my ($self, $c) = @_;
    $c->visit('embed/ok');
}

sub args_embed_absolute :Local {
    my ($self, $c) = @_;
    $c->visit('/action/visit/embed/ok');
}

sub embed :Local {
    my ($self, $c, $ok) = @_;
    $ok ||= 'not ok';
    $c->res->body($ok);
}

sub class_visit_test_action :Local {
    my ($self, $c) = @_;
    $c->visit(qw/TestApp/);
}

1;
package TestApp::Controller::Action::Action;

use strict;
use base 'TestApp::Controller::Action';

__PACKAGE__->config(
        actions     => {
                '*'                 => { extra_attribute => 13 },
                action_action_five  => { ActionClass => '+Catalyst::Action::TestBefore' },
                action_action_eight => { another_extra_attribute => 'foo' },
        },
        action_args => {
                '*'                 => { extra_arg => 42 },
                action_action_seven => { another_extra_arg => 23 },
        },
);

sub action_action_one :Global :ActionClass('TestBefore') {
    my ($self, $c) = @_;
    $c->res->header('X-Action', $c->stash->{test});
    $c->forward('TestApp::View::Dump::Request');
}

sub action_action_two :Global :ActionClass('TestAfter') {
    my ($self, $c) = @_;
    $c->stash->{after_message} = 'awesome';
    $c->forward('TestApp::View::Dump::Request');
}

sub action_action_three :Global :ActionClass('+TestApp::Action::TestBefore') {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub action_action_four :Global :MyAction('TestMyAction') {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub action_action_five :Global {
    my ($self, $c) = @_;
    $c->res->header('X-Action', $c->stash->{test});
    $c->forward('TestApp::View::Dump::Request');
}

sub action_action_six :Global :ActionClass('~TestMyAction') {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub action_action_seven :Global :ActionClass('~TestExtraArgsAction') {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}

sub action_action_eight :Global {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Action');
}

sub action_action_nine :Global :ActionClass('~TestActionArgsFromConstructor') {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Request');
}
1;
package TestApp::Controller::Action::Auto;

use strict;
use base 'TestApp::Controller::Action';

sub auto :Private {
    my ($self, $c) = @_;
    return 1;
}

sub default :Private {
    my ($self, $c) = @_;
    $c->res->body('default');
}

sub one :Local {
    my ($self, $c) = @_;
    $c->res->body('one');
}

1;
package TestApp::Controller::Priorities;

use strict;
use base 'Catalyst::Controller';

#
#   Local vs. Path (depends on definition order)
#

sub loc_vs_path1_loc :Path('/priorities/loc_vs_path1') {$_[1]->res->body('path')}
sub loc_vs_path1 :Local {$_[1]->res->body('local')}

sub loc_vs_path2 :Local {$_[1]->res->body('local')}
sub loc_vs_path2_loc :Path('/priorities/loc_vs_path2') {$_[1]->res->body('path')}

#
#   Local vs. index (has sub controller)
#

sub loc_vs_index :Local {$_[1]->res->body('local')}

#
#   Path vs. index (has sub controller)
#

sub path_vs_idx :Path('/priorities/path_vs_index') {$_[1]->res->body('path')}

1;
package TestApp::Controller::BodyParams;

use strict;
use base 'Catalyst::Controller';

sub default :Private {
    my ($self, $c) = @_;
    $c->req->body_params({ override => 'that' });
    $c->res->output($c->req->body_params->{override});
    $c->res->status(200);
}

sub no_params :Local {
    my ($self, $c) = @_;
    my $params = $c->req->body_parameters;
    $c->res->output(ref $params);
    $c->res->status(200);
}

1;
package TestApp::Controller::ActionRoles;

use Moose;

BEGIN {extends 'Catalyst::Controller'}

__PACKAGE__->config(
        action_roles => [ '~Kooh' ],
        action_args  => {
                frew => { boo => 'hello' },
        },
);

sub foo :Local Does('Guff') {}
sub bar :Local Does('~Guff') {}
sub baz :Local Does('+Guff') {}
sub quux :Local Does('Zoo') {}

sub corge :Local Does('Guff') ActionClass('TestAfter') {
    my ($self, $ctx) = @_;
    $ctx->stash(after_message => 'moo');
}

sub frew :Local Does('Boo') {
    my ($self, $ctx) = @_;
    my $boo = $ctx->stash->{action_boo};
    $ctx->response->body($boo);
}

1;
package TestApp::Controller::ContextClosure;

use Moose;

BEGIN {
    extends 'Catalyst::Controller';
    with 'Catalyst::Component::ContextClosure';
}

sub normal_closure :Local {
    my ($self, $ctx) = @_;
    $ctx->stash(closure => sub {
        $ctx->response->body('from normal closure');
    });
    $ctx->response->body('stashed normal closure');
}

sub context_closure :Local {
    my ($self, $ctx) = @_;
    $ctx->stash(closure => $self->make_context_closure(sub {
        my ($ctx) = @_;
        $ctx->response->body('from context closure');
    }, $ctx));
    $ctx->response->body('stashed context closure');
}

sub non_closure :Local {
    my ($self, $ctx) = @_;
    $ctx->stash(no_closure => "not a closure");
}

__PACKAGE__->meta->make_immutable;

1;
package TestApp::Controller::Engine::Response::Large;

use strict;
use base 'Catalyst::Controller';

sub one :Relative {
    my ($self, $c) = @_;
    $c->res->output('x' x (100 * 1024));
}

sub two :Relative {
    my ($self, $c) = @_;
    $c->res->output('y' x (1024 * 1024));
}

1;
package TestApp::Controller::Engine::Response::Status;

use strict;
use base 'Catalyst::Controller';

sub begin :Private {
    my ($self, $c) = @_;
    $c->response->content_type('text/plain');
    return 1;
}

sub s200 :Relative {
    my ($self, $c) = @_;
    $c->res->status(200);
    $c->res->output("200 OK\n");
}

sub s400 :Relative {
    my ($self, $c) = @_;
    $c->res->status(400);
    $c->res->output("400 Bad Request\n");
}

sub s403 :Relative {
    my ($self, $c) = @_;
    $c->res->status(403);
    $c->res->output("403 Forbidden\n");
}

sub s404 :Relative {
    my ($self, $c) = @_;
    $c->res->status(404);
    $c->res->output("404 Not Found\n");
}

sub s500 :Relative {
    my ($self, $c) = @_;
    $c->res->status(500);
    $c->res->output("500 Internal Server Error\n");
}

1;
package TestApp::Controller::Engine::Response::Errors;

use strict;
use base 'Catalyst::Controller';

sub one :Relative {
    my ($self, $c) = @_;
    my $a = 0;
    my $b = 0;
    my $t = $a / $b;
}

sub two :Relative {
    my ($self, $c) = @_;
    $c->forward('/non/existing/path');
}

sub three :Relative {
    my ($self, $c) = @_;
    die("I'm going to die!\n");
}

1;
package TestApp::Controller::Engine::Response::Redirect;

use strict;
use base 'Catalyst::Controller';

sub one :Relative {
    my ($self, $c) = @_;
    $c->response->redirect('/test/writing/is/boring');
}

sub two :Relative {
    my ($self, $c) = @_;
    $c->response->redirect('http://www.google.com/');
}

sub three :Relative {
    my ($self, $c) = @_;
    $c->response->redirect('http://www.google.com/');
    $c->response->status(301); # Moved Permanently
}

sub four :Relative {
    my ($self, $c) = @_;
    $c->response->redirect('http://www.google.com/');
    $c->response->status(307); # Temporary Redirect
}

1;

package TestApp::Controller::Engine::Response::Print;

use strict;
use base 'Catalyst::Controller';

sub one :Relative {
    my ($self, $c) = @_;

    $c->res->print("foo");
}

sub two :Relative {
    my ($self, $c) = @_;

    $c->res->print(qw/foo bar/);
}

sub three :Relative {
    my ($self, $c) = @_;

    local $, = ',';
    local $\ = ':';
    $c->res->print(qw/foo bar baz/);
}

1;
package TestApp::Controller::Engine::Response::Headers;

use strict;
use base 'Catalyst::Controller';

sub one :Relative {
    my ($self, $c) = @_;
    $c->res->header('X-Header-Catalyst' => 'Cool');
    $c->res->header('X-Header-Cool' => 'Catalyst');
    $c->res->header('X-Header-Numbers' => join ', ', 1 .. 10);
    $c->forward('TestApp::View::Dump', [ { some => [ qw(fixed content) ] } ]);
}

1;
package TestApp::Controller::Engine::Response::Cookies;

use strict;
use base 'Catalyst::Controller';

sub one :Local {
    my ($self, $c) = @_;
    $c->res->cookies->{catalyst} = { value => 'cool', path => '/bah' };
    $c->res->cookies->{cool} = { value => 'catalyst', path => '/' };
    $c->forward('TestApp::View::Dump::Request');
}

sub two :Local {
    my ($self, $c) = @_;
    $c->res->cookies->{catalyst} = { value => 'cool', path => '/bah' };
    $c->res->cookies->{cool} = { value => 'catalyst', path => '/' };
    $c->res->redirect('http://www.google.com/');
}

sub three :Local {
    my ($self, $c) = @_;

    $c->res->cookies->{object} = CGI::Simple::Cookie->new(
            -name  => "this_is_the_real_name",
            -value => [ qw/foo bar/ ],
    );

    $c->res->cookies->{hash} = {
            value => [ qw/a b c/ ],
    };

    $c->forward('TestApp::View::Dump::Request');
}

sub four :Local {
    my ($self, $c) = @_;
    $c->res->cookies->{good} = { value => 'good_cookie', path => '/' };
    $c->res->cookies->{bad} = { value => undef };
    $c->forward('TestApp::View::Dump::Request');
}

1;
package TestApp::Controller::Engine::Request::URI;

use strict;
use base 'Catalyst::Controller';

sub default :Private {
    my ($self, $c) = @_;

    $c->forward('TestApp::View::Dump::Request');
}

sub change_path :Local {
    my ($self, $c) = @_;

    # change the path
    $c->req->path('/my/app/lives/here');

    $c->forward('TestApp::View::Dump::Request');
}

sub change_base :Local {
    my ($self, $c) = @_;

    # change the base and uri paths
    $c->req->base->path('/new/location');
    $c->req->uri->path('/new/location/engine/request/uri/change_base');

    $c->forward('TestApp::View::Dump::Request');
}

sub uri_with :Local {
    my ($self, $c) = @_;

    # change the current uri
    my $uri = $c->req->uri_with({ b => 1, c => undef });
    my %query = $uri->query_form;

    $c->res->header('X-Catalyst-Param-a' => $query{ a });
    $c->res->header('X-Catalyst-Param-b' => $query{ b });
    $c->res->header('X-Catalyst-Param-c' => exists($query{ c }) ? $query{ c } : '--notexists--');
    $c->res->header('X-Catalyst-query' => $uri->query);

    $c->forward('TestApp::View::Dump::Request');
}

sub uri_with_object :Local {
    my ($self, $c) = @_;

    my $uri = $c->req->uri_with({ a => $c->req->base });
    my %query = $uri->query_form;

    $c->res->header('X-Catalyst-Param-a' => $query{ a });

    $c->forward('TestApp::View::Dump::Request');
}

sub uri_with_utf8 :Local {
    my ($self, $c) = @_;

    # change the current uri
    my $uri = $c->req->uri_with({ unicode => "\x{2620}" });

    $c->res->header('X-Catalyst-uri-with' => "$uri");

    $c->forward('TestApp::View::Dump::Request');
}

sub uri_with_undef :Local {
    my ($self, $c) = @_;

    my $warnings = 0;
    local $SIG{__WARN__} = sub {$warnings++};

    # change the current uri
    my $uri = $c->req->uri_with({ foo => undef });

    $c->res->header('X-Catalyst-warnings' => $warnings);

    $c->forward('TestApp::View::Dump::Request');
}

sub uri_with_undef_only :Local {
    my ($self, $c) = @_;

    my $uri = $c->req->uri_with({ a => undef });

    $c->res->header('X-Catalyst-uri-with' => "$uri");
    $c->forward('TestApp::View::Dump::Request');
}

sub uri_with_undef_ignore :Local {
    my ($self, $c) = @_;

    my $uri = $c->req->uri_with({ a => 1, b => undef });

    my %query = $uri->query_form;
    $c->res->header('X-Catalyst-uri-with' => "$uri");
    $c->res->header('X-Catalyst-Param-a' => $query{ a });
    $c->res->header('X-Catalyst-Param-b' => $query{ b });
    $c->res->header('X-Catalyst-Param-c' => $query{ c });
    $c->forward('TestApp::View::Dump::Request');
}

1;
package TestApp::Controller::Engine::Request::Uploads;

use strict;
use base 'Catalyst::Controller';

sub slurp :Relative {
    my ($self, $c) = @_;
    $c->response->content_type('text/plain; charset=utf-8');
    my $upload = $c->request->upload('slurp');
    my $contents = $upload->slurp;
    my $contents2 = $upload->slurp;
    die("Slurp not callable multiple times") unless $contents eq $contents2;
    $c->response->output($c->request->upload('slurp')->slurp);
}

1;
package TestApp::Controller::Immutable::HardToReload::Role;
use Moose::Role; # Role metaclass does not have make_immutable..
no Moose::Role;

package TestApp::Controller::Immutable::HardToReload;
use Moose;
BEGIN {extends 'Catalyst::Controller'}
no Moose;
__PACKAGE__->meta->make_immutable;

package # Standard PAUSE hiding technique
TestApp::Controller::Immutable::HardToReload::PAUSEHide;
use Moose;
BEGIN {extends 'Catalyst::Controller'}
no Moose;
__PACKAGE__->meta->make_immutable;

# Not an inner package
package TestApp::Controller::Immutable2;
use Moose;
BEGIN {extends 'Catalyst::Controller'}
no Moose;
__PACKAGE__->meta->make_immutable;

# Not even in the app namespace
package Frobnitz;
use Moose;
BEGIN {extends 'Catalyst::Controller'}
no Moose;
__PACKAGE__->meta->make_immutable;
package TestApp::Controller::Args;

use strict;
use base 'Catalyst::Controller';

sub args :Local {
    my ($self, $c) = @_;
    $c->res->body(join('', @{$c->req->args}));
}

sub params :Local {
    my ($self, $c) = splice @_, 0, 2;
    $c->res->body(join('', @_));
}

1;
package TestApp::Controller::Keyword;

use strict;
use base 'Catalyst::Controller';

#
# Due to 'actions' being used as an attribute up to cat 5.80003 using this name
# for an action causes a weird error, as this would be called during BUILD time
# of the Catalyst::Controller class
#

sub actions :Local {
    my ($self, $c) = @_;
    die("Call to controller action method without context! Probably naming clash") unless $c;
    $c->res->output("Test case for using 'actions' as a catalyst action name\n");
}

1;
package Anon::Trait;
use Moose::Role -traits => 'MethodAttributes'; # Needed for role composition to work correctly with anon classes.

after test => sub {
    my ($self, $c) = @_;
    $c->res->header('X-Anon-Trait-Applied', 1);
};

no Moose::Role;

package TestApp::Controller::Anon;
use Moose;
use Moose::Util qw/find_meta/;
use namespace::clean -except => 'meta';
BEGIN {extends 'Catalyst::Controller'};

sub COMPONENT {
    # Don't do this yourself, use CatalystX::Component::Traits!
    my ($class, $app, $args) = @_;

    my $meta = $class->meta->create_anon_class(
            superclasses => [ $class->meta->name ],
            roles        => [ 'Anon::Trait' ],
            cache        => 1,
    );
    # Special move as the methodattributes trait has changed our metaclass..
    $meta = find_meta($meta->name);

    $class = $meta->name;
    $class->new($app, $args);
}

sub test :Local ActionClass('+TestApp::Action::TestMyAction') {
    my ($self, $c) = @_;
    $c->res->header('X-Component-Name-Controller', $self->catalyst_component_name);
    $c->res->body('It works');
}

__PACKAGE__->meta->make_immutable;

package TestApp::Controller::Log;

use strict;
use base 'Catalyst::Controller';

sub debug :Local {
    my ($self, $c) = @_;
    $c->log->debug('debug');
    $c->res->body('logged');
}

sub info :Local {
    my ($self, $c) = @_;
    $c->log->info('info');
    $c->res->body('logged');
}

1;

package TestApp::Controller::Priorities::locre_vs_index;

use strict;
use base 'Catalyst::Controller';

sub index :Private {$_[1]->res->body('index')}

1;
package TestApp::Controller::Priorities::MultiMethod;

use strict;
use warnings;
use base qw/Catalyst::Controller/;

sub auto :Private {
    my ($self, $c) = @_;
    $c->res->body(join(' ', $c->action->name, @{$c->req->args}));
    return 1;
}

sub zero :Path :Args(0) {}

sub one :Path :Args(1) {}

sub two :Path :Args(2) {}

sub not_def :Path {}

1;
package TestApp::Controller::Priorities::path_vs_index;

use strict;
use base 'Catalyst::Controller';

sub index :Private {$_[1]->res->body('index')}

1;
package TestApp::Controller::Priorities::loc_vs_index;

use strict;
use base 'Catalyst::Controller';

sub index :Private {$_[1]->res->body('index')}

1;
package TestApp::Controller::HTTPMethods;

use Moose;
use MooseX::MethodAttributes;

extends 'Catalyst::Controller';

sub default :Path Args {
    my ($self, $ctx) = @_;
    $ctx->response->body('default');
}

sub get :Path('foo') Method('GET') {
    my ($self, $ctx) = @_;
    $ctx->response->body('get');
}

sub post :Path('foo') Method('POST') {
    my ($self, $ctx) = @_;
    $ctx->response->body('post');
}

sub get_or_post :Path('bar') Method('GET') Method('POST') {
    my ($self, $ctx) = @_;
    $ctx->response->body('get or post');
}

sub any_method :Path('baz') {
    my ($self, $ctx) = @_;
    $ctx->response->body('any');
}

sub typo_option :Path('opt_typo') OPTION {
    my ($self, $ctx) = @_;
    $ctx->response->body('typo');
}

sub real_options :Path('opt') OPTIONS {
    my ($self, $ctx) = @_;
    $ctx->response->body('options');
}

sub base :Chained('/') PathPrefix CaptureArgs(0) {}

sub chained_get :Chained('base') Args(0) GET {
    pop->res->body('chained_get');
}

sub chained_post :Chained('base') Args(0) POST {
    pop->res->body('chained_post');
}

sub chained_put :Chained('base') Args(0) PUT {
    pop->res->body('chained_put');
}

sub chained_delete :Chained('base') Args(0) DELETE {
    pop->res->body('chained_delete');
}

sub get_or_put :Chained('base') PathPart('get_put_post_delete') CaptureArgs(0) GET PUT {}

sub get2 :Chained('get_or_put') PathPart('') Args(0) GET {
    pop->res->body('get2');
}

sub put2 :Chained('get_or_put') PathPart('') Args(0) PUT {
    pop->res->body('put2');
}

sub post_or_delete :Chained('base') PathPart('get_put_post_delete') CaptureArgs(0) POST DELETE {}

sub post2 :Chained('post_or_delete') PathPart('') Args(0) POST {
    pop->res->body('post2');
}

sub delete2 :Chained('post_or_delete') PathPart('') Args(0) DELETE {
    pop->res->body('delete2');
}

sub check_default :Chained('base') CaptureArgs(0) {}

sub chain_default :Chained('check_default') PathPart('') Args(0) {
    pop->res->body('chain_default');
}

sub default_get :Chained('check_default') PathPart('') Args(0) GET {
    pop->res->body('get3');
}

sub default_post :Chained('check_default') PathPart('') Args(0) POST {
    pop->res->body('post3');
}

__PACKAGE__->meta->make_immutable;
package TestApp::Controller::Immutable;
use Moose;
BEGIN {extends 'Catalyst::Controller'}
no Moose;
__PACKAGE__->meta->make_immutable;
# Fork.pm
# Copyright (c) 2006 Jonathan Rockway <jrockway@cpan.org>

package TestApp::Controller::Fork;

use strict;
use warnings;
use base 'Catalyst::Controller';

use JSON::MaybeXS qw(encode_json);

sub system :Local {
    my ($self, $c, $ls) = @_;
    my ($result, $code) = (undef, 1);

    if (!-e $ls || !-x _) {
        $result = 'skip';
    }
    else {
        $result = system($ls, $ls, $ls);
        $result = $! if $result != 0;
    }

    $c->response->body(encode_json({ result => $result }));
}

sub backticks :Local {
    my ($self, $c, $ls) = @_;
    my ($result, $code) = (undef, 1);

    if (!-e $ls || !-x _) {
        $result = 'skip';
        $code = 0;
    }
    else {
        $result = `$ls $ls $ls` || $!;
        $code = $?;
    }

    $c->response->body(encode_json({ result => $result, code => $code }));
}

sub fork :Local {
    my ($self, $c) = @_;
    my $pid;
    my $x = 0;

    if ($pid = fork()) {
        $x = "ok";
    }
    else {
        exit(0);
    }

    waitpid $pid, 0 or die;

    $c->response->body(encode_json({ pid => $pid, result => $x }));
}

1;
use strict;
use warnings;

package My::AttributesBaseClass;
use base qw(Catalyst::Controller);

sub fetch :Chained('/') PathPrefix CaptureArgs(0) {}

sub left_alone :Chained('fetch') PathPart Args(0) {}

sub view :PathPart Chained('fetch') Args(0) {}

sub foo {} # no attributes

package TestApp::Controller::Attributes;
use base qw(My::AttributesBaseClass);

sub _parse_MakeMeVisible_attr {
    my ($self, $c, $name, $value) = @_;
    if (!$value) {
        return Chained => 'fetch', PathPart => 'all_attrs', Args => 0;
    }
    elsif ($value eq 'some') {
        return Chained => 'fetch', Args => 0;
    }
    elsif ($value eq 'one') {
        return PathPart => 'one_attr';
    }
}

sub view {} # override attributes to "hide" url

sub foo :Local {}

sub all_attrs_action :MakeMeVisible {}

sub some_attrs_action :MakeMeVisible('some') PathPart('some_attrs') {}

sub one_attr_action :MakeMeVisible('one') Chained('fetch') Args(0) {}

1;
package TestApp::Controller::Index;

use strict;
use base 'Catalyst::Controller';

sub index :Private {
    my ($self, $c) = @_;
    $c->res->body('Index index');
}

1;
package TestApp::Controller::Moose;

use Moose;

use namespace::clean -except => 'meta';

BEGIN {extends qw/Catalyst::Controller/;}
use MooseX::MethodAttributes; # FIXME - You need to say this if you have
#         modifiers so that you get the correct
#         method metaclass, why does the modifier
#         on MODIFY_CODE_ATTRIBUTES not work.

has attribute => (
        is      => 'ro',
        default => 42,
);

sub get_attribute :Local {
    my ($self, $c) = @_;
    $c->response->body($self->attribute);
}

sub with_local_modifier :Local {
    my ($self, $c) = @_;
    $c->forward('get_attribute');
}

before with_local_modifier => sub {
    my ($self, $c) = @_;
    $c->response->header('X-Catalyst-Test-Before' => 'before called');
};

1;
package TestApp::Controller::Dump;

use strict;
use base 'Catalyst::Controller';

sub default :Action {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump');
}

sub env :Action Relative {
    my ($self, $c) = @_;
    $c->stash(env => $c->req->env);
    $c->forward('TestApp::View::Dump::Env');
}

sub request :Action Relative {
    my ($self, $c) = @_;
    $c->req->params(undef); # Should be a no-op, and be ignored.
    # Back compat test for 5.7
    $c->forward('TestApp::View::Dump::Request');
}

sub prepare_parameters :Action Relative {
    my ($self, $c) = @_;

    die 'Must pass in parameters' unless keys %{$c->req->parameters};

    $c->req->parameters({});
    die 'parameters are not empty' if keys %{$c->req->parameters};

    # Now reset and reload
    $c->prepare_parameters;
    die 'Parameters were not reset' unless keys %{$c->req->parameters};

    $c->forward('TestApp::View::Dump::Request');
}
sub response :Action Relative {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Response');
}

sub body :Action Relative {
    my ($self, $c) = @_;
    $c->forward('TestApp::View::Dump::Body');
}

1;
package TestApp::Controller::Action;

use strict;
use base 'Catalyst::Controller';

sub begin :Private {
    my ($self, $c) = @_;
    $c->res->header('X-Test-Class' => ref($self));
    $c->response->content_type('text/plain; charset=utf-8');
}

sub default :Private {
    my ($self, $c) = @_;
    $c->res->output("Error - TestApp::Controller::Action\n");
    $c->res->status(404);
}

1;
package TestApp::Controller::Moose::NoAttributes;
use Moose;
extends qw/Catalyst::Controller/;

__PACKAGE__->config(
        actions => {
                test => { Local => undef }
        }
);

sub test {
}

no Moose;
1;

package TestApp::Controller::Moose::MethodModifiers;
use Moose;
BEGIN {extends qw/TestApp::Controller::Moose/;}

after get_attribute => sub {
    my ($self, $c) = @_;
    $c->response->header('X-Catalyst-Test-After' => 'after called');
};

1;
package TestApp::DispatchType::CustomPreLoad;
use strict;
use warnings;
use base qw/Catalyst::DispatchType::Path/;

# Never match anything..
sub match {}

1;

package TestApp::DispatchType::CustomPostLoad;
use strict;
use warnings;
use base qw/Catalyst::DispatchType::Path/;

# Never match anything..
sub match {}

1;

package TestApp::ActionRole::Guff;

use Moose::Role;

after execute => sub {
    my ($self, $controller, $c) = @_;
    $c->response->body(__PACKAGE__);
};

1;
package TestApp::ActionRole::Kooh;

use Moose::Role;
use namespace::clean -except => [ 'meta' ];

after execute => sub {
    my ($self, $controller, $c) = @_;
    $c->response->header('X-Affe' => 'Tiger');
};

1;
package TestApp::ActionRole::Boo;

use Moose::Role;

has boo => (
        is       => 'ro',
        required => 1,
);

around execute => sub {
    my ($orig, $self, $controller, $ctx, @rest) = @_;
    $ctx->stash(action_boo => $self->boo);
    return $self->$orig($controller, $ctx, @rest);
};

1;
package TestApp::Model::ClosuresInConfig;
use Moose;
use namespace::clean -except => 'meta';

extends 'TestApp::Model';

# Note - don't call ->config in here until the constructor calls it to
#        retrieve config, so that we get the 'copy from parent' path,
#        and ergo break due to the closure if dclone is used there..

__PACKAGE__->meta->make_immutable;

package TestApp::Model::Foo::Bar;

sub model_foo_bar_method_from_foo_bar {"model_foo_bar_method_from_foo_bar"}

1;
package TestApp::Model::Foo;

use strict;
use warnings;

use base qw/Catalyst::Model/;

__PACKAGE__->config('quux' => 'chunkybacon');

sub model_foo_method {1}

sub model_quux_method {shift->{quux}}

package TestApp::Model::Foo::Bar;
sub model_foo_bar_method_from_foo {1}

package TestApp::Model::Foo;
sub bar {"TestApp::Model::Foo::Bar"}

1;
package TestApp::Model::Generating;
use Moose;
extends 'Catalyst::Model';

sub BUILD {
    Class::MOP::Class->create(
            'TestApp::Model::Generated' => (
                    methods => {
                            foo => sub {'foo'}
                    }
            )
    );
}

sub expand_modules {
    return ('TestApp::Model::Generated');
}

__PACKAGE__->meta->make_immutable;
no Moose;

1;
# See t/plugin_new_method_backcompat.t
package TestAppPluginWithConstructor;
use Test::More;
use Test::Fatal;
use Catalyst qw/+TestPluginWithConstructor/;
use Moose;
extends qw/Catalyst/;

__PACKAGE__->setup;
our $MODIFIER_FIRED = 0;

is exception {
    before 'dispatch' => sub {$MODIFIER_FIRED = 1}
}, undef, 'Can apply method modifier';
no Moose;

our $IS_IMMUTABLE_YET = __PACKAGE__->meta->is_immutable;
ok !$IS_IMMUTABLE_YET, 'I am not immutable yet';

1;

package TestAppChainedRecursive::Controller::Foo;

use strict;
use warnings;

use base qw/Catalyst::Controller/;

sub foo :Chained('bar') CaptureArgs(1) {}
sub bar :Chained('foo') CaptureArgs(1) {}

1;
package TestAppNonMooseController;
use base qw/Catalyst/;
use Catalyst;

__PACKAGE__->setup;

1;

package TestAppMatchSingleArg::Controller::Root;

use strict;
use warnings;
use base 'Catalyst::Controller';

__PACKAGE__->config->{namespace} = '';

sub match_single :Path Args(1) {
    my ($self, $c) = @_;
    $c->res->body('Path Args(1)');
}

sub match_other :Path {
    my ($self, $c) = @_;
    $c->res->body('Path');
}

sub match_two :Path Args(2) {
    my ($self, $c) = @_;
    $c->res->body('Path Args(2)');
}

1;
use strict;
use warnings;

package TestAppStats;

use Catalyst qw/
        -Stats=1
/;

our $VERSION = '0.01';
our @log_messages;

__PACKAGE__->config(name => 'TestAppStats', root => '/some/dir');

__PACKAGE__->log(TestAppStats::Log->new);

__PACKAGE__->setup;

package TestAppStats::Log;
use base qw/Catalyst::Log/;

sub info {push(@TestAppStats::log_messages, @_);}
sub debug {push(@TestAppStats::log_messages, @_);}

1;

package TestLogger;
use strict;
use warnings;

our @LOGS;
our @ILOGS;
our @ELOGS;

sub new {
    return bless {}, __PACKAGE__;
}

sub debug {
    shift;
    push(@LOGS, shift());
}

sub info {
    shift;
    push(@ILOGS, shift());
}

sub warn {
    shift;
    push(@ELOGS, shift());
}

sub error {die "Got unexpected error; $_[1]"}
1;

package TestAppChainedAbsolutePathPart;

use strict;
use Catalyst qw/
        Test::Errors
        Test::Headers
/;
use Catalyst::Utils;

our $VERSION = '0.01';

TestAppChainedAbsolutePathPart
        ->config(
        name => 'TestAppChainedAbsolutePathPart',
        root => '/some/dir'
);

TestAppChainedAbsolutePathPart->setup;

1;
package TestAppMetaCompat;
use base qw/Catalyst/;

__PACKAGE__->config(name => __PACKAGE__);
__PACKAGE__->setup;

1;

package TestApp;
use strict;
use Catalyst qw/
        Test::MangleDollarUnderScore
        Test::Errors
        Test::Headers
        Test::Plugin
        Test::Inline
        +TestApp::Plugin::FullyQualified
        +TestApp::Plugin::AddDispatchTypes
        +TestApp::Role
/;
use Catalyst::Utils;
use Class::Load 'try_load_class';

use Moose;
use namespace::clean -except => [ 'meta' ];

# -----------
# t/aggregate/unit_core_ctx_attr.t pukes until lazy is true
package Greeting;
use Moose;
sub hello_notlazy {'hello there'}
sub hello_lazy {'hello there'}

package TestApp;
has 'my_greeting_obj_notlazy' => (
        is      => 'ro',
        isa     => 'Greeting',
        default => sub {Greeting->new()},
        handles => [ qw(hello_notlazy) ],
        lazy    => 0,
);
has 'my_greeting_obj_lazy' => (
        is      => 'ro',
        isa     => 'Greeting',
        default => sub {Greeting->new()},
        handles => [ qw(hello_lazy) ],
        lazy    => 1,
);
# -----------

our $VERSION = '0.01';

TestApp->config(
        name                         => 'TestApp',
        root                         => '/some/dir',
        use_request_uri_for_path     => 1,
        'Controller::Action::Action' => {
                action_args => {
                        action_action_nine => { another_extra_arg => 13 }
                }
        },
        encoding                     => 'UTF-8',
        abort_chain_on_error_fix     => 1,
);

# Test bug found when re-adjusting the metaclass compat code in Moose
# in 292360. Test added to Moose in 4b760d6, but leave this attribute
# above ->setup so we have some generated methods to be double sure.
has an_attribute_before_we_change_base_classes => (is => 'ro');

if ($::setup_leakchecker) {
    require Scalar::Util;
    require Devel::Cycle;

    has leaks => (
            is      => 'ro',
            default => sub {[]},
    );

    sub count_leaks {
        my ($ctx) = @_;
        return scalar @{$ctx->leaks};
    }

    after finalize => sub {
        my ($ctx) = @_;
        my @leaks;

        my $weak_ctx = $ctx;
        Scalar::Util::weaken $weak_ctx;

        Devel::Cycle::find_cycle($ctx, sub {
            my ($path) = @_;
            push @leaks, $path
                    if $path->[0]->[2] == $weak_ctx;
        });

        push @{$ctx->leaks}, @leaks;
    };
}

TestApp->setup;

sub execute {
    my $c = shift;
    my $class = ref($c->component($_[0])) || $_[0];
    my $action = $_[1]->reverse;

    my $method;

    if ($action =~ /->(\w+)$/) {
        $method = $1;
    }
    elsif ($action =~ /\/(\w+)$/) {
        $method = $1;
    }
    elsif ($action =~ /^(\w+)$/) {
        $method = $action;
    }

    if ($class && $method && $method !~ /^_/) {
        my $executed = sprintf("%s->%s", $class, $method);
        my @executed = $c->response->headers->header('X-Catalyst-Executed');
        push @executed, $executed;
        $c->response->headers->header(
                'X-Catalyst-Executed' => join ', ',
                        @executed
        );
    }
    no warnings 'recursion';
    return $c->SUPER::execute(@_);
}

# Replace the very large HTML error page with
# useful info if something crashes during a test
sub finalize_error {
    my $c = shift;

    $c->next::method(@_);

    $c->res->status(500);
    $c->res->body('FATAL ERROR: ' . join(', ', @{$c->error}));
}

{
    no warnings 'redefine';
    sub Catalyst::Log::error {}
}

# Pretend to be Plugin::Session and hook finalize_headers to send a header

sub finalize_headers {
    my $c = shift;

    $c->res->header('X-Test-Header', 'valid');

    my $call_count = $c->stash->{finalize_headers_call_count} || 0;
    $call_count++;
    $c->stash(finalize_headers_call_count => $call_count);
    $c->res->header('X-Test-Header-Call-Count' => $call_count);

    return $c->maybe::next::method(@_);
}

# Make sure we can load Inline plugins.

package Catalyst::Plugin::Test::Inline;
use Moose;

1;
package TestAppEncodingSetInApp;
use Moose;

use Catalyst;

extends 'Catalyst';

__PACKAGE__->config(
        encoding => 'UTF-8',
);

__PACKAGE__->setup;

1;
package TestAppWithMeta::Controller::Root;
use base qw/Catalyst::Controller/; # N.B. Do not convert to Moose, so we do not
#      have a metaclass instance!

__PACKAGE__->config(namespace => '');

no warnings 'redefine';
sub meta {'fnar'}
use warnings 'redefine';

sub default :Private {
    my ($self, $c) = @_;
    $c->res->body($self->meta);
}

1;

package TestMiddlewareFromPlugin::Controller::Root;

use Moose;
use MooseX::MethodAttributes;

extends 'Catalyst::Controller';

sub default :Path {}
sub welcome :Path(welcome) {
    pop->res->body('Welcome to Catalyst');
}

__PACKAGE__->meta->make_immutable;
package TestMiddlewareFromPlugin::SetMiddleware;
use strict;
use warnings;
use File::Spec;
use File::Basename ();

my $config_path = File::Spec->catfile(File::Basename::dirname(__FILE__), 'testmiddlewarefromplugin.pl');

sub setup {
    my $c = shift;
    $c->config(do $config_path);
    $c->next::method(@_);
}

1;
package TestMiddlewareFromPlugin::Custom;

use strict;
use warnings;

use parent qw/Plack::Middleware::Static/;

1;
package Guff;

use Moose::Role;
use namespace::clean -except => [ 'meta' ];

after execute => sub {
    my ($self, $controller, $c) = @_;
    $c->response->body(__PACKAGE__);
};

1;
package TestAppToTestScripts;
use strict;
use warnings;
use Carp;

our @RUN_ARGS;

sub run {
    @RUN_ARGS = @_;
    1; # Does this work?
}

1;

package TestAppStats::Controller::Root;
use strict;
use warnings;
use base 'Catalyst::Controller';

__PACKAGE__->config->{namespace} = '';

# Return log messages from previous request
sub default :Private {
    my ($self, $c) = @_;
    $c->stats->profile("test");
    $c->res->body(join("\n", @TestAppStats::log_messages));
    @TestAppStats::log_messages = ();
}

1;
package TestAppClassExceptionSimpleTest::Exception;
use strict;
use warnings;

sub throw {}

#########

package TestAppClassExceptionSimpleTest;
use strict;
use warnings;

use Catalyst::Utils; #< some of the scripts use Catalyst::Utils before MyApp.pm

BEGIN {$Catalyst::Exception::CATALYST_EXCEPTION_CLASS = 'TestAppClassExceptionSimpleTest::Exception';}

use Catalyst;

__PACKAGE__->setup;

1;
package DeprecatedTestApp::C::Root;
use strict;
use warnings;
use base qw/Catalyst::Controller/;

__PACKAGE__->config->{namespace} = '';

sub index :Private {
    my ($self, $c) = @_;
    $c->res->body('root index');
}

sub req_user :Local {
    my ($self, $c) = @_;
    $c->res->body('REMOTE_USER = ' . $c->req->user);
}

1;
package TestAppPluginWithConstructor::Controller::Root;

use base 'Catalyst::Controller';

__PACKAGE__->config->{namespace} = '';

sub foo :Local {
    my ($self, $c) = @_;
    $c->res->body('foo');
}

1;
package DeprecatedTestApp;

use strict;
use Catalyst qw/
        Test::Deprecated
/;

our $VERSION = '0.01';

__PACKAGE__->config(name => 'DeprecatedTestApp', root => '/some/dir');

__PACKAGE__->setup;

1;
package TestApp;

use strict;
use warnings;

use Catalyst::Runtime 5.70;

use base qw/Catalyst/;

use Catalyst;

__PACKAGE__->setup();

sub _test {
    my $self = shift;
    $self->_method_which_does_not_exist;
}

__PACKAGE__->_test;

1;

package PluginTestApp;
use Test::More;

use Catalyst (
        'Test::Plugin',
        '+TestApp::Plugin::FullyQualified',
        (eval {
            require MooseX::Role::Parameterized;
            1
        }
                ? ('+TestApp::Plugin::ParameterizedRole' => { method_name => 'affe' })
                : ()),
);

sub _test_plugins {
    my $c = shift;
    is_deeply [ $c->registered_plugins ],
            [
                    qw/Catalyst::Plugin::Test::Plugin
                            TestApp::Plugin::FullyQualified/
            ],
            '... and it should report the correct plugins';
    ok $c->registered_plugins('Catalyst::Plugin::Test::Plugin'),
            '... or if we have a particular plugin';
    ok $c->registered_plugins('Test::Plugin'),
            '... even if it is not fully qualified';
    ok !$c->registered_plugins('No::Such::Plugin'),
            '... and it should return false if the plugin does not exist';
}

__PACKAGE__->setup;
package ACLTestApp::Controller::Root;
use Test::More;

use base 'Catalyst::Controller';

__PACKAGE__->config->{namespace} = '';

sub foobar :Private {
    die $Catalyst::DETACH;
}

sub gorch :Local {
    my ($self, $c, $frozjob) = @_;
    is $frozjob, 'wozzle';
    $c->res->body("gorch");
}

1;
package TestDataHandlers;

use Catalyst;

__PACKAGE__->config(
        'Controller::Root', { namespace => '' }
);

__PACKAGE__->setup;
package Catalyst::Action::TestBefore;

use strict;
use warnings;

use base qw/Catalyst::Action/;

sub execute {
    my $self = shift;
    my ($controller, $c) = @_;
    $c->stash->{test} = 'works';
    $self->next::method(@_);
}

1;
package Catalyst::Action::TestAfter;

use strict;
use warnings;

use base qw/Catalyst::Action/; # N.B. Keep as a non-moose class, this also
# tests metaclass initialization works as expected

sub execute {
    my $self = shift;
    my ($controller, $c) = @_;
    $self->next::method(@_);
    $c->res->header('X-Action-After', $c->stash->{after_message});
}

1;
package Catalyst::Plugin::Test::MangleDollarUnderScore;
use strict;
use warnings;

# FIXME - should proably use utf8??
our $VERSION = 0.1; # Make is_class_loaded happy

# Class::Load::load_class($_) can hurt you real hard.
BEGIN {$_ = q{
mst sayeth, Class::Load::load_class($_) will ruin your life
rafl spokeh "i ♥ my $_"',
and verrily forsooth, t0m made tests
and yea, there was fail' };}

1;
package Catalyst::Plugin::Test::Errors;

use strict;
use MRO::Compat;

sub error {
    my $c = shift;

    unless ($_[0]) {
        return $c->next::method(@_);
    }

    if ($_[0] =~ /^(Unknown resource|No default action defined)/) {
        $c->response->status(404);
    }

    if ($_[0] =~ /^Couldn\'t forward/) {
        $c->response->status(404);
    }

    if ($_[0] =~ /^Caught exception/) {
        $c->response->status(500);
    }

    my $error = $_[0];
    $error =~ s/\n/, /g;

    $c->response->headers->push_header('X-Catalyst-Error' => $error);

    $c->next::method(@_);
}

1;
package Catalyst::Plugin::Test::Plugin;
use Moose;
use MRO::Compat;

with 'Catalyst::ClassData';

__PACKAGE__->mk_classdata('ran_setup');

sub setup {
    my $c = shift;
    $c->ran_setup('1');

    return $c->next::method(@_);
}

sub prepare {
    my $class = shift;

    my $c = $class->next::method(@_);
    $c->response->header('X-Catalyst-Plugin-Setup' => $c->ran_setup);

    return $c;
}

# Note: Catalyst::Plugin::Server forces the body to
#       be parsed, by calling the $c->req->body method in prepare_action.
#       We need to test this, as this was broken by 5.80. See also
#       t/aggregate/live_engine_request_body.t.
sub prepare_action {
    my $c = shift;
    $c->res->header('X-Have-Request-Body', 1) if $c->req->body;
    $c->next::method(@_);
}

no Moose;
1;
package Catalyst::Plugin::Test::Headers;

use strict;
use MRO::Compat;

sub prepare {
    my $class = shift;

    my $c = $class->next::method(@_);

    $c->response->header('X-Catalyst-Engine' => $c->engine);
    $c->response->header('X-Catalyst-Debug' => $c->debug ? 1 : 0);

    {
        my $components = join(', ', sort keys %{$c->components});
        $c->response->header('X-Catalyst-Components' => $components);
    }

    {
        no strict 'refs';
        my $plugins = join ', ', $class->registered_plugins;
        $c->response->header('X-Catalyst-Plugins' => $plugins);
    }

    return $c;
}

sub prepare_action {
    my $c = shift;
    $c->next::method(@_);
    $c->res->header('X-Catalyst-Action' => $c->req->action);
}

1;
package Catalyst::Plugin::Test::Deprecated;

use strict;
use warnings;

sub prepare {
    my $class = shift;
    # Note: This use of NEXT is deliberately left here (without a use NEXT)
    #       to ensure back compat, as NEXT always used to be loaded, but
    #       is now replaced by Class::C3::Adopt::NEXT.
    my $c = $class->NEXT::prepare(@_);
    $c->response->header('X-Catalyst-Plugin-Deprecated' => 1);

    return $c;
}

1;
package Catalyst::Script::Baz;
use Moose;
use namespace::clean -except => [ 'meta' ];

use Test::More;

with 'Catalyst::ScriptRole';

sub run {__PACKAGE__}

after new_with_options => sub {
    my ($self, %args) = @_;
    is_deeply \%args, { application_name => 'ScriptTestApp' }, 'App name correct';
};

1;
package Catalyst::Script::Bar;
use Moose;
use namespace::clean -except => [ 'meta' ];

with 'Catalyst::ScriptRole';

sub run {__PACKAGE__}

1;
package Catalyst::Script::CompileTest;
use Moose;
use namespace::clean -except => [ 'meta' ];

use Test::More;

with 'Catalyst::ScriptRole';

sub run {__PACKAGE__}

after new_with_options => sub {
    my ($self, %args) = @_;
    is_deeply \%args, { application_name => 'ScriptTestApp' }, 'App name correct';
};

1;
package Catalyst::ActionRole::Guff;

use Moose::Role;
use namespace::clean -except => [ 'meta' ];

after execute => sub {
    my ($self, $controller, $c) = @_;
    $c->response->body(__PACKAGE__);
};

1;
package Catalyst::ActionRole::Zoo;

use Moose::Role;
use namespace::clean -except => [ 'meta' ];

after execute => sub {
    my ($self, $controller, $c) = @_;
    $c->response->body(__PACKAGE__);
};

1;
use strict;
use warnings;

package TestAppViewWarnings;

use Catalyst;

our @log_messages;

__PACKAGE__->config(name => 'TestAppWarnings', root => '/some/dir', default_view => "DoesNotExist");

__PACKAGE__->log(TestAppViewWarnings::Log->new);

__PACKAGE__->setup;

package TestAppViewWarnings::Log;

use base qw/Catalyst::Log/;
sub warn {push(@TestAppViewWarnings::log_messages, @_[1 .. $#_]);}

1;

package TestAppEncodingSetInApp::Controller::Root;
use Moose;
use namespace::clean -except => [ 'meta' ];

BEGIN {extends 'Catalyst::Controller';}

__PACKAGE__->config(namespace => '');

sub default :Local {
    my ($self, $c) = @_;

    $c->res->body('');
}

1;
package TestAppEncoding::Controller::Root;
use strict;
use warnings;
use base 'Catalyst::Controller';
use Test::More;

__PACKAGE__->config->{namespace} = '';

sub binary :Local {
    my ($self, $c) = @_;
    $c->res->content_type('image/gif');
    $c->res->body(do {
        open(my $fh, '<', $c->path_to('..', '..', 'catalyst_130pix.gif')) or die $!;
        binmode($fh);
        local $/ = undef;
        <$fh>;
    });
}

sub binary_utf8 :Local {
    my ($self, $c) = @_;
    $c->forward('binary');
    my $str = $c->res->body;
    utf8::upgrade($str);
    ok utf8::is_utf8($str), 'Body is variable width encoded string';
    $c->res->body($str);
}

# called by t/aggregate/catalyst_test_utf8.t
sub utf8_non_ascii_content :Local {
    use utf8;
    my ($self, $c) = @_;

    my $str = 'ʇsʎlɐʇɐɔ'; # 'catalyst' flipped at http://www.revfad.com/flip.html
    ok utf8::is_utf8($str), '$str is in UTF8 internally';

    $c->res->content_type('text/plain');
    $c->res->body($str);
}

sub end :Private {
    my ($self, $c) = @_;
}

1;
package TestAppOneView::View::Dummy;

use base 'Catalyst::View';

sub COMPONENT {
    bless {}, 'AClass'
}

package AClass;

use base 'Catalyst::View';

1;
package TestAppOneView::Controller::Root;

use base 'Catalyst::Controller';
use Scalar::Util ();

__PACKAGE__->config->{namespace} = '';

sub view_no_args :Local {
    my ($self, $c) = @_;

    my $v = $c->view;

    $c->res->body(Scalar::Util::blessed($v));
}

sub view_by_name :Local {
    my ($self, $c) = @_;

    my $v = $c->view($c->req->param('view'));

    $c->res->body(Scalar::Util::blessed($v));
}

sub view_by_regex :Local {
    my ($self, $c) = @_;

    my $v_name = $c->req->param('view');

    my ($v) = $c->view(qr/$v_name/);

    $c->res->body(Scalar::Util::blessed($v));
}

1;
package ScriptTestApp;
use Moose;

extends 'Catalyst';

__PACKAGE__->setup;
1;

package TestAppShowInternalActions;
use Moose;
use namespace::clean -except => [ 'meta' ];

use Catalyst::Runtime 5.80;

use Catalyst qw/-Debug/; # Debug must remain on for
# t/live_show_internal_actions_warnings.t

extends 'Catalyst';

__PACKAGE__->config(
        name                                        => 'TestAppShowInternalActions',
        disable_component_resolution_regex_fallback => 1,
        show_internal_actions                       => 1,
);

__PACKAGE__->setup();

1;
package TestAppWithoutUnicode;
use strict;
use warnings;
use TestLogger;
use base qw/Catalyst/;
use Catalyst qw//;

__PACKAGE__->config('name' => 'TestAppWithoutUnicode');

__PACKAGE__->log(TestLogger->new);

__PACKAGE__->setup;

1;
package TestAppOnDemand;

use strict;
use Catalyst qw/
        Test::Errors
        Test::Headers
/;
use Catalyst::Utils;

our $VERSION = '0.01';

__PACKAGE__->config(
        name            => __PACKAGE__,
        root            => '/some/dir',
        parse_on_demand => 1,
);

__PACKAGE__->setup;

1;
# See t/plugin_new_method_backcompat.t
package Class::Accessor::Fast;
use strict;
use warnings;

sub new {
    my $class = shift;
    return bless $_[0], $class;
}

package TestPluginWithConstructor;
use strict;
use warnings;
use base qw/Class::Accessor::Fast/;

1;

package NullPackage;
# Do nothing class, there should be no code or symbols defined here..
# Loading this works fine in 5.70, but a die was introduced in 5.80 which caused
# it to fail. This has been changed to a warning to maintain back-compat.
# See Catalyst::Utils::ensure_class_loaded() for more info.
1;

package TestAppIndexDefault::Controller::Root;

use base 'Catalyst::Controller';

__PACKAGE__->config->{namespace} = '';

sub default :Private {
    my ($self, $c) = @_;
    $c->res->body('default');
}

sub path_one_arg :Path('/') Args(1) {
    my ($self, $c) = @_;
    $c->res->body('path_one_arg');
}

1;
package TestAppIndexDefault::Controller::IndexPrivate;

use base 'Catalyst::Controller';

sub index :Private {
    my ($self, $c) = @_;
    $c->res->body('index_private');
}

1;
package TestAppIndexDefault::Controller::Default;

use base 'Catalyst::Controller';

sub default :Private {
    my ($self, $c) = @_;
    $c->res->body('default_default');
}

sub path_one_arg :Path('/default/') Args(1) {
    my ($self, $c) = @_;
    $c->res->body('default_path_one_arg');
}

1;
package TestAppIndexDefault::Controller::IndexChained;

use base 'Catalyst::Controller';

sub index :Chained('/') PathPart('indexchained') CaptureArgs(0) {}

sub index_endpoint :Chained('index') PathPart('') Args(0) {
    my ($self, $c) = @_;
    $c->res->body('index_chained');
}

1;
package TestAppShowInternalActions::Controller::Root;
use Moose;
use namespace::clean -except => [ 'meta' ];

BEGIN {extends 'Catalyst::Controller'}

__PACKAGE__->config(namespace => '');

sub index :Path :Args(0) {
    my ($self, $c) = @_;

    $c->response->body('hello world');
}

sub end :Action {}

__PACKAGE__->meta->make_immutable;

1;
package MakeTestApp;
use strict;
use warnings;

use Exporter 'import';
use Cwd qw(abs_path);
use File::Spec::Functions qw(updir catdir);
use File::Basename qw(dirname);
use File::Path qw(rmtree);
use File::Copy::Recursive qw(dircopy);

our @EXPORT = qw(make_test_app);

our $root = abs_path(catdir(dirname(__FILE__), (updir) x 2));

sub make_test_app {
    my $tmp = "$root/t/tmp";
    rmtree $tmp if -d $tmp;
    mkdir $tmp;

    # create a TestApp and copy the test libs into it
    my $testapp = "$tmp/TestApp";
    mkdir $testapp;

    mkdir "$testapp/lib";
    mkdir "$testapp/script";

    for my $command (qw(CGI FastCGI Server)) {
        my $script = "$testapp/script/testapp_\L$command\E.pl";
        open my $fh, '>:raw', $script
                or die "can't create $script: $!";
        print $fh <<"END_CODE";
#!/usr/bin/env perl

use Catalyst::ScriptRunner;
Catalyst::ScriptRunner->run('TestApp', '$command');

1;
END_CODE
        close $fh;
        chmod 0755, $script;
    }

    open my $fh, '>:raw', "$testapp/cpanfile";
    close $fh;

    File::Copy::Recursive::dircopy("$root/t/lib", "$testapp/lib");

    return $testapp;
}

1;
package TestMiddleware;

use Moose;
use Plack::Middleware::Static;
use Plack::App::File;
use Catalyst;

extends 'Catalyst';

my $static = Plack::Middleware::Static->new(
        path => qr{^/static/}, root => TestMiddleware->path_to('share'));

__PACKAGE__->config(
        'Controller::Root', { namespace => '' },
        'psgi_middleware', [
        'Head',
        $static,
        'Static', { path => qr{^/static2/}, root => TestMiddleware->path_to('share') },
        'Runtime',
        '+TestMiddleware::Custom', { path => qr{^/static3/}, root => TestMiddleware->path_to('share') },
        sub {
            my $app = shift;
            return sub {
                my $env = shift;
                if ($env->{PATH_INFO} =~ m/forced/) {
                    Plack::App::File->new(file => TestMiddleware->path_to(qw/share static forced.txt/))
                            ->call($env);
                }
                else {
                    return $app->($env);
                }
            },
        },

],
);

__PACKAGE__->setup;

package TestAppOneView;
use strict;
use warnings;
use TestLogger;
use Catalyst;

__PACKAGE__->log(TestLogger->new);

__PACKAGE__->setup;

1;
package CDICompatTestPlugin;

# This plugin specificially tests an edge case of C::D::I compat,
# where you load a plugin which creates an accessor with the same
# name as a class data accessor (_config in this case)..

# This is what happens if you use the authentication back-compat
# stuff, as C::A::Plugin::Credential::Password is added to the plugin
# list, and that uses base C::A::C::P class, does the mk_accessors.

# If a class data method called _config hasn't been created in
# MyApp ($app below), then our call to ->config gets our accessor
# (rather than the class data one), and we fail..

use strict;
use warnings;
use base qw/Class::Accessor::Fast/;
use MRO::Compat;
__PACKAGE__->mk_accessors(qw/_config/);

sub setup {
    my $app = shift;

    $app->config;
    $app->next::method(@_);
}

# However, if we are too enthusiastic about adding accessors to the
# MyApp package, then this method isn't called (as there is a local
# symbol already).

# Note - use a different package here, so that Moose's
# package detection code doesn't get confused..
$CDICompatTestPlugin::Data::HAS_RUN_SETUP_FINISHED = 0;

sub setup_finished {
    my $app = shift;
    $CDICompatTestPlugin::Data::HAS_RUN_SETUP_FINISHED = 1;
    $app->next::method(@_);
}

1;
package TestContentNegotiation;

use Moose;
use Catalyst;

extends 'Catalyst';

__PACKAGE__->config(
        'Controller::Root', { namespace => '' },
);

__PACKAGE__->setup;

package TestAppIndexDefault;
use strict;
use warnings;
use TestLogger;
use Catalyst;

__PACKAGE__->log(TestLogger->new);

__PACKAGE__->setup;

1;
package ChainedActionsApp::Controller::Root;
use Moose;
use namespace::clean -except => [ 'meta' ];

BEGIN {extends 'Catalyst::Controller'}

#
# Sets the actions in this controller to be registered with no prefix
# so they function identically to actions created in MyApp.pm
#
__PACKAGE__->config(namespace => '');

sub setup :Chained('/') PathPart('') CaptureArgs(0) {
    my ($self, $c) = @_;
    # Common things here are to check for ACL and setup global contexts
}

sub home :Chained('setup') PathPart('') Args(0) {
    my ($self, $c) = @_;
    $c->response->body("Application Home Page");
}

sub home_base :Chained('setup') PathPart('') CaptureArgs(2) {
    my ($self, $c, $proj_id, $title) = @_;
    $c->stash({ project_id => $proj_id, project_title => $title });
}

sub hpages :Chained('home_base') PathPart('') Args(0) {
    my ($self, $c) = @_;
    $c->response->body("List project " . $c->stash->{project_title} . " pages");
}

sub hpage :Chained('home_base') PathPart('') Args(2) {
    my ($self, $c, $page_id, $pagetitle) = @_;
    $c->response->body("This is $pagetitle page of " . $c->stash->{project_title} . " project");
}

sub no_account :Chained('setup') PathPart('account') Args(0) {
    my ($self, $c) = @_;
    $c->response->body("New account o login");
}

sub account_base :Chained('setup') PathPart('account') CaptureArgs(1) {
    my ($self, $c, $acc_id) = @_;
    $c->stash({ account_id => $acc_id });
}

sub account :Chained('account_base') PathPart('') Args(0) {
    my ($self, $c, $acc) = @_;
    $c->response->body("This is account " . $c->stash->{account_id});
}

sub profile_base :Chained('setup') PathPart('account/profile') CaptureArgs(1) {
    my ($self, $c, $acc_id) = @_;
    $c->stash({ account_id => $acc_id });
}

sub profile :Chained('profile_base') PathPart('') Args(1) {
    my ($self, $c, $acc) = @_;
    $c->response->body("This is profile of " . $acc);
}

=head2 downloads

    This is a different test, this function is void, just to let following in the chain
    to declare downloads as PathPart.

=cut

sub downloads :Chained('setup') PathPart('') CaptureArgs(0) {
    my ($self, $c) = @_;
}

sub downloads_index :Chained('downloads') PathPart('downloads') Args(0) {
    my ($self, $c) = @_;
    $c->response->body("This is download index");
}

sub default :Chained('setup') PathPart('') Args() {
    my ($self, $c) = @_;
    $c->response->body('Page not found');
    $c->response->status(404);
}

sub end :Action {}

__PACKAGE__->meta->make_immutable;

1;
package TestFromPSGI;

use Moose;
use Catalyst;

__PACKAGE__->config(
        'Controller::Root', { namespace => '' },
        use_hash_multivalue_in_request => 1,
);

__PACKAGE__->setup;

package TestDataHandlers::Controller::Root;

use base 'Catalyst::Controller';

sub root :Path('/') {}

sub test_json :Local {
    my ($self, $c) = @_;
    $c->res->body($c->req->body_data->{message});
}

sub test_nested_for :Local {
    my ($self, $c) = @_;
    $c->res->body($c->req->body_data->{nested}->{value});
}

1;
use strict;
use warnings;

package TestAppDoubleAutoBug;

use TestLogger;
use Catalyst qw/
        Test::Errors
        Test::Headers
        Test::Plugin
/;

our $VERSION = '0.01';

__PACKAGE__->config(name => 'TestAppDoubleAutoBug', root => '/some/dir');

__PACKAGE__->log(TestLogger->new);

__PACKAGE__->setup;

sub execute {
    my $c = shift;
    my $class = ref($c->component($_[0])) || $_[0];
    my $action = $_[1]->reverse();

    my $method;

    if ($action =~ /->(\w+)$/) {
        $method = $1;
    }
    elsif ($action =~ /\/(\w+)$/) {
        $method = $1;
    }
    elsif ($action =~ /^(\w+)$/) {
        $method = $action;
    }

    if ($class && $method && $method !~ /^_/) {
        my $executed = sprintf("%s->%s", $class, $method);
        my @executed = $c->response->headers->header('X-Catalyst-Executed');
        push @executed, $executed;
        $c->response->headers->header(
                'X-Catalyst-Executed' => join ', ',
                        @executed
        );
    }

    return $c->SUPER::execute(@_);
}

1;

package TestAppNonMooseController::Controller::Foo;
use base qw/TestAppNonMooseController::ControllerBase/;

1;

package TestAppNonMooseController::ControllerBase;
use base qw/Catalyst::Controller/;

1;

package TestAppUnicode::Controller::Root;
use strict;
use warnings;
use utf8;

__PACKAGE__->config(namespace => q{});

use base 'Catalyst::Controller';

sub main :Path('') {
    my ($self, $ctx, $charset) = @_;
    my $content_type = 'text/html';
    if ($ctx->stash->{charset}) {
        $content_type .= ";charset=" . $ctx->stash->{charset};
    }
    $ctx->res->body('<h1>It works</h1>');
    $ctx->res->content_type($content_type);
}

sub unicode_no_enc :Local {
    my ($self, $c) = @_;
    my $data = "ほげ"; # hoge!
    utf8::encode($data);
    $c->response->body($data);
    $c->res->content_type('text/plain');
    $c->encoding(undef);
}

sub unicode :Local {
    my ($self, $c) = @_;
    my $data = "ほげ";         # hoge!
    $c->response->body($data); # should be decoded
    $c->res->content_type('text/plain');
}

sub not_unicode :Local {
    my ($self, $c) = @_;
    my $data = "\x{1234}\x{5678}";
    utf8::encode($data);       # DO NOT WANT unicode
    $c->response->body($data); # just some octets
    $c->res->content_type('text/plain');
    $c->encoding(undef);
}

sub latin1 :Local {
    my ($self, $c) = @_;

    $c->res->content_type('text/plain');
    $c->response->body('LATIN SMALL LETTER E WITH ACUTE: é');
}

sub file :Local {
    my ($self, $c) = @_;
    close *STDERR; # i am evil.
    open my $test_file, '<', \"this is a test";
    $c->response->body($test_file);
}

sub capture :Chained('/') CaptureArgs(1) {}

sub decode_capture :Chained('capture') PathPart('') Args(0) {
    my ($self, $c, $cap_arg) = @_;
    $c->forward('main');
}

sub capture_charset :Chained('/') Args(1) {
    my ($self, $c, $cap_arg) = @_;
    $c->stash(charset => $cap_arg);
    $c->forward('main');
}

sub shift_jis :Local {
    my ($self, $c) = @_;
    my $data = "ほげ";         # hoge!
    $c->response->body($data); # should be decoded
    $c->res->content_type('text/plain; charset=Shift_JIS');
    $c->encoding("Shift_JIS");
}

1;

package TestAppEncodingSetInPlugin;
use Moose;

use Catalyst qw/+TestAppEncodingSetInPlugin::SetEncoding/;

extends 'Catalyst';

__PACKAGE__->setup;

1;
package TestPath;
use strict;
use warnings;
use Catalyst;

__PACKAGE__->setup;

1;
package Test::Apple;

use strict;
use warnings;

use parent qw/Catalyst::Controller/;

sub default :Path {
}

sub apple :Local {
}

1;
package ChainedActionsApp;
use Moose;
use TestLogger;

use Catalyst::Runtime 5.80;

use Catalyst qw//;

use namespace::clean -except => [ 'meta' ];

extends 'Catalyst';

our $VERSION = "0.01";
$VERSION = eval $VERSION;

__PACKAGE__->config(
        name                             => 'ChainedActionsApp',
        disable_component_regex_fallback => 1,
);

__PACKAGE__->log(TestLogger->new);

__PACKAGE__->setup;

1;
package TestAppViewWarnings::Controller::Root;
use strict;
use warnings;
use base 'Catalyst::Controller';

__PACKAGE__->config->{namespace} = '';

# Return log messages from previous request
sub index :Path Args() {}

sub end :Action {
    my ($self, $c) = @_;
    $c->view; # Cause view lookup and ergo warning we are testing.
    $c->res->body('foo');
}

1;
package Catalyst::Test;

use strict;
use warnings;
use Test::More ();

use Plack::Test;
use Catalyst::Exception;
use Catalyst::Utils;
use Class::Load qw(load_class is_class_loaded);
use Sub::Exporter;
use Moose::Util 'find_meta';
use Carp 'croak', 'carp';

sub _build_request_export {
    my ($self, $args) = @_;

    return sub {_remote_request(@_)}
            if $args->{remote};

    my $class = $args->{class};

    # Here we should be failing right away, but for some stupid backcompat thing
    # I don't quite remember we fail lazily here. Needs a proper deprecation and
    # then removal.
    return sub {croak "Must specify a test app: use Catalyst::Test 'TestApp'"}
            unless $class;

    load_class($class) unless is_class_loaded($class);
    $class->import;

    return sub {_local_request($class, @_)};
}

sub _build_get_export {
    my ($self, $args) = @_;
    my $request = $args->{request};

    return sub {$request->(@_)->content};
}
sub _build_ctx_request_export {
    my ($self, $args) = @_;
    my ($class, $request) = @{$args}{qw(class request)};

    return sub {
        my $me = ref $self || $self;

        # fail if ctx_request is being used against a remote server
        Catalyst::Exception->throw("$me only works with local requests, not remote")
                if $ENV{CATALYST_SERVER};

        # check explicitly for the class here, or the Cat->meta call will blow
        # up in our face
        Catalyst::Exception->throw("Must specify a test app: use Catalyst::Test 'TestApp'") unless $class;

        # place holder for $c after the request finishes; reset every time
        # requests are done.
        my $ctx_closed_over;

        # hook into 'dispatch' -- the function gets called after all plugins
        # have done their work, and it's an easy place to capture $c.
        my $meta = find_meta($class);
        $meta->make_mutable;
        $meta->add_after_method_modifier("dispatch", sub {
            $ctx_closed_over = shift;
        });
        $meta->make_immutable(replace_constructor => 1);
        Class::C3::reinitialize(); # Fixes RT#46459, I've failed to write a test for how/why, but it does.

        # do the request; C::T::request will know about the class name, and
        # we've already stopped it from doing remote requests above.
        my $res = $args->{request}->(@_);

        # Make sure not to leave a reference $ctx hanging around.
        # This means that the context will go out of scope as soon as the
        # caller disposes of it, rather than waiting till the next time
        # that ctx_request is called. This can be important if your $ctx
        # ends up with a reference to a shared resource or lock (for example)
        # which you want to clean up in test teardown - if the $ctx is still
        # closed over then you're stuffed...
        my $ctx = $ctx_closed_over;
        undef $ctx_closed_over;

        return ($res, $ctx);
    };
}

my $build_exports = sub {
    my ($self, $meth, $args, $defaults) = @_;
    my $class = $args->{class};

    my $request = $self->_build_request_export({
            class  => $class,
            remote => $ENV{CATALYST_SERVER},
    });

    my $get = $self->_build_get_export({ request => $request });

    my $ctx_request = $self->_build_ctx_request_export({
            class   => $class,
            request => $request,
    });

    return {
            request         => $request,
            get             => $get,
            ctx_request     => $ctx_request,
            content_like    => sub {
                my $action = shift;
                return Test::More->builder->like($get->($action), @_);
            },
            action_ok       => sub {
                my $action = shift;
                my $meth = $request->($action)->request->method;
                my @args = @_ ? @_ : ("$meth $action returns successfully");
                return Test::More->builder->ok($request->($action)->is_success, @args);
            },
            action_redirect => sub {
                my $action = shift;
                my $meth = $request->($action)->request->method;
                my @args = @_ ? @_ : ("$meth $action returns a redirect");
                return Test::More->builder->ok($request->($action)->is_redirect, @args);
            },
            action_notfound => sub {
                my $action = shift;
                my $meth = $request->($action)->request->method;
                my @args = @_ ? @_ : ("$meth $action returns a 404");
                return Test::More->builder->is_eq($request->($action)->code, 404, @args);
            },
            contenttype_is  => sub {
                my $action = shift;
                my $res = $request->($action);
                return Test::More->builder->is_eq(scalar($res->content_type), @_);
            },
    };
};

our $default_host;

{
    my $import = Sub::Exporter::build_exporter({
            groups     => [ all => $build_exports ],
            into_level => 1,
    });

    sub import {
        my ($self, $class, $opts) = @_;
        Carp::carp(
                qq{Importing Catalyst::Test without an application name is deprecated:\n
Instead of saying: use Catalyst::Test;
say: use Catalyst::Test (); # If you don't want to import a test app right now.
or say: use Catalyst::Test 'MyApp'; # If you do want to import a test app.\n\n})
                unless $class;
        $import->($self, '-all' => { class => $class });
        $opts = {} unless ref $opts eq 'HASH';
        $default_host = $opts->{default_host} if exists $opts->{default_host};
        return 1;
    }
}

=head1 NAME

Catalyst::Test - Test Catalyst Applications

=head1 SYNOPSIS

    # Helper
    script/test.pl

    # Tests
    use Catalyst::Test 'TestApp';
    my $content  = get('index.html');           # Content as string
    my $response = request('index.html');       # HTTP::Response object
    my($res, $c) = ctx_request('index.html');      # HTTP::Response & context object

    use HTTP::Request::Common;
    my $response = request POST '/foo', [
        bar => 'baz',
        something => 'else'
    ];

    # Run tests against a remote server
    CATALYST_SERVER='http://localhost:3000/' prove -r -l lib/ t/

    use Catalyst::Test 'TestApp';
    use Test::More tests => 1;

    ok( get('/foo') =~ /bar/ );

    # mock virtual hosts
    use Catalyst::Test 'MyApp', { default_host => 'myapp.com' };
    like( get('/whichhost'), qr/served by myapp.com/ );
    like( get( '/whichhost', { host => 'yourapp.com' } ), qr/served by yourapp.com/ );
    {
        local $Catalyst::Test::default_host = 'otherapp.com';
        like( get('/whichhost'), qr/served by otherapp.com/ );
    }

=head1 DESCRIPTION

This module allows you to make requests to a Catalyst application either without
a server, by simulating the environment of an HTTP request using
L<HTTP::Request::AsCGI> or remotely if you define the CATALYST_SERVER
environment variable. This module also adds a few Catalyst-specific
testing methods as displayed in the method section.

The L<get|/"$content = get( ... )"> and L<request|/"$res = request( ... );">
functions take either a URI or an L<HTTP::Request> object.

=head1 INLINE TESTS WILL NO LONGER WORK

While it used to be possible to inline a whole test app into a C<.t> file for
a distribution, this will no longer work.

The convention is to place your L<Catalyst> test apps into C<t/lib> in your
distribution. E.g.: C<t/lib/TestApp.pm>, C<t/lib/TestApp/Controller/Root.pm>,
etc..  Multiple test apps can be used in this way.

Then write your C<.t> files like so:

    use strict;
    use warnings;
    use FindBin '$Bin';
    use lib "$Bin/lib";
    use Test::More tests => 6;
    use Catalyst::Test 'TestApp';

=head1 METHODS

=head2 $content = get( ... )

Returns the content.

    my $content = get('foo/bar?test=1');

Note that this method doesn't follow redirects, so to test for a
correctly redirecting page you'll need to use a combination of this
method and the L<request|/"$res = request( ... );"> method below:

    my $res = request('/'); # redirects to /y
    warn $res->header('location');
    use URI;
    my $uri = URI->new($res->header('location'));
    is ( $uri->path , '/y');
    my $content = get($uri->path);

Note also that the content is returned as raw bytes, without any attempt
to decode it into characters.

=head2 $res = request( ... );

Returns an L<HTTP::Response> object. Accepts an optional hashref for request
header configuration; currently only supports setting 'host' value.

    my $res = request('foo/bar?test=1');
    my $virtual_res = request('foo/bar?test=1', {host => 'virtualhost.com'});

Alternately, you can pass in an L<HTTP::Request::Common> object to set arbitrary
request headers.

    my $res = request(GET '/foo/bar',
        X-Foo => 'Bar',
        Authorization => 'Bearer JWT_HERE',
        ...
    );

=head2 ($res, $c) = ctx_request( ... );

Works exactly like L<request|/"$res = request( ... );">, except it also returns the Catalyst context object,
C<$c>. Note that this only works for local requests.

=cut

sub _request {
    my $args = shift;

    my $request = Catalyst::Utils::request(shift);

    my %extra_env;
    _customize_request($request, \%extra_env, @_);
    $args->{mangle_request}->($request) if $args->{mangle_request};

    my $ret;
    test_psgi
            %{$args},
            app    => sub {$args->{app}->({ %{$_[0]}, %extra_env })},
            client => sub {
                my ($psgi_app) = @_;
                my $resp = $psgi_app->($request);
                $args->{mangle_response}->($resp) if $args->{mangle_response};
                $ret = $resp;
            };

    return $ret;
}

sub _local_request {
    my $class = shift;

    return _request({
            app             => ref($class) eq "CODE" ? $class : $class->_finalized_psgi_app,
            mangle_response => sub {
                my ($resp) = @_;

                # HTML head parsing based on LWP::UserAgent
                #
                # This is because if you make a remote request with LWP, then the
                # <BASE HREF="..."> from the returned HTML document will be used
                # to fill in $res->base, as documented in HTTP::Response. We need
                # to support this in local test requests so that they work 'the same'.
                #
                # This is not just horrible and possibly broken, but also really
                # doesn't belong here. Whoever wants this should be working on
                # getting it into Plack::Test, or make a middleware out of it, or
                # whatever. Seriously - horrible.

                if (!$resp->content_type || $resp->content_is_html) {
                    require HTML::HeadParser;

                    my $parser = HTML::HeadParser->new();
                    $parser->xml_mode(1) if $resp->content_is_xhtml;
                    $parser->utf8_mode(1) if $] >= 5.008 && $HTML::Parser::VERSION >= 3.40;

                    $parser->parse($resp->content);
                    my $h = $parser->header;
                    for my $f ($h->header_field_names) {
                        $resp->init_header($f, [ $h->header($f) ]);
                    }
                }
                # Another horrible hack to make the response headers have a
                # 'status' field. This is for back-compat, but you should
                # call $resp->code instead!
                $resp->init_header('status', [ $resp->code ]);
            },
    }, @_);
}

my $agent;

sub _remote_request {
    require LWP::UserAgent;
    local $Plack::Test::Impl = 'ExternalServer';

    unless ($agent) {
        $agent = LWP::UserAgent->new(
                keep_alive            => 1,
                max_redirect          => 0,
                timeout               => 60,

                # work around newer LWP max_redirect 0 bug
                # http://rt.cpan.org/Ticket/Display.html?id=40260
                requests_redirectable => [],
        );

        $agent->env_proxy;
    }

    my $server = URI->new($ENV{CATALYST_SERVER});
    if ($server->path =~ m|^(.+)?/$|) {
        my $path = $1;
        $server->path("$path") if $path; # need to be quoted
    }

    return _request({
            ua             => $agent,
            uri            => $server,
            mangle_request => sub {
                my ($request) = @_;

                # the request path needs to be sanitised if $server is using a
                # non-root path due to potential overlap between request path and
                # response path.
                if ($server->path) {
                    # If request path is '/', we have to add a trailing slash to the
                    # final request URI
                    my $add_trailing = ($request->uri->path eq '/' || $request->uri->path eq '') ? 1 : 0;

                    my @sp = split '/', $server->path;
                    my @rp = split '/', $request->uri->path;
                    shift @sp;
                    shift @rp; # leading /
                    if (@rp) {
                        foreach my $sp (@sp) {
                            $sp eq $rp[0] ? shift @rp : last
                        }
                    }
                    $request->uri->path(join '/', @rp);

                    if ($add_trailing) {
                        $request->uri->path($request->uri->path . '/');
                    }
                }
            },
    }, @_);
}

for my $name (qw(local_request remote_request)) {
    my $fun = sub {
        carp <<"EOW";
Calling Catalyst::Test::${name}() directly is deprecated.

Please import Catalyst::Test into your namespace and use the provided request()
function instead.
EOW
        return __PACKAGE__->can("_${name}")->(@_);
    };

    no strict 'refs';
    *$name = $fun;
}

sub _customize_request {
    my $request = shift;
    my $extra_env = shift;
    my $opts = pop(@_) || {};
    $opts = {} unless ref($opts) eq 'HASH';
    if (my $host = exists $opts->{host} ? $opts->{host} : $default_host) {
        $request->header('Host' => $host);
    }

    if (my $extra = $opts->{extra_env}) {
        @{$extra_env}{keys %{$extra}} = values %{$extra};
    }
}

=head2 action_ok($url [, $test_name ])

Fetches the given URL and checks that the request was successful. An optional
second argument can be given to specify the name of the test.

=head2 action_redirect($url [, $test_name ])

Fetches the given URL and checks that the request was a redirect. An optional
second argument can be given to specify the name of the test.

=head2 action_notfound($url [, $test_name ])

Fetches the given URL and checks that the request was not found. An optional
second argument can be given to specify the name of the test.

=head2 content_like( $url, $regexp [, $test_name ] )

Fetches the given URL and returns whether the content matches the regexp. An
optional third argument can be given to specify the name of the test.

=head2 contenttype_is($url, $type [, $test_name ])

Verify the given URL has a content type of $type and optionally specify a test name.

=head1 SEE ALSO

L<Catalyst>, L<Test::WWW::Mechanize::Catalyst>,
L<Test::WWW::Selenium::Catalyst>, L<Test::More>, L<HTTP::Request::Common>

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=begin Pod::Coverage

local_request

remote_request

=end Pod::Coverage

=cut

1;
package Catalyst::ActionContainer;

=head1 NAME

Catalyst::ActionContainer - Catalyst Action Container

=head1 SYNOPSIS

See L<Catalyst>.

=head1 DESCRIPTION

This is a container for actions. The dispatcher sets up a tree of these
to represent the various dispatch points in your application.

=cut

use Moose;
with 'MooseX::Emulate::Class::Accessor::Fast';

has part => (is => 'rw', required => 1);
has actions => (is => 'rw', required => 1, lazy => 1, default => sub {{}});

around BUILDARGS => sub {
    my ($next, $self, @args) = @_;
    unshift @args, 'part' if scalar @args == 1 && !ref $args[0];
    return $self->$next(@args);
};

no Moose;

use overload (
        # Stringify to path part for tree search
        q{""} => sub {shift->part},
);

sub get_action {
    my ($self, $name) = @_;
    return $self->actions->{$name} if defined $self->actions->{$name};
    return;
}

sub add_action {
    my ($self, $action, $name) = @_;
    $name ||= $action->name;
    $self->actions->{$name} = $action;
}

__PACKAGE__->meta->make_immutable;

1;

package Catalyst::Component;

use Moose;
use Class::MOP;
use Class::MOP::Object;
use Catalyst::Utils;
use Class::C3::Adopt::NEXT;
use Devel::InnerPackage ();
use MRO::Compat;
use mro 'c3';
use Scalar::Util 'blessed';
use Class::Load 'is_class_loaded';
use Moose::Util 'find_meta';
use namespace::clean -except => 'meta';

with 'MooseX::Emulate::Class::Accessor::Fast';
with 'Catalyst::ClassData';


=head1 NAME

Catalyst::Component - Catalyst Component Base Class

=head1 SYNOPSIS

    # lib/MyApp/Model/Something.pm
    package MyApp::Model::Something;

    use base 'Catalyst::Component';

    __PACKAGE__->config( foo => 'bar' );

    has foo => (
        is => 'ro',
    );

    sub test {
        my $self = shift;
        return $self->foo;
    }

    sub forward_to_me {
        my ( $self, $c ) = @_;
        $c->response->output( $self->foo );
    }

    1;

    # Methods can be a request step
    $c->forward(qw/MyApp::Model::Something forward_to_me/);

    # Or just methods
    print $c->comp('MyApp::Model::Something')->test;

    print $c->comp('MyApp::Model::Something')->foo;

=head1 DESCRIPTION

This is the universal base class for Catalyst components
(Model/View/Controller).

It provides you with a generic new() for component construction through Catalyst's
component loader with config() support and a process() method placeholder.

B<Note> that calling C<< $self->config >> inside a component is strongly
not recommended - the correctly merged config should have already been
passed to the constructor and stored in attributes - accessing
the config accessor directly from an instance is likely to get the
wrong values (as it only holds the class wide config, not things loaded
from the config file!)

=cut

__PACKAGE__->mk_classdata('_plugins');
__PACKAGE__->mk_classdata('_config');

has catalyst_component_name => (is => 'ro'); # Cannot be required => 1 as context
# class @ISA component - HATE
# Make accessor callable as a class method, as we need to call setup_actions
# on the application class, which we don't have an instance of, ewwwww
# Also, naughty modules like Catalyst::View::JSON try to write to _everything_,
# so spit a warning, ignore that (and try to do the right thing anyway) here..
around catalyst_component_name => sub {
    my ($orig, $self) = (shift, shift);
    Carp::cluck("Tried to write to the catalyst_component_name accessor - is your component broken or just mad? (Write ignored - using default value.)") if scalar @_;
    blessed($self) ? $self->$orig() || blessed($self) : $self;
};

sub BUILDARGS {
    my $class = shift;
    my $args = {};

    if (@_ == 1) {
        $args = $_[0] if ref($_[0]) eq 'HASH';
    }
    elsif (@_ == 2) { # is it ($app, $args) or foo => 'bar' ?
        if (blessed($_[0])) {
            $args = $_[1] if ref($_[1]) eq 'HASH';
        }
        elsif (is_class_loaded($_[0]) &&
                $_[0]->isa('Catalyst') && ref($_[1]) eq 'HASH') {
            $args = $_[1];
        }
        else {
            $args = +{ @_ };
        }
    }
    elsif (@_ % 2 == 0) {
        $args = +{ @_ };
    }

    return $class->merge_config_hashes($class->config, $args);
}

sub COMPONENT {
    my ($class, $c) = @_;

    # Temporary fix, some components does not pass context to constructor
    my $arguments = (ref($_[-1]) eq 'HASH') ? $_[-1] : {};
    if (my $next = $class->next::can) {
        my ($next_package) = Class::MOP::get_code_info($next);
        warn "There is a COMPONENT method resolving after Catalyst::Component in ${next_package}.\n";
        warn "This behavior can no longer be supported, and so your application is probably broken.\n";
        warn "Your linearized isa hierarchy is: " . join(', ', @{mro::get_linear_isa($class)}) . "\n";
        warn "Please see perldoc Catalyst::Upgrading for more information about this issue.\n";
    }
    return $class->new($c, $arguments);
}

sub config {
    my $self = shift;
    # Uncomment once sane to do so
    #Carp::cluck("config method called on instance") if ref $self;
    my $config = $self->_config || {};
    if (@_) {
        my $newconfig = { %{@_ > 1 ? { @_ } : $_[0]} };
        $self->_config(
                $self->merge_config_hashes($config, $newconfig)
        );
    }
    else {
        # this is a bit of a kludge, required to make
        # __PACKAGE__->config->{foo} = 'bar';
        # work in a subclass.
        # TODO maybe this should be a ClassData option?
        my $class = blessed($self) || $self;
        my $meta = find_meta($class);
        unless (${$meta->get_or_add_package_symbol('$_config')}) {
            # Call merge_hashes to ensure we deep copy the parent
            # config onto the subclass
            $self->_config(Catalyst::Utils::merge_hashes($config, {}));
        }
    }
    return $self->_config;
}

sub merge_config_hashes {
    my ($self, $lefthash, $righthash) = @_;

    return Catalyst::Utils::merge_hashes($lefthash, $righthash);
}

sub process {

    Catalyst::Exception->throw(message => (ref $_[0] || $_[0])
            . " did not override Catalyst::Component::process");
}

sub expand_modules {
    my ($class, $component) = @_;
    return Devel::InnerPackage::list_packages($component);
}

__PACKAGE__->meta->make_immutable;

1;

package Catalyst::EngineLoader;
use Moose;
use Catalyst::Exception;
use Catalyst::Utils;
use namespace::clean -except => [ 'meta' ];

extends 'Plack::Loader';

has application_name => (
        isa      => 'Str',
        is       => 'ro',
        required => 1,
);

has requested_engine => (
        is        => 'ro',
        isa       => 'Str',
        predicate => 'has_requested_engine',
);

sub needs_psgi_engine_compat_hack {
    my ($self) = @_;
    return $self->has_requested_engine
            && $self->requested_engine eq 'PSGI';
}

has catalyst_engine_class => (
        isa     => 'Str',
        is      => 'rw',
        lazy    => 1,
        builder => '_guess_catalyst_engine_class',
);

sub _guess_catalyst_engine_class {
    my $self = shift;
    my $old_engine = $self->has_requested_engine
            ? $self->requested_engine
            : Catalyst::Utils::env_value($self->application_name, 'ENGINE');
    if (!defined $old_engine) {
        return 'Catalyst::Engine';
    }
    elsif ($old_engine eq 'PSGI') {
        ## If we are running under plackup let the Catalyst::Engine::PSGI
        ## continue to run, but warn.
        warn <<"EOW";
You are running Catalyst::Engine::PSGI, which is considered a legacy engine for
this version of Catalyst.  We will continue running and use your existing psgi
file, but it is recommended to perform the trivial upgrade process, which will
leave you with less code and a forward path.

Please review Catalyst::Upgrading
EOW
        return 'Catalyst::Engine::' . $old_engine;
    }
    elsif ($old_engine =~ /^(CGI|FastCGI|HTTP|Apache.*)$/) {
        return 'Catalyst::Engine';
    }
    else {
        return 'Catalyst::Engine::' . $old_engine;
    }
}

around guess => sub {
    my ($orig, $self) = (shift, shift);
    my $engine = $self->$orig(@_);
    if ($ENV{MOD_PERL}) {
        my ($software, $version) =
                $ENV{MOD_PERL} =~ /^(\S+)\/(\d+(?:[\.\_]\d+)+)/;
        $version =~ s/_//g;
        $version =~ s/(\.[^.]+)\./$1/g;

        if ($software eq 'mod_perl') {
            if ($version >= 1.99922) {
                $engine = 'Apache2';
            }
            elsif ($version >= 1.9901) {
                Catalyst::Exception->throw(message => 'Plack does not have a mod_perl 1.99 handler');
                $engine = 'Apache2::MP19';
            }
            elsif ($version >= 1.24) {
                $engine = 'Apache1';
            }
            else {
                Catalyst::Exception->throw(message =>
                        qq/Unsupported mod_perl version: $ENV{MOD_PERL}/);
            }
        }
    }

    my $old_engine = Catalyst::Utils::env_value($self->application_name, 'ENGINE');
    if (!defined $old_engine) { # Not overridden
    }
    elsif ($old_engine =~ /^(PSGI|CGI|Apache.*)$/) {
        # Trust autodetect
    }
    elsif ($old_engine eq 'HTTP') {
        $engine = 'Standalone';
    }
    elsif ($old_engine eq 'FastCGI') {
        $engine = 'FCGI';
    }
    elsif ($old_engine eq "HTTP::Prefork") { # Too bad if you're customising, we don't handle options
        # write yourself a script to collect and pass in the options
        $engine = "Starman";
    }
    elsif ($old_engine eq "HTTP::POE") {
        Catalyst::Exception->throw("HTTP::POE engine no longer works, recommend you use Twiggy instead");
    }
    elsif ($old_engine eq "Zeus") {
        Catalyst::Exception->throw("Zeus engine no longer works");
    }
    else {
        warn("You asked for an unrecognised engine '$old_engine' which is no longer supported, this has been ignored.\n");
    }

    return $engine;
};

# Force constructor inlining
__PACKAGE__->meta->make_immutable(replace_constructor => 1);

1;

package Catalyst::Plugin::Unicode::Encoding;
use strict;
use warnings;

our $VERSION = '5.90130';
$VERSION =~ tr/_//d;

1;

=head1 NAME

Catalyst::Plugin::Unicode::Encoding - Unicode aware Catalyst

=head1 DESCRIPTION

This plugin has been merged into core.  This package only exists to clean out
any existing versions on your installed system.

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
package Catalyst::Model;

use Moose;
extends qw/Catalyst::Component/;

no Moose;

=head1 NAME

Catalyst::Model - Catalyst Model base class

=head1 SYNOPSIS

See L<Catalyst>.

=head1 DESCRIPTION

Catalyst Model base class.

=head1 METHODS

Implements the same methods as other Catalyst components, see
L<Catalyst::Component>

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

__PACKAGE__->meta->make_immutable;

1;
package # Hide from PAUSE
Catalyst::Engine::HTTP;
use strict;
use warnings;

use base 'Catalyst::Engine';

warn("You are loading Catalyst::Engine::HTTP explicitly.

This is almost certainly a bad idea, as Catalyst::Engine::HTTP
has been removed in this version of Catalyst.

Please update your application's scripts with:

  catalyst.pl -force -scripts MyApp

to update your scripts to not do this.\n") unless $ENV{HARNESS_ACTIVE};

1;

package Catalyst::ClassData;

use Moose::Role;
use Moose::Meta::Class ();
use Class::MOP;
use Moose::Util ();

sub mk_classdata {
    my ($class, $attribute, $warn_on_instance) = @_;
    confess("mk_classdata() is a class method, not an object method")
            if blessed $class;

    my $slot = '$' . $attribute;
    my $accessor = sub {
        my $pkg = ref $_[0] || $_[0];
        my $meta = Moose::Util::find_meta($pkg)
                || Moose::Meta::Class->initialize($pkg);
        if (@_ > 1) {
            $meta->namespace->{$attribute} = \$_[1];
            return $_[1];
        }

        # tighter version of
        # if ( $meta->has_package_symbol($slot) ) {
        #   return ${ $meta->get_package_symbol($slot) };
        # }
        no strict 'refs';
        my $v = *{"${pkg}::${attribute}"}{SCALAR};
        if (defined ${$v}) {
            return ${$v};
        }
        else {
            foreach my $super ($meta->linearized_isa) {
                # tighter version of same after
                # my $super_meta = Moose::Meta::Class->initialize($super);
                my $v = ${"${super}::"}{$attribute} ? *{"${super}::${attribute}"}{SCALAR} : undef;
                if (defined ${$v}) {
                    return ${$v};
                }
            }
        }
        return;
    };

    confess("Failed to create accessor: $@ ")
            unless ref $accessor eq 'CODE';

    my $meta = $class->Class::MOP::Object::meta();
    confess "${class}'s metaclass is not a Class::MOP::Class"
            unless $meta->isa('Class::MOP::Class');

    my $was_immutable = $meta->is_immutable;
    my %immutable_options = $meta->immutable_options;

    $meta->make_mutable if $was_immutable;

    my $alias = "_${attribute}_accessor";
    $meta->add_method($alias, $accessor);
    $meta->add_method($attribute, $accessor);

    $meta->make_immutable(%immutable_options) if $was_immutable;

    $class->$attribute($_[2]) if (@_ > 2);
    return $accessor;
}

1;

package Catalyst::Engine;

use Moose;
with 'MooseX::Emulate::Class::Accessor::Fast';

use CGI::Simple::Cookie;
use Data::Dump qw/dump/;
use Errno 'EWOULDBLOCK';
use HTML::Entities;
use HTTP::Headers;
use Plack::Loader;
use Catalyst::EngineLoader;
use Encode 2.21 'decode_utf8', 'encode', 'decode';
use Plack::Request::Upload;
use Hash::MultiValue;
use namespace::clean -except => 'meta';
use utf8;

# Amount of data to read from input on each pass
our $CHUNKSIZE = 64 * 1024;

# XXX - this is only here for compat, do not use!
has env => (is => 'rw', writer => '_set_env', weak_ref => 1);
my $WARN_ABOUT_ENV = 0;
around env => sub {
    my ($orig, $self, @args) = @_;
    if (@args) {
        warn "env as a writer is deprecated, you probably need to upgrade Catalyst::Engine::PSGI"
                unless $WARN_ABOUT_ENV++;
        return $self->_set_env(@args);
    }
    return $self->$orig;
};

# XXX - Only here for Engine::PSGI compat
sub prepare_connection {
    my ($self, $ctx) = @_;
    $ctx->request->prepare_connection;
}

=head1 NAME

Catalyst::Engine - The Catalyst Engine

=head1 SYNOPSIS

See L<Catalyst>.

=head1 DESCRIPTION

=head1 METHODS


=head2 $self->finalize_body($c)

Finalize body.  Prints the response output as blocking stream if it looks like
a filehandle, otherwise write it out all in one go.  If there is no body in
the response, we assume you are handling it 'manually', such as for nonblocking
style or asynchronous streaming responses.  You do this by calling L</write>
several times (which sends HTTP headers if needed) or you close over
C<< $response->write_fh >>.

See L<Catalyst::Response/write> and L<Catalyst::Response/write_fh> for more.

=cut

sub finalize_body {
    my ($self, $c) = @_;
    my $res = $c->response; # We use this all over

    ## If we've asked for the write 'filehandle' that means the application is
    ## doing something custom and is expected to close the response
    return if $res->_has_write_fh;

    my $body = $res->body; # save some typing
    if ($res->_has_response_cb) {
        ## we have not called the response callback yet, so we are safe to send
        ## the whole body to PSGI

        my @headers;
        $res->headers->scan(sub {push @headers, @_});

        # We need to figure out what kind of body we have and normalize it to something
        # PSGI can deal with
        if (defined $body) {
            # Handle objects first
            if (blessed($body)) {
                if ($body->can('getline')) {
                    # Body is an IO handle that meets the PSGI spec.  Nothing to normalize
                }
                elsif ($body->can('read')) {

                    # In the past, Catalyst only looked for ->read not ->getline.  It is very possible
                    # that one might have an object that respected read but did not have getline.
                    # As a result, we need to handle this case for backcompat.

                    # We will just do the old loop for now.  In a future version of Catalyst this support
                    # will be removed and one will have to rewrite their custom object or use
                    # Plack::Middleware::AdaptFilehandleRead.  In anycase support for this is officially
                    # deprecated and described as such as of 5.90060

                    my $got;
                    do {
                        $got = read $body, my ($buffer), $CHUNKSIZE;
                        $got = 0 unless $self->write($c, $buffer);
                    } while $got > 0;

                    close $body;
                    return;
                }
                else {
                    # Looks like for  backcompat reasons we need to be able to deal
                    # with stringyfiable objects.
                    $body = [ "$body" ];
                }
            }
            elsif (ref $body) {
                if ((ref($body) eq 'GLOB') or (ref($body) eq 'ARRAY')) {
                    # Again, PSGI can just accept this, no transform needed.  We don't officially
                    # document the body as arrayref at this time (and there's not specific test
                    # cases.  we support it because it simplifies some plack compatibility logic
                    # and we might make it official at some point.
                }
                else {
                    $c->log->error("${\ref($body)} is not a valid value for Response->body");
                    return;
                }
            }
            else {
                # Body is defined and not an object or reference.  We assume a simple value
                # and wrap it in an array for PSGI
                $body = [ $body ];
            }
        }
        else {
            # There's no body...
            $body = [];
        }
        $res->_response_cb->([ $res->status, \@headers, $body ]);
        $res->_clear_response_cb;

    }
    else {
        ## Now, if there's no response callback anymore, that means someone has
        ## called ->write in order to stream 'some stuff along the way'.  I think
        ## for backcompat we still need to handle a ->body.  I guess I could see
        ## someone calling ->write to presend some stuff, and then doing the rest
        ## via ->body, like in a template.

        ## We'll just use the old, existing code for this (or most of it)

        if (my $body = $res->body) {

            if (blessed($body) && $body->can('read') or ref($body) eq 'GLOB') {

                ## In this case we have no choice and will fall back on the old
                ## manual streaming stuff.  Not optimal.  This is deprecated as of 5.900560+

                my $got;
                do {
                    $got = read $body, my ($buffer), $CHUNKSIZE;
                    $got = 0 unless $self->write($c, $buffer);
                } while $got > 0;

                close $body;
            }
            else {

                # Case where body was set after calling ->write.  We'd prefer not to
                # support this, but I can see some use cases with the way most of the
                # views work. Since body has already been encoded, we need to do
                # an 'unencoded_write' here.
                $self->unencoded_write($c, $body);
            }
        }

        $res->_writer->close;
        $res->_clear_writer;
    }

    return;
}

=head2 $self->finalize_cookies($c)

Create CGI::Simple::Cookie objects from $c->res->cookies, and set them as
response headers.

=cut

sub finalize_cookies {
    my ($self, $c) = @_;

    my @cookies;
    my $response = $c->response;

    foreach my $name (keys %{$response->cookies}) {

        my $val = $response->cookies->{$name};

        my $cookie = (
                blessed($val)
                        ? $val
                        : CGI::Simple::Cookie->new(
                        -name     => $name,
                        -value    => $val->{value},
                        -expires  => $val->{expires},
                        -domain   => $val->{domain},
                        -path     => $val->{path},
                        -secure   => $val->{secure} || 0,
                        -httponly => $val->{httponly} || 0,
                        -samesite => $val->{samesite},
                )
        );
        if (!defined $cookie) {
            $c->log->warn("undef passed in '$name' cookie value - not setting cookie")
                    if $c->debug;
            next;
        }

        push @cookies, $cookie->as_string;
    }

    for my $cookie (@cookies) {
        $response->headers->push_header('Set-Cookie' => $cookie);
    }
}

=head2 $self->finalize_error($c)

Output an appropriate error message. Called if there's an error in $c
after the dispatch has finished. Will output debug messages if Catalyst
is in debug mode, or a `please come back later` message otherwise.

=cut

sub _dump_error_page_element {
    my ($self, $i, $element) = @_;
    my ($name, $val) = @{$element};

    # This is fugly, but the metaclass is _HUGE_ and demands waaay too much
    # scrolling. Suggestions for more pleasant ways to do this welcome.
    local $val->{'__MOP__'} = "Stringified: "
            . $val->{'__MOP__'} if ref $val eq 'HASH' && exists $val->{'__MOP__'};

    my $text = encode_entities(dump($val));
    sprintf <<"EOF", $name, $text;
<h2><a href="#" onclick="toggleDump('dump_$i'); return false">%s</a></h2>
<div id="dump_$i">
    <pre wrap="">%s</pre>
</div>
EOF
}

sub finalize_error {
    my ($self, $c) = @_;

    $c->res->content_type('text/html; charset=utf-8');
    my $name = ref($c)->config->{name} || join(' ', split('::', ref $c));

    # Prevent Catalyst::Plugin::Unicode::Encoding from running.
    # This is a little nasty, but it's the best way to be clean whether or
    # not the user has an encoding plugin.

    if ($c->can('encoding')) {
        $c->{encoding} = '';
    }

    my ($title, $error, $infos);
    if ($c->debug) {

        # For pretty dumps
        $error = join '', map {
            '<p><code class="error">'
                    . encode_entities($_)
                    . '</code></p>'
        } @{$c->error};
        $error ||= 'No output';
        $error = qq{<pre wrap="">$error</pre>};
        $title = $name = "$name on Catalyst $Catalyst::VERSION";
        $name = "<h1>$name</h1>";

        # Don't show context in the dump
        $c->res->_clear_context;

        # Don't show body parser in the dump
        $c->req->_clear_body;

        my @infos;
        my $i = 0;
        for my $dump ($c->dump_these) {
            push @infos, $self->_dump_error_page_element($i, $dump);
            $i++;
        }
        $infos = join "\n", @infos;
    }
    else {
        $title = $name;
        $error = '';
        $infos = <<"";
<pre>
(en) Please come back later
(fr) SVP veuillez revenir plus tard
(de) Bitte versuchen sie es spaeter nocheinmal
(at) Konnten's bitt'schoen spaeter nochmal reinschauen
(no) Vennligst prov igjen senere
(dk) Venligst prov igen senere
(pl) Prosze sprobowac pozniej
(pt) Por favor volte mais tarde
(ru) Попробуйте еще раз позже
(ua) Спробуйте ще раз пізніше
(it) Per favore riprova più tardi
</pre>

        $name = '';
    }
    $c->res->body(<<"");
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Language" content="en" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>$title</title>
    <script type="text/javascript">
        <!--
        function toggleDump (dumpElement) {
            var e = document.getElementById( dumpElement );
            if (e.style.display == "none") {
                e.style.display = "";
            }
            else {
                e.style.display = "none";
            }
        }
        -->
    </script>
    <style type="text/css">
        body {
            font-family: "Bitstream Vera Sans", "Trebuchet MS", Verdana,
                         Tahoma, Arial, helvetica, sans-serif;
            color: #333;
            background-color: #eee;
            margin: 0px;
            padding: 0px;
        }
        :link, :link:hover, :visited, :visited:hover {
            color: #000;
        }
        div.box {
            position: relative;
            background-color: #ccc;
            border: 1px solid #aaa;
            padding: 4px;
            margin: 10px;
        }
        div.error {
            background-color: #cce;
            border: 1px solid #755;
            padding: 8px;
            margin: 4px;
            margin-bottom: 10px;
        }
        div.infos {
            background-color: #eee;
            border: 1px solid #575;
            padding: 8px;
            margin: 4px;
            margin-bottom: 10px;
        }
        div.name {
            background-color: #cce;
            border: 1px solid #557;
            padding: 8px;
            margin: 4px;
        }
        code.error {
            display: block;
            margin: 1em 0;
            overflow: auto;
        }
        div.name h1, div.error p {
            margin: 0;
        }
        h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: medium;
            font-weight: bold;
            text-decoration: underline;
        }
        h1 {
            font-size: medium;
            font-weight: normal;
        }
        /* from http://users.tkk.fi/~tkarvine/linux/doc/pre-wrap/pre-wrap-css3-mozilla-opera-ie.html */
        /* Browser specific (not valid) styles to make preformatted text wrap */
        pre {
            white-space: pre-wrap;       /* css-3 */
            white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
            white-space: -pre-wrap;      /* Opera 4-6 */
            white-space: -o-pre-wrap;    /* Opera 7 */
            word-wrap: break-word;       /* Internet Explorer 5.5+ */
        }
    </style>
</head>
<body>
    <div class="box">
        <div class="error">$error</div>
        <div class="infos">$infos</div>
        <div class="name">$name</div>
    </div>
</body>
</html>

 # Trick IE. Old versions of IE would display their own error page instead
    # of ours if we'd give it less than 512 bytes.
    $c->res->{body} .= (' ' x 512);

    $c->res->{body} = Encode::encode("UTF-8", $c->res->{body});

    # Return 500
    $c->res->status(500);
}

=head2 $self->finalize_headers($c)

Allows engines to write headers to response

=cut

sub finalize_headers {
    my ($self, $ctx) = @_;

    $ctx->finalize_headers unless $ctx->response->finalized_headers;
    return;
}

=head2 $self->finalize_uploads($c)

Clean up after uploads, deleting temp files.

=cut

sub finalize_uploads {
    my ($self, $c) = @_;

    # N.B. This code is theoretically entirely unneeded due to ->cleanup(1)
    #      on the HTTP::Body object.
    my $request = $c->request;
    foreach my $key (keys %{$request->uploads}) {
        my $upload = $request->uploads->{$key};
        unlink grep {-e $_} map {$_->tempname}
                (ref $upload eq 'ARRAY' ? @{$upload} : ($upload));
    }

}

=head2 $self->prepare_body($c)

sets up the L<Catalyst::Request> object body using L<HTTP::Body>

=cut

sub prepare_body {
    my ($self, $c) = @_;

    $c->request->prepare_body;
}

=head2 $self->prepare_body_chunk($c)

Add a chunk to the request body.

=cut

# XXX - Can this be deleted?
sub prepare_body_chunk {
    my ($self, $c, $chunk) = @_;

    $c->request->prepare_body_chunk($chunk);
}

=head2 $self->prepare_body_parameters($c)

Sets up parameters from body.

=cut

sub prepare_body_parameters {
    my ($self, $c) = @_;

    $c->request->prepare_body_parameters;
}

=head2 $self->prepare_parameters($c)

Sets up parameters from query and post parameters.
If parameters have already been set up will clear
existing parameters and set up again.

=cut

sub prepare_parameters {
    my ($self, $c) = @_;

    $c->request->_clear_parameters;
    return $c->request->parameters;
}

=head2 $self->prepare_path($c)

abstract method, implemented by engines.

=cut

sub prepare_path {
    my ($self, $ctx) = @_;

    my $env = $ctx->request->env;

    my $scheme = $ctx->request->secure ? 'https' : 'http';
    my $host = $env->{HTTP_HOST} || $env->{SERVER_NAME};
    my $port = $env->{SERVER_PORT} || 80;
    my $base_path = $env->{SCRIPT_NAME} || "/";

    # set the request URI
    my $path;
    if (!$ctx->config->{use_request_uri_for_path}) {
        my $path_info = $env->{PATH_INFO};
        if (exists $env->{REDIRECT_URL}) {
            $base_path = $env->{REDIRECT_URL};
            $base_path =~ s/\Q$path_info\E$//;
        }
        $path = $base_path . $path_info;
        $path =~ s{^/+}{};
        $path =~ s/([^$URI::uric])/$URI::Escape::escapes{$1}/go;
        $path =~ s/\?/%3F/g; # STUPID STUPID SPECIAL CASE
    }
    else {
        my $req_uri = $env->{REQUEST_URI};
        $req_uri =~ s/\?.*$//;
        $path = $req_uri;
        $path =~ s{^/+}{};
    }

    # Using URI directly is way too slow, so we construct the URLs manually
    my $uri_class = "URI::$scheme";

    # HTTP_HOST will include the port even if it's 80/443
    $host =~ s/:(?:80|443)$//;

    if ($port !~ /^(?:80|443)$/ && $host !~ /:/) {
        $host .= ":$port";
    }

    my $query = $env->{QUERY_STRING} ? '?' . $env->{QUERY_STRING} : '';
    my $uri = $scheme . '://' . $host . '/' . $path . $query;

    $ctx->request->uri((bless \$uri, $uri_class)->canonical);

    # set the base URI
    # base must end in a slash
    $base_path .= '/' unless $base_path =~ m{/$};

    my $base_uri = $scheme . '://' . $host . $base_path;

    $ctx->request->base(bless \$base_uri, $uri_class);

    return;
}

=head2 $self->prepare_request($c)

=head2 $self->prepare_query_parameters($c)

process the query string and extract query parameters.

=cut

sub prepare_query_parameters {
    my ($self, $c) = @_;
    my $env = $c->request->env;
    my $do_not_decode_query = $c->config->{do_not_decode_query};

    my $old_encoding;
    if (my $new = $c->config->{default_query_encoding}) {
        $old_encoding = $c->encoding;
        $c->encoding($new);
    }

    my $check = $c->config->{do_not_check_query_encoding} ? undef : $c->_encode_check;
    my $decoder = sub {
        my $str = shift;
        return $str if $do_not_decode_query;
        return $c->_handle_param_unicode_decoding($str, $check);
    };

    my $query_string = exists $env->{QUERY_STRING}
            ? $env->{QUERY_STRING}
            : '';

    $query_string =~ s/\A[&;]+//;

    my @unsplit_pairs = split /[&;]+/, $query_string;
    my $p = Hash::MultiValue->new();

    my $is_first_pair = 1;
    for my $pair (@unsplit_pairs) {
        my ($name, $value)
                = map {defined $_ ? $decoder->($self->unescape_uri($_)) : $_}
                (split /=/, $pair, 2)[0, 1]; # slice forces two elements

        if ($is_first_pair) {
            # If the first pair has no equal sign, then it means the isindex
            # flag is set.
            $c->request->query_keywords($name) unless defined $value;

            $is_first_pair = 0;
        }

        $p->add($name => $value);
    }

    $c->encoding($old_encoding) if $old_encoding;
    $c->request->query_parameters($c->request->_use_hash_multivalue ? $p : $p->mixed);
}

=head2 $self->prepare_read($c)

Prepare to read by initializing the Content-Length from headers.

=cut

sub prepare_read {
    my ($self, $c) = @_;

    # Initialize the amount of data we think we need to read
    $c->request->_read_length;
}

=head2 $self->prepare_request(@arguments)

Populate the context object from the request object.

=cut

sub prepare_request {
    my ($self, $ctx, %args) = @_;
    $ctx->log->psgienv($args{env}) if $ctx->log->can('psgienv');
    $ctx->request->_set_env($args{env});
    $self->_set_env($args{env}); # Nasty back compat!
    $ctx->response->_set_response_cb($args{response_cb});
}

=head2 $self->prepare_uploads($c)

=cut

sub prepare_uploads {
    my ($self, $c) = @_;

    my $request = $c->request;
    return unless $request->_body;

    my $enc = $c->encoding;
    my $uploads = $request->_body->upload;
    my $parameters = $request->parameters;
    foreach my $name (keys %$uploads) {
        my $files = $uploads->{$name};
        $name = $c->_handle_unicode_decoding($name) if $enc;
        my @uploads;
        for my $upload (ref $files eq 'ARRAY' ? @$files : ($files)) {
            my $headers = HTTP::Headers->new(%{$upload->{headers}});
            my $filename = $upload->{filename};
            $filename = $c->_handle_unicode_decoding($filename) if $enc;

            my $u = Catalyst::Request::Upload->new
                    (
                            size     => $upload->{size},
                            type     => scalar $headers->content_type,
                            charset  => scalar $headers->content_type_charset,
                            headers  => $headers,
                            tempname => $upload->{tempname},
                            filename => $filename,
                    );
            push @uploads, $u;
        }
        $request->uploads->{$name} = @uploads > 1 ? \@uploads : $uploads[0];

        # support access to the filename as a normal param
        my @filenames = map {$_->{filename}} @uploads;
        # append, if there's already params with this name
        if (exists $parameters->{$name}) {
            if (ref $parameters->{$name} eq 'ARRAY') {
                push @{$parameters->{$name}}, @filenames;
            }
            else {
                $parameters->{$name} = [ $parameters->{$name}, @filenames ];
            }
        }
        else {
            $parameters->{$name} = @filenames > 1 ? \@filenames : $filenames[0];
        }
    }
}

=head2 $self->write($c, $buffer)

Writes the buffer to the client.

=cut

sub write {
    my ($self, $c, $buffer) = @_;

    $c->response->write($buffer);
}

=head2 $self->unencoded_write($c, $buffer)

Writes the buffer to the client without encoding. Necessary for
already encoded buffers. Used when a $c->write has been done
followed by $c->res->body.

=cut

sub unencoded_write {
    my ($self, $c, $buffer) = @_;

    $c->response->unencoded_write($buffer);
}

=head2 $self->read($c, [$maxlength])

Reads from the input stream by calling C<< $self->read_chunk >>.

Maintains the read_length and read_position counters as data is read.

=cut

sub read {
    my ($self, $c, $maxlength) = @_;

    $c->request->read($maxlength);
}

=head2 $self->read_chunk($c, \$buffer, $length)

Each engine implements read_chunk as its preferred way of reading a chunk
of data. Returns the number of bytes read. A return of 0 indicates that
there is no more data to be read.

=cut

sub read_chunk {
    my ($self, $ctx) = (shift, shift);
    return $ctx->request->read_chunk(@_);
}

=head2 $self->run($app, $server)

Start the engine. Builds a PSGI application and calls the
run method on the server passed in, which then causes the
engine to loop, handling requests..

=cut

sub run {
    my ($self, $app, $psgi, @args) = @_;
    # @args left here rather than just a $options, $server for back compat with the
    # old style scripts which send a few args, then a hashref

    # They should never actually be used in the normal case as the Plack engine is
    # passed in got all the 'standard' args via the loader in the script already.

    # FIXME - we should stash the options in an attribute so that custom args
    # like Gitalist's --git_dir are possible to get from the app without stupid tricks.
    my $server = pop @args if (scalar @args && blessed $args[-1]);
    my $options = pop @args if (scalar @args && ref($args[-1]) eq 'HASH');
    # Back compat hack for applications with old (non Catalyst::Script) scripts to work in FCGI.
    if (scalar @args && !ref($args[0])) {
        if (my $listen = shift @args) {
            $options->{listen} ||= [ $listen ];
        }
    }
    if (!$server) {
        $server = Catalyst::EngineLoader->new(application_name => ref($self))->auto(%$options);
        # We're not being called from a script, so auto detect what backend to
        # run on.  This should never happen, as mod_perl never calls ->run,
        # instead the $app->handle method is called per request.
        $app->log->warn("Not supplied a Plack engine, falling back to engine auto-loader (are your scripts ancient?)")
    }
    $app->run_options($options);
    $server->run($psgi, $options);
}

=head2 build_psgi_app ($app, @args)

Builds and returns a PSGI application closure. (Raw, not wrapped in middleware)

=cut

sub build_psgi_app {
    my ($self, $app, @args) = @_;

    return sub {
        my ($env) = @_;

        return sub {
            my ($respond) = @_;
            confess("Did not get a response callback for writer, cannot continue") unless $respond;
            $app->handle_request(env => $env, response_cb => $respond);
        };
    };
}

=head2 $self->unescape_uri($uri)

Unescapes a given URI using the most efficient method available.  Engines such
as Apache may implement this using Apache's C-based modules, for example.

=cut

sub unescape_uri {
    my ($self, $str) = @_;

    $str =~ s/(?:%([0-9A-Fa-f]{2})|\+)/defined $1 ? chr(hex($1)) : ' '/eg;

    return $str;
}

=head2 $self->finalize_output

<obsolete>, see finalize_body

=head2 $self->env

Hash containing environment variables including many special variables inserted
by WWW server - like SERVER_*, REMOTE_*, HTTP_* ...

Before accessing environment variables consider whether the same information is
not directly available via Catalyst objects $c->request, $c->engine ...

BEWARE: If you really need to access some environment variable from your Catalyst
application you should use $c->engine->env->{VARNAME} instead of $ENV{VARNAME},
as in some environments the %ENV hash does not contain what you would expect.

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

__PACKAGE__->meta->make_immutable;

1;
package Catalyst::Component::ContextClosure;

use Moose::Role;
use Scalar::Util 'weaken';
use namespace::clean -except => [ 'meta' ];

sub make_context_closure {
    my ($self, $closure, $ctx) = @_;
    weaken $ctx;
    return sub {$closure->($ctx, @_)};
}

1;

package Catalyst::Component::ApplicationAttribute;

use Moose::Role;
use namespace::clean -except => 'meta';

# Future - isa => 'ClassName|Catalyst' performance?
#           required => 1 breaks tests..
has _application => (is => 'ro', weak_ref => 1);
sub _app {(shift)->_application(@_)}

override BUILDARGS => sub {
    my ($self, $app) = @_;

    my $args = super();
    $args->{_application} = $app;

    return $args;
};

1;

package Catalyst::ScriptRole;
use Moose::Role;
use Pod::Usage;
use MooseX::Getopt;
use Catalyst::EngineLoader;
use Moose::Util::TypeConstraints;
use Catalyst::Utils;
use namespace::clean -except => [ 'meta' ];

subtype 'Catalyst::ScriptRole::LoadableClass',
        as 'ClassName';
coerce 'Catalyst::ScriptRole::LoadableClass',
        from 'Str',
                via {
                    Catalyst::Utils::ensure_class_loaded($_);
                    $_
                };

with 'MooseX::Getopt' => {
        -version  => 0.48,
        -excludes => [ qw/
                _getopt_spec_warnings
                _getopt_spec_exception
                print_usage_text
        / ],
};

has application_name => (
        traits   => [ 'NoGetopt' ],
        isa      => 'Str',
        is       => 'ro',
        required => 1,
);

has loader_class => (
        isa           => 'Catalyst::ScriptRole::LoadableClass',
        is            => 'ro',
        coerce        => 1,
        default       => 'Catalyst::EngineLoader',
        documentation => 'The class to use to detect and load the PSGI engine',
);

has _loader => (
        isa     => 'Plack::Loader',
        default => sub {
            my $self = shift;
            $self->loader_class->new(application_name => $self->application_name);
        },
        handles => {
                load_engine     => 'load',
                autoload_engine => 'auto',
        },
        lazy    => 1,
);

sub _getopt_spec_exception {}

sub _getopt_spec_warnings {
    shift;
    warn @_;
}

sub print_usage_text {
    my $self = shift;
    pod2usage();
    exit 0;
}

sub run {
    my $self = shift;
    $self->_run_application;
}

sub _application_args {
    my $self = shift;
    return {
            argv       => $self->ARGV,
            extra_argv => $self->extra_argv,
    }
}

sub _plack_loader_args {
    my $self = shift;
    my @app_args = $self->_application_args;
    return (port => $app_args[0]);
}

sub _plack_engine_name {}

sub _run_application {
    my $self = shift;
    my $app = $self->application_name;
    Catalyst::Utils::ensure_class_loaded($app);
    my $server;
    if (my $e = $self->_plack_engine_name) {
        $server = $self->load_engine($e, $self->_plack_loader_args);
    }
    else {
        $server = $self->autoload_engine($self->_plack_loader_args);
    }
    $app->run($self->_application_args, $server);
}

1;

=head1 NAME

Catalyst::ScriptRole - Common functionality for Catalyst scripts.

=head1 SYNOPSIS

    package MyApp::Script::Foo;
    use Moose;
    use namespace::autoclean;

    with 'Catalyst::ScriptRole';

    sub _application_args { ... }

=head1 DESCRIPTION

Role with the common functionality of Catalyst scripts.

=head1 METHODS

=head2 run

The method invoked to run the application.

=head2 print_usage_text

Prints out the usage text for the script you tried to invoke.

=head1 ATTRIBUTES

=head2 application_name

The name of the application class, e.g. MyApp

=head1 SEE ALSO

L<Catalyst>

L<MooseX::Getopt>

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software, you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
package Catalyst::View;

use Moose;
extends qw/Catalyst::Component/;

=head1 NAME

Catalyst::View - Catalyst View base class

=head1 SYNOPSIS

    package Catalyst::View::Homebrew;

    use base qw/Catalyst::View/;

    sub process {
    # template processing goes here.
    }

=head1 DESCRIPTION

This is the Catalyst View base class. It's meant to be used as
a base class by Catalyst views.

As a convention, views are expected to read template names from
$c->stash->{template}, and put the output into $c->res->body.
Some views default to render a template named after the dispatched
action's private name. (See L<Catalyst::Action>.)

=head1 METHODS

Implements the same methods as other Catalyst components, see
L<Catalyst::Component>

=head2 process

gives an error message about direct use.

=cut

sub process {

    Catalyst::Exception->throw(message => (ref $_[0] || $_[0]) .
            " directly inherits from Catalyst::View. You need to\n" .
            " inherit from a subclass like Catalyst::View::TT instead.\n");

}

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

no Moose;
__PACKAGE__->meta->make_immutable();

1;
package Catalyst::Runtime;

use strict;
use warnings;

BEGIN {require 5.008003;}

our $VERSION = '5.90130';
$VERSION =~ tr/_//d;

=head1 NAME

Catalyst::Runtime - The Catalyst Framework Runtime

=head1 SYNOPSIS

See L<Catalyst>.

=head1 DESCRIPTION

This is the primary class for the Catalyst-Runtime distribution, version 5.80.

=head1 AUTHORS & COPYRIGHT

Catalyst Contributors, see Catalyst.pm

=head1 LICENSE

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

1;
package Catalyst::DispatchType::Chained;

use Moose;
extends 'Catalyst::DispatchType';

use Text::SimpleTable;
use Catalyst::ActionChain;
use Catalyst::Utils;
use URI;
use Scalar::Util ();
use Encode 2.21 'decode_utf8';

has _endpoints => (
        is       => 'rw',
        isa      => 'ArrayRef',
        required => 1,
        default  => sub {[]},
);

has _actions => (
        is       => 'rw',
        isa      => 'HashRef',
        required => 1,
        default  => sub {{}},
);

has _children_of => (
        is       => 'rw',
        isa      => 'HashRef',
        required => 1,
        default  => sub {{}},
);

no Moose;

# please don't perltidy this. hairy code within.

=head1 NAME

Catalyst::DispatchType::Chained - Path Part DispatchType

=head1 SYNOPSIS

Path part matching, allowing several actions to sequentially take care of processing a request:

  #   root action - captures one argument after it
  sub foo_setup : Chained('/') PathPart('foo') CaptureArgs(1) {
      my ( $self, $c, $foo_arg ) = @_;
      ...
  }

  #   child action endpoint - takes one argument
  sub bar : Chained('foo_setup') Args(1) {
      my ( $self, $c, $bar_arg ) = @_;
      ...
  }

=head1 DESCRIPTION

Dispatch type managing default behaviour.  For more information on
dispatch types, see:

=over 4

=item * L<Catalyst::Manual::Intro> for how they affect application authors

=item * L<Catalyst::DispatchType> for implementation information.

=back

=head1 METHODS

=head2 $self->list($c)

Debug output for Path Part dispatch points

=cut

sub list {
    my ($self, $c) = @_;

    return unless $self->_endpoints;

    my $avail_width = Catalyst::Utils::term_width() - 9;
    my $col1_width = ($avail_width * .50) < 35 ? 35 : int($avail_width * .50);
    my $col2_width = $avail_width - $col1_width;
    my $paths = Text::SimpleTable->new(
            [ $col1_width, 'Path Spec' ], [ $col2_width, 'Private' ],
    );

    my $has_unattached_actions;
    my $unattached_actions = Text::SimpleTable->new(
            [ $col1_width, 'Private' ], [ $col2_width, 'Missing parent' ],
    );

    ENDPOINT:
    foreach my $endpoint (
            sort {$a->reverse cmp $b->reverse}
                    @{$self->_endpoints}
    ) {
        my $args = $endpoint->list_extra_info->{Args};

        my @parts;
        if ($endpoint->has_args_constraints) {
            @parts = map {"{$_}"} $endpoint->all_args_constraints;
        }
        elsif (defined $endpoint->attributes->{Args}) {
            @parts = (defined($endpoint->attributes->{Args}[0]) ? (("*") x $args) : '...');
        }

        my @parents = ();
        my $parent = "DUMMY";
        my $extra = $self->_list_extra_http_methods($endpoint);
        my $consumes = $self->_list_extra_consumes($endpoint);
        my $scheme = $self->_list_extra_scheme($endpoint);
        my $curr = $endpoint;
        while ($curr) {
            if (my $cap = $curr->list_extra_info->{CaptureArgs}) {
                if ($curr->has_captures_constraints) {
                    my $names = join '/', map {"{$_}"} $curr->all_captures_constraints;
                    unshift(@parts, $names);
                }
                else {
                    unshift(@parts, (("*") x $cap));
                }
            }
            if (my $pp = $curr->attributes->{PathPart}) {
                unshift(@parts, $pp->[0])
                        if (defined $pp->[0] && length $pp->[0]);
            }
            $parent = $curr->attributes->{Chained}->[0];
            $curr = $self->_actions->{$parent};
            unshift(@parents, $curr) if $curr;
        }
        if ($parent ne '/') {
            $has_unattached_actions = 1;
            $unattached_actions->row('/' . ($parents[0] || $endpoint)->reverse, $parent);
            next ENDPOINT;
        }
        my @rows;
        foreach my $p (@parents) {
            my $name = "/${p}";

            if (defined(my $extra = $self->_list_extra_http_methods($p))) {
                $name = "${extra} ${name}";
            }
            if (defined(my $cap = $p->list_extra_info->{CaptureArgs})) {
                if ($p->has_captures_constraints) {
                    my $tc = join ',', @{$p->captures_constraints};
                    $name .= " ($tc)";
                }
                else {
                    $name .= " ($cap)";
                }
            }
            if (defined(my $ct = $p->list_extra_info->{Consumes})) {
                $name .= ' :' . $ct;
            }
            if (defined(my $s = $p->list_extra_info->{Scheme})) {
                $scheme = uc $s;
            }

            unless ($p eq $parents[0]) {
                $name = "-> ${name}";
            }
            push(@rows, [ '', $name ]);
        }

        my $endpoint_arg_info = $endpoint;
        if ($endpoint->has_args_constraints) {
            my $tc = join ',', @{$endpoint->args_constraints};
            $endpoint_arg_info .= " ($tc)";
        }
        else {
            $endpoint_arg_info .= defined($endpoint->attributes->{Args}[0]) ? " ($args)" : " (...)";
        }
        push(@rows, [ '', (@rows ? "=> " : '') . ($extra ? "$extra " : '') . ($scheme ? "$scheme: " : '') . "/${endpoint_arg_info}" . ($consumes ? " :$consumes" : "") ]);
        my @display_parts = map {$_ =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
            decode_utf8 $_} @parts;
        $rows[0][0] = join('/', '', @display_parts) || '/';
        $paths->row(@$_) for @rows;
    }

    $c->log->debug("Loaded Chained actions:\n" . $paths->draw . "\n");
    $c->log->debug("Unattached Chained actions:\n", $unattached_actions->draw . "\n")
            if $has_unattached_actions;
}

sub _list_extra_http_methods {
    my ($self, $action) = @_;
    return unless defined $action->list_extra_info->{HTTP_METHODS};
    return join(', ', @{$action->list_extra_info->{HTTP_METHODS}});

}

sub _list_extra_consumes {
    my ($self, $action) = @_;
    return unless defined $action->list_extra_info->{CONSUMES};
    return join(', ', @{$action->list_extra_info->{CONSUMES}});
}

sub _list_extra_scheme {
    my ($self, $action) = @_;
    return unless defined $action->list_extra_info->{Scheme};
    return uc $action->list_extra_info->{Scheme};
}

=head2 $self->match( $c, $path )

Calls C<recurse_match> to see if a chain matches the C<$path>.

=cut

sub match {
    my ($self, $c, $path) = @_;

    my $request = $c->request;
    return 0 if @{$request->args};

    my @parts = split('/', $path);

    my ($chain, $captures, $parts) = $self->recurse_match($c, '/', \@parts);

    if ($parts && @$parts) {
        for my $arg (@$parts) {
            $arg =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
            push @{$request->args}, $arg;
        }
    }

    return 0 unless $chain;

    my $action = Catalyst::ActionChain->from_chain($chain);

    $request->action("/${action}");
    $request->match("/${action}");
    $request->captures($captures);
    $c->action($action);
    $c->namespace($action->namespace);

    return 1;
}

=head2 $self->recurse_match( $c, $parent, \@path_parts )

Recursive search for a matching chain.

=cut

sub recurse_match {
    my ($self, $c, $parent, $path_parts) = @_;
    my $children = $self->_children_of->{$parent};
    return () unless $children;
    my $best_action;
    my @captures;
    TRY:
    foreach my $try_part (sort {length($b) <=> length($a)}
            keys %$children) {
        # $b then $a to try longest part first
        my @parts = @$path_parts;
        if (length $try_part) { # test and strip PathPart
            next TRY unless
                    ($try_part eq join('/', # assemble equal number of parts
                            splice(         # and strip them off @parts as well
                                    @parts, 0, scalar(@{[ split('/', $try_part) ]})
                            ))); # @{[]} to avoid split to @_
        }
        my @try_actions = @{$children->{$try_part}};
        TRY_ACTION:
        foreach my $action (@try_actions) {


            if (my $capture_attr = $action->attributes->{CaptureArgs}) {
                my $capture_count = $action->number_of_captures || 0;

                # Short-circuit if not enough remaining parts
                next TRY_ACTION unless @parts >= $capture_count;

                my @captures;
                my @parts = @parts; # localise

                # strip CaptureArgs into list
                push(@captures, splice(@parts, 0, $capture_count));

                # check if the action may fit, depending on a given test by the app
                next TRY_ACTION unless $action->match_captures($c, \@captures);

                # try the remaining parts against children of this action
                my ($actions, $captures, $action_parts, $n_pathparts) = $self->recurse_match(
                        $c, '/' . $action->reverse, \@parts
                );
                #    No best action currently
                # OR The action has less parts
                # OR The action has equal parts but less captured data (ergo more defined)
                if ($actions &&
                        (!$best_action ||
                                $#$action_parts < $#{$best_action->{parts}} ||
                                ($#$action_parts == $#{$best_action->{parts}} &&
                                        $#$captures < $#{$best_action->{captures}} &&
                                        $n_pathparts > $best_action->{n_pathparts}))) {
                    my @pathparts = split /\//, $action->attributes->{PathPart}->[0];
                    $best_action = {
                            actions     => [ $action, @$actions ],
                            captures    => [ @captures, @$captures ],
                            parts       => $action_parts,
                            n_pathparts => scalar(@pathparts) + $n_pathparts,
                    };
                }
            }
            else {
                {
                    local $c->req->{arguments} = [ @{$c->req->args}, @parts ];
                    next TRY_ACTION unless $action->match($c);
                }
                my $args_attr = $action->attributes->{Args}->[0];
                my $args_count = $action->comparable_arg_number;
                my @pathparts = split /\//, $action->attributes->{PathPart}->[0];
                #    No best action currently
                # OR This one matches with fewer parts left than the current best action,
                #    And therefore is a better match
                # OR No parts and this expects 0
                #    The current best action might also be Args(0),
                #    but we couldn't chose between then anyway so we'll take the last seen
                if (
                        !$best_action ||
                                @parts < @{$best_action->{parts}} ||
                                (
                                        !@parts &&
                                                defined($args_attr) &&
                                                (
                                                        $args_count eq "0" &&
                                                                (
                                                                        ($c->config->{use_chained_args_0_special_case} || 0) ||
                                                                                (
                                                                                        exists($best_action->{args_count}) && defined($best_action->{args_count}) ?
                                                                                                ($best_action->{args_count} ne 0) : 1
                                                                                )
                                                                )
                                                )
                                )
                ) {
                    $best_action = {
                            actions     => [ $action ],
                            captures    => [],
                            parts       => \@parts,
                            args_count  => $args_count,
                            n_pathparts => scalar(@pathparts),
                    };
                }
            }
        }
    }
    return @$best_action{qw/actions captures parts n_pathparts/} if $best_action;
    return ();
}

=head2 $self->register( $c, $action )

Calls register_path for every Path attribute for the given $action.

=cut

sub register {
    my ($self, $c, $action) = @_;

    my @chained_attr = @{$action->attributes->{Chained} || []};

    return 0 unless @chained_attr;

    if (@chained_attr > 1) {
        Catalyst::Exception->throw(
                "Multiple Chained attributes not supported registering ${action}"
        );
    }
    my $chained_to = $chained_attr[0];

    Catalyst::Exception->throw(
            "Actions cannot chain to themselves registering /${action}"
    ) if ($chained_to eq '/' . $action);

    my $children = ($self->_children_of->{ $chained_to } ||= {});

    my @path_part = @{$action->attributes->{PathPart} || []};

    my $part = $action->name;

    if (@path_part == 1 && defined $path_part[0]) {
        $part = $path_part[0];
    }
    elsif (@path_part > 1) {
        Catalyst::Exception->throw(
                "Multiple PathPart attributes not supported registering " . $action->reverse()
        );
    }

    if ($part =~ m(^/)) {
        Catalyst::Exception->throw(
                "Absolute parameters to PathPart not allowed registering " . $action->reverse()
        );
    }

    my $encoded_part = URI->new($part)->canonical;
    $encoded_part =~ s{(?<=[^/])/+\z}{};

    $action->attributes->{PathPart} = [ $encoded_part ];

    unshift(@{$children->{$encoded_part} ||= []}, $action);

    $self->_actions->{'/' . $action->reverse} = $action;

    if (exists $action->attributes->{Args} and exists $action->attributes->{CaptureArgs}) {
        Catalyst::Exception->throw(
                "Combining Args and CaptureArgs attributes not supported registering " .
                        $action->reverse()
        );
    }

    unless ($action->attributes->{CaptureArgs}) {
        unshift(@{$self->_endpoints}, $action);
    }

    return 1;
}

=head2 $self->uri_for_action($action, $captures)

Get the URI part for the action, using C<$captures> to fill
the capturing parts.

=cut

sub uri_for_action {
    my ($self, $action, $captures) = @_;

    return undef unless ($action->attributes->{Chained}
            && !$action->attributes->{CaptureArgs});

    my @parts = ();
    my @captures = @$captures;
    my $parent = "DUMMY";
    my $curr = $action;
    # If this is an action chain get the last action in the chain
    if ($curr->can('chain')) {
        $curr = ${$curr->chain}[-1];
    }
    while ($curr) {
        if (my $cap = $curr->number_of_captures) {
            return undef unless @captures >= $cap; # not enough captures
            if ($cap) {
                unshift(@parts, splice(@captures, -$cap));
            }
        }
        if (my $pp = $curr->attributes->{PathPart}) {
            unshift(@parts, $pp->[0])
                    if (defined($pp->[0]) && length($pp->[0]));
        }
        $parent = $curr->attributes->{Chained}->[0];
        $curr = $self->_actions->{$parent};
    }

    return undef unless $parent eq '/'; # fail for dangling action

    return undef if @captures; # fail for too many captures

    return join('/', '', @parts);

}

=head2 $c->expand_action($action)

Return a list of actions that represents a chained action. See
L<Catalyst::Dispatcher> for more info. You probably want to
use the expand_action it provides rather than this directly.

=cut

sub expand_action {
    my ($self, $action) = @_;

    return unless $action->attributes && $action->attributes->{Chained};

    my @chain;
    my $curr = $action;

    while ($curr) {
        push @chain, $curr;
        my $parent = $curr->attributes->{Chained}->[0];
        $curr = $self->_actions->{$parent};
    }

    return Catalyst::ActionChain->from_chain([ reverse @chain ]);
}

__PACKAGE__->meta->make_immutable;
1;

=head1 USAGE

=head2 Introduction

The C<Chained> attribute allows you to chain public path parts together
by their private names. A chain part's path can be specified with
C<PathPart> and can be declared to expect an arbitrary number of
arguments. The endpoint of the chain specifies how many arguments it
gets through the C<Args> attribute. C<:Args(0)> would be none at all,
C<:Args> without an integer would be unlimited. The path parts that
aren't endpoints are using C<CaptureArgs> to specify how many parameters
they expect to receive. As an example setup:

  package MyApp::Controller::Greeting;
  use base qw/ Catalyst::Controller /;

  #   this is the beginning of our chain
  sub hello : PathPart('hello') Chained('/') CaptureArgs(1) {
      my ( $self, $c, $integer ) = @_;
      $c->stash->{ message } = "Hello ";
      $c->stash->{ arg_sum } = $integer;
  }

  #   this is our endpoint, because it has no :CaptureArgs
  sub world : PathPart('world') Chained('hello') Args(1) {
      my ( $self, $c, $integer ) = @_;
      $c->stash->{ message } .= "World!";
      $c->stash->{ arg_sum } += $integer;

      $c->response->body( join "<br/>\n" =>
          $c->stash->{ message }, $c->stash->{ arg_sum } );
  }

The debug output provides a separate table for chained actions, showing
the whole chain as it would match and the actions it contains. Here's an
example of the startup output with our actions above:

  ...
  [debug] Loaded Path Part actions:
  .-----------------------+------------------------------.
  | Path Spec             | Private                      |
  +-----------------------+------------------------------+
  | /hello/*/world/*      | /greeting/hello (1)          |
  |                       | => /greeting/world           |
  '-----------------------+------------------------------'
  ...

As you can see, Catalyst only deals with chains as whole paths and
builds one for each endpoint, which are the actions with C<:Chained> but
without C<:CaptureArgs>.

Let's assume this application gets a request at the path
C</hello/23/world/12>. What happens then? First, Catalyst will dispatch
to the C<hello> action and pass the value C<23> as an argument to it
after the context. It does so because we have previously used
C<:CaptureArgs(1)> to declare that it has one path part after itself as
its argument. We told Catalyst that this is the beginning of the chain
by specifying C<:Chained('/')>. Also note that instead of saying
C<:PathPart('hello')> we could also just have said C<:PathPart>, as it
defaults to the name of the action.

After C<hello> has run, Catalyst goes on to dispatch to the C<world>
action. This is the last action to be called: Catalyst knows this is an
endpoint because we did not specify a C<:CaptureArgs>
attribute. Nevertheless we specify that this action expects an argument,
but at this point we're using C<:Args(1)> to do that. We could also have
said C<:Args> or left it out altogether, which would mean this action
would get all arguments that are there. This action's C<:Chained>
attribute says C<hello> and tells Catalyst that the C<hello> action in
the current controller is its parent.

With this we have built a chain consisting of two public path parts.
C<hello> captures one part of the path as its argument, and also
specifies the path root as its parent. So this part is
C</hello/$arg>. The next part is the endpoint C<world>, expecting one
argument. It sums up to the path part C<world/$arg>. This leads to a
complete chain of C</hello/$arg/world/$arg> which is matched against the
requested paths.

This example application would, if run and called by e.g.
C</hello/23/world/12>, set the stash value C<message> to "Hello" and the
value C<arg_sum> to "23". The C<world> action would then append "World!"
to C<message> and add C<12> to the stash's C<arg_sum> value.  For the
sake of simplicity no view is shown. Instead we just put the values of
the stash into our body. So the output would look like:

  Hello World!
  35

And our test server would have given us this debugging output for the
request:

  ...
  [debug] "GET" request for "hello/23/world/12" from "127.0.0.1"
  [debug] Path is "/greeting/world"
  [debug] Arguments are "12"
  [info] Request took 0.164113s (6.093/s)
  .------------------------------------------+-----------.
  | Action                                   | Time      |
  +------------------------------------------+-----------+
  | /greeting/hello                          | 0.000029s |
  | /greeting/world                          | 0.000024s |
  '------------------------------------------+-----------'
  ...

What would be common uses of this dispatch technique? It gives the
possibility to split up logic that contains steps that each depend on
each other. An example would be, for example, a wiki path like
C</wiki/FooBarPage/rev/23/view>. This chain can be easily built with
these actions:

  sub wiki : PathPart('wiki') Chained('/') CaptureArgs(1) {
      my ( $self, $c, $page_name ) = @_;
      #  load the page named $page_name and put the object
      #  into the stash
  }

  sub rev : PathPart('rev') Chained('wiki') CaptureArgs(1) {
      my ( $self, $c, $revision_id ) = @_;
      #  use the page object in the stash to get at its
      #  revision with number $revision_id
  }

  sub view : PathPart Chained('rev') Args(0) {
      my ( $self, $c ) = @_;
      #  display the revision in our stash. Another option
      #  would be to forward a compatible object to the action
      #  that displays the default wiki pages, unless we want
      #  a different interface here, for example restore
      #  functionality.
  }

It would now be possible to add other endpoints, for example C<restore>
to restore this specific revision as the current state.

You don't have to put all the chained actions in one controller. The
specification of the parent through C<:Chained> also takes an absolute
action path as its argument. Just specify it with a leading C</>.

If you want, for example, to have actions for the public paths
C</foo/12/edit> and C</foo/12>, just specify two actions with
C<:PathPart('foo')> and C<:Chained('/')>. The handler for the former
path needs a C<:CaptureArgs(1)> attribute and a endpoint with
C<:PathPart('edit')> and C<:Chained('foo')>. For the latter path give
the action just a C<:Args(1)> to mark it as endpoint. This sums up to
this debugging output:

  ...
  [debug] Loaded Path Part actions:
  .-----------------------+------------------------------.
  | Path Spec             | Private                      |
  +-----------------------+------------------------------+
  | /foo/*                | /controller/foo_view         |
  | /foo/*/edit           | /controller/foo_load (1)     |
  |                       | => /controller/edit          |
  '-----------------------+------------------------------'
  ...

Here's a more detailed specification of the attributes belonging to
C<:Chained>:

=head2 Attributes

=over 8

=item PathPart

Sets the name of this part of the chain. If it is specified without
arguments, it takes the name of the action as default. So basically
C<sub foo :PathPart> and C<sub foo :PathPart('foo')> are identical.
This can also contain slashes to bind to a deeper level. An action
with C<sub bar :PathPart('foo/bar') :Chained('/')> would bind to
C</foo/bar/...>. If you don't specify C<:PathPart> it has the same
effect as using C<:PathPart>, it would default to the action name.

=item PathPrefix

Sets PathPart to the path_prefix of the current controller.

=item Chained

Has to be specified for every child in the chain. Possible values are
absolute and relative private action paths or a single slash C</> to
tell Catalyst that this is the root of a chain. The attribute
C<:Chained> without arguments also defaults to the C</> behavior.
Relative action paths may use C<../> to refer to actions in parent
controllers.

Because you can specify an absolute path to the parent action, it
doesn't matter to Catalyst where that parent is located. So, if your
design requests it, you can redispatch a chain through any controller or
namespace you want.

Another interesting possibility gives C<:Chained('.')>, which chains
itself to an action with the path of the current controller's namespace.
For example:

  #   in MyApp::Controller::Foo
  sub bar : Chained CaptureArgs(1) { ... }

  #   in MyApp::Controller::Foo::Bar
  sub baz : Chained('.') Args(1) { ... }

This builds up a chain like C</bar/*/baz/*>. The specification of C<.>
as the argument to Chained here chains the C<baz> action to an action
with the path of the current controller namespace, namely
C</foo/bar>. That action chains directly to C</>, so the C</bar/*/baz/*>
chain comes out as the end product.

=item ChainedParent

Chains an action to another action with the same name in the parent
controller. For Example:

  # in MyApp::Controller::Foo
  sub bar : Chained CaptureArgs(1) { ... }

  # in MyApp::Controller::Foo::Bar
  sub bar : ChainedParent Args(1) { ... }

This builds a chain like C</bar/*/bar/*>.

=item CaptureArgs

Must be specified for every part of the chain that is not an
endpoint. With this attribute Catalyst knows how many of the following
parts of the path (separated by C</>) this action wants to capture as
its arguments. If it doesn't expect any, just specify
C<:CaptureArgs(0)>.  The captures get passed to the action's C<@_> right
after the context, but you can also find them as array references in
C<< $c->request->captures->[$level] >>. The C<$level> is the
level of the action in the chain that captured the parts of the path.

An action that is part of a chain (that is, one that has a C<:Chained>
attribute) but has no C<:CaptureArgs> attribute is treated by Catalyst
as a chain end.

Allowed values for CaptureArgs is a single integer (CaptureArgs(2), meaning two
allowed) or you can declare a L<Moose>, L<MooseX::Types> or L<Type::Tiny>
named constraint such as CaptureArgs(Int,Str) would require two args with
the first being a Integer and the second a string.  You may declare your own
custom type constraints and import them into the controller namespace:

    package MyApp::Controller::Root;

    use Moose;
    use MooseX::MethodAttributes;
    use MyApp::Types qw/Int/;

    extends 'Catalyst::Controller';

    sub chain_base :Chained(/) CaptureArgs(1) { }

      sub any_priority_chain :Chained(chain_base) PathPart('') Args(1) { }

      sub int_priority_chain :Chained(chain_base) PathPart('') Args(Int) { }

If you use a reference type constraint in CaptureArgs, it must be a type
like Tuple in L<Types::Standard> that allows us to determine the number of
args to match.  Otherwise this will raise an error during startup.

See L<Catalyst::RouteMatching> for more.

=item Args

By default, endpoints receive the rest of the arguments in the path. You
can tell Catalyst through C<:Args> explicitly how many arguments your
endpoint expects, just like you can with C<:CaptureArgs>. Note that this
also affects whether this chain is invoked on a request. A chain with an
endpoint specifying one argument will only match if exactly one argument
exists in the path.

You can specify an exact number of arguments like C<:Args(3)>, including
C<0>. If you just say C<:Args> without any arguments, it is the same as
leaving it out altogether: The chain is matched regardless of the number
of path parts after the endpoint.

Just as with C<:CaptureArgs>, the arguments get passed to the action in
C<@_> after the context object. They can also be reached through
C<< $c->request->arguments >>.

You should see 'Args' in L<Catalyst::Controller> for more details on using
type constraints in your Args declarations.

=back

=head2 Auto actions, dispatching and forwarding

Note that the list of C<auto> actions called depends on the private path
of the endpoint of the chain, not on the chained actions way. The
C<auto> actions will be run before the chain dispatching begins. In
every other aspect, C<auto> actions behave as documented.

The C<forward>ing to other actions does just what you would expect. i.e.
only the target action is run. The actions that that action is chained
to are not run.
If you C<detach> out of a chain, the rest of the chain will not get
called after the C<detach>.

=head2 match_captures

A method which can optionally be implemented by actions to
stop chain matching.

See L<Catalyst::Action> for further details.

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

1;
package Catalyst::DispatchType::Path;

use Moose;
extends 'Catalyst::DispatchType';

use Text::SimpleTable;
use Catalyst::Utils;
use URI;
use Encode 2.21 'decode_utf8';

has _paths => (
        is       => 'rw',
        isa      => 'HashRef',
        required => 1,
        default  => sub {+{}},
);

no Moose;

=head1 NAME

Catalyst::DispatchType::Path - Path DispatchType

=head1 SYNOPSIS

See L<Catalyst::DispatchType>.

=head1 DESCRIPTION

Dispatch type managing full path matching behaviour.  For more information on
dispatch types, see:

=over 4

=item * L<Catalyst::Manual::Intro> for how they affect application authors

=item * L<Catalyst::DispatchType> for implementation information.

=back

=head1 METHODS

=head2 $self->list($c)

Debug output for Path dispatch points

=cut

sub list {
    my ($self, $c) = @_;
    my $avail_width = Catalyst::Utils::term_width() - 9;
    my $col1_width = ($avail_width * .50) < 35 ? 35 : int($avail_width * .50);
    my $col2_width = $avail_width - $col1_width;
    my $paths = Text::SimpleTable->new(
            [ $col1_width, 'Path' ], [ $col2_width, 'Private' ]
    );
    foreach my $path (sort keys %{$self->_paths}) {
        foreach my $action (@{$self->_paths->{$path}}) {
            my $args = $action->number_of_args;
            my $parts = defined($args) ? '/*' x $args : '/...';

            my $display_path = "/$path/$parts";
            $display_path =~ s{/{1,}}{/}g;
            $display_path =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg; # deconvert urlencoded for pretty view
            $display_path = decode_utf8 $display_path;            # URI does encoding
            $paths->row($display_path, "/$action");
        }
    }
    $c->log->debug("Loaded Path actions:\n" . $paths->draw . "\n")
            if (keys %{$self->_paths});
}

=head2 $self->match( $c, $path )

For each action registered to this exact path, offers the action a chance to
match the path (in the order in which they were registered). Succeeds on the
first action that matches, if any; if not, returns 0.

=cut

sub match {
    my ($self, $c, $path) = @_;

    $path = '/' if !defined $path || !length $path;

    my @actions = @{$self->_paths->{$path} || []};

    foreach my $action (@actions) {
        next unless $action->match($c);
        $c->req->action($path);
        $c->req->match($path);
        $c->action($action);
        $c->namespace($action->namespace);
        return 1;
    }

    return 0;
}

=head2 $self->register( $c, $action )

Calls register_path for every Path attribute for the given $action.

=cut

sub register {
    my ($self, $c, $action) = @_;

    my @register = @{$action->attributes->{Path} || []};

    $self->register_path($c, $_, $action) for @register;

    return 1 if @register;
    return 0;
}

=head2 $self->register_path($c, $path, $action)

Registers an action at a given path.

=cut

sub register_path {
    my ($self, $c, $path, $action) = @_;
    $path =~ s!^/!!;
    $path = '/' unless length $path;
    $path = URI->new($path)->canonical;
    $path =~ s{(?<=[^/])/+\z}{};

    $self->_paths->{$path} = [
            sort {$a->compare($b)} ($action, @{$self->_paths->{$path} || []})
    ];

    return 1;
}

=head2 $self->uri_for_action($action, $captures)

get a URI part for an action; always returns undef is $captures is set
since Path actions don't have captures

=cut

sub uri_for_action {
    my ($self, $action, $captures) = @_;

    return undef if @$captures;

    if (my $paths = $action->attributes->{Path}) {
        my $path = $paths->[0];
        $path = '/' unless length($path);
        $path = "/${path}" unless ($path =~ m/^\//);
        $path = URI->new($path)->canonical;
        return $path;
    }
    else {
        return undef;
    }
}

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

__PACKAGE__->meta->make_immutable;

1;
package Catalyst::DispatchType::Default;

use Moose;
extends 'Catalyst::DispatchType';

no Moose;

=head1 NAME

Catalyst::DispatchType::Default - Default DispatchType

=head1 SYNOPSIS

See L<Catalyst::DispatchType>.

=head1 DESCRIPTION

Dispatch type managing default behaviour.  For more information on
dispatch types, see:

=over 4

=item * L<Catalyst::Manual::Intro> for how they affect application authors

=item * L<Catalyst::DispatchType> for implementation information.

=back

=head1 METHODS

=head2 $self->match( $c, $path )

If path is empty (i.e. all path parts have been converted into args),
attempts to find a default for the namespace constructed from the args,
or the last inherited default otherwise and will match that.

If path is not empty, never matches since Default will only match if all
other possibilities have been exhausted.

=cut

sub match {
    my ($self, $c, $path) = @_;
    return if $path ne ''; # Not at root yet, wait for it ...
    my $result = ($c->get_actions('default', $c->req->path))[-1];

    # Find default on namespace or super
    if ($result && $result->match($c)) {
        $c->action($result);
        $c->namespace($result->namespace);
        $c->req->action('default');

        # default methods receive the controller name as the first argument
        unshift @{$c->req->args}, $path if $path;
        $c->req->match('');
        return 1;
    }
    return 0;
}

sub _is_low_precedence {1}

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

__PACKAGE__->meta->make_immutable;

1;
package Catalyst::DispatchType::Index;

use Moose;
extends 'Catalyst::DispatchType';
use namespace::clean -except => 'meta';

=head1 NAME

Catalyst::DispatchType::Index - Index DispatchType

=head1 SYNOPSIS

See L<Catalyst::DispatchType>.

=head1 DESCRIPTION

Dispatch type managing behaviour for index pages.  For more information on
dispatch types, see:

=over 4

=item * L<Catalyst::Manual::Intro> for how they affect application authors

=item * L<Catalyst::DispatchType> for implementation information.

=back

=cut

has _actions => (
        is => 'rw', isa => 'HashRef', default => sub {+{}}
);

=head1 METHODS

=head2 $self->match( $c, $path )

Check if there's an index action for a given path, and set it up to use it
if there is; only matches a full URI - if $c->req->args is already set
this DispatchType is guaranteed not to match.

=cut

sub match {
    my ($self, $c, $path) = @_;
    return if @{$c->req->args};
    my $result = $c->get_action('index', $path);

    return 0 unless $result && exists $self->_actions->{ $result->reverse };

    if ($result && $result->match($c)) {
        $c->action($result);
        $c->namespace($result->namespace);
        $c->req->action('index');
        $c->req->match($c->req->path);
        return 1;
    }
    return 0;
}

=head2 $self->register( $c, $action )

Register an action with this DispatchType.

=cut

sub register {
    my ($self, $c, $action) = @_;

    $self->_actions->{ $action->reverse } = $action if $action->name eq 'index';

    return 1;
}

=head2 $self->uri_for_action( $action, $captures )

get a URI part for an action; always returns undef is $captures is set
since index actions don't have captures

=cut

sub uri_for_action {
    my ($self, $action, $captures) = @_;

    return undef if @$captures;

    return undef unless exists $self->_actions->{ $action->reverse };

    return "/" . $action->namespace;
}

sub _is_low_precedence {1}

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

__PACKAGE__->meta->make_immutable;

1;
package Catalyst::Response::Writer;
use strict;
use warnings;

sub write {shift->{_writer}->write(@_)}
sub close {shift->{_writer}->close}

sub write_encoded {
    my ($self, $line) = @_;
    if ((my $enc = $self->{_context}->encoding) && $self->{_requires_encoding}) {
        # Not going to worry about CHECK arg since Unicode always croaks I think - jnap
        $line = $enc->encode($line);
    }

    $self->write($line);
}

=head1 NAME

Catalyst::Response::Writer - Proxy over the PSGI Writer

=head1 SYNOPSIS

    sub myaction : Path {
      my ($self, $c) = @_;
      my $w = $c->response->writer_fh;

      $w->write("hello world");
      $w->close;
    }

=head1 DESCRIPTION

This wraps the PSGI writer (see L<PSGI.pod\Delayed-Response-and-Streaming-Body>)
for more.  We wrap this object so we can provide some additional methods that
make sense from inside L<Catalyst>

=head1 METHODS

This class does the following methods

=head2 write

=head2 close

These delegate to the underlying L<PSGI> writer object

=head2 write_encoded

If the application defines a response encoding (default is UTF8) and the
content type is a type that needs to be encoded (text types like HTML or XML and
Javascript) we first encode the line you want to write.  This is probably the
thing you want to always do.  If you use the L<\write> method directly you will
need to handle your own encoding.

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

1;
package Catalyst::Response;

use Moose;
use HTTP::Headers;
use Moose::Util::TypeConstraints;
use Scalar::Util 'blessed';
use Catalyst::Response::Writer;
use Catalyst::Utils ();

use namespace::clean -except => [ 'meta' ];

with 'MooseX::Emulate::Class::Accessor::Fast';

our $DEFAULT_ENCODE_CONTENT_TYPE_MATCH = qr{text|xml$|javascript$};

has encodable_content_type => (
        is       => 'rw',
        required => 1,
        default  => sub {$DEFAULT_ENCODE_CONTENT_TYPE_MATCH}
);

has _response_cb => (
        is        => 'ro',
        isa       => 'CodeRef',
        writer    => '_set_response_cb',
        clearer   => '_clear_response_cb',
        predicate => '_has_response_cb',
);

subtype 'Catalyst::Engine::Types::Writer',
        as duck_type([ qw(write close) ]);

has _writer => (
        is        => 'ro',
        isa       => 'Catalyst::Engine::Types::Writer', #Pointless since we control how this is built
        #writer  => '_set_writer', Now that its lazy I think this is safe to remove
        clearer   => '_clear_writer',
        predicate => '_has_writer',
        lazy      => 1,
        builder   => '_build_writer',
);

sub _build_writer {
    my $self = shift;

    ## These two lines are probably crap now...
    $self->_context->finalize_headers unless
            $self->finalized_headers;

    my @headers;
    $self->headers->scan(sub {push @headers, @_});

    my $writer = $self->_response_cb->([ $self->status, \@headers ]);
    $self->_clear_response_cb;

    return $writer;
}

has write_fh => (
        is        => 'ro',
        predicate => '_has_write_fh',
        lazy      => 1,
        builder   => '_build_write_fh',
);

sub _build_write_fh {
    my $writer = $_[0]->_writer; # We need to get the finalize headers side effect...
    my $requires_encoding = $_[0]->encodable_response;
    my %fields = (
            _writer            => $writer,
            _context           => $_[0]->_context,
            _requires_encoding => $requires_encoding,
    );

    return bless \%fields, 'Catalyst::Response::Writer';
}

sub DEMOLISH {
    my $self = shift;
    return if $self->_has_write_fh;
    if ($self->_has_writer) {
        $self->_writer->close
    }
}

has cookies => (is => 'rw', default => sub {{}});
has body => (is => 'rw', default => undef);
sub has_body {defined($_[0]->body)}

has location => (is => 'rw');
has status => (is => 'rw', default => 200);
has finalized_headers => (is => 'rw', default => 0);
has headers => (
        is       => 'rw',
        isa      => 'HTTP::Headers',
        handles  => [ qw(content_encoding content_length content_type content_type_charset header) ],
        default  => sub {HTTP::Headers->new()},
        required => 1,
        lazy     => 1,
);
has _context => (
        is       => 'rw',
        weak_ref => 1,
        clearer  => '_clear_context',
);

before [ qw(status headers content_encoding content_length content_type) ] => sub {
    my $self = shift;

    $self->_context->log->warn(
            "Useless setting a header value after finalize_headers and the response callback has been called." .
                    " Since we don't support tail headers this will not work as you might expect.")
            if ($self->_context && $self->finalized_headers && !$self->_has_response_cb && @_);
};

# This has to be different since the first param to ->header is the header name and presumably
# you should be able to request the header even after finalization, just not try to change it.
before 'header' => sub {
    my $self = shift;
    my $header = shift;

    $self->_context->log->warn(
            "Useless setting a header value after finalize_headers and the response callback has been called." .
                    " Since we don't support tail headers this will not work as you might expect.")
            if ($self->_context && $self->finalized_headers && !$self->_has_response_cb && @_);
};

sub output {shift->body(@_)}

sub code {shift->status(@_)}

sub write {
    my ($self, $buffer) = @_;

    # Finalize headers if someone manually writes output
    $self->_context->finalize_headers unless $self->finalized_headers;

    $buffer = q[] unless defined $buffer;

    if ($self->encodable_response) {
        $buffer = $self->_context->encoding->encode($buffer, $self->_context->_encode_check)
    }

    my $len = length($buffer);
    $self->_writer->write($buffer);

    return $len;
}

sub unencoded_write {
    my ($self, $buffer) = @_;

    # Finalize headers if someone manually writes output
    $self->_context->finalize_headers unless $self->finalized_headers;

    $buffer = q[] unless defined $buffer;

    my $len = length($buffer);
    $self->_writer->write($buffer);

    return $len;
}

sub finalize_headers {
    my ($self) = @_;
    return;
}

sub from_psgi_response {
    my ($self, $psgi_res) = @_;
    if (blessed($psgi_res) && $psgi_res->can('as_psgi')) {
        $psgi_res = $psgi_res->as_psgi;
    }
    if (ref $psgi_res eq 'ARRAY') {
        my ($status, $headers, $body) = @$psgi_res;
        $self->status($status);
        $self->headers(HTTP::Headers->new(@$headers));
        # Can be arrayref or filehandle...
        if (defined $body) { # probably paranoia
            ref $body eq 'ARRAY' ? $self->body(join('', @$body)) : $self->body($body);
        }
    }
    elsif (ref $psgi_res eq 'CODE') {

        # Its not clear to me this is correct.  Right now if the PSGI application wants
        # to stream, we stream immediately and then completely bypass the rest of the
        # Catalyst finalization process (unlike if the PSGI app sets an arrayref).  Part of
        # me thinks we should override the current _response_cb and then let finalize_body
        # call that.  I'm not sure the downside of bypassing those bits.  I'm going to leave
        # this be for now and document the behavior.

        $psgi_res->(sub {
            my $response = shift;
            my ($status, $headers, $maybe_body) = @$response;
            $self->status($status);
            $self->headers(HTTP::Headers->new(@$headers));
            if (defined $maybe_body) {
                # Can be arrayref or filehandle...
                ref $maybe_body eq 'ARRAY' ? $self->body(join('', @$maybe_body)) : $self->body($maybe_body);
            }
            else {
                return $self->write_fh;
            }
        });
    }
    else {
        die "You can't set a Catalyst response from that, expect a valid PSGI response";
    }

    # Encoding compatibilty.   If the response set a charset, well... we need
    # to assume its properly encoded and NOT encode for this response.  Otherwise
    # We risk double encoding.

    # We check first to make sure headers have not been finalized.  Headers might be finalized
    # in the case where a PSGI response is streaming and the PSGI application already wrote
    # to the output stream and close the filehandle.
    if (!$self->finalized_headers && $self->content_type_charset) {
        # We have to do this since for backcompat reasons having a charset doesn't always
        # mean that the body is already encoded :(
        $self->_context->clear_encoding;
    }
}

=head1 NAME

Catalyst::Response - stores output responding to the current client request

=head1 SYNOPSIS

    $res = $c->response;
    $res->body;
    $res->code;
    $res->content_encoding;
    $res->content_length;
    $res->content_type;
    $res->cookies;
    $res->header;
    $res->headers;
    $res->output;
    $res->redirect;
    $res->status;
    $res->write;

=head1 DESCRIPTION

This is the Catalyst Response class, which provides methods for responding to
the current client request. The appropriate L<Catalyst::Engine> for your environment
will turn the Catalyst::Response into a HTTP Response and return it to the client.

=head1 METHODS

=head2 $res->body( $text | $fh | $iohandle_object )

    $c->response->body('Catalyst rocks!');

Sets or returns the output (text or binary data). If you are returning a large body,
you might want to use a L<IO::Handle> type of object (Something that implements the getline method
in the same fashion), or a filehandle GLOB. These will be passed down to the PSGI
handler you are using and might be optimized using server specific abilities (for
example L<Twiggy> will attempt to server a real local file in a non blocking manner).

If you are using a filehandle as the body response you are responsible for
making sure it conforms to the L<PSGI> specification with regards to content
encoding.  Unlike with scalar body values or when using the streaming interfaces
we currently do not attempt to normalize and encode your filehandle.  In general
this means you should be sure to be sending bytes not UTF8 decoded multibyte
characters.

Most of the time when you do:

    open(my $fh, '<:raw', $path);

You should be fine.  If you open a filehandle with a L<PerlIO> layer you probably
are not fine.  You can usually fix this by explicitly using binmode to set
the IOLayer to :raw.  Its possible future versions of L<Catalyst> will try to
'do the right thing'.

When using a L<IO::Handle> type of object and no content length has been
already set in the response headers Catalyst will make a reasonable attempt
to determine the size of the Handle. Depending on the implementation of your
handle object, setting the content length may fail. If it is at all possible
for you to determine the content length of your handle object,
it is recommended that you set the content length in the response headers
yourself, which will be respected and sent by Catalyst in the response.

Please note that the object needs to implement C<getline>, not just
C<read>.  Older versions of L<Catalyst> expected your filehandle like objects
to do read.  If you have code written for this expectation and you cannot
change the code to meet the L<PSGI> specification, you can try the following
middleware L<Plack::Middleware::AdaptFilehandleRead> which will attempt to
wrap your object in an interface that so conforms.

Starting from version 5.90060, when using an L<IO::Handle> object, you
may want to use L<Plack::Middleware::XSendfile>, to delegate the
actual serving to the frontend server. To do so, you need to pass to
C<body> an IO object with a C<path> method. This can be achieved in
two ways.

Either using L<Plack::Util>:

  my $fh = IO::File->new($file, 'r');
  Plack::Util::set_io_path($fh, $file);

Or using L<IO::File::WithPath>

  my $fh = IO::File::WithPath->new($file, 'r');

And then passing the filehandle to body and setting headers, if needed.

  $c->response->body($fh);
  $c->response->headers->content_type('text/plain');
  $c->response->headers->content_length(-s $file);
  $c->response->headers->last_modified((stat($file))[9]);

L<Plack::Middleware::XSendfile> can be loaded in the application so:

 __PACKAGE__->config(
     psgi_middleware => [
         'XSendfile',
         # other middlewares here...
        ],
 );

B<Beware> that loading the middleware without configuring the
webserver to set the request header C<X-Sendfile-Type> to a supported
type (C<X-Accel-Redirect> for nginx, C<X-Sendfile> for Apache and
Lighttpd), could lead to the disclosure of private paths to malicious
clients setting that header.

Nginx needs the additional X-Accel-Mapping header to be set in the
webserver configuration, so the middleware will replace the absolute
path of the IO object with the internal nginx path. This is also
useful to prevent a buggy app to server random files from the
filesystem, as it's an internal redirect.

An nginx configuration for FastCGI could look so:

 server {
     server_name example.com;
     root /my/app/root;
     location /private/repo/ {
         internal;
         alias /my/app/repo/;
     }
     location /private/staging/ {
         internal;
         alias /my/app/staging/;
     }
     location @proxy {
         include /etc/nginx/fastcgi_params;
         fastcgi_param SCRIPT_NAME '';
         fastcgi_param PATH_INFO   $fastcgi_script_name;
         fastcgi_param HTTP_X_SENDFILE_TYPE X-Accel-Redirect;
         fastcgi_param HTTP_X_ACCEL_MAPPING /my/app=/private;
         fastcgi_pass  unix:/my/app/run/app.sock;
    }
 }

In the example above, passing filehandles with a local path matching
/my/app/staging or /my/app/repo will be served by nginx. Passing paths
with other locations will lead to an internal server error.

Setting the body to a filehandle without the C<path> method bypasses
the middleware completely.

For Apache and Lighttpd, the mapping doesn't apply and setting the
X-Sendfile-Type is enough.

=head2 $res->has_body

Predicate which returns true when a body has been set.

=head2 $res->code

Alias for $res->status.

=head2 $res->content_encoding

Shortcut for $res->headers->content_encoding.

=head2 $res->content_length

Shortcut for $res->headers->content_length.

=head2 $res->content_type

Shortcut for $res->headers->content_type.

This value is typically set by your view or plugin. For example,
L<Catalyst::Plugin::Static::Simple> will guess the mime type based on the file
it found, while L<Catalyst::View::TT> defaults to C<text/html>.

=head2 $res->content_type_charset

Shortcut for $res->headers->content_type_charset;

=head2 $res->cookies

Returns a reference to a hash containing cookies to be set. The keys of the
hash are the cookies' names, and their corresponding values are hash
references used to construct a L<CGI::Simple::Cookie> object.

    $c->response->cookies->{foo} = { value => '123' };

The keys of the hash reference on the right correspond to the L<CGI::Simple::Cookie>
parameters of the same name, except they are used without a leading dash.
Possible parameters are:

=over

=item value

=item expires

=item domain

=item path

=item secure

=item httponly

=back

=head2 $res->header

Shortcut for $res->headers->header.

=head2 $res->headers

Returns an L<HTTP::Headers> object, which can be used to set headers.

    $c->response->headers->header( 'X-Catalyst' => $Catalyst::VERSION );

=head2 $res->output

Alias for $res->body.

=head2 $res->redirect( $url, $status )

Causes the response to redirect to the specified URL. The default status is
C<302>.

    $c->response->redirect( 'http://slashdot.org' );
    $c->response->redirect( 'http://slashdot.org', 307 );

This is a convenience method that sets the Location header to the
redirect destination, and then sets the response status.  You will
want to C< return > or C<< $c->detach() >> to interrupt the normal
processing flow if you want the redirect to occur straight away.

B<Note:> do not give a relative URL as $url, i.e: one that is not fully
qualified (= C<http://...>, etc.) or that starts with a slash
(= C</path/here>). While it may work, it is not guaranteed to do the right
thing and is not a standard behaviour. You may opt to use uri_for() or
uri_for_action() instead.

B<Note:> If $url is an object that does ->as_string (such as L<URI>, which is
what you get from ->uri_for) we automatically call that to stringify.  This
should ease the common case usage

    return $c->res->redirect( $c->uri_for(...));

=cut

sub redirect {
    my $self = shift;

    if (@_) {
        my $location = shift;
        my $status = shift || 302;

        if (blessed($location) && $location->can('as_string')) {
            $location = $location->as_string;
        }

        $self->location($location);
        $self->status($status);
    }

    return $self->location;
}

=head2 $res->location

Sets or returns the HTTP 'Location'.

=head2 $res->status

Sets or returns the HTTP status.

    $c->response->status(404);

$res->code is an alias for this, to match HTTP::Response->code.

=head2 $res->write( $data )

Writes $data to the output stream.  Calling this method will finalize your
headers and send the headers and status code response to the client (so changing
them afterwards is a waste... be sure to set your headers correctly first).

You may call this as often as you want throughout your response cycle.  You may
even set a 'body' afterward.  So for example you might write your HTTP headers
and the HEAD section of your document and then set the body from a template
driven from a database.  In some cases this can seem to the client as if you had
a faster overall response (but note that unless your server support chunked
body your content is likely to get queued anyway (L<Starman> and most other
http 1.1 webservers support this).

If there is an encoding set, we encode each line of the response (the default
encoding is UTF-8).

=head2 $res->unencoded_write( $data )

Works just like ->write but we don't apply any content encoding to C<$data>.  Use
this if you are already encoding the $data or the data is arriving from an encoded
storage.

=head2 $res->write_fh

Returns an instance of L<Catalyst::Response::Writer>, which is a lightweight
decorator over the PSGI C<$writer> object (see L<PSGI.pod\Delayed-Response-and-Streaming-Body>).

In addition to proxying the C<write> and C<close> method from the underlying PSGI
writer, this proxy object knows any application wide encoding, and provides a method
C<write_encoded> that will properly encode your written lines based upon your
encoding settings.  By default in L<Catalyst> responses are UTF-8 encoded and this
is the encoding used if you respond via C<write_encoded>.  If you want to handle
encoding yourself, you can use the C<write> method directly.

Encoding only applies to content types for which it matters.  Currently the following
content types are assumed to need encoding: text (including HTML), xml and javascript.

We provide access to this object so that you can properly close over it for use in
asynchronous and nonblocking applications.  For example (assuming you are using a supporting
server, like L<Twiggy>:

    package AsyncExample::Controller::Root;

    use Moose;

    BEGIN { extends 'Catalyst::Controller' }

    sub prepare_cb {
      my $write_fh = pop;
      return sub {
        my $message = shift;
        $write_fh->write("Finishing: $message\n");
        $write_fh->close;
      };
    }

    sub anyevent :Local :Args(0) {
      my ($self, $c) = @_;
      my $cb = $self->prepare_cb($c->res->write_fh);

      my $watcher;
      $watcher = AnyEvent->timer(
        after => 5,
        cb => sub {
          $cb->(scalar localtime);
          undef $watcher; # cancel circular-ref
        });
    }

Like the 'write' method, calling this will finalize headers. Unlike 'write' when you
can this it is assumed you are taking control of the response so the body is never
finalized (there isn't one anyway) and you need to call the close method.

=head2 $res->print( @data )

Prints @data to the output stream, separated by $,.  This lets you pass
the response object to functions that want to write to an L<IO::Handle>.

=head2 $res->finalize_headers()

Writes headers to response if not already written

=head2 from_psgi_response

Given a PSGI response (either three element ARRAY reference OR coderef expecting
a $responder) set the response from it.

Properly supports streaming and delayed response and / or async IO if running
under an expected event loop.

If passed an object, will expect that object to do a method C<as_psgi>.

Example:

    package MyApp::Web::Controller::Test;

    use base 'Catalyst::Controller';
    use Plack::App::Directory;


    my $app = Plack::App::Directory->new({ root => "/path/to/htdocs" })
      ->to_app;

    sub myaction :Local Args {
      my ($self, $c) = @_;
      $c->res->from_psgi_response($app->($c->req->env));
    }

    sub streaming_body :Local {
      my ($self, $c) = @_;
      my $psgi_app = sub {
          my $respond = shift;
          my $writer = $respond->([200,["Content-Type" => "text/plain"]]);
          $writer->write("body");
          $writer->close;
      };
      $c->res->from_psgi_response($psgi_app);
    }

Please note this does not attempt to map or nest your PSGI application under
the Controller and Action namespace or path. You may wish to review 'PSGI Helpers'
under L<Catalyst::Utils> for help in properly nesting applications.

B<NOTE> If your external PSGI application returns a response that has a character
set associated with the content type (such as "text/html; charset=UTF-8") we set
$c->clear_encoding to remove any additional content type encoding processing later
in the application (this is done to avoid double encoding issues).

B<NOTE> If your external PSGI application is streaming, we assume you completely
handle the entire jobs (including closing the stream).  This will also bypass
the output finalization methods on Catalyst (such as 'finalize_body' which gets
called but then skipped when it finds that output is already finished.)  Its possible
this might cause issue with some plugins that want to do 'things' during those
finalization methods.  Just understand what is happening.

=head2 encodable_content_type

This is a regular expression used to determine of the current content type
should be considered encodable.  Currently we apply default encoding (usually
UTF8) to text type contents.  Here's the default regular expression:

This would match content types like:

    text/plain
    text/html
    text/xml
    application/javascript
    application/xml
    application/vnd.user+xml

B<NOTE>: We don't encode JSON content type responses by default since most
of the JSON serializers that are commonly used for this task will do so
automatically and we don't want to double encode.  If you are not using a
tool like L<JSON> to produce JSON type content, (for example you are using
a template system, or creating the strings manually) you will need to either
encoding the body yourself:

    $c->response->body( $c->encoding->encode( $body, $c->_encode_check ) );

Or you can alter the regular expression using this attribute.

=head2 encodable_response

Given a L<Catalyst::Response> return true if its one that can be encoded.

     make sure there is an encoding set on the response
     make sure the content type is encodable
     make sure no content type charset has been already set to something different from the global encoding
     make sure no content encoding is present.

Note this does not inspect a body since we do allow automatic encoding on streaming
type responses.

=cut

sub encodable_response {
    my ($self) = @_;
    return 0 unless $self->_context; # Cases like returning a HTTP Exception response you don't have a context here...
    return 0 unless $self->_context->encoding;

    # The response is considered to have a 'manual charset' when a charset is already set on
    # the content type of the response AND it is not the same as the one we set in encoding.
    # If there is no charset OR we are asking for the one which is the same as the current
    # required encoding, that is a flag that we want Catalyst to encode the response automatically.
    my $has_manual_charset = 0;
    if (my $charset = $self->content_type_charset) {
        $has_manual_charset = (uc($charset) ne uc($self->_context->encoding->mime_name)) ? 1 : 0;
    }

    # Content type is encodable if it matches the regular expression stored in this attribute
    my $encodable_content_type = $self->content_type =~ m/${\$self->encodable_content_type}/ ? 1 : 0;

    # The content encoding is allowed (for charset encoding) only if its empty or is set to identity
    my $allowed_content_encoding = (!$self->content_encoding || $self->content_encoding eq 'identity') ? 1 : 0;

    # The content type must be an encodable type, and there must be NO manual charset and also
    # the content encoding must be the allowed values;
    if (
            $encodable_content_type and
                    !$has_manual_charset and
                    $allowed_content_encoding
    ) {
        return 1;
    }
    else {
        return 0;
    }
}

=head2 DEMOLISH

Ensures that the response is flushed and closed at the end of the
request.

=head2 meta

Provided by Moose

=cut

sub print {
    my $self = shift;
    my $data = shift;

    defined $self->write($data) or return;

    for (@_) {
        defined $self->write($,) or return;
        defined $self->write($_) or return;
    }
    defined $self->write($\) or return;

    return 1;
}

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

__PACKAGE__->meta->make_immutable;

1;
package Catalyst::Log;

use Moose;
with 'MooseX::Emulate::Class::Accessor::Fast';

use Data::Dump;
use Moose::Util 'find_meta';
use Carp qw/cluck/;

our %LEVELS = ();      # Levels stored as bit field, ergo debug = 1, warn = 2 etc
our %LEVEL_MATCH = (); # Stored as additive, thus debug = 31, warn = 30 etc

has level => (is => 'rw');
has _body => (is => 'rw');
has abort => (is => 'rw');
has autoflush => (is => 'rw', default => sub {1});
has _psgi_logger => (is => 'rw', predicate => '_has_psgi_logger', clearer => '_clear_psgi_logger');
has _psgi_errors => (is => 'rw', predicate => '_has_psgi_errors', clearer => '_clear_psgi_errors');

sub clear_psgi {
    my $self = shift;
    $self->_clear_psgi_logger;
    $self->_clear_psgi_errors;
}

sub psgienv {
    my ($self, $env) = @_;

    $self->_psgi_logger($env->{'psgix.logger'}) if $env->{'psgix.logger'};
    $self->_psgi_errors($env->{'psgi.errors'}) if $env->{'psgi.errors'};
}

{
    my @levels = qw[debug info warn error fatal];

    my $meta = find_meta(__PACKAGE__);
    my $summed_level = 0;
    for (my $i = $#levels; $i >= 0; $i--) {

        my $name = $levels[$i];

        my $level = 1 << $i;
        $summed_level |= $level;

        $LEVELS{$name} = $level;
        $LEVEL_MATCH{$name} = $summed_level;

        $meta->add_method($name, sub {
            my $self = shift;

            if ($self->level & $level) {
                $self->_log($name, @_);
            }
        });

        $meta->add_method("is_$name", sub {
            my $self = shift;
            return $self->level & $level;
        });;
    }
}

around new => sub {
    my $orig = shift;
    my $class = shift;
    my $self = $class->$orig;

    $self->levels(scalar(@_) ? @_ : keys %LEVELS);

    return $self;
};

sub levels {
    my ($self, @levels) = @_;
    $self->level(0);
    $self->enable(@levels);
}

sub enable {
    my ($self, @levels) = @_;
    my $level = $self->level;
    for (map {$LEVEL_MATCH{$_}} @levels) {
        $level |= $_;
    }
    $self->level($level);
}

sub disable {
    my ($self, @levels) = @_;
    my $level = $self->level;
    for (map {$LEVELS{$_}} @levels) {
        $level &= ~$_;
    }
    $self->level($level);
}

our $HAS_DUMPED;
sub _dump {
    my $self = shift;
    unless ($HAS_DUMPED++) {
        cluck("Catalyst::Log::_dump is deprecated and will be removed. Please change to using your own Dumper.\n");
    }
    $self->info(Data::Dump::dump(@_));
}

sub _log {
    my $self = shift;
    my $level = shift;
    my $message = join("\n", @_);
    if ($self->can('_has_psgi_logger') and $self->_has_psgi_logger) {
        $self->_psgi_logger->({
                level   => $level,
                message => $message,
        });
    }
    else {
        $message .= "\n" unless $message =~ /\n$/;
        my $body = $self->_body;
        $body .= sprintf("[%s] %s", $level, $message);
        $self->_body($body);
    }
    if ($self->autoflush && !$self->abort) {
        $self->_flush;
    }
    return 1;
}

sub _flush {
    my $self = shift;
    if ($self->abort || !$self->_body) {
        $self->abort(undef);
    }
    else {
        $self->_send_to_log($self->_body);
    }
    $self->_body(undef);
}

sub _send_to_log {
    my $self = shift;
    if ($self->can('_has_psgi_errors') and $self->_has_psgi_errors) {
        $self->_psgi_errors->print(@_);
    }
    else {
        binmode STDERR, ":utf8";
        print STDERR @_;
    }
}

# 5.7 compat code.
# Alias _body to body, add a before modifier to warn..
my $meta = __PACKAGE__->meta; # Calling meta method here fine as we happen at compile time.
$meta->add_method('body', $meta->get_method('_body'));
my %package_hash; # Only warn once per method, per package.
# I haven't provided a way to disable them, patches welcome.
$meta->add_before_method_modifier('body', sub {
    my $class = blessed(shift);
    $package_hash{$class}++ || do {
        warn("Class $class is calling the deprecated method Catalyst::Log->body method,\n"
                . "this will be removed in Catalyst 5.81");
    };
});
# End 5.70 backwards compatibility hacks.

no Moose;
__PACKAGE__->meta->make_immutable(inline_constructor => 0);

1;

use strict;
use warnings;

package Catalyst::Middleware::Stash;

use base 'Plack::Middleware';
use Exporter 'import';
use Carp 'croak';

our @EXPORT_OK = qw(stash get_stash);

sub PSGI_KEY() {'Catalyst.Stash.v2'}

sub get_stash {
    my $env = shift;
    return $env->{+PSGI_KEY} ||
            croak "You requested a stash, but one does not exist.";
}

sub stash {
    my ($host, @args) = @_;
    return get_stash($host->env)
            ->(@args);
}

sub _create_stash {
    my $self = shift;
    my $stash = shift || +{};
    return sub {
        if (@_) {
            my $new_stash = @_ > 1 ? { @_ } : $_[0];
            croak('stash takes a hash or hashref')
                    unless ref $new_stash;
            foreach my $key (keys %$new_stash) {
                $stash->{$key} = $new_stash->{$key};
            }
        }
        $stash;
    };
}

sub call {
    my ($self, $env) = @_;
    $env->{+PSGI_KEY} = $self->_create_stash
            unless exists($env->{+PSGI_KEY});

    return $self->app->($env);
}

=head1 NAME

Catalyst::Middleware::Stash - The Catalyst stash - in middleware

=head1 DESCRIPTION

We've moved the L<Catalyst> stash to middleware.  Please don't use this
directly since it is likely to move off the Catalyst namespace into a stand
alone distribution

We store a coderef under the C<PSGI_KEY> which can be dereferenced with
key values or nothing to access the underlying hashref.

Anything placed into the stash will be available in the stash of any 'mounted'
Catalyst applications.  A mounted Catalyst application may set the stash and
'pass back' information to the parent application.  Non Catalyst applications
may use this middleware to access and set stash values.

Please note I highly recommend having a stronger interface than a stash key
between applications.

For more information the current test case t/middleware-stash.t is the best
documentation.

=head1 SUBROUTINES

This class defines the following subroutines.

=head2 PSGI_KEY

Returns the hash key where we store the stash.  You should not assume
the string value here will never change!  Also, its better to use
L</get_stash> or L</stash>.

=head2 get_stash

Expect: $psgi_env.

Exportable subroutine.

Get the stash out of the C<$env>.

=head2 stash

Expects: An object that does C<env> and arguments

Exportable subroutine.

Given an object with a method C<env> get or set stash values, either
as a method or via hashref modification.  This stash is automatically
reset for each request (it is not persistent or shared across connected
clients.  Stash key / value are stored in memory.

    use Plack::Request;
    use Catalyst::Middleware::Stash 'stash';

    my $app = sub {
      my $env = shift;
      my $req = Plack::Request->new($env);
      my $stashed = $req->stash->{in_the_stash};  # Assume the stash was previously populated.

      return [200, ['Content-Type' => 'text/plain'],
        ["I found $stashed in the stash!"]];
    };

If the stash does not yet exist, an exception is thrown.

=head1 METHODS

This class defines the following methods.

=head2 call

Used by plack to call the middleware

=cut

1;
package Catalyst::Stats;

use Moose;
use Time::HiRes qw/gettimeofday tv_interval/;
use Text::SimpleTable ();
use Catalyst::Utils;
use Tree::Simple qw/use_weak_refs/;
use Tree::Simple::Visitor::FindByUID;

use namespace::clean -except => 'meta';

has enable => (is => 'rw', required => 1, default => sub {1});
has tree => (
        is       => 'ro',
        required => 1,
        default  => sub {Tree::Simple->new({ t => [ gettimeofday ] })},
        handles  => [ qw/accept traverse/ ],
);
has stack => (
        is       => 'ro',
        required => 1,
        lazy     => 1,
        default  => sub {[ shift->tree ]}
);

sub profile {
    my $self = shift;

    return unless $self->enable;

    my %params;
    if (@_ <= 1) {
        $params{comment} = shift || "";
    }
    elsif (@_ % 2 != 0) {
        die "profile() requires a single comment parameter or a list of name-value pairs; found "
                . (scalar @_) . " values: " . join(", ", @_);
    }
    else {
        (%params) = @_;
        $params{comment} ||= "";
    }

    my $parent;
    my $prev;
    my $t = [ gettimeofday ];
    my $stack = $self->stack;

    if ($params{end}) {
        # parent is on stack; search for matching block and splice out
        for (my $i = $#{$stack}; $i > 0; $i--) {
            if ($stack->[$i]->getNodeValue->{action} eq $params{end}) {
                my ($node) = splice(@{$stack}, $i, 1);
                # Adjust elapsed on partner node
                my $v = $node->getNodeValue;
                $v->{elapsed} = tv_interval($v->{t}, $t);
                return $node->getUID;
            }
        }
        # if partner not found, fall through to treat as non-closing call
    }
    if ($params{parent}) {
        # parent is explicitly defined
        $prev = $parent = $self->_get_uid($params{parent});
    }
    if (!$parent) {
        # Find previous node, which is either previous sibling or parent, for ref time.
        $prev = $parent = $stack->[-1] or return undef;
        my $n = $parent->getChildCount;
        $prev = $parent->getChild($n - 1) if $n > 0;
    }

    my $node = Tree::Simple->new({
            action  => $params{begin} || "",
            t       => $t,
            elapsed => tv_interval($prev->getNodeValue->{t}, $t),
            comment => $params{comment},
    });
    $node->setUID($params{uid}) if $params{uid};

    $parent->addChild($node);
    push(@{$stack}, $node) if $params{begin};

    return $node->getUID;
}

sub created {
    return @{shift->{tree}->getNodeValue->{t}};
}

sub elapsed {
    return tv_interval(shift->{tree}->getNodeValue->{t});
}

sub report {
    my $self = shift;

    my $t;
    my @results;

    if (!wantarray) {
        $t = Text::SimpleTable->new(
                [ Catalyst::Utils::term_width() - 9 - 13, 'Action' ],
                [ 9, 'Time' ],
        );
    }

    $self->traverse(sub {
        my $action = shift;
        my $stat = $action->getNodeValue;
        my @r = ($action->getDepth,
                ($stat->{action} || "") .
                        ($stat->{action} && $stat->{comment} ? " " : "") . ($stat->{comment} ? '- ' . $stat->{comment} : ""),
                $stat->{elapsed},
                $stat->{action} ? 1 : 0,
        );
        # Trim down any times >= 10 to avoid ugly Text::Simple line wrapping
        my $elapsed = substr(sprintf("%f", $stat->{elapsed}), 0, 8) . "s";
        if ($t) {
            $t->row((q{ } x $r[0]) . $r[1],
                    defined $r[2] ? $elapsed : '??');
        }
        else {
            push @results, \@r;
        }
    });
    return wantarray ? @results : $t->draw;
}

sub _get_uid {
    my ($self, $uid) = @_;

    my $visitor = Tree::Simple::Visitor::FindByUID->new;
    $visitor->searchForUID($uid);
    $self->accept($visitor);
    return $visitor->getResult;
}

sub addChild {
    my $self = shift;
    my $node = $_[ 0 ];

    my $stat = $node->getNodeValue;

    # do we need to fake $stat->{ t } ?
    if ($stat->{ elapsed }) {
        # remove the "s" from elapsed time
        $stat->{ elapsed } =~ s{s$}{};
    }

    $self->tree->addChild(@_);
}

sub setNodeValue {
    my $self = shift;
    my $stat = $_[ 0 ];

    # do we need to fake $stat->{ t } ?
    if ($stat->{ elapsed }) {
        # remove the "s" from elapsed time
        $stat->{ elapsed } =~ s{s$}{};
    }

    $self->tree->setNodeValue(@_);
}

sub getNodeValue {
    my $self = shift;
    $self->tree->getNodeValue(@_)->{ t };
}

__PACKAGE__->meta->make_immutable();

1;

package Catalyst::ScriptRunner;
use Moose;
use FindBin;
use lib;
use File::Spec;
use Class::Load qw/load_first_existing_class load_optional_class/;
use Catalyst::Utils;
use Try::Tiny;
use namespace::clean -except => [ 'meta' ];

sub find_script_class {
    my ($self, $app, $script) = @_;
    return load_first_existing_class("${app}::Script::${script}", "Catalyst::Script::$script");
}

sub find_script_traits {
    my ($self, @try) = @_;

    return grep {load_optional_class($_)} @try;
}

no namespace::clean;
sub subclass_with_traits {
    my ($base, @traits) = @_;

    my $meta = Class::MOP::class_of($base)->create_anon_class(
            superclasses => [ $base ],
            roles        => [ @traits ],
            cache        => 1,
    );
    $meta->add_method(meta => sub {$meta});

    return $meta->name;
}
use namespace::clean;

sub run {
    my ($self, $appclass, $scriptclass) = @_;

    if (grep {-f File::Spec->catfile($FindBin::Bin, '..', $_)} Catalyst::Utils::dist_indicator_file_list()) {
        lib->import(File::Spec->catdir($FindBin::Bin, '..', 'lib'));
    }

    my $class = $self->find_script_class($appclass, $scriptclass);

    my @possible_traits = ("${appclass}::TraitFor::Script::${scriptclass}", "${appclass}::TraitFor::Script");
    my @traits = $self->find_script_traits(@possible_traits);

    $class = subclass_with_traits($class, @traits)
            if @traits;

    $class->new_with_options(application_name => $appclass)->run;
}

__PACKAGE__->meta->make_immutable;
1;

=head1 NAME

Catalyst::ScriptRunner - The Catalyst Framework script runner

=head1 SYNOPSIS

    # Will run MyApp::Script::Server if it exists, otherwise
    # will run Catalyst::Script::Server.
    Catalyst::ScriptRunner->run('MyApp', 'Server');

=head1 DESCRIPTION

This class is responsible for loading and running scripts, either in the
application specific namespace
(e.g. C<MyApp::Script::Server>), or the Catalyst namespace (e.g. C<Catalyst::Script::Server>).

If your application contains a custom script, then it will be used in preference to the generic
script, and is expected to sub-class the standard script.

=head1 TRAIT LOADING

Catalyst will automatically load and apply roles to the scripts in your
application.

C<MyApp::TraitFor::Script> will be loaded if present, and will be applied to B<ALL>
scripts.

C<MyApp::TraitFor::Script::XXXX> will be loaded (if present) and for script
individually.

=head1 METHODS

=head2 run ($application_class, $scriptclass)

Called with two parameters, the application class (e.g. MyApp)
and the script class, (i.e. one of Server/FastCGI/CGI/Create/Test)

=head2 find_script_class ($appname, $script_name)

Finds and loads the class for the script, trying the application specific
script first, and falling back to the generic script. Returns the script
which was loaded.

=head2 find_script_traits ($appname, @try)

Finds and loads a set of traits. Returns the list of traits which were loaded.

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
package Catalyst::ActionChain;

use Moose;
extends qw(Catalyst::Action);

has chain => (is => 'rw');
no Moose;

=head1 NAME

Catalyst::ActionChain - Chain of Catalyst Actions

=head1 SYNOPSIS

See L<Catalyst::Manual::Intro> for more info about Chained actions.

=head1 DESCRIPTION

This class represents a chain of Catalyst Actions. It behaves exactly like
the action at the *end* of the chain except on dispatch it will execute all
the actions in the chain in order.

=cut

sub dispatch {
    my ($self, $c) = @_;
    my @captures = @{$c->req->captures || []};
    my @chain = @{$self->chain};
    my $last = pop(@chain);
    foreach my $action (@chain) {
        my @args;
        if (my $cap = $action->number_of_captures) {
            @args = splice(@captures, 0, $cap);
        }
        local $c->request->{arguments} = \@args;
        $action->dispatch($c);

        # break the chain if exception occurs in the middle of chain.  We
        # check the global config flag 'abort_chain_on_error_fix', but this
        # is now considered true by default, so unless someone explicitly sets
        # it to false we default it to true (if its not defined).
        my $abort = defined($c->config->{abort_chain_on_error_fix}) ?
                $c->config->{abort_chain_on_error_fix} : 1;
        return if ($c->has_errors && $abort);
    }
    $last->dispatch($c);
}

sub from_chain {
    my ($self, $actions) = @_;
    my $final = $actions->[-1];
    return $self->new({ %$final, chain => $actions });
}

sub number_of_captures {
    my ($self) = @_;
    my $chain = $self->chain;
    my $captures = 0;

    $captures += $_->number_of_captures for @$chain;
    return $captures;
}

sub match_captures {
    my ($self, $c, $captures) = @_;
    my @captures = @{$captures || []};

    foreach my $link (@{$self->chain}) {
        my @local_captures = splice @captures, 0, $link->number_of_captures;
        return unless $link->match_captures($c, \@local_captures);
    }
    return 1;
}
sub match_captures_constraints {
    my ($self, $c, $captures) = @_;
    my @captures = @{$captures || []};

    foreach my $link (@{$self->chain}) {
        my @local_captures = splice @captures, 0, $link->number_of_captures;
        next unless $link->has_captures_constraints;
        return unless $link->match_captures_constraints($c, \@local_captures);
    }
    return 1;
}

# the scheme defined at the end of the chain is the one we use
# but warn if too many.

sub scheme {
    my $self = shift;
    my @chain = @{$self->chain};
    my ($scheme, @more) = map {
        exists $_->attributes->{Scheme} ? $_->attributes->{Scheme}[0] : ();
    } reverse @chain;

    warn "$self is a chain with two many Scheme attributes (only one is allowed)"
            if @more;

    return $scheme;
}

__PACKAGE__->meta->make_immutable;
1;

package Catalyst::Dispatcher;

use Moose;
use Class::MOP;
with 'MooseX::Emulate::Class::Accessor::Fast';

use Catalyst::Exception;
use Catalyst::Utils;
use Catalyst::Action;
use Catalyst::ActionContainer;
use Catalyst::DispatchType::Default;
use Catalyst::DispatchType::Index;
use Catalyst::Utils;
use Text::SimpleTable;
use Tree::Simple;
use Class::Load qw(load_class try_load_class);
use Encode 2.21 'decode_utf8';

use namespace::clean -except => 'meta';

# Refactoring note:
# do these belong as package vars or should we build these via a builder method?
# See Catalyst-Plugin-Server for them being added to, which should be much less ugly.

# Preload these action types
our @PRELOAD = qw/Index Path/;

# Postload these action types
our @POSTLOAD = qw/Default/;

# Note - see back-compat methods at end of file.
has _tree => (is => 'rw', builder => '_build__tree');
has dispatch_types => (is => 'rw', default => sub {[]}, required => 1, lazy => 1);
has _registered_dispatch_types => (is => 'rw', default => sub {{}}, required => 1, lazy => 1);
has _method_action_class => (is => 'rw', default => 'Catalyst::Action');
has _action_hash => (is => 'rw', required => 1, lazy => 1, default => sub {{}});
has _container_hash => (is => 'rw', required => 1, lazy => 1, default => sub {{}});

my %dispatch_types = (pre => \@PRELOAD, post => \@POSTLOAD);
foreach my $type (keys %dispatch_types) {
    has $type . "load_dispatch_types" => (
            is     => 'rw', required => 1, lazy => 1, default => sub {$dispatch_types{$type}},
            traits => [ 'MooseX::Emulate::Class::Accessor::Fast::Meta::Role::Attribute' ], # List assignment is CAF style
    );
}

=head1 NAME

Catalyst::Dispatcher - The Catalyst Dispatcher

=head1 SYNOPSIS

See L<Catalyst>.

=head1 DESCRIPTION

This is the class that maps public urls to actions in your Catalyst
application based on the attributes you set.

=head1 METHODS

=head2 new

Construct a new dispatcher.

=cut

sub _build__tree {
    my ($self) = @_;

    my $container =
            Catalyst::ActionContainer->new({ part => '/', actions => {} });

    return Tree::Simple->new($container, Tree::Simple->ROOT);
}

=head2 $self->preload_dispatch_types

An arrayref of pre-loaded dispatchtype classes

Entries are considered to be available as C<Catalyst::DispatchType::CLASS>
To use a custom class outside the regular C<Catalyst> namespace, prefix
it with a C<+>, like so:

    +My::Dispatch::Type

=head2 $self->postload_dispatch_types

An arrayref of post-loaded dispatchtype classes

Entries are considered to be available as C<Catalyst::DispatchType::CLASS>
To use a custom class outside the regular C<Catalyst> namespace, prefix
it with a C<+>, like so:

    +My::Dispatch::Type

=head2 $self->dispatch($c)

Delegate the dispatch to the action that matched the url, or return a
message about unknown resource

=cut

sub dispatch {
    my ($self, $c) = @_;
    if (my $action = $c->action) {
        $c->forward(join('/', '', $action->namespace, '_DISPATCH'));
    }
    else {
        my $path = $c->req->path;
        $path =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
        $path = decode_utf8($path);

        my $error = $path
                ? qq/Unknown resource "$path"/
                : "No default action defined";
        $c->log->error($error) if $c->debug;
        $c->error($error);
    }
}

# $self->_command2action( $c, $command [, \@arguments ] )
# $self->_command2action( $c, $command [, \@captures, \@arguments ] )
# Search for an action, from the command and returns C<($action, $args, $captures)> on
# success. Returns C<(0)> on error.

sub _command2action {
    my ($self, $c, $command, @extra_params) = @_;

    unless ($command) {
        $c->log->debug('Nothing to go to') if $c->debug;
        return 0;
    }

    my (@args, @captures);

    if (ref($extra_params[-2]) eq 'ARRAY') {
        @captures = @{splice @extra_params, -2, 1};
    }

    if (ref($extra_params[-1]) eq 'ARRAY') {
        @args = @{pop @extra_params}
    }
    else {
        # this is a copy, it may take some abuse from
        # ->_invoke_as_path if the path had trailing parts
        @args = @{$c->request->arguments};
    }

    my $action;

    # go to a string path ("/foo/bar/gorch")
    # or action object
    if (blessed($command) && $command->isa('Catalyst::Action')) {
        $action = $command;
    }
    else {
        $action = $self->_invoke_as_path($c, "$command", \@args);
    }

    # go to a component ( "View::Foo" or $c->component("...")
    # - a path or an object)
    unless ($action) {
        my $method = @extra_params ? $extra_params[0] : "process";
        $action = $self->_invoke_as_component($c, $command, $method);
    }

    return $action, \@args, \@captures;
}

=head2 $self->visit( $c, $command [, \@arguments ] )

Documented in L<Catalyst>

=cut

sub visit {
    my $self = shift;
    $self->_do_visit('visit', @_);
}

sub _do_visit {
    my $self = shift;
    my $opname = shift;
    my ($c, $command) = @_;
    my ($action, $args, $captures) = $self->_command2action(@_);
    my $error = qq/Couldn't $opname("$command"): /;

    if (!$action) {
        $error .= qq/Couldn't $opname to command "$command": /
                . qq/Invalid action or component./;
    }
    elsif (!defined $action->namespace) {
        $error .= qq/Action has no namespace: cannot $opname() to a plain /
                . qq/method or component, must be an :Action of some sort./
    }
    elsif (!$action->class->can('_DISPATCH')) {
        $error .= qq/Action cannot _DISPATCH. /
                . qq/Did you try to $opname() a non-controller action?/;
    }
    else {
        $error = q();
    }

    if ($error) {
        $c->error($error);
        $c->log->debug($error) if $c->debug;
        return 0;
    }

    $action = $self->expand_action($action);

    local $c->request->{arguments} = $args;
    local $c->request->{captures} = $captures;
    local $c->{namespace} = $action->{'namespace'};
    local $c->{action} = $action;

    $self->dispatch($c);
}

=head2 $self->go( $c, $command [, \@arguments ] )

Documented in L<Catalyst>

=cut

sub go {
    my $self = shift;
    $self->_do_visit('go', @_);
    Catalyst::Exception::Go->throw;
}

=head2 $self->forward( $c, $command [, \@arguments ] )

Documented in L<Catalyst>

=cut

sub forward {
    my $self = shift;
    no warnings 'recursion';
    return $self->_do_forward(forward => @_);
}

sub _do_forward {
    my $self = shift;
    my $opname = shift;
    my ($c, $command) = @_;
    my ($action, $args, $captures) = $self->_command2action(@_);

    if (!$action) {
        my $error .= qq/Couldn't $opname to command "$command": /
                . qq/Invalid action or component./;
        $c->error($error);
        $c->log->debug($error) if $c->debug;
        return 0;
    }

    local $c->request->{arguments} = $args;
    no warnings 'recursion';
    $action->dispatch($c);

    #If there is an error, all bets off regarding state.  Documentation
    #Specifies that when you forward, if there's an error you must expect
    #state to be 0.
    if (@{$c->error}) {
        $c->state(0);
    }
    return $c->state;
}

=head2 $self->detach( $c, $command [, \@arguments ] )

Documented in L<Catalyst>

=cut

sub detach {
    my ($self, $c, $command, @args) = @_;
    $self->_do_forward(detach => $c, $command, @args) if $command;
    $c->state(0); # Needed in order to skip any auto functions
    Catalyst::Exception::Detach->throw;
}

sub _action_rel2abs {
    my ($self, $c, $path) = @_;

    unless ($path =~ m#^/#) {
        my $namespace = $c->stack->[-1]->namespace;
        $path = "$namespace/$path";
    }

    $path =~ s#^/##;
    return $path;
}

sub _invoke_as_path {
    my ($self, $c, $rel_path, $args) = @_;

    my $path = $self->_action_rel2abs($c, $rel_path);

    my ($tail, @extra_args);
    while (($path, $tail) = ($path =~ m#^(?:(.*)/)?(\w+)?$#)) {
        # allow $path to be empty
        if (my $action = $c->get_action($tail, $path)) {
            push @$args, @extra_args;
            return $action;
        }
        else {
            return
                    unless $path
            ; # if a match on the global namespace failed then the whole lookup failed
        }

        unshift @extra_args, $tail;
    }
}

sub _find_component {
    my ($self, $c, $component) = @_;

    # fugly, why doesn't ->component('MyApp') work?
    return $c if ($component eq blessed($c));

    return blessed($component)
            ? $component
            : $c->component($component);
}

sub _invoke_as_component {
    my ($self, $c, $component_or_class, $method) = @_;

    my $component = $self->_find_component($c, $component_or_class);
    my $component_class = blessed $component || return 0;

    if (my $code = $component_class->can('action_for')) {
        my $possible_action = $component->$code($method);
        return $possible_action if $possible_action;
    }

    if (my $code = $component_class->can($method)) {
        return $self->_method_action_class->new(
                {
                        name      => $method,
                        code      => $code,
                        reverse   => "$component_class->$method",
                        class     => $component_class,
                        (blessed($component_or_class) ? (instance => $component_or_class) : ()),
                        namespace => Catalyst::Utils::class2prefix(
                                $component_class, ref($c)->config->{case_sensitive}
                        ),
                }
        );
    }
    else {
        my $error =
                qq/Couldn't forward to "$component_class". Does not implement "$method"/;
        $c->error($error);
        $c->log->debug($error)
                if $c->debug;
        return 0;
    }
}

=head2 $self->prepare_action($c)

Find an dispatch type that matches $c->req->path, and set args from it.

=cut

sub prepare_action {
    my ($self, $c) = @_;
    my $req = $c->req;
    my $path = $req->path;
    my @path = split /\//, $req->path;
    $req->args(\my @args);

    unshift(@path, ''); # Root action

    DESCEND:
    while (@path) {
        $path = join '/', @path;
        $path =~ s#^/+##;

        # Check out dispatch types to see if any will handle the path at
        # this level

        foreach my $type (@{$self->dispatch_types}) {
            last DESCEND if $type->match($c, $path);
        }

        # If not, move the last part path to args
        my $arg = pop(@path);
        $arg =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
        unshift @args, $arg;
    }

    s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg for grep {defined} @{$req->captures || []};

    if ($c->debug && defined $req->match && length $req->match) {
        my $match = $req->match;
        $match =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
        $match = decode_utf8($match);
        $c->log->debug('Path is "' . $match . '"')
    }

    $c->log->debug('Arguments are "' . join('/', map {decode_utf8 $_} @args) . '"')
            if ($c->debug && @args);
}

=head2 $self->get_action( $action_name, $namespace )

returns a named action from a given namespace.  C<$action_name>
may be a relative path on that C<$namespace> such as

    $self->get_action('../bar', 'foo/baz');

In which case we look for the action at 'foo/bar'.

=cut

sub get_action {
    my ($self, $name, $namespace) = @_;
    return unless $name;

    $namespace = join("/", grep {length} split '/', (defined $namespace ? $namespace : ""));

    return $self->get_action_by_path("${namespace}/${name}");
}

=head2 $self->get_action_by_path( $path );

Returns the named action by its full private path.

This method performs some normalization on C<$path> so that if
it includes '..' it will do the right thing (for example if
C<$path> is '/foo/../bar' that is normalized to '/bar'.

=cut

sub get_action_by_path {
    my ($self, $path) = @_;
    $path =~ s/[^\/]+\/\.\.\/// while $path =~ m/[^\/]+\/\.\.\//;
    $path =~ s/^\///;
    $path = "/$path" unless $path =~ /\//;
    $self->_action_hash->{$path};
}

=head2 $self->get_actions( $c, $action, $namespace )

=cut

sub get_actions {
    my ($self, $c, $action, $namespace) = @_;
    return [] unless $action;

    $namespace = join("/", grep {length} split '/', $namespace || "");

    my @match = $self->get_containers($namespace);

    return map {$_->get_action($action)} @match;
}

=head2 $self->get_containers( $namespace )

Return all the action containers for a given namespace, inclusive

=cut

sub get_containers {
    my ($self, $namespace) = @_;
    $namespace ||= '';
    $namespace = '' if $namespace eq '/';

    my @containers;

    if (length $namespace) {
        do {
            push @containers, $self->_container_hash->{$namespace};
        } while ($namespace =~ s#/[^/]+$##);
    }

    return reverse grep {defined} @containers, $self->_container_hash->{''};
}

=head2 $self->uri_for_action($action, \@captures)

Takes a Catalyst::Action object and action parameters and returns a URI
part such that if $c->req->path were this URI part, this action would be
dispatched to with $c->req->captures set to the supplied arrayref.

If the action object is not available for external dispatch or the dispatcher
cannot determine an appropriate URI, this method will return undef.

=cut

sub uri_for_action {
    my ($self, $action, $captures) = @_;
    $captures ||= [];
    foreach my $dispatch_type (@{$self->dispatch_types}) {
        my $uri = $dispatch_type->uri_for_action($action, $captures);
        return ($uri eq '' ? '/' : $uri)
                if defined($uri);
    }
    return undef;
}

=head2 expand_action

expand an action into a full representation of the dispatch.
mostly useful for chained, other actions will just return a
single action.

=cut

sub expand_action {
    my ($self, $action) = @_;

    foreach my $dispatch_type (@{$self->dispatch_types}) {
        my $expanded = $dispatch_type->expand_action($action);
        return $expanded if $expanded;
    }

    return $action;
}

=head2 $self->register( $c, $action )

Make sure all required dispatch types for this action are loaded, then
pass the action to our dispatch types so they can register it if required.
Also, set up the tree with the action containers.

=cut

sub register {
    my ($self, $c, $action) = @_;

    my $registered = $self->_registered_dispatch_types;

    foreach my $key (keys %{$action->attributes}) {
        next if $key eq 'Private';
        my $class = "Catalyst::DispatchType::$key";
        unless ($registered->{$class}) {
            # FIXME - Some error checking and re-throwing needed here, as
            #         we eat exceptions loading dispatch types.
            # see also try_load_class
            eval {load_class($class)};
            my $load_failed = $@;
            $self->_check_deprecated_dispatch_type($key, $load_failed);
            push(@{$self->dispatch_types}, $class->new) unless $load_failed;
            $registered->{$class} = 1;
        }
    }

    my @dtypes = @{$self->dispatch_types};
    my @normal_dtypes;
    my @low_precedence_dtypes;

    for my $type (@dtypes) {
        if ($type->_is_low_precedence) {
            push @low_precedence_dtypes, $type;
        }
        else {
            push @normal_dtypes, $type;
        }
    }

    # Pass the action to our dispatch types so they can register it if reqd.
    my $was_registered = 0;
    foreach my $type (@normal_dtypes) {
        $was_registered = 1 if $type->register($c, $action);
    }

    if (not $was_registered) {
        foreach my $type (@low_precedence_dtypes) {
            $type->register($c, $action);
        }
    }

    my $namespace = $action->namespace;
    my $name = $action->name;

    my $container = $self->_find_or_create_action_container($namespace);

    # Set the method value
    $container->add_action($action);

    $self->_action_hash->{"$namespace/$name"} = $action;
    $self->_container_hash->{$namespace} = $container;
}

sub _find_or_create_action_container {
    my ($self, $namespace) = @_;

    my $tree ||= $self->_tree;

    return $tree->getNodeValue unless $namespace;

    my @namespace = split '/', $namespace;
    return $self->_find_or_create_namespace_node($tree, @namespace)
            ->getNodeValue;
}

sub _find_or_create_namespace_node {
    my ($self, $parent, $part, @namespace) = @_;

    return $parent unless $part;

    my $child =
            (grep {$_->getNodeValue->part eq $part} $parent->getAllChildren)[0];

    unless ($child) {
        my $container = Catalyst::ActionContainer->new($part);
        $parent->addChild($child = Tree::Simple->new($container));
    }

    $self->_find_or_create_namespace_node($child, @namespace);
}

=head2 $self->setup_actions( $class, $context )

Loads all of the pre-load dispatch types, registers their actions and then
loads all of the post-load dispatch types, and iterates over the tree of
actions, displaying the debug information if appropriate.

=cut

sub setup_actions {
    my ($self, $c) = @_;

    my @classes =
            $self->_load_dispatch_types(@{$self->preload_dispatch_types});
    @{$self->_registered_dispatch_types}{@classes} = (1) x @classes;

    foreach my $comp (map @{$_}{sort keys %$_}, $c->components) {
        $comp = $comp->() if ref($comp) eq 'CODE';
        $comp->register_actions($c) if $comp->can('register_actions');
    }

    $self->_load_dispatch_types(@{$self->postload_dispatch_types});

    return unless $c->debug;
    $self->_display_action_tables($c);
}

sub _display_action_tables {
    my ($self, $c) = @_;

    my $avail_width = Catalyst::Utils::term_width() - 12;
    my $col1_width = ($avail_width * .25) < 20 ? 20 : int($avail_width * .25);
    my $col2_width = ($avail_width * .50) < 36 ? 36 : int($avail_width * .50);
    my $col3_width = $avail_width - $col1_width - $col2_width;
    my $privates = Text::SimpleTable->new(
            [ $col1_width, 'Private' ], [ $col2_width, 'Class' ], [ $col3_width, 'Method' ]
    );

    my $has_private = 0;
    my $walker = sub {
        my ($walker, $parent, $prefix) = @_;
        $prefix .= $parent->getNodeValue || '';
        $prefix .= '/' unless $prefix =~ /\/$/;
        my $node = $parent->getNodeValue->actions;

        for my $action (keys %{$node}) {
            my $action_obj = $node->{$action};
            next
                    if (($action =~ /^_.*/)
                            && (!$c->config->{show_internal_actions}));
            $privates->row("$prefix$action", $action_obj->class, $action);
            $has_private = 1;
        }

        $walker->($walker, $_, $prefix) for $parent->getAllChildren;
    };

    $walker->($walker, $self->_tree, '');
    $c->log->debug("Loaded Private actions:\n" . $privates->draw . "\n")
            if $has_private;

    # List all public actions
    $_->list($c) for @{$self->dispatch_types};
}

sub _load_dispatch_types {
    my ($self, @types) = @_;

    my @loaded;
    # Preload action types
    for my $type (@types) {
        # first param is undef because we cannot get the appclass
        my $class = Catalyst::Utils::resolve_namespace(undef, 'Catalyst::DispatchType', $type);

        my ($success, $error) = try_load_class($class);
        Catalyst::Exception->throw(message => $error) if not $success;
        push @{$self->dispatch_types}, $class->new;

        push @loaded, $class;
    }

    return @loaded;
}

=head2 $self->dispatch_type( $type )

Get the DispatchType object of the relevant type, i.e. passing C<$type> of
C<Chained> would return a L<Catalyst::DispatchType::Chained> object (assuming
of course it's being used.)

=cut

sub dispatch_type {
    my ($self, $name) = @_;

    # first param is undef because we cannot get the appclass
    $name = Catalyst::Utils::resolve_namespace(undef, 'Catalyst::DispatchType', $name);

    for (@{$self->dispatch_types}) {
        return $_ if ref($_) eq $name;
    }
    return undef;
}

sub _check_deprecated_dispatch_type {
    my ($self, $key, $load_failed) = @_;

    return unless $key =~ /^(Local)?Regexp?/;

    # TODO: Should these throw an exception rather than just warning?
    if ($load_failed) {
        warn("Attempt to use deprecated $key dispatch type.\n"
                . "  Use Chained methods or install the standalone\n"
                . "  Catalyst::DispatchType::Regex if necessary.\n");
    }
    elsif (!defined $Catalyst::DispatchType::Regex::VERSION
            || $Catalyst::DispatchType::Regex::VERSION le '5.90020') {
        # We loaded the old core version of the Regex module this will break
        warn("The $key DispatchType has been removed from Catalyst core.\n"
                . "  An old version of the core Catalyst::DispatchType::Regex\n"
                . "  has been loaded and will likely fail. Please remove\n"
                . "   $INC{'Catalyst/DispatchType/Regex.pm'}\n"
                . "  and use Chained methods or install the standalone\n"
                . "  Catalyst::DispatchType::Regex if necessary.\n");
    }
}

use Moose;

# 5.70 backwards compatibility hacks.

# Various plugins (e.g. Plugin::Server and Plugin::Authorization::ACL)
# need the methods here which *should* be private..

# You should be able to use get_actions or get_containers appropriately
# instead of relying on these methods which expose implementation details
# of the dispatcher..
#
# IRC backlog included below, please come ask if this doesn't work for you.
#
# <@t0m> 5.80, the state of. There are things in the dispatcher which have
#        been deprecated, that we yell at anyone for using, which there isn't
#        a good alternative for yet..
# <@mst> er, get_actions/get_containers provides that doesn't it?
# <@mst> DispatchTypes are loaded on demand anyway
# <@t0m> I'm thinking of things like _tree which is aliased to 'tree' with
#        warnings otherwise shit breaks.. We're issuing warnings about the
#        correct set of things which you shouldn't be calling..
# <@mst> right
# <@mst> basically, I don't see there's a need for a replacement for anything
# <@mst> it was never a good idea to call ->tree
# <@mst> nothingmuch was the only one who did AFAIK
# <@mst> and he admitted it was a hack ;)

# See also t/lib/TestApp/Plugin/AddDispatchTypes.pm

# Alias _method_name to method_name, add a before modifier to warn..
foreach my $public_method_name (qw/
        tree
        registered_dispatch_types
        method_action_class
        action_hash
        container_hash
/) {
    my $private_method_name = '_' . $public_method_name;
    my $meta = __PACKAGE__->meta; # Calling meta method here fine as we happen at compile time.
    $meta->add_method($public_method_name, $meta->get_method($private_method_name));
    {
        my %package_hash; # Only warn once per method, per package. These are infrequent enough that
        # I haven't provided a way to disable them, patches welcome.
        $meta->add_before_method_modifier($public_method_name, sub {
            my $class = caller(2);
            chomp($class);
            $package_hash{$class}++ || do {
                warn("Class $class is calling the deprecated method\n"
                        . "  Catalyst::Dispatcher::$public_method_name,\n"
                        . "  this will be removed in Catalyst 5.9\n");
            };
        });
    }
}
# End 5.70 backwards compatibility hacks.

__PACKAGE__->meta->make_immutable;

=head2 meta

Provided by Moose

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

1;
package Catalyst::Script::Test;
use Moose;
use Catalyst::Test ();
use namespace::clean -except => [ 'meta' ];

with 'Catalyst::ScriptRole';

sub run {
    my $self = shift;

    Catalyst::Test->import($self->application_name);

    foreach my $arg (@{$self->ARGV}) {
        print request($arg)->content . "\n";
    }
}

__PACKAGE__->meta->make_immutable;
1;

=head1 NAME

Catalyst::Script::Test - Test Catalyst application on the command line

=head1 SYNOPSIS

  myapp_test.pl [options] /path

  Options:
  -h     --help           display this help and exits

=head1 DESCRIPTION

Script to perform a test hit against your application and display the output.

=head1 SEE ALSO

L<Catalyst::ScriptRunner>

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
package Catalyst::Script::Server;
use Moose;
use Catalyst::Utils;
use Class::Load qw(try_load_class load_class);
use namespace::clean -except => [ 'meta' ];

with 'Catalyst::ScriptRole';

has debug => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'd',
        isa           => 'Bool',
        is            => 'ro',
        documentation => q{Force debug mode},
);

has host => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'h',
        isa           => 'Str',
        is            => 'ro',
        # N.B. undef (the default) means we bind on all interfaces on the host.
        documentation => 'Specify a hostname or IP on this host for the server to bind to',
);

has fork => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'f',
        isa           => 'Bool',
        is            => 'ro',
        default       => 0,
        documentation => 'Fork the server to be able to serve multiple requests at once',
);

has port => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'p',
        isa           => 'Int',
        is            => 'ro',
        lazy          => 1,
        default       => sub {
            Catalyst::Utils::env_value(shift->application_name, 'port') || 3000
        },
        documentation => 'Specify a different listening port (to the default port 3000)',
);

has '+help_flag' => (
        cmd_aliases => [ qw(usage ?) ],
);

use Moose::Util::TypeConstraints;
class_type 'MooseX::Daemonize::Pid::File';
subtype 'Catalyst::Script::Server::Types::Pidfile',
        as 'MooseX::Daemonize::Pid::File';

coerce 'Catalyst::Script::Server::Types::Pidfile', from 'Str', via {
    my ($success, $error) = try_load_class("MooseX::Daemonize::Pid::File");
    warn("Could not load MooseX::Daemonize::Pid::File, needed for --pid option: $error\n"),
            exit 1 if not $success;
    MooseX::Daemonize::Pid::File->new(file => $_);
};
MooseX::Getopt::OptionTypeMap->add_option_type_to_map(
        'Catalyst::Script::Server::Types::Pidfile' => '=s',
);
has pidfile => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'pid',
        isa           => 'Catalyst::Script::Server::Types::Pidfile',
        is            => 'ro',
        documentation => 'Specify a pidfile',
        coerce        => 1,
        predicate     => '_has_pidfile',
);

# Override MooseX::Daemonize
sub dont_close_all_files {1}
sub BUILD {
    my $self = shift;

    if ($self->background) {
        # FIXME - This is evil. Should we just add MX::Daemonize to the deps?
        my ($success, $error) = try_load_class("MooseX::Daemonize::Core");
        warn("MooseX::Daemonize is needed for the --background option: $error\n"),
                exit 1 if not $success;
        ($success, $error) = try_load_class("POSIX");
        warn("$error\n"), exit 1 if not $success;
        MooseX::Daemonize::Core->meta->apply($self);
        POSIX::close($_) foreach (0 .. 2);
    }
}

has keepalive => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'k',
        isa           => 'Bool',
        is            => 'ro',
        default       => 0,
        documentation => 'Support keepalive',
);

has background => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'bg',
        isa           => 'Bool',
        is            => 'ro',
        default       => 0,
        documentation => 'Run in the background',
);

has restart => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'r',
        isa           => 'Bool',
        is            => 'ro',
        lazy          => 1,
        default       => sub {
            Catalyst::Utils::env_value(shift->application_name, 'reload') || 0;
        },
        documentation => 'use Catalyst::Restarter to detect code changes and restart the application',
);

has restart_directory => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => [ 'rdir', 'restartdirectory' ],
        isa           => 'ArrayRef[Str]',
        is            => 'ro',
        documentation => 'Restarter directory to watch',
        predicate     => '_has_restart_directory',
);

has restart_delay => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'rd',
        isa           => 'Int',
        is            => 'ro',
        documentation => 'Set a restart delay',
        predicate     => '_has_restart_delay',
);

{
    use Moose::Util::TypeConstraints;

    my $tc = subtype 'Catalyst::Script::Server::Types::RegexpRef', as 'RegexpRef';
    coerce $tc, from 'Str', via {qr/$_/};

    MooseX::Getopt::OptionTypeMap->add_option_type_to_map($tc => '=s');

    has restart_regex => (
            traits        => [ qw(Getopt) ],
            cmd_aliases   => 'rr',
            isa           => $tc,
            coerce        => 1,
            is            => 'ro',
            documentation => 'Restart regex',
            predicate     => '_has_restart_regex',
    );
}

has follow_symlinks => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'sym',
        isa           => 'Bool',
        is            => 'ro',
        default       => 0,
        documentation => 'Follow symbolic links',
        predicate     => '_has_follow_symlinks',
);

sub _plack_engine_name {
    my $self = shift;
    return $self->fork || $self->keepalive ? 'Starman' : 'Standalone';
}

sub _restarter_args {
    my $self = shift;

    return (
            argv      => $self->ARGV,
            start_sub => sub {$self->_run_application},
            ($self->_has_follow_symlinks ? (follow_symlinks => $self->follow_symlinks) : ()),
            ($self->_has_restart_delay ? (sleep_interval => $self->restart_delay) : ()),
            ($self->_has_restart_directory ? (directories => $self->restart_directory) : ()),
            ($self->_has_restart_regex ? (filter => $self->restart_regex) : ()),
    ),
            (
                    map {$_ => $self->$_} qw(application_name host port debug pidfile fork background keepalive)
            );
}

has restarter_class => (
        is      => 'ro',
        isa     => 'Str',
        lazy    => 1,
        default => sub {
            my $self = shift;
            Catalyst::Utils::env_value($self->application_name, 'RESTARTER') || 'Catalyst::Restarter';
        }
);

sub run {
    my $self = shift;

    local $ENV{CATALYST_DEBUG} = 1
            if $self->debug;

    if ($self->restart) {
        die "Cannot run in the background and also watch for changed files.\n"
                if $self->background;
        die "Cannot write out a pid file and fork for the restarter.\n"
                if $self->_has_pidfile;

        # If we load this here, then in the case of a restarter, it does not
        # need to be reloaded for each restart.
        require Catalyst;

        # If this isn't done, then the Catalyst::Devel tests for the restarter
        # fail.
        $| = 1 if $ENV{HARNESS_ACTIVE};

        Catalyst::Utils::ensure_class_loaded($self->restarter_class);

        my $subclass = $self->restarter_class->pick_subclass;

        my $restarter = $subclass->new(
                $self->_restarter_args()
        );

        $restarter->run_and_watch;
    }
    else {
        if ($self->background) {
            $self->daemon_fork;

            return 1 unless $self->is_daemon;

            load_class($self->application_name);

            $self->daemon_detach;
        }

        $self->pidfile->write
                if $self->_has_pidfile;

        $self->_run_application;
    }

}

sub _plack_loader_args {
    my ($self) = shift;
    return (
            port         => $self->port,
            host         => $self->host,
            keepalive    => $self->keepalive ? 100 : 1,
            server_ready => sub {
                my ($args) = @_;

                my $name = $args->{server_software} || ref($args); # $args is $server
                my $host = $args->{host} || 0;
                my $proto = $args->{proto} || 'http';

                print STDERR "$name: Accepting connections at $proto://$host:$args->{port}/\n";
            },
    );
}

around _application_args => sub {
    my ($orig, $self) = @_;
    return (
            $self->port,
            $self->host,
            {
                    %{$self->$orig},
                    map {$_ => $self->$_} qw/
                            fork
                            keepalive
                            background
                            pidfile
                            keepalive
                            follow_symlinks
                            port
                            host
                    /,
            },
    );
};

__PACKAGE__->meta->make_immutable;
1;

=head1 NAME

Catalyst::Script::Server - Catalyst test server

=head1 SYNOPSIS

 myapp_server.pl [options]

 Options:
   -d     --debug          force debug mode
   -f     --fork           handle each request in a new process
                      (defaults to false)
          --help           display this help and exits
   -h     --host           host (defaults to all)
   -p     --port           port (defaults to 3000)
   -k     --keepalive      enable keep-alive connections
   -r     --restart        restart when files get modified
                       (defaults to false)
   --rd   --restart_delay  delay between file checks
                      (ignored if you have Linux::Inotify2 installed)
   --rr   --restart_regex  regex match files that trigger
                      a restart when modified
                      (defaults to '\.yml$|\.yaml$|\.conf|\.pm$')
   --rdir --restart_directory  the directory to search for
                      modified files, can be set multiple times
                      (defaults to '[SCRIPT_DIR]/..')
   --sym  --follow_symlinks   follow symlinks in search directories
                      (defaults to false. this is a no-op on Win32)
   --bg   --background        run the process in the background
   --pid  --pidfile           specify filename for pid file

 See also:
   perldoc Catalyst::Manual
   perldoc Catalyst::Manual::Intro

=head1 DESCRIPTION

Run a Catalyst test server for this application.

=head1 SEE ALSO

L<Catalyst::ScriptRunner>

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
package Catalyst::Script::Create;
use Moose;
use Class::Load 'load_class';
use namespace::clean -except => [ 'meta' ];

with 'Catalyst::ScriptRole';

has force => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'nonew',
        isa           => 'Bool',
        is            => 'ro',
        documentation => 'Force new scripts',
);

has debug => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'd',
        isa           => 'Bool',
        is            => 'ro',
        documentation => 'Force debug mode',
);

has mechanize => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'mech',
        isa           => 'Bool',
        is            => 'ro',
        documentation => 'use WWW::Mechanize',
);

has helper_class => (
        isa     => 'Str',
        is      => 'ro',
        builder => '_build_helper_class',
);

sub _build_helper_class {'Catalyst::Helper'}

sub run {
    my ($self) = @_;

    $self->print_usage_text if !$self->ARGV->[0];

    my $helper_class = $self->helper_class;
    load_class($helper_class);
    my $helper = $helper_class->new({ '.newfiles' => !$self->force, mech => $self->mechanize });

    $self->print_usage_text unless $helper->mk_component($self->application_name, @{$self->extra_argv});

}

__PACKAGE__->meta->make_immutable;
1;

=head1 NAME

Catalyst::Script::Create - Create a new Catalyst Component

=head1 SYNOPSIS

 myapp_create.pl [options] model|view|controller name [helper] [options]

 Options:
   --force        don't create a .new file where a file to be created exists
   --mechanize    use Test::WWW::Mechanize::Catalyst for tests if available
   --help         display this help and exits

 Examples:
   myapp_create.pl controller My::Controller
   myapp_create.pl controller My::Controller BindLex
   myapp_create.pl --mechanize controller My::Controller
   myapp_create.pl view My::View
   myapp_create.pl view MyView TT
   myapp_create.pl view TT TT
   myapp_create.pl model My::Model
   myapp_create.pl model SomeDB DBIC::Schema MyApp::Schema create=dynamic\
   dbi:SQLite:/tmp/my.db
   myapp_create.pl model AnotherDB DBIC::Schema MyApp::Schema create=static\
   dbi:Pg:dbname=foo root 4321

 See also:
   perldoc Catalyst::Manual
   perldoc Catalyst::Manual::Intro

=head1 DESCRIPTION

Create a new Catalyst Component.

Existing component files are not overwritten.  If any of the component files
to be created already exist the file will be written with a '.new' suffix.
This behavior can be suppressed with the C<--force> option.

=head1 SEE ALSO

L<Catalyst::ScriptRunner>

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software, you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

package Catalyst::Script::CGI;
use Moose;
use namespace::clean -except => [ 'meta' ];

sub _plack_engine_name {'CGI'}

with 'Catalyst::ScriptRole';

__PACKAGE__->meta->make_immutable;
1;

=head1 NAME

Catalyst::Script::CGI - The CGI Catalyst Script

=head1 SYNOPSIS

  myapp_cgi.pl [options]

  Options:
  -?     --help           display this help and exits

=head1 DESCRIPTION

This is a script to run the Catalyst engine specialized for the CGI environment.

=head1 SEE ALSO

L<Catalyst::ScriptRunner>

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
package Catalyst::Script::FastCGI;
use Moose;
use Data::OptList;
use namespace::clean -except => [ 'meta' ];

sub _plack_engine_name {'FCGI'}

with 'Catalyst::ScriptRole';

has listen => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'l',
        isa           => 'Str',
        is            => 'ro',
        documentation => 'Specify a listening port/socket',
);

has pidfile => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => [ qw/pid p/ ],
        isa           => 'Str',
        is            => 'ro',
        documentation => 'Specify a pidfile',
);

has daemon => (
        traits        => [ qw(Getopt) ],
        isa           => 'Bool',
        is            => 'ro',
        cmd_aliases   => [ qw/d detach/ ], # Eww, detach is here as we fucked it up.. Deliberately not documented
        documentation => 'Daemonize (go into the background)',
);

has manager => (
        traits        => [ qw(Getopt) ],
        isa           => 'Str',
        is            => 'ro',
        cmd_aliases   => 'M',
        documentation => 'Use a different FastCGI process manager class',
);

has keeperr => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'e',
        isa           => 'Bool',
        is            => 'ro',
        documentation => 'Log STDERR',
);

has nproc => (
        traits        => [ qw(Getopt) ],
        cmd_aliases   => 'n',
        isa           => 'Int',
        is            => 'ro',
        documentation => 'Specify a number of child processes',
);

has proc_title => (
        traits        => [ qw(Getopt) ],
        isa           => 'Str',
        is            => 'ro',
        lazy          => 1,
        builder       => '_build_proc_title',
        documentation => 'Set the process title',
);

sub _build_proc_title {
    my ($self) = @_;
    return sprintf 'perl-fcgi-pm [%s]', $self->application_name;
}

sub BUILD {
    my ($self) = @_;
    $self->proc_title;
}

# Munge the 'listen' arg so that Plack::Handler::FCGI will accept it.
sub _listen {
    my ($self) = @_;

    if (defined(my $listen = $self->listen)) {
        return [ $listen ];
    }
    else {
        return undef;
    }
}

sub _plack_loader_args {
    my ($self) = shift;

    my $opts = Data::OptList::mkopt([
            qw/manager nproc proc_title/,
            pid         => [ 'pidfile' ],
            daemonize   => [ 'daemon' ],
            keep_stderr => [ 'keeperr' ],
            listen      => [ '_listen' ],
    ]);

    my %args = map {$_->[0] => $self->${\($_->[1] ? $_->[1]->[0] : $_->[0])}} @$opts;

    # Plack::Handler::FCGI thinks manager => undef means "use no manager".
    delete $args{'manager'} unless defined $args{'manager'};

    return %args;
}

around _application_args => sub {
    my ($orig, $self) = @_;
    return (
            $self->listen,
            {
                    %{$self->$orig},
                    nproc       => $self->nproc,
                    pidfile     => $self->pidfile,
                    manager     => $self->manager,
                    detach      => $self->daemon,
                    keep_stderr => $self->keeperr,
                    proc_title  => $self->proc_title,
            }
    );
};

__PACKAGE__->meta->make_immutable;
1;

=head1 NAME

Catalyst::Script::FastCGI - The FastCGI Catalyst Script

=head1 SYNOPSIS

  myapp_fastcgi.pl [options]

 Options:
   -? --help       display this help and exits
   -l --listen     Socket path to listen on
                   (defaults to standard input)
                   can be HOST:PORT, :PORT or a
                   filesystem path
   -n --nproc      specify number of processes to keep
                   to serve requests (defaults to 1,
                   requires -listen)
   -p --pidfile    specify filename for pid file
                   (requires -listen)
   -d --daemon     daemonize (requires -listen)
   -M --manager    specify alternate process manager
                   (FCGI::ProcManager sub-class)
                   or empty string to disable
   -e --keeperr    send error messages to STDOUT, not
                   to the webserver
      --proc_title set the process title

=head1 DESCRIPTION

Run a Catalyst application as fastcgi.

=head1 SEE ALSO

L<Catalyst::ScriptRunner>

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
package Catalyst::ActionRole::Scheme;

use Moose::Role;

requires 'match', 'match_captures', 'list_extra_info';

around [ 'match', 'match_captures' ] => sub {
    my ($orig, $self, $ctx, @args) = @_;
    my $request_scheme = lc($ctx->req->env->{'psgi.url_scheme'});
    my $match_scheme = lc($self->scheme || '');

    return $request_scheme eq $match_scheme ? $self->$orig($ctx, @args) : 0;
};

around 'list_extra_info' => sub {
    my ($orig, $self, @args) = @_;
    return {
            %{$self->$orig(@args)},
            Scheme => $self->attributes->{Scheme}[0] || '',
    };
};

1;

=head1 NAME

Catalyst::ActionRole::Scheme - Match on HTTP Request Scheme

=head1 SYNOPSIS

    package MyApp::Web::Controller::MyController;

    use base 'Catalyst::Controller';

    sub is_http :Path(scheme) Scheme(http) Args(0) {
      my ($self, $c) = @_;
      Test::More::is $c->action->scheme, 'http';
      $c->response->body("is_http");
    }

    sub is_https :Path(scheme) Scheme(https) Args(0)  {
      my ($self, $c) = @_;
      Test::More::is $c->action->scheme, 'https';
      $c->response->body("is_https");
    }

    1;

=head1 DESCRIPTION

This is an action role that lets your L<Catalyst::Action> match on the scheme
type of the request.  Typically this is C<http> or C<https> but other common
schemes that L<Catalyst> can handle include C<ws> and C<wss> (web socket and web
socket secure).

This also ensures that if you use C<uri_for> on an action that specifies a
match scheme, that the generated L<URI> object sets its scheme to that automatically
(rather than the scheme of the current request object, which is and remains the
default behavior.)

For matching purposes, we match strings but the casing is insensitive.

=head1 REQUIRES

This role requires the following methods in the consuming class.

=head2 match

=head2 match_captures

Returns 1 if the action matches the existing request and zero if not.

=head1 METHODS

This role defines the following methods

=head2 match

=head2 match_captures

Around method modifier that return 1 if the scheme matches

=head2 list_extra_info

Add the scheme declaration if present to the debug screen.

=head1 AUTHORS

Catalyst Contributors, see L<Catalyst>

=head1 COPYRIGHT

See L<Catalyst>

=cut
package Catalyst::ActionRole::QueryMatching;

use Moose::Role;
use Moose::Util::TypeConstraints ();

requires 'match', 'match_captures', 'list_extra_info';

sub _query_attr {@{shift->attributes->{Query} || []}}

has is_slurpy => (
        is       => 'ro',
        init_arg => undef,
        isa      => 'Bool',
        required => 1,
        lazy     => 1,
        builder  => '_build_is_slurpy');

sub _build_is_slurpy {
    my $self = shift;
    my ($query, @extra) = $self->_query_attr;
    return $query =~ m/^.+,\.\.\.$/ ? 1 : 0;
}

has query_constraints => (
        is       => 'ro',
        init_arg => undef,
        isa      => 'ArrayRef|Ref',
        required => 1,
        lazy     => 1,
        builder  => '_build_query_constraints');

sub _build_query_constraints {
    my $self = shift;
    my ($constraint_proto, @extra) = $self->_query_attr;

    die "Action ${\$self->private_path} defines more than one 'Query' attribute" if scalar @extra;
    return +{} unless defined($constraint_proto);

    $constraint_proto =~ s/^(.+),\.\.\.$/$1/; # slurpy is handled elsewhere

    # Query may be a Hash like Query(p=>Int,q=>Str) OR it may be a Ref like
    # Query(Tuple[p=>Int, slurpy HashRef]).  The only way to figure is to eval it
    # and look at what we have.
    my @signature = eval "package ${\$self->class}; $constraint_proto"
            or die "'$constraint_proto' is not valid Query Contraint at action ${\$self->private_path}, error '$@'";

    if (scalar(@signature) > 1) {
        # Do a dance to support old school stringy types
        # At this point we 'should' have a hash...
        my %pairs = @signature;
        foreach my $key (keys %pairs) {
            next if ref $pairs{$key};
            $pairs{$key} = Moose::Util::TypeConstraints::find_or_parse_type_constraint($pairs{$key}) ||
                    die "'$pairs{$key}' is not a valid type constraint in Action ${\$self->private_path}";
        }
        return \%pairs;
    }
    else {
        # We have a 'reference type' constraint, like Dict[p=>Int,...]
        return $signature[0] if ref($signature[0]); # Is like Tiny::Type
        return Moose::Util::TypeConstraints::find_or_parse_type_constraint($signature[0]) ||
                die "'$signature[0]' is not a valid type constraint in Action ${\$self->private_path}";
    }
}

around [ 'match', 'match_captures' ] => sub {
    my ($orig, $self, $c, @args) = @_;
    my $tc = $self->query_constraints;
    if (ref $tc eq 'HASH') {
        # Do the key names match, unless slurpy?
        unless ($self->is_slurpy) {
            return 0 unless $self->_compare_arrays([ sort keys %$tc ], [ sort keys %{$c->req->query_parameters} ]);
        }
        for my $key (keys %$tc) {
            $tc->{$key}->check($c->req->query_parameters->{$key}) || return 0;
        }
    }
    else {
        $tc->check($c->req->query_parameters) || return 0;
    }

    return $self->$orig($c, @args);
};

around 'list_extra_info' => sub {
    my ($orig, $self, @args) = @_;
    return {
            %{$self->$orig(@args)},
    };
};

sub _compare_arrays {
    my ($self, $first, $second) = @_;
    no warnings; # silence spurious -w undef complaints
    return 0 unless @$first == @$second;
    for (my $i = 0; $i < @$first; $i++) {
        return 0 if $first->[$i] ne $second->[$i];
    }
    return 1;
}

1;

=head1 NAME

Catalyst::ActionRole::QueryMatching - Match on GET parameters using type constraints

=head1 SYNOPSIS

    TBD

=head1 DESCRIPTION

    TBD

=head1 METHODS

This role defines the following methods

=head2 TBD

    TBD

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
package Catalyst::ActionRole::ConsumesContent;

use Moose::Role;

requires 'match', 'match_captures', 'list_extra_info';

has allowed_content_types => (
        is       => 'ro',
        required => 1,
        lazy     => 1,
        isa      => 'ArrayRef',
        builder  => '_build_allowed_content_types');

has normalized => (
        is       => 'ro',
        required => 1,
        lazy     => 1,
        isa      => 'HashRef',
        builder  => '_build_normalized');

sub _build_normalized {
    return +{
            JSON       => 'application/json',
            JS         => 'application/javascript',
            PERL       => 'application/perl',
            HTML       => 'text/html',
            XML        => 'text/XML',
            Plain      => 'text/plain',
            UrlEncoded => 'application/x-www-form-urlencoded',
            Multipart  => 'multipart/form-data',
            HTMLForm   => [ 'application/x-www-form-urlencoded', 'multipart/form-data' ],
    };
}

sub _build_allowed_content_types {
    my $self = shift;
    my @proto = map {split ',', $_} @{$self->attributes->{Consumes}};
    my @converted = map {
        if (my $normalized = $self->normalized->{$_}) {
            ref $normalized ? @$normalized : ($normalized);
        }
        else {
            $_;
        }
    } @proto;

    return \@converted;
}

around [ 'match', 'match_captures' ] => sub {
    my ($orig, $self, $ctx, @args) = @_;
    if (my $content_type = $ctx->req->content_type) {
        return 0 unless $self->can_consume($content_type);
    }
    return $self->$orig($ctx, @args);
};

sub can_consume {
    my ($self, $request_content_type) = @_;
    my @matches = grep {lc($_) eq lc($request_content_type)}
            @{$self->allowed_content_types};
    return @matches ? 1 : 0;
}

around 'list_extra_info' => sub {
    my ($orig, $self, @args) = @_;
    return {
            %{$self->$orig(@args)},
            CONSUMES => $self->allowed_content_types,
    };
};

1;

=head1 NAME

Catalyst::ActionRole::ConsumesContent - Match on HTTP Request Content-Type

=head1 SYNOPSIS

    package MyApp::Web::Controller::MyController;

    use base 'Catalyst::Controller';

    sub start : POST Chained('/') CaptureArg(0) { ... }

      sub is_json       : Chained('start') Consumes('application/json') { ... }
      sub is_urlencoded : Chained('start') Consumes('application/x-www-form-urlencoded') { ... }
      sub is_multipart  : Chained('start') Consumes('multipart/form-data') { ... }

      ## Alternatively, for common types...

      sub is_json       : Chained('start') Consume(JSON) { ... }
      sub is_urlencoded : Chained('start') Consumes(UrlEncoded) { ... }
      sub is_multipart  : Chained('start') Consumes(Multipart) { ... }

      ## Or allow more than one type

      sub is_more_than_one
        : Chained('start')
        : Consumes('application/x-www-form-urlencoded')
        : Consumes('multipart/form-data')
      {
        ## ...
      }

      1;

=head1 DESCRIPTION

This is an action role that lets your L<Catalyst::Action> match on the content
type of the incoming request.

Generally when there's a PUT or POST request, there's a request content body
with a matching MIME content type.  Commonly this will be one of the types
used with classic HTML forms ('application/x-www-form-urlencoded' for example)
but there's nothing stopping you specifying any valid content type.

For matching purposes, we match strings but the casing is insensitive.

=head1 REQUIRES

This role requires the following methods in the consuming class.

=head2 match

=head2 match_captures

Returns 1 if the action matches the existing request and zero if not.

=head1 METHODS

This role defines the following methods

=head2 match

=head2 match_captures

Around method modifier that return 1 if the request content type matches one of the
allowed content types (see L</http_methods>) and zero otherwise.

=head2 allowed_content_types

An array of strings that are the allowed content types for matching this action.

=head2 can_consume

Boolean.  Does the current request match content type with what this actionrole
can consume?

=head2 list_extra_info

Add the accepted content type to the debug screen.

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
package Catalyst::ActionRole::HTTPMethods;

use Moose::Role;

requires 'match', 'match_captures', 'list_extra_info';

sub allowed_http_methods {@{shift->attributes->{Method} || []}}

sub _has_expected_http_method {
    my ($self, $expected) = @_;
    return 1 unless scalar(my @allowed = $self->allowed_http_methods);
    return scalar(grep {lc($_) eq lc($expected)} @allowed) ?
            1 : 0;
}

around [ 'match', 'match_captures' ] => sub {
    my ($orig, $self, $ctx, @args) = @_;
    return 0 unless $self->$orig($ctx, @args);

    my $expected = $ctx->req->method;
    return $self->_has_expected_http_method($expected);
};

around 'list_extra_info' => sub {
    my ($orig, $self, @args) = @_;
    return {
            %{$self->$orig(@args)},
            HTTP_METHODS => [ sort $self->allowed_http_methods ],
    };
};

1;

=head1 NAME

Catalyst::ActionRole::HTTPMethods - Match on HTTP Methods

=head1 SYNOPSIS

    package MyApp::Web::Controller::MyController;

    use Moose;
    use MooseX::MethodAttributes;

    extends 'Catalyst::Controller';

    sub user_base : Chained('/') CaptureArg(0) { ... }

      sub get_user     : Chained('user_base') Args(1) GET { ... }
      sub post_user    : Chained('user_base') Args(1) POST { ... }
      sub put_user     : Chained('user_base') Args(1) PUT { ... }
      sub delete_user  : Chained('user_base') Args(1) DELETE { ... }
      sub head_user    : Chained('user_base') Args(1) HEAD { ... }
      sub options_user : Chained('user_base') Args(1) OPTIONS { ... }
      sub patch_user   : Chained('user_base') Args(1) PATCH { ... }


      sub post_and_put : Chained('user_base') POST PUT Args(1) { ... }
      sub method_attr  : Chained('user_base') Method('DELETE') Args(0) { ... }

    __PACKAGE__->meta->make_immutable;

=head1 DESCRIPTION

This is an action role that lets your L<Catalyst::Action> match on standard
HTTP methods, such as GET, POST, etc.

Since most web browsers have limited support for rich HTTP Method vocabularies
we use L<Plack::Middleware::MethodOverride> which allows you to 'tunnel' your
request method over POST  This works in two ways.  You can set an extension
HTTP header C<X-HTTP-Method-Override> which will contain the value of the
desired request method, or you may set a search query parameter
C<x-tunneled-method>.  Remember, these only work over HTTP Request type
POST.  See L<Plack::Middleware::MethodOverride> for more.

=head1 REQUIRES

This role requires the following methods in the consuming class.

=head2 match

=head2 match_captures

Returns 1 if the action matches the existing request and zero if not.

=head1 METHODS

This role defines the following methods

=head2 match

=head2 match_captures

Around method modifier that return 1 if the request method matches one of the
allowed methods (see L</http_methods>) and zero otherwise.

=head2 allowed_http_methods

An array of strings that are the allowed http methods for matching this action
normalized as noted above (using X-Method* overrides).

=head2 list_extra_info

Adds a key => [@values] "HTTP_METHODS" whose value is an ArrayRef of sorted
allowed methods to the ->list_extra_info HashRef.  This is used primarily for
debugging output.

=head2 _has_expected_http_method ($expected)

Private method which returns 1 if C<$expected> matches one of the allowed
in L</http_methods> and zero otherwise.

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
package Catalyst::Exception::Detach;

use Moose;
use namespace::clean -except => 'meta';

with 'Catalyst::Exception::Basic';

has '+message' => (
        default => "catalyst_detach\n",
);

__PACKAGE__->meta->make_immutable;

1;

package Catalyst::Exception::Basic;

use Moose::Role;
use Carp;
use namespace::clean -except => 'meta';

with 'Catalyst::Exception::Interface';

has message => (
        is      => 'ro',
        isa     => 'Str',
        default => sub {$! || ''},
);

sub as_string {
    my ($self) = @_;
    return $self->message;
}

around BUILDARGS => sub {
    my ($next, $class, @args) = @_;
    if (@args == 1 && !ref $args[0]) {
        @args = (message => $args[0]);
    }

    my $args = $class->$next(@args);
    $args->{message} ||= $args->{error}
            if exists $args->{error};

    return $args;
};

sub throw {
    my $class = shift;
    my $error = $class->new(@_);
    local $Carp::CarpLevel = 1;
    croak $error;
}

sub rethrow {
    my ($self) = @_;
    croak $self;
}

1;

=head1 NAME

Catalyst::Exception::Basic - Basic Catalyst Exception Role

=head1 SYNOPSIS

   package My::Exception;
   use Moose;
   use namespace::clean -except => 'meta';

   with 'Catalyst::Exception::Basic';

   # Elsewhere..
   My::Exception->throw( qq/Fatal exception/ );

See also L<Catalyst> and L<Catalyst::Exception>.

=head1 DESCRIPTION

This is the basic Catalyst Exception role which implements all of
L<Catalyst::Exception::Interface>.

=head1 ATTRIBUTES

=head2 message

Holds the exception message.

=head1 METHODS

=head2 as_string

Stringifies the exception's message attribute.
Called when the object is stringified by overloading.

=head2 throw( $message )

=head2 throw( message => $message )

=head2 throw( error => $error )

Throws a fatal exception.

=head2 rethrow( $exception )

Rethrows a caught exception.

=head2 meta

Provided by Moose

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
package Catalyst::Exception::Go;

use Moose;
use namespace::clean -except => 'meta';

with 'Catalyst::Exception::Basic';

has '+message' => (
        default => "catalyst_go\n",
);

__PACKAGE__->meta->make_immutable;

1;

package Catalyst::Exception::Interface;

use Moose::Role;
use namespace::clean -except => 'meta';

use overload
        q{""}    => sub {$_[0]->as_string},
        fallback => 1;

requires qw/as_string throw rethrow/;

1;

package Catalyst::Request::PartData;

use Moose;
use HTTP::Headers;
use Encode;

has [ qw/raw_data name size/ ] => (is => 'ro', required => 1);

has headers => (
        is       => 'ro',
        required => 1,
        handles  => [ qw/content_type content_encoding content_type_charset/ ]);

sub build_from_part_data {
    my ($class, $c, $part_data) = @_;

    # If the headers are complex, we need to work harder to figure out what to do
    if (my $hdrs = $class->part_data_has_complex_headers($part_data)) {

        # Ok so its one of two possibilities.  If I can inspect the headers and
        # Figure out what to do, the I will return data.  Otherwise I will return
        # a PartData object and expect you do deal with it.
        # For now if I can find a charset in the content type I will just decode and
        # assume I got it right (patches and bug reports welcomed).

        # Any of these headers means I can't decode

        if (
                $hdrs->content_encoding
        ) {
            return $class->new(
                    raw_data => $part_data->{data},
                    name     => $part_data->{name},
                    size     => $part_data->{size},
                    headers  => HTTP::Headers->new(%{$part_data->{headers}}));
        }

        my ($ct, $charset) = $hdrs->content_type_charset;

        if ($ct) {
            # Good news, we probably have data we can return.  If there is a charset
            # then use that to decode otherwise use the default decoding.
            if ($charset) {
                return Encode::decode($charset, $part_data->{data})
            }
            else {
                if ($c and $c->encoding and !$c->config->{skip_body_param_unicode_decoding}) {
                    return $c->_handle_param_unicode_decoding($part_data->{data});
                }
                else {
                    return $part_data->{data}
                }
            }
        }
        else {
            # I have no idea what to do with this now..
            return $class->new(
                    raw_data => $part_data->{data},
                    name     => $part_data->{name},
                    size     => $part_data->{size},
                    headers  => HTTP::Headers->new(%{$part_data->{headers}}));
        }
    }
    else {
        if ($c and $c->encoding and !$c->config->{skip_body_param_unicode_decoding}) {
            return $c->_handle_param_unicode_decoding($part_data->{data});
        }
        else {
            return $part_data->{data}
        }
    }

    return $part_data->{data} unless $class->part_data_has_complex_headers($part_data);
    return $class->new(
            raw_data => $part_data->{data},
            name     => $part_data->{name},
            size     => $part_data->{size},
            headers  => HTTP::Headers->new(%{$part_data->{headers}}));
}

sub part_data_has_complex_headers {
    my ($class, $part_data) = @_;
    my %h = %{$part_data->{headers}};
    my $hdrs = HTTP::Headers->new(%h);

    # Remove non threatening headers.
    $hdrs->remove_header('Content-Length', 'Expires', 'Last-Modified', 'Content-Language');

    # If we still have more than one (Content-Disposition) header we need to understand
    # that and deal with it.

    return $hdrs->header_field_names > 1 ? $hdrs : 0;
}

__PACKAGE__->meta->make_immutable;

=head1 NAME

Catalyst::Request::Upload - handles file upload requests

=head1 SYNOPSIS

    my $data_part =

To specify where Catalyst should put the temporary files, set the 'uploadtmp'
option in the Catalyst config. If unset, Catalyst will use the system temp dir.

    __PACKAGE__->config( uploadtmp => '/path/to/tmpdir' );

See also L<Catalyst>.

=head1 DESCRIPTION

=head1 ATTRIBUTES

This class defines the following immutable attributes

=head2 raw_data

The raw data as returned via L<HTTP::Body>.

=head2 name

The part name that gets extracted from the content-disposition header.

=head2 size

The raw byte count (over http) of the data.  This is not the same as the character
length

=head2 headers

An L<HTTP::Headers> object that represents the submitted headers of the POST.  This
object will handle the following methods:

=head3 content_type

=head3 content_encoding

=head3 content_type_charset

These three methods are the same as methods described in L<HTTP::Headers>.

=head1 METHODS

=head2 build_from_part_data

Factory method to build an object from part data returned by L<HTTP::Body>

=head2 part_data_has_complex_headers

Returns true if there more than one header (indicates the part data is complex and
contains content type and encoding information.).

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
package Catalyst::Request::Upload;

use Moose;
with 'MooseX::Emulate::Class::Accessor::Fast';

use Catalyst::Exception;
use File::Copy ();
use IO::File ();
use File::Spec::Unix;
use PerlIO::utf8_strict;
use namespace::clean -except => 'meta';

has filename => (is => 'rw');
has headers => (is => 'rw');
has size => (is => 'rw');
has tempname => (is => 'rw');
has type => (is => 'rw');
has basename => (is => 'ro', lazy_build => 1);
has raw_basename => (is => 'ro', lazy_build => 1);
has charset => (is => 'ro', predicate => 'has_charset');

has fh => (
        is       => 'rw',
        required => 1,
        lazy     => 1,
        default  => sub {
            my $self = shift;

            my $fh = IO::File->new($self->tempname, IO::File::O_RDONLY);
            unless (defined $fh) {
                my $filename = $self->tempname;
                Catalyst::Exception->throw(
                        message => qq/Can't open '$filename': '$!'/);
            }
            return $fh;
        },
);

sub _build_basename {
    my $basename = shift->raw_basename;
    $basename =~ s|[^\w\.-]+|_|g;
    return $basename;
}

sub _build_raw_basename {
    my $self = shift;
    my $basename = $self->filename;
    $basename =~ s|\\|/|g;
    $basename = (File::Spec::Unix->splitpath($basename))[2];
    return $basename;
}

no Moose;

=for stopwords uploadtmp

=head1 NAME

Catalyst::Request::Upload - handles file upload requests

=head1 SYNOPSIS

    my $upload = $c->req->upload('field');

    $upload->basename;
    $upload->copy_to;
    $upload->fh;
    $upload->decoded_fh
    $upload->filename;
    $upload->headers;
    $upload->link_to;
    $upload->size;
    $upload->slurp;
    $upload->decoded_slurp;
    $upload->tempname;
    $upload->type;
    $upload->charset;

To specify where Catalyst should put the temporary files, set the 'uploadtmp'
option in the Catalyst config. If unset, Catalyst will use the system temp dir.

    __PACKAGE__->config( uploadtmp => '/path/to/tmpdir' );

See also L<Catalyst>.

=head1 DESCRIPTION

This class provides accessors and methods to handle client upload requests.

=head1 METHODS

=head2 $upload->new

Simple constructor.

=head2 $upload->copy_to

Copies the temporary file using L<File::Copy>. Returns true for success,
false for failure.

     $upload->copy_to('/path/to/target');

Please note the filename used for the copy target is the 'tempname' that
is the actual filename on the filesystem, NOT the 'filename' that was
part of the upload headers.  This might seem counter intuitive but at this
point this behavior is so established that its not something we can change.

You can always create your own copy routine that munges the target path
as you wish.

=cut

sub copy_to {
    my $self = shift;
    return File::Copy::copy($self->tempname, @_);
}

=head2 $upload->is_utf8_encoded

Returns true of the upload defines a character set at that value is 'UTF-8'.
This does not try to inspect your upload and make any guesses if the Content
Type charset is undefined.

=cut

sub is_utf8_encoded {
    my $self = shift;
    if (my $charset = $self->charset) {
        return $charset eq 'UTF-8' ? 1 : 0;
    }
    return 0;
}

=head2 $upload->fh

Opens a temporary file (see tempname below) and returns an L<IO::File> handle.

This is a filehandle that is opened with no additional IO Layers.

=head2 $upload->decoded_fh(?$encoding)

Returns a filehandle that has binmode set to UTF-8 if a UTF-8 character set
is found. This also accepts an override encoding value that you can use to
force a particular L<PerlIO> layer.  If neither are found the filehandle is
set to :raw.

This is useful if you are pulling the file into code and inspecting bits and
maybe then sending those bits back as the response.  (Please note this is not
a suitable filehandle to set in the body; use C<fh> if you are doing that).

Please note that using this method sets the underlying filehandle IO layer
so once you use this method if you go back and use the C<fh> method you
still get the IO layer applied.

=cut

sub decoded_fh {
    my ($self, $layer) = @_;
    my $fh = $self->fh;

    $layer = ':utf8_strict' if !$layer && $self->is_utf8_encoded;
    $layer = ':raw' unless $layer;

    binmode($fh, $layer);
    return $fh;
}

=head2 $upload->filename

Returns the client-supplied filename.

=head2 $upload->headers

Returns an L<HTTP::Headers> object for the request.

=head2 $upload->link_to

Creates a hard link to the temporary file. Returns true for success,
false for failure.

    $upload->link_to('/path/to/target');

=cut

sub link_to {
    my ($self, $target) = @_;
    return CORE::link($self->tempname, $target);
}

=head2 $upload->size

Returns the size of the uploaded file in bytes.

=head2 $upload->slurp(?$encoding)

Optionally accepts an argument to define an IO Layer (which is applied to
the filehandle via binmode; if no layer is defined the default is set to
":raw".

Returns a scalar containing the contents of the temporary file.

Note that this will cause the filehandle pointed to by C<< $upload->fh >> to
be reset to the start of the file using seek and the file handle to be put
into whatever encoding mode is applied.

=cut

sub slurp {
    my ($self, $layer) = @_;

    unless ($layer) {
        $layer = ':raw';
    }

    my $content = '';
    my $handle = $self->fh;

    binmode($handle, $layer);

    $handle->seek(0, IO::File::SEEK_SET);

    if ($layer eq ':raw') {
        while ($handle->sysread(my $buffer, 8192)) {
            $content .= $buffer;
        }
    }
    else {
        $content = do {
            local $/;
            $handle->getline
        };
    }

    $handle->seek(0, IO::File::SEEK_SET);
    return $content;
}

=head2 $upload->decoded_slurp(?$encoding)

Works just like C<slurp> except we use C<decoded_fh> instead of C<fh> to
open a filehandle to slurp.  This means if your upload charset is UTF8
we binmode the filehandle to that encoding.

=cut

sub decoded_slurp {
    my ($self, $layer) = @_;
    my $handle = $self->decoded_fh($layer);

    $handle->seek(0, IO::File::SEEK_SET);

    my $content = do {
        local $/;
        $handle->getline
    };

    $handle->seek(0, IO::File::SEEK_SET);
    return $content;
}

=head2 $upload->basename

Returns basename for C<filename>.  This filters the name through a regexp
C<basename =~ s|[^\w\.-]+|_|g> to make it safe for filesystems that don't
like advanced characters.  This will of course filter UTF8 characters.
If you need the exact basename unfiltered use C<raw_basename>.

=head2 $upload->raw_basename

Just like C<basename> but without filtering the filename for characters that
don't always write to a filesystem.

=head2 $upload->tempname

Returns the path to the temporary file.

=head2 $upload->type

Returns the client-supplied Content-Type.

=head2 $upload->charset

The character set information part of the content type, if any.  Useful if you
need to figure out any encodings on the file upload.

=head2 meta

Provided by Moose

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

__PACKAGE__->meta->make_immutable;

1;
package Catalyst::Base;
use Moose;
BEGIN {extends 'Catalyst::Controller'}

after 'BUILD' => sub {
    my $self = shift;
    warn(ref($self) . " is using the deprecated Catalyst::Base, update your application as this will be removed in the next major release");
};

no Moose;

__PACKAGE__->meta->make_immutable;

1;

package Catalyst::Exception;

# XXX: See bottom of file for Exception implementation

=head1 NAME

Catalyst::Exception - Catalyst Exception Class

=head1 SYNOPSIS

   Catalyst::Exception->throw( qq/Fatal exception/ );

See also L<Catalyst>.

=head1 DESCRIPTION

This is the Catalyst Exception class.

=head1 METHODS

=head2 throw( $message )

=head2 throw( message => $message )

=head2 throw( error => $error )

Throws a fatal exception.

=head2 meta

Provided by Moose

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

{
    package Catalyst::Exception::Base;

    use Moose;
    use namespace::clean -except => 'meta';

    with 'Catalyst::Exception::Basic';

    __PACKAGE__->meta->make_immutable;
}

{
    package Catalyst::Exception;

    use Moose;
    use namespace::clean -except => 'meta';

    use vars qw[$CATALYST_EXCEPTION_CLASS];

    BEGIN {
        extends ($CATALYST_EXCEPTION_CLASS || 'Catalyst::Exception::Base');
    }

    __PACKAGE__->meta->make_immutable;
}

1;
package Catalyst::DispatchType;

use Moose;
with 'MooseX::Emulate::Class::Accessor::Fast';
no Moose;

=head1 NAME

Catalyst::DispatchType - DispatchType Base Class

=head1 SYNOPSIS

See L<Catalyst>.

=head1 DESCRIPTION

This is an abstract base class for Dispatch Types.

From a code perspective, dispatch types are used to find which actions
to call for a given request URL.  Website authors will typically work
with them via subroutine names attributes; a description of dispatch
at the attribute/URL level is given in L<Catalyst::Manual::Intro>.

=head1 METHODS

=head2 $self->list($c)

abstract method, to be implemented by dispatchtypes. Called to display
info in debug log.

=cut

sub list {}

=head2 $self->match( $c, $path )

abstract method, to be implemented by dispatchtypes. Returns true if the
dispatch type matches the given path

=cut

sub match {die "Abstract method!"}

=head2 $self->register( $c, $action )

abstract method, to be implemented by dispatchtypes. Takes a
context object and a L<Catalyst::Action> object.

Should return true if it registers something, or false otherwise.

=cut

sub register {}

=head2 $self->uri_for_action( $action, \@captures )

abstract method, to be implemented by dispatchtypes. Takes a
L<Catalyst::Action> object and an arrayref of captures, and should
return either a URI part which if placed in $c->req->path would cause
$self->match to match this action and set $c->req->captures to the supplied
arrayref, or undef if unable to do so.

=cut

sub uri_for_action {}

=head2 $self->expand_action

Default fallback, returns nothing. See L<Catalyst::Dispatcher> for more info
about expand_action.

=cut

sub expand_action {}

sub _is_low_precedence {0}

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

__PACKAGE__->meta->make_immutable;

1;
package Catalyst::Utils;
use strict;
use warnings;

use File::Spec;
use HTTP::Request;
use Path::Class;
use URI;
use Carp qw/croak/;
use Cwd;
use Class::Load 'is_class_loaded';
use String::RewritePrefix;
use Class::Load ();
use namespace::clean;
use Devel::InnerPackage;
use Moose::Util;

=head1 NAME

Catalyst::Utils - The Catalyst Utils

=head1 SYNOPSIS

See L<Catalyst>.

=head1 DESCRIPTION

Catalyst Utilities.

=head1 METHODS

=head2 appprefix($class)

    MyApp::Foo becomes myapp_foo

=cut

sub appprefix {
    my $class = shift;
    $class =~ s/::/_/g;
    $class = lc($class);
    return $class;
}

=head2 class2appclass($class);

    MyApp::Controller::Foo::Bar becomes MyApp
    My::App::Controller::Foo::Bar becomes My::App

=cut

sub class2appclass {
    my $class = shift || '';
    my $appname = '';
    if ($class =~ /^(.+?)::([MVC]|Model|View|Controller)::.+$/) {
        $appname = $1;
    }
    return $appname;
}

=head2 class2classprefix($class);

    MyApp::Controller::Foo::Bar becomes MyApp::Controller
    My::App::Controller::Foo::Bar becomes My::App::Controller

=cut

sub class2classprefix {
    my $class = shift || '';
    my $prefix;
    if ($class =~ /^(.+?::([MVC]|Model|View|Controller))::.+$/) {
        $prefix = $1;
    }
    return $prefix;
}

=head2 class2classsuffix($class);

    MyApp::Controller::Foo::Bar becomes Controller::Foo::Bar

=cut

sub class2classsuffix {
    my $class = shift || '';
    my $prefix = class2appclass($class) || '';
    $class =~ s/$prefix\:://;
    return $class;
}

=head2 class2env($class);

Returns the environment name for class.

    MyApp becomes MYAPP
    My::App becomes MY_APP

=cut

sub class2env {
    my $class = shift || '';
    $class =~ s/::/_/g;
    return uc($class);
}

=head2 class2prefix( $class, $case );

Returns the uri prefix for a class. If case is false the prefix is converted to lowercase.

    My::App::Controller::Foo::Bar becomes foo/bar

=cut

sub class2prefix {
    my $class = shift || '';
    my $case = shift || 0;
    my $prefix;
    if ($class =~ /^.+?::([MVC]|Model|View|Controller)::(.+)$/) {
        $prefix = $case ? $2 : lc $2;
        $prefix =~ s{::}{/}g;
    }
    return $prefix;
}

=head2 class2tempdir( $class [, $create ] );

Returns a tempdir for a class. If create is true it will try to create the path.

    My::App becomes /tmp/my/app
    My::App::Controller::Foo::Bar becomes /tmp/my/app/c/foo/bar

=cut

sub class2tempdir {
    my $class = shift || '';
    my $create = shift || 0;
    my @parts = split '::', lc $class;

    my $tmpdir = dir(File::Spec->tmpdir, @parts)->cleanup;

    if ($create && !-e $tmpdir) {

        eval {
            $tmpdir->mkpath;
            1
        }
                or do {
            # don't load Catalyst::Exception as a BEGIN in Utils,
            # because Utils often gets loaded before MyApp.pm, and if
            # Catalyst::Exception is loaded before MyApp.pm, it does
            # not honor setting
            # $Catalyst::Exception::CATALYST_EXCEPTION_CLASS in
            # MyApp.pm
            require Catalyst::Exception;
            Catalyst::Exception->throw(
                    message => qq/Couldn't create tmpdir '$tmpdir', "$@"/);
        }
    }

    return $tmpdir->stringify;
}

=head2 home($class)

Returns home directory for given class.

=head2 dist_indicator_file_list

Returns a list of files which can be tested to check if you're inside
a CPAN distribution which is not yet installed.

These are:

=over

=item Makefile.PL

=item Build.PL

=item dist.ini

=item L<cpanfile>

=back

=cut

sub dist_indicator_file_list {
    qw{Makefile.PL Build.PL dist.ini cpanfile};
}

sub home {
    my $class = shift;

    # make an $INC{ $key } style string from the class name
    (my $file = "$class.pm") =~ s{::}{/}g;

    if (my $inc_entry = $INC{$file}) {
        {
            # look for an uninstalled Catalyst app

            # find the @INC entry in which $file was found
            (my $path = $inc_entry) =~ s/$file$//;
            $path ||= cwd() if !defined $path || !length $path;
            my $home = dir($path)->absolute->cleanup;

            # pop off /lib and /blib if they're there
            $home = $home->parent while $home =~ /b?lib$/;

            # only return the dir if it has a Makefile.PL or Build.PL or dist.ini
            if (grep {-f $home->file($_)} dist_indicator_file_list()) {
                # clean up relative path:
                # MyApp/script/.. -> MyApp

                my $dir;
                my @dir_list = $home->dir_list();
                while (($dir = pop(@dir_list)) && $dir eq '..') {
                    $home = dir($home)->parent->parent;
                }

                return $home->stringify;
            }
        }

        {
            # look for an installed Catalyst app

            # trim the .pm off the thing ( Foo/Bar.pm -> Foo/Bar/ )
            (my $path = $inc_entry) =~ s/\.pm$//;
            my $home = dir($path)->absolute->cleanup;

            # return if it's a valid directory
            return $home->stringify if -d $home;
        }
    }

    # we found nothing
    return 0;
}

=head2 prefix($class, $name);

Returns a prefixed action.

    MyApp::Controller::Foo::Bar, yada becomes foo/bar/yada

=cut

sub prefix {
    my ($class, $name) = @_;
    my $prefix = &class2prefix($class);
    $name = "$prefix/$name" if $prefix;
    return $name;
}

=head2 request($uri)

Returns an L<HTTP::Request> object for a uri.

=cut

sub request {
    my $request = shift;
    unless (ref $request) {
        if ($request =~ m/^http/i) {
            $request = URI->new($request);
        }
        else {
            $request = URI->new('http://localhost' . $request);
        }
    }
    unless (ref $request eq 'HTTP::Request') {
        $request = HTTP::Request->new('GET', $request);
    }
    return $request;
}

=head2 ensure_class_loaded($class_name, \%opts)

Loads the class unless it already has been loaded.

If $opts{ignore_loaded} is true always tries the require whether the package
already exists or not. Only pass this if you're either (a) sure you know the
file exists on disk or (b) have code to catch the file not found exception
that will result if it doesn't.

=cut

sub ensure_class_loaded {
    my $class = shift;
    my $opts = shift;

    croak "Malformed class Name $class"
            if $class =~ m/(?:\b\:\b|\:{3,})/;

    croak "Malformed class Name $class"
            if $class =~ m/[^\w:]/;

    croak "ensure_class_loaded should be given a classname, not a filename ($class)"
            if $class =~ m/\.pm$/;

    # $opts->{ignore_loaded} can be set to true, and this causes the class to be required, even
    # if it already has symbol table entries. This is to support things like Schema::Loader, which
    # part-generate classes in memory, but then also load some of their contents from disk.
    return if !$opts->{ ignore_loaded }
            && is_class_loaded($class); # if a symbol entry exists we don't load again

    # this hack is so we don't overwrite $@ if the load did not generate an error
    my $error;
    {
        local $@;
        my $file = $class . '.pm';
        $file =~ s{::}{/}g;
        eval {CORE::require($file)};
        $error = $@;
    }

    die $error if $error;

    warn "require $class was successful but the package is not defined."
            unless is_class_loaded($class);

    return 1;
}

=head2 merge_hashes($hashref, $hashref)

Base code to recursively merge two hashes together with right-hand precedence.

=cut

sub merge_hashes {
    my ($lefthash, $righthash) = @_;

    return $lefthash unless defined $righthash;

    my %merged = %$lefthash;
    for my $key (keys %$righthash) {
        my $right_ref = (ref $righthash->{ $key } || '') eq 'HASH';
        my $left_ref = ((exists $lefthash->{ $key } && ref $lefthash->{ $key }) || '') eq 'HASH';
        if ($right_ref and $left_ref) {
            $merged{ $key } = merge_hashes(
                    $lefthash->{ $key }, $righthash->{ $key }
            );
        }
        else {
            $merged{ $key } = $righthash->{ $key };
        }
    }

    return \%merged;
}

=head2 env_value($class, $key)

Checks for and returns an environment value. For instance, if $key is
'home', then this method will check for and return the first value it finds,
looking at $ENV{MYAPP_HOME} and $ENV{CATALYST_HOME}.

=cut

sub env_value {
    my ($class, $key) = @_;

    $key = uc($key);
    my @prefixes = (class2env($class), 'CATALYST');

    for my $prefix (@prefixes) {
        if (defined(my $value = $ENV{"${prefix}_${key}"})) {
            return $value;
        }
    }

    return;
}

=head2 term_width

Try to guess terminal width to use with formatting of debug output

All you need to get this work, is:

1) Install Term::Size::Any, or

2) Export $COLUMNS from your shell.

(Warning to bash users: 'echo $COLUMNS' may be showing you the bash
variable, not $ENV{COLUMNS}. 'export COLUMNS=$COLUMNS' and you should see
that 'env' now lists COLUMNS.)

As last resort, default value of 80 chars will be used.

Calling C<term_width> with a true value will cause it to be recalculated; you
can use this to cause it to get recalculated when your terminal is resized like
this

 $SIG{WINCH} = sub { Catalyst::Utils::term_width(1) };

=cut

my $_term_width;
my $_use_term_size_any;

sub term_width {
    my $force_reset = shift;

    undef $_term_width if $force_reset;

    return $_term_width if $_term_width;

    if ($ENV{COLUMNS} && $ENV{COLUMNS} =~ /\A\d+\z/) {
        return $_term_width = $ENV{COLUMNS};
    }

    if (!-t STDOUT && !-t STDERR) {
        return $_term_width = 80;
    }

    if (!defined $_use_term_size_any) {
        eval {
            require Term::Size::Any;
            Term::Size::Any->import();
            $_use_term_size_any = 1;
            1;
        } or do {
            if ($@ =~ m[Can't locate Term/Size/Any\.pm]) {
                warn "Term::Size::Any is not installed, can't autodetect terminal column width\n";
            }
            else {
                warn "There was an error trying to detect your terminal size: $@\n";
            }
            $_use_term_size_any = 0;
        };
    }

    my $width;

    if ($_use_term_size_any) {
        $width = Term::Size::Any::chars(*STDERR) || Term::Size::Any::chars(*STDOUT);
    }

    if (!$width || $width < 80) {
        $width = 80;
    }

    return $_term_width = $width;
}


=head2 resolve_namespace

Method which adds the namespace for plugins and actions.

  __PACKAGE__->setup(qw(MyPlugin));

  # will load Catalyst::Plugin::MyPlugin

=cut


sub resolve_namespace {
    my $appnamespace = shift;
    my $namespace = shift;
    my @classes = @_;
    return String::RewritePrefix->rewrite({
            q[]  => qq[${namespace}::],
            q[+] => q[],
            (defined $appnamespace
                    ? (q[~] => qq[${appnamespace}::])
                    : ()
            ),
    }, @classes);
}

=head2 build_middleware (@args)

Internal application that converts a single middleware definition (see
L<Catalyst/psgi_middleware>) into an actual instance of middleware.

=cut

sub build_middleware {
    my ($class, $namespace, @init_args) = @_;

    if (
            $namespace =~ s/^\+// ||
                    $namespace =~ /^Plack::Middleware/ ||
                    $namespace =~ /^$class/
    ) { ## the string is a full namespace
        return Class::Load::try_load_class($namespace) ?
                $namespace->new(@init_args) :
                die "Can't load class $namespace";
    }
    else { ## the string is a partial namespace
        if (Class::Load::try_load_class($class . '::Middleware::' . $namespace)) {
           ## Load Middleware from Project namespace
            my $ns = $class . '::Middleware::' . $namespace;
            return $ns->new(@init_args);
        }
        elsif (Class::Load::try_load_class("Plack::Middleware::$namespace")) { ## Act like Plack::Builder
            return "Plack::Middleware::$namespace"->new(@init_args);
        }
        else {
            die "Can't load middleware via '$namespace'.  It's not " . $class . "::Middleware::" . $namespace . " or Plack::Middleware::$namespace";
        }
    }

    return; ## be sure we can count on a proper return when valid
}

=head2 apply_registered_middleware ($psgi)

Given a $psgi reference, wrap all the L<Catalyst/registered_middlewares>
around it and return the wrapped version.

This exists to deal with the fact Catalyst registered middleware can be
either an object with a wrap method or a coderef.

=cut

sub apply_registered_middleware {
    my ($class, $psgi) = @_;
    my $new_psgi = $psgi;
    foreach my $middleware ($class->registered_middlewares) {
        $new_psgi = Scalar::Util::blessed $middleware ?
                $middleware->wrap($new_psgi) :
                $middleware->($new_psgi);
    }
    return $new_psgi;
}

=head2 inject_component

Used to add components at runtime:

    into        The Catalyst package to inject into (e.g. My::App)
    component   The component package to inject
    traits      (Optional) ArrayRef of L<Moose::Role>s that the component should consume.
    as          An optional moniker to use as the package name for the derived component

For example:

    Catalyst::Utils::inject_component( into => My::App, component => Other::App::Controller::Apple )

        The above will create 'My::App::Controller::Other::App::Controller::Apple'

    Catalyst::Utils::inject_component( into => My::App, component => Other::App::Controller::Apple, as => Apple )

        The above will create 'My::App::Controller::Apple'

    Catalyst::Utils::inject_component( into => $myapp, component => 'MyRootV', as => 'Controller::Root' );

Will inject Controller, Model, and View components into your Catalyst application
at setup (run)time. It does this by creating a new package on-the-fly, having that
package extend the given component, and then having Catalyst setup the new component
(via $app->setup_component).

B<NOTE:> This is basically a core version of L<CatalystX::InjectComponent>.  If you were using that
you can now use this safely instead.  Going forward changes required to make this work will be
synchronized with the core method.

B<NOTE:> The 'traits' option is unique to the L<Catalyst::Utils> version of this feature.

B<NOTE:> These injected components really need to be a L<Catalyst::Component> and a L<Moose>
based class.

=cut

sub inject_component {
    my %given = @_;
    my ($into, $component, $as) = @given{qw/into component as/};

    croak "No Catalyst (package) given" unless $into;
    croak "No component (package) given" unless $component;

    Class::Load::load_class($component);

    $as ||= $component;
    unless ($as =~ m/^(?:Controller|Model|View)::/ || $given{skip_mvc_renaming}) {
        my $category;
        for (qw/Controller Model View/) {
            if ($component->isa("Catalyst::$_")) {
                $category = $_;
                last;
            }
        }
        croak "Don't know what kind of component \"$component\" is" unless $category;
        $as = "${category}::$as";
    }
    my $component_package = join '::', $into, $as;

    unless (Class::Load::is_class_loaded $component_package) {
        eval "package $component_package; use base qw/$component/; 1;" or
                croak "Unable to build component package for \"$component_package\": $@";
        Moose::Util::apply_all_roles($component_package, @{$given{traits}}) if $given{traits};
        (my $file = "$component_package.pm") =~ s{::}{/}g;
        $INC{$file} ||= 1;
    }

    my $_setup_component = sub {
        my $into = shift;
        my $component_package = shift;
        $into->components->{$component_package} = $into->delayed_setup_component($component_package);
    };

    $_setup_component->($into, $component_package);
}

=head1 PSGI Helpers

Utility functions to make it easier to work with PSGI applications under Catalyst

=head2 env_at_path_prefix

Localize C<$env> under the current controller path prefix:

    package MyApp::Controller::User;

    use Catalyst::Utils;

    use base 'Catalyst::Controller';

    sub name :Local {
      my ($self, $c) = @_;
      my $env = $c->Catalyst::Utils::env_at_path_prefix;
    }

Assuming you have a request like GET /user/name:

In the example case C<$env> will have PATH_INFO of '/name' instead of
'/user/name' and SCRIPT_NAME will now be '/user'.

=cut

sub env_at_path_prefix {
    my $ctx = shift;
    my $path_prefix = $ctx->controller->path_prefix;
    my $env = $ctx->request->env;
    my $path_info = $env->{PATH_INFO};
    my $script_name = ($env->{SCRIPT_NAME} || '');

    $path_info =~ s/(^\/\Q$path_prefix\E)//;
    $script_name = "$script_name$1";

    return +{
            %$env,
            PATH_INFO   => $path_info,
            SCRIPT_NAME => $script_name };
}

=head2 env_at_action

Localize C<$env> under the current action namespace.

    package MyApp::Controller::User;

    use Catalyst::Utils;

    use base 'Catalyst::Controller';

    sub name :Local {
      my ($self, $c) = @_;
      my $env = $c->Catalyst::Utils::env_at_action;
    }

Assuming you have a request like GET /user/name:

In the example case C<$env> will have PATH_INFO of '/' instead of
'/user/name' and SCRIPT_NAME will now be '/user/name'.

Alternatively, assuming you have a request like GET /user/name/foo:

In this example case C<$env> will have PATH_INFO of '/foo' instead of
'/user/name/foo' and SCRIPT_NAME will now be '/user/name'.

This is probably a common case where you want to mount a PSGI application
under an action but let the Args fall through to the PSGI app.

=cut

sub env_at_action {
    my $ctx = shift;
    my $argpath = join '/', @{$ctx->request->arguments};
    my $path = '/' . $ctx->request->path;

    $path =~ s/\/?\Q$argpath\E\/?$//;

    my $env = $ctx->request->env;
    my $path_info = $env->{PATH_INFO};
    my $script_name = ($env->{SCRIPT_NAME} || '');

    $path_info =~ s/(^\Q$path\E)//;
    $script_name = "$script_name$1";

    return +{
            %$env,
            PATH_INFO   => $path_info,
            SCRIPT_NAME => $script_name };
}

=head2 env_at_request_uri

Localize C<$env> under the current request URI:

    package MyApp::Controller::User;

    use Catalyst::Utils;

    use base 'Catalyst::Controller';

    sub name :Local Args(1) {
      my ($self, $c, $id) = @_;
      my $env = $c->Catalyst::Utils::env_at_request_uri
    }

Assuming you have a request like GET /user/name/hello:

In the example case C<$env> will have PATH_INFO of '/' instead of
'/user/name' and SCRIPT_NAME will now be '/user/name/hello'.

=cut

sub env_at_request_uri {
    my $ctx = shift;
    my $path = '/' . $ctx->request->path;
    my $env = $ctx->request->env;
    my $path_info = $env->{PATH_INFO};
    my $script_name = ($env->{SCRIPT_NAME} || '');

    $path_info =~ s/(^\Q$path\E)//;
    $script_name = "$script_name$1";

    return +{
            %$env,
            PATH_INFO   => $path_info,
            SCRIPT_NAME => $script_name };
}

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

1;
package Catalyst::Request;

use Socket qw(getaddrinfo getnameinfo AI_NUMERICHOST NI_NAMEREQD NIx_NOSERV);
use Carp;
use utf8;
use URI::http;
use URI::https;
use URI::QueryParam;
use HTTP::Headers;
use Stream::Buffered;
use Hash::MultiValue;
use Scalar::Util;
use HTTP::Body;
use Catalyst::Exception;
use Catalyst::Request::PartData;
use Moose;

use namespace::clean -except => 'meta';

with 'MooseX::Emulate::Class::Accessor::Fast';

has env => (is => 'ro', writer => '_set_env', predicate => '_has_env');
# XXX Deprecated crap here - warn?
has action => (is => 'rw');
# XXX: Deprecated in docs ages ago (2006), deprecated with warning in 5.8000 due
# to confusion between Engines and Plugin::Authentication. Remove in 5.8100?
has user => (is => 'rw');
sub snippets {shift->captures(@_)}

has _read_position => (
        # FIXME: work around Moose bug RT#75367
        # init_arg => undef,
        is      => 'ro',
        writer  => '_set_read_position',
        default => 0,
);
has _read_length => (
        # FIXME: work around Moose bug RT#75367
        # init_arg => undef,
        is      => 'ro',
        default => sub {
            my $self = shift;
            $self->header('Content-Length') || 0;
        },
        lazy    => 1,
);

has address => (is => 'rw');
has arguments => (is => 'rw', default => sub {[]});
has cookies => (is => 'ro', builder => 'prepare_cookies', lazy => 1);

sub prepare_cookies {
    my ($self) = @_;

    if (my $header = $self->header('Cookie')) {
        return { CGI::Simple::Cookie->parse($header) };
    }
    {};
}

has query_keywords => (is => 'rw');
has match => (is => 'rw');
has method => (is => 'rw');
has protocol => (is => 'rw');
has query_parameters => (is => 'rw', lazy => 1, default => sub {shift->_use_hash_multivalue ? Hash::MultiValue->new : +{}});
has secure => (is => 'rw', default => 0);
has captures => (is => 'rw', default => sub {[]});
has uri => (is => 'rw', predicate => 'has_uri');
has remote_user => (is => 'rw');
has headers => (
        is      => 'rw',
        isa     => 'HTTP::Headers',
        handles => [ qw(content_encoding content_length content_type header referer user_agent) ],
        builder => 'prepare_headers',
        lazy    => 1,
);

sub prepare_headers {
    my ($self) = @_;

    my $env = $self->env;
    my $headers = HTTP::Headers->new();

    for my $header (keys %{$env}) {
        next unless $header =~ /^(HTTP|CONTENT|COOKIE)/i;
        (my $field = $header) =~ s/^HTTPS?_//;
        $field =~ tr/_/-/;
        $headers->header($field => $env->{$header});
    }
    return $headers;
}

has _log => (
        is       => 'ro',
        weak_ref => 1,
        required => 1,
);

has io_fh => (
        is        => 'ro',
        predicate => '_has_io_fh',
        lazy      => 1,
        builder   => '_build_io_fh');

sub _build_io_fh {
    my $self = shift;
    return $self->env->{'psgix.io'}
            || (
            $self->env->{'net.async.http.server.req'} &&
                    $self->env->{'net.async.http.server.req'}->stream) ## Until I can make ioasync cabal see the value of supportin psgix.io (jnap)
            || die "Your Server does not support psgix.io";
};

has data_handlers => (is => 'ro', isa => 'HashRef', default => sub {+{}});

has body_data => (
        is      => 'ro',
        lazy    => 1,
        builder => '_build_body_data');

sub _build_body_data {
    my ($self) = @_;

    # Not sure if these returns should not be exceptions...
    my $content_type = $self->content_type || return;
    return unless ($self->method eq 'POST' || $self->method eq 'PUT' || $self->method eq 'PATCH' || $self->method eq 'DELETE');

    my ($match) = grep {$content_type =~ /$_/i}
            keys(%{$self->data_handlers});

    if ($match) {
        my $fh = $self->body;
        local $_ = $fh;
        return $self->data_handlers->{$match}->($fh, $self);
    }
    else {
        Catalyst::Exception->throw(
                sprintf '%s does not have an available data handler. Valid data_handlers are %s.',
                        $content_type, join ', ', sort keys %{$self->data_handlers}
        );
    }
}

has _use_hash_multivalue => (
        is       => 'ro',
        required => 1,
        default  => sub {0});

# Amount of data to read from input on each pass
our $CHUNKSIZE = 64 * 1024;

sub read {
    my ($self, $maxlength) = @_;
    my $remaining = $self->_read_length - $self->_read_position;
    $maxlength ||= $CHUNKSIZE;

    # Are we done reading?
    if ($remaining <= 0) {
        return;
    }

    my $readlen = ($remaining > $maxlength) ? $maxlength : $remaining;
    my $rc = $self->read_chunk(my $buffer, $readlen);
    if (defined $rc) {
        if (0 == $rc) { # Nothing more to read even though Content-Length
            # said there should be.
            return;
        }
        $self->_set_read_position($self->_read_position + $rc);
        return $buffer;
    }
    else {
        Catalyst::Exception->throw(
                message => "Unknown error reading input: $!");
    }
}

sub read_chunk {
    my $self = shift;
    return $self->env->{'psgi.input'}->read(@_);
}

has body_parameters => (
        is        => 'rw',
        required  => 1,
        lazy      => 1,
        predicate => 'has_body_parameters',
        builder   => 'prepare_body_parameters',
);

has uploads => (
        is       => 'rw',
        required => 1,
        default  => sub {{}},
);

has parameters => (
        is      => 'rw',
        lazy    => 1,
        builder => '_build_parameters',
        clearer => '_clear_parameters',
);

# TODO:
# - Can we lose the before modifiers which just call prepare_body ?
#   they are wasteful, slow us down and feel cluttery.

#  Can we make _body an attribute, have the rest of
#  these lazy build from there and kill all the direct hash access
#  in Catalyst.pm and Engine.pm?

sub prepare_parameters {
    my ($self) = @_;
    $self->_clear_parameters;
    return $self->parameters;
}

sub _build_parameters {
    my ($self) = @_;
    my $parameters = {};
    my $body_parameters = $self->body_parameters;
    my $query_parameters = $self->query_parameters;

    if ($self->_use_hash_multivalue) {
        return Hash::MultiValue->new($query_parameters->flatten, $body_parameters->flatten);
    }

    # We copy, no references
    foreach my $name (keys %$query_parameters) {
        my $param = $query_parameters->{$name};
        $parameters->{$name} = ref $param eq 'ARRAY' ? [ @$param ] : $param;
    }

    # Merge query and body parameters
    foreach my $name (keys %$body_parameters) {
        my $param = $body_parameters->{$name};
        my @values = ref $param eq 'ARRAY' ? @$param : ($param);
        if (my $existing = $parameters->{$name}) {
            unshift(@values, (ref $existing eq 'ARRAY' ? @$existing : $existing));
        }
        $parameters->{$name} = @values > 1 ? \@values : $values[0];
    }
    $parameters;
}

has _uploadtmp => (
        is        => 'ro',
        predicate => '_has_uploadtmp',
);

sub prepare_body {
    my ($self) = @_;

    # If previously applied middleware created the HTTP::Body object, then we
    # just use that one.

    if (my $plack_body = $self->_has_env ? $self->env->{'plack.request.http.body'} : undef) {
        $self->_body($plack_body);
        $self->_body->cleanup(1);
        return;
    }

    # If there is nothing to read, set body to naught and return.  This
    # will cause all body code to be skipped

    return $self->_body(0) unless my $length = $self->_read_length;

    # Unless the body has already been set, create it.  Not sure about this
    # code, how else might it be set, but this was existing logic.

    unless ($self->_body) {
        my $type = $self->header('Content-Type');
        $self->_body(HTTP::Body->new($type, $length));
        $self->_body->cleanup(1);

        # JNAP: I'm not sure this is doing what we expect, but it also doesn't
        # seem to be hurting (seems ->_has_uploadtmp is true more than I would
        # expect.

        $self->_body->tmpdir($self->_uploadtmp)
                if $self->_has_uploadtmp;
    }

    # Ok if we get this far, we have to read psgi.input into the new body
    # object.  Lets play nice with any plack app or other downstream, so
    # we create a buffer unless one exists.

    my $stream_buffer;
    if ($self->env->{'psgix.input.buffered'}) {
        # Be paranoid about previous psgi middleware or apps that read the
        # input but didn't return the buffer to the start.
        $self->env->{'psgi.input'}->seek(0, 0);
    }
    else {
        $stream_buffer = Stream::Buffered->new($length);
    }

    # Check for definedness as you could read '0'
    while (defined(my $chunk = $self->read())) {
        $self->prepare_body_chunk($chunk);
        next unless $stream_buffer;

        $stream_buffer->print($chunk)
                || die sprintf "Failed to write %d bytes to psgi.input file: $!", length($chunk);
    }

    # Ok, we read the body.  Lets play nice for any PSGI app down the pipe

    if ($stream_buffer) {
        $self->env->{'psgix.input.buffered'} = 1;
        $self->env->{'psgi.input'} = $stream_buffer->rewind;
    }
    else {
        $self->env->{'psgi.input'}->seek(0, 0); # Reset the buffer for downstream middleware or apps
    }

    # paranoia against wrong Content-Length header
    my $remaining = $length - $self->_read_position;
    if ($remaining > 0) {
        Catalyst::Exception->throw("Wrong Content-Length value: $length");
    }
}

sub prepare_body_chunk {
    my ($self, $chunk) = @_;

    $self->_body->add($chunk);
}

sub prepare_body_parameters {
    my ($self, $c) = @_;
    return $self->body_parameters if $self->has_body_parameters;
    $self->prepare_body if !$self->_has_body;

    unless ($self->_body) {
        my $return = $self->_use_hash_multivalue ? Hash::MultiValue->new : {};
        $self->body_parameters($return);
        return $return;
    }

    my $params;
    my %part_data = %{$self->_body->part_data};
    if (scalar %part_data && !$c->config->{skip_complex_post_part_handling}) {
        foreach my $key (keys %part_data) {
            my $proto_value = $part_data{$key};
            my ($val, @extra) = (ref($proto_value) || '') eq 'ARRAY' ? @$proto_value : ($proto_value);

            $key = $c->_handle_param_unicode_decoding($key)
                    if ($c and $c->encoding and !$c->config->{skip_body_param_unicode_decoding});

            if (@extra) {
                $params->{$key} = [ map {Catalyst::Request::PartData->build_from_part_data($c, $_)} ($val, @extra) ];
            }
            else {
                $params->{$key} = Catalyst::Request::PartData->build_from_part_data($c, $val);
            }
        }
    }
    else {
        $params = $self->_body->param;

        # If we have an encoding configured (like UTF-8) in general we expect a client
        # to POST with the encoding we fufilled the request in. Otherwise don't do any
        # encoding (good change wide chars could be in HTML entity style llike the old
        # days -JNAP

        # so, now that HTTP::Body prepared the body params, we gotta 'walk' the structure
        # and do any needed decoding.

        # This only does something if the encoding is set via the encoding param.  Remember
        # this is assuming the client is not bad and responds with what you provided.  In
        # general you can just use utf8 and get away with it.
        #
        # I need to see if $c is here since this also doubles as a builder for the object :(

        if ($c and $c->encoding and !$c->config->{skip_body_param_unicode_decoding}) {
            $params = $c->_handle_unicode_decoding($params);
        }
    }

    my $return = $self->_use_hash_multivalue ?
            Hash::MultiValue->from_mixed($params) :
            $params;

    $self->body_parameters($return) unless $self->has_body_parameters;
    return $return;
}

sub prepare_connection {
    my ($self) = @_;

    my $env = $self->env;

    $self->address($env->{REMOTE_ADDR});
    $self->hostname($env->{REMOTE_HOST})
            if exists $env->{REMOTE_HOST};
    $self->protocol($env->{SERVER_PROTOCOL});
    $self->remote_user($env->{REMOTE_USER});
    $self->method($env->{REQUEST_METHOD});
    $self->secure($env->{'psgi.url_scheme'} eq 'https' ? 1 : 0);
}

# XXX - FIXME - method is here now, move this crap...
around parameters => sub {
    my ($orig, $self, $params) = @_;
    if ($params) {
        if (!ref $params) {
            $self->_log->warn(
                    "Attempt to retrieve '$params' with req->params(), " .
                            "you probably meant to call req->param('$params')"
            );
            $params = undef;
        }
        return $self->$orig($params);
    }
    $self->$orig();
};

has base => (
        is       => 'rw',
        required => 1,
        lazy     => 1,
        default  => sub {
            my $self = shift;
            return $self->path if $self->has_uri;
        },
);

has _body => (
        is => 'rw', clearer => '_clear_body', predicate => '_has_body',
);
# Eugh, ugly. Should just be able to rename accessor methods to 'body'
#             and provide a custom reader..
sub body {
    my $self = shift;
    $self->prepare_body unless $self->_has_body;
    croak 'body is a reader' if scalar @_;
    return blessed $self->_body ? $self->_body->body : $self->_body;
}

has hostname => (
        is      => 'rw',
        lazy    => 1,
        default => sub {
            my ($self) = @_;
            my ($err, $sockaddr) = getaddrinfo(
                    $self->address,
                    # no service
                    '',
                    { flags => AI_NUMERICHOST }
            );
            if ($err) {
                $self->_log->warn("resolve of hostname failed: $err");
                return $self->address;
            }
            ($err, my $hostname) = getnameinfo(
                    $sockaddr->{addr},
                    NI_NAMEREQD,
                    # we are only interested in the hostname, not the servicename
                    NIx_NOSERV
            );
            if ($err) {
                $self->_log->warn("resolve of hostname failed: $err");
                return $self->address;
            }
            return $hostname;
        },
);

has _path => (is => 'rw', predicate => '_has_path', clearer => '_clear_path');

sub args {shift->arguments(@_)}
sub body_params {shift->body_parameters(@_)}
sub input {shift->body(@_)}
sub params {shift->parameters(@_)}
sub query_params {shift->query_parameters(@_)}
sub path_info {shift->path(@_)}

=for stopwords param params

=head1 NAME

Catalyst::Request - provides information about the current client request

=head1 SYNOPSIS

    $req = $c->request;
    $req->address eq "127.0.0.1";
    $req->arguments;
    $req->args;
    $req->base;
    $req->body;
    $req->body_data;
    $req->body_parameters;
    $req->content_encoding;
    $req->content_length;
    $req->content_type;
    $req->cookie;
    $req->cookies;
    $req->header;
    $req->headers;
    $req->hostname;
    $req->input;
    $req->query_keywords;
    $req->match;
    $req->method;
    $req->param;
    $req->parameters;
    $req->params;
    $req->path;
    $req->protocol;
    $req->query_parameters;
    $req->read;
    $req->referer;
    $req->secure;
    $req->captures;
    $req->upload;
    $req->uploads;
    $req->uri;
    $req->user;
    $req->user_agent;
    $req->env;

See also L<Catalyst>, L<Catalyst::Request::Upload>.

=head1 DESCRIPTION

This is the Catalyst Request class, which provides an interface to data for the
current client request. The request object is prepared by L<Catalyst::Engine>,
thus hiding the details of the particular engine implementation.

=head1 METHODS

=head2 $req->address

Returns the IP address of the client.

=head2 $req->arguments

Returns a reference to an array containing the arguments.

    print $c->request->arguments->[0];

For example, if your action was

    package MyApp::Controller::Foo;

    sub moose : Local {
        ...
    }

and the URI for the request was C<http://.../foo/moose/bah>, the string C<bah>
would be the first and only argument.

Arguments get automatically URI-unescaped for you.

=head2 $req->args

Shortcut for L</arguments>.

=head2 $req->base

Contains the URI base. This will always have a trailing slash. Note that the
URI scheme (e.g., http vs. https) must be determined through heuristics;
depending on your server configuration, it may be incorrect. See $req->secure
for more info.

If your application was queried with the URI
C<http://localhost:3000/some/path> then C<base> is C<http://localhost:3000/>.

=head2 $req->body

Returns the message body of the request, as returned by L<HTTP::Body>: a string,
unless Content-Type is C<application/x-www-form-urlencoded>, C<text/xml>, or
C<multipart/form-data>, in which case a L<File::Temp> object is returned.

=head2 $req->body_data

Returns a Perl representation of body data that is not classic HTML
form data, such as JSON, XML, etc.  By default, Catalyst will parse incoming
data of the type 'application/json' for POST, PUT, PATCH or DELETE methods,
and return access to that data via this method.

You may define addition data_handlers via a global configuration
setting.  See L<Catalyst\DATA HANDLERS> for more information.

If the body is malformed in some way (such as undefined or not content that
matches the content-type) we raise a L<Catalyst::Exception> with the error
text as the message.

If the body content type does not match an available data handler, this
will also raise an exception.

=head2 $req->body_parameters

Returns a reference to a hash containing body (POST) parameters. Values can
be either a scalar or an arrayref containing scalars.

    print $c->request->body_parameters->{field};
    print $c->request->body_parameters->{field}->[0];

These are the parameters from the POST part of the request, if any.

B<NOTE> If your POST is multipart, but contains non file upload parts (such
as an line part with an alternative encoding or content type) we do our best to
try and figure out how the value should be presented.  If there's a specified character
set we will use that to decode rather than the default encoding set by the application.
However if there are complex headers and we cannot determine
the correct way to extra a meaningful value from the upload, in this case any
part like this will be represented as an instance of L<Catalyst::Request::PartData>.

Patches and review of this part of the code welcomed.

=head2 $req->body_params

Shortcut for body_parameters.

=head2 $req->content_encoding

Shortcut for $req->headers->content_encoding.

=head2 $req->content_length

Shortcut for $req->headers->content_length.

=head2 $req->content_type

Shortcut for $req->headers->content_type.

=head2 $req->cookie

A convenient method to access $req->cookies.

    $cookie  = $c->request->cookie('name');
    @cookies = $c->request->cookie;

=cut

sub cookie {
    my $self = shift;

    if (@_ == 0) {
        return keys %{$self->cookies};
    }

    if (@_ == 1) {

        my $name = shift;

        unless (exists $self->cookies->{$name}) {
            return undef;
        }

        return $self->cookies->{$name};
    }
}

=head2 $req->cookies

Returns a reference to a hash containing the cookies.

    print $c->request->cookies->{mycookie}->value;

The cookies in the hash are indexed by name, and the values are L<CGI::Simple::Cookie>
objects.

=head2 $req->header

Shortcut for $req->headers->header.

=head2 $req->headers

Returns an L<HTTP::Headers> object containing the headers for the current request.

    print $c->request->headers->header('X-Catalyst');

=head2 $req->hostname

Returns the hostname of the client. Use C<< $req->uri->host >> to get the hostname of the server.

=head2 $req->input

Alias for $req->body.

=head2 $req->query_keywords

Contains the keywords portion of a query string, when no '=' signs are
present.

    http://localhost/path?some+keywords

    $c->request->query_keywords will contain 'some keywords'

=head2 $req->match

This contains the matching part of a Regex action. Otherwise
it returns the same as 'action', except for default actions,
which return an empty string.

=head2 $req->method

Contains the request method (C<GET>, C<POST>, C<HEAD>, etc).

=head2 $req->param

Returns GET and POST parameters with a CGI.pm-compatible param method. This
is an alternative method for accessing parameters in $c->req->parameters.

    $value  = $c->request->param( 'foo' );
    @values = $c->request->param( 'foo' );
    @params = $c->request->param;

Like L<CGI>, and B<unlike> earlier versions of Catalyst, passing multiple
arguments to this method, like this:

    $c->request->param( 'foo', 'bar', 'gorch', 'quxx' );

will set the parameter C<foo> to the multiple values C<bar>, C<gorch> and
C<quxx>. Previously this would have added C<bar> as another value to C<foo>
(creating it if it didn't exist before), and C<quxx> as another value for
C<gorch>.

B<NOTE> this is considered a legacy interface and care should be taken when
using it. C<< scalar $c->req->param( 'foo' ) >> will return only the first
C<foo> param even if multiple are present; C<< $c->req->param( 'foo' ) >> will
return a list of as many are present, which can have unexpected consequences
when writing code of the form:

    $foo->bar(
        a => 'b',
        baz => $c->req->param( 'baz' ),
    );

If multiple C<baz> parameters are provided this code might corrupt data or
cause a hash initialization error. For a more straightforward interface see
C<< $c->req->parameters >>.

B<NOTE> Interfaces like this, which are based on L<CGI> and the C<param> method
are known to cause demonstrated exploits. It is highly recommended that you
avoid using this method, and migrate existing code away from it.  Here's a
whitepaper of the exploit:

L<http://blog.gerv.net/2014/10/new-class-of-vulnerability-in-perl-web-applications/>

B<NOTE> Further discussion on IRC indicate that the L<Catalyst> core team from 'back then'
were well aware of this hack and this is the main reason we added the new approach to
getting parameters in the first place.

Basically this is an exploit that takes advantage of how L<\param> will do one thing
in scalar context and another thing in list context.  This is combined with how Perl
chooses to deal with duplicate keys in a hash definition by overwriting the value of
existing keys with a new value if the same key shows up again.  Generally you will be
vulnerable to this exploit if you are using this method in a direct assignment in a
hash, such as with a L<DBIx::Class> create statement.  For example, if you have
parameters like:

    user?user=123&foo=a&foo=user&foo=456

You could end up with extra parameters injected into your method calls:

    $c->model('User')->create({
      user => $c->req->param('user'),
      foo => $c->req->param('foo'),
    });

Which would look like:

    $c->model('User')->create({
      user => 123,
      foo => qw(a user 456),
    });

(or to be absolutely clear if you are not seeing it):

    $c->model('User')->create({
      user => 456,
      foo => 'a',
    });

Possible remediations include scrubbing your parameters with a form validator like
L<HTML::FormHandler> or being careful to force scalar context using the scalar
keyword:

    $c->model('User')->create({
      user => scalar($c->req->param('user')),
      foo => scalar($c->req->param('foo')),
    });

Upcoming versions of L<Catalyst> will disable this interface by default and require
you to positively enable it should you require it for backwards compatibility reasons.

=cut

sub param {
    my $self = shift;

    if (@_ == 0) {
        return keys %{$self->parameters};
    }

    # If anything in @_ is undef, carp about that, and remove it from
    # the list;

    my @params = grep {defined($_) ? 1 : do {
        carp "You called ->params with an undefined value";
        0
    }} @_;

    if (@params == 1) {

        defined(my $param = shift @params) ||
                carp "You called ->params with an undefined value 2";

        unless (exists $self->parameters->{$param}) {
            return wantarray ? () : undef;
        }

        if (ref $self->parameters->{$param} eq 'ARRAY') {
            return (wantarray)
                    ? @{$self->parameters->{$param}}
                    : $self->parameters->{$param}->[0];
        }
        else {
            return (wantarray)
                    ? ($self->parameters->{$param})
                    : $self->parameters->{$param};
        }
    }
    elsif (@params > 1) {
        my $field = shift @params;
        $self->parameters->{$field} = [ @params ];
    }
}

=head2 $req->parameters

Returns a reference to a hash containing GET and POST parameters. Values can
be either a scalar or an arrayref containing scalars.

    print $c->request->parameters->{field};
    print $c->request->parameters->{field}->[0];

This is the combination of C<query_parameters> and C<body_parameters>.

=head2 $req->params

Shortcut for $req->parameters.

=head2 $req->path

Returns the path, i.e. the part of the URI after $req->base, for the current request.

    http://localhost/path/foo

    $c->request->path will contain 'path/foo'

=head2 $req->path_info

Alias for path, added for compatibility with L<CGI>.

=cut

sub path {
    my ($self, @params) = @_;

    if (@params) {
        $self->uri->path(@params);
        $self->_clear_path;
    }
    elsif ($self->_has_path) {
        return $self->_path;
    }
    else {
        my $path = $self->uri->path;
        my $location = $self->base->path;
        $path =~ s/^(\Q$location\E)?//;
        $path =~ s/^\///;
        $self->_path($path);

        return $path;
    }
}

=head2 $req->protocol

Returns the protocol (HTTP/1.0 or HTTP/1.1) used for the current request.

=head2 $req->query_parameters

=head2 $req->query_params

Returns a reference to a hash containing query string (GET) parameters. Values can
be either a scalar or an arrayref containing scalars.

    print $c->request->query_parameters->{field};
    print $c->request->query_parameters->{field}->[0];

=head2 $req->read( [$maxlength] )

Reads a chunk of data from the request body. This method is intended to be
used in a while loop, reading $maxlength bytes on every call. $maxlength
defaults to the size of the request if not specified.

=head2 $req->read_chunk(\$buff, $max)

Reads a chunk.

You have to set MyApp->config(parse_on_demand => 1) to use this directly.

=head2 $req->referer

Shortcut for $req->headers->referer. Returns the referring page.

=head2 $req->secure

Returns true or false, indicating whether the connection is secure
(https). The reliability of $req->secure may depend on your server
configuration; Catalyst relies on PSGI to determine whether or not a
request is secure (Catalyst looks at psgi.url_scheme), and different
PSGI servers may make this determination in different ways (as by
directly passing along information from the server, interpreting any of
several HTTP headers, or using heuristics of their own).

=head2 $req->captures

Returns a reference to an array containing captured args from chained
actions or regex captures.

    my @captures = @{ $c->request->captures };

=head2 $req->upload

A convenient method to access $req->uploads.

    $upload  = $c->request->upload('field');
    @uploads = $c->request->upload('field');
    @fields  = $c->request->upload;

    for my $upload ( $c->request->upload('field') ) {
        print $upload->filename;
    }

=cut

sub upload {
    my $self = shift;

    if (@_ == 0) {
        return keys %{$self->uploads};
    }

    if (@_ == 1) {

        my $upload = shift;

        unless (exists $self->uploads->{$upload}) {
            return wantarray ? () : undef;
        }

        if (ref $self->uploads->{$upload} eq 'ARRAY') {
            return (wantarray)
                    ? @{$self->uploads->{$upload}}
                    : $self->uploads->{$upload}->[0];
        }
        else {
            return (wantarray)
                    ? ($self->uploads->{$upload})
                    : $self->uploads->{$upload};
        }
    }

    if (@_ > 1) {

        while (my ($field, $upload) = splice(@_, 0, 2)) {

            if (exists $self->uploads->{$field}) {
                for ($self->uploads->{$field}) {
                    $_ = [ $_ ] unless ref($_) eq "ARRAY";
                    push(@$_, $upload);
                }
            }
            else {
                $self->uploads->{$field} = $upload;
            }
        }
    }
}

=head2 $req->uploads

Returns a reference to a hash containing uploads. Values can be either a
L<Catalyst::Request::Upload> object, or an arrayref of
L<Catalyst::Request::Upload> objects.

    my $upload = $c->request->uploads->{field};
    my $upload = $c->request->uploads->{field}->[0];

=head2 $req->uri

Returns a L<URI> object for the current request. Stringifies to the URI text.

=head2 $req->mangle_params( { key => 'value' }, $appendmode);

Returns a hashref of parameters stemming from the current request's params,
plus the ones supplied.  Keys for which no current param exists will be
added, keys with undefined values will be removed and keys with existing
params will be replaced.  Note that you can supply a true value as the final
argument to change behavior with regards to existing parameters, appending
values rather than replacing them.

A quick example:

  # URI query params foo=1
  my $hashref = $req->mangle_params({ foo => 2 });
  # Result is query params of foo=2

versus append mode:

  # URI query params foo=1
  my $hashref = $req->mangle_params({ foo => 2 }, 1);
  # Result is query params of foo=1&foo=2

This is the code behind C<uri_with>.

=cut

sub mangle_params {
    my ($self, $args, $append) = @_;

    carp('No arguments passed to mangle_params()') unless $args;

    foreach my $value (values %$args) {
        next unless defined $value;
        for (ref $value eq 'ARRAY' ? @$value : $value) {
            $_ = "$_";
            #      utf8::encode($_);
        }
    };

    my %params = %{$self->uri->query_form_hash};
    foreach my $key (keys %{$args}) {
        my $val = $args->{$key};
        if (defined($val)) {

            if ($append && exists($params{$key})) {

                # This little bit of heaven handles appending a new value onto
                # an existing one regardless if the existing value is an array
                # or not, and regardless if the new value is an array or not
                $params{$key} = [
                        ref($params{$key}) eq 'ARRAY' ? @{$params{$key}} : $params{$key},
                        ref($val) eq 'ARRAY' ? @{$val} : $val
                ];

            }
            else {
                $params{$key} = $val;
            }
        }
        else {

            # If the param wasn't defined then we delete it.
            delete($params{$key});
        }
    }

    return \%params;
}

=head2 $req->uri_with( { key => 'value' } );

Returns a rewritten URI object for the current request. Key/value pairs
passed in will override existing parameters. You can remove an existing
parameter by passing in an undef value. Unmodified pairs will be
preserved.

You may also pass an optional second parameter that puts C<uri_with> into
append mode:

  $req->uri_with( { key => 'value' }, { mode => 'append' } );

See C<mangle_params> for an explanation of this behavior.

=cut

sub uri_with {
    my ($self, $args, $behavior) = @_;

    carp('No arguments passed to uri_with()') unless $args;

    my $append = 0;
    if ((ref($behavior) eq 'HASH') && defined($behavior->{mode}) && ($behavior->{mode} eq 'append')) {
        $append = 1;
    }

    my $params = $self->mangle_params($args, $append);

    my $uri = $self->uri->clone;
    $uri->query_form($params);

    return $uri;
}

=head2 $req->remote_user

Returns the value of the C<REMOTE_USER> environment variable.

=head2 $req->user_agent

Shortcut to $req->headers->user_agent. Returns the user agent (browser)
version string.

=head2 $req->io_fh

Returns a psgix.io bidirectional socket, if your server supports one.  Used for
when you want to jailbreak out of PSGI and handle bidirectional client server
communication manually, such as when you are using cometd or websockets.

=head1 SETUP METHODS

You should never need to call these yourself in application code,
however they are useful if extending Catalyst by applying a request role.

=head2 $self->prepare_headers()

Sets up the C<< $res->headers >> accessor.

=head2 $self->prepare_body()

Sets up the body using L<HTTP::Body>

=head2 $self->prepare_body_chunk()

Add a chunk to the request body.

=head2 $self->prepare_body_parameters()

Sets up parameters from body.

=head2 $self->prepare_cookies()

Parse cookies from header. Sets up a L<CGI::Simple::Cookie> object.

=head2 $self->prepare_connection()

Sets up various fields in the request like the local and remote addresses,
request method, hostname requested etc.

=head2 $self->prepare_parameters()

Ensures that the body has been parsed, then builds the parameters, which are
combined from those in the request and those in the body.

If parameters have already been set will clear the parameters and build them again.

=head2 $self->env

Access to the raw PSGI env.

=head2 meta

Provided by Moose

=head1 AUTHORS

Catalyst Contributors, see Catalyst.pm

=head1 COPYRIGHT

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

__PACKAGE__->meta->make_immutable;

1;
package Catalyst::Controller;

use Moose;
use Class::MOP;
use Class::Load ':all';
use String::RewritePrefix;
use Moose::Util qw/find_meta/;
use List::Util qw/first uniq/;
use namespace::clean -except => 'meta';

BEGIN {
    extends qw/Catalyst::Component/;
    with qw/MooseX::MethodAttributes::Role::AttrContainer::Inheritable/;
}

use MooseX::MethodAttributes;
use Catalyst::Exception;
use Catalyst::Utils;

with 'Catalyst::Component::ApplicationAttribute';

has path_prefix => (
        is        => 'rw',
        isa       => 'Str',
        init_arg  => 'path',
        predicate => 'has_path_prefix',
);

has action_namespace => (
        is        => 'rw',
        isa       => 'Str',
        init_arg  => 'namespace',
        predicate => 'has_action_namespace',
);

has actions => (
        accessor => '_controller_actions',
        isa      => 'HashRef',
        init_arg => undef,
);

has _action_role_args => (
        traits   => [ qw(Array) ],
        isa      => 'ArrayRef[Str]',
        init_arg => 'action_roles',
        default  => sub {[]},
        handles  => {
                _action_role_args => 'elements',
        },
);

has _action_roles => (
        traits   => [ qw(Array) ],
        isa      => 'ArrayRef[RoleName]',
        init_arg => undef,
        lazy     => 1,
        builder  => '_build__action_roles',
        handles  => {
                _action_roles => 'elements',
        },
);

has action_args => (is => 'ro');

# ->config(actions => { '*' => ...
has _all_actions_attributes => (
        is       => 'ro',
        isa      => 'HashRef',
        init_arg => undef,
        lazy     => 1,
        builder  => '_build__all_actions_attributes',
);

sub BUILD {
    my ($self, $args) = @_;
    my $action = delete $args->{action} || {};
    my $actions = delete $args->{actions} || {};
    my $attr_value = $self->merge_config_hashes($actions, $action);
    $self->_controller_actions($attr_value);

    # trigger lazy builder
    $self->_all_actions_attributes;
    $self->_action_roles;
}

sub _build__action_roles {
    my $self = shift;
    my @roles = $self->_expand_role_shortname($self->_action_role_args);
    load_class($_) for @roles;
    return \@roles;
}

sub _build__all_actions_attributes {
    my ($self) = @_;
    delete $self->_controller_actions->{'*'} || {};
}

=head1 NAME

Catalyst::Controller - Catalyst Controller base class

=head1 SYNOPSIS

  package MyApp::Controller::Search
  use base qw/Catalyst::Controller/;

  sub foo : Local {
    my ($self,$c,@args) = @_;
    ...
  } # Dispatches to /search/foo

=head1 DESCRIPTION

Controllers are where the actions in the Catalyst framework
reside. Each action is represented by a function with an attribute to
identify what kind of action it is. See the L<Catalyst::Dispatcher>
for more info about how Catalyst dispatches to actions.

=cut

#I think both of these could be attributes. doesn't really seem like they need
#to be class data. i think that attributes +default would work just fine
__PACKAGE__->mk_classdata($_) for qw/_dispatch_steps _action_class _action_role_prefix/;

__PACKAGE__->_dispatch_steps([ qw/_BEGIN _AUTO _ACTION/ ]);
__PACKAGE__->_action_class('Catalyst::Action');
__PACKAGE__->_action_role_prefix([ 'Catalyst::ActionRole::' ]);

sub _DISPATCH :Private {
    my ($self, $c) = @_;

    foreach my $disp (@{$self->_dispatch_steps}) {
        last unless $c->forward($disp);
    }

    $c->forward('_END');
}

sub _BEGIN :Private {
    my ($self, $c) = @_;
    my $begin = ($c->get_actions('begin', $c->namespace))[-1];
    return 1 unless $begin;
    $begin->dispatch($c);
    #If there is an error, all bets off
    if (@{$c->error}) {
        return !@{$c->error};
    }
    else {
        return $c->state || 1;
    }
}

sub _AUTO :Private {
    my ($self, $c) = @_;
    my @auto = $c->get_actions('auto', $c->namespace);
    foreach my $auto (@auto) {
        # We FORCE the auto action user to explicitly return
        # true.  We need to do this since there's some auto
        # users (Catalyst::Authentication::Credential::HTTP) that
        # actually do a detach instead.
        $c->state(0);
        $auto->dispatch($c);
        return 0 unless $c->state;
    }
    return $c->state || 1;
}

sub _ACTION :Private {
    my ($self, $c) = @_;
    if (ref $c->action
            && $c->action->can('execute')
            && defined $c->req->action) {
        $c->action->dispatch($c);
    }
    #If there is an error, all bets off
    if (@{$c->error}) {
        return !@{$c->error};
    }
    else {
        return $c->state || 1;
    }
}

sub _END :Private {
    my ($self, $c) = @_;
    my $end = ($c->get_actions('end', $c->namespace))[-1];
    return 1 unless $end;
    $end->dispatch($c);
    return !@{$c->error};
}

sub action_for {
    my ($self, $name) = @_;
    my $app = ($self->isa('Catalyst') ? $self : $self->_application);
    return $app->dispatcher->get_action($name, $self->action_namespace);
}

#my opinion is that this whole sub really should be a builder method, not
#something that happens on every call. Anyone else disagree?? -- groditi
## -- apparently this is all just waiting for app/ctx split
around action_namespace => sub {
    my $orig = shift;
    my ($self, $c) = @_;

    my $class = ref($self) || $self;
    my $appclass = ref($c) || $c;
    if (ref($self)) {
        return $self->$orig if $self->has_action_namespace;
    }
    else {
        return $class->config->{namespace} if exists $class->config->{namespace};
    }

    my $case_s;
    if ($c) {
        $case_s = $appclass->config->{case_sensitive};
    }
    else {
        if ($self->isa('Catalyst')) {
            $case_s = $class->config->{case_sensitive};
        }
        else {
            if (ref $self) {
                $case_s = ref($self->_application)->config->{case_sensitive};
            }
            else {
                confess("Can't figure out case_sensitive setting");
            }
        }
    }

    my $namespace = Catalyst::Utils::class2prefix($self->catalyst_component_name, $case_s) || '';
    $self->$orig($namespace) if ref($self);
    return $namespace;
};

#Once again, this is probably better written as a builder method
around path_prefix => sub {
    my $orig = shift;
    my $self = shift;
    if (ref($self)) {
        return $self->$orig if $self->has_path_prefix;
    }
    else {
        return $self->config->{path} if exists $self->config->{path};
    }
    my $namespace = $self->action_namespace(@_);
    $self->$orig($namespace) if ref($self);
    return $namespace;
};

sub get_action_methods {
    my $self = shift;
    my $meta = find_meta($self) || confess("No metaclass setup for $self");
    confess(
            sprintf "Metaclass %s for %s cannot support register_actions.",
                    ref $meta, $meta->name,
    ) unless $meta->can('get_nearest_methods_with_attributes');
    my @methods = $meta->get_nearest_methods_with_attributes;

    # actions specified via config are also action_methods
    push(
            @methods,
            map {
                $meta->find_method_by_name($_)
                        || confess(sprintf 'Action "%s" is not available from controller %s',
                        $_, ref $self)
            } keys %{$self->_controller_actions}
    ) if (ref $self);
    return uniq @methods;
}

sub register_actions {
    my ($self, $c) = @_;
    $self->register_action_methods($c, $self->get_action_methods);
}

sub register_action_methods {
    my ($self, $c, @methods) = @_;
    my $class = $self->catalyst_component_name;
    #this is still not correct for some reason.
    my $namespace = $self->action_namespace($c);

    # FIXME - fugly
    if (!blessed($self) && $self eq $c && scalar(@methods)) {
        my @really_bad_methods = grep {!/^_(DISPATCH|BEGIN|AUTO|ACTION|END)$/} map {$_->name} @methods;
        if (scalar(@really_bad_methods)) {
            $c->log->warn("Action methods (" . join(', ', @really_bad_methods) . ") found defined in your application class, $self. This is deprecated, please move them into a Root controller.");
        }
    }

    foreach my $method (@methods) {
        my $name = $method->name;
        # Horrible hack! All method metaclasses should have an attributes
        # method, core Moose bug - see r13354.
        my $attributes = $method->can('attributes') ? $method->attributes : [];
        my $attrs = $self->_parse_attrs($c, $name, @{$attributes});
        if ($attrs->{Private} && (keys %$attrs > 1)) {
            $c->log->warn('Bad action definition "'
                    . join(' ', @{$attributes})
                    . qq/" for "$class->$name"/)
                    if $c->debug;
            next;
        }
        my $reverse = $namespace ? "${namespace}/${name}" : $name;
        my $action = $self->create_action(
                name       => $name,
                code       => $method->body,
                reverse    => $reverse,
                namespace  => $namespace,
                class      => $class,
                attributes => $attrs,
        );

        $c->dispatcher->register($c, $action);
    }
}

sub _apply_action_class_roles {
    my ($self, $class, @roles) = @_;

    load_class($_) for @roles;
    my $meta = Moose::Meta::Class->initialize($class)->create_anon_class(
            superclasses => [ $class ],
            roles        => \@roles,
            cache        => 1,
    );
    $meta->add_method(meta => sub {$meta});

    return $meta->name;
}

sub action_class {
    my $self = shift;
    my %args = @_;

    my $class = (exists $args{attributes}{ActionClass}
            ? $args{attributes}{ActionClass}[0]
            : $self->_action_class);

    load_class($class);
    return $class;
}

sub create_action {
    my $self = shift;
    my %args = @_;

    my $class = $self->action_class(%args);

    load_class($class);
    Moose->init_meta(for_class => $class)
            unless Class::MOP::does_metaclass_exist($class);

    unless ($args{name} =~ /^_(DISPATCH|BEGIN|AUTO|ACTION|END)$/) {
        my @roles = $self->gather_action_roles(%args);
        push @roles, $self->gather_default_action_roles(%args);

        $class = $self->_apply_action_class_roles($class, @roles) if @roles;
    }

    my $action_args = (
            ref($self)
                    ? $self->action_args
                    : $self->config->{action_args}
    );

    my %extra_args = (
            %{$action_args->{'*'} || {}},
            %{$action_args->{ $args{name} } || {}},
    );

    return $class->new({ %extra_args, %args });
}

sub gather_action_roles {
    my ($self, %args) = @_;
    return (
            (blessed $self ? $self->_action_roles : ()),
            @{$args{attributes}->{Does} || []},
    );
}

sub gather_default_action_roles {
    my ($self, %args) = @_;
    my @roles = ();
    push @roles, 'Catalyst::ActionRole::HTTPMethods'
            if $args{attributes}->{Method};

    push @roles, 'Catalyst::ActionRole::ConsumesContent'
            if $args{attributes}->{Consumes};

    push @roles, 'Catalyst::ActionRole::Scheme'
            if $args{attributes}->{Scheme};

    push @roles, 'Catalyst::ActionRole::QueryMatching'
            if $args{attributes}->{Query};
    return @roles;
}

sub _parse_attrs {
    my ($self, $c, $name, @attrs) = @_;

    my %raw_attributes;

    foreach my $attr (@attrs) {

        # Parse out :Foo(bar) into Foo => bar etc (and arrayify)

        if (my ($key, $value) = ($attr =~ /^(.*?)(?:\(\s*(.+?)?\s*\))?$/)) {

            if (defined $value) {
                ($value =~ s/^'(.*)'$/$1/) || ($value =~ s/^"(.*)"/$1/);
            }
            push(@{$raw_attributes{$key}}, $value);
        }
    }

    my ($actions_config, $all_actions_config);
    if (ref($self)) {
        $actions_config = $self->_controller_actions;
        # No, you're not getting actions => { '*' => ... } with actions in MyApp.
        $all_actions_config = $self->_all_actions_attributes;
    }
    else {
        my $cfg = $self->config;
        $actions_config = $self->merge_config_hashes($cfg->{actions}, $cfg->{action});
        $all_actions_config = {};
    }

    %raw_attributes = (
            %raw_attributes,
            # Note we deep copy array refs here to stop crapping on config
            # when attributes are parsed. RT#65463
            exists $actions_config->{$name} ? map {ref($_) eq 'ARRAY' ? [ @$_ ] : $_} %{$actions_config->{$name }} : (),
    );

    # Private actions with additional attributes will raise a warning and then
    # be ignored. Adding '*' arguments to the default _DISPATCH / etc. methods,
    # which are Private, will prevent those from being registered. They should
    # probably be turned into :Actions instead, or we might want to otherwise
    # disambiguate between those built-in internal actions and user-level
    # Private ones.
    %raw_attributes = (%{$all_actions_config}, %raw_attributes)
            unless $raw_attributes{Private};

    my %final_attributes;

    while (my ($key, $value) = each %raw_attributes) {
        my $new_attrs = $self->_parse_attr($c, $name, $key => $value);
        push @{$final_attributes{$_}}, @{$new_attrs->{$_}} for keys %$new_attrs;
    }

    return \%final_attributes;
}

sub _parse_attr {
    my ($self, $c, $name, $key, $values) = @_;

    my %final_attributes;
    foreach my $value (ref($values) eq 'ARRAY' ? @$values : $values) {
        my $meth = "_parse_${key}_attr";
        if (my $code = $self->can($meth)) {
            my %new_attrs = $self->$code($c, $name, $value);
            while (my ($new_key, $value) = each %new_attrs) {
                my $new_attrs = $key eq $new_key ?
                        { $new_key => [ $value ] } :
                        $self->_parse_attr($c, $name, $new_key => $value);
                push @{$final_attributes{$_}}, @{$new_attrs->{$_}} for keys %$new_attrs;
            }
        }
        else {
            push(@{$final_attributes{$key}}, $value);
        }
    }

    return \%final_attributes;
}

sub _parse_Global_attr {
    my ($self, $c, $name, $value) = @_;
    # _parse_attr will call _parse_Path_attr for us
    return Path => "/$name";
}

sub _parse_Absolute_attr {shift->_parse_Global_attr(@_);}

sub _parse_Local_attr {
    my ($self, $c, $name, $value) = @_;
    # _parse_attr will call _parse_Path_attr for us
    return Path => $name;
}

sub _parse_Relative_attr {shift->_parse_Local_attr(@_);}

sub _parse_Path_attr {
    my ($self, $c, $name, $value) = @_;
    $value = '' if !defined $value;
    if ($value =~ m!^/!) {
        return ('Path', $value);
    }
    elsif (length $value) {
        return ('Path', join('/', $self->path_prefix($c), $value));
    }
    else {
        return ('Path', $self->path_prefix($c));
    }
}

sub _parse_Chained_attr {
    my ($self, $c, $name, $value) = @_;

    if (defined($value) && length($value)) {
        if ($value eq '.') {
            $value = '/' . $self->action_namespace($c);
        }
        elsif (my ($rel, $rest) = $value =~ /^((?:\.{2}\/)+)(.*)$/) {
            my @parts = split '/', $self->action_namespace($c);
            my @levels = split '/', $rel;

            $value = '/' . join('/', @parts[0 .. $#parts - @levels], $rest);
        }
        elsif ($value !~ m/^\//) {
            my $action_ns = $self->action_namespace($c);

            if ($action_ns) {
                $value = '/' . join('/', $action_ns, $value);
            }
            else {
                $value = '/' . $value; # special case namespace '' (root)
            }
        }
    }
    else {
        $value = '/'
    }

    return Chained => $value;
}

sub _parse_ChainedParent_attr {
    my ($self, $c, $name, $value) = @_;
    return $self->_parse_Chained_attr($c, $name, '../' . $name);
}

sub _parse_PathPrefix_attr {
    my ($self, $c) = @_;
    return PathPart => $self->path_prefix($c);
}

sub _parse_ActionClass_attr {
    my ($self, $c, $name, $value) = @_;
    my $appname = $self->_application;
    $value = Catalyst::Utils::resolve_namespace($appname . '::Action', $self->_action_class, $value);
    return ('ActionClass', $value);
}

sub _parse_MyAction_attr {
    my ($self, $c, $name, $value) = @_;

    my $appclass = Catalyst::Utils::class2appclass($self);
    $value = "+${appclass}::Action::${value}";

    return ('ActionClass', $value);
}

sub _parse_Does_attr {
    my ($self, $app, $name, $value) = @_;
    return Does => $self->_expand_role_shortname($value);
}

sub _parse_GET_attr {Method => 'GET'}
sub _parse_POST_attr {Method => 'POST'}
sub _parse_PUT_attr {Method => 'PUT'}
sub _parse_DELETE_attr {Method => 'DELETE'}
sub _parse_OPTIONS_attr {Method => 'OPTIONS'}
sub _parse_HEAD_attr {Method => 'HEAD'}
sub _parse_PATCH_attr {Method => 'PATCH'}

sub _expand_role_shortname {
    my ($self, @shortnames) = @_;
    my $app = $self->_application;

    my $prefix = $self->can('_action_role_prefix') ? $self->_action_role_prefix : [ 'Catalyst::ActionRole::' ];
    my @prefixes = (qq{${app}::ActionRole::}, @$prefix);

    return String::RewritePrefix->rewrite(
            { ''        => sub {
                my $loaded = load_first_existing_class(
                        map {"$_$_[0]"} @prefixes
                );
                return first {$loaded =~ /^$_/}
                        sort {length $b <=> length $a} @prefixes;
            },
                    '~' => $prefixes[0],
                    '+' => '' },
            @shortnames,
    );
}

__PACKAGE__->meta->make_immutable;

1;

package Catalyst::Action;

=head1 NAME

Catalyst::Action - Catalyst Action

=head1 SYNOPSIS

    <form action="[%c.uri_for(c.action)%]">

    $c->forward( $action->private_path );

=head1 DESCRIPTION

This class represents a Catalyst Action. You can access the object for the
currently dispatched action via $c->action. See the L<Catalyst::Dispatcher>
for more information on how actions are dispatched. Actions are defined in
L<Catalyst::Controller> subclasses.

=cut

use Moose;
use Scalar::Util 'looks_like_number', 'blessed';
use Moose::Util::TypeConstraints ();
with 'MooseX::Emulate::Class::Accessor::Fast';
use namespace::clean -except => 'meta';

has class => (is => 'rw');
has instance => (is => 'ro', required => 0, predicate => 'has_instance');
has namespace => (is => 'rw');
has 'reverse' => (is => 'rw');
has attributes => (is => 'rw');
has name => (is => 'rw');
has code => (is => 'rw');
has private_path => (
        reader   => 'private_path',
        isa      => 'Str',
        lazy     => 1,
        required => 1,
        default  => sub {'/' . shift->reverse},
);

has number_of_args => (
        is       => 'ro',
        init_arg => undef,
        isa      => 'Int|Undef',
        required => 1,
        lazy     => 1,
        builder  => '_build_number_of_args');

sub _build_number_of_args {
    my $self = shift;
    if (!exists $self->attributes->{Args}) {
        # When 'Args' does not exist, that means we want 'any number of args'.
        return undef;
    }
    elsif (!defined($self->attributes->{Args}[0])) {
        # When its 'Args' that internal cue for 'unlimited'
        return undef;
    }
    elsif (
            scalar(@{$self->attributes->{Args}}) == 1 &&
                    looks_like_number($self->attributes->{Args}[0])
    ) {
        # 'Old school' numbered args (is allowed to be undef as well)
        return $self->attributes->{Args}[0];
    }
    else {
        # New hotness named arg constraints
        return $self->number_of_args_constraints;
    }
}

sub normalized_arg_number {
    return $_[0]->number_of_args;
}

sub comparable_arg_number {
    return defined($_[0]->number_of_args) ? $_[0]->number_of_args : ~0;
}

has number_of_args_constraints => (
        is       => 'ro',
        isa      => 'Int|Undef',
        init_arg => undef,
        required => 1,
        lazy     => 1,
        builder  => '_build_number_of_args_constraints');

sub _build_number_of_args_constraints {
    my $self = shift;
    return unless $self->has_args_constraints;

    # If there is one constraint and its a ref, we need to decide
    # if this number 'unknown' number or if the ref allows us to
    # determine a length.

    if (scalar @{$self->args_constraints} == 1) {
        my $tc = $self->args_constraints->[0];
        if (
                $tc->can('is_strictly_a_type_of') &&
                        $tc->is_strictly_a_type_of('Tuple')) {
            my @parameters = @{$tc->parameters || []};
            my $final = $parameters[-1];
            if (defined $final) {
                if (blessed $final) {
                    # modern form of slurpy
                    if ($final->can('is_strictly_a_type_of') && $final->is_strictly_a_type_of('Slurpy')) {
                        return undef;
                    }
                }
                else {
                    # old form of slurpy
                    if (ref $final eq 'HASH' && $final->{slurpy}) {
                        return undef;
                    }
                }
            }
            return scalar @parameters;
        }
        elsif ($tc->is_a_type_of('Ref')) {
            return undef;
        }
        else {
            return 1; # Its a normal 1 arg type constraint.
        }
    }
    else {
        # We need to loop through and error on ref types.  We don't allow a ref type
        # in the middle.
        my $total = 0;
        foreach my $tc (@{$self->args_constraints}) {
            if ($tc->is_a_type_of('Ref')) {
                die "$tc is a Ref type constraint.  You cannot mix Ref and non Ref type constraints in Args for action ${\$self->reverse}";
            }
            else {
                ++$total;
            }
        }
        return $total;
    }
}

has args_constraints => (
        is       => 'ro',
        init_arg => undef,
        traits   => [ 'Array' ],
        isa      => 'ArrayRef',
        required => 1,
        lazy     => 1,
        builder  => '_build_args_constraints',
        handles  => {
                has_args_constraints  => 'count',
                args_constraint_count => 'count',
                all_args_constraints  => 'elements',
        });

sub _build_args_constraints {
    my $self = shift;
    my @arg_protos = @{$self->attributes->{Args} || []};

    return [] unless scalar(@arg_protos);
    return [] unless defined($arg_protos[0]);

    # If there is only one arg and it looks like a number
    # we assume its 'classic' and the number is the number of
    # constraints.
    my @args = ();
    if (
            scalar(@arg_protos) == 1 &&
                    looks_like_number($arg_protos[0])
    ) {
        return \@args;
    }
    else {
        @args =
                map {my @tc = $self->resolve_type_constraint($_);
                    scalar(@tc) ? @tc : die "$_ is not a constraint!"}
                        @arg_protos;
    }
    return \@args;
}

has number_of_captures_constraints => (
        is       => 'ro',
        isa      => 'Int|Undef',
        init_arg => undef,
        required => 1,
        lazy     => 1,
        builder  => '_build_number_of_capture_constraints');

sub _build_number_of_capture_constraints {
    my $self = shift;
    return unless $self->has_captures_constraints;

    # If there is one constraint and its a ref, we need to decide
    # if this number 'unknown' number or if the ref allows us to
    # determine a length.

    if (scalar @{$self->captures_constraints} == 1) {
        my $tc = $self->captures_constraints->[0];
        if (
                $tc->can('is_strictly_a_type_of') &&
                        $tc->is_strictly_a_type_of('Tuple')) {
            my @parameters = @{$tc->parameters || []};
            if (defined($parameters[-1]) and exists($parameters[-1]->{slurpy})) {
                return undef;
            }
            else {
                return my $total_params = scalar(@parameters);
            }
        }
        elsif ($tc->is_a_type_of('Ref')) {
            die "You cannot use CaptureArgs($tc) in ${\$self->reverse} because we cannot determined the number of its parameters";
        }
        else {
            return 1; # Its a normal 1 arg type constraint.
        }
    }
    else {
        # We need to loop through and error on ref types.  We don't allow a ref type
        # in the middle.
        my $total = 0;
        foreach my $tc (@{$self->captures_constraints}) {
            if ($tc->is_a_type_of('Ref')) {
                die "$tc is a Ref type constraint.  You cannot mix Ref and non Ref type constraints in CaptureArgs for action ${\$self->reverse}";
            }
            else {
                ++$total;
            }
        }
        return $total;
    }
}

has captures_constraints => (
        is       => 'ro',
        init_arg => undef,
        traits   => [ 'Array' ],
        isa      => 'ArrayRef',
        required => 1,
        lazy     => 1,
        builder  => '_build_captures_constraints',
        handles  => {
                has_captures_constraints   => 'count',
                captures_constraints_count => 'count',
                all_captures_constraints   => 'elements',
        });

sub _build_captures_constraints {
    my $self = shift;
    my @arg_protos = @{$self->attributes->{CaptureArgs} || []};

    return [] unless scalar(@arg_protos);
    return [] unless defined($arg_protos[0]);
    # If there is only one arg and it looks like a number
    # we assume its 'classic' and the number is the number of
    # constraints.
    my @args = ();
    if (
            scalar(@arg_protos) == 1 &&
                    looks_like_number($arg_protos[0])
    ) {
        return \@args;
    }
    else {
        @args =
                map {my @tc = $self->resolve_type_constraint($_);
                    scalar(@tc) ? @tc : die "$_ is not a constraint!"}
                        @arg_protos;
    }

    return \@args;
}

sub resolve_type_constraint {
    my ($self, $name) = @_;

    if (defined($name) && blessed($name) && $name->can('check')) {
        # Its already a TC, good to go.
        return $name;
    }

    # This is broken for when there is more than one constraint
    if ($name =~ m/::/) {
        eval "use Type::Registry; 1" || die "Can't resolve type constraint $name without installing Type::Tiny";
        my $tc = Type::Registry->new->foreign_lookup($name);
        return defined $tc ? $tc : die "'$name' not a full namespace type constraint in ${\$self->private_path}";
    }

    my @tc = grep {defined $_} (eval("package ${\$self->class}; $name"));

    unless (scalar @tc) {
        # ok... so its not defined in the package.  we need to look at all the roles
        # and superclasses, look for attributes and figure it out.
        # Superclasses take precedence;

        my @supers = $self->class->can('meta') ? map {$_->meta} $self->class->meta->superclasses : ();
        my @roles = $self->class->can('meta') ? $self->class->meta->calculate_all_roles : ();

        # So look through all the super and roles in order and return the
        # first type constraint found. We should probably find all matching
        # type constraints and try to do some sort of resolution.

        foreach my $parent (@roles, @supers) {
            if (my $m = $parent->get_method($self->name)) {
                if ($m->can('attributes')) {
                    my ($key, $value) = map {$_ =~ /^(.*?)(?:\(\s*(.+?)\s*\))?$/}
                            grep {$_ =~ /^Args\(/ or $_ =~ /^CaptureArgs\(/}
                                    @{$m->attributes};
                    next unless $value eq $name;
                    my @tc = eval "package ${\$parent->name}; $name";
                    if (scalar(@tc)) {
                        return map {ref($_) ? $_ : Moose::Util::TypeConstraints::find_or_parse_type_constraint($_)} @tc;
                    }
                    else {
                        return;
                    }
                }
            }
        }

        my $classes = join(',', $self->class, @roles, @supers);
        die "'$name' not a type constraint in '${\$self->private_path}', Looked in: $classes";
    }

    if (scalar(@tc)) {
        return map {ref($_) ? $_ : Moose::Util::TypeConstraints::find_or_parse_type_constraint($_)} @tc;
    }
    else {
        return;
    }
}

has number_of_captures => (
        is       => 'ro',
        init_arg => undef,
        isa      => 'Int',
        required => 1,
        lazy     => 1,
        builder  => '_build_number_of_captures');

sub _build_number_of_captures {
    my $self = shift;
    if (!exists $self->attributes->{CaptureArgs}) {
        # If there are no defined capture args, thats considered 0.
        return 0;
    }
    elsif (!defined($self->attributes->{CaptureArgs}[0])) {
        # If you fail to give a defined value, that's also 0
        return 0;
    }
    elsif (
            scalar(@{$self->attributes->{CaptureArgs}}) == 1 &&
                    looks_like_number($self->attributes->{CaptureArgs}[0])
    ) {
        # 'Old school' numbered captures
        return $self->attributes->{CaptureArgs}[0];
    }
    else {
        # New hotness named arg constraints
        return $self->number_of_captures_constraints;
    }
}

use overload (

        # Stringify to reverse for debug output etc.
        q{""}    => sub {shift->{reverse}},

        # Codulate to execute to invoke the encapsulated action coderef
        '&{}'    => sub {
            my $self = shift;
            sub {$self->execute(@_);};
        },

        # Make general $stuff still work
        fallback => 1,

);

no warnings 'recursion';

sub dispatch {
    # Execute ourselves against a context
    my ($self, $c) = @_;
    if ($self->has_instance) {
        return $c->execute($self->instance, $self);
    }
    else {
        return $c->execute($self->class, $self);
    }
}

sub execute {
    my $self = shift;
    $self->code->(@_);
}

sub match {
    my ($self, $c) = @_;
    return $self->match_args($c, $c->req->args);
}

sub match_args {
    my ($self, $c, $args) = @_;
    my @args = @{$args || []};

    # There there are arg constraints, we must see to it that the constraints
    # check positive for each arg in the list.
    if ($self->has_args_constraints) {
        # If there is only one type constraint, and its a Ref or subtype of Ref,
        # That means we expect a reference, so use the full args arrayref.
        if (
                $self->args_constraint_count == 1 &&
                        (
                                $self->args_constraints->[0]->is_a_type_of('Ref') ||
                                        $self->args_constraints->[0]->is_a_type_of('ClassName')
                        )
        ) {
            # Ok, the the type constraint is a ref type, which is allowed to have
            # any number of args.  We need to check the arg length, if one is defined.
            # If we had a ref type constraint that allowed us to determine the allowed
            # number of args, we need to match that number.  Otherwise if there was an
            # undetermined number (~0) then we allow all the args.  This is more of an
            # Optimization since Tuple[Int, Int] would fail on 3,4,5 anyway, but this
            # way we can avoid calling the constraint when the arg length is incorrect.
            if (
                    $self->comparable_arg_number == ~0 ||
                            scalar(@args) == $self->comparable_arg_number
            ) {
                return $self->args_constraints->[0]->check($args);
            }
            else {
                return 0;
            }
            # Removing coercion stuff for the first go
            #if($self->args_constraints->[0]->coercion && $self->attributes->{Coerce}) {
            #  my $coerced = $self->args_constraints->[0]->coerce($c) || return 0;
            #  $c->req->args([$coerced]);
            #  return 1;
            #}
        }
        else {
            # Because of the way chaining works, we can expect args that are totally not
            # what you'd expect length wise.  When they don't match length, thats a fail
            return 0 unless scalar(@args) == $self->comparable_arg_number;

            for my $i (0 .. $#args) {
                $self->args_constraints->[$i]->check($args[$i]) || return 0;
            }
            return 1;
        }
    }
    else {
        # If infinite args with no constraints, we always match
        return 1 if $self->comparable_arg_number == ~0;

        # Otherwise, we just need to match the number of args.
        return scalar(@args) == $self->comparable_arg_number;
    }
}

sub match_captures {
    my ($self, $c, $captures) = @_;
    my @captures = @{$captures || []};

    return 1 unless scalar(@captures); # If none, just say its ok
    return $self->has_captures_constraints ?
            $self->match_captures_constraints($c, $captures) : 1;

    return 1;
}

sub match_captures_constraints {
    my ($self, $c, $captures) = @_;
    my @captures = @{$captures || []};

    # Match is positive if you don't have any.
    return 1 unless $self->has_captures_constraints;

    if (
            $self->captures_constraints_count == 1 &&
                    (
                            $self->captures_constraints->[0]->is_a_type_of('Ref') ||
                                    $self->captures_constraints->[0]->is_a_type_of('ClassName')
                    )
    ) {
        return $self->captures_constraints->[0]->check($captures);
    }
    else {
        for my $i (0 .. $#captures) {
            $self->captures_constraints->[$i]->check($captures[$i]) || return 0;
        }
        return 1;
    }

}

sub compare {
    my ($a1, $a2) = @_;
    return $a1->comparable_arg_number <=> $a2->comparable_arg_number;
}

sub equals {
    my ($self, $target) = @_;
    return $self->private_path eq $target->private_path ? $self : 0;
}

sub scheme {
    return exists $_[0]->attributes->{Scheme} ? $_[0]->attributes->{Scheme}[0] : undef;
}

sub list_extra_info {
    my $self = shift;
    return {
            Args        => $self->normalized_arg_number,
            CaptureArgs => $self->number_of_captures,
    }
}

__PACKAGE__->meta->make_immutable;

1;

package Catalyst;

use Moose;
use Moose::Meta::Class ();
extends 'Catalyst::Component';
use Moose::Util qw/find_meta/;
use namespace::clean -except => 'meta';
use Catalyst::Exception;
use Catalyst::Exception::Detach;
use Catalyst::Exception::Go;
use Catalyst::Log;
use Catalyst::Request;
use Catalyst::Request::Upload;
use Catalyst::Response;
use Catalyst::Utils;
use Catalyst::Controller;
use Data::OptList;
use Devel::InnerPackage ();
use Module::Pluggable::Object ();
use Text::SimpleTable ();
use Path::Class::Dir ();
use Path::Class::File ();
use URI ();
use URI::http;
use URI::https;
use HTML::Entities;
use Tree::Simple qw/use_weak_refs/;
use Tree::Simple::Visitor::FindByUID;
use Class::C3::Adopt::NEXT;
use List::Util qw/uniq/;
use attributes;
use String::RewritePrefix;
use Catalyst::EngineLoader;
use utf8;
use Carp qw/croak carp shortmess/;
use Try::Tiny;
use Safe::Isa;
use Moose::Util 'find_meta';
use Plack::Middleware::Conditional;
use Plack::Middleware::ReverseProxy;
use Plack::Middleware::IIS6ScriptNameFix;
use Plack::Middleware::IIS7KeepAliveFix;
use Plack::Middleware::LighttpdScriptNameFix;
use Plack::Middleware::ContentLength;
use Plack::Middleware::Head;
use Plack::Middleware::HTTPExceptions;
use Plack::Middleware::FixMissingBodyInRedirect;
use Plack::Middleware::MethodOverride;
use Plack::Middleware::RemoveRedundantBody;
use Catalyst::Middleware::Stash;
use Plack::Util;
use Class::Load 'load_class';
use Encode 2.21 'decode_utf8', 'encode_utf8';
use Scalar::Util;

our $VERSION = '5.90130';
$VERSION =~ tr/_//d;

BEGIN {require 5.008003;}

has stack => (is => 'ro', default => sub {[]});
has state => (is => 'rw', default => 0);
has stats => (is => 'rw');
has action => (is => 'rw');
has counter => (is => 'rw', default => sub {{}});
has request => (
        is        => 'rw',
        default   => sub {
            my $self = shift;
            my $class = ref $self;
            my $composed_request_class = $class->composed_request_class;
            return $composed_request_class->new($self->_build_request_constructor_args);
        },
        predicate => 'has_request',
        lazy      => 1,
);
sub _build_request_constructor_args {
    my $self = shift;
    my %p = (_log => $self->log);
    $p{_uploadtmp} = $self->_uploadtmp if $self->_has_uploadtmp;
    $p{data_handlers} = { $self->registered_data_handlers };
    $p{_use_hash_multivalue} = $self->config->{use_hash_multivalue_in_request}
            if $self->config->{use_hash_multivalue_in_request};
    \%p;
}

sub composed_request_class {
    my $class = shift;
    return $class->_composed_request_class if $class->_composed_request_class;

    my @traits = (@{$class->request_class_traits || []}, @{$class->config->{request_class_traits} || []});

    # For each trait listed, figure out what the namespace is.  First we try the $trait
    # as it is in the config.  Then try $MyApp::TraitFor::Request:$trait. Last we try
    # Catalyst::TraitFor::Request::$trait.  If none load, throw error.

    my $trait_ns = 'TraitFor::Request';
    my @normalized_traits = map {
        Class::Load::load_first_existing_class($_, $class . '::' . $trait_ns . '::' . $_, 'Catalyst::' . $trait_ns . '::' . $_)
    } @traits;

    if ($class->debug && scalar(@normalized_traits)) {
        my $column_width = Catalyst::Utils::term_width() - 6;
        my $t = Text::SimpleTable->new($column_width);
        $t->row($_) for @normalized_traits;
        $class->log->debug("Composed Request Class Traits:\n" . $t->draw . "\n");
    }

    return $class->_composed_request_class(Moose::Util::with_traits($class->request_class, @normalized_traits));
}

has response => (
        is        => 'rw',
        default   => sub {
            my $self = shift;
            my $class = ref $self;
            my $composed_response_class = $class->composed_response_class;
            return $composed_response_class->new($self->_build_response_constructor_args);
        },
        predicate => 'has_response',
        lazy      => 1,
);
sub _build_response_constructor_args {
    return +{
            _log     => $_[0]->log,
            encoding => $_[0]->encoding,
    };
}

sub composed_response_class {
    my $class = shift;
    return $class->_composed_response_class if $class->_composed_response_class;

    my @traits = (@{$class->response_class_traits || []}, @{$class->config->{response_class_traits} || []});

    my $trait_ns = 'TraitFor::Response';
    my @normalized_traits = map {
        Class::Load::load_first_existing_class($_, $class . '::' . $trait_ns . '::' . $_, 'Catalyst::' . $trait_ns . '::' . $_)
    } @traits;

    if ($class->debug && scalar(@normalized_traits)) {
        my $column_width = Catalyst::Utils::term_width() - 6;
        my $t = Text::SimpleTable->new($column_width);
        $t->row($_) for @normalized_traits;
        $class->log->debug("Composed Response Class Traits:\n" . $t->draw . "\n");
    }

    return $class->_composed_response_class(Moose::Util::with_traits($class->response_class, @normalized_traits));
}

has namespace => (is => 'rw');

sub depth {scalar @{shift->stack || []};}
sub comp {shift->component(@_)}

sub req {
    my $self = shift;
    return $self->request(@_);
}
sub res {
    my $self = shift;
    return $self->response(@_);
}

# For backwards compatibility
sub finalize_output {shift->finalize_body(@_)};

# For statistics
our $COUNT = 1;
our $START = time;
our $RECURSION = 1000;
our $DETACH = Catalyst::Exception::Detach->new;
our $GO = Catalyst::Exception::Go->new;

#I imagine that very few of these really
#need to be class variables. if any.
#maybe we should just make them attributes with a default?
__PACKAGE__->mk_classdata($_)
        for qw/components arguments dispatcher engine log dispatcher_class
                engine_loader context_class request_class response_class stats_class
                setup_finished _psgi_app loading_psgi_file run_options _psgi_middleware
                _data_handlers _encoding _encode_check finalized_default_middleware
                request_class_traits response_class_traits stats_class_traits
                _composed_request_class _composed_response_class _composed_stats_class/;

__PACKAGE__->dispatcher_class('Catalyst::Dispatcher');
__PACKAGE__->request_class('Catalyst::Request');
__PACKAGE__->response_class('Catalyst::Response');
__PACKAGE__->stats_class('Catalyst::Stats');

sub composed_stats_class {
    my $class = shift;
    return $class->_composed_stats_class if $class->_composed_stats_class;

    my @traits = (@{$class->stats_class_traits || []}, @{$class->config->{stats_class_traits} || []});

    my $trait_ns = 'TraitFor::Stats';
    my @normalized_traits = map {
        Class::Load::load_first_existing_class($_, $class . '::' . $trait_ns . '::' . $_, 'Catalyst::' . $trait_ns . '::' . $_)
    } @traits;

    if ($class->debug && scalar(@normalized_traits)) {
        my $column_width = Catalyst::Utils::term_width() - 6;
        my $t = Text::SimpleTable->new($column_width);
        $t->row($_) for @normalized_traits;
        $class->log->debug("Composed Stats Class Traits:\n" . $t->draw . "\n");
    }

    return $class->_composed_stats_class(Moose::Util::with_traits($class->stats_class, @normalized_traits));
}

__PACKAGE__->_encode_check(Encode::FB_CROAK | Encode::LEAVE_SRC);

sub import {
    my ($class, @arguments) = @_;

    # We have to limit $class to Catalyst to avoid pushing Catalyst upon every
    # callers @ISA.
    return unless $class eq 'Catalyst';

    my $caller = caller();
    return if $caller eq 'main';

    my $meta = Moose::Meta::Class->initialize($caller);
    unless ($caller->isa('Catalyst')) {
        my @superclasses = ($meta->superclasses, $class, 'Catalyst::Controller');
        $meta->superclasses(@superclasses);
    }
    # Avoid possible C3 issues if 'Moose::Object' is already on RHS of MyApp
    $meta->superclasses(grep {$_ ne 'Moose::Object'} $meta->superclasses);

    unless ($meta->has_method('meta')) {
        if ($Moose::VERSION >= 1.15) {
            $meta->_add_meta_method('meta');
        }
        else {
            $meta->add_method(meta => sub {Moose::Meta::Class->initialize("${caller}")});
        }
    }

    $caller->arguments([ @arguments ]);
    $caller->setup_home;
}

sub _application {$_[0]}

=encoding UTF-8

=head1 NAME

Catalyst - The Elegant MVC Web Application Framework

=head1 SYNOPSIS

See the L<Catalyst::Manual> distribution for comprehensive
documentation and tutorials.

    # Install Catalyst::Devel for helpers and other development tools
    # use the helper to create a new application
    catalyst.pl MyApp

    # add models, views, controllers
    script/myapp_create.pl model MyDatabase DBIC::Schema create=static dbi:SQLite:/path/to/db
    script/myapp_create.pl view MyTemplate TT
    script/myapp_create.pl controller Search

    # built in testserver -- use -r to restart automatically on changes
    # --help to see all available options
    script/myapp_server.pl

    # command line testing interface
    script/myapp_test.pl /yada

    ### in lib/MyApp.pm
    use Catalyst qw/-Debug/; # include plugins here as well

    ### In lib/MyApp/Controller/Root.pm (autocreated)
    sub foo : Chained('/') Args() { # called for /foo, /foo/1, /foo/1/2, etc.
        my ( $self, $c, @args ) = @_; # args are qw/1 2/ for /foo/1/2
        $c->stash->{template} = 'foo.tt'; # set the template
        # lookup something from db -- stash vars are passed to TT
        $c->stash->{data} =
          $c->model('Database::Foo')->search( { country => $args[0] } );
        if ( $c->req->params->{bar} ) { # access GET or POST parameters
            $c->forward( 'bar' ); # process another action
            # do something else after forward returns
        }
    }

    # The foo.tt TT template can use the stash data from the database
    [% WHILE (item = data.next) %]
        [% item.foo %]
    [% END %]

    # called for /bar/of/soap, /bar/of/soap/10, etc.
    sub bar : Chained('/') PathPart('/bar/of/soap') Args() { ... }

    # called after all actions are finished
    sub end : Action {
        my ( $self, $c ) = @_;
        if ( scalar @{ $c->error } ) { ... } # handle errors
        return if $c->res->body; # already have a response
        $c->forward( 'MyApp::View::TT' ); # render template
    }

See L<Catalyst::Manual::Intro> for additional information.

=head1 DESCRIPTION

Catalyst is a modern framework for making web applications without the
pain usually associated with this process. This document is a reference
to the main Catalyst application. If you are a new user, we suggest you
start with L<Catalyst::Manual::Tutorial> or L<Catalyst::Manual::Intro>.

See L<Catalyst::Manual> for more documentation.

Catalyst plugins can be loaded by naming them as arguments to the "use
Catalyst" statement. Omit the C<Catalyst::Plugin::> prefix from the
plugin name, i.e., C<Catalyst::Plugin::My::Module> becomes
C<My::Module>.

    use Catalyst qw/My::Module/;

If your plugin starts with a name other than C<Catalyst::Plugin::>, you can
fully qualify the name by using a unary plus:

    use Catalyst qw/
        My::Module
        +Fully::Qualified::Plugin::Name
    /;

Special flags like C<-Debug> can also be specified as
arguments when Catalyst is loaded:

    use Catalyst qw/-Debug My::Module/;

The position of plugins and flags in the chain is important, because
they are loaded in the order in which they appear.

The following flags are supported:

=head2 -Debug

Enables debug output. You can also force this setting from the system
environment with CATALYST_DEBUG or <MYAPP>_DEBUG. The environment
settings override the application, with <MYAPP>_DEBUG having the highest
priority.

This sets the log level to 'debug' and enables full debug output on the
error screen. If you only want the latter, see L<< $c->debug >>.

=head2 -Home

Forces Catalyst to use a specific home directory, e.g.:

    use Catalyst qw[-Home=/usr/mst];

This can also be done in the shell environment by setting either the
C<CATALYST_HOME> environment variable or C<MYAPP_HOME>; where C<MYAPP>
is replaced with the uppercased name of your application, any "::" in
the name will be replaced with underscores, e.g. MyApp::Web should use
MYAPP_WEB_HOME. If both variables are set, the MYAPP_HOME one will be used.

If none of these are set, Catalyst will attempt to automatically detect the
home directory. If you are working in a development environment, Catalyst
will try and find the directory containing either Makefile.PL, Build.PL,
dist.ini, or cpanfile. If the application has been installed into the system
(i.e. you have done C<make install>), then Catalyst will use the path to your
application module, without the .pm extension (e.g., /foo/MyApp if your
application was installed at /foo/MyApp.pm)

=head2 -Log

    use Catalyst '-Log=warn,fatal,error';

Specifies a comma-delimited list of log levels.

=head2 -Stats

Enables statistics collection and reporting.

   use Catalyst qw/-Stats=1/;

You can also force this setting from the system environment with CATALYST_STATS
or <MYAPP>_STATS. The environment settings override the application, with
<MYAPP>_STATS having the highest priority.

Stats are also enabled if L<< debugging |/"-Debug" >> is enabled.

=head1 METHODS

=head2 INFORMATION ABOUT THE CURRENT REQUEST

=head2 $c->action

Returns a L<Catalyst::Action> object for the current action, which
stringifies to the action name. See L<Catalyst::Action>.

=head2 $c->namespace

Returns the namespace of the current action, i.e., the URI prefix
corresponding to the controller of the current action. For example:

    # in Controller::Foo::Bar
    $c->namespace; # returns 'foo/bar';

=head2 $c->request

=head2 $c->req

Returns the current L<Catalyst::Request> object, giving access to
information about the current client request (including parameters,
cookies, HTTP headers, etc.). See L<Catalyst::Request>.

There is a predicate method C<has_request> that returns true if the
request object has been created.  This is something you might need to
check if you are writing plugins that run before a request is finalized.

=head2 REQUEST FLOW HANDLING

=head2 $c->forward( $action [, \@arguments ] )

=head2 $c->forward( $class, $method, [, \@arguments ] )

=head2 $c->forward( $component_instance, $method, [, \@arguments ] )


This is one way of calling another action (method) in the same or
a different controller. You can also use C<< $self->my_method($c, @args) >>
in the same controller or C<< $c->controller('MyController')->my_method($c, @args) >>
in a different controller.
The main difference is that 'forward' uses some of the Catalyst request
cycle overhead, including debugging, which may be useful to you. On the
other hand, there are some complications to using 'forward', restrictions
on values returned from 'forward', and it may not handle errors as you prefer.
Whether you use 'forward' or not is up to you; it is not considered superior to
the other ways to call a method.

'forward' calls  another action, by its private name. If you give a
class name but no method, C<process()> is called. You may also optionally
pass arguments in an arrayref. The action will receive the arguments in
C<@_> and C<< $c->req->args >>. Upon returning from the function,
C<< $c->req->args >> will be restored to the previous values.

Any data C<return>ed from the action forwarded to, will be returned by the
call to forward.

    my $foodata = $c->forward('/foo');
    $c->forward('index');
    $c->forward(qw/Model::DBIC::Foo do_stuff/);
    $c->forward('View::TT');

Note that L<< forward|/"$c->forward( $action [, \@arguments ] )" >> implies
an C<< eval { } >> around the call (actually
L<< execute|/"$c->execute( $class, $coderef )" >> does), thus rendering all
exceptions thrown by the called action non-fatal and pushing them onto
$c->error instead. If you want C<die> to propagate you need to do something
like:

    $c->forward('foo');
    die join "\n", @{ $c->error } if @{ $c->error };

Or make sure to always return true values from your actions and write
your code like this:

    $c->forward('foo') || return;

Another note is that C<< $c->forward >> always returns a scalar because it
actually returns $c->state which operates in a scalar context.
Thus, something like:

    return @array;

in an action that is forwarded to is going to return a scalar,
i.e. how many items are in that array, which is probably not what you want.
If you need to return an array then return a reference to it,
or stash it like so:

    $c->stash->{array} = \@array;

and access it from the stash.

Keep in mind that the C<end> method used is that of the caller action. So a C<< $c->detach >> inside a forwarded action would run the C<end> method from the original action requested.

If you call c<forward> with the name of a component class or instance, rather than an action name
or instance, we invoke the C<process> action on that class or instance, or whatever action you
specific via the second argument $method.

=cut

sub forward {
    my $c = shift;
    no warnings 'recursion';
    $c->dispatcher->forward($c, @_)
}

=head2 $c->detach( $action [, \@arguments ] )

=head2 $c->detach( $class, $method, [, \@arguments ] )

=head2 $c->detach()

The same as L<< forward|/"$c->forward( $action [, \@arguments ] )" >>, but
doesn't return to the previous action when processing is finished.

When called with no arguments it escapes the processing chain entirely.

=cut

sub detach {
    my $c = shift;
    $c->dispatcher->detach($c, @_)
}

=head2 $c->visit( $action [, \@arguments ] )

=head2 $c->visit( $action [, \@captures, \@arguments ] )

=head2 $c->visit( $class, $method, [, \@arguments ] )

=head2 $c->visit( $class, $method, [, \@captures, \@arguments ] )

Almost the same as L<< forward|/"$c->forward( $action [, \@arguments ] )" >>,
but does a full dispatch, instead of just calling the new C<$action> /
C<< $class->$method >>. This means that C<begin>, C<auto> and the method
you go to are called, just like a new request.

In addition both C<< $c->action >> and C<< $c->namespace >> are localized.
This means, for example, that C<< $c->action >> methods such as
L<name|Catalyst::Action/name>, L<class|Catalyst::Action/class> and
L<reverse|Catalyst::Action/reverse> return information for the visited action
when they are invoked within the visited action.  This is different from the
behavior of L<< forward|/"$c->forward( $action [, \@arguments ] )" >>, which
continues to use the $c->action object from the caller action even when
invoked from the called action.

C<< $c->stash >> is kept unchanged.

In effect, L<< visit|/"$c->visit( $action [, \@captures, \@arguments ] )" >>
allows you to "wrap" another action, just as it would have been called by
dispatching from a URL, while the analogous
L<< go|/"$c->go( $action [, \@captures, \@arguments ] )" >> allows you to
transfer control to another action as if it had been reached directly from a URL.

=cut

sub visit {
    my $c = shift;
    $c->dispatcher->visit($c, @_)
}

=head2 $c->go( $action [, \@arguments ] )

=head2 $c->go( $action [, \@captures, \@arguments ] )

=head2 $c->go( $class, $method, [, \@arguments ] )

=head2 $c->go( $class, $method, [, \@captures, \@arguments ] )

The relationship between C<go> and
L<< visit|/"$c->visit( $action [, \@captures, \@arguments ] )" >> is the same as
the relationship between
L<< forward|/"$c->forward( $class, $method, [, \@arguments ] )" >> and
L<< detach|/"$c->detach( $action [, \@arguments ] )" >>. Like C<< $c->visit >>,
C<< $c->go >> will perform a full dispatch on the specified action or method,
with localized C<< $c->action >> and C<< $c->namespace >>. Like C<detach>,
C<go> escapes the processing of the current request chain on completion, and
does not return to its caller.

@arguments are arguments to the final destination of $action. @captures are
arguments to the intermediate steps, if any, on the way to the final sub of
$action.

=cut

sub go {
    my $c = shift;
    $c->dispatcher->go($c, @_)
}

=head2 $c->response

=head2 $c->res

Returns the current L<Catalyst::Response> object, see there for details.

There is a predicate method C<has_response> that returns true if the
request object has been created.  This is something you might need to
check if you are writing plugins that run before a request is finalized.

=head2 $c->stash

Returns a hashref to the stash, which may be used to store data and pass
it between components during a request. You can also set hash keys by
passing arguments. The stash is automatically sent to the view. The
stash is cleared at the end of a request; it cannot be used for
persistent storage (for this you must use a session; see
L<Catalyst::Plugin::Session> for a complete system integrated with
Catalyst).

    $c->stash->{foo} = $bar;
    $c->stash( { moose => 'majestic', qux => 0 } );
    $c->stash( bar => 1, gorch => 2 ); # equivalent to passing a hashref

    # stash is automatically passed to the view for use in a template
    $c->forward( 'MyApp::View::TT' );

The stash hash is currently stored in the PSGI C<$env> and is managed by
L<Catalyst::Middleware::Stash>.  Since it's part of the C<$env> items in
the stash can be accessed in sub applications mounted under your main
L<Catalyst> application.  For example if you delegate the response of an
action to another L<Catalyst> application, that sub application will have
access to all the stash keys of the main one, and if can of course add
more keys of its own.  However those new keys will not 'bubble' back up
to the main application.

For more information the best thing to do is to review the test case:
t/middleware-stash.t in the distribution /t directory.

=cut

sub stash {
    my $c = shift;
    $c->log->error("You are requesting the stash but you don't have a context") unless blessed $c;
    return Catalyst::Middleware::Stash::get_stash($c->req->env)->(@_);
}

=head2 $c->error

=head2 $c->error($error, ...)

=head2 $c->error($arrayref)

Returns an arrayref containing error messages.  If Catalyst encounters an
error while processing a request, it stores the error in $c->error.  This
method should only be used to store fatal error messages.

    my @error = @{ $c->error };

Add a new error.

    $c->error('Something bad happened');

Calling this will always return an arrayref (if there are no errors it
will be an empty arrayref.

=cut

sub error {
    my $c = shift;
    if ($_[0]) {
        my $error = ref $_[0] eq 'ARRAY' ? $_[0] : [ @_ ];
        croak @$error unless ref $c;
        push @{$c->{error}}, @$error;
    }
    elsif (defined $_[0]) {$c->{error} = undef}
    return $c->{error} || [];
}

=head2 $c->state

Contains the return value of the last executed action.
Note that << $c->state >> operates in a scalar context which means that all
values it returns are scalar.

Please note that if an action throws an exception, the value of state
should no longer be considered the return if the last action.  It is generally
going to be 0, which indicates an error state.  Examine $c->error for error
details.

=head2 $c->clear_errors

Clear errors.  You probably don't want to clear the errors unless you are
implementing a custom error screen.

This is equivalent to running

    $c->error(0);

=cut

sub clear_errors {
    my $c = shift;
    $c->error(0);
}

=head2 $c->has_errors

Returns true if you have errors

=cut

sub has_errors {scalar(@{shift->error}) ? 1 : 0}

=head2 $c->last_error

Returns the most recent error in the stack (the one most recently added...)
or nothing if there are no errors.  This does not modify the contents of the
error stack.

=cut

sub last_error {
    my (@errs) = @{shift->error};
    return scalar(@errs) ? $errs[-1] : undef;
}

=head2 shift_errors

shifts the most recently added error off the error stack and returns it.  Returns
nothing if there are no more errors.

=cut

sub shift_errors {
    my ($self) = @_;
    my @errors = @{$self->error};
    my $err = shift(@errors);
    $self->{error} = \@errors;
    return $err;
}

=head2 pop_errors

pops the most recently added error off the error stack and returns it.  Returns
nothing if there are no more errors.

=cut

sub pop_errors {
    my ($self) = @_;
    my @errors = @{$self->error};
    my $err = pop(@errors);
    $self->{error} = \@errors;
    return $err;
}

sub _comp_search_prefixes {
    my $c = shift;
    return map $c->components->{ $_ }, $c->_comp_names_search_prefixes(@_);
}

# search components given a name and some prefixes
sub _comp_names_search_prefixes {
    my ($c, $name, @prefixes) = @_;
    my $appclass = ref $c || $c;
    my $filter = "^${appclass}::(" . join('|', @prefixes) . ')::';
    $filter = qr/$filter/; # Compile regex now rather than once per loop

    # map the original component name to the sub part that we will search against
    my %eligible = map {my $n = $_;
        $n =~ s{^$appclass\::[^:]+::}{};
        $_ => $n;}
            grep {/$filter/} keys %{$c->components};

    # undef for a name will return all
    return keys %eligible if !defined $name;

    my $query = $name->$_isa('Regexp') ? $name : qr/^$name$/i;
    my @result = grep {$eligible{$_} =~ m{$query}} keys %eligible;

    return @result if @result;

    # if we were given a regexp to search against, we're done.
    return if $name->$_isa('Regexp');

    # skip regexp fallback if configured
    return
            if $appclass->config->{disable_component_resolution_regex_fallback};

    # regexp fallback
    $query = qr/$name/i;
    @result = grep {$eligible{ $_ } =~ m{$query}} keys %eligible;

    # no results? try against full names
    if (!@result) {
        @result = grep {m{$query}} keys %eligible;
    }

    # don't warn if we didn't find any results, it just might not exist
    if (@result) {
        # Disgusting hack to work out correct method name
        my $warn_for = lc $prefixes[0];
        my $msg = "Used regexp fallback for \$c->${warn_for}('${name}'), which found '" .
                (join '", "', @result) . "'. Relying on regexp fallback behavior for " .
                "component resolution is unreliable and unsafe.";
        my $short = $result[0];
        # remove the component namespace prefix
        $short =~ s/.*?(Model|Controller|View):://;
        my $shortmess = Carp::shortmess('');
        if ($shortmess =~ m#Catalyst/Plugin#) {
            $msg .= " You probably need to set '$short' instead of '${name}' in this " .
                    "plugin's config";
        }
        elsif ($shortmess =~ m#Catalyst/lib/(View|Controller)#) {
            $msg .= " You probably need to set '$short' instead of '${name}' in this " .
                    "component's config";
        }
        else {
            $msg .= " You probably meant \$c->${warn_for}('$short') instead of \$c->${warn_for}('${name}'), " .
                    "but if you really wanted to search, pass in a regexp as the argument " .
                    "like so: \$c->${warn_for}(qr/${name}/)";
        }
        $c->log->warn("${msg}$shortmess");
    }

    return @result;
}

# Find possible names for a prefix
sub _comp_names {
    my ($c, @prefixes) = @_;
    my $appclass = ref $c || $c;

    my $filter = "^${appclass}::(" . join('|', @prefixes) . ')::';

    my @names = map {s{$filter}{};
        $_;}
            $c->_comp_names_search_prefixes(undef, @prefixes);

    return @names;
}

# Filter a component before returning by calling ACCEPT_CONTEXT if available

sub _filter_component {
    my ($c, $comp, @args) = @_;

    if (ref $comp eq 'CODE') {
        $comp = $comp->();
    }

    if (eval {$comp->can('ACCEPT_CONTEXT');}) {
        return $comp->ACCEPT_CONTEXT($c, @args);
    }

    $c->log->warn("You called component '${\$comp->catalyst_component_name}' with arguments [@args], but this component does not ACCEPT_CONTEXT, so args are ignored.") if scalar(@args) && $c->debug;

    return $comp;
}

=head2 COMPONENT ACCESSORS

=head2 $c->controller($name)

Gets a L<Catalyst::Controller> instance by name.

    $c->controller('Foo')->do_stuff;

If the name is omitted, will return the controller for the dispatched
action.

If you want to search for controllers, pass in a regexp as the argument.

    # find all controllers that start with Foo
    my @foo_controllers = $c->controller(qr{^Foo});


=cut

sub controller {
    my ($c, $name, @args) = @_;

    my $appclass = ref($c) || $c;
    if ($name) {
        unless ($name->$_isa('Regexp')) {
            # Direct component hash lookup to avoid costly regexps
            my $comps = $c->components;
            my $check = $appclass . "::Controller::" . $name;
            return $c->_filter_component($comps->{$check}, @args) if exists $comps->{$check};
            foreach my $path (@{$appclass->config->{ setup_components }->{ search_extra }}) {
                next unless $path =~ /.*::Controller/;
                $check = $path . "::" . $name;
                return $c->_filter_component($comps->{$check}, @args) if exists $comps->{$check};
            }
        }
        my @result = $c->_comp_search_prefixes($name, qw/Controller C/);
        return map {$c->_filter_component($_, @args)} @result if ref $name;
        return $c->_filter_component($result[ 0 ], @args);
    }

    return $c->component($c->action->class);
}

=head2 $c->model($name)

Gets a L<Catalyst::Model> instance by name.

    $c->model('Foo')->do_stuff;

Any extra arguments are directly passed to ACCEPT_CONTEXT, if the model
defines ACCEPT_CONTEXT.  If it does not, the args are discarded.

If the name is omitted, it will look for
 - a model object in $c->stash->{current_model_instance}, then
 - a model name in $c->stash->{current_model}, then
 - a config setting 'default_model', or
 - check if there is only one model, and return it if that's the case.

If you want to search for models, pass in a regexp as the argument.

    # find all models that start with Foo
    my @foo_models = $c->model(qr{^Foo});

=cut

sub model {
    my ($c, $name, @args) = @_;
    my $appclass = ref($c) || $c;
    if ($name) {
        unless ($name->$_isa('Regexp')) {
            # Direct component hash lookup to avoid costly regexps
            my $comps = $c->components;
            my $check = $appclass . "::Model::" . $name;
            return $c->_filter_component($comps->{$check}, @args) if exists $comps->{$check};
            foreach my $path (@{$appclass->config->{ setup_components }->{ search_extra }}) {
                next unless $path =~ /.*::Model/;
                $check = $path . "::" . $name;
                return $c->_filter_component($comps->{$check}, @args) if exists $comps->{$check};
            }
        }
        my @result = $c->_comp_search_prefixes($name, qw/Model M/);
        return map {$c->_filter_component($_, @args)} @result if ref $name;
        return $c->_filter_component($result[ 0 ], @args);
    }

    if (ref $c) {
        return $c->stash->{current_model_instance}
                if $c->stash->{current_model_instance};
        return $c->model($c->stash->{current_model})
                if $c->stash->{current_model};
    }
    return $c->model($appclass->config->{default_model})
            if $appclass->config->{default_model};

    my ($comp, $rest) = $c->_comp_search_prefixes(undef, qw/Model M/);

    if ($rest) {
        $c->log->warn(Carp::shortmess('Calling $c->model() will return a random model unless you specify one of:'));
        $c->log->warn('* $c->config(default_model => "the name of the default model to use")');
        $c->log->warn('* $c->stash->{current_model} # the name of the model to use for this request');
        $c->log->warn('* $c->stash->{current_model_instance} # the instance of the model to use for this request');
        $c->log->warn('NB: in version 5.81, the "random" behavior will not work at all.');
    }

    return $c->_filter_component($comp);
}


=head2 $c->view($name)

Gets a L<Catalyst::View> instance by name.

    $c->view('Foo')->do_stuff;

Any extra arguments are directly passed to ACCEPT_CONTEXT.

If the name is omitted, it will look for
 - a view object in $c->stash->{current_view_instance}, then
 - a view name in $c->stash->{current_view}, then
 - a config setting 'default_view', or
 - check if there is only one view, and return it if that's the case.

If you want to search for views, pass in a regexp as the argument.

    # find all views that start with Foo
    my @foo_views = $c->view(qr{^Foo});

=cut

sub view {
    my ($c, $name, @args) = @_;

    my $appclass = ref($c) || $c;
    if ($name) {
        unless ($name->$_isa('Regexp')) {
            # Direct component hash lookup to avoid costly regexps
            my $comps = $c->components;
            my $check = $appclass . "::View::" . $name;
            if (exists $comps->{$check}) {
                return $c->_filter_component($comps->{$check}, @args);
            }
            else {
                $c->log->warn("Attempted to use view '$check', but does not exist");
            }
            foreach my $path (@{$appclass->config->{ setup_components }->{ search_extra }}) {
                next unless $path =~ /.*::View/;
                $check = $path . "::" . $name;
                return $c->_filter_component($comps->{$check}, @args) if exists $comps->{$check};
            }
        }
        my @result = $c->_comp_search_prefixes($name, qw/View V/);
        return map {$c->_filter_component($_, @args)} @result if ref $name;
        return $c->_filter_component($result[ 0 ], @args);
    }

    if (ref $c) {
        return $c->stash->{current_view_instance}
                if $c->stash->{current_view_instance};
        return $c->view($c->stash->{current_view})
                if $c->stash->{current_view};
    }
    return $c->view($appclass->config->{default_view})
            if $appclass->config->{default_view};

    my ($comp, $rest) = $c->_comp_search_prefixes(undef, qw/View V/);

    if ($rest) {
        $c->log->warn('Calling $c->view() will return a random view unless you specify one of:');
        $c->log->warn('* $c->config(default_view => "the name of the default view to use")');
        $c->log->warn('* $c->stash->{current_view} # the name of the view to use for this request');
        $c->log->warn('* $c->stash->{current_view_instance} # the instance of the view to use for this request');
        $c->log->warn('NB: in version 5.81, the "random" behavior will not work at all.');
    }

    return $c->_filter_component($comp);
}

=head2 $c->controllers

Returns the available names which can be passed to $c->controller

=cut

sub controllers {
    my ($c) = @_;
    return $c->_comp_names(qw/Controller C/);
}

=head2 $c->models

Returns the available names which can be passed to $c->model

=cut

sub models {
    my ($c) = @_;
    return $c->_comp_names(qw/Model M/);
}


=head2 $c->views

Returns the available names which can be passed to $c->view

=cut

sub views {
    my ($c) = @_;
    return $c->_comp_names(qw/View V/);
}

=head2 $c->comp($name)

=head2 $c->component($name)

Gets a component object by name. This method is not recommended,
unless you want to get a specific component by full
class. C<< $c->controller >>, C<< $c->model >>, and C<< $c->view >>
should be used instead.

If C<$name> is a regexp, a list of components matched against the full
component name will be returned.

If Catalyst can't find a component by name, it will fallback to regex
matching by default. To disable this behaviour set
disable_component_resolution_regex_fallback to a true value.

    __PACKAGE__->config( disable_component_resolution_regex_fallback => 1 );

=cut

sub component {
    my ($c, $name, @args) = @_;

    if ($name) {
        my $comps = $c->components;

        if (!ref $name) {
            # is it the exact name?
            return $c->_filter_component($comps->{ $name }, @args)
                    if exists $comps->{ $name };

            # perhaps we just omitted "MyApp"?
            my $composed = (ref $c || $c) . "::${name}";
            return $c->_filter_component($comps->{ $composed }, @args)
                    if exists $comps->{ $composed };

            # search all of the models, views and controllers
            my ($comp) = $c->_comp_search_prefixes($name, qw/Model M Controller C View V/);
            return $c->_filter_component($comp, @args) if $comp;
        }

        return
                if $c->config->{disable_component_resolution_regex_fallback};

        # This is here so $c->comp( '::M::' ) works
        my $query = ref $name ? $name : qr{$name}i;

        my @result = grep {m{$query}} keys %{$c->components};
        return map {$c->_filter_component($_, @args)} @result if ref $name;

        if ($result[ 0 ]) {
            $c->log->warn(Carp::shortmess(qq(Found results for "${name}" using regexp fallback)));
            $c->log->warn('Relying on the regexp fallback behavior for component resolution');
            $c->log->warn('is unreliable and unsafe. You have been warned');
            return $c->_filter_component($result[ 0 ], @args);
        }

        # I would expect to return an empty list here, but that breaks back-compat
    }

    # fallback
    return sort keys %{$c->components};
}

=head2 CLASS DATA AND HELPER CLASSES

=head2 $c->config

Returns or takes a hashref containing the application's configuration.

    __PACKAGE__->config( { db => 'dsn:SQLite:foo.db' } );

You can also use a C<YAML>, C<XML> or L<Config::General> config file
like C<myapp.conf> in your applications home directory. See
L<Catalyst::Plugin::ConfigLoader>.

=head3 Cascading configuration

The config method is present on all Catalyst components, and configuration
will be merged when an application is started. Configuration loaded with
L<Catalyst::Plugin::ConfigLoader> takes precedence over other configuration,
followed by configuration in your top level C<MyApp> class. These two
configurations are merged, and then configuration data whose hash key matches a
component name is merged with configuration for that component.

The configuration for a component is then passed to the C<new> method when a
component is constructed.

For example:

    MyApp->config({ 'Model::Foo' => { bar => 'baz', overrides => 'me' } });
    MyApp::Model::Foo->config({ quux => 'frob', overrides => 'this' });

will mean that C<MyApp::Model::Foo> receives the following data when
constructed:

    MyApp::Model::Foo->new({
        bar => 'baz',
        quux => 'frob',
        overrides => 'me',
    });

It's common practice to use a Moose attribute
on the receiving component to access the config value.

    package MyApp::Model::Foo;

    use Moose;

    # this attr will receive 'baz' at construction time
    has 'bar' => (
        is  => 'rw',
        isa => 'Str',
    );

You can then get the value 'baz' by calling $c->model('Foo')->bar
(or $self->bar inside code in the model).

B<NOTE:> you MUST NOT call C<< $self->config >> or C<< __PACKAGE__->config >>
as a way of reading config within your code, as this B<will not> give you the
correctly merged config back. You B<MUST> take the config values supplied to
the constructor and use those instead.

=cut

around config => sub {
    my $orig = shift;
    my $c = shift;

    croak('Setting config after setup has been run is not allowed.')
            if (@_ and $c->setup_finished);

    $c->$orig(@_);
};

=head2 $c->log

Returns the logging object instance. Unless it is already set, Catalyst
sets this up with a L<Catalyst::Log> object. To use your own log class,
set the logger with the C<< __PACKAGE__->log >> method prior to calling
C<< __PACKAGE__->setup >>.

 __PACKAGE__->log( MyLogger->new );
 __PACKAGE__->setup;

And later:

    $c->log->info( 'Now logging with my own logger!' );

Your log class should implement the methods described in
L<Catalyst::Log>.

=head2 has_encoding

Returned True if there's a valid encoding

=head2 clear_encoding

Clears the encoding for the current context

=head2 encoding

Sets or gets the application encoding.  Setting encoding takes either an
Encoding object or a string that we try to resolve via L<Encode::find_encoding>.

You would expect to get the encoding object back if you attempt to set it.  If
there is a failure you will get undef returned and an error message in the log.

=cut

sub has_encoding {shift->encoding ? 1 : 0}

sub clear_encoding {
    my $c = shift;
    if (blessed $c) {
        $c->encoding(undef);
    }
    else {
        $c->log->error("You can't clear encoding on the application");
    }
}

sub encoding {
    my $c = shift;
    my $encoding;

    if (scalar @_) {

        # Don't let one change this once we are too far into the response
        if (blessed $c && $c->res->finalized_headers) {
            Carp::croak("You may not change the encoding once the headers are finalized");
            return;
        }

        # Let it be set to undef
        if (my $wanted = shift) {
            $encoding = Encode::find_encoding($wanted)
                    or Carp::croak(qq/Unknown encoding '$wanted'/);
            binmode(STDERR, ':encoding(' . $encoding->name . ')');
        }
        else {
            binmode(STDERR);
        }

        $encoding = ref $c
                ? $c->{encoding} = $encoding
                : $c->_encoding($encoding);
    }
    else {
        $encoding = ref $c && exists $c->{encoding}
                ? $c->{encoding}
                : $c->_encoding;
    }

    return $encoding;
}

=head2 $c->debug

Returns 1 if debug mode is enabled, 0 otherwise.

You can enable debug mode in several ways:

=over

=item By calling myapp_server.pl with the -d flag

=item With the environment variables MYAPP_DEBUG, or CATALYST_DEBUG

=item The -Debug option in your MyApp.pm

=item By declaring C<sub debug { 1 }> in your MyApp.pm.

=back

The first three also set the log level to 'debug'.

Calling C<< $c->debug(1) >> has no effect.

=cut

sub debug {0}

=head2 $c->dispatcher

Returns the dispatcher instance. See L<Catalyst::Dispatcher>.

=head2 $c->engine

Returns the engine instance. See L<Catalyst::Engine>.


=head2 UTILITY METHODS

=head2 $c->path_to(@path)

Merges C<@path> with C<< $c->config->{home} >> and returns a
L<Path::Class::Dir> object. Note you can usually use this object as
a filename, but sometimes you will have to explicitly stringify it
yourself by calling the C<< ->stringify >> method.

For example:

    $c->path_to( 'db', 'sqlite.db' );

=cut

sub path_to {
    my ($c, @path) = @_;
    my $path = Path::Class::Dir->new($c->config->{home}, @path);
    if (-d $path) {return $path}
    else {return Path::Class::File->new($c->config->{home}, @path)}
}

sub plugin {
    my ($class, $name, $plugin, @args) = @_;

    # See block comment in t/unit_core_plugin.t
    $class->log->warn(qq/Adding plugin using the ->plugin method is deprecated, and will be removed in a future release/);

    $class->_register_plugin($plugin, 1);

    eval {$plugin->import};
    $class->mk_classdata($name);
    my $obj;
    eval {$obj = $plugin->new(@args)};

    if ($@) {
        Catalyst::Exception->throw(message =>
                qq/Couldn't instantiate instant plugin "$plugin", "$@"/);
    }

    $class->$name($obj);
    $class->log->debug(qq/Initialized instant plugin "$plugin" as "$name"/)
            if $class->debug;
}

=head2 MyApp->setup

Initializes the dispatcher and engine, loads any plugins, and loads the
model, view, and controller components. You may also specify an array
of plugins to load here, if you choose to not load them in the C<use
Catalyst> line.

    MyApp->setup;
    MyApp->setup( qw/-Debug/ );

B<Note:> You B<should not> wrap this method with method modifiers
or bad things will happen - wrap the C<setup_finalize> method instead.

B<Note:> You can create a custom setup stage that will execute when the
application is starting.  Use this to customize setup.

    MyApp->setup(-Custom=value);

    sub setup_custom {
      my ($class, $value) = @_;
    }

Can be handy if you want to hook into the setup phase.

=cut

sub setup {
    my ($class, @arguments) = @_;
    croak('Running setup more than once')
            if ($class->setup_finished);

    unless ($class->isa('Catalyst')) {

        Catalyst::Exception->throw(
                message => qq/'$class' does not inherit from Catalyst/);
    }

    if ($class->arguments) {
        @arguments = (@arguments, @{$class->arguments});
    }

    # Process options
    my $flags = {};

    foreach (@arguments) {

        if (/^-Debug$/) {
            $flags->{log} =
                    ($flags->{log}) ? 'debug,' . $flags->{log} : 'debug';
        }
        elsif (/^-(\w+)=?(.*)$/) {
            $flags->{ lc $1 } = $2;
        }
        else {
            push @{$flags->{plugins}}, $_;
        }
    }

    $class->setup_home(delete $flags->{home});

    $class->setup_log(delete $flags->{log});
    $class->setup_plugins(delete $flags->{plugins});

    $class->setup_data_handlers();
    $class->setup_dispatcher(delete $flags->{dispatcher});
    if (my $engine = delete $flags->{engine}) {
        $class->log->warn("Specifying the engine in ->setup is no longer supported, see Catalyst::Upgrading");
    }
    $class->setup_engine();
    $class->setup_stats(delete $flags->{stats});

    for my $flag (sort keys %{$flags}) {

        if (my $code = $class->can('setup_' . $flag)) {
            &$code($class, delete $flags->{$flag});
        }
        else {
            $class->log->warn(qq/Unknown flag "$flag"/);
        }
    }

    eval {require Catalyst::Devel;};
    if (!$@ && $ENV{CATALYST_SCRIPT_GEN} && ($ENV{CATALYST_SCRIPT_GEN} < $Catalyst::Devel::CATALYST_SCRIPT_GEN)) {
        $class->log->warn(<<"EOF");
You are running an old script!

  Please update by running (this will overwrite existing files):
    catalyst.pl -force -scripts $class

  or (this will not overwrite existing files):
    catalyst.pl -scripts $class

EOF
    }

    # Call plugins setup, this is stupid and evil.
    # Also screws C3 badly on 5.10, hack to avoid.
    {
        no warnings qw/redefine/;
        local *setup = sub {};
        $class->setup unless $Catalyst::__AM_RESTARTING;
    }

    # If you are expecting configuration info as part of your setup, it needs
    # to get called here and below, since we need the above line to support
    # ConfigLoader based configs.

    $class->setup_encoding();
    $class->setup_middleware();

    # Initialize our data structure
    $class->components({});

    $class->setup_components;

    if ($class->debug) {
        my @plugins = map {"$_  " . ($_->VERSION || '')} $class->registered_plugins;

        if (@plugins) {
            my $column_width = Catalyst::Utils::term_width() - 6;
            my $t = Text::SimpleTable->new($column_width);
            $t->row($_) for @plugins;
            $class->log->debug("Loaded plugins:\n" . $t->draw . "\n");
        }

        my @middleware = map {
            ref $_ eq 'CODE' ?
                    "Inline Coderef" :
                    (ref($_) . '  ' . ($_->can('VERSION') ? $_->VERSION || '' : '')
                            || '')} $class->registered_middlewares;

        if (@middleware) {
            my $column_width = Catalyst::Utils::term_width() - 6;
            my $t = Text::SimpleTable->new($column_width);
            $t->row($_) for @middleware;
            $class->log->debug("Loaded PSGI Middleware:\n" . $t->draw . "\n");
        }

        my %dh = $class->registered_data_handlers;
        if (my @data_handlers = keys %dh) {
            my $column_width = Catalyst::Utils::term_width() - 6;
            my $t = Text::SimpleTable->new($column_width);
            $t->row($_) for @data_handlers;
            $class->log->debug("Loaded Request Data Handlers:\n" . $t->draw . "\n");
        }

        my $dispatcher = $class->dispatcher;
        my $engine = $class->engine;
        my $home = $class->config->{home};

        $class->log->debug(sprintf(q/Loaded dispatcher "%s"/, blessed($dispatcher)));
        $class->log->debug(sprintf(q/Loaded engine "%s"/, blessed($engine)));

        $home
                ? (-d $home)
                ? $class->log->debug(qq/Found home "$home"/)
                : $class->log->debug(qq/Home "$home" doesn't exist/)
                : $class->log->debug(q/Couldn't find home/);

        my $column_width = Catalyst::Utils::term_width() - 8 - 9;

        my $t = Text::SimpleTable->new([ $column_width, 'Class' ], [ 8, 'Type' ]);
        for my $comp (sort keys %{$class->components}) {
            my $type = ref $class->components->{$comp} ? 'instance' : 'class';
            $t->row($comp, $type);
        }
        $class->log->debug("Loaded components:\n" . $t->draw . "\n")
                if (keys %{$class->components});
    }

    # Add our self to components, since we are also a component
    if ($class->isa('Catalyst::Controller')) {
        $class->components->{$class} = $class;
    }

    $class->setup_actions;

    if ($class->debug) {
        my $name = $class->config->{name} || 'Application';
        $class->log->info("$name powered by Catalyst $Catalyst::VERSION");
    }

    if ($class->config->{case_sensitive}) {
        $class->log->warn($class . "->config->{case_sensitive} is set.");
        $class->log->warn("This setting is deprecated and planned to be removed in Catalyst 5.81.");
    }

    # call these so we pre setup the composed classes
    $class->composed_request_class;
    $class->composed_response_class;
    $class->composed_stats_class;

    $class->setup_finalize;

    # Flush the log for good measure (in case something turned off 'autoflush' early)
    $class->log->_flush() if $class->log->can('_flush');

    return $class || 1; # Just in case someone named their Application 0...
}

=head2 $app->setup_finalize

A hook to attach modifiers to. This method does not do anything except set the
C<setup_finished> accessor.

Applying method modifiers to the C<setup> method doesn't work, because of quirky things done for plugin setup.

Example:

    after setup_finalize => sub {
        my $app = shift;

        ## do stuff here..
    };

=cut

sub setup_finalize {
    my ($class) = @_;
    $class->setup_finished(1);
}

=head2 $c->uri_for( $path?, @args?, \%query_values?, \$fragment? )

=head2 $c->uri_for( $action, \@captures?, @args?, \%query_values?, \$fragment? )

=head2 $c->uri_for( $action, [@captures, @args], \%query_values?, \$fragment? )

Constructs an absolute L<URI> object based on the application root, the
provided path, and the additional arguments and query parameters provided.
When used as a string, provides a textual URI.  If you need more flexibility
than this (i.e. the option to provide relative URIs etc.) see
L<Catalyst::Plugin::SmartURI>.

If no arguments are provided, the URI for the current action is returned.
To return the current action and also provide @args, use
C<< $c->uri_for( $c->action, @args ) >>.

If the first argument is a string, it is taken as a public URI path relative
to C<< $c->namespace >> (if it doesn't begin with a forward slash) or
relative to the application root (if it does). It is then merged with
C<< $c->request->base >>; any C<@args> are appended as additional path
components; and any C<%query_values> are appended as C<?foo=bar> parameters.

B<NOTE> If you are using this 'stringy' first argument, we skip encoding and
allow you to declare something like:

    $c->uri_for('/foo/bar#baz')

Where 'baz' is a URI fragment.  We consider this first argument string to be
'expert' mode where you are expected to create a valid URL and we for the most
part just pass it through without a lot of internal effort to escape and encode.

If the first argument is a L<Catalyst::Action> it represents an action which
will have its path resolved using C<< $c->dispatcher->uri_for_action >>. The
optional C<\@captures> argument (an arrayref) allows passing the captured
variables that are needed to fill in the paths of Chained and Regex actions;
once the path is resolved, C<uri_for> continues as though a path was
provided, appending any arguments or parameters and creating an absolute
URI.

The captures for the current request can be found in
C<< $c->request->captures >>, and actions can be resolved using
C<< Catalyst::Controller->action_for($name) >>. If you have a private action
path, use C<< $c->uri_for_action >> instead.

  # Equivalent to $c->req->uri
  $c->uri_for($c->action, $c->req->captures,
      @{ $c->req->args }, $c->req->params);

  # For the Foo action in the Bar controller
  $c->uri_for($c->controller('Bar')->action_for('Foo'));

  # Path to a static resource
  $c->uri_for('/static/images/logo.png');

In general the scheme of the generated URI object will follow the incoming request
however if your targeted action or action chain has the Scheme attribute it will
use that instead.

Also, if the targeted Action or Action chain declares Args/CaptureArgs that have
type constraints, we will require that your proposed URL verify on those declared
constraints.

=cut

sub uri_for {
    my ($c, $path, @args) = @_;

    if ($path->$_isa('Catalyst::Controller')) {
        $path = $path->path_prefix;
        $path =~ s{/+\z}{};
        $path .= '/';
    }

    my $fragment = ((scalar(@args) && ref($args[-1]) eq 'SCALAR') ? ${pop @args} : undef);

    unless (blessed $path) {
        if (defined($path) and $path =~ s/#(.+)$//) {
            if (defined($1) and defined $fragment) {
                carp "Abiguious fragment declaration: You cannot define a fragment in '$path' and as an argument '$fragment'";
            }
            if (defined($1)) {
                $fragment = $1;
            }
        }
    }

    my $params =
            (scalar @args && ref $args[$#args] eq 'HASH' ? pop @args : {});

    undef($path) if (defined $path && $path eq '');

    carp "uri_for called with undef argument" if grep {!defined $_} @args;

    my $target_action = $path->$_isa('Catalyst::Action') ? $path : undef;
    if ($path->$_isa('Catalyst::Action')) {
        # action object
        s|/|%2F|g for @args;
        my $captures = [ map {s|/|%2F|g;
            $_;}
                (scalar @args && ref $args[0] eq 'ARRAY'
                        ? @{shift(@args)}
                        : ()) ];

        my $action = $path;
        my $expanded_action = $c->dispatcher->expand_action($action);
        my $num_captures = $expanded_action->number_of_captures;

        # ->uri_for( $action, \@captures_and_args, \%query_values? )
        if (!@args && $action->number_of_args && @$captures > $num_captures) {
            unshift @args, splice @$captures, $num_captures;
        }

        if ($num_captures) {
            unless ($expanded_action->match_captures_constraints($c, $captures)) {
                $c->log->debug("captures [@{$captures}] do not match the type constraints in actionchain ending with '$expanded_action'")
                        if $c->debug;
                return undef;
            }
        }

        $path = $c->dispatcher->uri_for_action($action, $captures);
        if (not defined $path) {
            $c->log->debug(qq/Can't find uri_for action '$action' @$captures/)
                    if $c->debug;
            return undef;
        }
        $path = '/' if $path eq '';

        # At this point @encoded_args is the remaining Args (all captures removed).
        if ($expanded_action->has_args_constraints) {
            unless ($expanded_action->match_args($c, \@args)) {
                $c->log->debug("args [@args] do not match the type constraints in action '$expanded_action'")
                        if $c->debug;
                return undef;
            }
        }
    }

    unshift(@args, $path);

    unless (defined $path && $path =~ s!^/!!) {
        # in-place strip
        my $namespace = $c->namespace;
        if (defined $path) { # cheesy hack to handle path '../foo'
            $namespace =~ s{(?:^|/)[^/]+$}{} while $args[0] =~ s{^\.\./}{};
        }
        unshift(@args, $namespace || '');
    }

    # join args with '/', or a blank string
    my $args = join('/', grep {defined($_)} @args);
    $args =~ s/\?/%3F/g; # STUPID STUPID SPECIAL CASE
    $args =~ s!^/+!!;

    my ($base, $class) = ('/', 'URI::_generic');
    if (blessed($c)) {
        $base = $c->req->base;
        if ($target_action) {
            $target_action = $c->dispatcher->expand_action($target_action);
            if (my $s = $target_action->scheme) {
                $s = lc($s);
                $class = "URI::$s";
                $base->scheme($s);
            }
            else {
                $class = ref($base);
            }
        }
        else {
            $class = ref($base);
        }

        $base =~ s{(?<!/)$}{/};
    }

    my $query = '';
    if (my @keys = keys %$params) {
        # somewhat lifted from URI::_query's query_form
        $query = '?' . join('&', map {
            my $val = $params->{$_};
            my $key = encode_utf8($_);
            # using the URI::Escape pattern here so utf8 chars survive
            $key =~ s/([^A-Za-z0-9\-_.!~*'() ])/$URI::Escape::escapes{$1}/go;
            $key =~ s/ /+/g;

            $val = '' unless defined $val;
            (map {
                my $param = encode_utf8($_);
                # using the URI::Escape pattern here so utf8 chars survive
                $param =~ s/([^A-Za-z0-9\-_.!~*'() ])/$URI::Escape::escapes{$1}/go;
                $param =~ s/ /+/g;

                "${key}=$param";
            } (ref $val eq 'ARRAY' ? @$val : $val));
        } @keys);
    }

    $base = encode_utf8 $base;
    $base =~ s/([^$URI::uric])/$URI::Escape::escapes{$1}/go;
    $args = encode_utf8 $args;
    $args =~ s/([^$URI::uric])/$URI::Escape::escapes{$1}/go;

    if (defined $fragment) {
        if (blessed $path) {
            $fragment = encode_utf8($fragment);
            $fragment =~ s/([^A-Za-z0-9\-_.!~*'() ])/$URI::Escape::escapes{$1}/go;
            $fragment =~ s/ /+/g;
        }
        $query .= "#$fragment";
    }

    my $res = bless(\"${base}${args}${query}", $class);
    $res;
}

=head2 $c->uri_for_action( $path, \@captures_and_args?, @args?, \%query_values? )

=head2 $c->uri_for_action( $action, \@captures_and_args?, @args?, \%query_values? )

=over

=item $path

A private path to the Catalyst action you want to create a URI for.

This is a shortcut for calling C<< $c->dispatcher->get_action_by_path($path)
>> and passing the resulting C<$action> and the remaining arguments to C<<
$c->uri_for >>.

You can also pass in a Catalyst::Action object, in which case it is passed to
C<< $c->uri_for >>.

Note that although the path looks like a URI that dispatches to the wanted action, it is not a URI, but an internal path to that action.

For example, if the action looks like:

 package MyApp::Controller::Users;

 sub lst : Path('the-list') {}

You can use:

 $c->uri_for_action('/users/lst')

and it will create the URI /users/the-list.

=item \@captures_and_args?

Optional array reference of Captures (i.e. C<CaptureArgs> or C<< $c->req->captures >>)
and arguments to the request. Usually used with L<Catalyst::DispatchType::Chained>
to interpolate all the parameters in the URI.

=item @args?

Optional list of extra arguments - can be supplied in the
C<< \@captures_and_args? >> array ref, or here - whichever is easier for your
code.

Your action can have zero, a fixed or a variable number of args (e.g.
C<< Args(1) >> for a fixed number or C<< Args() >> for a variable number)..

=item \%query_values?

Optional array reference of query parameters to append. E.g.

  { foo => 'bar' }

will generate

  /rest/of/your/uri?foo=bar

=back

=cut

sub uri_for_action {
    my ($c, $path, @args) = @_;
    my $action = blessed($path)
            ? $path
            : $c->dispatcher->get_action_by_path($path);
    unless (defined $action) {
        croak "Can't find action for path '$path'";
    }
    return $c->uri_for($action, @args);
}

=head2 $c->welcome_message

Returns the Catalyst welcome HTML page.

=cut

sub welcome_message {
    my $c = shift;
    my $name = $c->config->{name};
    my $logo = $c->uri_for('/static/images/catalyst_logo.png');
    my $prefix = Catalyst::Utils::appprefix(ref $c);
    $c->response->content_type('text/html; charset=utf-8');
    return <<"EOF";
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <meta http-equiv="Content-Language" content="en" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>$name on Catalyst $VERSION</title>
        <style type="text/css">
            body {
                color: #000;
                background-color: #eee;
            }
            div#content {
                width: 640px;
                margin-left: auto;
                margin-right: auto;
                margin-top: 10px;
                margin-bottom: 10px;
                text-align: left;
                background-color: #ccc;
                border: 1px solid #aaa;
            }
            p, h1, h2 {
                margin-left: 20px;
                margin-right: 20px;
                font-family: verdana, tahoma, sans-serif;
            }
            a {
                font-family: verdana, tahoma, sans-serif;
            }
            :link, :visited {
                    text-decoration: none;
                    color: #b00;
                    border-bottom: 1px dotted #bbb;
            }
            :link:hover, :visited:hover {
                    color: #555;
            }
            div#topbar {
                margin: 0px;
            }
            pre {
                margin: 10px;
                padding: 8px;
            }
            div#answers {
                padding: 8px;
                margin: 10px;
                background-color: #fff;
                border: 1px solid #aaa;
            }
            h1 {
                font-size: 0.9em;
                font-weight: normal;
                text-align: center;
            }
            h2 {
                font-size: 1.0em;
            }
            p {
                font-size: 0.9em;
            }
            p img {
                float: right;
                margin-left: 10px;
            }
            span#appname {
                font-weight: bold;
                font-size: 1.6em;
            }
        </style>
    </head>
    <body>
        <div id="content">
            <div id="topbar">
                <h1><span id="appname">$name</span> on <a href="http://catalyst.perl.org">Catalyst</a>
                    $VERSION</h1>
             </div>
             <div id="answers">
                 <p>
                 <img src="$logo" alt="Catalyst Logo" />
                 </p>
                 <p>Welcome to the  world of Catalyst.
                    This <a href="http://en.wikipedia.org/wiki/MVC">MVC</a>
                    framework will make web development something you had
                    never expected it to be: Fun, rewarding, and quick.</p>
                 <h2>What to do now?</h2>
                 <p>That really depends  on what <b>you</b> want to do.
                    We do, however, provide you with a few starting points.</p>
                 <p>If you want to jump right into web development with Catalyst
                    you might want to start with a tutorial.</p>
<pre>perldoc <a href="https://metacpan.org/module/Catalyst::Manual::Tutorial">Catalyst::Manual::Tutorial</a></code>
</pre>
<p>Afterwards you can go on to check out a more complete look at our features.</p>
<pre>
<code>perldoc <a href="https://metacpan.org/module/Catalyst::Manual::Intro">Catalyst::Manual::Intro</a>
<!-- Something else should go here, but the Catalyst::Manual link seems unhelpful -->
</code></pre>
                 <h2>What to do next?</h2>
                 <p>Next it's time to write an actual application. Use the
                    helper scripts to generate <a href="https://metacpan.org/search?q=Catalyst%3A%3AController">controllers</a>,
                    <a href="https://metacpan.org/search?q=Catalyst%3A%3AModel">models</a>, and
                    <a href="https://metacpan.org/search?q=Catalyst%3A%3AView">views</a>;
                    they can save you a lot of work.</p>
                    <pre><code>script/${prefix}_create.pl --help</code></pre>
                    <p>Also, be sure to check out the vast and growing
                    collection of <a href="http://search.cpan.org/search?query=Catalyst">plugins for Catalyst on CPAN</a>;
                    you are likely to find what you need there.
                    </p>

                 <h2>Need help?</h2>
                 <p>Catalyst has a very active community. Here are the main places to
                    get in touch with us.</p>
                 <ul>
                     <li>
                         <a href="http://dev.catalyst.perl.org">Wiki</a>
                     </li>
                     <li>
                         <a href="http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/catalyst">Mailing-List</a>
                     </li>
                     <li>
                         <a href="irc://irc.perl.org/catalyst">IRC channel #catalyst on irc.perl.org</a>
                     </li>
                 </ul>
                 <h2>In conclusion</h2>
                 <p>The Catalyst team hopes you will enjoy using Catalyst as much
                    as we enjoyed making it. Please contact us if you have ideas
                    for improvement or other feedback.</p>
             </div>
         </div>
    </body>
</html>
EOF
}

=head2 run_options

Contains a hash of options passed from the application script, including
the original ARGV the script received, the processed values from that
ARGV and any extra arguments to the script which were not processed.

This can be used to add custom options to your application's scripts
and setup your application differently depending on the values of these
options.

=head1 INTERNAL METHODS

These methods are not meant to be used by end users.

=head2 $c->components

Returns a hash of components.

=head2 $c->context_class

Returns or sets the context class.

=head2 $c->counter

Returns a hashref containing coderefs and execution counts (needed for
deep recursion detection).

=head2 $c->depth

Returns the number of actions on the current internal execution stack.

=head2 $c->dispatch

Dispatches a request to actions.

=cut

sub dispatch {
    my $c = shift;
    $c->dispatcher->dispatch($c, @_)
}

=head2 $c->dispatcher_class

Returns or sets the dispatcher class.

=head2 $c->dump_these

Returns a list of 2-element array references (name, structure) pairs
that will be dumped on the error page in debug mode.

=cut

sub dump_these {
    my $c = shift;
    [ Request => $c->req ],
            [ Response => $c->res ],
            [ Stash => $c->stash ],
            [ Config => $c->config ];
}

=head2 $c->engine_class

Returns or sets the engine class.

=head2 $c->execute( $class, $coderef )

Execute a coderef in given class and catch exceptions. Errors are available
via $c->error.

=cut

sub execute {
    my ($c, $class, $code) = @_;
    $class = $c->component($class) || $class;
    #$c->state(0);

    if ($c->depth >= $RECURSION) {
        my $action = $code->reverse();
        $action = "/$action" unless $action =~ /->/;
        my $error = qq/Deep recursion detected calling "${action}"/;
        $c->log->error($error);
        $c->error($error);
        $c->state(0);
        return $c->state;
    }

    my $stats_info = $c->_stats_start_execute($code) if $c->use_stats;

    push(@{$c->stack}, $code);

    no warnings 'recursion';
    # N.B. This used to be combined, but I have seen $c get clobbered if so, and
    #      I have no idea how, ergo $ret (which appears to fix the issue)
    eval {
        my $ret = $code->execute($class, $c, @{$c->req->args}) || 0;
        $c->state($ret)
    };

    $c->_stats_finish_execute($stats_info) if $c->use_stats and $stats_info;

    my $last = pop(@{$c->stack});

    if (my $error = $@) {
        #rethow if this can be handled by middleware
        if ($c->_handle_http_exception($error)) {
            foreach my $err (@{$c->error}) {
                $c->log->error($err);
            }
            $c->clear_errors;
            $c->log->_flush if $c->log->can('_flush');

            $error->can('rethrow') ? $error->rethrow : croak $error;
        }
        if (blessed($error) and $error->isa('Catalyst::Exception::Detach')) {
            $error->rethrow if $c->depth > 1;
        }
        elsif (blessed($error) and $error->isa('Catalyst::Exception::Go')) {
            $error->rethrow if $c->depth > 0;
        }
        else {
            unless (ref $error) {
                no warnings 'uninitialized';
                chomp $error;
                my $class = $last->class;
                my $name = $last->name;
                $error = qq/Caught exception in $class->$name "$error"/;
            }
            $c->error($error);
        }
        #$c->state(0);
    }
    return $c->state;
}

sub _stats_start_execute {
    my ($c, $code) = @_;
    my $appclass = ref($c) || $c;
    return if (($code->name =~ /^_.*/)
            && (!$appclass->config->{show_internal_actions}));

    my $action_name = $code->reverse();
    $c->counter->{$action_name}++;

    my $action = $action_name;
    $action = "/$action" unless $action =~ /->/;

    # determine if the call was the result of a forward
    # this is done by walking up the call stack and looking for a calling
    # sub of Catalyst::forward before the eval
    my $callsub = q{};
    for my $index (2 .. 11) {
        last
                if ((caller($index))[0] eq 'Catalyst'
                        && (caller($index))[3] eq '(eval)');

        if ((caller($index))[3] =~ /forward$/) {
            $callsub = (caller($index))[3];
            $action = "-> $action";
            last;
        }
    }

    my $uid = $action_name . $c->counter->{$action_name};

    # is this a root-level call or a forwarded call?
    if ($callsub =~ /forward$/) {
        my $parent = $c->stack->[-1];

        # forward, locate the caller
        if (defined $parent && exists $c->counter->{"$parent"}) {
            $c->stats->profile(
                    begin  => $action,
                    parent => "$parent" . $c->counter->{"$parent"},
                    uid    => $uid,
            );
        }
        else {

            # forward with no caller may come from a plugin
            $c->stats->profile(
                    begin => $action,
                    uid   => $uid,
            );
        }
    }
    else {

        # root-level call
        $c->stats->profile(
                begin => $action,
                uid   => $uid,
        );
    }
    return $action;

}

sub _stats_finish_execute {
    my ($c, $info) = @_;
    $c->stats->profile(end => $info);
}

=head2 $c->finalize

Finalizes the request.

=cut

sub finalize {
    my $c = shift;

    for my $error (@{$c->error}) {
        $c->log->error($error);
    }

    # Support skipping finalize for psgix.io style 'jailbreak'.  Used to support
    # stuff like cometd and websockets

    if ($c->request->_has_io_fh) {
        $c->log_response;
        return;
    }

    # Allow engine to handle finalize flow (for POE)
    my $engine = $c->engine;
    if (my $code = $engine->can('finalize')) {
        $engine->$code($c);
    }
    else {

        $c->finalize_uploads;

        # Error
        if ($#{$c->error} >= 0) {
            $c->finalize_error;
        }

        $c->finalize_encoding;
        $c->finalize_headers unless $c->response->finalized_headers;
        $c->finalize_body;
    }

    $c->log_response;

    $c->log_stats if $c->use_stats;

    return $c->response->status;
}

=head2 $c->log_stats

Logs statistics.

=cut

sub log_stats {
    my $c = shift;

    my $elapsed = $c->stats->elapsed;
    my $av = $elapsed == 0 ? '??' : sprintf '%.3f', 1 / $elapsed;
    $c->log->info(
            "Request took ${elapsed}s ($av/s)\n" . $c->stats->report . "\n");
}


=head2 $c->finalize_body

Finalizes body.

=cut

sub finalize_body {
    my $c = shift;
    $c->engine->finalize_body($c, @_)
}

=head2 $c->finalize_cookies

Finalizes cookies.

=cut

sub finalize_cookies {
    my $c = shift;
    $c->engine->finalize_cookies($c, @_)
}

=head2 $c->finalize_error

Finalizes error.  If there is only one error in L</error> and it is an object that
does C<as_psgi> or C<code> we rethrow the error and presume it caught by middleware
up the ladder.  Otherwise we return the debugging error page (in debug mode) or we
return the default error page (production mode).

=cut

sub finalize_error {
    my $c = shift;
    if ($#{$c->error} > 0) {
        $c->engine->finalize_error($c, @_);
    }
    else {
        my ($error) = @{$c->error};
        if ($c->_handle_http_exception($error)) {
            # In the case where the error 'knows what it wants', becauses its PSGI
            # aware, just rethow and let middleware catch it
            $error->can('rethrow') ? $error->rethrow : croak $error;
        }
        else {
            $c->engine->finalize_error($c, @_)
        }
    }
}

=head2 $c->finalize_headers

Finalizes headers.

=cut

sub finalize_headers {
    my $c = shift;

    my $response = $c->response; #accessor calls can add up?

    # Check if we already finalized headers
    return if $response->finalized_headers;

    # Handle redirects
    if (my $location = $response->redirect) {
        $c->log->debug(qq/Redirecting to "$location"/) if $c->debug;
        $response->header(Location => $location);
    }

    # Remove incorrectly added body and content related meta data when returning
    # an information response, or a response the is required to not include a body

    $c->finalize_cookies;

    # This currently is a NOOP but I don't want to remove it since I guess people
    # might have Response subclasses that use it for something... (JNAP)
    $c->response->finalize_headers();

    # Done
    $response->finalized_headers(1);
}

=head2 $c->finalize_encoding

Make sure your body is encoded properly IF you set an encoding.  By
default the encoding is UTF-8 but you can disable it by explicitly setting the
encoding configuration value to undef.

We can only encode when the body is a scalar.  Methods for encoding via the
streaming interfaces (such as C<write> and C<write_fh> on L<Catalyst::Response>
are available).

See L</ENCODING>.

=cut

sub finalize_encoding {
    my $c = shift;
    my $res = $c->res || return;

    # Warn if the set charset is different from the one you put into encoding.  We need
    # to do this early since encodable_response is false for this condition and we need
    # to match the debug output for backcompat (there's a test for this...) -JNAP
    if (
            $res->content_type_charset and $c->encoding and
                    (uc($c->encoding->mime_name) ne uc($res->content_type_charset))
    ) {
        my $ct = lc($res->content_type_charset);
        $c->log->debug("Catalyst encoding config is set to encode in '" .
                $c->encoding->mime_name .
                "', content type is '$ct', not encoding ");
    }

    if (
            ($res->encodable_response) and
                    (defined($res->body)) and
                    (ref(\$res->body) eq 'SCALAR')
    ) {
        # if you are finding yourself here and your body is already encoded correctly
        # and you want to turn this off, use $c->clear_encoding to prevent encoding
        # at this step, or set encoding to undef in the config to do so for the whole
        # application.  See the ENCODING documentaiton for better notes.
        $c->res->body($c->encoding->encode($c->res->body, $c->_encode_check));

        # Set the charset if necessary.  This might be a bit bonkers since encodable response
        # is false when the set charset is not the same as the encoding mimetype (maybe
        # confusing action at a distance here..
        # Don't try to set the charset if one already exists or if headers are already finalized
        $c->res->content_type($c->res->content_type . "; charset=" . $c->encoding->mime_name)
                unless ($c->res->content_type_charset ||
                        ($c->res->_context && $c->res->finalized_headers && !$c->res->_has_response_cb));
    }
}

=head2 $c->finalize_output

An alias for finalize_body.

=head2 $c->finalize_read

Finalizes the input after reading is complete.

=cut

sub finalize_read {
    my $c = shift;
    $c->engine->finalize_read($c, @_)
}

=head2 $c->finalize_uploads

Finalizes uploads. Cleans up any temporary files.

=cut

sub finalize_uploads {
    my $c = shift;
    $c->engine->finalize_uploads($c, @_)
}

=head2 $c->get_action( $action, $namespace )

Gets an action in a given namespace.

=cut

sub get_action {
    my $c = shift;
    $c->dispatcher->get_action(@_)
}

=head2 $c->get_actions( $action, $namespace )

Gets all actions of a given name in a namespace and all parent
namespaces.

=cut

sub get_actions {
    my $c = shift;
    $c->dispatcher->get_actions($c, @_)
}

=head2 $app->handle_request( @arguments )

Called to handle each HTTP request.

=cut

sub handle_request {
    my ($class, @arguments) = @_;

    # Always expect worst case!
    my $status = -1;
    try {
        if ($class->debug) {
            my $secs = time - $START || 1;
            my $av = sprintf '%.3f', $COUNT / $secs;
            my $time = localtime time;
            $class->log->info("*** Request $COUNT ($av/s) [$$] [$time] ***");
        }

        my $c = $class->prepare(@arguments);
        $c->dispatch;
        $status = $c->finalize;
    }
    catch {
        #rethow if this can be handled by middleware
        if ($class->_handle_http_exception($_)) {
            $_->can('rethrow') ? $_->rethrow : croak $_;
        }
        chomp(my $error = $_);
        $class->log->error(qq/Caught exception in engine "$error"/);
    };

    $COUNT++;

    if (my $coderef = $class->log->can('_flush')) {
        $class->log->$coderef();
    }
    return $status;
}

=head2 $class->prepare( @arguments )

Creates a Catalyst context from an engine-specific request (Apache, CGI,
etc.).

=cut

has _uploadtmp => (
        is        => 'ro',
        predicate => '_has_uploadtmp',
);

sub prepare {
    my ($class, @arguments) = @_;

    # XXX
    # After the app/ctxt split, this should become an attribute based on something passed
    # into the application.
    $class->context_class(ref $class || $class) unless $class->context_class;

    my $uploadtmp = $class->config->{uploadtmp};
    my $c = $class->context_class->new({ $uploadtmp ? (_uploadtmp => $uploadtmp) : () });

    $c->response->_context($c);
    $c->stats($class->stats_class->new)->enable($c->use_stats);

    if ($c->debug || $c->config->{enable_catalyst_header}) {
        $c->res->headers->header('X-Catalyst' => $Catalyst::VERSION);
    }

    try {
        # Allow engine to direct the prepare flow (for POE)
        if (my $prepare = $c->engine->can('prepare')) {
            $c->engine->$prepare($c, @arguments);
        }
        else {
            $c->prepare_request(@arguments);
            $c->prepare_connection;
            $c->prepare_query_parameters;
            $c->prepare_headers; # Just hooks, no longer needed - they just
            $c->prepare_cookies; # cause the lazy attribute on req to build
            $c->prepare_path;

            # Prepare the body for reading, either by prepare_body
            # or the user, if they are using $c->read
            $c->prepare_read;

            # Parse the body unless the user wants it on-demand
            unless (ref($c)->config->{parse_on_demand}) {
                $c->prepare_body;
            }
        }
        $c->prepare_action;
    }
    # VERY ugly and probably shouldn't rely on ->finalize actually working
    catch {
        # failed prepare is always due to an invalid request, right?
        # Note we call finalize and then die here, which escapes
        # finalize being called in the enclosing block..
        # It in fact couldn't be called, as we don't return $c..
        # This is a mess - but I'm unsure you can fix this without
        # breaking compat for people doing crazy things (we should set
        # the 400 and just return the ctx here IMO, letting finalize get called
        # above...
        if ($c->_handle_http_exception($_)) {
            foreach my $err (@{$c->error}) {
                $c->log->error($err);
            }
            $c->clear_errors;
            $c->log->_flush if $c->log->can('_flush');
            $_->can('rethrow') ? $_->rethrow : croak $_;
        }
        else {
            $c->response->status(400);
            $c->response->content_type('text/plain');
            $c->response->body('Bad Request');
            $c->finalize;
            die $_;
        }
    };

    $c->log_request;
    $c->{stash} = $c->stash;
    Scalar::Util::weaken($c->{stash});

    return $c;
}

=head2 $c->prepare_action

Prepares action. See L<Catalyst::Dispatcher>.

=cut

sub prepare_action {
    my $c = shift;
    my $ret = $c->dispatcher->prepare_action($c, @_);

    if ($c->encoding) {
        foreach (@{$c->req->arguments}, @{$c->req->captures}) {
            $_ = $c->_handle_param_unicode_decoding($_);
        }
    }

    return $ret;
}


=head2 $c->prepare_body

Prepares message body.

=cut

sub prepare_body {
    my $c = shift;

    return if $c->request->_has_body;

    # Initialize on-demand data
    $c->engine->prepare_body($c, @_);
    $c->prepare_parameters;
    $c->prepare_uploads;
}

=head2 $c->prepare_body_chunk( $chunk )

Prepares a chunk of data before sending it to L<HTTP::Body>.

See L<Catalyst::Engine>.

=cut

sub prepare_body_chunk {
    my $c = shift;
    $c->engine->prepare_body_chunk($c, @_);
}

=head2 $c->prepare_body_parameters

Prepares body parameters.

=cut

sub prepare_body_parameters {
    my $c = shift;
    $c->request->prepare_body_parameters($c, @_);
}

=head2 $c->prepare_connection

Prepares connection.

=cut

sub prepare_connection {
    my $c = shift;
    $c->request->prepare_connection($c);
}

=head2 $c->prepare_cookies

Prepares cookies by ensuring that the attribute on the request
object has been built.

=cut

sub prepare_cookies {
    my $c = shift;
    $c->request->cookies
}

=head2 $c->prepare_headers

Prepares request headers by ensuring that the attribute on the request
object has been built.

=cut

sub prepare_headers {
    my $c = shift;
    $c->request->headers
}

=head2 $c->prepare_parameters

Prepares parameters.

=cut

sub prepare_parameters {
    my $c = shift;
    $c->prepare_body_parameters;
    $c->engine->prepare_parameters($c, @_);
}

=head2 $c->prepare_path

Prepares path and base.

=cut

sub prepare_path {
    my $c = shift;
    $c->engine->prepare_path($c, @_)
}

=head2 $c->prepare_query_parameters

Prepares query parameters.

=cut

sub prepare_query_parameters {
    my $c = shift;

    $c->engine->prepare_query_parameters($c, @_);
}

=head2 $c->log_request

Writes information about the request to the debug logs.  This includes:

=over 4

=item * Request method, path, and remote IP address

=item * Query keywords (see L<Catalyst::Request/query_keywords>)

=item * Request parameters

=item * File uploads

=back

=cut

sub log_request {
    my $c = shift;

    return unless $c->debug;

    my ($dump) = grep {$_->[0] eq 'Request'} $c->dump_these;
    my $request = $dump->[1];

    my ($method, $path, $address) = ($request->method, $request->path, $request->address);
    $method ||= '';
    $path = '/' unless length $path;
    $address ||= '';

    $path =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
    $path = decode_utf8($path);

    $c->log->debug(qq/"$method" request for "$path" from "$address"/);

    $c->log_request_headers($request->headers);

    if (my $keywords = $request->query_keywords) {
        $c->log->debug("Query keywords are: $keywords");
    }

    $c->log_request_parameters(query => $request->query_parameters, $request->_has_body ? (body => $request->body_parameters) : ());

    $c->log_request_uploads($request);
}

=head2 $c->log_response

Writes information about the response to the debug logs by calling
C<< $c->log_response_status_line >> and C<< $c->log_response_headers >>.

=cut

sub log_response {
    my $c = shift;

    return unless $c->debug;

    my ($dump) = grep {$_->[0] eq 'Response'} $c->dump_these;
    my $response = $dump->[1];

    $c->log_response_status_line($response);
    $c->log_response_headers($response->headers);
}

=head2 $c->log_response_status_line($response)

Writes one line of information about the response to the debug logs.  This includes:

=over 4

=item * Response status code

=item * Content-Type header (if present)

=item * Content-Length header (if present)

=back

=cut

sub log_response_status_line {
    my ($c, $response) = @_;

    $c->log->debug(
            sprintf(
                    'Response Code: %s; Content-Type: %s; Content-Length: %s',
                    $response->status || 'unknown',
                    $response->headers->header('Content-Type') || 'unknown',
                    $response->headers->header('Content-Length') || 'unknown'
            )
    );
}

=head2 $c->log_response_headers($headers);

Hook method which can be wrapped by plugins to log the response headers.
No-op in the default implementation.

=cut

sub log_response_headers {}

=head2 $c->log_request_parameters( query => {}, body => {} )

Logs request parameters to debug logs

=cut

sub log_request_parameters {
    my $c = shift;
    my %all_params = @_;

    return unless $c->debug;

    my $column_width = Catalyst::Utils::term_width() - 44;
    foreach my $type (qw(query body)) {
        my $params = $all_params{$type};
        next if !keys %$params;
        my $t = Text::SimpleTable->new([ 35, 'Parameter' ], [ $column_width, 'Value' ]);
        for my $key (sort keys %$params) {
            my @values = ();
            if (ref $params eq 'Hash::MultiValue') {
                @values = $params->get_all($key);
            }
            else {
                my $param = $params->{$key};
                if (defined($param)) {
                    @values = ref $param eq 'ARRAY' ? @$param : $param;
                }
            }
            $t->row($key . (scalar @values > 1 ? ' [multiple]' : ''), join(', ', @values));
        }
        $c->log->debug(ucfirst($type) . " Parameters are:\n" . $t->draw);
    }
}

=head2 $c->log_request_uploads

Logs file uploads included in the request to the debug logs.
The parameter name, filename, file type, and file size are all included in
the debug logs.

=cut

sub log_request_uploads {
    my $c = shift;
    my $request = shift;
    return unless $c->debug;
    my $uploads = $request->uploads;
    if (keys %$uploads) {
        my $t = Text::SimpleTable->new(
                [ 12, 'Parameter' ],
                [ 26, 'Filename' ],
                [ 18, 'Type' ],
                [ 9, 'Size' ]
        );
        for my $key (sort keys %$uploads) {
            my $upload = $uploads->{$key};
            for my $u (ref $upload eq 'ARRAY' ? @{$upload} : ($upload)) {
                $t->row($key, $u->filename, $u->type, $u->size);
            }
        }
        $c->log->debug("File Uploads are:\n" . $t->draw);
    }
}

=head2 $c->log_request_headers($headers);

Hook method which can be wrapped by plugins to log the request headers.
No-op in the default implementation.

=cut

sub log_request_headers {}

=head2 $c->log_headers($type => $headers)

Logs L<HTTP::Headers> (either request or response) to the debug logs.

=cut

sub log_headers {
    my $c = shift;
    my $type = shift;
    my $headers = shift; # an HTTP::Headers instance

    return unless $c->debug;

    my $column_width = Catalyst::Utils::term_width() - 28;
    my $t = Text::SimpleTable->new([ 15, 'Header Name' ], [ $column_width, 'Value' ]);
    $headers->scan(
            sub {
                my ($name, $value) = @_;
                $t->row($name, $value);
            }
    );
    $c->log->debug(ucfirst($type) . " Headers:\n" . $t->draw);
}


=head2 $c->prepare_read

Prepares the input for reading.

=cut

sub prepare_read {
    my $c = shift;
    $c->engine->prepare_read($c, @_)
}

=head2 $c->prepare_request

Prepares the engine request.

=cut

sub prepare_request {
    my $c = shift;
    $c->engine->prepare_request($c, @_)
}

=head2 $c->prepare_uploads

Prepares uploads.

=cut

sub prepare_uploads {
    my $c = shift;
    $c->engine->prepare_uploads($c, @_);
}

=head2 $c->prepare_write

Prepares the output for writing.

=cut

sub prepare_write {
    my $c = shift;
    $c->engine->prepare_write($c, @_)
}

=head2 $c->request_class

Returns or sets the request class. Defaults to L<Catalyst::Request>.

=head2 $app->request_class_traits

An arrayref of L<Moose::Role>s which are applied to the request class.  You can
name the full namespace of the role, or a namespace suffix, which will then
be tried against the following standard namespace prefixes.

    $MyApp::TraitFor::Request::$trait_suffix
    Catalyst::TraitFor::Request::$trait_suffix

So for example if you set:

    MyApp->request_class_traits(['Foo']);

We try each possible role in turn (and throw an error if none load)

    Foo
    MyApp::TraitFor::Request::Foo
    Catalyst::TraitFor::Request::Foo

The namespace part 'TraitFor::Request' was chosen to assist in backwards
compatibility with L<CatalystX::RoleApplicator> which previously provided
these features in a stand alone package.

=head2 $app->composed_request_class

This is the request class which has been composed with any request_class_traits.

=head2 $c->response_class

Returns or sets the response class. Defaults to L<Catalyst::Response>.

=head2 $app->response_class_traits

An arrayref of L<Moose::Role>s which are applied to the response class.  You can
name the full namespace of the role, or a namespace suffix, which will then
be tried against the following standard namespace prefixes.

    $MyApp::TraitFor::Response::$trait_suffix
    Catalyst::TraitFor::Response::$trait_suffix

So for example if you set:

    MyApp->response_class_traits(['Foo']);

We try each possible role in turn (and throw an error if none load)

    Foo
    MyApp::TraitFor::Response::Foo
    Catalyst::TraitFor::Responset::Foo

The namespace part 'TraitFor::Response' was chosen to assist in backwards
compatibility with L<CatalystX::RoleApplicator> which previously provided
these features in a stand alone package.


=head2 $app->composed_response_class

This is the request class which has been composed with any response_class_traits.

=head2 $c->read( [$maxlength] )

Reads a chunk of data from the request body. This method is designed to
be used in a while loop, reading C<$maxlength> bytes on every call.
C<$maxlength> defaults to the size of the request if not specified.

You have to set C<< MyApp->config(parse_on_demand => 1) >> to use this
directly.

Warning: If you use read(), Catalyst will not process the body,
so you will not be able to access POST parameters or file uploads via
$c->request.  You must handle all body parsing yourself.

=cut

sub read {
    my $c = shift;
    return $c->request->read(@_)
}

=head2 $c->run

Starts the engine.

=cut

sub run {
    my $app = shift;
    $app->_make_immutable_if_needed;
    $app->engine_loader->needs_psgi_engine_compat_hack ?
            $app->engine->run($app, @_) :
            $app->engine->run($app, $app->_finalized_psgi_app, @_);
}

sub _make_immutable_if_needed {
    my $class = shift;
    my $meta = find_meta($class);
    my $isa_ca = $class->isa('Class::Accessor::Fast') || $class->isa('Class::Accessor');
    if (
            $meta->is_immutable
                    && !{ $meta->immutable_options }->{replace_constructor}
                    && $isa_ca
    ) {
        warn("You made your application class ($class) immutable, "
                . "but did not inline the\nconstructor. "
                . "This will break catalyst, as your app \@ISA "
                . "Class::Accessor(::Fast)?\nPlease pass "
                . "(replace_constructor => 1)\nwhen making your class immutable.\n");
    }
    unless ($meta->is_immutable) {
        # XXX - FIXME warning here as you should make your app immutable yourself.
        $meta->make_immutable(
                replace_constructor => 1,
        );
    }
}

=head2 $c->set_action( $action, $code, $namespace, $attrs )

Sets an action in a given namespace.

=cut

sub set_action {
    my $c = shift;
    $c->dispatcher->set_action($c, @_)
}

=head2 $c->setup_actions($component)

Sets up actions for a component.

=cut

sub setup_actions {
    my $c = shift;
    $c->dispatcher->setup_actions($c, @_)
}

=head2 $c->setup_components

This method is called internally to set up the application's components.

It finds modules by calling the L<locate_components> method, expands them to
package names with the L<expand_component_module> method, and then installs
each component into the application.

The C<setup_components> config option is passed to both of the above methods.

Installation of each component is performed by the L<setup_component> method,
below.

=cut

sub setup_components {
    my $class = shift;

    my $config = $class->config->{ setup_components };

    my @comps = $class->locate_components($config);

    my $deprecatedcatalyst_component_names = grep {/::[CMV]::/} @comps;
    $class->log->warn(qq{Your application is using the deprecated ::[MVC]:: type naming scheme.\n} .
            qq{Please switch your class names to ::Model::, ::View:: and ::Controller: as appropriate.\n}
    ) if $deprecatedcatalyst_component_names;

    for my $component (@comps) {

        # We pass ignore_loaded here so that overlay files for (e.g.)
        # Model::DBI::Schema sub-classes are loaded - if it's in @comps
        # we know M::P::O found a file on disk so this is safe

        Catalyst::Utils::ensure_class_loaded($component, { ignore_loaded => 1 });
    }

    for my $component (@comps) {
        my $instance = $class->components->{ $component } = $class->delayed_setup_component($component);
    }

    # Inject a component or wrap a stand alone class in an adaptor. This makes a list
    # of named components in the configuration that are not actually existing (not a
    # real file).

    my @injected = $class->setup_injected_components;

    # All components are registered, now we need to 'init' them.
    foreach my $component_name (@comps, @injected) {
        $class->components->{$component_name} = $class->components->{$component_name}->() if
                (ref($class->components->{$component_name}) || '') eq 'CODE';
    }
}

=head2 $app->setup_injected_components

Called by setup_compoents to setup components that are injected.

=cut

sub setup_injected_components {
    my ($class) = @_;
    my @injected_components = keys %{$class->config->{inject_components} || +{}};

    foreach my $injected_comp_name (@injected_components) {
        $class->setup_injected_component(
                $injected_comp_name,
                $class->config->{inject_components}->{$injected_comp_name});
    }

    return map {$class . "::" . $_}
            @injected_components;
}

=head2 $app->setup_injected_component( $injected_component_name, $config )

Setup a given injected component.

=cut

sub setup_injected_component {
    my ($class, $injected_comp_name, $config) = @_;
    if (my $component_class = $config->{from_component}) {
        my @roles = @{$config->{roles} || []};
        Catalyst::Utils::inject_component(
                into      => $class,
                component => $component_class,
                (scalar(@roles) ? (traits => \@roles) : ()),
                as        => $injected_comp_name);
    }
}

=head2 $app->inject_component($MyApp_Component_name => \%args);

Add a component that is injected at setup:

    MyApp->inject_component( 'Model::Foo' => { from_component => 'Common::Foo' } );

Must be called before ->setup.  Expects a component name for your
current application and \%args where

=over 4

=item from_component

The target component being injected into your application

=item roles

An arrayref of L<Moose::Role>s that are applied to your component.

=back

Example

    MyApp->inject_component(
      'Model::Foo' => {
        from_component => 'Common::Model::Foo',
        roles => ['Role1', 'Role2'],
      });

=head2 $app->inject_components

Inject a list of components:

    MyApp->inject_components(
      'Model::FooOne' => {
        from_component => 'Common::Model::Foo',
        roles => ['Role1', 'Role2'],
      },
      'Model::FooTwo' => {
        from_component => 'Common::Model::Foo',
        roles => ['Role1', 'Role2'],
      });

=cut

sub inject_component {
    my ($app, $name, $args) = @_;
    die "Component $name exists" if
            $app->config->{inject_components}->{$name};
    $app->config->{inject_components}->{$name} = $args;
}

sub inject_components {
    my $app = shift;
    while (@_) {
        $app->inject_component(shift, shift);
    }
}

=head2 $c->locate_components( $setup_component_config )

This method is meant to provide a list of component modules that should be
setup for the application.  By default, it will use L<Module::Pluggable>.

Specify a C<setup_components> config option to pass additional options directly
to L<Module::Pluggable>. To add additional search paths, specify a key named
C<search_extra> as an array reference. Items in the array beginning with C<::>
will have the application class name prepended to them.

=cut

sub locate_components {
    my $class = shift;
    my $config = shift;

    my @paths = qw(::M ::Model ::V ::View ::C ::Controller);
    my $extra = $config->{ search_extra } || [];

    unshift @paths, @$extra;

    my @comps = map {sort {length($a) <=> length($b)} Module::Pluggable::Object->new(
            search_path => [ map {s/^(?=::)/$class/;
                $_;} ($_) ],
            %$config
    )->plugins} @paths;

    return @comps;
}

=head2 $c->expand_component_module( $component, $setup_component_config )

Components found by C<locate_components> will be passed to this method, which
is expected to return a list of component (package) names to be set up.

=cut

sub expand_component_module {
    my ($class, $module) = @_;
    return Devel::InnerPackage::list_packages($module);
}

=head2 $app->delayed_setup_component

Returns a coderef that points to a setup_component instance.  Used
internally for when you want to delay setup until the first time
the component is called.

=cut

sub delayed_setup_component {
    my ($class, $component, @more) = @_;
    return sub {
        return my $instance = $class->setup_component($component, @more);
    };
}

=head2 $c->setup_component

=cut

sub setup_component {
    my ($class, $component) = @_;

    unless ($component->can('COMPONENT')) {
        return $component;
    }

    my $config = $class->config_for($component);
    # Stash catalyst_component_name in the config here, so that custom COMPONENT
    # methods also pass it. local to avoid pointlessly shitting in config
    # for the debug screen, as $component is already the key name.
    local $config->{catalyst_component_name} = $component;

    my $instance = eval {
        $component->COMPONENT($class, $config);
    } || do {
        my $error = $@;
        chomp $error;
        Catalyst::Exception->throw(
                message => qq/Couldn't instantiate component "$component", "$error"/
        );
    };

    unless (blessed $instance) {
        my $metaclass = Moose::Util::find_meta($component);
        my $method_meta = $metaclass->find_method_by_name('COMPONENT');
        my $component_method_from = $method_meta->associated_metaclass->name;
        my $value = defined($instance) ? $instance : 'undef';
        Catalyst::Exception->throw(
                message =>
                        qq/Couldn't instantiate component "$component", COMPONENT() method (from $component_method_from) didn't return an object-like value (value was $value)./
        );
    }

    my @expanded_components = $instance->can('expand_modules')
            ? $instance->expand_modules($component, $config)
            : $class->expand_component_module($component, $config);
    for my $component (@expanded_components) {
        next if $class->components->{ $component };
        $class->components->{ $component } = $class->setup_component($component);
    }

    return $instance;
}

=head2 $app->config_for( $component_name )

Return the application level configuration (which is not yet merged with any
local component configuration, via $component_class->config) for the named
component or component object. Example:

    MyApp->config(
      'Model::Foo' => { a => 1, b => 2},
    );

    my $config = MyApp->config_for('MyApp::Model::Foo');

In this case $config is the hashref C<< {a=>1, b=>2} >>.

This is also handy for looking up configuration for a plugin, to make sure you follow
existing L<Catalyst> standards for where a plugin should put its configuration.

=cut

sub config_for {
    my ($class, $component_name) = @_;
    my $component_suffix = Catalyst::Utils::class2classsuffix($component_name);
    my $config = $class->config->{ $component_suffix } || {};

    return $config;
}

=head2 $c->setup_dispatcher

Sets up dispatcher.

=cut

sub setup_dispatcher {
    my ($class, $dispatcher) = @_;

    if ($dispatcher) {
        $dispatcher = 'Catalyst::Dispatcher::' . $dispatcher;
    }

    if (my $env = Catalyst::Utils::env_value($class, 'DISPATCHER')) {
        $dispatcher = 'Catalyst::Dispatcher::' . $env;
    }

    unless ($dispatcher) {
        $dispatcher = $class->dispatcher_class;
    }

    load_class($dispatcher);

    # dispatcher instance
    $class->dispatcher($dispatcher->new);
}

=head2 $c->setup_engine

Sets up engine.

=cut

sub engine_class {
    my ($class, $requested_engine) = @_;

    if (!$class->engine_loader || $requested_engine) {
        $class->engine_loader(
                Catalyst::EngineLoader->new({
                        application_name => $class,
                        (defined $requested_engine
                                ? (catalyst_engine_class => $requested_engine) : ()),
                }),
        );
    }

    $class->engine_loader->catalyst_engine_class;
}

sub setup_engine {
    my ($class, $requested_engine) = @_;

    my $engine = do {
        my $loader = $class->engine_loader;

        if (!$loader || $requested_engine) {
            $loader = Catalyst::EngineLoader->new({
                    application_name => $class,
                    (defined $requested_engine
                            ? (requested_engine => $requested_engine) : ()),
            }),

                    $class->engine_loader($loader);
        }

        $loader->catalyst_engine_class;
    };

    # Don't really setup_engine -- see _setup_psgi_app for explanation.
    return if $class->loading_psgi_file;

    load_class($engine);

    if ($ENV{MOD_PERL}) {
        my $apache = $class->engine_loader->auto;

        my $meta = find_meta($class);
        my $was_immutable = $meta->is_immutable;
        my %immutable_options = $meta->immutable_options;
        $meta->make_mutable if $was_immutable;

        $meta->add_method(handler => sub {
            my $r = shift;
            my $psgi_app = $class->_finalized_psgi_app;
            $apache->call_app($r, $psgi_app);
        });

        $meta->make_immutable(%immutable_options) if $was_immutable;
    }

    $class->engine($engine->new);

    return;
}

## This exists just to supply a prebuild psgi app for mod_perl and for the
## build in server support (back compat support for pre psgi port behavior).
## This is so that we don't build a new psgi app for each request when using
## the mod_perl handler or the built in servers (http and fcgi, etc).

sub _finalized_psgi_app {
    my ($app) = @_;

    unless ($app->_psgi_app) {
        my $psgi_app = $app->_setup_psgi_app;
        $app->_psgi_app($psgi_app);
    }

    return $app->_psgi_app;
}

## Look for a psgi file like 'myapp_web.psgi' (if the app is MyApp::Web) in the
## home directory and load that and return it (just assume it is doing the
## right thing :) ).  If that does not exist, call $app->psgi_app, wrap that
## in default_middleware and return it ( this is for backward compatibility
## with pre psgi port behavior ).

sub _setup_psgi_app {
    my ($app) = @_;

    for my $home (Path::Class::Dir->new($app->config->{home})) {
        my $psgi_file = $home->file(
                Catalyst::Utils::appprefix($app) . '.psgi',
        );

        next unless -e $psgi_file;

        # If $psgi_file calls ->setup_engine, it's doing so to load
        # Catalyst::Engine::PSGI. But if it does that, we're only going to
        # throw away the loaded PSGI-app and load the 5.9 Catalyst::Engine
        # anyway. So set a flag (ick) that tells setup_engine not to populate
        # $c->engine or do any other things we might regret.

        $app->loading_psgi_file(1);
        my $psgi_app = Plack::Util::load_psgi($psgi_file);
        $app->loading_psgi_file(0);

        return $psgi_app
                unless $app->engine_loader->needs_psgi_engine_compat_hack;

        warn <<"EOW";
Found a legacy Catalyst::Engine::PSGI .psgi file at ${psgi_file}.

Its content has been ignored. Please consult the Catalyst::Upgrading
documentation on how to upgrade from Catalyst::Engine::PSGI.
EOW
    }

    return $app->apply_default_middlewares($app->psgi_app);
}

=head2 $c->apply_default_middlewares

Adds the following L<Plack> middlewares to your application, since they are
useful and commonly needed:

L<Plack::Middleware::LighttpdScriptNameFix> (if you are using Lighttpd),
L<Plack::Middleware::IIS6ScriptNameFix> (always applied since this middleware
is smart enough to conditionally apply itself).

We will also automatically add L<Plack::Middleware::ReverseProxy> if we notice
that your HTTP $env variable C<REMOTE_ADDR> is '127.0.0.1'.  This is usually
an indication that your server is running behind a proxy frontend.  However in
2014 this is often not the case.  We preserve this code for backwards compatibility
however I B<highly> recommend that if you are running the server behind a front
end proxy that you clearly indicate so with the C<using_frontend_proxy> configuration
setting to true for your environment configurations that run behind a proxy.  This
way if you change your front end proxy address someday your code would inexplicably
stop working as expected.

Additionally if we detect we are using Nginx, we add a bit of custom middleware
to solve some problems with the way that server handles $ENV{PATH_INFO} and
$ENV{SCRIPT_NAME}.

Please B<NOTE> that if you do use C<using_frontend_proxy> the middleware is now
adding via C<registered_middleware> rather than this method.

If you are using Lighttpd or IIS6 you may wish to apply these middlewares.  In
general this is no longer a common case but we have this here for backward
compatibility.

=cut


sub apply_default_middlewares {
    my ($app, $psgi_app) = @_;

    # Don't add this conditional IF we are explicitly saying we want the
    # frontend proxy support.  We don't need it here since if that is the
    # case it will be always loaded in the default_middleware.

    unless ($app->config->{using_frontend_proxy}) {
        $psgi_app = Plack::Middleware::Conditional->wrap(
                $psgi_app,
                builder   => sub {Plack::Middleware::ReverseProxy->wrap($_[0])},
                condition => sub {
                    my ($env) = @_;
                    return if $app->config->{ignore_frontend_proxy};
                    return $env->{REMOTE_ADDR} && $env->{REMOTE_ADDR} eq '127.0.0.1';
                },
        );
    }

    # If we're running under Lighttpd, swap PATH_INFO and SCRIPT_NAME
    # http://lists.scsys.co.uk/pipermail/catalyst/2006-June/008361.html
    $psgi_app = Plack::Middleware::Conditional->wrap(
            $psgi_app,
            builder   => sub {Plack::Middleware::LighttpdScriptNameFix->wrap($_[0])},
            condition => sub {
                my ($env) = @_;
                return unless $env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ m!lighttpd[-/]1\.(\d+\.\d+)!;
                return unless $1 < 4.23;
                1;
            },
    );

    # we're applying this unconditionally as the middleware itself already makes
    # sure it doesn't fuck things up if it's not running under one of the right
    # IIS versions
    $psgi_app = Plack::Middleware::IIS6ScriptNameFix->wrap($psgi_app);

    # And another IIS issue, this time with IIS7.
    $psgi_app = Plack::Middleware::Conditional->wrap(
            $psgi_app,
            builder   => sub {Plack::Middleware::IIS7KeepAliveFix->wrap($_[0])},
            condition => sub {
                my ($env) = @_;
                return $env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ m!IIS/7\.[0-9]!;
            },
    );

    return $psgi_app;
}

=head2 App->psgi_app

=head2 App->to_app

Returns a PSGI application code reference for the catalyst application
C<$c>. This is the bare application created without the C<apply_default_middlewares>
method called.  We do however apply C<registered_middleware> since those are
integral to how L<Catalyst> functions.  Also, unlike starting your application
with a generated server script (via L<Catalyst::Devel> and C<catalyst.pl>) we do
not attempt to return a valid L<PSGI> application using any existing C<${myapp}.psgi>
scripts in your $HOME directory.

B<NOTE> C<apply_default_middlewares> was originally created when the first PSGI
port was done for v5.90000.  These are middlewares that are added to achieve
backward compatibility with older applications.  If you start your application
using one of the supplied server scripts (generated with L<Catalyst::Devel> and
the project skeleton script C<catalyst.pl>) we apply C<apply_default_middlewares>
automatically.  This was done so that pre and post PSGI port applications would
work the same way.

This is what you want to be using to retrieve the PSGI application code
reference of your Catalyst application for use in a custom F<.psgi> or in your
own created server modules.

=cut

*to_app = \&psgi_app;

sub psgi_app {
    my ($app) = @_;
    my $psgi = $app->engine->build_psgi_app($app);
    return $app->Catalyst::Utils::apply_registered_middleware($psgi);
}

=head2 $c->setup_home

Sets up the home directory.

=cut

sub setup_home {
    my ($class, $home) = @_;

    if (my $env = Catalyst::Utils::env_value($class, 'HOME')) {
        $home = $env;
    }

    $home ||= Catalyst::Utils::home($class);

    if ($home) {
        #I remember recently being scolded for assigning config values like this
        $class->config->{home} ||= $home;
        $class->config->{root} ||= Path::Class::Dir->new($home)->subdir('root');
    }
}

=head2 $c->setup_encoding

Sets up the input/output encoding. See L<ENCODING>

=cut

sub setup_encoding {
    my $c = shift;
    if (exists($c->config->{encoding}) && !defined($c->config->{encoding})) {
        # Ok, so the user has explicitly said "I don't want encoding..."
        return;
    }
    else {
        my $enc = defined($c->config->{encoding}) ?
                delete $c->config->{encoding} : 'UTF-8'; # not sure why we delete it... (JNAP)
        $c->encoding($enc);
    }
}

=head2 handle_unicode_encoding_exception

Hook to let you customize how encoding errors are handled. By default
we just throw an exception and the default error page will pick it up.
Receives a hashref of debug information. Example of call (from the
Catalyst internals):

  my $decoded_after_fail = $c->handle_unicode_encoding_exception({
        param_value => $value,
        error_msg => $_,
        encoding_step => 'params',
   });

The calling code expects to receive a decoded string or an exception.

You can override this for custom handling of unicode errors. By
default we just die. If you want a custom response here, one approach
is to throw an HTTP style exception, instead of returning a decoded
string or throwing a generic exception.

    sub handle_unicode_encoding_exception {
      my ($c, $params) = @_;
      HTTP::Exception::BAD_REQUEST->throw(status_message=>$params->{error_msg});
    }

Alternatively you can 'catch' the error, stash it and write handling code later
in your application:

    sub handle_unicode_encoding_exception {
      my ($c, $params) = @_;
      $c->stash(BAD_UNICODE_DATA=>$params);
      # return a dummy string.
      return 1;
    }

<B>NOTE:</b> Please keep in mind that once an error like this occurs,
the request setup is still ongoing, which means the state of C<$c> and
related context parts like the request and response may not be setup
up correctly (since we haven't finished the setup yet). If you throw
an exception the setup is aborted.

=cut

sub handle_unicode_encoding_exception {
    my ($self, $exception_ctx) = @_;
    die $exception_ctx->{error_msg};
}

# Some unicode helpers cargo culted from the old plugin.  These could likely
# be neater.

sub _handle_unicode_decoding {
    my ($self, $value) = @_;

    return unless defined $value;

    ## I think this mess is to support the old nested
    if (ref $value eq 'ARRAY') {
        foreach (@$value) {
            $_ = $self->_handle_unicode_decoding($_);
        }
        return $value;
    }
    elsif (ref $value eq 'HASH') {
        foreach (keys %$value) {
            my $encoded_key = $self->_handle_param_unicode_decoding($_);
            $value->{$encoded_key} = $self->_handle_unicode_decoding($value->{$_});

            # If the key was encoded we now have two (the original and current so
            # delete the original.
            delete $value->{$_} if $_ ne $encoded_key;
        }
        return $value;
    }
    else {
        return $self->_handle_param_unicode_decoding($value);
    }
}

sub _handle_param_unicode_decoding {
    my ($self, $value, $check) = @_;
    return unless defined $value;     # not in love with just ignoring undefs - jnap
    return $value if blessed($value); #don't decode when the value is an object.

    my $enc = $self->encoding;

    return $value unless $enc; # don't decode if no encoding is specified

    $check ||= $self->_encode_check;
    return try {
        $enc->decode($value, $check);
    }
    catch {
        return $self->handle_unicode_encoding_exception({
                param_value   => $value,
                error_msg     => $_,
                encoding_step => 'params',
        });
    };
}

=head2 $c->setup_log

Sets up log by instantiating a L<Catalyst::Log|Catalyst::Log> object and
passing it to C<log()>. Pass in a comma-delimited list of levels to set the
log to.

This method also installs a C<debug> method that returns a true value into the
catalyst subclass if the "debug" level is passed in the comma-delimited list,
or if the C<$CATALYST_DEBUG> environment variable is set to a true value.

Note that if the log has already been setup, by either a previous call to
C<setup_log> or by a call such as C<< __PACKAGE__->log( MyLogger->new ) >>,
that this method won't actually set up the log object.

=cut

sub setup_log {
    my ($class, $levels) = @_;

    $levels ||= '';
    $levels =~ s/^\s+//;
    $levels =~ s/\s+$//;
    my %levels = map {$_ => 1} split /\s*,\s*/, $levels;

    my $env_debug = Catalyst::Utils::env_value($class, 'DEBUG');
    if (defined $env_debug) {
        $levels{debug} = 1 if $env_debug; # Ugly!
        delete($levels{debug}) unless $env_debug;
    }

    unless ($class->log) {
        $class->log(Catalyst::Log->new(keys %levels));
    }

    if ($levels{debug}) {
        Class::MOP::get_metaclass_by_name($class)->add_method('debug' => sub {1});
        $class->log->debug('Debug messages enabled');
    }
}

=head2 $c->setup_plugins

Sets up plugins.

=cut

=head2 $c->setup_stats

Sets up timing statistics class.

=cut

sub setup_stats {
    my ($class, $stats) = @_;

    Catalyst::Utils::ensure_class_loaded($class->stats_class);

    my $env = Catalyst::Utils::env_value($class, 'STATS');
    if (defined($env) ? $env : ($stats || $class->debug)) {
        Class::MOP::get_metaclass_by_name($class)->add_method('use_stats' => sub {1});
        $class->log->debug('Statistics enabled');
    }
}


=head2 $c->registered_plugins

Returns a sorted list of the plugins which have either been stated in the
import list.

If passed a given plugin name, it will report a boolean value indicating
whether or not that plugin is loaded.  A fully qualified name is required if
the plugin name does not begin with C<Catalyst::Plugin::>.

 if ($c->registered_plugins('Some::Plugin')) {
     ...
 }

=cut

{

    sub registered_plugins {
        my $proto = shift;
        return sort keys %{$proto->_plugins} unless @_;
        my $plugin = shift;
        return 1 if exists $proto->_plugins->{$plugin};
        return exists $proto->_plugins->{"Catalyst::Plugin::$plugin"};
    }

    sub _register_plugin {
        my ($proto, $plugin, $instant) = @_;
        my $class = ref $proto || $proto;

        load_class($plugin);
        $class->log->warn("$plugin inherits from 'Catalyst::Component' - this is deprecated and will not work in 5.81")
                if $plugin->isa('Catalyst::Component');
        my $plugin_meta = Moose::Meta::Class->create($plugin);
        if (!$plugin_meta->has_method('new')
                && ($plugin->isa('Class::Accessor::Fast') || $plugin->isa('Class::Accessor'))) {
            $plugin_meta->add_method('new', Moose::Object->meta->get_method('new'))
        }
        if (!$instant && !$proto->_plugins->{$plugin}) {
            my $meta = Class::MOP::get_metaclass_by_name($class);
            $meta->superclasses($plugin, $meta->superclasses);
        }
        $proto->_plugins->{$plugin} = 1;
        return $class;
    }

    sub _default_plugins {return qw()}

    sub setup_plugins {
        my ($class, $plugins) = @_;

        $class->_plugins({}) unless $class->_plugins;
        $plugins = [ grep {
            m/Unicode::Encoding/ ? do {
                $class->log->warn(
                        'Unicode::Encoding plugin is auto-applied,'
                                . ' please remove this from your appclass'
                                . ' and make sure to define "encoding" config'
                );
                unless (exists $class->config->{'encoding'}) {
                    $class->config->{'encoding'} = 'UTF-8';
                }
                ()
            }
                    : $_
        } @$plugins ];
        push @$plugins, $class->_default_plugins;
        $plugins = Data::OptList::mkopt($plugins || []);

        my @plugins = map {
            [ Catalyst::Utils::resolve_namespace(
                    $class . '::Plugin',
                    'Catalyst::Plugin', $_->[0]
            ),
                    $_->[1],
            ]
        } @{$plugins};

        for my $plugin (reverse @plugins) {
            load_class($plugin->[0], $plugin->[1]);
            my $meta = find_meta($plugin->[0]);
            next if $meta && $meta->isa('Moose::Meta::Role');

            $class->_register_plugin($plugin->[0]);
        }

        my @roles =
                map {$_->[0]->name, $_->[1]}
                        grep {blessed($_->[0]) && $_->[0]->isa('Moose::Meta::Role')}
                                map {[ find_meta($_->[0]), $_->[1] ]}
                                        @plugins;

        Moose::Util::apply_all_roles(
                $class => @roles
        ) if @roles;
    }
}

=head2 default_middleware

Returns a list of instantiated PSGI middleware objects which is the default
middleware that is active for this application (taking any configuration
options into account, excluding your custom added middleware via the C<psgi_middleware>
configuration option).  You can override this method if you wish to change
the default middleware (although do so at risk since some middleware is vital
to application function.)

The current default middleware list is:

      Catalyst::Middleware::Stash
      Plack::Middleware::HTTPExceptions
      Plack::Middleware::RemoveRedundantBody
      Plack::Middleware::FixMissingBodyInRedirect
      Plack::Middleware::ContentLength
      Plack::Middleware::MethodOverride
      Plack::Middleware::Head

If the configuration setting C<using_frontend_proxy> is true we add:

      Plack::Middleware::ReverseProxy

If the configuration setting C<using_frontend_proxy_path> is true we add:

      Plack::Middleware::ReverseProxyPath

But B<NOTE> that L<Plack::Middleware::ReverseProxyPath> is not a dependency of the
L<Catalyst> distribution so if you want to use this option you should add it to
your project distribution file.

These middlewares will be added at L</setup_middleware> during the
L</setup> phase of application startup.

=cut

sub default_middleware {
    my $class = shift;
    my @mw = (
            Catalyst::Middleware::Stash->new,
            Plack::Middleware::HTTPExceptions->new,
            Plack::Middleware::RemoveRedundantBody->new,
            Plack::Middleware::FixMissingBodyInRedirect->new,
            Plack::Middleware::ContentLength->new,
            Plack::Middleware::MethodOverride->new,
            Plack::Middleware::Head->new);

    if ($class->config->{using_frontend_proxy}) {
        push @mw, Plack::Middleware::ReverseProxy->new;
    }

    if ($class->config->{using_frontend_proxy_path}) {
        if (Class::Load::try_load_class('Plack::Middleware::ReverseProxyPath')) {
            push @mw, Plack::Middleware::ReverseProxyPath->new;
        }
        else {
            $class->log->error("Cannot use configuration 'using_frontend_proxy_path' because 'Plack::Middleware::ReverseProxyPath' is not installed");
        }
    }

    return @mw;
}

=head2 registered_middlewares

Read only accessor that returns an array of all the middleware in the order
that they were added (which is the REVERSE of the order they will be applied).

The values returned will be either instances of L<Plack::Middleware> or of a
compatible interface, or a coderef, which is assumed to be inlined middleware

=head2 setup_middleware (?@middleware)

Read configuration information stored in configuration key C<psgi_middleware> or
from passed @args.

See under L</CONFIGURATION> information regarding C<psgi_middleware> and how
to use it to enable L<Plack::Middleware>

This method is automatically called during 'setup' of your application, so
you really don't need to invoke it.  However you may do so if you find the idea
of loading middleware via configuration weird :).  For example:

    package MyApp;

    use Catalyst;

    __PACKAGE__->setup_middleware('Head');
    __PACKAGE__->setup;

When we read middleware definitions from configuration, we reverse the list
which sounds odd but is likely how you expect it to work if you have prior
experience with L<Plack::Builder> or if you previously used the plugin
L<Catalyst::Plugin::EnableMiddleware> (which is now considered deprecated)

So basically your middleware handles an incoming request from the first
registered middleware, down and handles the response from the last middleware
up.

=cut

sub registered_middlewares {
    my $class = shift;
    if (my $middleware = $class->_psgi_middleware) {
        my @mw = ($class->default_middleware, @$middleware);

        if ($class->config->{using_frontend_proxy}) {
            push @mw, Plack::Middleware::ReverseProxy->new;
        }

        return @mw;
    }
    else {
        die "You cannot call ->registered_middlewares until middleware has been setup";
    }
}

sub setup_middleware {
    my $class = shift;
    my @middleware_definitions;

    # If someone calls this method you can add middleware with args.  However if its
    # called without an arg we need to setup the configuration middleware.
    if (@_) {
        @middleware_definitions = reverse(@_);
    }
    else {
        @middleware_definitions = reverse(@{$class->config->{'psgi_middleware'} || []})
                unless $class->finalized_default_middleware;
        $class->finalized_default_middleware(1); # Only do this once, just in case some people call setup over and over...
    }

    my @middleware = ();
    while (my $next = shift(@middleware_definitions)) {
        if (ref $next) {
            if (Scalar::Util::blessed $next && $next->can('wrap')) {
                push @middleware, $next;
            }
            elsif (ref $next eq 'CODE') {
                push @middleware, $next;
            }
            elsif (ref $next eq 'HASH') {
                my $namespace = shift @middleware_definitions;
                my $mw = $class->Catalyst::Utils::build_middleware($namespace, %$next);
                push @middleware, $mw;
            }
            else {
                die "I can't handle middleware definition ${\ref $next}";
            }
        }
        else {
            my $mw = $class->Catalyst::Utils::build_middleware($next);
            push @middleware, $mw;
        }
    }

    my @existing = @{$class->_psgi_middleware || []};
    $class->_psgi_middleware([ @middleware, @existing, ]);
}

=head2 registered_data_handlers

A read only copy of registered Data Handlers returned as a Hash, where each key
is a content type and each value is a subref that attempts to decode that content
type.

=head2 setup_data_handlers (?@data_handler)

Read configuration information stored in configuration key C<data_handlers> or
from passed @args.

See under L</CONFIGURATION> information regarding C<data_handlers>.

This method is automatically called during 'setup' of your application, so
you really don't need to invoke it.

=head2 default_data_handlers

Default Data Handlers that come bundled with L<Catalyst>.  Currently there are
only two default data handlers, for 'application/json' and an alternative to
'application/x-www-form-urlencoded' which supposed nested form parameters via
L<CGI::Struct> or via L<CGI::Struct::XS> IF you've installed it.

The 'application/json' data handler is used to parse incoming JSON into a Perl
data structure.  It uses L<JSON::MaybeXS>.  This allows you to fail back to
L<JSON::PP>, which is a Pure Perl JSON decoder, and has the smallest dependency
impact.

Because we don't wish to add more dependencies to L<Catalyst>, if you wish to
use this new feature we recommend installing L<Cpanel::JSON::XS> in order to get
the best performance.  You should add either to your dependency list
(Makefile.PL, dist.ini, cpanfile, etc.)

=cut

sub registered_data_handlers {
    my $class = shift;
    if (my $data_handlers = $class->_data_handlers) {
        return %$data_handlers;
    }
    else {
        $class->setup_data_handlers;
        return $class->registered_data_handlers;
    }
}

sub setup_data_handlers {
    my ($class, %data_handler_callbacks) = @_;
    %data_handler_callbacks = (
            %{$class->default_data_handlers},
            %{$class->config->{'data_handlers'} || +{}},
            %data_handler_callbacks);

    $class->_data_handlers(\%data_handler_callbacks);
}

sub default_data_handlers {
    my ($class) = @_;
    return +{
            'application/x-www-form-urlencoded' => sub {
                my ($fh, $req) = @_;
                my $params = $req->_use_hash_multivalue ? $req->body_parameters->mixed : $req->body_parameters;
                Class::Load::load_first_existing_class('CGI::Struct::XS', 'CGI::Struct')
                        ->can('build_cgi_struct')->($params);
            },
            'application/json'                  => sub {
                my ($fh, $req) = @_;
                require JSON::MaybeXS;
                my $slurped;
                return eval {
                    local $/;
                    $slurped = $fh->getline;
                    JSON::MaybeXS::decode_json($slurped); # decode_json does utf8 decoding for us
                } || Catalyst::Exception->throw(sprintf "Error Parsing POST '%s', Error: %s", (defined($slurped) ? $slurped : 'undef'), $@);
            },
    };
}

sub _handle_http_exception {
    my ($self, $error) = @_;
    if (
            !$self->config->{always_catch_http_exceptions}
                    && blessed $error
                    && (
                    $error->can('as_psgi')
                            || ($error->can('code')
                            && $error->code =~ m/^[1-5][0-9][0-9]$/)
            )
    ) {
        return 1;
    }
}

=head2 $c->stack

Returns an arrayref of the internal execution stack (actions that are
currently executing).

=head2 $c->stats

Returns the current timing statistics object. By default Catalyst uses
L<Catalyst::Stats|Catalyst::Stats>, but can be set otherwise with
L<< stats_class|/"$c->stats_class" >>.

Even if L<< -Stats|/"-Stats" >> is not enabled, the stats object is still
available. By enabling it with C<< $c->stats->enabled(1) >>, it can be used to
profile explicitly, although MyApp.pm still won't profile nor output anything
by itself.

=head2 $c->stats_class

Returns or sets the stats (timing statistics) class. L<Catalyst::Stats|Catalyst::Stats> is used by default.

=head2 $app->stats_class_traits

A arrayref of L<Moose::Role>s that are applied to the stats_class before creating it.

=head2 $app->composed_stats_class

this is the stats_class composed with any 'stats_class_traits'.  You can
name the full namespace of the role, or a namespace suffix, which will then
be tried against the following standard namespace prefixes.

    $MyApp::TraitFor::Stats::$trait_suffix
    Catalyst::TraitFor::Stats::$trait_suffix

So for example if you set:

    MyApp->stats_class_traits(['Foo']);

We try each possible role in turn (and throw an error if none load)

    Foo
    MyApp::TraitFor::Stats::Foo
    Catalyst::TraitFor::Stats::Foo

The namespace part 'TraitFor::Stats' was chosen to assist in backwards
compatibility with L<CatalystX::RoleApplicator> which previously provided
these features in a stand alone package.

=head2 $c->use_stats

Returns 1 when L<< stats collection|/"-Stats" >> is enabled.

Note that this is a static method, not an accessor and should be overridden
by declaring C<sub use_stats { 1 }> in your MyApp.pm, not by calling C<< $c->use_stats(1) >>.

=cut

sub use_stats {0}


=head2 $c->write( $data )

Writes $data to the output stream. When using this method directly, you
will need to manually set the C<Content-Length> header to the length of
your output data, if known.

=cut

sub write {
    my $c = shift;

    # Finalize headers if someone manually writes output (for compat)
    $c->finalize_headers;

    return $c->response->write(@_);
}

=head2 version

Returns the Catalyst version number. Mostly useful for "powered by"
messages in template systems.

=cut

sub version {return $Catalyst::VERSION}

=head1 CONFIGURATION

There are a number of 'base' config variables which can be set:

=over

=item *

C<always_catch_http_exceptions> - As of version 5.90060 Catalyst
rethrows errors conforming to the interface described by
L<Plack::Middleware::HTTPExceptions> and lets the middleware deal with it.
Set true to get the deprecated behaviour and have Catalyst catch HTTP exceptions.

=item *

C<default_model> - The default model picked if you say C<< $c->model >>. See L<< /$c->model($name) >>.

=item *

C<default_view> - The default view to be rendered or returned when C<< $c->view >> is called. See L<< /$c->view($name) >>.

=item *

C<disable_component_resolution_regex_fallback> - Turns
off the deprecated component resolution functionality so
that if any of the component methods (e.g. C<< $c->controller('Foo') >>)
are called then regex search will not be attempted on string values and
instead C<undef> will be returned.

=item *

C<home> - The application home directory. In an uninstalled application,
this is the top level application directory. In an installed application,
this will be the directory containing C<< MyApp.pm >>.

=item *

C<ignore_frontend_proxy> - See L</PROXY SUPPORT>

=item *

C<name> - The name of the application in debug messages and the debug and
welcome screens

=item *

C<parse_on_demand> - The request body (for example file uploads) will not be parsed
until it is accessed. This allows you to (for example) check authentication (and reject
the upload) before actually receiving all the data. See L</ON-DEMAND PARSER>

=item *

C<root> - The root directory for templates. Usually this is just a
subdirectory of the home directory, but you can set it to change the
templates to a different directory.

=item *

C<search_extra> - Array reference passed to Module::Pluggable to for additional
namespaces from which components will be loaded (and constructed and stored in
C<< $c->components >>).

=item *

C<show_internal_actions> - If true, causes internal actions such as C<< _DISPATCH >>
to be shown in hit debug tables in the test server.

=item *

C<use_request_uri_for_path> - Controls if the C<REQUEST_URI> or C<PATH_INFO> environment
variable should be used for determining the request path.

Most web server environments pass the requested path to the application using environment variables,
from which Catalyst has to reconstruct the request base (i.e. the top level path to / in the application,
exposed as C<< $c->request->base >>) and the request path below that base.

There are two methods of doing this, both of which have advantages and disadvantages. Which method is used
is determined by the C<< $c->config(use_request_uri_for_path) >> setting (which can either be true or false).

=over

=item use_request_uri_for_path => 0

This is the default (and the) traditional method that Catalyst has used for determining the path information.
The path is generated from a combination of the C<PATH_INFO> and C<SCRIPT_NAME> environment variables.
The allows the application to behave correctly when C<mod_rewrite> is being used to redirect requests
into the application, as these variables are adjusted by mod_rewrite to take account for the redirect.

However this method has the major disadvantage that it is impossible to correctly decode some elements
of the path, as RFC 3875 says: "C<< Unlike a URI path, the PATH_INFO is not URL-encoded, and cannot
contain path-segment parameters. >>" This means PATH_INFO is B<always> decoded, and therefore Catalyst
can't distinguish / vs %2F in paths (in addition to other encoded values).

=item use_request_uri_for_path => 1

This method uses the C<REQUEST_URI> and C<SCRIPT_NAME> environment variables. As C<REQUEST_URI> is never
decoded, this means that applications using this mode can correctly handle URIs including the %2F character
(i.e. with C<AllowEncodedSlashes> set to C<On> in Apache).

Given that this method of path resolution is provably more correct, it is recommended that you use
this unless you have a specific need to deploy your application in a non-standard environment, and you are
aware of the implications of not being able to handle encoded URI paths correctly.

However it also means that in a number of cases when the app isn't installed directly at a path, but instead
is having paths rewritten into it (e.g. as a .cgi/fcgi in a public_html directory, with mod_rewrite in a
.htaccess file, or when SSI is used to rewrite pages into the app, or when sub-paths of the app are exposed
at other URIs than that which the app is 'normally' based at with C<mod_rewrite>), the resolution of
C<< $c->request->base >> will be incorrect.

=back

=item *

C<using_frontend_proxy> - See L</PROXY SUPPORT>.

=item *

C<using_frontend_proxy_path> - Enabled L<Plack::Middleware::ReverseProxyPath> on your application (if
installed, otherwise log an error).  This is useful if your application is not running on the
'root' (or /) of your host server.  B<NOTE> if you use this feature you should add the required
middleware to your project dependency list since its not automatically a dependency of L<Catalyst>.
This has been done since not all people need this feature and we wish to restrict the growth of
L<Catalyst> dependencies.

=item *

C<encoding> - See L</ENCODING>

This now defaults to 'UTF-8'.  You my turn it off by setting this configuration
value to undef.

=item *

C<abort_chain_on_error_fix>

Defaults to true.

When there is an error in an action chain, the default behavior is to
abort the processing of the remaining actions to avoid running them
when the application is in an unexpected state.

Before version 5.90070, the default used to be false. To keep the old
behaviour, you can explicitly set the value to false. E.g.

    __PACKAGE__->config(abort_chain_on_error_fix => 0);

If this setting is set to false, then the remaining actions are
performed and the error is caught at the end of the chain.


=item *

C<use_hash_multivalue_in_request>

In L<Catalyst::Request> the methods C<query_parameters>, C<body_parametes>
and C<parameters> return a hashref where values might be scalar or an arrayref
depending on the incoming data.  In many cases this can be undesirable as it
leads one to writing defensive code like the following:

    my ($val) = ref($c->req->parameters->{a}) ?
      @{$c->req->parameters->{a}} :
        $c->req->parameters->{a};

Setting this configuration item to true will make L<Catalyst> populate the
attributes underlying these methods with an instance of L<Hash::MultiValue>
which is used by L<Plack::Request> and others to solve this very issue.  You
may prefer this behavior to the default, if so enable this option (be warned
if you enable it in a legacy application we are not sure if it is completely
backwardly compatible).

=item *

C<skip_complex_post_part_handling>

When creating body parameters from a POST, if we run into a multipart POST
that does not contain uploads, but instead contains inlined complex data
(very uncommon) we cannot reliably convert that into field => value pairs.  So
instead we create an instance of L<Catalyst::Request::PartData>.  If this causes
issue for you, you can disable this by setting C<skip_complex_post_part_handling>
to true (default is false).

=item *

C<skip_body_param_unicode_decoding>

Generally we decode incoming POST params based on your declared encoding (the
default for this is to decode UTF-8).  If this is causing you trouble and you
do not wish to turn all encoding support off (with the C<encoding> configuration
parameter) you may disable this step atomically by setting this configuration
parameter to true.

=item *

C<do_not_decode_query>

If true, then do not try to character decode any wide characters in your
request URL query or keywords.  Most readings of the relevant specifications
suggest these should be UTF-* encoded, which is the default that L<Catalyst>
will use, however if you are creating a lot of URLs manually or have external
evil clients, this might cause you trouble.  If you find the changes introduced
in Catalyst version 5.90080+ break some of your query code, you may disable
the UTF-8 decoding globally using this configuration.

This setting takes precedence over C<default_query_encoding>

=item *

C<do_not_check_query_encoding>

Catalyst versions 5.90080 - 5.90106 would decode query parts of an incoming
request but would not raise an exception when the decoding failed due to
incorrect unicode.  It now does, but if this change is giving you trouble
you may disable it by setting this configuration to true.

=item *

C<default_query_encoding>

By default we decode query and keywords in your request URL using UTF-8, which
is our reading of the relevant specifications.  This setting allows one to
specify a fixed value for how to decode your query.  You might need this if
you are doing a lot of custom encoding of your URLs and not using UTF-8.

=item *

C<use_chained_args_0_special_case>

In older versions of Catalyst, when more than one action matched the same path
AND all those matching actions declared Args(0), we'd break the tie by choosing
the first action defined.  We now normalized how Args(0) works so that it
follows the same rule as Args(N), which is to say when we need to break a tie
we choose the LAST action defined.  If this breaks your code and you don't
have time to update to follow the new normalized approach, you may set this
value to true and it will globally revert to the original chaining behavior.

=item *

C<psgi_middleware> - See L<PSGI MIDDLEWARE>.

=item *

C<data_handlers> - See L<DATA HANDLERS>.

=item *

C<stats_class_traits>

An arrayref of L<Moose::Role>s that get composed into your stats class.

=item *

C<request_class_traits>

An arrayref of L<Moose::Role>s that get composed into your request class.

=item *

C<response_class_traits>

An arrayref of L<Moose::Role>s that get composed into your response class.

=item *

C<inject_components>

A Hashref of L<Catalyst::Component> subclasses that are 'injected' into configuration.
For example:

    MyApp->config({
      inject_components => {
        'Controller::Err' => { from_component => 'Local::Controller::Errors' },
        'Model::Zoo' => { from_component => 'Local::Model::Foo' },
        'Model::Foo' => { from_component => 'Local::Model::Foo', roles => ['TestRole'] },
      },
      'Controller::Err' => { a => 100, b=>200, namespace=>'error' },
      'Model::Zoo' => { a => 2 },
      'Model::Foo' => { a => 100 },
    });

Generally L<Catalyst> looks for components in your Model/View or Controller directories.
However for cases when you which to use an existing component and you don't need any
customization (where for when you can apply a role to customize it) you may inject those
components into your application.  Please note any configuration should be done 'in the
normal way', with a key under configuration named after the component affix, as in the
above example.

Using this type of injection allows you to construct significant amounts of your application
with only configuration!.  This may or may not lead to increased code understanding.

Please not you may also call the ->inject_components application method as well, although
you must do so BEFORE setup.

=back

=head1 EXCEPTIONS

Generally when you throw an exception inside an Action (or somewhere in
your stack, such as in a model that an Action is calling) that exception
is caught by Catalyst and unless you either catch it yourself (via eval
or something like L<Try::Tiny> or by reviewing the L</error> stack, it
will eventually reach L</finalize_errors> and return either the debugging
error stack page, or the default error page.  However, if your exception
can be caught by L<Plack::Middleware::HTTPExceptions>, L<Catalyst> will
instead rethrow it so that it can be handled by that middleware (which
is part of the default middleware).  For example this would allow

    use HTTP::Throwable::Factory 'http_throw';

    sub throws_exception :Local {
      my ($self, $c) = @_;

      http_throw(SeeOther => { location =>
        $c->uri_for($self->action_for('redirect')) });

    }

=head1 INTERNAL ACTIONS

Catalyst uses internal actions like C<_DISPATCH>, C<_BEGIN>, C<_AUTO>,
C<_ACTION>, and C<_END>. These are by default not shown in the private
action table, but you can make them visible with a config parameter.

    MyApp->config(show_internal_actions => 1);

=head1 ON-DEMAND PARSER

The request body is usually parsed at the beginning of a request,
but if you want to handle input yourself, you can enable on-demand
parsing with a config parameter.

    MyApp->config(parse_on_demand => 1);

=head1 PROXY SUPPORT

Many production servers operate using the common double-server approach,
with a lightweight frontend web server passing requests to a larger
backend server. An application running on the backend server must deal
with two problems: the remote user always appears to be C<127.0.0.1> and
the server's hostname will appear to be C<localhost> regardless of the
virtual host that the user connected through.

Catalyst will automatically detect this situation when you are running
the frontend and backend servers on the same machine. The following
changes are made to the request.

    $c->req->address is set to the user's real IP address, as read from
    the HTTP X-Forwarded-For header.

    The host value for $c->req->base and $c->req->uri is set to the real
    host, as read from the HTTP X-Forwarded-Host header.

Additionally, you may be running your backend application on an insecure
connection (port 80) while your frontend proxy is running under SSL.  If there
is a discrepancy in the ports, use the HTTP header C<X-Forwarded-Port> to
tell Catalyst what port the frontend listens on.  This will allow all URIs to
be created properly.

In the case of passing in:

    X-Forwarded-Port: 443

All calls to C<uri_for> will result in an https link, as is expected.

Obviously, your web server must support these headers for this to work.

In a more complex server farm environment where you may have your
frontend proxy server(s) on different machines, you will need to set a
configuration option to tell Catalyst to read the proxied data from the
headers.

    MyApp->config(using_frontend_proxy => 1);

If you do not wish to use the proxy support at all, you may set:

    MyApp->config(ignore_frontend_proxy => 0);

=head2 Note about psgi files

Note that if you supply your own .psgi file, calling
C<< MyApp->psgi_app(@_); >>, then B<this will not happen automatically>.

You either need to apply L<Plack::Middleware::ReverseProxy> yourself
in your psgi, for example:

    builder {
        enable "Plack::Middleware::ReverseProxy";
        MyApp->psgi_app
    };

This will unconditionally add the ReverseProxy support, or you need to call
C<< $app = MyApp->apply_default_middlewares($app) >> (to conditionally
apply the support depending upon your config).

See L<Catalyst::PSGI> for more information.

=head1 THREAD SAFETY

Catalyst has been tested under Apache 2's threading C<mpm_worker>,
C<mpm_winnt>, and the standalone forking HTTP server on Windows. We
believe the Catalyst core to be thread-safe.

If you plan to operate in a threaded environment, remember that all other
modules you are using must also be thread-safe. Some modules, most notably
L<DBD::SQLite>, are not thread-safe.

=head1 DATA HANDLERS

The L<Catalyst::Request> object uses L<HTTP::Body> to populate 'classic' HTML
form parameters and URL search query fields.  However it has become common
for various alternative content types to be PUT or POSTed to your controllers
and actions.  People working on RESTful APIs, or using AJAX often use JSON,
XML and other content types when communicating with an application server.  In
order to better support this use case, L<Catalyst> defines a global configuration
option, C<data_handlers>, which lets you associate a content type with a coderef
that parses that content type into something Perl can readily access.

    package MyApp::Web;

    use Catalyst;
    use JSON::MaybeXS;

    __PACKAGE__->config(
      data_handlers => {
        'application/json' => sub { local $/; decode_json $_->getline },
      },
      ## Any other configuration.
    );

    __PACKAGE__->setup;

By default L<Catalyst> comes with a generic JSON data handler similar to the
example given above, which uses L<JSON::MaybeXS> to provide either L<JSON::PP>
(a pure Perl, dependency free JSON parser) or L<Cpanel::JSON::XS> if you have
it installed (if you want the faster XS parser, add it to you project Makefile.PL
or dist.ini, cpanfile, etc.)

The C<data_handlers> configuration is a hashref whose keys are HTTP Content-Types
(matched against the incoming request type using a regexp such as to be case
insensitive) and whose values are coderefs that receive a localized version of
C<$_> which is a filehandle object pointing to received body.

This feature is considered an early access release and we reserve the right
to alter the interface in order to provide a performant and secure solution to
alternative request body content.  Your reports welcomed!

=head1 PSGI MIDDLEWARE

You can define middleware, defined as L<Plack::Middleware> or a compatible
interface in configuration.  Your middleware definitions are in the form of an
arrayref under the configuration key C<psgi_middleware>.  Here's an example
with details to follow:

    package MyApp::Web;

    use Catalyst;
    use Plack::Middleware::StackTrace;

    my $stacktrace_middleware = Plack::Middleware::StackTrace->new;

    __PACKAGE__->config(
      'psgi_middleware', [
        'Debug',
        '+MyApp::Custom',
        $stacktrace_middleware,
        'Session' => {store => 'File'},
        sub {
          my $app = shift;
          return sub {
            my $env = shift;
            $env->{myapp.customkey} = 'helloworld';
            $app->($env);
          },
        },
      ],
    );

    __PACKAGE__->setup;

So the general form is:

    __PACKAGE__->config(psgi_middleware => \@middleware_definitions);

Where C<@middleware> is one or more of the following, applied in the REVERSE of
the order listed (to make it function similarly to L<Plack::Builder>:

Alternatively, you may also define middleware by calling the L</setup_middleware>
package method:

    package MyApp::Web;

    use Catalyst;

    __PACKAGE__->setup_middleware( \@middleware_definitions);
    __PACKAGE__->setup;

In the case where you do both (use 'setup_middleware' and configuration) the
package call to setup_middleware will be applied earlier (in other words its
middleware will wrap closer to the application).  Keep this in mind since in
some cases the order of middleware is important.

The two approaches are not exclusive.

=over 4

=item Middleware Object

An already initialized object that conforms to the L<Plack::Middleware>
specification:

    my $stacktrace_middleware = Plack::Middleware::StackTrace->new;

    __PACKAGE__->config(
      'psgi_middleware', [
        $stacktrace_middleware,
      ]);


=item coderef

A coderef that is an inlined middleware:

    __PACKAGE__->config(
      'psgi_middleware', [
        sub {
          my $app = shift;
          return sub {
            my $env = shift;
            if($env->{PATH_INFO} =~m/forced/) {
              Plack::App::File
                ->new(file=>TestApp->path_to(qw/share static forced.txt/))
                ->call($env);
            } else {
              return $app->($env);
            }
         },
      },
    ]);



=item a scalar

We assume the scalar refers to a namespace after normalizing it using the
following rules:

(1) If the scalar is prefixed with a "+" (as in C<+MyApp::Foo>) then the full string
is assumed to be 'as is', and we just install and use the middleware.

(2) If the scalar begins with "Plack::Middleware" or your application namespace
(the package name of your Catalyst application subclass), we also assume then
that it is a full namespace, and use it.

(3) Lastly, we then assume that the scalar is a partial namespace, and attempt to
resolve it first by looking for it under your application namespace (for example
if you application is "MyApp::Web" and the scalar is "MyMiddleware", we'd look
under "MyApp::Web::Middleware::MyMiddleware") and if we don't find it there, we
will then look under the regular L<Plack::Middleware> namespace (i.e. for the
previous we'd try "Plack::Middleware::MyMiddleware").  We look under your application
namespace first to let you 'override' common L<Plack::Middleware> locally, should
you find that a good idea.

Examples:

    package MyApp::Web;

    __PACKAGE__->config(
      'psgi_middleware', [
        'Debug',  ## MyAppWeb::Middleware::Debug->wrap or Plack::Middleware::Debug->wrap
        'Plack::Middleware::Stacktrace', ## Plack::Middleware::Stacktrace->wrap
        '+MyApp::Custom',  ## MyApp::Custom->wrap
      ],
    );

=item a scalar followed by a hashref

Just like the previous, except the following C<HashRef> is used as arguments
to initialize the middleware object.

    __PACKAGE__->config(
      'psgi_middleware', [
         'Session' => {store => 'File'},
    ]);

=back

Please see L<PSGI> for more on middleware.

=head1 ENCODING

Starting in L<Catalyst> version 5.90080 encoding is automatically enabled
and set to encode all body responses to UTF8 when possible and applicable.
Following is documentation on this process.  If you are using an older
version of L<Catalyst> you should review documentation for that version since
a lot has changed.

By default encoding is now 'UTF-8'.  You may turn it off by setting
the encoding configuration to undef.

    MyApp->config(encoding => undef);

This is recommended for temporary backwards compatibility only.

To turn it off for a single request use the L<clear_encoding>
method to turn off encoding for this request.  This can be useful
when you are setting the body to be an arbitrary block of bytes,
especially if that block happens to be a block of UTF8 text.

Encoding is automatically applied when the content-type is set to
a type that can be encoded.  Currently we encode when the content type
matches the following regular expression:

    $content_type =~ /^text|xml$|javascript$/

Encoding is set on the application, but it is copied to the context object
so that you can override it on a request basis.

Be default we don't automatically encode 'application/json' since the most
common approaches to generating this type of response (Either via L<Catalyst::View::JSON>
or L<Catalyst::Action::REST>) will do so already and we want to avoid double
encoding issues.

If you are producing JSON response in an unconventional manner (such
as via a template or manual strings) you should perform the UTF8 encoding
manually as well such as to conform to the JSON specification.

NOTE: We also examine the value of $c->response->content_encoding.  If
you set this (like for example 'gzip', and manually gzipping the body)
we assume that you have done all the necessary encoding yourself, since
we cannot encode the gzipped contents.  If you use a plugin like
L<Catalyst::Plugin::Compress> you need to update to a modern version in order
to have this function correctly  with the new UTF8 encoding code, or you
can use L<Plack::Middleware::Deflater> or (probably best) do your compression on
a front end proxy.

=head2 Methods

=over 4

=item encoding

Returns an instance of an C<Encode> encoding

    print $c->encoding->name

=item handle_unicode_encoding_exception ($exception_context)

Method called when decoding process for a request fails.

An C<$exception_context> hashref is provided to allow you to override the
behaviour of your application when given data with incorrect encodings.

The default method throws exceptions in the case of invalid request parameters
(resulting in a 500 error), but ignores errors in upload filenames.

The keys passed in the C<$exception_context> hash are:

=over

=item param_value

The value which was not able to be decoded.

=item error_msg

The exception received from L<Encode>.

=item encoding_step

What type of data was being decoded. Valid values are (currently)
C<params> - for request parameters / arguments / captures
and C<uploads> - for request upload filenames.

=back

=back

=head1 SUPPORT

IRC:

    Join #catalyst on irc.perl.org.

Mailing Lists:

    http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/catalyst
    http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/catalyst-dev

Web:

    http://catalyst.perl.org

Wiki:

    http://dev.catalyst.perl.org

=head1 SEE ALSO

=head2 L<Task::Catalyst> - All you need to start with Catalyst

=head2 L<Catalyst::Manual> - The Catalyst Manual

=head2 L<Catalyst::Component>, L<Catalyst::Controller> - Base classes for components

=head2 L<Catalyst::Engine> - Core engine

=head2 L<Catalyst::Log> - Log class.

=head2 L<Catalyst::Request> - Request object

=head2 L<Catalyst::Response> - Response object

=head2 L<Catalyst::Test> - The test suite.

=head1 PROJECT FOUNDER

sri: Sebastian Riedel <sri@cpan.org>

=head1 CONTRIBUTORS

abw: Andy Wardley

acme: Leon Brocard <leon@astray.com>

abraxxa: Alexander Hartmaier <abraxxa@cpan.org>

andrewalker: André Walker <andre@cpan.org>

Andrew Bramble

Andrew Ford <A.Ford@ford-mason.co.uk>

Andrew Ruthven

andyg: Andy Grundman <andy@hybridized.org>

audreyt: Audrey Tang

bricas: Brian Cassidy <bricas@cpan.org>

Caelum: Rafael Kitover <rkitover@io.com>

chansen: Christian Hansen

Chase Venters <chase.venters@gmail.com>

chicks: Christopher Hicks

Chisel Wright <pause@herlpacker.co.uk>

Danijel Milicevic <me@danijel.de>

davewood: David Schmidt <davewood@cpan.org>

David Kamholz <dkamholz@cpan.org>

David Naughton <naughton@umn.edu>

David E. Wheeler

dhoss: Devin Austin <dhoss@cpan.org>

dkubb: Dan Kubb <dan.kubb-cpan@onautopilot.com>

Drew Taylor

dwc: Daniel Westermann-Clark <danieltwc@cpan.org>

esskar: Sascha Kiefer

fireartist: Carl Franks <cfranks@cpan.org>

frew: Arthur Axel "fREW" Schmidt <frioux@gmail.com>

gabb: Danijel Milicevic

Gary Ashton Jones

Gavin Henry <ghenry@perl.me.uk>

Geoff Richards

groditi: Guillermo Roditi <groditi@gmail.com>

hobbs: Andrew Rodland <andrew@cleverdomain.org>

ilmari: Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>

jcamacho: Juan Camacho

jester: Jesse Sheidlower <jester@panix.com>

jhannah: Jay Hannah <jay@jays.net>

Jody Belka

Johan Lindstrom

jon: Jon Schutz <jjschutz@cpan.org>

Jonathan Rockway <jrockway@cpan.org>

Kieren Diment <kd@totaldatasolution.com>

konobi: Scott McWhirter <konobi@cpan.org>

marcus: Marcus Ramberg <mramberg@cpan.org>

miyagawa: Tatsuhiko Miyagawa <miyagawa@bulknews.net>

mgrimes: Mark Grimes <mgrimes@cpan.org>

mst: Matt S. Trout <mst@shadowcatsystems.co.uk>

mugwump: Sam Vilain

naughton: David Naughton

ningu: David Kamholz <dkamholz@cpan.org>

nothingmuch: Yuval Kogman <nothingmuch@woobling.org>

numa: Dan Sully <daniel@cpan.org>

obra: Jesse Vincent

Octavian Rasnita

omega: Andreas Marienborg

Oleg Kostyuk <cub.uanic@gmail.com>

phaylon: Robert Sedlacek <phaylon@dunkelheit.at>

rafl: Florian Ragwitz <rafl@debian.org>

random: Roland Lammel <lammel@cpan.org>

revmischa: Mischa Spiegelmock <revmischa@cpan.org>

Robert Sedlacek <rs@474.at>

rrwo: Robert Rothenberg <rrwo@cpan.org>

SpiceMan: Marcel Montes

sky: Arthur Bergman

szbalint: Balint Szilakszi <szbalint@cpan.org>

t0m: Tomas Doran <bobtfish@bobtfish.net>

Ulf Edvinsson

vanstyn: Henry Van Styn <vanstyn@cpan.org>

Viljo Marrandi <vilts@yahoo.com>

Will Hawes <info@whawes.co.uk>

willert: Sebastian Willert <willert@cpan.org>

wreis: Wallace Reis <wreis@cpan.org>

Yuval Kogman <nothingmuch@woobling.org>

rainboxx: Matthias Dietrich <perl@rainboxx.de>

dd070: Dhaval Dhanani <dhaval070@gmail.com>

Upasana <me@upasana.me>

John Napiorkowski (jnap) <jjnapiork@cpan.org>

=head1 COPYRIGHT

Copyright (c) 2005-2015, the above named PROJECT FOUNDER and CONTRIBUTORS.

=head1 LICENSE

This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

no Moose;

__PACKAGE__->meta->make_immutable;

1;
File size: 7537044
Re-highlighted ranges: 649465
Avg range size: 11.604996420130416
Min range size: 1
Max range size: 398865
10% of text has range <= 6
20% of text has range <= 9
30% of text has range <= 14
40% of text has range <= 21
50% of text has range <= 26
60% of text has range <= 36
70% of text has range <= 63
80% of text has range <= 466
90% of text has range <= 6631
----------
Range: (31056,43215) (12159)
=head1␣NAME

Benchmark␣-␣benchmark␣running␣times␣of␣Perl␣code

=head1␣SYNOPSIS

␣␣␣␣use␣Benchmark␣qw(:all)␣;

␣␣␣␣timethis␣($count,␣"code");

␣␣␣␣#␣Use␣Perl␣code␣in␣strings...
␣␣␣␣timethese($count,␣{
	'Name1'␣=>␣'...code1...',
	'Name2'␣=>␣'...code2...',
␣␣␣␣});

␣␣␣␣#␣...␣or␣use␣subroutine␣references.
␣␣␣␣timethese($count,␣{
	'Name1'␣=>␣sub␣{␣...code1...␣},
	'Name2'␣=>␣sub␣{␣...code2...␣},
␣␣␣␣});

␣␣␣␣#␣cmpthese␣can␣be␣used␣both␣ways␣as␣well
␣␣␣␣cmpthese($count,␣{
	'Name1'␣=>␣'...code1...',
	'Name2'␣=>␣'...code2...',
␣␣␣␣});

␣␣␣␣cmpthese($count,␣{
	'Name1'␣=>␣sub␣{␣...code1...␣},
	'Name2'␣=>␣sub␣{␣...code2...␣},
␣␣␣␣});

␣␣␣␣#␣...or␣in␣two␣stages
␣␣␣␣$results␣=␣timethese($count,␣
␣␣␣␣␣␣␣␣{
	␣␣␣␣'Name1'␣=>␣sub␣{␣...code1...␣},
	␣␣␣␣'Name2'␣=>␣sub␣{␣...code2...␣},
␣␣␣␣␣␣␣␣},
	'none'
␣␣␣␣);
␣␣␣␣cmpthese(␣$results␣)␣;

␣␣␣␣$t␣=␣timeit($count,␣'...other␣code...')
␣␣␣␣print␣"$count␣loops␣of␣other␣code␣took:",timestr($t),"\n";

␣␣␣␣$t␣=␣countit($time,␣'...other␣code...')
␣␣␣␣$count␣=␣$t->iters␣;
␣␣␣␣print␣"$count␣loops␣of␣other␣code␣took:",timestr($t),"\n";

␣␣␣␣#␣enable␣hires␣wallclock␣timing␣if␣possible
␣␣␣␣use␣Benchmark␣':hireswallclock';

=head1␣DESCRIPTION

The␣Benchmark␣module␣encapsulates␣a␣number␣of␣routines␣to␣help␣you
figure␣out␣how␣long␣it␣takes␣to␣execute␣some␣code.

timethis␣-␣run␣a␣chunk␣of␣code␣several␣times

timethese␣-␣run␣several␣chunks␣of␣code␣several␣times

cmpthese␣-␣print␣results␣of␣timethese␣as␣a␣comparison␣chart

timeit␣-␣run␣a␣chunk␣of␣code␣and␣see␣how␣long␣it␣goes

countit␣-␣see␣how␣many␣times␣a␣chunk␣of␣code␣runs␣in␣a␣given␣time


=head2␣Methods

=over␣10

=item␣new

Returns␣the␣current␣time.␣␣␣Example:

␣␣␣␣use␣Benchmark;
␣␣␣␣$t0␣=␣Benchmark->new;
␣␣␣␣#␣...␣your␣code␣here␣...
␣␣␣␣$t1␣=␣Benchmark->new;
␣␣␣␣$td␣=␣timediff($t1,␣$t0);
␣␣␣␣print␣"the␣code␣took:",timestr($td),"\n";

=item␣debug

Enables␣or␣disable␣debugging␣by␣setting␣the␣C<$Benchmark::Debug>␣flag:

␣␣␣␣Benchmark->debug(1);
␣␣␣␣$t␣=␣timeit(10,␣'␣5␣**␣$Global␣');
␣␣␣␣Benchmark->debug(0);

=item␣iters

Returns␣the␣number␣of␣iterations.

=back

=head2␣Standard␣Exports

The␣following␣routines␣will␣be␣exported␣into␣your␣namespace
if␣you␣use␣the␣Benchmark␣module:

=over␣10

=item␣timeit(COUNT,␣CODE)

Arguments:␣COUNT␣is␣the␣number␣of␣times␣to␣run␣the␣loop,␣and␣CODE␣is
the␣code␣to␣run.␣␣CODE␣may␣be␣either␣a␣code␣reference␣or␣a␣string␣to
be␣eval'd;␣either␣way␣it␣will␣be␣run␣in␣the␣caller's␣package.

Returns:␣a␣Benchmark␣object.

=item␣timethis␣(␣COUNT,␣CODE,␣[␣TITLE,␣[␣STYLE␣]]␣)

Time␣COUNT␣iterations␣of␣CODE.␣CODE␣may␣be␣a␣string␣to␣eval␣or␣a
code␣reference;␣either␣way␣the␣CODE␣will␣run␣in␣the␣caller's␣package.
Results␣will␣be␣printed␣to␣STDOUT␣as␣TITLE␣followed␣by␣the␣times.
TITLE␣defaults␣to␣"timethis␣COUNT"␣if␣none␣is␣provided.␣STYLE
determines␣the␣format␣of␣the␣output,␣as␣described␣for␣timestr()␣below.

The␣COUNT␣can␣be␣zero␣or␣negative:␣this␣means␣the␣I<minimum␣number␣of
CPU␣seconds>␣to␣run.␣␣A␣zero␣signifies␣the␣default␣of␣3␣seconds.␣␣For
example␣to␣run␣at␣least␣for␣10␣seconds:

	timethis(-10,␣$code)

or␣to␣run␣two␣pieces␣of␣code␣tests␣for␣at␣least␣3␣seconds:

	timethese(0,␣{␣test1␣=>␣'...',␣test2␣=>␣'...'})

CPU␣seconds␣is,␣in␣UNIX␣terms,␣the␣user␣time␣plus␣the␣system␣time␣of
the␣process␣itself,␣as␣opposed␣to␣the␣real␣(wallclock)␣time␣and␣the
time␣spent␣by␣the␣child␣processes.␣␣Less␣than␣0.1␣seconds␣is␣not
accepted␣(-0.01␣as␣the␣count,␣for␣example,␣will␣cause␣a␣fatal␣runtime
exception).

Note␣that␣the␣CPU␣seconds␣is␣the␣B<minimum>␣time:␣CPU␣scheduling␣and
other␣operating␣system␣factors␣may␣complicate␣the␣attempt␣so␣that␣a
little␣bit␣more␣time␣is␣spent.␣␣The␣benchmark␣output␣will,␣however,
also␣tell␣the␣number␣of␣C<$code>␣runs/second,␣which␣should␣be␣a␣more
interesting␣number␣than␣the␣actually␣spent␣seconds.

Returns␣a␣Benchmark␣object.

=item␣timethese␣(␣COUNT,␣CODEHASHREF,␣[␣STYLE␣]␣)

The␣CODEHASHREF␣is␣a␣reference␣to␣a␣hash␣containing␣names␣as␣keys
and␣either␣a␣string␣to␣eval␣or␣a␣code␣reference␣for␣each␣value.
For␣each␣(KEY,␣VALUE)␣pair␣in␣the␣CODEHASHREF,␣this␣routine␣will
call

	timethis(COUNT,␣VALUE,␣KEY,␣STYLE)

The␣routines␣are␣called␣in␣string␣comparison␣order␣of␣KEY.

The␣COUNT␣can␣be␣zero␣or␣negative,␣see␣timethis().

Returns␣a␣hash␣reference␣of␣Benchmark␣objects,␣keyed␣by␣name.

=item␣timediff␣(␣T1,␣T2␣)

Returns␣the␣difference␣between␣two␣Benchmark␣times␣as␣a␣Benchmark
object␣suitable␣for␣passing␣to␣timestr().

=item␣timestr␣(␣TIMEDIFF,␣[␣STYLE,␣[␣FORMAT␣]␣]␣)

Returns␣a␣string␣that␣formats␣the␣times␣in␣the␣TIMEDIFF␣object␣in
the␣requested␣STYLE.␣TIMEDIFF␣is␣expected␣to␣be␣a␣Benchmark␣object
similar␣to␣that␣returned␣by␣timediff().

STYLE␣can␣be␣any␣of␣'all',␣'none',␣'noc',␣'nop'␣or␣'auto'.␣'all'␣shows
each␣of␣the␣5␣times␣available␣('wallclock'␣time,␣user␣time,␣system␣time,
user␣time␣of␣children,␣and␣system␣time␣of␣children).␣'noc'␣shows␣all
except␣the␣two␣children␣times.␣'nop'␣shows␣only␣wallclock␣and␣the
two␣children␣times.␣'auto'␣(the␣default)␣will␣act␣as␣'all'␣unless
the␣children␣times␣are␣both␣zero,␣in␣which␣case␣it␣acts␣as␣'noc'.
'none'␣prevents␣output.

FORMAT␣is␣the␣L<printf(3)>-style␣format␣specifier␣(without␣the
leading␣'%')␣to␣use␣to␣print␣the␣times.␣It␣defaults␣to␣'5.2f'.

=back

=head2␣Optional␣Exports

The␣following␣routines␣will␣be␣exported␣into␣your␣namespace
if␣you␣specifically␣ask␣that␣they␣be␣imported:

=over␣10

=item␣clearcache␣(␣COUNT␣)

Clear␣the␣cached␣time␣for␣COUNT␣rounds␣of␣the␣null␣loop.

=item␣clearallcache␣(␣)

Clear␣all␣cached␣times.

=item␣cmpthese␣(␣COUNT,␣CODEHASHREF,␣[␣STYLE␣]␣)

=item␣cmpthese␣(␣RESULTSHASHREF,␣[␣STYLE␣]␣)

Optionally␣calls␣timethese(),␣then␣outputs␣comparison␣chart.␣␣This:

␣␣␣␣cmpthese(␣-1,␣{␣a␣=>␣"++\$i",␣b␣=>␣"\$i␣*=␣2"␣}␣)␣;

outputs␣a␣chart␣like:

␣␣␣␣␣␣␣␣␣␣␣Rate␣␣␣␣b␣␣␣␣a
␣␣␣␣b␣2831802/s␣␣␣--␣-61%
␣␣␣␣a␣7208959/s␣155%␣␣␣--

This␣chart␣is␣sorted␣from␣slowest␣to␣fastest,␣and␣shows␣the␣percent␣speed
difference␣between␣each␣pair␣of␣tests.

C<cmpthese>␣can␣also␣be␣passed␣the␣data␣structure␣that␣timethese()␣returns:

␣␣␣␣$results␣=␣timethese(␣-1,␣{␣a␣=>␣"++\$i",␣b␣=>␣"\$i␣*=␣2"␣}␣)␣;
␣␣␣␣cmpthese(␣$results␣);

in␣case␣you␣want␣to␣see␣both␣sets␣of␣results.
If␣the␣first␣argument␣is␣an␣unblessed␣hash␣reference,
that␣is␣RESULTSHASHREF;␣otherwise␣that␣is␣COUNT.

Returns␣a␣reference␣to␣an␣ARRAY␣of␣rows,␣each␣row␣is␣an␣ARRAY␣of␣cells␣from␣the
above␣chart,␣including␣labels.␣This:

␣␣␣␣my␣$rows␣=␣cmpthese(␣-1,␣{␣a␣=>␣'++$i',␣b␣=>␣'$i␣*=␣2'␣},␣"none"␣);

returns␣a␣data␣structure␣like:

␣␣␣␣[
␣␣␣␣␣␣␣␣[␣'',␣␣␣␣␣␣␣'Rate',␣␣␣'b',␣␣␣␣'a'␣],
␣␣␣␣␣␣␣␣[␣'b',␣'2885232/s',␣␣'--',␣'-59%'␣],
␣␣␣␣␣␣␣␣[␣'a',␣'7099126/s',␣'146%',␣␣'--'␣],
␣␣␣␣]

B<NOTE>:␣This␣result␣value␣differs␣from␣previous␣versions,␣which␣returned
the␣C<timethese()>␣result␣structure.␣␣If␣you␣want␣that,␣just␣use␣the␣two
statement␣C<timethese>...C<cmpthese>␣idiom␣shown␣above.

Incidently,␣note␣the␣variance␣in␣the␣result␣values␣between␣the␣two␣examples;
this␣is␣typical␣of␣benchmarking.␣␣If␣this␣were␣a␣real␣benchmark,␣you␣would
probably␣want␣to␣run␣a␣lot␣more␣iterations.

=item␣countit(TIME,␣CODE)

Arguments:␣TIME␣is␣the␣minimum␣length␣of␣time␣to␣run␣CODE␣for,␣and␣CODE␣is
the␣code␣to␣run.␣␣CODE␣may␣be␣either␣a␣code␣reference␣or␣a␣string␣to
be␣eval'd;␣either␣way␣it␣will␣be␣run␣in␣the␣caller's␣package.

TIME␣is␣I<not>␣negative.␣␣countit()␣will␣run␣the␣loop␣many␣times␣to
calculate␣the␣speed␣of␣CODE␣before␣running␣it␣for␣TIME.␣␣The␣actual
time␣run␣for␣will␣usually␣be␣greater␣than␣TIME␣due␣to␣system␣clock
resolution,␣so␣it's␣best␣to␣look␣at␣the␣number␣of␣iterations␣divided
by␣the␣times␣that␣you␣are␣concerned␣with,␣not␣just␣the␣iterations.

Returns:␣a␣Benchmark␣object.

=item␣disablecache␣(␣)

Disable␣caching␣of␣timings␣for␣the␣null␣loop.␣This␣will␣force␣Benchmark
to␣recalculate␣these␣timings␣for␣each␣new␣piece␣of␣code␣timed.

=item␣enablecache␣(␣)

Enable␣caching␣of␣timings␣for␣the␣null␣loop.␣The␣time␣taken␣for␣COUNT
rounds␣of␣the␣null␣loop␣will␣be␣calculated␣only␣once␣for␣each
different␣COUNT␣used.

=item␣timesum␣(␣T1,␣T2␣)

Returns␣the␣sum␣of␣two␣Benchmark␣times␣as␣a␣Benchmark␣object␣suitable
for␣passing␣to␣timestr().

=back

=head2␣:hireswallclock

If␣the␣Time::HiRes␣module␣has␣been␣installed,␣you␣can␣specify␣the
special␣tag␣C<:hireswallclock>␣for␣Benchmark␣(if␣Time::HiRes␣is␣not
available,␣the␣tag␣will␣be␣silently␣ignored).␣␣This␣tag␣will␣cause␣the
wallclock␣time␣to␣be␣measured␣in␣microseconds,␣instead␣of␣integer
seconds.␣␣Note␣though␣that␣the␣speed␣computations␣are␣still␣conducted
in␣CPU␣time,␣not␣wallclock␣time.

=head1␣NOTES

The␣data␣is␣stored␣as␣a␣list␣of␣values␣from␣the␣time␣and␣times
functions:

␣␣␣␣␣␣($real,␣$user,␣$system,␣$children_user,␣$children_system,␣$iters)

in␣seconds␣for␣the␣whole␣loop␣(not␣divided␣by␣the␣number␣of␣rounds).

The␣timing␣is␣done␣using␣time(3)␣and␣times(3).

Code␣is␣executed␣in␣the␣caller's␣package.

The␣time␣of␣the␣null␣loop␣(a␣loop␣with␣the␣same
number␣of␣rounds␣but␣empty␣loop␣body)␣is␣subtracted
from␣the␣time␣of␣the␣real␣loop.

The␣null␣loop␣times␣can␣be␣cached,␣the␣key␣being␣the
number␣of␣rounds.␣The␣caching␣can␣be␣controlled␣using
calls␣like␣these:

␣␣␣␣clearcache($key);
␣␣␣␣clearallcache();

␣␣␣␣disablecache();
␣␣␣␣enablecache();

Caching␣is␣off␣by␣default,␣as␣it␣can␣(usually␣slightly)␣decrease
accuracy␣and␣does␣not␣usually␣noticably␣affect␣runtimes.

=head1␣EXAMPLES

For␣example,

␣␣␣␣use␣Benchmark␣qw(␣cmpthese␣)␣;
␣␣␣␣$x␣=␣3;
␣␣␣␣cmpthese(␣-5,␣{
␣␣␣␣␣␣␣␣a␣=>␣sub{$x*$x},
␣␣␣␣␣␣␣␣b␣=>␣sub{$x**2},
␣␣␣␣}␣);

outputs␣something␣like␣this:

␣␣␣Benchmark:␣running␣a,␣b,␣each␣for␣at␣least␣5␣CPU␣seconds...
␣␣␣␣␣␣␣␣␣␣Rate␣␣␣␣b␣␣␣␣a
␣␣␣b␣1559428/s␣␣␣--␣-62%
␣␣␣a␣4152037/s␣166%␣␣␣--


while␣

␣␣␣␣use␣Benchmark␣qw(␣timethese␣cmpthese␣)␣;
␣␣␣␣$x␣=␣3;
␣␣␣␣$r␣=␣timethese(␣-5,␣{
␣␣␣␣␣␣␣␣a␣=>␣sub{$x*$x},
␣␣␣␣␣␣␣␣b␣=>␣sub{$x**2},
␣␣␣␣}␣);
␣␣␣␣cmpthese␣$r;

outputs␣something␣like␣this:

␣␣␣␣Benchmark:␣running␣a,␣b,␣each␣for␣at␣least␣5␣CPU␣seconds...
␣␣␣␣␣␣␣␣␣␣␣␣␣a:␣10␣wallclock␣secs␣(␣5.14␣usr␣+␣␣0.13␣sys␣=␣␣5.27␣CPU)␣@␣3835055.60/s␣(n=20210743)
␣␣␣␣␣␣␣␣␣␣␣␣␣b:␣␣5␣wallclock␣secs␣(␣5.41␣usr␣+␣␣0.00␣sys␣=␣␣5.41␣CPU)␣@␣1574944.92/s␣(n=8520452)
␣␣␣␣␣␣␣␣␣␣␣Rate␣␣␣␣b␣␣␣␣a
␣␣␣␣b␣1574945/s␣␣␣--␣-59%
␣␣␣␣a␣3835056/s␣144%␣␣␣--


=head1␣INHERITANCE

Benchmark␣inherits␣from␣no␣other␣class,␣except␣of␣course
for␣Exporter.

=head1␣CAVEATS

Comparing␣eval'd␣strings␣with␣code␣references␣will␣give␣you
inaccurate␣results:␣a␣code␣reference␣will␣show␣a␣slightly␣slower
execution␣time␣than␣the␣equivalent␣eval'd␣string.

The␣real␣time␣timing␣is␣done␣using␣time(2)␣and
the␣granularity␣is␣therefore␣only␣one␣second.

Short␣tests␣may␣produce␣negative␣figures␣because␣perl
can␣appear␣to␣take␣longer␣to␣execute␣the␣empty␣loop
than␣a␣short␣test;␣try:

␣␣␣␣timethis(100,'1');

The␣system␣time␣of␣the␣null␣loop␣might␣be␣slightly
more␣than␣the␣system␣time␣of␣the␣loop␣with␣the␣actual
code␣and␣therefore␣the␣difference␣might␣end␣up␣being␣E<lt>␣0.

=head1␣SEE␣ALSO

L<Devel::DProf>␣-␣a␣Perl␣code␣profiler

=head1␣AUTHORS

Jarkko␣Hietaniemi␣<F<jhi@iki.fi>>,␣Tim␣Bunce␣<F<Tim.Bunce@ig.co.uk>>

=head1␣MODIFICATION␣HISTORY

September␣8th,␣1994;␣by␣Tim␣Bunce.

March␣28th,␣1997;␣by␣Hugo␣van␣der␣Sanden:␣added␣support␣for␣code
references␣and␣the␣already␣documented␣'debug'␣method;␣revamped
documentation.

April␣04-07th,␣1997:␣by␣Jarkko␣Hietaniemi,␣added␣the␣run-for-some-time
functionality.

September,␣1999;␣by␣Barrie␣Slaymaker:␣math␣fixes␣and␣accuracy␣and␣
efficiency␣tweaks.␣␣Added␣cmpthese().␣␣A␣result␣is␣now␣returned␣from␣
timethese().␣␣Exposed␣countit()␣(was␣runfor()).

December,␣2001;␣by␣Nicholas␣Clark:␣make␣timestr()␣recognise␣the␣style␣'none'
and␣return␣an␣empty␣string.␣If␣cmpthese␣is␣calling␣timethese,␣make␣it␣pass␣the
style␣in.␣(so␣that␣'none'␣will␣suppress␣output).␣Make␣sub␣new␣dump␣its
debugging␣output␣to␣STDERR,␣to␣be␣consistent␣with␣everything␣else.
All␣bugs␣found␣while␣writing␣a␣regression␣test.

September,␣2002;␣by␣Jarkko␣Hietaniemi:␣add␣':hireswallclock'␣special␣tag.

February,␣2004;␣by␣Chia-liang␣Kao:␣make␣cmpthese␣and␣timestr␣use␣time
statistics␣for␣children␣instead␣of␣parent␣when␣the␣style␣is␣'nop'.

November,␣2007;␣by␣Christophe␣Grosjean:␣make␣cmpthese␣and␣timestr␣compute
time␣consistently␣with␣style␣argument,␣default␣is␣'all'␣not␣'noc'␣any␣more.

=cut
----------
Range: (454458,463180) (8722)
=head1␣NAME

IO::Handle␣-␣supply␣object␣methods␣for␣I/O␣handles

=head1␣SYNOPSIS

␣␣␣␣use␣IO::Handle;

␣␣␣␣$io␣=␣new␣IO::Handle;
␣␣␣␣if␣($io->fdopen(fileno(STDIN),"r"))␣{
␣␣␣␣␣␣␣␣print␣$io->getline;
␣␣␣␣␣␣␣␣$io->close;
␣␣␣␣}

␣␣␣␣$io␣=␣new␣IO::Handle;
␣␣␣␣if␣($io->fdopen(fileno(STDOUT),"w"))␣{
␣␣␣␣␣␣␣␣$io->print("Some␣text\n");
␣␣␣␣}

␣␣␣␣#␣setvbuf␣is␣not␣available␣by␣default␣on␣Perls␣5.8.0␣and␣later.
␣␣␣␣use␣IO::Handle␣'_IOLBF';
␣␣␣␣$io->setvbuf($buffer_var,␣_IOLBF,␣1024);

␣␣␣␣undef␣$io;␣␣␣␣␣␣␣#␣automatically␣closes␣the␣file␣if␣it's␣open

␣␣␣␣autoflush␣STDOUT␣1;

=head1␣DESCRIPTION

C<IO::Handle>␣is␣the␣base␣class␣for␣all␣other␣IO␣handle␣classes.␣It␣is
not␣intended␣that␣objects␣of␣C<IO::Handle>␣would␣be␣created␣directly,
but␣instead␣C<IO::Handle>␣is␣inherited␣from␣by␣several␣other␣classes
in␣the␣IO␣hierarchy.

If␣you␣are␣reading␣this␣documentation,␣looking␣for␣a␣replacement␣for
the␣C<FileHandle>␣package,␣then␣I␣suggest␣you␣read␣the␣documentation
for␣C<IO::File>␣too.

=head1␣CONSTRUCTOR

=over␣4

=item␣new␣()

Creates␣a␣new␣C<IO::Handle>␣object.

=item␣new_from_fd␣(␣FD,␣MODE␣)

Creates␣an␣C<IO::Handle>␣like␣C<new>␣does.
It␣requires␣two␣parameters,␣which␣are␣passed␣to␣the␣method␣C<fdopen>;
if␣the␣fdopen␣fails,␣the␣object␣is␣destroyed.␣Otherwise,␣it␣is␣returned
to␣the␣caller.

=back

=head1␣METHODS

See␣L<perlfunc>␣for␣complete␣descriptions␣of␣each␣of␣the␣following
supported␣C<IO::Handle>␣methods,␣which␣are␣just␣front␣ends␣for␣the
corresponding␣built-in␣functions:

␣␣␣␣$io->close
␣␣␣␣$io->eof
␣␣␣␣$io->fcntl(␣FUNCTION,␣SCALAR␣)
␣␣␣␣$io->fileno
␣␣␣␣$io->format_write(␣[FORMAT_NAME]␣)
␣␣␣␣$io->getc
␣␣␣␣$io->ioctl(␣FUNCTION,␣SCALAR␣)
␣␣␣␣$io->read␣(␣BUF,␣LEN,␣[OFFSET]␣)
␣␣␣␣$io->print␣(␣ARGS␣)
␣␣␣␣$io->printf␣(␣FMT,␣[ARGS]␣)
␣␣␣␣$io->say␣(␣ARGS␣)
␣␣␣␣$io->stat
␣␣␣␣$io->sysread␣(␣BUF,␣LEN,␣[OFFSET]␣)
␣␣␣␣$io->syswrite␣(␣BUF,␣[LEN,␣[OFFSET]]␣)
␣␣␣␣$io->truncate␣(␣LEN␣)

See␣L<perlvar>␣for␣complete␣descriptions␣of␣each␣of␣the␣following
supported␣C<IO::Handle>␣methods.␣␣All␣of␣them␣return␣the␣previous
value␣of␣the␣attribute␣and␣takes␣an␣optional␣single␣argument␣that␣when
given␣will␣set␣the␣value.␣␣If␣no␣argument␣is␣given␣the␣previous␣value
is␣unchanged␣(except␣for␣$io->autoflush␣will␣actually␣turn␣ON
autoflush␣by␣default).

␣␣␣␣$io->autoflush␣(␣[BOOL]␣)␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$|
␣␣␣␣$io->format_page_number(␣[NUM]␣)␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$%
␣␣␣␣$io->format_lines_per_page(␣[NUM]␣)␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$=
␣␣␣␣$io->format_lines_left(␣[NUM]␣)␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$-
␣␣␣␣$io->format_name(␣[STR]␣)␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$~
␣␣␣␣$io->format_top_name(␣[STR]␣)␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$^
␣␣␣␣$io->input_line_number(␣[NUM])␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$.

The␣following␣methods␣are␣not␣supported␣on␣a␣per-filehandle␣basis.

␣␣␣␣IO::Handle->format_line_break_characters(␣[STR]␣)␣$:
␣␣␣␣IO::Handle->format_formfeed(␣[STR])␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$^L
␣␣␣␣IO::Handle->output_field_separator(␣[STR]␣)␣␣␣␣␣␣␣$,
␣␣␣␣IO::Handle->output_record_separator(␣[STR]␣)␣␣␣␣␣␣$\

␣␣␣␣IO::Handle->input_record_separator(␣[STR]␣)␣␣␣␣␣␣␣$/

Furthermore,␣for␣doing␣normal␣I/O␣you␣might␣need␣these:

=over␣4

=item␣$io->fdopen␣(␣FD,␣MODE␣)

C<fdopen>␣is␣like␣an␣ordinary␣C<open>␣except␣that␣its␣first␣parameter
is␣not␣a␣filename␣but␣rather␣a␣file␣handle␣name,␣an␣IO::Handle␣object,
or␣a␣file␣descriptor␣number.␣␣(For␣the␣documentation␣of␣the␣C<open>
method,␣see␣L<IO::File>.)

=item␣$io->opened

Returns␣true␣if␣the␣object␣is␣currently␣a␣valid␣file␣descriptor,␣false
otherwise.

=item␣$io->getline

This␣works␣like␣<$io>␣described␣in␣L<perlop/"I/O␣Operators">
except␣that␣it's␣more␣readable␣and␣can␣be␣safely␣called␣in␣a
list␣context␣but␣still␣returns␣just␣one␣line.␣␣If␣used␣as␣the␣conditional
+within␣a␣C<while>␣or␣C-style␣C<for>␣loop,␣however,␣you␣will␣need␣to
+emulate␣the␣functionality␣of␣<$io>␣with␣C<<␣defined($_␣=␣$io->getline)␣>>.

=item␣$io->getlines

This␣works␣like␣<$io>␣when␣called␣in␣a␣list␣context␣to␣read␣all
the␣remaining␣lines␣in␣a␣file,␣except␣that␣it's␣more␣readable.
It␣will␣also␣croak()␣if␣accidentally␣called␣in␣a␣scalar␣context.

=item␣$io->ungetc␣(␣ORD␣)

Pushes␣a␣character␣with␣the␣given␣ordinal␣value␣back␣onto␣the␣given
handle's␣input␣stream.␣␣Only␣one␣character␣of␣pushback␣per␣handle␣is
guaranteed.

=item␣$io->write␣(␣BUF,␣LEN␣[,␣OFFSET␣]␣)

This␣C<write>␣is␣like␣C<write>␣found␣in␣C,␣that␣is␣it␣is␣the
opposite␣of␣read.␣The␣wrapper␣for␣the␣perl␣C<write>␣function␣is
called␣C<format_write>.

=item␣$io->error

Returns␣a␣true␣value␣if␣the␣given␣handle␣has␣experienced␣any␣errors
since␣it␣was␣opened␣or␣since␣the␣last␣call␣to␣C<clearerr>,␣or␣if␣the
handle␣is␣invalid.␣It␣only␣returns␣false␣for␣a␣valid␣handle␣with␣no
outstanding␣errors.

=item␣$io->clearerr

Clear␣the␣given␣handle's␣error␣indicator.␣Returns␣-1␣if␣the␣handle␣is
invalid,␣0␣otherwise.

=item␣$io->sync

C<sync>␣synchronizes␣a␣file's␣in-memory␣state␣␣with␣␣that␣␣on␣the
physical␣medium.␣C<sync>␣does␣not␣operate␣at␣the␣perlio␣api␣level,␣but
operates␣on␣the␣file␣descriptor␣(similar␣to␣sysread,␣sysseek␣and
systell).␣This␣means␣that␣any␣data␣held␣at␣the␣perlio␣api␣level␣will␣not
be␣synchronized.␣To␣synchronize␣data␣that␣is␣buffered␣at␣the␣perlio␣api
level␣you␣must␣use␣the␣flush␣method.␣C<sync>␣is␣not␣implemented␣on␣all
platforms.␣Returns␣"0␣but␣true"␣on␣success,␣C<undef>␣on␣error,␣C<undef>
for␣an␣invalid␣handle.␣See␣L<fsync(3c)>.

=item␣$io->flush

C<flush>␣causes␣perl␣to␣flush␣any␣buffered␣data␣at␣the␣perlio␣api␣level.
Any␣unread␣data␣in␣the␣buffer␣will␣be␣discarded,␣and␣any␣unwritten␣data
will␣be␣written␣to␣the␣underlying␣file␣descriptor.␣Returns␣"0␣but␣true"
on␣success,␣C<undef>␣on␣error.

=item␣$io->printflush␣(␣ARGS␣)

Turns␣on␣autoflush,␣print␣ARGS␣and␣then␣restores␣the␣autoflush␣status␣of␣the
C<IO::Handle>␣object.␣Returns␣the␣return␣value␣from␣print.

=item␣$io->blocking␣(␣[␣BOOL␣]␣)

If␣called␣with␣an␣argument␣C<blocking>␣will␣turn␣on␣non-blocking␣IO␣if
C<BOOL>␣is␣false,␣and␣turn␣it␣off␣if␣C<BOOL>␣is␣true.

C<blocking>␣will␣return␣the␣value␣of␣the␣previous␣setting,␣or␣the
current␣setting␣if␣C<BOOL>␣is␣not␣given.␣

If␣an␣error␣occurs␣C<blocking>␣will␣return␣undef␣and␣C<$!>␣will␣be␣set.

=back


If␣the␣C␣functions␣setbuf()␣and/or␣setvbuf()␣are␣available,␣then
C<IO::Handle::setbuf>␣and␣C<IO::Handle::setvbuf>␣set␣the␣buffering
policy␣for␣an␣IO::Handle.␣␣The␣calling␣sequences␣for␣the␣Perl␣functions
are␣the␣same␣as␣their␣C␣counterparts--including␣the␣constants␣C<_IOFBF>,
C<_IOLBF>,␣and␣C<_IONBF>␣for␣setvbuf()--except␣that␣the␣buffer␣parameter
specifies␣a␣scalar␣variable␣to␣use␣as␣a␣buffer.␣You␣should␣only
change␣the␣buffer␣before␣any␣I/O,␣or␣immediately␣after␣calling␣flush.

WARNING:␣The␣IO::Handle::setvbuf()␣is␣not␣available␣by␣default␣on
Perls␣5.8.0␣and␣later␣because␣setvbuf()␣is␣rather␣specific␣to␣using
the␣stdio␣library,␣while␣Perl␣prefers␣the␣new␣perlio␣subsystem␣instead.

WARNING:␣A␣variable␣used␣as␣a␣buffer␣by␣C<setbuf>␣or␣C<setvbuf>␣B<must␣not
be␣modified>␣in␣any␣way␣until␣the␣IO::Handle␣is␣closed␣or␣C<setbuf>␣or
C<setvbuf>␣is␣called␣again,␣or␣memory␣corruption␣may␣result!␣Remember␣that
the␣order␣of␣global␣destruction␣is␣undefined,␣so␣even␣if␣your␣buffer
variable␣remains␣in␣scope␣until␣program␣termination,␣it␣may␣be␣undefined
before␣the␣file␣IO::Handle␣is␣closed.␣Note␣that␣you␣need␣to␣import␣the
constants␣C<_IOFBF>,␣C<_IOLBF>,␣and␣C<_IONBF>␣explicitly.␣Like␣C,␣setbuf
returns␣nothing.␣setvbuf␣returns␣"0␣but␣true",␣on␣success,␣C<undef>␣on
failure.

Lastly,␣there␣is␣a␣special␣method␣for␣working␣under␣B<-T>␣and␣setuid/gid
scripts:

=over␣4

=item␣$io->untaint

Marks␣the␣object␣as␣taint-clean,␣and␣as␣such␣data␣read␣from␣it␣will␣also
be␣considered␣taint-clean.␣Note␣that␣this␣is␣a␣very␣trusting␣action␣to
take,␣and␣appropriate␣consideration␣for␣the␣data␣source␣and␣potential
vulnerability␣should␣be␣kept␣in␣mind.␣Returns␣0␣on␣success,␣-1␣if␣setting
the␣taint-clean␣flag␣failed.␣(eg␣invalid␣handle)

=back

=head1␣NOTE

An␣C<IO::Handle>␣object␣is␣a␣reference␣to␣a␣symbol/GLOB␣reference␣(see
the␣C<Symbol>␣package).␣␣Some␣modules␣that
inherit␣from␣C<IO::Handle>␣may␣want␣to␣keep␣object␣related␣variables
in␣the␣hash␣table␣part␣of␣the␣GLOB.␣In␣an␣attempt␣to␣prevent␣modules
trampling␣on␣each␣other␣I␣propose␣the␣that␣any␣such␣module␣should␣prefix
its␣variables␣with␣its␣own␣name␣separated␣by␣_'s.␣For␣example␣the␣IO::Socket
module␣keeps␣a␣C<timeout>␣variable␣in␣'io_socket_timeout'.

=head1␣SEE␣ALSO

L<perlfunc>,␣
L<perlop/"I/O␣Operators">,
L<IO::File>

=head1␣BUGS

Due␣to␣backwards␣compatibility,␣all␣filehandles␣resemble␣objects
of␣class␣C<IO::Handle>,␣or␣actually␣classes␣derived␣from␣that␣class.
They␣actually␣aren't.␣␣Which␣means␣you␣can't␣derive␣your␣own␣
class␣from␣C<IO::Handle>␣and␣inherit␣those␣methods.

=head1␣HISTORY

Derived␣from␣FileHandle.pm␣by␣Graham␣Barr␣E<lt>F<gbarr@pobox.com>E<gt>

=cut
----------
Range: (529367,548887) (19520)
=head1␣NAME

Devel::PPPort␣-␣Perl/Pollution/Portability

=head1␣SYNOPSIS

␣␣␣␣Devel::PPPort::WriteFile();␣␣␣#␣defaults␣to␣./ppport.h
␣␣␣␣Devel::PPPort::WriteFile('someheader.h');

=head1␣DESCRIPTION

Perl's␣API␣has␣changed␣over␣time,␣gaining␣new␣features,␣new␣functions,
increasing␣its␣flexibility,␣and␣reducing␣the␣impact␣on␣the␣C␣namespace
environment␣(reduced␣pollution).␣The␣header␣file␣written␣by␣this␣module,
typically␣F<ppport.h>,␣attempts␣to␣bring␣some␣of␣the␣newer␣Perl␣API
features␣to␣older␣versions␣of␣Perl,␣so␣that␣you␣can␣worry␣less␣about
keeping␣track␣of␣old␣releases,␣but␣users␣can␣still␣reap␣the␣benefit.

C<Devel::PPPort>␣contains␣a␣single␣function,␣called␣C<WriteFile>.␣Its
only␣purpose␣is␣to␣write␣the␣F<ppport.h>␣C␣header␣file.␣This␣file
contains␣a␣series␣of␣macros␣and,␣if␣explicitly␣requested,␣functions␣that
allow␣XS␣modules␣to␣be␣built␣using␣older␣versions␣of␣Perl.␣Currently,
Perl␣versions␣from␣5.003␣to␣5.10.0␣are␣supported.

This␣module␣is␣used␣by␣C<h2xs>␣to␣write␣the␣file␣F<ppport.h>.

=head2␣Why␣use␣ppport.h?

You␣should␣use␣F<ppport.h>␣in␣modern␣code␣so␣that␣your␣code␣will␣work
with␣the␣widest␣range␣of␣Perl␣interpreters␣possible,␣without␣significant
additional␣work.

You␣should␣attempt␣older␣code␣to␣fully␣use␣F<ppport.h>,␣because␣the
reduced␣pollution␣of␣newer␣Perl␣versions␣is␣an␣important␣thing.␣It's␣so
important␣that␣the␣old␣polluting␣ways␣of␣original␣Perl␣modules␣will␣not␣be
supported␣very␣far␣into␣the␣future,␣and␣your␣module␣will␣almost␣certainly
break!␣By␣adapting␣to␣it␣now,␣you'll␣gain␣compatibility␣and␣a␣sense␣of
having␣done␣the␣electronic␣ecology␣some␣good.

=head2␣How␣to␣use␣ppport.h

Don't␣direct␣the␣users␣of␣your␣module␣to␣download␣C<Devel::PPPort>.
They␣are␣most␣probably␣no␣XS␣writers.␣Also,␣don't␣make␣F<ppport.h>
optional.␣Rather,␣just␣take␣the␣most␣recent␣copy␣of␣F<ppport.h>␣that
you␣can␣find␣(e.g.␣by␣generating␣it␣with␣the␣latest␣C<Devel::PPPort>
release␣from␣CPAN),␣copy␣it␣into␣your␣project,␣adjust␣your␣project␣to
use␣it,␣and␣distribute␣the␣header␣along␣with␣your␣module.

=head2␣Running␣ppport.h

But␣F<ppport.h>␣is␣more␣than␣just␣a␣C␣header.␣It's␣also␣a␣Perl␣script
that␣can␣check␣your␣source␣code.␣It␣will␣suggest␣hints␣and␣portability
notes,␣and␣can␣even␣make␣suggestions␣on␣how␣to␣change␣your␣code.␣You
can␣run␣it␣like␣any␣other␣Perl␣program:

␣␣␣␣perl␣ppport.h␣[options]␣[files]

It␣also␣has␣embedded␣documentation,␣so␣you␣can␣use

␣␣␣␣perldoc␣ppport.h

to␣find␣out␣more␣about␣how␣to␣use␣it.

=head1␣FUNCTIONS

=head2␣WriteFile

C<WriteFile>␣takes␣one␣optional␣argument.␣When␣called␣with␣one
argument,␣it␣expects␣to␣be␣passed␣a␣filename.␣When␣called␣with
no␣arguments,␣it␣defaults␣to␣the␣filename␣F<ppport.h>.

The␣function␣returns␣a␣true␣value␣if␣the␣file␣was␣written␣successfully.
Otherwise␣it␣returns␣a␣false␣value.

=head1␣COMPATIBILITY

F<ppport.h>␣supports␣Perl␣versions␣from␣5.003␣to␣5.10.0
in␣threaded␣and␣non-threaded␣configurations.

=head2␣Provided␣Perl␣compatibility␣API

The␣header␣file␣written␣by␣this␣module,␣typically␣F<ppport.h>,␣provides
access␣to␣the␣following␣elements␣of␣the␣Perl␣API␣that␣is␣not␣available
in␣older␣Perl␣releases:

␣␣␣␣_aMY_CXT
␣␣␣␣_pMY_CXT
␣␣␣␣aMY_CXT
␣␣␣␣aMY_CXT_
␣␣␣␣aTHX
␣␣␣␣aTHX_
␣␣␣␣aTHXR
␣␣␣␣aTHXR_
␣␣␣␣AvFILLp
␣␣␣␣boolSV
␣␣␣␣call_argv
␣␣␣␣call_method
␣␣␣␣call_pv
␣␣␣␣call_sv
␣␣␣␣ckWARN
␣␣␣␣CopFILE
␣␣␣␣CopFILE_set
␣␣␣␣CopFILEAV
␣␣␣␣CopFILEGV
␣␣␣␣CopFILEGV_set
␣␣␣␣CopFILESV
␣␣␣␣CopSTASH
␣␣␣␣CopSTASH_eq
␣␣␣␣CopSTASH_set
␣␣␣␣CopSTASHPV
␣␣␣␣CopSTASHPV_set
␣␣␣␣CopyD
␣␣␣␣CPERLscope
␣␣␣␣dAX
␣␣␣␣dAXMARK
␣␣␣␣DEFSV
␣␣␣␣DEFSV_set
␣␣␣␣dITEMS
␣␣␣␣dMY_CXT
␣␣␣␣dMY_CXT_SV
␣␣␣␣dNOOP
␣␣␣␣dTHR
␣␣␣␣dTHX
␣␣␣␣dTHXa
␣␣␣␣dTHXoa
␣␣␣␣dTHXR
␣␣␣␣dUNDERBAR
␣␣␣␣dVAR
␣␣␣␣dXCPT
␣␣␣␣dXSTARG
␣␣␣␣END_EXTERN_C
␣␣␣␣ERRSV
␣␣␣␣eval_pv
␣␣␣␣eval_sv
␣␣␣␣EXTERN_C
␣␣␣␣G_METHOD
␣␣␣␣get_av
␣␣␣␣get_cv
␣␣␣␣get_hv
␣␣␣␣get_sv
␣␣␣␣grok_bin
␣␣␣␣grok_hex
␣␣␣␣grok_number
␣␣␣␣GROK_NUMERIC_RADIX
␣␣␣␣grok_numeric_radix
␣␣␣␣grok_oct
␣␣␣␣gv_fetchpvn_flags
␣␣␣␣gv_fetchpvs
␣␣␣␣gv_stashpvn
␣␣␣␣gv_stashpvs
␣␣␣␣GvSVn
␣␣␣␣hv_fetchs
␣␣␣␣hv_stores
␣␣␣␣HvNAME_get
␣␣␣␣HvNAMELEN_get
␣␣␣␣IN_LOCALE
␣␣␣␣IN_LOCALE_COMPILETIME
␣␣␣␣IN_LOCALE_RUNTIME
␣␣␣␣IN_PERL_COMPILETIME
␣␣␣␣INT2PTR
␣␣␣␣IS_NUMBER_GREATER_THAN_UV_MAX
␣␣␣␣IS_NUMBER_IN_UV
␣␣␣␣IS_NUMBER_INFINITY
␣␣␣␣IS_NUMBER_NAN
␣␣␣␣IS_NUMBER_NEG
␣␣␣␣IS_NUMBER_NOT_INT
␣␣␣␣isALNUMC
␣␣␣␣isASCII
␣␣␣␣isBLANK
␣␣␣␣isCNTRL
␣␣␣␣isGRAPH
␣␣␣␣isGV_with_GP
␣␣␣␣isPRINT
␣␣␣␣isPSXSPC
␣␣␣␣isPUNCT
␣␣␣␣isXDIGIT
␣␣␣␣IVdf
␣␣␣␣IVSIZE
␣␣␣␣IVTYPE
␣␣␣␣load_module
␣␣␣␣memEQ
␣␣␣␣memNE
␣␣␣␣MoveD
␣␣␣␣mPUSHi
␣␣␣␣mPUSHn
␣␣␣␣mPUSHp
␣␣␣␣mPUSHs
␣␣␣␣mPUSHu
␣␣␣␣mXPUSHi
␣␣␣␣mXPUSHn
␣␣␣␣mXPUSHp
␣␣␣␣mXPUSHs
␣␣␣␣mXPUSHu
␣␣␣␣MY_CXT
␣␣␣␣MY_CXT_CLONE
␣␣␣␣MY_CXT_INIT
␣␣␣␣my_snprintf
␣␣␣␣my_sprintf
␣␣␣␣my_strlcat
␣␣␣␣my_strlcpy
␣␣␣␣newCONSTSUB
␣␣␣␣newRV_inc
␣␣␣␣newRV_noinc
␣␣␣␣newSV_type
␣␣␣␣newSVpvn
␣␣␣␣newSVpvn_flags
␣␣␣␣newSVpvn_share
␣␣␣␣newSVpvn_utf8
␣␣␣␣newSVpvs
␣␣␣␣newSVpvs_flags
␣␣␣␣newSVuv
␣␣␣␣Newx
␣␣␣␣Newxc
␣␣␣␣Newxz
␣␣␣␣NOOP
␣␣␣␣NUM2PTR
␣␣␣␣NVef
␣␣␣␣NVff
␣␣␣␣NVgf
␣␣␣␣NVTYPE
␣␣␣␣packWARN
␣␣␣␣PERL_ABS
␣␣␣␣PERL_BCDVERSION
␣␣␣␣PERL_GCC_BRACE_GROUPS_FORBIDDEN
␣␣␣␣PERL_HASH
␣␣␣␣PERL_INT_MAX
␣␣␣␣PERL_INT_MIN
␣␣␣␣PERL_LONG_MAX
␣␣␣␣PERL_LONG_MIN
␣␣␣␣PERL_MAGIC_arylen
␣␣␣␣PERL_MAGIC_backref
␣␣␣␣PERL_MAGIC_bm
␣␣␣␣PERL_MAGIC_collxfrm
␣␣␣␣PERL_MAGIC_dbfile
␣␣␣␣PERL_MAGIC_dbline
␣␣␣␣PERL_MAGIC_defelem
␣␣␣␣PERL_MAGIC_env
␣␣␣␣PERL_MAGIC_envelem
␣␣␣␣PERL_MAGIC_ext
␣␣␣␣PERL_MAGIC_fm
␣␣␣␣PERL_MAGIC_glob
␣␣␣␣PERL_MAGIC_isa
␣␣␣␣PERL_MAGIC_isaelem
␣␣␣␣PERL_MAGIC_mutex
␣␣␣␣PERL_MAGIC_nkeys
␣␣␣␣PERL_MAGIC_overload
␣␣␣␣PERL_MAGIC_overload_elem
␣␣␣␣PERL_MAGIC_overload_table
␣␣␣␣PERL_MAGIC_pos
␣␣␣␣PERL_MAGIC_qr
␣␣␣␣PERL_MAGIC_regdata
␣␣␣␣PERL_MAGIC_regdatum
␣␣␣␣PERL_MAGIC_regex_global
␣␣␣␣PERL_MAGIC_shared
␣␣␣␣PERL_MAGIC_shared_scalar
␣␣␣␣PERL_MAGIC_sig
␣␣␣␣PERL_MAGIC_sigelem
␣␣␣␣PERL_MAGIC_substr
␣␣␣␣PERL_MAGIC_sv
␣␣␣␣PERL_MAGIC_taint
␣␣␣␣PERL_MAGIC_tied
␣␣␣␣PERL_MAGIC_tiedelem
␣␣␣␣PERL_MAGIC_tiedscalar
␣␣␣␣PERL_MAGIC_utf8
␣␣␣␣PERL_MAGIC_uvar
␣␣␣␣PERL_MAGIC_uvar_elem
␣␣␣␣PERL_MAGIC_vec
␣␣␣␣PERL_MAGIC_vstring
␣␣␣␣PERL_PV_ESCAPE_ALL
␣␣␣␣PERL_PV_ESCAPE_FIRSTCHAR
␣␣␣␣PERL_PV_ESCAPE_NOBACKSLASH
␣␣␣␣PERL_PV_ESCAPE_NOCLEAR
␣␣␣␣PERL_PV_ESCAPE_QUOTE
␣␣␣␣PERL_PV_ESCAPE_RE
␣␣␣␣PERL_PV_ESCAPE_UNI
␣␣␣␣PERL_PV_ESCAPE_UNI_DETECT
␣␣␣␣PERL_PV_PRETTY_DUMP
␣␣␣␣PERL_PV_PRETTY_ELLIPSES
␣␣␣␣PERL_PV_PRETTY_LTGT
␣␣␣␣PERL_PV_PRETTY_NOCLEAR
␣␣␣␣PERL_PV_PRETTY_QUOTE
␣␣␣␣PERL_PV_PRETTY_REGPROP
␣␣␣␣PERL_QUAD_MAX
␣␣␣␣PERL_QUAD_MIN
␣␣␣␣PERL_REVISION
␣␣␣␣PERL_SCAN_ALLOW_UNDERSCORES
␣␣␣␣PERL_SCAN_DISALLOW_PREFIX
␣␣␣␣PERL_SCAN_GREATER_THAN_UV_MAX
␣␣␣␣PERL_SCAN_SILENT_ILLDIGIT
␣␣␣␣PERL_SHORT_MAX
␣␣␣␣PERL_SHORT_MIN
␣␣␣␣PERL_SIGNALS_UNSAFE_FLAG
␣␣␣␣PERL_SUBVERSION
␣␣␣␣PERL_UCHAR_MAX
␣␣␣␣PERL_UCHAR_MIN
␣␣␣␣PERL_UINT_MAX
␣␣␣␣PERL_UINT_MIN
␣␣␣␣PERL_ULONG_MAX
␣␣␣␣PERL_ULONG_MIN
␣␣␣␣PERL_UNUSED_ARG
␣␣␣␣PERL_UNUSED_CONTEXT
␣␣␣␣PERL_UNUSED_DECL
␣␣␣␣PERL_UNUSED_VAR
␣␣␣␣PERL_UQUAD_MAX
␣␣␣␣PERL_UQUAD_MIN
␣␣␣␣PERL_USE_GCC_BRACE_GROUPS
␣␣␣␣PERL_USHORT_MAX
␣␣␣␣PERL_USHORT_MIN
␣␣␣␣PERL_VERSION
␣␣␣␣Perl_warner
␣␣␣␣Perl_warner_nocontext
␣␣␣␣PERLIO_FUNCS_CAST
␣␣␣␣PERLIO_FUNCS_DECL
␣␣␣␣PL_bufend
␣␣␣␣PL_bufptr
␣␣␣␣PL_compiling
␣␣␣␣PL_copline
␣␣␣␣PL_curcop
␣␣␣␣PL_curstash
␣␣␣␣PL_DBsignal
␣␣␣␣PL_DBsingle
␣␣␣␣PL_DBsub
␣␣␣␣PL_DBtrace
␣␣␣␣PL_debstash
␣␣␣␣PL_defgv
␣␣␣␣PL_diehook
␣␣␣␣PL_dirty
␣␣␣␣PL_dowarn
␣␣␣␣PL_errgv
␣␣␣␣PL_error_count
␣␣␣␣PL_expect
␣␣␣␣PL_hexdigit
␣␣␣␣PL_hints
␣␣␣␣PL_in_my
␣␣␣␣PL_in_my_stash
␣␣␣␣PL_laststatval
␣␣␣␣PL_lex_state
␣␣␣␣PL_lex_stuff
␣␣␣␣PL_linestr
␣␣␣␣PL_na
␣␣␣␣PL_no_modify
␣␣␣␣PL_parser
␣␣␣␣PL_perl_destruct_level
␣␣␣␣PL_perldb
␣␣␣␣PL_ppaddr
␣␣␣␣PL_rsfp
␣␣␣␣PL_rsfp_filters
␣␣␣␣PL_signals
␣␣␣␣PL_stack_base
␣␣␣␣PL_stack_sp
␣␣␣␣PL_statcache
␣␣␣␣PL_stdingv
␣␣␣␣PL_Sv
␣␣␣␣PL_sv_arenaroot
␣␣␣␣PL_sv_no
␣␣␣␣PL_sv_undef
␣␣␣␣PL_sv_yes
␣␣␣␣PL_tainted
␣␣␣␣PL_tainting
␣␣␣␣PL_tokenbuf
␣␣␣␣pMY_CXT
␣␣␣␣pMY_CXT_
␣␣␣␣Poison
␣␣␣␣PoisonFree
␣␣␣␣PoisonNew
␣␣␣␣PoisonWith
␣␣␣␣pTHX
␣␣␣␣pTHX_
␣␣␣␣PTR2IV
␣␣␣␣PTR2nat
␣␣␣␣PTR2NV
␣␣␣␣PTR2ul
␣␣␣␣PTR2UV
␣␣␣␣PTRV
␣␣␣␣PUSHmortal
␣␣␣␣PUSHu
␣␣␣␣pv_display
␣␣␣␣pv_escape
␣␣␣␣pv_pretty
␣␣␣␣SAVE_DEFSV
␣␣␣␣START_EXTERN_C
␣␣␣␣START_MY_CXT
␣␣␣␣STMT_END
␣␣␣␣STMT_START
␣␣␣␣STR_WITH_LEN
␣␣␣␣sv_2pv_flags
␣␣␣␣sv_2pv_nolen
␣␣␣␣sv_2pvbyte
␣␣␣␣sv_2pvbyte_nolen
␣␣␣␣sv_2uv
␣␣␣␣sv_catpv_mg
␣␣␣␣sv_catpvf_mg
␣␣␣␣sv_catpvf_mg_nocontext
␣␣␣␣sv_catpvn_mg
␣␣␣␣sv_catpvn_nomg
␣␣␣␣sv_catpvs
␣␣␣␣sv_catsv_mg
␣␣␣␣sv_catsv_nomg
␣␣␣␣SV_CONST_RETURN
␣␣␣␣SV_COW_DROP_PV
␣␣␣␣SV_COW_SHARED_HASH_KEYS
␣␣␣␣SV_GMAGIC
␣␣␣␣SV_HAS_TRAILING_NUL
␣␣␣␣SV_IMMEDIATE_UNREF
␣␣␣␣sv_magic_portable
␣␣␣␣SV_MUTABLE_RETURN
␣␣␣␣SV_NOSTEAL
␣␣␣␣sv_pvn_force_flags
␣␣␣␣sv_pvn_nomg
␣␣␣␣sv_setiv_mg
␣␣␣␣sv_setnv_mg
␣␣␣␣sv_setpv_mg
␣␣␣␣sv_setpvf_mg
␣␣␣␣sv_setpvf_mg_nocontext
␣␣␣␣sv_setpvn_mg
␣␣␣␣sv_setpvs
␣␣␣␣sv_setsv_mg
␣␣␣␣sv_setsv_nomg
␣␣␣␣sv_setuv
␣␣␣␣sv_setuv_mg
␣␣␣␣SV_SMAGIC
␣␣␣␣sv_usepvn_mg
␣␣␣␣SV_UTF8_NO_ENCODING
␣␣␣␣sv_uv
␣␣␣␣sv_vcatpvf
␣␣␣␣sv_vcatpvf_mg
␣␣␣␣sv_vsetpvf
␣␣␣␣sv_vsetpvf_mg
␣␣␣␣SVf
␣␣␣␣SVf_UTF8
␣␣␣␣SVfARG
␣␣␣␣SvGETMAGIC
␣␣␣␣SvIV_nomg
␣␣␣␣SvMAGIC_set
␣␣␣␣SvPV_const
␣␣␣␣SvPV_flags
␣␣␣␣SvPV_flags_const
␣␣␣␣SvPV_flags_const_nolen
␣␣␣␣SvPV_flags_mutable
␣␣␣␣SvPV_force
␣␣␣␣SvPV_force_flags
␣␣␣␣SvPV_force_flags_mutable
␣␣␣␣SvPV_force_flags_nolen
␣␣␣␣SvPV_force_mutable
␣␣␣␣SvPV_force_nolen
␣␣␣␣SvPV_force_nomg
␣␣␣␣SvPV_force_nomg_nolen
␣␣␣␣SvPV_mutable
␣␣␣␣SvPV_nolen
␣␣␣␣SvPV_nolen_const
␣␣␣␣SvPV_nomg
␣␣␣␣SvPV_nomg_const
␣␣␣␣SvPV_nomg_const_nolen
␣␣␣␣SvPV_renew
␣␣␣␣SvPVbyte
␣␣␣␣SvPVX_const
␣␣␣␣SvPVX_mutable
␣␣␣␣SvREFCNT_inc
␣␣␣␣SvREFCNT_inc_NN
␣␣␣␣SvREFCNT_inc_simple
␣␣␣␣SvREFCNT_inc_simple_NN
␣␣␣␣SvREFCNT_inc_simple_void
␣␣␣␣SvREFCNT_inc_simple_void_NN
␣␣␣␣SvREFCNT_inc_void
␣␣␣␣SvREFCNT_inc_void_NN
␣␣␣␣SvRV_set
␣␣␣␣SvSHARED_HASH
␣␣␣␣SvSTASH_set
␣␣␣␣SvUOK
␣␣␣␣SvUV
␣␣␣␣SvUV_nomg
␣␣␣␣SvUV_set
␣␣␣␣SvUVX
␣␣␣␣SvUVx
␣␣␣␣SvUVXx
␣␣␣␣SvVSTRING_mg
␣␣␣␣UNDERBAR
␣␣␣␣UTF8_MAXBYTES
␣␣␣␣UVof
␣␣␣␣UVSIZE
␣␣␣␣UVTYPE
␣␣␣␣UVuf
␣␣␣␣UVXf
␣␣␣␣UVxf
␣␣␣␣vload_module
␣␣␣␣vnewSVpvf
␣␣␣␣WARN_ALL
␣␣␣␣WARN_AMBIGUOUS
␣␣␣␣WARN_ASSERTIONS
␣␣␣␣WARN_BAREWORD
␣␣␣␣WARN_CLOSED
␣␣␣␣WARN_CLOSURE
␣␣␣␣WARN_DEBUGGING
␣␣␣␣WARN_DEPRECATED
␣␣␣␣WARN_DIGIT
␣␣␣␣WARN_EXEC
␣␣␣␣WARN_EXITING
␣␣␣␣WARN_GLOB
␣␣␣␣WARN_INPLACE
␣␣␣␣WARN_INTERNAL
␣␣␣␣WARN_IO
␣␣␣␣WARN_LAYER
␣␣␣␣WARN_MALLOC
␣␣␣␣WARN_MISC
␣␣␣␣WARN_NEWLINE
␣␣␣␣WARN_NUMERIC
␣␣␣␣WARN_ONCE
␣␣␣␣WARN_OVERFLOW
␣␣␣␣WARN_PACK
␣␣␣␣WARN_PARENTHESIS
␣␣␣␣WARN_PIPE
␣␣␣␣WARN_PORTABLE
␣␣␣␣WARN_PRECEDENCE
␣␣␣␣WARN_PRINTF
␣␣␣␣WARN_PROTOTYPE
␣␣␣␣WARN_QW
␣␣␣␣WARN_RECURSION
␣␣␣␣WARN_REDEFINE
␣␣␣␣WARN_REGEXP
␣␣␣␣WARN_RESERVED
␣␣␣␣WARN_SEMICOLON
␣␣␣␣WARN_SEVERE
␣␣␣␣WARN_SIGNAL
␣␣␣␣WARN_SUBSTR
␣␣␣␣WARN_SYNTAX
␣␣␣␣WARN_TAINT
␣␣␣␣WARN_THREADS
␣␣␣␣WARN_UNINITIALIZED
␣␣␣␣WARN_UNOPENED
␣␣␣␣WARN_UNPACK
␣␣␣␣WARN_UNTIE
␣␣␣␣WARN_UTF8
␣␣␣␣WARN_VOID
␣␣␣␣warner
␣␣␣␣XCPT_CATCH
␣␣␣␣XCPT_RETHROW
␣␣␣␣XCPT_TRY_END
␣␣␣␣XCPT_TRY_START
␣␣␣␣XPUSHmortal
␣␣␣␣XPUSHu
␣␣␣␣XSprePUSH
␣␣␣␣XSPROTO
␣␣␣␣XSRETURN
␣␣␣␣XSRETURN_UV
␣␣␣␣XST_mUV
␣␣␣␣ZeroD

=head2␣Perl␣API␣not␣supported␣by␣ppport.h

There␣is␣still␣a␣big␣part␣of␣the␣API␣not␣supported␣by␣F<ppport.h>.
Either␣because␣it␣doesn't␣make␣sense␣to␣back-port␣that␣part␣of␣the␣API,
or␣simply␣because␣it␣hasn't␣been␣implemented␣yet.␣Patches␣welcome!

Here's␣a␣list␣of␣the␣currently␣unsupported␣API,␣and␣also␣the␣version␣of
Perl␣below␣which␣it␣is␣unsupported:

=over␣4

=item␣perl␣5.11.0

␣␣HeUTF8
␣␣MULTICALL
␣␣PERL_SYS_TERM
␣␣POP_MULTICALL
␣␣PUSH_MULTICALL
␣␣SvOOK_offset
␣␣av_iter_p
␣␣croak_xs_usage
␣␣fetch_cop_label
␣␣gv_fetchmethod_flags
␣␣hv_assert
␣␣mro_get_from_name
␣␣mro_get_private_data
␣␣mro_register
␣␣mro_set_mro
␣␣mro_set_private_data
␣␣pad_sv
␣␣pregfree2
␣␣ref
␣␣save_adelete
␣␣save_helem_flags
␣␣save_padsv_and_mortalize
␣␣save_pushptr
␣␣stashpv_hvname_match
␣␣sv_insert_flags
␣␣sv_utf8_upgrade_flags_grow

=item␣perl␣5.10.0

␣␣hv_common
␣␣hv_common_key_len
␣␣sv_destroyable
␣␣sys_init
␣␣sys_init3
␣␣sys_term

=item␣perl␣5.9.5

␣␣Perl_signbit
␣␣SvRX
␣␣SvRXOK
␣␣av_create_and_push
␣␣av_create_and_unshift_one
␣␣get_cvn_flags
␣␣gv_fetchfile_flags
␣␣mro_get_linear_isa
␣␣mro_method_changed_in
␣␣my_dirfd
␣␣pregcomp
␣␣ptr_table_clear
␣␣ptr_table_fetch
␣␣ptr_table_free
␣␣ptr_table_new
␣␣ptr_table_split
␣␣ptr_table_store
␣␣re_compile
␣␣re_intuit_start
␣␣reg_named_buff_all
␣␣reg_named_buff_exists
␣␣reg_named_buff_fetch
␣␣reg_named_buff_firstkey
␣␣reg_named_buff_nextkey
␣␣reg_named_buff_scalar
␣␣regfree_internal
␣␣savesharedpvn
␣␣scan_vstring
␣␣upg_version

=item␣perl␣5.9.4

␣␣PerlIO_context_layers
␣␣gv_name_set
␣␣my_vsnprintf
␣␣newXS_flags
␣␣regclass_swash
␣␣sv_does
␣␣sv_usepvn_flags

=item␣perl␣5.9.3

␣␣av_arylen_p
␣␣ckwarn
␣␣ckwarn_d
␣␣csighandler
␣␣dMULTICALL
␣␣doref
␣␣gv_const_sv
␣␣hv_eiter_p
␣␣hv_eiter_set
␣␣hv_name_set
␣␣hv_placeholders_get
␣␣hv_placeholders_p
␣␣hv_placeholders_set
␣␣hv_riter_p
␣␣hv_riter_set
␣␣is_utf8_string_loclen
␣␣newGIVENOP
␣␣newSVhek
␣␣newSVpvs_share
␣␣newWHENOP
␣␣newWHILEOP
␣␣savepvs
␣␣sortsv_flags
␣␣vverify

=item␣perl␣5.9.2

␣␣SvPVbyte_force
␣␣find_rundefsvoffset
␣␣gv_fetchsv
␣␣op_refcnt_lock
␣␣op_refcnt_unlock
␣␣savesvpv
␣␣vnormal

=item␣perl␣5.9.1

␣␣hv_clear_placeholders
␣␣hv_scalar
␣␣scan_version
␣␣sv_2iv_flags
␣␣sv_2uv_flags

=item␣perl␣5.9.0

␣␣new_version
␣␣save_set_svflags
␣␣vcmp
␣␣vnumify
␣␣vstringify

=item␣perl␣5.8.3

␣␣SvIsCOW
␣␣SvIsCOW_shared_hash

=item␣perl␣5.8.1

␣␣SvVOK
␣␣doing_taint
␣␣find_runcv
␣␣is_utf8_string_loc
␣␣packlist
␣␣save_bool
␣␣savestack_grow_cnt
␣␣seed
␣␣sv_cat_decode
␣␣sv_compile_2op
␣␣sv_setpviv
␣␣sv_setpviv_mg
␣␣unpackstring

=item␣perl␣5.8.0

␣␣hv_iternext_flags
␣␣hv_store_flags
␣␣is_utf8_idcont
␣␣nothreadhook

=item␣perl␣5.7.3

␣␣PerlIO_clearerr
␣␣PerlIO_close
␣␣PerlIO_eof
␣␣PerlIO_error
␣␣PerlIO_fileno
␣␣PerlIO_fill
␣␣PerlIO_flush
␣␣PerlIO_get_base
␣␣PerlIO_get_bufsiz
␣␣PerlIO_get_cnt
␣␣PerlIO_get_ptr
␣␣PerlIO_read
␣␣PerlIO_seek
␣␣PerlIO_set_cnt
␣␣PerlIO_set_ptrcnt
␣␣PerlIO_setlinebuf
␣␣PerlIO_stderr
␣␣PerlIO_stdin
␣␣PerlIO_stdout
␣␣PerlIO_tell
␣␣PerlIO_unread
␣␣PerlIO_write
␣␣SvLOCK
␣␣SvSHARE
␣␣SvUNLOCK
␣␣atfork_lock
␣␣atfork_unlock
␣␣custom_op_desc
␣␣custom_op_name
␣␣deb
␣␣debstack
␣␣debstackptrs
␣␣gv_fetchmeth_autoload
␣␣ibcmp_utf8
␣␣my_fork
␣␣my_socketpair
␣␣pack_cat
␣␣perl_destruct
␣␣pv_uni_display
␣␣save_shared_pvref
␣␣savesharedpv
␣␣sortsv
␣␣sv_copypv
␣␣sv_magicext
␣␣sv_nolocking
␣␣sv_nosharing
␣␣sv_recode_to_utf8
␣␣sv_uni_display
␣␣to_uni_fold
␣␣to_uni_lower
␣␣to_uni_title
␣␣to_uni_upper
␣␣to_utf8_case
␣␣to_utf8_fold
␣␣to_utf8_lower
␣␣to_utf8_title
␣␣to_utf8_upper
␣␣unpack_str
␣␣uvchr_to_utf8_flags
␣␣uvuni_to_utf8_flags
␣␣vdeb

=item␣perl␣5.7.2

␣␣calloc
␣␣getcwd_sv
␣␣init_tm
␣␣malloc
␣␣mfree
␣␣mini_mktime
␣␣my_atof2
␣␣my_strftime
␣␣op_null
␣␣realloc
␣␣sv_catpvn_flags
␣␣sv_catsv_flags
␣␣sv_setsv_flags
␣␣sv_utf8_upgrade_flags
␣␣sv_utf8_upgrade_nomg
␣␣swash_fetch

=item␣perl␣5.7.1

␣␣POPpbytex
␣␣bytes_from_utf8
␣␣despatch_signals
␣␣do_openn
␣␣gv_handler
␣␣is_lvalue_sub
␣␣my_popen_list
␣␣save_mortalizesv
␣␣scan_num
␣␣sv_force_normal_flags
␣␣sv_setref_uv
␣␣sv_unref_flags
␣␣sv_utf8_upgrade
␣␣utf8_length
␣␣utf8_to_uvchr
␣␣utf8_to_uvuni
␣␣utf8n_to_uvuni
␣␣uvuni_to_utf8

=item␣perl␣5.6.1

␣␣SvGAMAGIC
␣␣apply_attrs_string
␣␣bytes_to_utf8
␣␣gv_efullname4
␣␣gv_fullname4
␣␣is_utf8_string
␣␣save_generic_pvref
␣␣utf16_to_utf8
␣␣utf16_to_utf8_reversed
␣␣utf8_to_bytes

=item␣perl␣5.6.0

␣␣PERL_SYS_INIT3
␣␣SvIOK_UV
␣␣SvIOK_notUV
␣␣SvIOK_only_UV
␣␣SvPOK_only_UTF8
␣␣SvPVbyte_nolen
␣␣SvPVbytex
␣␣SvPVbytex_force
␣␣SvPVutf8
␣␣SvPVutf8_force
␣␣SvPVutf8_nolen
␣␣SvPVutf8x
␣␣SvPVutf8x_force
␣␣SvUOK
␣␣SvUTF8
␣␣SvUTF8_off
␣␣SvUTF8_on
␣␣av_delete
␣␣av_exists
␣␣call_atexit
␣␣cast_i32
␣␣cast_iv
␣␣cast_ulong
␣␣cast_uv
␣␣do_gv_dump
␣␣do_gvgv_dump
␣␣do_hv_dump
␣␣do_magic_dump
␣␣do_op_dump
␣␣do_open9
␣␣do_pmop_dump
␣␣do_sv_dump
␣␣dump_all
␣␣dump_eval
␣␣dump_form
␣␣dump_indent
␣␣dump_packsubs
␣␣dump_sub
␣␣dump_vindent
␣␣get_context
␣␣get_ppaddr
␣␣gv_dump
␣␣init_i18nl10n
␣␣init_i18nl14n
␣␣is_uni_alnum
␣␣is_uni_alnum_lc
␣␣is_uni_alnumc
␣␣is_uni_alnumc_lc
␣␣is_uni_alpha
␣␣is_uni_alpha_lc
␣␣is_uni_ascii
␣␣is_uni_ascii_lc
␣␣is_uni_cntrl
␣␣is_uni_cntrl_lc
␣␣is_uni_digit
␣␣is_uni_digit_lc
␣␣is_uni_graph
␣␣is_uni_graph_lc
␣␣is_uni_idfirst
␣␣is_uni_idfirst_lc
␣␣is_uni_lower
␣␣is_uni_lower_lc
␣␣is_uni_print
␣␣is_uni_print_lc
␣␣is_uni_punct
␣␣is_uni_punct_lc
␣␣is_uni_space
␣␣is_uni_space_lc
␣␣is_uni_upper
␣␣is_uni_upper_lc
␣␣is_uni_xdigit
␣␣is_uni_xdigit_lc
␣␣is_utf8_alnum
␣␣is_utf8_alnumc
␣␣is_utf8_alpha
␣␣is_utf8_ascii
␣␣is_utf8_char
␣␣is_utf8_cntrl
␣␣is_utf8_digit
␣␣is_utf8_graph
␣␣is_utf8_idfirst
␣␣is_utf8_lower
␣␣is_utf8_mark
␣␣is_utf8_print
␣␣is_utf8_punct
␣␣is_utf8_space
␣␣is_utf8_upper
␣␣is_utf8_xdigit
␣␣magic_dump
␣␣mess
␣␣my_atof
␣␣my_fflush_all
␣␣newANONATTRSUB
␣␣newATTRSUB
␣␣newXS
␣␣newXSproto
␣␣new_collate
␣␣new_ctype
␣␣new_numeric
␣␣op_dump
␣␣perl_parse
␣␣pmop_dump
␣␣re_intuit_string
␣␣reginitcolors
␣␣require_pv
␣␣safesyscalloc
␣␣safesysfree
␣␣safesysmalloc
␣␣safesysrealloc
␣␣save_I8
␣␣save_alloc
␣␣save_destructor
␣␣save_destructor_x
␣␣save_re_context
␣␣save_vptr
␣␣scan_bin
␣␣set_context
␣␣set_numeric_local
␣␣set_numeric_radix
␣␣set_numeric_standard
␣␣str_to_version
␣␣sv_2pvutf8
␣␣sv_2pvutf8_nolen
␣␣sv_force_normal
␣␣sv_len_utf8
␣␣sv_pos_b2u
␣␣sv_pos_u2b
␣␣sv_pv
␣␣sv_pvbyte
␣␣sv_pvbyten
␣␣sv_pvbyten_force
␣␣sv_pvutf8
␣␣sv_pvutf8n
␣␣sv_pvutf8n_force
␣␣sv_rvweaken
␣␣sv_utf8_decode
␣␣sv_utf8_downgrade
␣␣sv_utf8_encode
␣␣swash_init
␣␣tmps_grow
␣␣to_uni_lower_lc
␣␣to_uni_title_lc
␣␣to_uni_upper_lc
␣␣utf8_distance
␣␣utf8_hop
␣␣vcroak
␣␣vform
␣␣vmess
␣␣vwarn
␣␣vwarner

=item␣perl␣5.005_03

␣␣POPpx
␣␣get_vtbl
␣␣save_generic_svref

=item␣perl␣5.005

␣␣PL_modglobal
␣␣cx_dump
␣␣debop
␣␣debprofdump
␣␣fbm_compile
␣␣fbm_instr
␣␣get_op_descs
␣␣get_op_names
␣␣init_stacks
␣␣mg_length
␣␣mg_size
␣␣newHVhv
␣␣new_stackinfo
␣␣regdump
␣␣regexec_flags
␣␣regnext
␣␣runops_debug
␣␣runops_standard
␣␣save_iv
␣␣screaminstr
␣␣sv_iv
␣␣sv_nv
␣␣sv_peek
␣␣sv_pvn
␣␣sv_pvn_nomg
␣␣sv_true

=item␣perl␣5.004_05

␣␣do_binmode
␣␣save_aelem
␣␣save_helem

=item␣perl␣5.004

␣␣GIMME_V
␣␣G_VOID
␣␣HEf_SVKEY
␣␣HeHASH
␣␣HeKEY
␣␣HeKLEN
␣␣HePV
␣␣HeSVKEY
␣␣HeSVKEY_force
␣␣HeSVKEY_set
␣␣HeVAL
␣␣SvSetMagicSV
␣␣SvSetMagicSV_nosteal
␣␣SvSetSV_nosteal
␣␣SvTAINTED
␣␣SvTAINTED_off
␣␣SvTAINTED_on
␣␣block_gimme
␣␣call_list
␣␣cv_const_sv
␣␣delimcpy
␣␣do_open
␣␣form
␣␣gv_autoload4
␣␣gv_efullname3
␣␣gv_fetchmethod_autoload
␣␣gv_fullname3
␣␣hv_delayfree_ent
␣␣hv_delete_ent
␣␣hv_exists_ent
␣␣hv_fetch_ent
␣␣hv_free_ent
␣␣hv_iterkeysv
␣␣hv_ksplit
␣␣hv_store_ent
␣␣ibcmp_locale
␣␣my_failure_exit
␣␣my_memcmp
␣␣my_pclose
␣␣my_popen
␣␣newSVpvf
␣␣rsignal
␣␣rsignal_state
␣␣save_I16
␣␣save_gp
␣␣share_hek
␣␣start_subparse
␣␣sv_catpvf
␣␣sv_catpvf_mg
␣␣sv_cmp_locale
␣␣sv_derived_from
␣␣sv_gets
␣␣sv_magic_portable
␣␣sv_setpvf
␣␣sv_setpvf_mg
␣␣sv_taint
␣␣sv_tainted
␣␣sv_untaint
␣␣sv_vcatpvf
␣␣sv_vcatpvf_mg
␣␣sv_vcatpvfn
␣␣sv_vsetpvf
␣␣sv_vsetpvf_mg
␣␣sv_vsetpvfn
␣␣unsharepvn
␣␣vnewSVpvf
␣␣warner

=back

=head1␣BUGS

If␣you␣find␣any␣bugs,␣C<Devel::PPPort>␣doesn't␣seem␣to␣build␣on␣your
system␣or␣any␣of␣its␣tests␣fail,␣please␣use␣the␣CPAN␣Request␣Tracker
at␣L<http://rt.cpan.org/>␣to␣create␣a␣ticket␣for␣the␣module.

=head1␣AUTHORS

=over␣2

=item␣*

Version␣1.x␣of␣Devel::PPPort␣was␣written␣by␣Kenneth␣Albanowski.

=item␣*

Version␣2.x␣was␣ported␣to␣the␣Perl␣core␣by␣Paul␣Marquess.

=item␣*

Version␣3.x␣was␣ported␣back␣to␣CPAN␣by␣Marcus␣Holland-Moritz.

=back

=head1␣COPYRIGHT

Version␣3.x,␣Copyright␣(C)␣2004-2009,␣Marcus␣Holland-Moritz.

Version␣2.x,␣Copyright␣(C)␣2001,␣Paul␣Marquess.

Version␣1.x,␣Copyright␣(C)␣1999,␣Kenneth␣Albanowski.

This␣program␣is␣free␣software;␣you␣can␣redistribute␣it␣and/or
modify␣it␣under␣the␣same␣terms␣as␣Perl␣itself.

=head1␣SEE␣ALSO

See␣L<h2xs>,␣L<ppport.h>.

=cut
----------
Range: (558162,565260) (7098)
=head1␣NAME

Socket,␣sockaddr_in,␣sockaddr_un,␣inet_aton,␣inet_ntoa,␣inet_pton,␣inet_ntop␣-␣load␣the␣C␣socket.h␣defines␣and␣structure␣manipulators␣

=head1␣SYNOPSIS

␣␣␣␣use␣Socket;

␣␣␣␣$proto␣=␣getprotobyname('udp');
␣␣␣␣socket(Socket_Handle,␣PF_INET,␣SOCK_DGRAM,␣$proto);
␣␣␣␣$iaddr␣=␣gethostbyname('hishost.com');
␣␣␣␣$port␣=␣getservbyname('time',␣'udp');
␣␣␣␣$sin␣=␣sockaddr_in($port,␣$iaddr);
␣␣␣␣send(Socket_Handle,␣0,␣0,␣$sin);

␣␣␣␣$proto␣=␣getprotobyname('tcp');
␣␣␣␣socket(Socket_Handle,␣PF_INET,␣SOCK_STREAM,␣$proto);
␣␣␣␣$port␣=␣getservbyname('smtp',␣'tcp');
␣␣␣␣$sin␣=␣sockaddr_in($port,inet_aton("127.1"));
␣␣␣␣$sin␣=␣sockaddr_in(7,inet_aton("localhost"));
␣␣␣␣$sin␣=␣sockaddr_in(7,INADDR_LOOPBACK);
␣␣␣␣connect(Socket_Handle,$sin);

␣␣␣␣($port,␣$iaddr)␣=␣sockaddr_in(getpeername(Socket_Handle));
␣␣␣␣$peer_host␣=␣gethostbyaddr($iaddr,␣AF_INET);
␣␣␣␣$peer_addr␣=␣inet_ntoa($iaddr);

␣␣␣␣$proto␣=␣getprotobyname('tcp');
␣␣␣␣socket(Socket_Handle,␣PF_UNIX,␣SOCK_STREAM,␣$proto);
␣␣␣␣unlink('/var/run/usock');
␣␣␣␣$sun␣=␣sockaddr_un('/var/run/usock');
␣␣␣␣connect(Socket_Handle,$sun);

=head1␣DESCRIPTION

This␣module␣is␣just␣a␣translation␣of␣the␣C␣F<socket.h>␣file.
Unlike␣the␣old␣mechanism␣of␣requiring␣a␣translated␣F<socket.ph>
file,␣this␣uses␣the␣B<h2xs>␣program␣(see␣the␣Perl␣source␣distribution)
and␣your␣native␣C␣compiler.␣␣This␣means␣that␣it␣has␣a␣
far␣more␣likely␣chance␣of␣getting␣the␣numbers␣right.␣␣This␣includes
all␣of␣the␣commonly␣used␣pound-defines␣like␣AF_INET,␣SOCK_STREAM,␣etc.

Also,␣some␣common␣socket␣"newline"␣constants␣are␣provided:␣the
constants␣C<CR>,␣C<LF>,␣and␣C<CRLF>,␣as␣well␣as␣C<$CR>,␣C<$LF>,␣and
C<$CRLF>,␣which␣map␣to␣C<\015>,␣C<\012>,␣and␣C<\015\012>.␣␣If␣you␣do
not␣want␣to␣use␣the␣literal␣characters␣in␣your␣programs,␣then␣use
the␣constants␣provided␣here.␣␣They␣are␣not␣exported␣by␣default,␣but␣can
be␣imported␣individually,␣and␣with␣the␣C<:crlf>␣export␣tag:

␣␣␣␣use␣Socket␣qw(:DEFAULT␣:crlf);

In␣addition,␣some␣structure␣manipulation␣functions␣are␣available:

=over␣4

=item␣inet_aton␣HOSTNAME

Takes␣a␣string␣giving␣the␣name␣of␣a␣host,␣and␣translates␣that␣to␣an
opaque␣string␣(if␣programming␣in␣C,␣struct␣in_addr).␣Takes␣arguments
of␣both␣the␣'rtfm.mit.edu'␣type␣and␣'18.181.0.24'.␣If␣the␣host␣name
cannot␣be␣resolved,␣returns␣undef.␣␣For␣multi-homed␣hosts␣(hosts␣with
more␣than␣one␣address),␣the␣first␣address␣found␣is␣returned.

For␣portability␣do␣not␣assume␣that␣the␣result␣of␣inet_aton()␣is␣32
bits␣wide,␣in␣other␣words,␣that␣it␣would␣contain␣only␣the␣IPv4␣address
in␣network␣order.

=item␣inet_ntoa␣IP_ADDRESS

Takes␣a␣string␣(an␣opaque␣string␣as␣returned␣by␣inet_aton(),
or␣a␣v-string␣representing␣the␣four␣octets␣of␣the␣IPv4␣address␣in
network␣order)␣and␣translates␣it␣into␣a␣string␣of␣the␣form␣'d.d.d.d'
where␣the␣'d's␣are␣numbers␣less␣than␣256␣(the␣normal␣human-readable
four␣dotted␣number␣notation␣for␣Internet␣addresses).

=item␣INADDR_ANY

Note:␣does␣not␣return␣a␣number,␣but␣a␣packed␣string.

Returns␣the␣4-byte␣wildcard␣ip␣address␣which␣specifies␣any
of␣the␣hosts␣ip␣addresses.␣␣(A␣particular␣machine␣can␣have
more␣than␣one␣ip␣address,␣each␣address␣corresponding␣to
a␣particular␣network␣interface.␣This␣wildcard␣address
allows␣you␣to␣bind␣to␣all␣of␣them␣simultaneously.)
Normally␣equivalent␣to␣inet_aton('0.0.0.0').

=item␣INADDR_BROADCAST

Note:␣does␣not␣return␣a␣number,␣but␣a␣packed␣string.

Returns␣the␣4-byte␣'this-lan'␣ip␣broadcast␣address.
This␣can␣be␣useful␣for␣some␣protocols␣to␣solicit␣information
from␣all␣servers␣on␣the␣same␣LAN␣cable.
Normally␣equivalent␣to␣inet_aton('255.255.255.255').

=item␣INADDR_LOOPBACK

Note␣-␣does␣not␣return␣a␣number.

Returns␣the␣4-byte␣loopback␣address.␣␣Normally␣equivalent
to␣inet_aton('localhost').

=item␣INADDR_NONE

Note␣-␣does␣not␣return␣a␣number.

Returns␣the␣4-byte␣'invalid'␣ip␣address.␣␣Normally␣equivalent
to␣inet_aton('255.255.255.255').

=item␣sockaddr_family␣SOCKADDR

Takes␣a␣sockaddr␣structure␣(as␣returned␣by␣pack_sockaddr_in(),
pack_sockaddr_un()␣or␣the␣perl␣builtin␣functions␣getsockname()␣and
getpeername())␣and␣returns␣the␣address␣family␣tag.␣␣It␣will␣match␣the
constant␣AF_INET␣for␣a␣sockaddr_in␣and␣AF_UNIX␣for␣a␣sockaddr_un.␣␣It
can␣be␣used␣to␣figure␣out␣what␣unpacker␣to␣use␣for␣a␣sockaddr␣of
unknown␣type.

=item␣sockaddr_in␣PORT,␣ADDRESS

=item␣sockaddr_in␣SOCKADDR_IN

In␣a␣list␣context,␣unpacks␣its␣SOCKADDR_IN␣argument␣and␣returns␣an␣array
consisting␣of␣(PORT,␣ADDRESS).␣␣In␣a␣scalar␣context,␣packs␣its␣(PORT,
ADDRESS)␣arguments␣as␣a␣SOCKADDR_IN␣and␣returns␣it.␣␣If␣this␣is␣confusing,
use␣pack_sockaddr_in()␣and␣unpack_sockaddr_in()␣explicitly.

=item␣pack_sockaddr_in␣PORT,␣IP_ADDRESS

Takes␣two␣arguments,␣a␣port␣number␣and␣an␣opaque␣string,␣IP_ADDRESS
(as␣returned␣by␣inet_aton(),␣or␣a␣v-string).␣␣Returns␣the␣sockaddr_in
structure␣with␣those␣arguments␣packed␣in␣with␣AF_INET␣filled␣in.␣␣For
Internet␣domain␣sockets,␣this␣structure␣is␣normally␣what␣you␣need␣for
the␣arguments␣in␣bind(),␣connect(),␣and␣send(),␣and␣is␣also␣returned
by␣getpeername(),␣getsockname()␣and␣recv().

=item␣unpack_sockaddr_in␣SOCKADDR_IN

Takes␣a␣sockaddr_in␣structure␣(as␣returned␣by␣pack_sockaddr_in())␣and
returns␣an␣array␣of␣two␣elements:␣the␣port␣and␣an␣opaque␣string
representing␣the␣IP␣address␣(you␣can␣use␣inet_ntoa()␣to␣convert␣the
address␣to␣the␣four-dotted␣numeric␣format).␣␣Will␣croak␣if␣the
structure␣does␣not␣have␣AF_INET␣in␣the␣right␣place.

=item␣sockaddr_un␣PATHNAME

=item␣sockaddr_un␣SOCKADDR_UN

In␣a␣list␣context,␣unpacks␣its␣SOCKADDR_UN␣argument␣and␣returns␣an␣array
consisting␣of␣(PATHNAME).␣␣In␣a␣scalar␣context,␣packs␣its␣PATHNAME
arguments␣as␣a␣SOCKADDR_UN␣and␣returns␣it.␣␣If␣this␣is␣confusing,␣use
pack_sockaddr_un()␣and␣unpack_sockaddr_un()␣explicitly.
These␣are␣only␣supported␣if␣your␣system␣has␣E<lt>F<sys/un.h>E<gt>.

=item␣pack_sockaddr_un␣PATH

Takes␣one␣argument,␣a␣pathname.␣Returns␣the␣sockaddr_un␣structure␣with
that␣path␣packed␣in␣with␣AF_UNIX␣filled␣in.␣For␣unix␣domain␣sockets,␣this
structure␣is␣normally␣what␣you␣need␣for␣the␣arguments␣in␣bind(),
connect(),␣and␣send(),␣and␣is␣also␣returned␣by␣getpeername(),
getsockname()␣and␣recv().

=item␣unpack_sockaddr_un␣SOCKADDR_UN

Takes␣a␣sockaddr_un␣structure␣(as␣returned␣by␣pack_sockaddr_un())
and␣returns␣the␣pathname.␣␣Will␣croak␣if␣the␣structure␣does␣not
have␣AF_UNIX␣in␣the␣right␣place.

=item␣inet_pton␣ADDRESS_FAMILY,␣HOSTNAME

Takes␣an␣address␣family,␣either␣AF_INET␣or␣AF_INET6,␣and␣a␣string␣giving
the␣name␣of␣a␣host,␣and␣translates␣that␣to␣an␣opaque␣string
(if␣programming␣in␣C,␣struct␣in_addr␣or␣struct␣in6_addr␣depending␣on␣the␣
address␣family␣passed␣in).␣␣The␣host␣string␣may␣be␣a␣string␣hostname,␣such
as␣'www.perl.org',␣or␣an␣IP␣address.␣␣If␣using␣an␣IP␣address,␣the␣type␣of
IP␣address␣must␣be␣consistant␣with␣the␣address␣family␣passed␣into␣the␣function.

This␣function␣is␣not␣exported␣by␣default.

=item␣inet_ntop␣ADDRESS_FAMILY,␣IP_ADDRESS

Takes␣an␣address␣family,␣either␣AF_INET␣or␣AF_INET6,␣and␣a␣string␣
(an␣opaque␣string␣as␣returned␣by␣inet_aton()␣or␣inet_pton())␣and
translates␣it␣to␣an␣IPv4␣or␣IPv6␣address␣string.

This␣function␣is␣not␣exported␣by␣default.

=back

=cut
----------
Range: (1231201,1239201) (8000)
=head1␣NAME␣

Memoize::Expire␣-␣Plug-in␣module␣for␣automatic␣expiration␣of␣memoized␣values

=head1␣SYNOPSIS

␣␣use␣Memoize;
␣␣use␣Memoize::Expire;
␣␣tie␣my␣%cache␣=>␣'Memoize::Expire',
	␣␣	␣␣␣␣␣LIFETIME␣=>␣$lifetime,␣␣␣␣#␣In␣seconds
		␣␣␣␣␣NUM_USES␣=>␣$n_uses;

␣␣memoize␣'function',␣SCALAR_CACHE␣=>␣[HASH␣=>␣\%cache␣];

=head1␣DESCRIPTION

Memoize::Expire␣is␣a␣plug-in␣module␣for␣Memoize.␣␣It␣allows␣the␣cached
values␣for␣memoized␣functions␣to␣expire␣automatically.␣␣This␣manual
assumes␣you␣are␣already␣familiar␣with␣the␣Memoize␣module.␣␣If␣not,␣you
should␣study␣that␣manual␣carefully␣first,␣paying␣particular␣attention
to␣the␣HASH␣feature.

Memoize::Expire␣is␣a␣layer␣of␣software␣that␣you␣can␣insert␣in␣between
Memoize␣itself␣and␣whatever␣underlying␣package␣implements␣the␣cache.
The␣layer␣presents␣a␣hash␣variable␣whose␣values␣expire␣whenever␣they
get␣too␣old,␣have␣been␣used␣too␣often,␣or␣both.␣You␣tell␣C<Memoize>␣to
use␣this␣forgetful␣hash␣as␣its␣cache␣instead␣of␣the␣default,␣which␣is
an␣ordinary␣hash.

To␣specify␣a␣real-time␣timeout,␣supply␣the␣C<LIFETIME>␣option␣with␣a
numeric␣value.␣␣Cached␣data␣will␣expire␣after␣this␣many␣seconds,␣and
will␣be␣looked␣up␣afresh␣when␣it␣expires.␣␣When␣a␣data␣item␣is␣looked
up␣afresh,␣its␣lifetime␣is␣reset.

If␣you␣specify␣C<NUM_USES>␣with␣an␣argument␣of␣I<n>,␣then␣each␣cached
data␣item␣will␣be␣discarded␣and␣looked␣up␣afresh␣after␣the␣I<n>th␣time
you␣access␣it.␣␣When␣a␣data␣item␣is␣looked␣up␣afresh,␣its␣number␣of
uses␣is␣reset.

If␣you␣specify␣both␣arguments,␣data␣will␣be␣discarded␣from␣the␣cache
when␣either␣expiration␣condition␣holds.

Memoize::Expire␣uses␣a␣real␣hash␣internally␣to␣store␣the␣cached␣data.
You␣can␣use␣the␣C<HASH>␣option␣to␣Memoize::Expire␣to␣supply␣a␣tied
hash␣in␣place␣of␣the␣ordinary␣hash␣that␣Memoize::Expire␣will␣normally
use.␣␣You␣can␣use␣this␣feature␣to␣add␣Memoize::Expire␣as␣a␣layer␣in
between␣a␣persistent␣disk␣hash␣and␣Memoize.␣␣If␣you␣do␣this,␣you␣get␣a
persistent␣disk␣cache␣whose␣entries␣expire␣automatically.␣␣For
example:

␣␣#␣␣␣Memoize
␣␣#␣␣␣␣␣␣|
␣␣#␣␣␣Memoize::Expire␣␣enforces␣data␣expiration␣policy
␣␣#␣␣␣␣␣␣|
␣␣#␣␣␣DB_File␣␣implements␣persistence␣of␣data␣in␣a␣disk␣file
␣␣#␣␣␣␣␣␣|
␣␣#␣␣␣Disk␣file

␣␣use␣Memoize;
␣␣use␣Memoize::Expire;
␣␣use␣DB_File;

␣␣#␣Set␣up␣persistence
␣␣tie␣my␣%disk_cache␣=>␣'DB_File',␣$filename,␣O_CREAT|O_RDWR,␣0666];

␣␣#␣Set␣up␣expiration␣policy,␣supplying␣persistent␣hash␣as␣a␣target
␣␣tie␣my␣%cache␣=>␣'Memoize::Expire',␣
	␣␣	␣␣␣␣␣LIFETIME␣=>␣$lifetime,␣␣␣␣#␣In␣seconds
		␣␣␣␣␣NUM_USES␣=>␣$n_uses,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣HASH␣=>␣\%disk_cache;␣

␣␣#␣Set␣up␣memoization,␣supplying␣expiring␣persistent␣hash␣for␣cache
␣␣memoize␣'function',␣SCALAR_CACHE␣=>␣[␣HASH␣=>␣\%cache␣];

=head1␣INTERFACE

There␣is␣nothing␣special␣about␣Memoize::Expire.␣␣It␣is␣just␣an
example.␣␣If␣you␣don't␣like␣the␣policy␣that␣it␣implements,␣you␣are
free␣to␣write␣your␣own␣expiration␣policy␣module␣that␣implements
whatever␣policy␣you␣desire.␣␣Here␣is␣how␣to␣do␣that.␣␣Let␣us␣suppose
that␣your␣module␣will␣be␣named␣MyExpirePolicy.

Short␣summary:␣You␣need␣to␣create␣a␣package␣that␣defines␣four␣methods:

=over␣4

=item␣
TIEHASH

Construct␣and␣return␣cache␣object.

=item␣
EXISTS

Given␣a␣function␣argument,␣is␣the␣corresponding␣function␣value␣in␣the
cache,␣and␣if␣so,␣is␣it␣fresh␣enough␣to␣use?

=item
FETCH

Given␣a␣function␣argument,␣look␣up␣the␣corresponding␣function␣value␣in
the␣cache␣and␣return␣it.

=item␣
STORE

Given␣a␣function␣argument␣and␣the␣corresponding␣function␣value,␣store
them␣into␣the␣cache.

=item
CLEAR

(Optional.)␣␣Flush␣the␣cache␣completely.

=back

The␣user␣who␣wants␣the␣memoization␣cache␣to␣be␣expired␣according␣to
your␣policy␣will␣say␣so␣by␣writing

␣␣tie␣my␣%cache␣=>␣'MyExpirePolicy',␣args...;
␣␣memoize␣'function',␣SCALAR_CACHE␣=>␣[HASH␣=>␣\%cache];

This␣will␣invoke␣C<<␣MyExpirePolicy->TIEHASH(args)␣>>.
MyExpirePolicy::TIEHASH␣should␣do␣whatever␣is␣appropriate␣to␣set␣up
the␣cache,␣and␣it␣should␣return␣the␣cache␣object␣to␣the␣caller.

For␣example,␣MyExpirePolicy::TIEHASH␣might␣create␣an␣object␣that
contains␣a␣regular␣Perl␣hash␣(which␣it␣will␣to␣store␣the␣cached
values)␣and␣some␣extra␣information␣about␣the␣arguments␣and␣how␣old␣the
data␣is␣and␣things␣like␣that.␣␣Let␣us␣call␣this␣object␣`C'.

When␣Memoize␣needs␣to␣check␣to␣see␣if␣an␣entry␣is␣in␣the␣cache
already,␣it␣will␣invoke␣C<<␣C->EXISTS(key)␣>>.␣␣C<key>␣is␣the␣normalized
function␣argument.␣␣MyExpirePolicy::EXISTS␣should␣return␣0␣if␣the␣key
is␣not␣in␣the␣cache,␣or␣if␣it␣has␣expired,␣and␣1␣if␣an␣unexpired␣value
is␣in␣the␣cache.␣␣It␣should␣I<not>␣return␣C<undef>,␣because␣there␣is␣a
bug␣in␣some␣versions␣of␣Perl␣that␣will␣cause␣a␣spurious␣FETCH␣if␣the
EXISTS␣method␣returns␣C<undef>.

If␣your␣EXISTS␣function␣returns␣true,␣Memoize␣will␣try␣to␣fetch␣the
cached␣value␣by␣invoking␣C<<␣C->FETCH(key)␣>>.␣␣MyExpirePolicy::FETCH␣should
return␣the␣cached␣value.␣␣Otherwise,␣Memoize␣will␣call␣the␣memoized
function␣to␣compute␣the␣appropriate␣value,␣and␣will␣store␣it␣into␣the
cache␣by␣calling␣C<<␣C->STORE(key,␣value)␣>>.

Here␣is␣a␣very␣brief␣example␣of␣a␣policy␣module␣that␣expires␣each
cache␣item␣after␣ten␣seconds.

	package␣Memoize::TenSecondExpire;

	sub␣TIEHASH␣{
	␣␣my␣($package,␣%args)␣=␣@_;
␣␣␣␣␣␣␣␣␣␣my␣$cache␣=␣$args{HASH}␣||␣{};
	␣␣bless␣$cache␣=>␣$package;
	}

	sub␣EXISTS␣{
	␣␣my␣($cache,␣$key)␣=␣@_;
	␣␣if␣(exists␣$cache->{$key}␣&&␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$cache->{$key}{EXPIRE_TIME}␣>␣time)␣{
	␣␣␣␣return␣1
	␣␣}␣else␣{
	␣␣␣␣return␣0;␣␣#␣Do␣NOT␣return␣`undef'␣here.
	␣␣}
	}

	sub␣FETCH␣{
	␣␣my␣($cache,␣$key)␣=␣@_;
	␣␣return␣$cache->{$key}{VALUE};
	}

	sub␣STORE␣{
	␣␣my␣($cache,␣$key,␣$newvalue)␣=␣@_;
	␣␣$cache->{$key}{VALUE}␣=␣$newvalue;
	␣␣$cache->{$key}{EXPIRE_TIME}␣=␣time␣+␣10;
	}

To␣use␣this␣expiration␣policy,␣the␣user␣would␣say

	use␣Memoize;
␣␣␣␣␣␣␣␣tie␣my␣%cache10sec␣=>␣'Memoize::TenSecondExpire';
	memoize␣'function',␣SCALAR_CACHE␣=>␣[HASH␣=>␣\%cache10sec];

Memoize␣would␣then␣call␣C<function>␣whenever␣a␣cached␣value␣was
entirely␣absent␣or␣was␣older␣than␣ten␣seconds.

You␣should␣always␣support␣a␣C<HASH>␣argument␣to␣C<TIEHASH>␣that␣ties
the␣underlying␣cache␣so␣that␣the␣user␣can␣specify␣that␣the␣cache␣is
also␣persistent␣or␣that␣it␣has␣some␣other␣interesting␣semantics.␣␣The
example␣above␣demonstrates␣how␣to␣do␣this,␣as␣does␣C<Memoize::Expire>.

=head1␣ALTERNATIVES

Brent␣Powers␣has␣a␣C<Memoize::ExpireLRU>␣module␣that␣was␣designed␣to
work␣with␣Memoize␣and␣provides␣expiration␣of␣least-recently-used␣data.
The␣cache␣is␣held␣at␣a␣fixed␣number␣of␣entries,␣and␣when␣new␣data
comes␣in,␣the␣least-recently␣used␣data␣is␣expired.␣␣See
L<http://search.cpan.org/search?mode=module&query=ExpireLRU>.

Joshua␣Chamas's␣Tie::Cache␣module␣may␣be␣useful␣as␣an␣expiration
manager.␣␣(If␣you␣try␣this,␣let␣me␣know␣how␣it␣works␣out.)

If␣you␣develop␣any␣useful␣expiration␣managers␣that␣you␣think␣should␣be
distributed␣with␣Memoize,␣please␣let␣me␣know.

=head1␣CAVEATS

This␣module␣is␣experimental,␣and␣may␣contain␣bugs.␣␣Please␣report␣bugs
to␣the␣address␣below.

Number-of-uses␣is␣stored␣as␣a␣16-bit␣unsigned␣integer,␣so␣can't␣exceed
65535.

Because␣of␣clock␣granularity,␣expiration␣times␣may␣occur␣up␣to␣one
second␣sooner␣than␣you␣expect.␣␣For␣example,␣suppose␣you␣store␣a␣value
with␣a␣lifetime␣of␣ten␣seconds,␣and␣you␣store␣it␣at␣12:00:00.998␣on␣a
certain␣day.␣␣Memoize␣will␣look␣at␣the␣clock␣and␣see␣12:00:00.␣␣Then
9.01␣seconds␣later,␣at␣12:00:10.008␣you␣try␣to␣read␣it␣back.␣␣Memoize
will␣look␣at␣the␣clock␣and␣see␣12:00:10␣and␣conclude␣that␣the␣value
has␣expired.␣␣This␣will␣probably␣not␣occur␣if␣you␣have
C<Time::HiRes>␣installed.

=head1␣AUTHOR

Mark-Jason␣Dominus␣(mjd-perl-memoize+@plover.com)

Mike␣Cariaso␣provided␣valuable␣insight␣into␣the␣best␣way␣to␣solve␣this
problem.

=head1␣SEE␣ALSO

perl(1)

The␣Memoize␣man␣page.

http://www.plover.com/~mjd/perl/Memoize/␣␣(for␣news␣and␣updates)

I␣maintain␣a␣mailing␣list␣on␣which␣I␣occasionally␣announce␣new
versions␣of␣Memoize.␣␣The␣list␣is␣for␣announcements␣only,␣not
discussion.␣␣To␣join,␣send␣an␣empty␣message␣to
mjd-perl-memoize-request@Plover.com.

=cut
----------
Range: (1569430,1579926) (10496)
=head1␣NAME

B<CGI::Carp>␣-␣CGI␣routines␣for␣writing␣to␣the␣HTTPD␣(or␣other)␣error␣log

=head1␣SYNOPSIS

␣␣␣␣use␣CGI::Carp;

␣␣␣␣croak␣"We're␣outta␣here!";
␣␣␣␣confess␣"It␣was␣my␣fault:␣$!";
␣␣␣␣carp␣"It␣was␣your␣fault!";␣␣␣
␣␣␣␣warn␣"I'm␣confused";
␣␣␣␣die␣␣"I'm␣dying.\n";

␣␣␣␣use␣CGI::Carp␣qw(cluck);
␣␣␣␣cluck␣"I␣wouldn't␣do␣that␣if␣I␣were␣you";

␣␣␣␣use␣CGI::Carp␣qw(fatalsToBrowser);
␣␣␣␣die␣"Fatal␣error␣messages␣are␣now␣sent␣to␣browser";

=head1␣DESCRIPTION

CGI␣scripts␣have␣a␣nasty␣habit␣of␣leaving␣warning␣messages␣in␣the␣error
logs␣that␣are␣neither␣time␣stamped␣nor␣fully␣identified.␣␣Tracking␣down
the␣script␣that␣caused␣the␣error␣is␣a␣pain.␣␣This␣fixes␣that.␣␣Replace
the␣usual

␣␣␣␣use␣Carp;

with

␣␣␣␣use␣CGI::Carp

And␣the␣standard␣warn(),␣die␣(),␣croak(),␣confess()␣and␣carp()␣calls
will␣automagically␣be␣replaced␣with␣functions␣that␣write␣out␣nicely
time-stamped␣messages␣to␣the␣HTTP␣server␣error␣log.

For␣example:

␣␣␣[Fri␣Nov␣17␣21:40:43␣1995]␣test.pl:␣I'm␣confused␣at␣test.pl␣line␣3.
␣␣␣[Fri␣Nov␣17␣21:40:43␣1995]␣test.pl:␣Got␣an␣error␣message:␣Permission␣denied.
␣␣␣[Fri␣Nov␣17␣21:40:43␣1995]␣test.pl:␣I'm␣dying.

=head1␣REDIRECTING␣ERROR␣MESSAGES

By␣default,␣error␣messages␣are␣sent␣to␣STDERR.␣␣Most␣HTTPD␣servers
direct␣STDERR␣to␣the␣server's␣error␣log.␣␣Some␣applications␣may␣wish
to␣keep␣private␣error␣logs,␣distinct␣from␣the␣server's␣error␣log,␣or
they␣may␣wish␣to␣direct␣error␣messages␣to␣STDOUT␣so␣that␣the␣browser
will␣receive␣them.

The␣C<carpout()>␣function␣is␣provided␣for␣this␣purpose.␣␣Since
carpout()␣is␣not␣exported␣by␣default,␣you␣must␣import␣it␣explicitly␣by
saying

␣␣␣use␣CGI::Carp␣qw(carpout);

The␣carpout()␣function␣requires␣one␣argument,␣which␣should␣be␣a
reference␣to␣an␣open␣filehandle␣for␣writing␣errors.␣␣It␣should␣be
called␣in␣a␣C<BEGIN>␣block␣at␣the␣top␣of␣the␣CGI␣application␣so␣that
compiler␣errors␣will␣be␣caught.␣␣Example:

␣␣␣BEGIN␣{
␣␣␣␣␣use␣CGI::Carp␣qw(carpout);
␣␣␣␣␣open(LOG,␣">>/usr/local/cgi-logs/mycgi-log")␣or
␣␣␣␣␣␣␣die("Unable␣to␣open␣mycgi-log:␣$!\n");
␣␣␣␣␣carpout(LOG);
␣␣␣}

carpout()␣does␣not␣handle␣file␣locking␣on␣the␣log␣for␣you␣at␣this␣point.
Also,␣note␣that␣carpout()␣does␣not␣work␣with␣in-memory␣file␣handles,␣although
a␣patch␣would␣be␣welcome␣to␣address␣that.

The␣real␣STDERR␣is␣not␣closed␣--␣it␣is␣moved␣to␣CGI::Carp::SAVEERR.␣␣Some
servers,␣when␣dealing␣with␣CGI␣scripts,␣close␣their␣connection␣to␣the
browser␣when␣the␣script␣closes␣STDOUT␣and␣STDERR.␣␣CGI::Carp::SAVEERR␣is␣there␣to
prevent␣this␣from␣happening␣prematurely.

You␣can␣pass␣filehandles␣to␣carpout()␣in␣a␣variety␣of␣ways.␣␣The␣"correct"
way␣according␣to␣Tom␣Christiansen␣is␣to␣pass␣a␣reference␣to␣a␣filehandle
GLOB:

␣␣␣␣carpout(\*LOG);

This␣looks␣weird␣to␣mere␣mortals␣however,␣so␣the␣following␣syntaxes␣are
accepted␣as␣well:

␣␣␣␣carpout(LOG);
␣␣␣␣carpout(main::LOG);
␣␣␣␣carpout(main'LOG);
␣␣␣␣carpout(\LOG);
␣␣␣␣carpout(\'main::LOG');

␣␣␣␣...␣and␣so␣on

FileHandle␣and␣other␣objects␣work␣as␣well.

Use␣of␣carpout()␣is␣not␣great␣for␣performance,␣so␣it␣is␣recommended
for␣debugging␣purposes␣or␣for␣moderate-use␣applications.␣␣A␣future
version␣of␣this␣module␣may␣delay␣redirecting␣STDERR␣until␣one␣of␣the
CGI::Carp␣methods␣is␣called␣to␣prevent␣the␣performance␣hit.

=head1␣MAKING␣PERL␣ERRORS␣APPEAR␣IN␣THE␣BROWSER␣WINDOW

If␣you␣want␣to␣send␣fatal␣(die,␣confess)␣errors␣to␣the␣browser,␣ask␣to
import␣the␣special␣"fatalsToBrowser"␣subroutine:

␣␣␣␣use␣CGI::Carp␣qw(fatalsToBrowser);
␣␣␣␣die␣"Bad␣error␣here";

Fatal␣errors␣will␣now␣be␣echoed␣to␣the␣browser␣as␣well␣as␣to␣the␣log.␣␣CGI::Carp
arranges␣to␣send␣a␣minimal␣HTTP␣header␣to␣the␣browser␣so␣that␣even␣errors␣that
occur␣in␣the␣early␣compile␣phase␣will␣be␣seen.
Nonfatal␣errors␣will␣still␣be␣directed␣to␣the␣log␣file␣only␣(unless␣redirected
with␣carpout).

Note␣that␣fatalsToBrowser␣does␣B<not>␣work␣with␣mod_perl␣version␣2.0
and␣higher.

=head2␣Changing␣the␣default␣message

By␣default,␣the␣software␣error␣message␣is␣followed␣by␣a␣note␣to
contact␣the␣Webmaster␣by␣e-mail␣with␣the␣time␣and␣date␣of␣the␣error.
If␣this␣message␣is␣not␣to␣your␣liking,␣you␣can␣change␣it␣using␣the
set_message()␣routine.␣␣This␣is␣not␣imported␣by␣default;␣you␣should
import␣it␣on␣the␣use()␣line:

␣␣␣␣use␣CGI::Carp␣qw(fatalsToBrowser␣set_message);
␣␣␣␣set_message("It's␣not␣a␣bug,␣it's␣a␣feature!");

You␣may␣also␣pass␣in␣a␣code␣reference␣in␣order␣to␣create␣a␣custom
error␣message.␣␣At␣run␣time,␣your␣code␣will␣be␣called␣with␣the␣text
of␣the␣error␣message␣that␣caused␣the␣script␣to␣die.␣␣Example:

␣␣␣␣use␣CGI::Carp␣qw(fatalsToBrowser␣set_message);
␣␣␣␣BEGIN␣{
␣␣␣␣␣␣␣sub␣handle_errors␣{
␣␣␣␣␣␣␣␣␣␣my␣$msg␣=␣shift;
␣␣␣␣␣␣␣␣␣␣print␣"<h1>Oh␣gosh</h1>";
␣␣␣␣␣␣␣␣␣␣print␣"<p>Got␣an␣error:␣$msg</p>";
␣␣␣␣␣␣}
␣␣␣␣␣␣set_message(\&handle_errors);
␣␣␣␣}

In␣order␣to␣correctly␣intercept␣compile-time␣errors,␣you␣should␣call
set_message()␣from␣within␣a␣BEGIN{}␣block.

=head1␣DOING␣MORE␣THAN␣PRINTING␣A␣MESSAGE␣IN␣THE␣EVENT␣OF␣PERL␣ERRORS

If␣fatalsToBrowser␣in␣conjunction␣with␣set_message␣does␣not␣provide␣
you␣with␣all␣of␣the␣functionality␣you␣need,␣you␣can␣go␣one␣step␣
further␣by␣specifying␣a␣function␣to␣be␣executed␣any␣time␣a␣script
calls␣"die",␣has␣a␣syntax␣error,␣or␣dies␣unexpectedly␣at␣runtime
with␣a␣line␣like␣"undef->explode();".␣

␣␣␣␣use␣CGI::Carp␣qw(set_die_handler);
␣␣␣␣BEGIN␣{
␣␣␣␣␣␣␣sub␣handle_errors␣{
␣␣␣␣␣␣␣␣␣␣my␣$msg␣=␣shift;
␣␣␣␣␣␣␣␣␣␣print␣"content-type:␣text/html\n\n";
␣␣␣␣␣␣␣␣␣␣print␣"<h1>Oh␣gosh</h1>";
␣␣␣␣␣␣␣␣␣␣print␣"<p>Got␣an␣error:␣$msg</p>";

␣␣␣␣␣␣␣␣␣␣#proceed␣to␣send␣an␣email␣to␣a␣system␣administrator,
␣␣␣␣␣␣␣␣␣␣#write␣a␣detailed␣message␣to␣the␣browser␣and/or␣a␣log,
␣␣␣␣␣␣␣␣␣␣#etc....
␣␣␣␣␣␣}
␣␣␣␣␣␣set_die_handler(\&handle_errors);
␣␣␣␣}

Notice␣that␣if␣you␣use␣set_die_handler(),␣you␣must␣handle␣sending
HTML␣headers␣to␣the␣browser␣yourself␣if␣you␣are␣printing␣a␣message.

If␣you␣use␣set_die_handler(),␣you␣will␣most␣likely␣interfere␣with␣
the␣behavior␣of␣fatalsToBrowser,␣so␣you␣must␣use␣this␣or␣that,␣not␣
both.␣

Using␣set_die_handler()␣sets␣SIG{__DIE__}␣(as␣does␣fatalsToBrowser),
and␣there␣is␣only␣one␣SIG{__DIE__}.␣This␣means␣that␣if␣you␣are␣
attempting␣to␣set␣SIG{__DIE__}␣yourself,␣you␣may␣interfere␣with␣
this␣module's␣functionality,␣or␣this␣module␣may␣interfere␣with␣
your␣module's␣functionality.

=head1␣MAKING␣WARNINGS␣APPEAR␣AS␣HTML␣COMMENTS

It␣is␣now␣also␣possible␣to␣make␣non-fatal␣errors␣appear␣as␣HTML
comments␣embedded␣in␣the␣output␣of␣your␣program.␣␣To␣enable␣this
feature,␣export␣the␣new␣"warningsToBrowser"␣subroutine.␣␣Since␣sending
warnings␣to␣the␣browser␣before␣the␣HTTP␣headers␣have␣been␣sent␣would
cause␣an␣error,␣any␣warnings␣are␣stored␣in␣an␣internal␣buffer␣until
you␣call␣the␣warningsToBrowser()␣subroutine␣with␣a␣true␣argument:

␣␣␣␣use␣CGI::Carp␣qw(fatalsToBrowser␣warningsToBrowser);
␣␣␣␣use␣CGI␣qw(:standard);
␣␣␣␣print␣header();
␣␣␣␣warningsToBrowser(1);

You␣may␣also␣give␣a␣false␣argument␣to␣warningsToBrowser()␣to␣prevent
warnings␣from␣being␣sent␣to␣the␣browser␣while␣you␣are␣printing␣some
content␣where␣HTML␣comments␣are␣not␣allowed:

␣␣␣␣warningsToBrowser(0);␣␣␣␣#␣disable␣warnings
␣␣␣␣print␣"<script␣type=\"text/javascript\"><!--\n";
␣␣␣␣print_some_javascript_code();
␣␣␣␣print␣"//--></script>\n";
␣␣␣␣warningsToBrowser(1);␣␣␣␣#␣re-enable␣warnings

Note:␣In␣this␣respect␣warningsToBrowser()␣differs␣fundamentally␣from
fatalsToBrowser(),␣which␣you␣should␣never␣call␣yourself!

=head1␣OVERRIDING␣THE␣NAME␣OF␣THE␣PROGRAM

CGI::Carp␣includes␣the␣name␣of␣the␣program␣that␣generated␣the␣error␣or
warning␣in␣the␣messages␣written␣to␣the␣log␣and␣the␣browser␣window.
Sometimes,␣Perl␣can␣get␣confused␣about␣what␣the␣actual␣name␣of␣the
executed␣program␣was.␣␣In␣these␣cases,␣you␣can␣override␣the␣program
name␣that␣CGI::Carp␣will␣use␣for␣all␣messages.

The␣quick␣way␣to␣do␣that␣is␣to␣tell␣CGI::Carp␣the␣name␣of␣the␣program
in␣its␣use␣statement.␣␣You␣can␣do␣that␣by␣adding
"name=cgi_carp_log_name"␣to␣your␣"use"␣statement.␣␣For␣example:

␣␣␣␣use␣CGI::Carp␣qw(name=cgi_carp_log_name);

.␣␣If␣you␣want␣to␣change␣the␣program␣name␣partway␣through␣the␣program,
you␣can␣use␣the␣C<set_progname()>␣function␣instead.␣␣It␣is␣not
exported␣by␣default,␣you␣must␣import␣it␣explicitly␣by␣saying

␣␣␣␣use␣CGI::Carp␣qw(set_progname);

Once␣you've␣done␣that,␣you␣can␣change␣the␣logged␣name␣of␣the␣program
at␣any␣time␣by␣calling

␣␣␣␣set_progname(new_program_name);

You␣can␣set␣the␣program␣back␣to␣the␣default␣by␣calling

␣␣␣␣set_progname(undef);

Note␣that␣this␣override␣doesn't␣happen␣until␣after␣the␣program␣has
compiled,␣so␣any␣compile-time␣errors␣will␣still␣show␣up␣with␣the
non-overridden␣program␣name
␣␣
=head1␣CHANGE␣LOG

1.29␣Patch␣from␣Peter␣Whaite␣to␣fix␣the␣unfixable␣problem␣of␣CGI::Carp
␣␣␣␣␣not␣behaving␣correctly␣in␣an␣eval()␣context.

1.05␣carpout()␣added␣and␣minor␣corrections␣by␣Marc␣Hedlund
␣␣␣␣␣<hedlund@best.com>␣on␣11/26/95.

1.06␣fatalsToBrowser()␣no␣longer␣aborts␣for␣fatal␣errors␣within
␣␣␣␣␣eval()␣statements.

1.08␣set_message()␣added␣and␣carpout()␣expanded␣to␣allow␣for␣FileHandle
␣␣␣␣␣objects.

1.09␣set_message()␣now␣allows␣users␣to␣pass␣a␣code␣REFERENCE␣for␣
␣␣␣␣␣really␣custom␣error␣messages.␣␣croak␣and␣carp␣are␣now
␣␣␣␣␣exported␣by␣default.␣␣Thanks␣to␣Gunther␣Birznieks␣for␣the
␣␣␣␣␣patches.

1.10␣Patch␣from␣Chris␣Dean␣(ctdean@cogit.com)␣to␣allow␣
␣␣␣␣␣module␣to␣run␣correctly␣under␣mod_perl.

1.11␣Changed␣order␣of␣&gt;␣and␣&lt;␣escapes.

1.12␣Changed␣die()␣on␣line␣217␣to␣CORE::die␣to␣avoid␣B<-w>␣warning.

1.13␣Added␣cluck()␣to␣make␣the␣module␣orthogonal␣with␣Carp.
␣␣␣␣␣More␣mod_perl␣related␣fixes.

1.20␣Patch␣from␣Ilmari␣Karonen␣(perl@itz.pp.sci.fi):␣␣Added
␣␣␣␣␣warningsToBrowser().␣␣Replaced␣<CODE>␣tags␣with␣<PRE>␣in
␣␣␣␣␣fatalsToBrowser()␣output.

1.23␣ineval()␣now␣checks␣both␣$^S␣and␣inspects␣the␣message␣for␣the␣"eval"␣pattern
␣␣␣␣␣(hack␣alert!)␣in␣order␣to␣accommodate␣various␣combinations␣of␣Perl␣and
␣␣␣␣␣mod_perl.

1.24␣Patch␣from␣Scott␣Gifford␣(sgifford@suspectclass.com):␣Add␣support
␣␣␣␣␣for␣overriding␣program␣name.

1.26␣Replaced␣CORE::GLOBAL::die␣with␣the␣evil␣$SIG{__DIE__}␣because␣the
␣␣␣␣␣former␣isn't␣working␣in␣some␣people's␣hands.␣␣There␣is␣no␣such␣thing
␣␣␣␣␣as␣reliable␣exception␣handling␣in␣Perl.

1.27␣Replaced␣tell␣STDOUT␣with␣bytes=tell␣STDOUT.

=head1␣AUTHORS

Copyright␣1995-2002,␣Lincoln␣D.␣Stein.␣␣All␣rights␣reserved.␣␣

This␣library␣is␣free␣software;␣you␣can␣redistribute␣it␣and/or␣modify
it␣under␣the␣same␣terms␣as␣Perl␣itself.

Address␣bug␣reports␣and␣comments␣to:␣lstein@cshl.org

=head1␣SEE␣ALSO

Carp,␣CGI::Base,␣CGI::BasePlus,␣CGI::Request,␣CGI::MiniSvr,␣CGI::Form,
CGI::Response

=cut
----------
Range: (1607176,1614265) (7089)
=head1␣NAME

CGI::Push␣-␣Simple␣Interface␣to␣Server␣Push

=head1␣SYNOPSIS

␣␣␣␣use␣CGI::Push␣qw(:standard);

␣␣␣␣do_push(-next_page=>\&next_page,
␣␣␣␣␣␣␣␣␣␣␣␣-last_page=>\&last_page,
␣␣␣␣␣␣␣␣␣␣␣␣-delay=>0.5);

␣␣␣␣sub␣next_page␣{
␣␣␣␣␣␣␣␣my($q,$counter)␣=␣@_;
␣␣␣␣␣␣␣␣return␣undef␣if␣$counter␣>=␣10;
␣␣␣␣␣␣␣␣return␣start_html('Test'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣h1('Visible'),"\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"This␣page␣has␣been␣called␣",␣strong($counter),"␣times",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣end_html();
␣␣␣␣}

␣␣␣␣sub␣last_page␣{
␣␣␣␣␣␣␣␣my($q,$counter)␣=␣@_;
␣␣␣␣␣␣␣␣return␣start_html('Done'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣h1('Finished'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣strong($counter␣-␣1),'␣iterations.',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣end_html;
␣␣␣␣}

=head1␣DESCRIPTION

CGI::Push␣is␣a␣subclass␣of␣the␣CGI␣object␣created␣by␣CGI.pm.␣␣It␣is
specialized␣for␣server␣push␣operations,␣which␣allow␣you␣to␣create
animated␣pages␣whose␣content␣changes␣at␣regular␣intervals.

You␣provide␣CGI::Push␣with␣a␣pointer␣to␣a␣subroutine␣that␣will␣draw
one␣page.␣␣Every␣time␣your␣subroutine␣is␣called,␣it␣generates␣a␣new
page.␣␣The␣contents␣of␣the␣page␣will␣be␣transmitted␣to␣the␣browser
in␣such␣a␣way␣that␣it␣will␣replace␣what␣was␣there␣beforehand.␣␣The
technique␣will␣work␣with␣HTML␣pages␣as␣well␣as␣with␣graphics␣files,␣
allowing␣you␣to␣create␣animated␣GIFs.

Only␣Netscape␣Navigator␣supports␣server␣push.␣␣Internet␣Explorer
browsers␣do␣not.

=head1␣USING␣CGI::Push

CGI::Push␣adds␣one␣new␣method␣to␣the␣standard␣CGI␣suite,␣do_push().
When␣you␣call␣this␣method,␣you␣pass␣it␣a␣reference␣to␣a␣subroutine
that␣is␣responsible␣for␣drawing␣each␣new␣page,␣an␣interval␣delay,␣and
an␣optional␣subroutine␣for␣drawing␣the␣last␣page.␣␣Other␣optional
parameters␣include␣most␣of␣those␣recognized␣by␣the␣CGI␣header()
method.

You␣may␣call␣do_push()␣in␣the␣object␣oriented␣manner␣or␣not,␣as␣you
prefer:

␣␣␣␣use␣CGI::Push;
␣␣␣␣$q␣=␣new␣CGI::Push;
␣␣␣␣$q->do_push(-next_page=>\&draw_a_page);

␣␣␣␣␣␣␣␣-or-

␣␣␣␣use␣CGI::Push␣qw(:standard);
␣␣␣␣do_push(-next_page=>\&draw_a_page);

Parameters␣are␣as␣follows:

=over␣4

=item␣-next_page

␣␣␣␣do_push(-next_page=>\&my_draw_routine);

This␣required␣parameter␣points␣to␣a␣reference␣to␣a␣subroutine␣responsible␣for
drawing␣each␣new␣page.␣␣The␣subroutine␣should␣expect␣two␣parameters
consisting␣of␣the␣CGI␣object␣and␣a␣counter␣indicating␣the␣number
of␣times␣the␣subroutine␣has␣been␣called.␣␣It␣should␣return␣the
contents␣of␣the␣page␣as␣an␣B<array>␣of␣one␣or␣more␣items␣to␣print.␣␣
It␣can␣return␣a␣false␣value␣(or␣an␣empty␣array)␣in␣order␣to␣abort␣the
redrawing␣loop␣and␣print␣out␣the␣final␣page␣(if␣any)

␣␣␣␣sub␣my_draw_routine␣{
␣␣␣␣␣␣␣␣my($q,$counter)␣=␣@_;
␣␣␣␣␣␣␣␣return␣undef␣if␣$counter␣>␣100;
␣␣␣␣␣␣␣␣return␣start_html('testing'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣h1('testing'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"This␣page␣called␣$counter␣times";
␣␣␣␣}

You␣are␣of␣course␣free␣to␣refer␣to␣create␣and␣use␣global␣variables
within␣your␣draw␣routine␣in␣order␣to␣achieve␣special␣effects.

=item␣-last_page

This␣optional␣parameter␣points␣to␣a␣reference␣to␣the␣subroutine
responsible␣for␣drawing␣the␣last␣page␣of␣the␣series.␣␣It␣is␣called
after␣the␣-next_page␣routine␣returns␣a␣false␣value.␣␣The␣subroutine
itself␣should␣have␣exactly␣the␣same␣calling␣conventions␣as␣the
-next_page␣routine.

=item␣-type

This␣optional␣parameter␣indicates␣the␣content␣type␣of␣each␣page.␣␣It
defaults␣to␣"text/html".␣␣Normally␣the␣module␣assumes␣that␣each␣page
is␣of␣a␣homogenous␣MIME␣type.␣␣However␣if␣you␣provide␣either␣of␣the
magic␣values␣"heterogeneous"␣or␣"dynamic"␣(the␣latter␣provided␣for␣the
convenience␣of␣those␣who␣hate␣long␣parameter␣names),␣you␣can␣specify
the␣MIME␣type␣--␣and␣other␣header␣fields␣--␣on␣a␣per-page␣basis.␣␣See␣
"heterogeneous␣pages"␣for␣more␣details.

=item␣-delay

This␣indicates␣the␣delay,␣in␣seconds,␣between␣frames.␣␣Smaller␣delays
refresh␣the␣page␣faster.␣␣Fractional␣values␣are␣allowed.

B<If␣not␣specified,␣-delay␣will␣default␣to␣1␣second>

=item␣-cookie,␣-target,␣-expires,␣-nph

These␣have␣the␣same␣meaning␣as␣the␣like-named␣parameters␣in
CGI::header().

If␣not␣specified,␣-nph␣will␣default␣to␣1␣(as␣needed␣for␣many␣servers,␣see␣below).

=back

=head2␣Heterogeneous␣Pages

Ordinarily␣all␣pages␣displayed␣by␣CGI::Push␣share␣a␣common␣MIME␣type.
However␣by␣providing␣a␣value␣of␣"heterogeneous"␣or␣"dynamic"␣in␣the
do_push()␣-type␣parameter,␣you␣can␣specify␣the␣MIME␣type␣of␣each␣page
on␣a␣case-by-case␣basis.␣␣

If␣you␣use␣this␣option,␣you␣will␣be␣responsible␣for␣producing␣the
HTTP␣header␣for␣each␣page.␣␣Simply␣modify␣your␣draw␣routine␣to
look␣like␣this:

␣␣␣␣sub␣my_draw_routine␣{
␣␣␣␣␣␣␣␣my($q,$counter)␣=␣@_;
␣␣␣␣␣␣␣␣return␣header('text/html'),␣␣␣#␣note␣we're␣producing␣the␣header␣here
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣start_html('testing'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣h1('testing'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"This␣page␣called␣$counter␣times";
␣␣␣␣}

You␣can␣add␣any␣header␣fields␣that␣you␣like,␣but␣some␣(cookies␣and
status␣fields␣included)␣may␣not␣be␣interpreted␣by␣the␣browser.␣␣One
interesting␣effect␣is␣to␣display␣a␣series␣of␣pages,␣then,␣after␣the
last␣page,␣to␣redirect␣the␣browser␣to␣a␣new␣URL.␣␣Because␣redirect()␣
does␣b<not>␣work,␣the␣easiest␣way␣is␣with␣a␣-refresh␣header␣field,
as␣shown␣below:

␣␣␣␣sub␣my_draw_routine␣{
␣␣␣␣␣␣␣␣my($q,$counter)␣=␣@_;
␣␣␣␣␣␣␣␣return␣undef␣if␣$counter␣>␣10;
␣␣␣␣␣␣␣␣return␣header('text/html'),␣␣␣#␣note␣we're␣producing␣the␣header␣here
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣start_html('testing'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣h1('testing'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"This␣page␣called␣$counter␣times";
␣␣␣␣}

␣␣␣␣sub␣my_last_page␣{
␣␣␣␣␣␣␣␣return␣header(-refresh=>'5;␣URL=http://somewhere.else/finished.html',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-type=>'text/html'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣start_html('Moved'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣h1('This␣is␣the␣last␣page'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'Goodbye!'
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣hr,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣end_html;␣
␣␣␣␣}

=head2␣Changing␣the␣Page␣Delay␣on␣the␣Fly

If␣you␣would␣like␣to␣control␣the␣delay␣between␣pages␣on␣a␣page-by-page
basis,␣call␣push_delay()␣from␣within␣your␣draw␣routine.␣␣push_delay()
takes␣a␣single␣numeric␣argument␣representing␣the␣number␣of␣seconds␣you
wish␣to␣delay␣after␣the␣current␣page␣is␣displayed␣and␣before
displaying␣the␣next␣one.␣␣The␣delay␣may␣be␣fractional.␣␣Without
parameters,␣push_delay()␣just␣returns␣the␣current␣delay.

=head1␣INSTALLING␣CGI::Push␣SCRIPTS

Server␣push␣scripts␣must␣be␣installed␣as␣no-parsed-header␣(NPH)
scripts␣in␣order␣to␣work␣correctly␣on␣many␣servers.␣␣On␣Unix␣systems,
this␣is␣most␣often␣accomplished␣by␣prefixing␣the␣script's␣name␣with␣"nph-".␣␣
Recognition␣of␣NPH␣scripts␣happens␣automatically␣with␣WebSTAR␣and␣
Microsoft␣IIS.␣␣Users␣of␣other␣servers␣should␣see␣their␣documentation
for␣help.

Apache␣web␣server␣from␣version␣1.3b2␣on␣does␣not␣need␣server
push␣scripts␣installed␣as␣NPH␣scripts:␣the␣-nph␣parameter␣to␣do_push()
may␣be␣set␣to␣a␣false␣value␣to␣disable␣the␣extra␣headers␣needed␣by␣an
NPH␣script.

=head1␣AUTHOR␣INFORMATION

Copyright␣1995-1998,␣Lincoln␣D.␣Stein.␣␣All␣rights␣reserved.␣␣

This␣library␣is␣free␣software;␣you␣can␣redistribute␣it␣and/or␣modify
it␣under␣the␣same␣terms␣as␣Perl␣itself.

Address␣bug␣reports␣and␣comments␣to:␣lstein@cshl.org

=head1␣BUGS

This␣section␣intentionally␣left␣blank.

=head1␣SEE␣ALSO

L<CGI::Carp>,␣L<CGI>

=cut
----------
Range: (1621699,1630708) (9009)
=head1␣NAME

CGI::Cookie␣-␣Interface␣to␣Netscape␣Cookies

=head1␣SYNOPSIS

␣␣␣␣use␣CGI␣qw/:standard/;
␣␣␣␣use␣CGI::Cookie;

␣␣␣␣#␣Create␣new␣cookies␣and␣send␣them
␣␣␣␣$cookie1␣=␣new␣CGI::Cookie(-name=>'ID',-value=>123456);
␣␣␣␣$cookie2␣=␣new␣CGI::Cookie(-name=>'preferences',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-value=>{␣font␣=>␣Helvetica,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣size␣=>␣12␣}␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣print␣header(-cookie=>[$cookie1,$cookie2]);

␣␣␣␣#␣fetch␣existing␣cookies
␣␣␣␣%cookies␣=␣fetch␣CGI::Cookie;
␣␣␣␣$id␣=␣$cookies{'ID'}->value;

␣␣␣␣#␣create␣cookies␣returned␣from␣an␣external␣source
␣␣␣␣%cookies␣=␣parse␣CGI::Cookie($ENV{COOKIE});

=head1␣DESCRIPTION

CGI::Cookie␣is␣an␣interface␣to␣Netscape␣(HTTP/1.1)␣cookies,␣an
innovation␣that␣allows␣Web␣servers␣to␣store␣persistent␣information␣on
the␣browser's␣side␣of␣the␣connection.␣␣Although␣CGI::Cookie␣is
intended␣to␣be␣used␣in␣conjunction␣with␣CGI.pm␣(and␣is␣in␣fact␣used␣by
it␣internally),␣you␣can␣use␣this␣module␣independently.

For␣full␣information␣on␣cookies␣see␣

	http://www.ics.uci.edu/pub/ietf/http/rfc2109.txt

=head1␣USING␣CGI::Cookie

CGI::Cookie␣is␣object␣oriented.␣␣Each␣cookie␣object␣has␣a␣name␣and␣a
value.␣␣The␣name␣is␣any␣scalar␣value.␣␣The␣value␣is␣any␣scalar␣or
array␣value␣(associative␣arrays␣are␣also␣allowed).␣␣Cookies␣also␣have
several␣optional␣attributes,␣including:

=over␣4

=item␣B<1.␣expiration␣date>

The␣expiration␣date␣tells␣the␣browser␣how␣long␣to␣hang␣on␣to␣the
cookie.␣␣If␣the␣cookie␣specifies␣an␣expiration␣date␣in␣the␣future,␣the
browser␣will␣store␣the␣cookie␣information␣in␣a␣disk␣file␣and␣return␣it
to␣the␣server␣every␣time␣the␣user␣reconnects␣(until␣the␣expiration
date␣is␣reached).␣␣If␣the␣cookie␣species␣an␣expiration␣date␣in␣the
past,␣the␣browser␣will␣remove␣the␣cookie␣from␣the␣disk␣file.␣␣If␣the
expiration␣date␣is␣not␣specified,␣the␣cookie␣will␣persist␣only␣until
the␣user␣quits␣the␣browser.

=item␣B<2.␣domain>

This␣is␣a␣partial␣or␣complete␣domain␣name␣for␣which␣the␣cookie␣is␣
valid.␣␣The␣browser␣will␣return␣the␣cookie␣to␣any␣host␣that␣matches
the␣partial␣domain␣name.␣␣For␣example,␣if␣you␣specify␣a␣domain␣name
of␣".capricorn.com",␣then␣Netscape␣will␣return␣the␣cookie␣to
Web␣servers␣running␣on␣any␣of␣the␣machines␣"www.capricorn.com",␣
"ftp.capricorn.com",␣"feckless.capricorn.com",␣etc.␣␣Domain␣names
must␣contain␣at␣least␣two␣periods␣to␣prevent␣attempts␣to␣match
on␣top␣level␣domains␣like␣".edu".␣␣If␣no␣domain␣is␣specified,␣then
the␣browser␣will␣only␣return␣the␣cookie␣to␣servers␣on␣the␣host␣the
cookie␣originated␣from.

=item␣B<3.␣path>

If␣you␣provide␣a␣cookie␣path␣attribute,␣the␣browser␣will␣check␣it
against␣your␣script's␣URL␣before␣returning␣the␣cookie.␣␣For␣example,
if␣you␣specify␣the␣path␣"/cgi-bin",␣then␣the␣cookie␣will␣be␣returned
to␣each␣of␣the␣scripts␣"/cgi-bin/tally.pl",␣"/cgi-bin/order.pl",␣and
"/cgi-bin/customer_service/complain.pl",␣but␣not␣to␣the␣script
"/cgi-private/site_admin.pl".␣␣By␣default,␣the␣path␣is␣set␣to␣"/",␣so
that␣all␣scripts␣at␣your␣site␣will␣receive␣the␣cookie.

=item␣B<4.␣secure␣flag>

If␣the␣"secure"␣attribute␣is␣set,␣the␣cookie␣will␣only␣be␣sent␣to␣your
script␣if␣the␣CGI␣request␣is␣occurring␣on␣a␣secure␣channel,␣such␣as␣SSL.

=item␣B<4.␣httponly␣flag>

If␣the␣"httponly"␣attribute␣is␣set,␣the␣cookie␣will␣only␣be␣accessible
through␣HTTP␣Requests.␣This␣cookie␣will␣be␣inaccessible␣via␣JavaScript
(to␣prevent␣XSS␣attacks).

But,␣currently␣this␣feature␣only␣used␣and␣recognised␣by␣
MS␣Internet␣Explorer␣6␣Service␣Pack␣1␣and␣later.

See␣this␣URL␣for␣more␣information:

L<http://msdn.microsoft.com/en-us/library/ms533046%28VS.85%29.aspx>

=back

=head2␣Creating␣New␣Cookies

	my␣$c␣=␣new␣CGI::Cookie(-name␣␣␣␣=>␣␣'foo',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-value␣␣␣=>␣␣'bar',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-expires␣=>␣␣'+3M',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-domain␣␣=>␣␣'.capricorn.com',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-path␣␣␣␣=>␣␣'/cgi-bin/database',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-secure␣␣=>␣␣1
	␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

Create␣cookies␣from␣scratch␣with␣the␣B<new>␣method.␣␣The␣B<-name>␣and
B<-value>␣parameters␣are␣required.␣␣The␣name␣must␣be␣a␣scalar␣value.
The␣value␣can␣be␣a␣scalar,␣an␣array␣reference,␣or␣a␣hash␣reference.
(At␣some␣point␣in␣the␣future␣cookies␣will␣support␣one␣of␣the␣Perl
object␣serialization␣protocols␣for␣full␣generality).

B<-expires>␣accepts␣any␣of␣the␣relative␣or␣absolute␣date␣formats
recognized␣by␣CGI.pm,␣for␣example␣"+3M"␣for␣three␣months␣in␣the
future.␣␣See␣CGI.pm's␣documentation␣for␣details.

B<-domain>␣points␣to␣a␣domain␣name␣or␣to␣a␣fully␣qualified␣host␣name.
If␣not␣specified,␣the␣cookie␣will␣be␣returned␣only␣to␣the␣Web␣server
that␣created␣it.

B<-path>␣points␣to␣a␣partial␣URL␣on␣the␣current␣server.␣␣The␣cookie
will␣be␣returned␣to␣all␣URLs␣beginning␣with␣the␣specified␣path.␣␣If
not␣specified,␣it␣defaults␣to␣'/',␣which␣returns␣the␣cookie␣to␣all
pages␣at␣your␣site.

B<-secure>␣if␣set␣to␣a␣true␣value␣instructs␣the␣browser␣to␣return␣the
cookie␣only␣when␣a␣cryptographic␣protocol␣is␣in␣use.

B<-httponly>␣if␣set␣to␣a␣true␣value,␣the␣cookie␣will␣not␣be␣accessible
via␣JavaScript.

For␣compatibility␣with␣Apache::Cookie,␣you␣may␣optionally␣pass␣in
a␣mod_perl␣request␣object␣as␣the␣first␣argument␣to␣C<new()>.␣It␣will
simply␣be␣ignored:

␣␣my␣$c␣=␣new␣CGI::Cookie($r,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-name␣␣␣␣=>␣␣'foo',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-value␣␣␣=>␣␣['bar','baz']);

=head2␣Sending␣the␣Cookie␣to␣the␣Browser

The␣simplest␣way␣to␣send␣a␣cookie␣to␣the␣browser␣is␣by␣calling␣the␣bake()
method:

␣␣$c->bake;

Under␣mod_perl,␣pass␣in␣an␣Apache␣request␣object:

␣␣$c->bake($r);

If␣you␣want␣to␣set␣the␣cookie␣yourself,␣Within␣a␣CGI␣script␣you␣can␣send
a␣cookie␣to␣the␣browser␣by␣creating␣one␣or␣more␣Set-Cookie:␣fields␣in␣the
HTTP␣header.␣␣Here␣is␣a␣typical␣sequence:

␣␣my␣$c␣=␣new␣CGI::Cookie(-name␣␣␣␣=>␣␣'foo',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-value␣␣␣=>␣␣['bar','baz'],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-expires␣=>␣␣'+3M');

␣␣print␣"Set-Cookie:␣$c\n";
␣␣print␣"Content-Type:␣text/html\n\n";

To␣send␣more␣than␣one␣cookie,␣create␣several␣Set-Cookie:␣fields.

If␣you␣are␣using␣CGI.pm,␣you␣send␣cookies␣by␣providing␣a␣-cookie
argument␣to␣the␣header()␣method:

␣␣print␣header(-cookie=>$c);

Mod_perl␣users␣can␣set␣cookies␣using␣the␣request␣object's␣header_out()
method:

␣␣$r->headers_out->set('Set-Cookie'␣=>␣$c);

Internally,␣Cookie␣overloads␣the␣""␣operator␣to␣call␣its␣as_string()
method␣when␣incorporated␣into␣the␣HTTP␣header.␣␣as_string()␣turns␣the
Cookie's␣internal␣representation␣into␣an␣RFC-compliant␣text
representation.␣␣You␣may␣call␣as_string()␣yourself␣if␣you␣prefer:

␣␣print␣"Set-Cookie:␣",$c->as_string,"\n";

=head2␣Recovering␣Previous␣Cookies

	%cookies␣=␣fetch␣CGI::Cookie;

B<fetch>␣returns␣an␣associative␣array␣consisting␣of␣all␣cookies
returned␣by␣the␣browser.␣␣The␣keys␣of␣the␣array␣are␣the␣cookie␣names.␣␣You
can␣iterate␣through␣the␣cookies␣this␣way:

	%cookies␣=␣fetch␣CGI::Cookie;
	foreach␣(keys␣%cookies)␣{
	␣␣␣do_something($cookies{$_});
␣␣␣␣␣␣␣␣}

In␣a␣scalar␣context,␣fetch()␣returns␣a␣hash␣reference,␣which␣may␣be␣more
efficient␣if␣you␣are␣manipulating␣multiple␣cookies.

CGI.pm␣uses␣the␣URL␣escaping␣methods␣to␣save␣and␣restore␣reserved␣characters
in␣its␣cookies.␣␣If␣you␣are␣trying␣to␣retrieve␣a␣cookie␣set␣by␣a␣foreign␣server,
this␣escaping␣method␣may␣trip␣you␣up.␣␣Use␣raw_fetch()␣instead,␣which␣has␣the
same␣semantics␣as␣fetch(),␣but␣performs␣no␣unescaping.

You␣may␣also␣retrieve␣cookies␣that␣were␣stored␣in␣some␣external
form␣using␣the␣parse()␣class␣method:

␣␣␣␣␣␣␣$COOKIES␣=␣`cat␣/usr/tmp/Cookie_stash`;
␣␣␣␣␣␣␣%cookies␣=␣parse␣CGI::Cookie($COOKIES);

If␣you␣are␣in␣a␣mod_perl␣environment,␣you␣can␣save␣some␣overhead␣by
passing␣the␣request␣object␣to␣fetch()␣like␣this:

␣␣␣CGI::Cookie->fetch($r);

=head2␣Manipulating␣Cookies

Cookie␣objects␣have␣a␣series␣of␣accessor␣methods␣to␣get␣and␣set␣cookie
attributes.␣␣Each␣accessor␣has␣a␣similar␣syntax.␣␣Called␣without
arguments,␣the␣accessor␣returns␣the␣current␣value␣of␣the␣attribute.
Called␣with␣an␣argument,␣the␣accessor␣changes␣the␣attribute␣and
returns␣its␣new␣value.

=over␣4

=item␣B<name()>

Get␣or␣set␣the␣cookie's␣name.␣␣Example:

	$name␣=␣$c->name;
	$new_name␣=␣$c->name('fred');

=item␣B<value()>

Get␣or␣set␣the␣cookie's␣value.␣␣Example:

	$value␣=␣$c->value;
	@new_value␣=␣$c->value(['a','b','c','d']);

B<value()>␣is␣context␣sensitive.␣␣In␣a␣list␣context␣it␣will␣return
the␣current␣value␣of␣the␣cookie␣as␣an␣array.␣␣In␣a␣scalar␣context␣it
will␣return␣the␣B<first>␣value␣of␣a␣multivalued␣cookie.

=item␣B<domain()>

Get␣or␣set␣the␣cookie's␣domain.

=item␣B<path()>

Get␣or␣set␣the␣cookie's␣path.

=item␣B<expires()>

Get␣or␣set␣the␣cookie's␣expiration␣time.

=back


=head1␣AUTHOR␣INFORMATION

Copyright␣1997-1998,␣Lincoln␣D.␣Stein.␣␣All␣rights␣reserved.␣␣

This␣library␣is␣free␣software;␣you␣can␣redistribute␣it␣and/or␣modify
it␣under␣the␣same␣terms␣as␣Perl␣itself.

Address␣bug␣reports␣and␣comments␣to:␣lstein@cshl.org

=head1␣BUGS

This␣section␣intentionally␣left␣blank.

=head1␣SEE␣ALSO

L<CGI::Carp>,␣L<CGI>

=cut
----------
Range: (1674695,1682379) (7684)
=head1␣NAME

Thread::Queue␣-␣Thread-safe␣queues

=head1␣VERSION

This␣document␣describes␣Thread::Queue␣version␣2.11

=head1␣SYNOPSIS

␣␣␣␣use␣strict;
␣␣␣␣use␣warnings;

␣␣␣␣use␣threads;
␣␣␣␣use␣Thread::Queue;

␣␣␣␣my␣$q␣=␣Thread::Queue->new();␣␣␣␣#␣A␣new␣empty␣queue

␣␣␣␣#␣Worker␣thread
␣␣␣␣my␣$thr␣=␣threads->create(sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣while␣(my␣$item␣=␣$q->dequeue())␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣Do␣work␣on␣$item
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣})->detach();

␣␣␣␣#␣Send␣work␣to␣the␣thread
␣␣␣␣$q->enqueue($item1,␣...);


␣␣␣␣#␣Count␣of␣items␣in␣the␣queue
␣␣␣␣my␣$left␣=␣$q->pending();

␣␣␣␣#␣Non-blocking␣dequeue
␣␣␣␣if␣(defined(my␣$item␣=␣$q->dequeue_nb()))␣{
␣␣␣␣␣␣␣␣#␣Work␣on␣$item
␣␣␣␣}

␣␣␣␣#␣Get␣the␣second␣item␣in␣the␣queue␣without␣dequeuing␣anything
␣␣␣␣my␣$item␣=␣$q->peek(1);

␣␣␣␣#␣Insert␣two␣items␣into␣the␣queue␣just␣behind␣the␣head
␣␣␣␣$q->insert(1,␣$item1,␣$item2);

␣␣␣␣#␣Extract␣the␣last␣two␣items␣on␣the␣queue
␣␣␣␣my␣($item1,␣$item2)␣=␣$q->extract(-2,␣2);

=head1␣DESCRIPTION

This␣module␣provides␣thread-safe␣FIFO␣queues␣that␣can␣be␣accessed␣safely␣by
any␣number␣of␣threads.

Any␣data␣types␣supported␣by␣L<threads::shared>␣can␣be␣passed␣via␣queues:

=over

=item␣Ordinary␣scalars

=item␣Array␣refs

=item␣Hash␣refs

=item␣Scalar␣refs

=item␣Objects␣based␣on␣the␣above

=back

Ordinary␣scalars␣are␣added␣to␣queues␣as␣they␣are.

If␣not␣already␣thread-shared,␣the␣other␣complex␣data␣types␣will␣be␣cloned
(recursively,␣if␣needed,␣and␣including␣any␣C<bless>ings␣and␣read-only
settings)␣into␣thread-shared␣structures␣before␣being␣placed␣onto␣a␣queue.

For␣example,␣the␣following␣would␣cause␣L<Thread::Queue>␣to␣create␣a␣empty,
shared␣array␣reference␣via␣C<&shared([])>,␣copy␣the␣elements␣'foo',␣'bar'
and␣'baz'␣from␣C<@ary>␣into␣it,␣and␣then␣place␣that␣shared␣reference␣onto
the␣queue:

␣␣␣␣my␣@ary␣=␣qw/foo␣bar␣baz/;
␣␣␣␣$q->enqueue(\@ary);

However,␣for␣the␣following,␣the␣items␣are␣already␣shared,␣so␣their␣references
are␣added␣directly␣to␣the␣queue,␣and␣no␣cloning␣takes␣place:

␣␣␣␣my␣@ary␣:shared␣=␣qw/foo␣bar␣baz/;
␣␣␣␣$q->enqueue(\@ary);

␣␣␣␣my␣$obj␣=␣&shared({});
␣␣␣␣$$obj{'foo'}␣=␣'bar';
␣␣␣␣$$obj{'qux'}␣=␣99;
␣␣␣␣bless($obj,␣'My::Class');
␣␣␣␣$q->enqueue($obj);

See␣L</"LIMITATIONS">␣for␣caveats␣related␣to␣passing␣objects␣via␣queues.

=head1␣QUEUE␣CREATION

=over

=item␣->new()

Creates␣a␣new␣empty␣queue.

=item␣->new(LIST)

Creates␣a␣new␣queue␣pre-populated␣with␣the␣provided␣list␣of␣items.

=back

=head1␣BASIC␣METHODS

The␣following␣methods␣deal␣with␣queues␣on␣a␣FIFO␣basis.

=over

=item␣->enqueue(LIST)

Adds␣a␣list␣of␣items␣onto␣the␣end␣of␣the␣queue.

=item␣->dequeue()

=item␣->dequeue(COUNT)

Removes␣the␣requested␣number␣of␣items␣(default␣is␣1)␣from␣the␣head␣of␣the
queue,␣and␣returns␣them.␣␣If␣the␣queue␣contains␣fewer␣than␣the␣requested
number␣of␣items,␣then␣the␣thread␣will␣be␣blocked␣until␣the␣requisite␣number
of␣items␣are␣available␣(i.e.,␣until␣other␣threads␣<enqueue>␣more␣items).

=item␣->dequeue_nb()

=item␣->dequeue_nb(COUNT)

Removes␣the␣requested␣number␣of␣items␣(default␣is␣1)␣from␣the␣head␣of␣the
queue,␣and␣returns␣them.␣␣If␣the␣queue␣contains␣fewer␣than␣the␣requested
number␣of␣items,␣then␣it␣immediately␣(i.e.,␣non-blocking)␣returns␣whatever
items␣there␣are␣on␣the␣queue.␣␣If␣the␣queue␣is␣empty,␣then␣C<undef>␣is
returned.

=item␣->pending()

Returns␣the␣number␣of␣items␣still␣in␣the␣queue.

=back

=head1␣ADVANCED␣METHODS

The␣following␣methods␣can␣be␣used␣to␣manipulate␣items␣anywhere␣in␣a␣queue.

To␣prevent␣the␣contents␣of␣a␣queue␣from␣being␣modified␣by␣another␣thread
while␣it␣is␣being␣examined␣and/or␣changed,␣L<lock|threads::shared/"lock
VARIABLE">␣the␣queue␣inside␣a␣local␣block:

␣␣␣␣{
␣␣␣␣␣␣␣␣lock($q);␣␣␣#␣Keep␣other␣threads␣from␣changing␣the␣queue's␣contents
␣␣␣␣␣␣␣␣my␣$item␣=␣$q->peek();
␣␣␣␣␣␣␣␣if␣($item␣...)␣{
␣␣␣␣␣␣␣␣␣␣␣␣...
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣#␣Queue␣is␣now␣unlocked

=over

=item␣->peek()

=item␣->peek(INDEX)

Returns␣an␣item␣from␣the␣queue␣without␣dequeuing␣anything.␣␣Defaults␣to␣the
the␣head␣of␣queue␣(at␣index␣position␣0)␣if␣no␣index␣is␣specified.␣␣Negative
index␣values␣are␣supported␣as␣with␣L<arrays|perldata/"Subscripts">␣(i.e.,␣-1
is␣the␣end␣of␣the␣queue,␣-2␣is␣next␣to␣last,␣and␣so␣on).

If␣no␣items␣exists␣at␣the␣specified␣index␣(i.e.,␣the␣queue␣is␣empty,␣or␣the
index␣is␣beyond␣the␣number␣of␣items␣on␣the␣queue),␣then␣C<undef>␣is␣returned.

Remember,␣the␣returned␣item␣is␣not␣removed␣from␣the␣queue,␣so␣manipulating␣a
C<peek>ed␣at␣reference␣affects␣the␣item␣on␣the␣queue.

=item␣->insert(INDEX,␣LIST)

Adds␣the␣list␣of␣items␣to␣the␣queue␣at␣the␣specified␣index␣position␣(0
is␣the␣head␣of␣the␣list).␣␣Any␣existing␣items␣at␣and␣beyond␣that␣position␣are
pushed␣back␣past␣the␣newly␣added␣items:

␣␣␣␣$q->enqueue(1,␣2,␣3,␣4);
␣␣␣␣$q->insert(1,␣qw/foo␣bar/);
␣␣␣␣#␣Queue␣now␣contains:␣␣1,␣foo,␣bar,␣2,␣3,␣4

Specifying␣an␣index␣position␣greater␣than␣the␣number␣of␣items␣in␣the␣queue
just␣adds␣the␣list␣to␣the␣end.

Negative␣index␣positions␣are␣supported:

␣␣␣␣$q->enqueue(1,␣2,␣3,␣4);
␣␣␣␣$q->insert(-2,␣qw/foo␣bar/);
␣␣␣␣#␣Queue␣now␣contains:␣␣1,␣2,␣foo,␣bar,␣3,␣4

Specifying␣a␣negative␣index␣position␣greater␣than␣the␣number␣of␣items␣in␣the
queue␣adds␣the␣list␣to␣the␣head␣of␣the␣queue.

=item␣->extract()

=item␣->extract(INDEX)

=item␣->extract(INDEX,␣COUNT)

Removes␣and␣returns␣the␣specified␣number␣of␣items␣(defaults␣to␣1)␣from␣the
specified␣index␣position␣in␣the␣queue␣(0␣is␣the␣head␣of␣the␣queue).␣␣When
called␣with␣no␣arguments,␣C<extract>␣operates␣the␣same␣as␣C<dequeue_nb>.

This␣method␣is␣non-blocking,␣and␣will␣return␣only␣as␣many␣items␣as␣are
available␣to␣fulfill␣the␣request:

␣␣␣␣$q->enqueue(1,␣2,␣3,␣4);
␣␣␣␣my␣$item␣␣=␣$q->extract(2)␣␣␣␣␣#␣Returns␣3
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣Queue␣now␣contains:␣␣1,␣2,␣4
␣␣␣␣my␣@items␣=␣$q->extract(1,␣3)␣␣#␣Returns␣(2,␣4)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣Queue␣now␣contains:␣␣1

Specifying␣an␣index␣position␣greater␣than␣the␣number␣of␣items␣in␣the
queue␣results␣in␣C<undef>␣or␣an␣empty␣list␣being␣returned.

␣␣␣␣$q->enqueue('foo');
␣␣␣␣my␣$nada␣=␣$q->extract(3)␣␣␣␣␣␣#␣Returns␣undef
␣␣␣␣my␣@nada␣=␣$q->extract(1,␣3)␣␣␣#␣Returns␣()

Negative␣index␣positions␣are␣supported.␣␣Specifying␣a␣negative␣index␣position
greater␣than␣the␣number␣of␣items␣in␣the␣queue␣may␣return␣items␣from␣the␣head
of␣the␣queue␣(similar␣to␣C<dequeue_nb>)␣if␣the␣count␣overlaps␣the␣head␣of␣the
queue␣from␣the␣specified␣position␣(i.e.␣if␣queue␣size␣+␣index␣+␣count␣is
greater␣than␣zero):

␣␣␣␣$q->enqueue(qw/foo␣bar␣baz/);
␣␣␣␣my␣@nada␣=␣$q->extract(-6,␣2);␣␣␣#␣Returns␣()␣␣␣␣␣␣␣␣␣-␣(3+(-6)+2)␣<=␣0
␣␣␣␣my␣@some␣=␣$q->extract(-6,␣4);␣␣␣#␣Returns␣(foo)␣␣␣␣␣␣-␣(3+(-6)+4)␣>␣0
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣Queue␣now␣contains:␣␣bar,␣baz
␣␣␣␣my␣@rest␣=␣$q->extract(-3,␣4);␣␣␣#␣Returns␣(bar,␣baz)␣-␣(2+(-3)+4)␣>␣0

=back

=head1␣NOTES

Queues␣created␣by␣L<Thread::Queue>␣can␣be␣used␣in␣both␣threaded␣and
non-threaded␣applications.

=head1␣LIMITATIONS

Passing␣objects␣on␣queues␣may␣not␣work␣if␣the␣objects'␣classes␣do␣not␣support
sharing.␣␣See␣L<threads::shared/"BUGS␣AND␣LIMITATIONS">␣for␣more.

Passing␣array/hash␣refs␣that␣contain␣objects␣may␣not␣work␣for␣Perl␣prior␣to
5.10.0.

=head1␣SEE␣ALSO

Thread::Queue␣Discussion␣Forum␣on␣CPAN:
L<http://www.cpanforum.com/dist/Thread-Queue>

Annotated␣POD␣for␣Thread::Queue:
L<http://annocpan.org/~JDHEDDEN/Thread-Queue-2.11/lib/Thread/Queue.pm>

Source␣repository:
L<http://code.google.com/p/thread-queue/>

L<threads>,␣L<threads::shared>

=head1␣MAINTAINER

Jerry␣D.␣Hedden,␣S<E<lt>jdhedden␣AT␣cpan␣DOT␣orgE<gt>>

=head1␣LICENSE

This␣program␣is␣free␣software;␣you␣can␣redistribute␣it␣and/or␣modify␣it␣under
the␣same␣terms␣as␣Perl␣itself.

=cut
----------
Range: (1899749,1908001) (8252)
=head1␣TREE-BASED␣PARSING

If␣straightforward␣stream-based␣parsing␣wont␣meet␣your␣needs␣(as␣is
likely␣the␣case␣for␣tasks␣such␣as␣translating␣PODs␣into␣structured
markup␣languages␣like␣HTML␣and␣XML)␣then␣you␣may␣need␣to␣take␣the
tree-based␣approach.␣Rather␣than␣doing␣everything␣in␣one␣pass␣and
calling␣the␣B<interpolate()>␣method␣to␣expand␣sequences␣into␣text,␣it
may␣be␣desirable␣to␣instead␣create␣a␣parse-tree␣using␣the␣B<parse_text()>
method␣to␣return␣a␣tree-like␣structure␣which␣may␣contain␣an␣ordered
list␣of␣children␣(each␣of␣which␣may␣be␣a␣text-string,␣or␣a␣similar
tree-like␣structure).

Pay␣special␣attention␣to␣L<"METHODS␣FOR␣PARSING␣AND␣PROCESSING">␣and
to␣the␣objects␣described␣in␣L<Pod::InputObjects>.␣The␣former␣describes
the␣gory␣details␣and␣parameters␣for␣how␣to␣customize␣and␣extend␣the
parsing␣behavior␣of␣B<Pod::Parser>.␣B<Pod::InputObjects>␣provides
several␣objects␣that␣may␣all␣be␣used␣interchangeably␣as␣parse-trees.␣The
most␣obvious␣one␣is␣the␣B<Pod::ParseTree>␣object.␣It␣defines␣the␣basic
interface␣and␣functionality␣that␣all␣things␣trying␣to␣be␣a␣POD␣parse-tree
should␣do.␣A␣B<Pod::ParseTree>␣is␣defined␣such␣that␣each␣"node"␣may␣be␣a
text-string,␣or␣a␣reference␣to␣another␣parse-tree.␣␣Each␣B<Pod::Paragraph>
object␣and␣each␣B<Pod::InteriorSequence>␣object␣also␣supports␣the␣basic
parse-tree␣interface.

The␣B<parse_text()>␣method␣takes␣a␣given␣paragraph␣of␣text,␣and
returns␣a␣parse-tree␣that␣contains␣one␣or␣more␣children,␣each␣of␣which
may␣be␣a␣text-string,␣or␣an␣InteriorSequence␣object.␣There␣are␣also
callback-options␣that␣may␣be␣passed␣to␣B<parse_text()>␣to␣customize
the␣way␣it␣expands␣or␣transforms␣interior-sequences,␣as␣well␣as␣the
returned␣result.␣These␣callbacks␣can␣be␣used␣to␣create␣a␣parse-tree
with␣custom-made␣objects␣(which␣may␣or␣may␣not␣support␣the␣parse-tree
interface,␣depending␣on␣how␣you␣choose␣to␣do␣it).

If␣you␣wish␣to␣turn␣an␣entire␣POD␣document␣into␣a␣parse-tree,␣that␣process
is␣fairly␣straightforward.␣The␣B<parse_text()>␣method␣is␣the␣key␣to␣doing
this␣successfully.␣Every␣paragraph-callback␣(i.e.␣the␣polymorphic␣methods
for␣B<command()>,␣B<verbatim()>,␣and␣B<textblock()>␣paragraphs)␣takes
a␣B<Pod::Paragraph>␣object␣as␣an␣argument.␣Each␣paragraph␣object␣has␣a
B<parse_tree()>␣method␣that␣can␣be␣used␣to␣get␣or␣set␣a␣corresponding
parse-tree.␣So␣for␣each␣of␣those␣paragraph-callback␣methods,␣simply␣call
B<parse_text()>␣with␣the␣options␣you␣desire,␣and␣then␣use␣the␣returned
parse-tree␣to␣assign␣to␣the␣given␣paragraph␣object.

That␣gives␣you␣a␣parse-tree␣for␣each␣paragraph␣-␣so␣now␣all␣you␣need␣is
an␣ordered␣list␣of␣paragraphs.␣You␣can␣maintain␣that␣yourself␣as␣a␣data
element␣in␣the␣object/hash.␣The␣most␣straightforward␣way␣would␣be␣simply
to␣use␣an␣array-ref,␣with␣the␣desired␣set␣of␣custom␣"options"␣for␣each
invocation␣of␣B<parse_text>.␣Let's␣assume␣the␣desired␣option-set␣is
given␣by␣the␣hash␣C<%options>.␣Then␣we␣might␣do␣something␣like␣the
following:

␣␣␣␣package␣MyPodParserTree;

␣␣␣␣@ISA␣=␣qw(␣Pod::Parser␣);

␣␣␣␣...

␣␣␣␣sub␣begin_pod␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣$self->{'-paragraphs'}␣=␣[];␣␣##␣initialize␣paragraph␣list
␣␣␣␣}

␣␣␣␣sub␣command␣{␣
␣␣␣␣␣␣␣␣my␣($parser,␣$command,␣$paragraph,␣$line_num,␣$pod_para)␣=␣@_;
␣␣␣␣␣␣␣␣my␣$ptree␣=␣$parser->parse_text({%options},␣$paragraph,␣...);
␣␣␣␣␣␣␣␣$pod_para->parse_tree(␣$ptree␣);
␣␣␣␣␣␣␣␣push␣@{␣$self->{'-paragraphs'}␣},␣$pod_para;
␣␣␣␣}

␣␣␣␣sub␣verbatim␣{␣
␣␣␣␣␣␣␣␣my␣($parser,␣$paragraph,␣$line_num,␣$pod_para)␣=␣@_;
␣␣␣␣␣␣␣␣push␣@{␣$self->{'-paragraphs'}␣},␣$pod_para;
␣␣␣␣}

␣␣␣␣sub␣textblock␣{␣
␣␣␣␣␣␣␣␣my␣($parser,␣$paragraph,␣$line_num,␣$pod_para)␣=␣@_;
␣␣␣␣␣␣␣␣my␣$ptree␣=␣$parser->parse_text({%options},␣$paragraph,␣...);
␣␣␣␣␣␣␣␣$pod_para->parse_tree(␣$ptree␣);
␣␣␣␣␣␣␣␣push␣@{␣$self->{'-paragraphs'}␣},␣$pod_para;
␣␣␣␣}

␣␣␣␣...

␣␣␣␣package␣main;
␣␣␣␣...
␣␣␣␣my␣$parser␣=␣new␣MyPodParserTree(...);
␣␣␣␣$parser->parse_from_file(...);
␣␣␣␣my␣$paragraphs_ref␣=␣$parser->{'-paragraphs'};

Of␣course,␣in␣this␣module-author's␣humble␣opinion,␣I'd␣be␣more␣inclined␣to
use␣the␣existing␣B<Pod::ParseTree>␣object␣than␣a␣simple␣array.␣That␣way
everything␣in␣it,␣paragraphs␣and␣sequences,␣all␣respond␣to␣the␣same␣core
interface␣for␣all␣parse-tree␣nodes.␣The␣result␣would␣look␣something␣like:

␣␣␣␣package␣MyPodParserTree2;

␣␣␣␣...

␣␣␣␣sub␣begin_pod␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣$self->{'-ptree'}␣=␣new␣Pod::ParseTree;␣␣##␣initialize␣parse-tree
␣␣␣␣}

␣␣␣␣sub␣parse_tree␣{
␣␣␣␣␣␣␣␣##␣convenience␣method␣to␣get/set␣the␣parse-tree␣for␣the␣entire␣POD
␣␣␣␣␣␣␣␣(@_␣>␣1)␣␣and␣␣$_[0]->{'-ptree'}␣=␣$_[1];
␣␣␣␣␣␣␣␣return␣$_[0]->{'-ptree'};
␣␣␣␣}

␣␣␣␣sub␣command␣{␣
␣␣␣␣␣␣␣␣my␣($parser,␣$command,␣$paragraph,␣$line_num,␣$pod_para)␣=␣@_;
␣␣␣␣␣␣␣␣my␣$ptree␣=␣$parser->parse_text({<<options>>},␣$paragraph,␣...);
␣␣␣␣␣␣␣␣$pod_para->parse_tree(␣$ptree␣);
␣␣␣␣␣␣␣␣$parser->parse_tree()->append(␣$pod_para␣);
␣␣␣␣}

␣␣␣␣sub␣verbatim␣{␣
␣␣␣␣␣␣␣␣my␣($parser,␣$paragraph,␣$line_num,␣$pod_para)␣=␣@_;
␣␣␣␣␣␣␣␣$parser->parse_tree()->append(␣$pod_para␣);
␣␣␣␣}

␣␣␣␣sub␣textblock␣{␣
␣␣␣␣␣␣␣␣my␣($parser,␣$paragraph,␣$line_num,␣$pod_para)␣=␣@_;
␣␣␣␣␣␣␣␣my␣$ptree␣=␣$parser->parse_text({<<options>>},␣$paragraph,␣...);
␣␣␣␣␣␣␣␣$pod_para->parse_tree(␣$ptree␣);
␣␣␣␣␣␣␣␣$parser->parse_tree()->append(␣$pod_para␣);
␣␣␣␣}

␣␣␣␣...

␣␣␣␣package␣main;
␣␣␣␣...
␣␣␣␣my␣$parser␣=␣new␣MyPodParserTree2(...);
␣␣␣␣$parser->parse_from_file(...);
␣␣␣␣my␣$ptree␣=␣$parser->parse_tree;
␣␣␣␣...

Now␣you␣have␣the␣entire␣POD␣document␣as␣one␣great␣big␣parse-tree.␣You
can␣even␣use␣the␣B<-expand_seq>␣option␣to␣B<parse_text>␣to␣insert
whole␣different␣kinds␣of␣objects.␣Just␣don't␣expect␣B<Pod::Parser>
to␣know␣what␣to␣do␣with␣them␣after␣that.␣That␣will␣need␣to␣be␣in␣your
code.␣Or,␣alternatively,␣you␣can␣insert␣any␣object␣you␣like␣so␣long␣as
it␣conforms␣to␣the␣B<Pod::ParseTree>␣interface.

One␣could␣use␣this␣to␣create␣subclasses␣of␣B<Pod::Paragraphs>␣and
B<Pod::InteriorSequences>␣for␣specific␣commands␣(or␣to␣create␣your␣own
custom␣node-types␣in␣the␣parse-tree)␣and␣add␣some␣kind␣of␣B<emit()>
method␣to␣each␣custom␣node/subclass␣object␣in␣the␣tree.␣Then␣all␣you'd
need␣to␣do␣is␣recursively␣walk␣the␣tree␣in␣the␣desired␣order,␣processing
the␣children␣(most␣likely␣from␣left␣to␣right)␣by␣formatting␣them␣if
they␣are␣text-strings,␣or␣by␣calling␣their␣B<emit()>␣method␣if␣they
are␣objects/references.

=head1␣CAVEATS

Please␣note␣that␣POD␣has␣the␣notion␣of␣"paragraphs":␣this␣is␣something
starting␣I<after>␣a␣blank␣(read:␣empty)␣line,␣with␣the␣single␣exception
of␣the␣file␣start,␣which␣is␣also␣starting␣a␣paragraph.␣That␣means␣that
especially␣a␣command␣(e.g.␣C<=head1>)␣I<must>␣be␣preceded␣with␣a␣blank
line;␣C<__END__>␣is␣I<not>␣a␣blank␣line.

=head1␣SEE␣ALSO

L<Pod::InputObjects>,␣L<Pod::Select>

B<Pod::InputObjects>␣defines␣POD␣input␣objects␣corresponding␣to
command␣paragraphs,␣parse-trees,␣and␣interior-sequences.

B<Pod::Select>␣is␣a␣subclass␣of␣B<Pod::Parser>␣which␣provides␣the␣ability
to␣selectively␣include␣and/or␣exclude␣sections␣of␣a␣POD␣document␣from␣being
translated␣based␣upon␣the␣current␣heading,␣subheading,␣subsubheading,␣etc.

=for␣__PRIVATE__
B<Pod::Callbacks>␣is␣a␣subclass␣of␣B<Pod::Parser>␣which␣gives␣its␣users
the␣ability␣the␣employ␣I<callback␣functions>␣instead␣of,␣or␣in␣addition
to,␣overriding␣methods␣of␣the␣base␣class.

=for␣__PRIVATE__
B<Pod::Select>␣and␣B<Pod::Callbacks>␣do␣not␣override␣any
methods␣nor␣do␣they␣define␣any␣new␣methods␣with␣the␣same␣name.␣Because
of␣this,␣they␣may␣I<both>␣be␣used␣(in␣combination)␣as␣a␣base␣class␣of
the␣same␣subclass␣in␣order␣to␣combine␣their␣functionality␣without
causing␣any␣namespace␣clashes␣due␣to␣multiple␣inheritance.

=head1␣AUTHOR

Please␣report␣bugs␣using␣L<http://rt.cpan.org>.

Brad␣Appleton␣E<lt>bradapp@enteract.comE<gt>

Based␣on␣code␣for␣B<Pod::Text>␣written␣by
Tom␣Christiansen␣E<lt>tchrist@mox.perl.comE<gt>

=head1␣LICENSE

Pod-Parser␣is␣free␣software;␣you␣can␣redistribute␣it␣and/or␣modify␣it
under␣the␣terms␣of␣the␣Artistic␣License␣distributed␣with␣Perl␣version
5.000␣or␣(at␣your␣option)␣any␣later␣version.␣Please␣refer␣to␣the
Artistic␣License␣that␣came␣with␣your␣Perl␣distribution␣for␣more
details.␣If␣your␣version␣of␣Perl␣was␣not␣distributed␣under␣the
terms␣of␣the␣Artistic␣License,␣than␣you␣may␣distribute␣PodParser
under␣the␣same␣terms␣as␣Perl␣itself.

=cut
----------
Range: (1923941,1933063) (9122)
=head1␣NAME

Pod::Checker,␣podchecker()␣-␣check␣pod␣documents␣for␣syntax␣errors

=head1␣SYNOPSIS

␣␣use␣Pod::Checker;

␣␣$syntax_okay␣=␣podchecker($filepath,␣$outputpath,␣%options);

␣␣my␣$checker␣=␣new␣Pod::Checker␣%options;
␣␣$checker->parse_from_file($filepath,␣\*STDERR);

=head1␣OPTIONS/ARGUMENTS

C<$filepath>␣is␣the␣input␣POD␣to␣read␣and␣C<$outputpath>␣is
where␣to␣write␣POD␣syntax␣error␣messages.␣Either␣argument␣may␣be␣a␣scalar
indicating␣a␣file-path,␣or␣else␣a␣reference␣to␣an␣open␣filehandle.
If␣unspecified,␣the␣input-file␣it␣defaults␣to␣C<\*STDIN>,␣and
the␣output-file␣defaults␣to␣C<\*STDERR>.

=head2␣podchecker()

This␣function␣can␣take␣a␣hash␣of␣options:

=over␣4

=item␣B<-warnings>␣=E<gt>␣I<val>

Turn␣warnings␣on/off.␣I<val>␣is␣usually␣1␣for␣on,␣but␣higher␣values
trigger␣additional␣warnings.␣See␣L<"Warnings">.

=back

=head1␣DESCRIPTION

B<podchecker>␣will␣perform␣syntax␣checking␣of␣Perl5␣POD␣format␣documentation.

Curious/ambitious␣users␣are␣welcome␣to␣propose␣additional␣features␣they␣wish
to␣see␣in␣B<Pod::Checker>␣and␣B<podchecker>␣and␣verify␣that␣the␣checks␣are
consistent␣with␣L<perlpod>.

The␣following␣checks␣are␣currently␣performed:

=over␣4

=item␣*

Unknown␣'=xxxx'␣commands,␣unknown␣'XE<lt>...E<gt>'␣interior-sequences,
and␣unterminated␣interior␣sequences.

=item␣*

Check␣for␣proper␣balancing␣of␣C<=begin>␣and␣C<=end>.␣The␣contents␣of␣such
a␣block␣are␣generally␣ignored,␣i.e.␣no␣syntax␣checks␣are␣performed.

=item␣*

Check␣for␣proper␣nesting␣and␣balancing␣of␣C<=over>,␣C<=item>␣and␣C<=back>.

=item␣*

Check␣for␣same␣nested␣interior-sequences␣(e.g.
C<LE<lt>...LE<lt>...E<gt>...E<gt>>).

=item␣*

Check␣for␣malformed␣or␣non-existing␣entities␣C<EE<lt>...E<gt>>.

=item␣*

Check␣for␣correct␣syntax␣of␣hyperlinks␣C<LE<lt>...E<gt>>.␣See␣L<perlpod>
for␣details.

=item␣*

Check␣for␣unresolved␣document-internal␣links.␣This␣check␣may␣also␣reveal
misspelled␣links␣that␣seem␣to␣be␣internal␣links␣but␣should␣be␣links
to␣something␣else.

=back

=head1␣DIAGNOSTICS

=head2␣Errors

=over␣4

=item␣*␣empty␣=headn

A␣heading␣(C<=head1>␣or␣C<=head2>)␣without␣any␣text?␣That␣ain't␣no
heading!

=item␣*␣=over␣on␣line␣I<N>␣without␣closing␣=back

The␣C<=over>␣command␣does␣not␣have␣a␣corresponding␣C<=back>␣before␣the
next␣heading␣(C<=head1>␣or␣C<=head2>)␣or␣the␣end␣of␣the␣file.

=item␣*␣=item␣without␣previous␣=over

=item␣*␣=back␣without␣previous␣=over

An␣C<=item>␣or␣C<=back>␣command␣has␣been␣found␣outside␣a
C<=over>/C<=back>␣block.

=item␣*␣No␣argument␣for␣=begin

A␣C<=begin>␣command␣was␣found␣that␣is␣not␣followed␣by␣the␣formatter
specification.

=item␣*␣=end␣without␣=begin

A␣standalone␣C<=end>␣command␣was␣found.

=item␣*␣Nested␣=begin's

There␣were␣at␣least␣two␣consecutive␣C<=begin>␣commands␣without
the␣corresponding␣C<=end>.␣Only␣one␣C<=begin>␣may␣be␣active␣at
a␣time.

=item␣*␣=for␣without␣formatter␣specification

There␣is␣no␣specification␣of␣the␣formatter␣after␣the␣C<=for>␣command.

=item␣*␣unresolved␣internal␣link␣I<NAME>

The␣given␣link␣to␣I<NAME>␣does␣not␣have␣a␣matching␣node␣in␣the␣current
POD.␣This␣also␣happened␣when␣a␣single␣word␣node␣name␣is␣not␣enclosed␣in
C<"">.

=item␣*␣Unknown␣command␣"I<CMD>"

An␣invalid␣POD␣command␣has␣been␣found.␣Valid␣are␣C<=head1>,␣C<=head2>,
C<=head3>,␣C<=head4>,␣C<=over>,␣C<=item>,␣C<=back>,␣C<=begin>,␣C<=end>,
C<=for>,␣C<=pod>,␣C<=cut>

=item␣*␣Unknown␣interior-sequence␣"I<SEQ>"

An␣invalid␣markup␣command␣has␣been␣encountered.␣Valid␣are:
C<BE<lt>E<gt>>,␣C<CE<lt>E<gt>>,␣C<EE<lt>E<gt>>,␣C<FE<lt>E<gt>>,
C<IE<lt>E<gt>>,␣C<LE<lt>E<gt>>,␣C<SE<lt>E<gt>>,␣C<XE<lt>E<gt>>,
C<ZE<lt>E<gt>>

=item␣*␣nested␣commands␣I<CMD>E<lt>...I<CMD>E<lt>...E<gt>...E<gt>

Two␣nested␣identical␣markup␣commands␣have␣been␣found.␣Generally␣this
does␣not␣make␣sense.

=item␣*␣garbled␣entity␣I<STRING>

The␣I<STRING>␣found␣cannot␣be␣interpreted␣as␣a␣character␣entity.

=item␣*␣Entity␣number␣out␣of␣range

An␣entity␣specified␣by␣number␣(dec,␣hex,␣oct)␣is␣out␣of␣range␣(1-255).

=item␣*␣malformed␣link␣LE<lt>E<gt>

The␣link␣found␣cannot␣be␣parsed␣because␣it␣does␣not␣conform␣to␣the
syntax␣described␣in␣L<perlpod>.

=item␣*␣nonempty␣ZE<lt>E<gt>

The␣C<ZE<lt>E<gt>>␣sequence␣is␣supposed␣to␣be␣empty.

=item␣*␣empty␣XE<lt>E<gt>

The␣index␣entry␣specified␣contains␣nothing␣but␣whitespace.

=item␣*␣Spurious␣text␣after␣=pod␣/␣=cut

The␣commands␣C<=pod>␣and␣C<=cut>␣do␣not␣take␣any␣arguments.

=item␣*␣Spurious␣character(s)␣after␣=back

The␣C<=back>␣command␣does␣not␣take␣any␣arguments.

=back

=head2␣Warnings

These␣may␣not␣necessarily␣cause␣trouble,␣but␣indicate␣mediocre␣style.

=over␣4

=item␣*␣multiple␣occurrence␣of␣link␣target␣I<name>

The␣POD␣file␣has␣some␣C<=item>␣and/or␣C<=head>␣commands␣that␣have
the␣same␣text.␣Potential␣hyperlinks␣to␣such␣a␣text␣cannot␣be␣unique␣then.
This␣warning␣is␣printed␣only␣with␣warning␣level␣greater␣than␣one.

=item␣*␣line␣containing␣nothing␣but␣whitespace␣in␣paragraph

There␣is␣some␣whitespace␣on␣a␣seemingly␣empty␣line.␣POD␣is␣very␣sensitive
to␣such␣things,␣so␣this␣is␣flagged.␣B<vi>␣users␣switch␣on␣the␣B<list>
option␣to␣avoid␣this␣problem.

=begin␣_disabled_

=item␣*␣file␣does␣not␣start␣with␣=head

The␣file␣starts␣with␣a␣different␣POD␣directive␣than␣head.
This␣is␣most␣probably␣something␣you␣do␣not␣want.

=end␣_disabled_

=item␣*␣previous␣=item␣has␣no␣contents

There␣is␣a␣list␣C<=item>␣right␣above␣the␣flagged␣line␣that␣has␣no
text␣contents.␣You␣probably␣want␣to␣delete␣empty␣items.

=item␣*␣preceding␣non-item␣paragraph(s)

A␣list␣introduced␣by␣C<=over>␣starts␣with␣a␣text␣or␣verbatim␣paragraph,
but␣continues␣with␣C<=item>s.␣Move␣the␣non-item␣paragraph␣out␣of␣the
C<=over>/C<=back>␣block.

=item␣*␣=item␣type␣mismatch␣(I<one>␣vs.␣I<two>)

A␣list␣started␣with␣e.g.␣a␣bullet-like␣C<=item>␣and␣continued␣with␣a
numbered␣one.␣This␣is␣obviously␣inconsistent.␣For␣most␣translators␣the
type␣of␣the␣I<first>␣C<=item>␣determines␣the␣type␣of␣the␣list.

=item␣*␣I<N>␣unescaped␣C<E<lt>E<gt>>␣in␣paragraph

Angle␣brackets␣not␣written␣as␣C<E<lt>ltE<gt>>␣and␣C<E<lt>gtE<gt>>
can␣potentially␣cause␣errors␣as␣they␣could␣be␣misinterpreted␣as
markup␣commands.␣This␣is␣only␣printed␣when␣the␣-warnings␣level␣is
greater␣than␣1.

=item␣*␣Unknown␣entity

A␣character␣entity␣was␣found␣that␣does␣not␣belong␣to␣the␣standard
ISO␣set␣or␣the␣POD␣specials␣C<verbar>␣and␣C<sol>.

=item␣*␣No␣items␣in␣=over

The␣list␣opened␣with␣C<=over>␣does␣not␣contain␣any␣items.

=item␣*␣No␣argument␣for␣=item

C<=item>␣without␣any␣parameters␣is␣deprecated.␣It␣should␣either␣be␣followed
by␣C<*>␣to␣indicate␣an␣unordered␣list,␣by␣a␣number␣(optionally␣followed
by␣a␣dot)␣to␣indicate␣an␣ordered␣(numbered)␣list␣or␣simple␣text␣for␣a
definition␣list.

=item␣*␣empty␣section␣in␣previous␣paragraph

The␣previous␣section␣(introduced␣by␣a␣C<=head>␣command)␣does␣not␣contain
any␣text.␣This␣usually␣indicates␣that␣something␣is␣missing.␣Note:␣A
C<=head1>␣followed␣immediately␣by␣C<=head2>␣does␣not␣trigger␣this␣warning.

=item␣*␣Verbatim␣paragraph␣in␣NAME␣section

The␣NAME␣section␣(C<=head1␣NAME>)␣should␣consist␣of␣a␣single␣paragraph
with␣the␣script/module␣name,␣followed␣by␣a␣dash␣`-'␣and␣a␣very␣short
description␣of␣what␣the␣thing␣is␣good␣for.

=item␣*␣=headI<n>␣without␣preceding␣higher␣level

For␣example␣if␣there␣is␣a␣C<=head2>␣in␣the␣POD␣file␣prior␣to␣a
C<=head1>.

=back

=head2␣Hyperlinks

There␣are␣some␣warnings␣with␣respect␣to␣malformed␣hyperlinks:

=over␣4

=item␣*␣ignoring␣leading/trailing␣whitespace␣in␣link

There␣is␣whitespace␣at␣the␣beginning␣or␣the␣end␣of␣the␣contents␣of
LE<lt>...E<gt>.

=item␣*␣(section)␣in␣'$page'␣deprecated

There␣is␣a␣section␣detected␣in␣the␣page␣name␣of␣LE<lt>...E<gt>,␣e.g.
C<LE<lt>passwd(2)E<gt>>.␣POD␣hyperlinks␣may␣point␣to␣POD␣documents␣only.
Please␣write␣C<CE<lt>passwd(2)E<gt>>␣instead.␣Some␣formatters␣are␣able
to␣expand␣this␣to␣appropriate␣code.␣For␣links␣to␣(builtin)␣functions,
please␣say␣C<LE<lt>perlfunc/mkdirE<gt>>,␣without␣().

=item␣*␣alternative␣text/node␣'%s'␣contains␣non-escaped␣|␣or␣/

The␣characters␣C<|>␣and␣C</>␣are␣special␣in␣the␣LE<lt>...E<gt>␣context.
Although␣the␣hyperlink␣parser␣does␣its␣best␣to␣determine␣which␣"/"␣is
text␣and␣which␣is␣a␣delimiter␣in␣case␣of␣doubt,␣one␣ought␣to␣escape
these␣literal␣characters␣like␣this:

␣␣/␣␣␣␣␣E<sol>
␣␣|␣␣␣␣␣E<verbar>

=back

=head1␣RETURN␣VALUE

B<podchecker>␣returns␣the␣number␣of␣POD␣syntax␣errors␣found␣or␣-1␣if
there␣were␣no␣POD␣commands␣at␣all␣found␣in␣the␣file.

=head1␣EXAMPLES

See␣L</SYNOPSIS>

=head1␣INTERFACE

While␣checking,␣this␣module␣collects␣document␣properties,␣e.g.␣the␣nodes
for␣hyperlinks␣(C<=headX>,␣C<=item>)␣and␣index␣entries␣(C<XE<lt>E<gt>>).
POD␣translators␣can␣use␣this␣feature␣to␣syntax-check␣and␣get␣the␣nodes␣in
a␣first␣pass␣before␣actually␣starting␣to␣convert.␣This␣is␣expensive␣in␣terms
of␣execution␣time,␣but␣allows␣for␣very␣robust␣conversions.

Since␣PodParser-1.24␣the␣B<Pod::Checker>␣module␣uses␣only␣the␣B<poderror>
method␣to␣print␣errors␣and␣warnings.␣The␣summary␣output␣(e.g.
"Pod␣syntax␣OK")␣has␣been␣dropped␣from␣the␣module␣and␣has␣been␣included␣in
B<podchecker>␣(the␣script).␣This␣allows␣users␣of␣B<Pod::Checker>␣to
control␣completely␣the␣output␣behavior.␣Users␣of␣B<podchecker>␣(the␣script)
get␣the␣well-known␣behavior.

=cut
----------
Range: (2485747,2498916) (13169)
=head1␣NAME

Pod::Usage,␣pod2usage()␣-␣print␣a␣usage␣message␣from␣embedded␣pod␣documentation

=head1␣SYNOPSIS

␣␣use␣Pod::Usage

␣␣my␣$message_text␣␣=␣"This␣text␣precedes␣the␣usage␣message.";
␣␣my␣$exit_status␣␣␣=␣2;␣␣␣␣␣␣␣␣␣␣##␣The␣exit␣status␣to␣use
␣␣my␣$verbose_level␣=␣0;␣␣␣␣␣␣␣␣␣␣##␣The␣verbose␣level␣to␣use
␣␣my␣$filehandle␣␣␣␣=␣\*STDERR;␣␣␣##␣The␣filehandle␣to␣write␣to

␣␣pod2usage($message_text);

␣␣pod2usage($exit_status);

␣␣pod2usage(␣{␣-message␣=>␣$message_text␣,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-exitval␣=>␣$exit_status␣␣,␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-verbose␣=>␣$verbose_level,␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-output␣␣=>␣$filehandle␣}␣);

␣␣pod2usage(␣␣␣-msg␣␣␣␣␣=>␣$message_text␣,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-exitval␣=>␣$exit_status␣␣,␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-verbose␣=>␣$verbose_level,␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-output␣␣=>␣$filehandle␣␣␣);

␣␣pod2usage(␣␣␣-verbose␣=>␣2,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣-noperldoc␣=>␣1␣␣)

=head1␣ARGUMENTS

B<pod2usage>␣should␣be␣given␣either␣a␣single␣argument,␣or␣a␣list␣of
arguments␣corresponding␣to␣an␣associative␣array␣(a␣"hash").␣When␣a␣single
argument␣is␣given,␣it␣should␣correspond␣to␣exactly␣one␣of␣the␣following:

=over␣4

=item␣*

A␣string␣containing␣the␣text␣of␣a␣message␣to␣print␣I<before>␣printing
the␣usage␣message

=item␣*

A␣numeric␣value␣corresponding␣to␣the␣desired␣exit␣status

=item␣*

A␣reference␣to␣a␣hash

=back

If␣more␣than␣one␣argument␣is␣given␣then␣the␣entire␣argument␣list␣is
assumed␣to␣be␣a␣hash.␣␣If␣a␣hash␣is␣supplied␣(either␣as␣a␣reference␣or
as␣a␣list)␣it␣should␣contain␣one␣or␣more␣elements␣with␣the␣following
keys:

=over␣4

=item␣C<-message>

=item␣C<-msg>

The␣text␣of␣a␣message␣to␣print␣immediately␣prior␣to␣printing␣the
program's␣usage␣message.␣

=item␣C<-exitval>

The␣desired␣exit␣status␣to␣pass␣to␣the␣B<exit()>␣function.
This␣should␣be␣an␣integer,␣or␣else␣the␣string␣"NOEXIT"␣to
indicate␣that␣control␣should␣simply␣be␣returned␣without
terminating␣the␣invoking␣process.

=item␣C<-verbose>

The␣desired␣level␣of␣"verboseness"␣to␣use␣when␣printing␣the␣usage
message.␣If␣the␣corresponding␣value␣is␣0,␣then␣only␣the␣"SYNOPSIS"
section␣of␣the␣pod␣documentation␣is␣printed.␣If␣the␣corresponding␣value
is␣1,␣then␣the␣"SYNOPSIS"␣section,␣along␣with␣any␣section␣entitled
"OPTIONS",␣"ARGUMENTS",␣or␣"OPTIONS␣AND␣ARGUMENTS"␣is␣printed.␣␣If␣the
corresponding␣value␣is␣2␣or␣more␣then␣the␣entire␣manpage␣is␣printed.

The␣special␣verbosity␣level␣99␣requires␣to␣also␣specify␣the␣-sections
parameter;␣then␣these␣sections␣are␣extracted␣(see␣L<Pod::Select>)
and␣printed.

=item␣C<-sections>

A␣string␣representing␣a␣selection␣list␣for␣sections␣to␣be␣printed
when␣-verbose␣is␣set␣to␣99,␣e.g.␣C<"NAME|SYNOPSIS|DESCRIPTION|VERSION">.

Alternatively,␣an␣array␣reference␣of␣section␣specifications␣can␣be␣used:

␣␣pod2usage(-verbose␣=>␣99,␣
␣␣␣␣␣␣␣␣␣␣␣␣-sections␣=>␣[␣qw(fred␣fred/subsection)␣]␣);

=item␣C<-output>

A␣reference␣to␣a␣filehandle,␣or␣the␣pathname␣of␣a␣file␣to␣which␣the
usage␣message␣should␣be␣written.␣The␣default␣is␣C<\*STDERR>␣unless␣the
exit␣value␣is␣less␣than␣2␣(in␣which␣case␣the␣default␣is␣C<\*STDOUT>).

=item␣C<-input>

A␣reference␣to␣a␣filehandle,␣or␣the␣pathname␣of␣a␣file␣from␣which␣the
invoking␣script's␣pod␣documentation␣should␣be␣read.␣␣It␣defaults␣to␣the
file␣indicated␣by␣C<$0>␣(C<$PROGRAM_NAME>␣for␣users␣of␣F<English.pm>).

If␣you␣are␣calling␣B<pod2usage()>␣from␣a␣module␣and␣want␣to␣display
that␣module's␣POD,␣you␣can␣use␣this:

␣␣use␣Pod::Find␣qw(pod_where);
␣␣pod2usage(␣-input␣=>␣pod_where({-inc␣=>␣1},␣__PACKAGE__)␣);

=item␣C<-pathlist>

A␣list␣of␣directory␣paths.␣If␣the␣input␣file␣does␣not␣exist,␣then␣it
will␣be␣searched␣for␣in␣the␣given␣directory␣list␣(in␣the␣order␣the
directories␣appear␣in␣the␣list).␣It␣defaults␣to␣the␣list␣of␣directories
implied␣by␣C<$ENV{PATH}>.␣The␣list␣may␣be␣specified␣either␣by␣a␣reference
to␣an␣array,␣or␣by␣a␣string␣of␣directory␣paths␣which␣use␣the␣same␣path
separator␣as␣C<$ENV{PATH}>␣on␣your␣system␣(e.g.,␣C<:>␣for␣Unix,␣C<;>␣for
MSWin32␣and␣DOS).

=item␣C<-noperldoc>

By␣default,␣Pod::Usage␣will␣call␣L<perldoc>␣when␣-verbose␣>=␣2␣is
specified.␣This␣does␣not␣work␣well␣e.g.␣if␣the␣script␣was␣packed
with␣L<PAR>.␣The␣-noperldoc␣option␣suppresses␣the␣external␣call␣to
L<perldoc>␣and␣uses␣the␣simple␣text␣formatter␣(L<Pod::Text>)␣to␣
output␣the␣POD.

=back

=head1␣DESCRIPTION

B<pod2usage>␣will␣print␣a␣usage␣message␣for␣the␣invoking␣script␣(using
its␣embedded␣pod␣documentation)␣and␣then␣exit␣the␣script␣with␣the
desired␣exit␣status.␣The␣usage␣message␣printed␣may␣have␣any␣one␣of␣three
levels␣of␣"verboseness":␣If␣the␣verbose␣level␣is␣0,␣then␣only␣a␣synopsis
is␣printed.␣If␣the␣verbose␣level␣is␣1,␣then␣the␣synopsis␣is␣printed
along␣with␣a␣description␣(if␣present)␣of␣the␣command␣line␣options␣and
arguments.␣If␣the␣verbose␣level␣is␣2,␣then␣the␣entire␣manual␣page␣is
printed.

Unless␣they␣are␣explicitly␣specified,␣the␣default␣values␣for␣the␣exit
status,␣verbose␣level,␣and␣output␣stream␣to␣use␣are␣determined␣as
follows:

=over␣4

=item␣*

If␣neither␣the␣exit␣status␣nor␣the␣verbose␣level␣is␣specified,␣then␣the
default␣is␣to␣use␣an␣exit␣status␣of␣2␣with␣a␣verbose␣level␣of␣0.

=item␣*

If␣an␣exit␣status␣I<is>␣specified␣but␣the␣verbose␣level␣is␣I<not>,␣then␣the
verbose␣level␣will␣default␣to␣1␣if␣the␣exit␣status␣is␣less␣than␣2␣and
will␣default␣to␣0␣otherwise.

=item␣*

If␣an␣exit␣status␣is␣I<not>␣specified␣but␣verbose␣level␣I<is>␣given,␣then
the␣exit␣status␣will␣default␣to␣2␣if␣the␣verbose␣level␣is␣0␣and␣will
default␣to␣1␣otherwise.

=item␣*

If␣the␣exit␣status␣used␣is␣less␣than␣2,␣then␣output␣is␣printed␣on
C<STDOUT>.␣␣Otherwise␣output␣is␣printed␣on␣C<STDERR>.

=back

Although␣the␣above␣may␣seem␣a␣bit␣confusing␣at␣first,␣it␣generally␣does
"the␣right␣thing"␣in␣most␣situations.␣␣This␣determination␣of␣the␣default
values␣to␣use␣is␣based␣upon␣the␣following␣typical␣Unix␣conventions:

=over␣4

=item␣*

An␣exit␣status␣of␣0␣implies␣"success".␣For␣example,␣B<diff(1)>␣exits
with␣a␣status␣of␣0␣if␣the␣two␣files␣have␣the␣same␣contents.

=item␣*

An␣exit␣status␣of␣1␣implies␣possibly␣abnormal,␣but␣non-defective,␣program
termination.␣␣For␣example,␣B<grep(1)>␣exits␣with␣a␣status␣of␣1␣if
it␣did␣I<not>␣find␣a␣matching␣line␣for␣the␣given␣regular␣expression.

=item␣*

An␣exit␣status␣of␣2␣or␣more␣implies␣a␣fatal␣error.␣For␣example,␣B<ls(1)>
exits␣with␣a␣status␣of␣2␣if␣you␣specify␣an␣illegal␣(unknown)␣option␣on
the␣command␣line.

=item␣*

Usage␣messages␣issued␣as␣a␣result␣of␣bad␣command-line␣syntax␣should␣go
to␣C<STDERR>.␣␣However,␣usage␣messages␣issued␣due␣to␣an␣explicit␣request
to␣print␣usage␣(like␣specifying␣B<-help>␣on␣the␣command␣line)␣should␣go
to␣C<STDOUT>,␣just␣in␣case␣the␣user␣wants␣to␣pipe␣the␣output␣to␣a␣pager
(such␣as␣B<more(1)>).

=item␣*

If␣program␣usage␣has␣been␣explicitly␣requested␣by␣the␣user,␣it␣is␣often
desirable␣to␣exit␣with␣a␣status␣of␣1␣(as␣opposed␣to␣0)␣after␣issuing
the␣user-requested␣usage␣message.␣␣It␣is␣also␣desirable␣to␣give␣a
more␣verbose␣description␣of␣program␣usage␣in␣this␣case.

=back

B<pod2usage>␣doesn't␣force␣the␣above␣conventions␣upon␣you,␣but␣it␣will
use␣them␣by␣default␣if␣you␣don't␣expressly␣tell␣it␣to␣do␣otherwise.␣␣The
ability␣of␣B<pod2usage()>␣to␣accept␣a␣single␣number␣or␣a␣string␣makes␣it
convenient␣to␣use␣as␣an␣innocent␣looking␣error␣message␣handling␣function:

␣␣␣␣use␣Pod::Usage;
␣␣␣␣use␣Getopt::Long;

␣␣␣␣##␣Parse␣options
␣␣␣␣GetOptions("help",␣"man",␣"flag1")␣␣||␣␣pod2usage(2);
␣␣␣␣pod2usage(1)␣␣if␣($opt_help);
␣␣␣␣pod2usage(-verbose␣=>␣2)␣␣if␣($opt_man);

␣␣␣␣##␣Check␣for␣too␣many␣filenames
␣␣␣␣pod2usage("$0:␣Too␣many␣files␣given.\n")␣␣if␣(@ARGV␣>␣1);

Some␣user's␣however␣may␣feel␣that␣the␣above␣"economy␣of␣expression"␣is
not␣particularly␣readable␣nor␣consistent␣and␣may␣instead␣choose␣to␣do
something␣more␣like␣the␣following:

␣␣␣␣use␣Pod::Usage;
␣␣␣␣use␣Getopt::Long;

␣␣␣␣##␣Parse␣options
␣␣␣␣GetOptions("help",␣"man",␣"flag1")␣␣||␣␣pod2usage(-verbose␣=>␣0);
␣␣␣␣pod2usage(-verbose␣=>␣1)␣␣if␣($opt_help);
␣␣␣␣pod2usage(-verbose␣=>␣2)␣␣if␣($opt_man);

␣␣␣␣##␣Check␣for␣too␣many␣filenames
␣␣␣␣pod2usage(-verbose␣=>␣2,␣-message␣=>␣"$0:␣Too␣many␣files␣given.\n")
␣␣␣␣␣␣␣␣if␣(@ARGV␣>␣1);

As␣with␣all␣things␣in␣Perl,␣I<there's␣more␣than␣one␣way␣to␣do␣it>,␣and
B<pod2usage()>␣adheres␣to␣this␣philosophy.␣␣If␣you␣are␣interested␣in
seeing␣a␣number␣of␣different␣ways␣to␣invoke␣B<pod2usage>␣(although␣by␣no
means␣exhaustive),␣please␣refer␣to␣L<"EXAMPLES">.

=head1␣EXAMPLES

Each␣of␣the␣following␣invocations␣of␣C<pod2usage()>␣will␣print␣just␣the
"SYNOPSIS"␣section␣to␣C<STDERR>␣and␣will␣exit␣with␣a␣status␣of␣2:

␣␣␣␣pod2usage();

␣␣␣␣pod2usage(2);

␣␣␣␣pod2usage(-verbose␣=>␣0);

␣␣␣␣pod2usage(-exitval␣=>␣2);

␣␣␣␣pod2usage({-exitval␣=>␣2,␣-output␣=>␣\*STDERR});

␣␣␣␣pod2usage({-verbose␣=>␣0,␣-output␣␣=>␣\*STDERR});

␣␣␣␣pod2usage(-exitval␣=>␣2,␣-verbose␣=>␣0);

␣␣␣␣pod2usage(-exitval␣=>␣2,␣-verbose␣=>␣0,␣-output␣=>␣\*STDERR);

Each␣of␣the␣following␣invocations␣of␣C<pod2usage()>␣will␣print␣a␣message
of␣"Syntax␣error."␣(followed␣by␣a␣newline)␣to␣C<STDERR>,␣immediately
followed␣by␣just␣the␣"SYNOPSIS"␣section␣(also␣printed␣to␣C<STDERR>)␣and
will␣exit␣with␣a␣status␣of␣2:

␣␣␣␣pod2usage("Syntax␣error.");

␣␣␣␣pod2usage(-message␣=>␣"Syntax␣error.",␣-verbose␣=>␣0);

␣␣␣␣pod2usage(-msg␣␣=>␣"Syntax␣error.",␣-exitval␣=>␣2);

␣␣␣␣pod2usage({-msg␣=>␣"Syntax␣error.",␣-exitval␣=>␣2,␣-output␣=>␣\*STDERR});

␣␣␣␣pod2usage({-msg␣=>␣"Syntax␣error.",␣-verbose␣=>␣0,␣-output␣=>␣\*STDERR});

␣␣␣␣pod2usage(-msg␣␣=>␣"Syntax␣error.",␣-exitval␣=>␣2,␣-verbose␣=>␣0);

␣␣␣␣pod2usage(-message␣=>␣"Syntax␣error.",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣-exitval␣=>␣2,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣-verbose␣=>␣0,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣-output␣␣=>␣\*STDERR);

Each␣of␣the␣following␣invocations␣of␣C<pod2usage()>␣will␣print␣the
"SYNOPSIS"␣section␣and␣any␣"OPTIONS"␣and/or␣"ARGUMENTS"␣sections␣to
C<STDOUT>␣and␣will␣exit␣with␣a␣status␣of␣1:

␣␣␣␣pod2usage(1);

␣␣␣␣pod2usage(-verbose␣=>␣1);

␣␣␣␣pod2usage(-exitval␣=>␣1);

␣␣␣␣pod2usage({-exitval␣=>␣1,␣-output␣=>␣\*STDOUT});

␣␣␣␣pod2usage({-verbose␣=>␣1,␣-output␣=>␣\*STDOUT});

␣␣␣␣pod2usage(-exitval␣=>␣1,␣-verbose␣=>␣1);

␣␣␣␣pod2usage(-exitval␣=>␣1,␣-verbose␣=>␣1,␣-output␣=>␣\*STDOUT});

Each␣of␣the␣following␣invocations␣of␣C<pod2usage()>␣will␣print␣the
entire␣manual␣page␣to␣C<STDOUT>␣and␣will␣exit␣with␣a␣status␣of␣1:

␣␣␣␣pod2usage(-verbose␣␣=>␣2);

␣␣␣␣pod2usage({-verbose␣=>␣2,␣-output␣=>␣\*STDOUT});

␣␣␣␣pod2usage(-exitval␣␣=>␣1,␣-verbose␣=>␣2);

␣␣␣␣pod2usage({-exitval␣=>␣1,␣-verbose␣=>␣2,␣-output␣=>␣\*STDOUT});

=head2␣Recommended␣Use

Most␣scripts␣should␣print␣some␣type␣of␣usage␣message␣to␣C<STDERR>␣when␣a
command␣line␣syntax␣error␣is␣detected.␣They␣should␣also␣provide␣an
option␣(usually␣C<-H>␣or␣C<-help>)␣to␣print␣a␣(possibly␣more␣verbose)
usage␣message␣to␣C<STDOUT>.␣Some␣scripts␣may␣even␣wish␣to␣go␣so␣far␣as␣to
provide␣a␣means␣of␣printing␣their␣complete␣documentation␣to␣C<STDOUT>
(perhaps␣by␣allowing␣a␣C<-man>␣option).␣The␣following␣complete␣example
uses␣B<Pod::Usage>␣in␣combination␣with␣B<Getopt::Long>␣to␣do␣all␣of␣these
things:

␣␣␣␣use␣Getopt::Long;
␣␣␣␣use␣Pod::Usage;

␣␣␣␣my␣$man␣=␣0;
␣␣␣␣my␣$help␣=␣0;
␣␣␣␣##␣Parse␣options␣and␣print␣usage␣if␣there␣is␣a␣syntax␣error,
␣␣␣␣##␣or␣if␣usage␣was␣explicitly␣requested.
␣␣␣␣GetOptions('help|?'␣=>␣\$help,␣man␣=>␣\$man)␣or␣pod2usage(2);
␣␣␣␣pod2usage(1)␣if␣$help;
␣␣␣␣pod2usage(-verbose␣=>␣2)␣if␣$man;

␣␣␣␣##␣If␣no␣arguments␣were␣given,␣then␣allow␣STDIN␣to␣be␣used␣only
␣␣␣␣##␣if␣it's␣not␣connected␣to␣a␣terminal␣(otherwise␣print␣usage)
␣␣␣␣pod2usage("$0:␣No␣files␣given.")␣␣if␣((@ARGV␣==␣0)␣&&␣(-t␣STDIN));
␣␣␣␣__END__

␣␣␣␣=head1␣NAME

␣␣␣␣sample␣-␣Using␣GetOpt::Long␣and␣Pod::Usage

␣␣␣␣=head1␣SYNOPSIS

␣␣␣␣sample␣[options]␣[file␣...]

␣␣␣␣␣Options:
␣␣␣␣␣␣␣-help␣␣␣␣␣␣␣␣␣␣␣␣brief␣help␣message
␣␣␣␣␣␣␣-man␣␣␣␣␣␣␣␣␣␣␣␣␣full␣documentation

␣␣␣␣=head1␣OPTIONS

␣␣␣␣=over␣8

␣␣␣␣=item␣B<-help>

␣␣␣␣Print␣a␣brief␣help␣message␣and␣exits.

␣␣␣␣=item␣B<-man>

␣␣␣␣Prints␣the␣manual␣page␣and␣exits.

␣␣␣␣=back

␣␣␣␣=head1␣DESCRIPTION

␣␣␣␣B<This␣program>␣will␣read␣the␣given␣input␣file(s)␣and␣do␣something
␣␣␣␣useful␣with␣the␣contents␣thereof.

␣␣␣␣=cut

=head1␣CAVEATS

By␣default,␣B<pod2usage()>␣will␣use␣C<$0>␣as␣the␣path␣to␣the␣pod␣input
file.␣␣Unfortunately,␣not␣all␣systems␣on␣which␣Perl␣runs␣will␣set␣C<$0>
properly␣(although␣if␣C<$0>␣isn't␣found,␣B<pod2usage()>␣will␣search
C<$ENV{PATH}>␣or␣else␣the␣list␣specified␣by␣the␣C<-pathlist>␣option).
If␣this␣is␣the␣case␣for␣your␣system,␣you␣may␣need␣to␣explicitly␣specify
the␣path␣to␣the␣pod␣docs␣for␣the␣invoking␣script␣using␣something
similar␣to␣the␣following:

␣␣␣␣pod2usage(-exitval␣=>␣2,␣-input␣=>␣"/path/to/your/pod/docs");

In␣the␣pathological␣case␣that␣a␣script␣is␣called␣via␣a␣relative␣path
I<and>␣the␣script␣itself␣changes␣the␣current␣working␣directory
(see␣L<perlfunc/chdir>)␣I<before>␣calling␣pod2usage,␣Pod::Usage␣will
fail␣even␣on␣robust␣platforms.␣Don't␣do␣that.

=head1␣AUTHOR

Please␣report␣bugs␣using␣L<http://rt.cpan.org>.

Marek␣Rouchal␣E<lt>marekr@cpan.orgE<gt>

Brad␣Appleton␣E<lt>bradapp@enteract.comE<gt>

Based␣on␣code␣for␣B<Pod::Text::pod2text()>␣written␣by
Tom␣Christiansen␣E<lt>tchrist@mox.perl.comE<gt>

=head1␣ACKNOWLEDGMENTS

Steven␣McDougall␣E<lt>swmcd@world.std.comE<gt>␣for␣his␣help␣and␣patience
with␣re-writing␣this␣manpage.

=head1␣SEE␣ALSO

L<Pod::Parser>,␣L<Getopt::Long>,␣L<Pod::Find>

=cut
----------
Range: (2626710,2640376) (13666)
=head1␣NAME

File::Find␣-␣Traverse␣a␣directory␣tree.

=head1␣SYNOPSIS

␣␣␣␣use␣File::Find;
␣␣␣␣find(\&wanted,␣@directories_to_search);
␣␣␣␣sub␣wanted␣{␣...␣}

␣␣␣␣use␣File::Find;
␣␣␣␣finddepth(\&wanted,␣@directories_to_search);
␣␣␣␣sub␣wanted␣{␣...␣}

␣␣␣␣use␣File::Find;
␣␣␣␣find({␣wanted␣=>␣\&process,␣follow␣=>␣1␣},␣'.');

=head1␣DESCRIPTION

These␣are␣functions␣for␣searching␣through␣directory␣trees␣doing␣work
on␣each␣file␣found␣similar␣to␣the␣Unix␣I<find>␣command.␣␣File::Find
exports␣two␣functions,␣C<find>␣and␣C<finddepth>.␣␣They␣work␣similarly
but␣have␣subtle␣differences.

=over␣4

=item␣B<find>

␣␣find(\&wanted,␣␣@directories);
␣␣find(\%options,␣@directories);

C<find()>␣does␣a␣depth-first␣search␣over␣the␣given␣C<@directories>␣in
the␣order␣they␣are␣given.␣␣For␣each␣file␣or␣directory␣found,␣it␣calls
the␣C<&wanted>␣subroutine.␣␣(See␣below␣for␣details␣on␣how␣to␣use␣the
C<&wanted>␣function).␣␣Additionally,␣for␣each␣directory␣found,␣it␣will
C<chdir()>␣into␣that␣directory␣and␣continue␣the␣search,␣invoking␣the
C<&wanted>␣function␣on␣each␣file␣or␣subdirectory␣in␣the␣directory.

=item␣B<finddepth>

␣␣finddepth(\&wanted,␣␣@directories);
␣␣finddepth(\%options,␣@directories);

C<finddepth()>␣works␣just␣like␣C<find()>␣except␣that␣it␣invokes␣the
C<&wanted>␣function␣for␣a␣directory␣I<after>␣invoking␣it␣for␣the
directory's␣contents.␣␣It␣does␣a␣postorder␣traversal␣instead␣of␣a
preorder␣traversal,␣working␣from␣the␣bottom␣of␣the␣directory␣tree␣up
where␣C<find()>␣works␣from␣the␣top␣of␣the␣tree␣down.

=back

=head2␣%options

The␣first␣argument␣to␣C<find()>␣is␣either␣a␣code␣reference␣to␣your
C<&wanted>␣function,␣or␣a␣hash␣reference␣describing␣the␣operations
to␣be␣performed␣for␣each␣file.␣␣The
code␣reference␣is␣described␣in␣L<The␣wanted␣function>␣below.

Here␣are␣the␣possible␣keys␣for␣the␣hash:

=over␣3

=item␣C<wanted>

The␣value␣should␣be␣a␣code␣reference.␣␣This␣code␣reference␣is
described␣in␣L<The␣wanted␣function>␣below.␣The␣C<&wanted>␣subroutine␣is
mandatory.

=item␣C<bydepth>

Reports␣the␣name␣of␣a␣directory␣only␣AFTER␣all␣its␣entries
have␣been␣reported.␣␣Entry␣point␣C<finddepth()>␣is␣a␣shortcut␣for
specifying␣C<<␣{␣bydepth␣=>␣1␣}␣>>␣in␣the␣first␣argument␣of␣C<find()>.

=item␣C<preprocess>

The␣value␣should␣be␣a␣code␣reference.␣This␣code␣reference␣is␣used␣to
preprocess␣the␣current␣directory.␣The␣name␣of␣the␣currently␣processed
directory␣is␣in␣C<$File::Find::dir>.␣Your␣preprocessing␣function␣is
called␣after␣C<readdir()>,␣but␣before␣the␣loop␣that␣calls␣the␣C<wanted()>
function.␣It␣is␣called␣with␣a␣list␣of␣strings␣(actually␣file/directory
names)␣and␣is␣expected␣to␣return␣a␣list␣of␣strings.␣The␣code␣can␣be
used␣to␣sort␣the␣file/directory␣names␣alphabetically,␣numerically,
or␣to␣filter␣out␣directory␣entries␣based␣on␣their␣name␣alone.␣When
I<follow>␣or␣I<follow_fast>␣are␣in␣effect,␣C<preprocess>␣is␣a␣no-op.

=item␣C<postprocess>

The␣value␣should␣be␣a␣code␣reference.␣It␣is␣invoked␣just␣before␣leaving
the␣currently␣processed␣directory.␣It␣is␣called␣in␣void␣context␣with␣no
arguments.␣The␣name␣of␣the␣current␣directory␣is␣in␣C<$File::Find::dir>.␣This
hook␣is␣handy␣for␣summarizing␣a␣directory,␣such␣as␣calculating␣its␣disk
usage.␣When␣I<follow>␣or␣I<follow_fast>␣are␣in␣effect,␣C<postprocess>␣is␣a
no-op.

=item␣C<follow>

Causes␣symbolic␣links␣to␣be␣followed.␣Since␣directory␣trees␣with␣symbolic
links␣(followed)␣may␣contain␣files␣more␣than␣once␣and␣may␣even␣have
cycles,␣a␣hash␣has␣to␣be␣built␣up␣with␣an␣entry␣for␣each␣file.
This␣might␣be␣expensive␣both␣in␣space␣and␣time␣for␣a␣large
directory␣tree.␣See␣I<follow_fast>␣and␣I<follow_skip>␣below.
If␣either␣I<follow>␣or␣I<follow_fast>␣is␣in␣effect:

=over␣6

=item␣*

It␣is␣guaranteed␣that␣an␣I<lstat>␣has␣been␣called␣before␣the␣user's
C<wanted()>␣function␣is␣called.␣This␣enables␣fast␣file␣checks␣involving␣S<_>.
Note␣that␣this␣guarantee␣no␣longer␣holds␣if␣I<follow>␣or␣I<follow_fast>
are␣not␣set.

=item␣*

There␣is␣a␣variable␣C<$File::Find::fullname>␣which␣holds␣the␣absolute
pathname␣of␣the␣file␣with␣all␣symbolic␣links␣resolved.␣␣If␣the␣link␣is
a␣dangling␣symbolic␣link,␣then␣fullname␣will␣be␣set␣to␣C<undef>.

=back

This␣is␣a␣no-op␣on␣Win32.

=item␣C<follow_fast>

This␣is␣similar␣to␣I<follow>␣except␣that␣it␣may␣report␣some␣files␣more
than␣once.␣␣It␣does␣detect␣cycles,␣however.␣␣Since␣only␣symbolic␣links
have␣to␣be␣hashed,␣this␣is␣much␣cheaper␣both␣in␣space␣and␣time.␣␣If
processing␣a␣file␣more␣than␣once␣(by␣the␣user's␣C<wanted()>␣function)
is␣worse␣than␣just␣taking␣time,␣the␣option␣I<follow>␣should␣be␣used.

This␣is␣also␣a␣no-op␣on␣Win32.

=item␣C<follow_skip>

C<follow_skip==1>,␣which␣is␣the␣default,␣causes␣all␣files␣which␣are
neither␣directories␣nor␣symbolic␣links␣to␣be␣ignored␣if␣they␣are␣about
to␣be␣processed␣a␣second␣time.␣If␣a␣directory␣or␣a␣symbolic␣link
are␣about␣to␣be␣processed␣a␣second␣time,␣File::Find␣dies.

C<follow_skip==0>␣causes␣File::Find␣to␣die␣if␣any␣file␣is␣about␣to␣be
processed␣a␣second␣time.

C<follow_skip==2>␣causes␣File::Find␣to␣ignore␣any␣duplicate␣files␣and
directories␣but␣to␣proceed␣normally␣otherwise.

=item␣C<dangling_symlinks>

If␣true␣and␣a␣code␣reference,␣will␣be␣called␣with␣the␣symbolic␣link
name␣and␣the␣directory␣it␣lives␣in␣as␣arguments.␣␣Otherwise,␣if␣true
and␣warnings␣are␣on,␣warning␣"symbolic_link_name␣is␣a␣dangling
symbolic␣link\n"␣will␣be␣issued.␣␣If␣false,␣the␣dangling␣symbolic␣link
will␣be␣silently␣ignored.

=item␣C<no_chdir>

Does␣not␣C<chdir()>␣to␣each␣directory␣as␣it␣recurses.␣The␣C<wanted()>
function␣will␣need␣to␣be␣aware␣of␣this,␣of␣course.␣In␣this␣case,
C<$_>␣will␣be␣the␣same␣as␣C<$File::Find::name>.

=item␣C<untaint>

If␣find␣is␣used␣in␣taint-mode␣(-T␣command␣line␣switch␣or␣if␣EUID␣!=␣UID
or␣if␣EGID␣!=␣GID)␣then␣internally␣directory␣names␣have␣to␣be␣untainted
before␣they␣can␣be␣chdir'ed␣to.␣Therefore␣they␣are␣checked␣against␣a␣regular
expression␣I<untaint_pattern>.␣␣Note␣that␣all␣names␣passed␣to␣the␣user's
I<wanted()>␣function␣are␣still␣tainted.␣If␣this␣option␣is␣used␣while
not␣in␣taint-mode,␣C<untaint>␣is␣a␣no-op.

=item␣C<untaint_pattern>

See␣above.␣This␣should␣be␣set␣using␣the␣C<qr>␣quoting␣operator.
The␣default␣is␣set␣to␣␣C<qr|^([-+@\w./]+)$|>.
Note␣that␣the␣parentheses␣are␣vital.

=item␣C<untaint_skip>

If␣set,␣a␣directory␣which␣fails␣the␣I<untaint_pattern>␣is␣skipped,
including␣all␣its␣sub-directories.␣The␣default␣is␣to␣'die'␣in␣such␣a␣case.

=back

=head2␣The␣wanted␣function

The␣C<wanted()>␣function␣does␣whatever␣verifications␣you␣want␣on
each␣file␣and␣directory.␣␣Note␣that␣despite␣its␣name,␣the␣C<wanted()>
function␣is␣a␣generic␣callback␣function,␣and␣does␣B<not>␣tell
File::Find␣if␣a␣file␣is␣"wanted"␣or␣not.␣␣In␣fact,␣its␣return␣value
is␣ignored.

The␣wanted␣function␣takes␣no␣arguments␣but␣rather␣does␣its␣work
through␣a␣collection␣of␣variables.

=over␣4

=item␣C<$File::Find::dir>␣is␣the␣current␣directory␣name,

=item␣C<$_>␣is␣the␣current␣filename␣within␣that␣directory

=item␣C<$File::Find::name>␣is␣the␣complete␣pathname␣to␣the␣file.

=back

The␣above␣variables␣have␣all␣been␣localized␣and␣may␣be␣changed␣without
affecting␣data␣outside␣of␣the␣wanted␣function.

For␣example,␣when␣examining␣the␣file␣F</some/path/foo.ext>␣you␣will␣have:

␣␣␣␣$File::Find::dir␣␣=␣/some/path/
␣␣␣␣$_␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=␣foo.ext
␣␣␣␣$File::Find::name␣=␣/some/path/foo.ext

You␣are␣chdir()'d␣to␣C<$File::Find::dir>␣when␣the␣function␣is␣called,
unless␣C<no_chdir>␣was␣specified.␣Note␣that␣when␣changing␣to
directories␣is␣in␣effect␣the␣root␣directory␣(F</>)␣is␣a␣somewhat
special␣case␣inasmuch␣as␣the␣concatenation␣of␣C<$File::Find::dir>,
C<'/'>␣and␣C<$_>␣is␣not␣literally␣equal␣to␣C<$File::Find::name>.␣The
table␣below␣summarizes␣all␣variants:

␣␣␣␣␣␣␣␣␣␣␣␣␣␣$File::Find::name␣␣$File::Find::dir␣␣$_
␣default␣␣␣␣␣␣/␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣.
␣no_chdir=>0␣␣/etc␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣etc
␣␣␣␣␣␣␣␣␣␣␣␣␣␣/etc/x␣␣␣␣␣␣␣␣␣␣␣␣␣/etc␣␣␣␣␣␣␣␣␣␣␣␣␣␣x

␣no_chdir=>1␣␣/␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/
␣␣␣␣␣␣␣␣␣␣␣␣␣␣/etc␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/etc
␣␣␣␣␣␣␣␣␣␣␣␣␣␣/etc/x␣␣␣␣␣␣␣␣␣␣␣␣␣/etc␣␣␣␣␣␣␣␣␣␣␣␣␣␣/etc/x


When␣C<follow>␣or␣C<follow_fast>␣are␣in␣effect,␣there␣is
also␣a␣C<$File::Find::fullname>.␣␣The␣function␣may␣set
C<$File::Find::prune>␣to␣prune␣the␣tree␣unless␣C<bydepth>␣was
specified.␣␣Unless␣C<follow>␣or␣C<follow_fast>␣is␣specified,␣for
compatibility␣reasons␣(find.pl,␣find2perl)␣there␣are␣in␣addition␣the
following␣globals␣available:␣C<$File::Find::topdir>,
C<$File::Find::topdev>,␣C<$File::Find::topino>,
C<$File::Find::topmode>␣and␣C<$File::Find::topnlink>.

This␣library␣is␣useful␣for␣the␣C<find2perl>␣tool,␣which␣when␣fed,

␣␣␣␣find2perl␣/␣-name␣.nfs\*␣-mtime␣+7␣\
␣␣␣␣␣␣␣␣-exec␣rm␣-f␣{}␣\;␣-o␣-fstype␣nfs␣-prune

produces␣something␣like:

␣␣␣␣sub␣wanted␣{
␣␣␣␣␣␣␣␣/^\.nfs.*\z/s␣&&
␣␣␣␣␣␣␣␣(($dev,␣$ino,␣$mode,␣$nlink,␣$uid,␣$gid)␣=␣lstat($_))␣&&
␣␣␣␣␣␣␣␣int(-M␣_)␣>␣7␣&&
␣␣␣␣␣␣␣␣unlink($_)
␣␣␣␣␣␣␣␣||
␣␣␣␣␣␣␣␣($nlink␣||␣(($dev,␣$ino,␣$mode,␣$nlink,␣$uid,␣$gid)␣=␣lstat($_)))␣&&
␣␣␣␣␣␣␣␣$dev␣<␣0␣&&
␣␣␣␣␣␣␣␣($File::Find::prune␣=␣1);
␣␣␣␣}

Notice␣the␣C<_>␣in␣the␣above␣C<int(-M␣_)>:␣the␣C<_>␣is␣a␣magical
filehandle␣that␣caches␣the␣information␣from␣the␣preceding
C<stat()>,␣C<lstat()>,␣or␣filetest.

Here's␣another␣interesting␣wanted␣function.␣␣It␣will␣find␣all␣symbolic
links␣that␣don't␣resolve:

␣␣␣␣sub␣wanted␣{
␣␣␣␣␣␣␣␣␣-l␣&&␣!-e␣&&␣print␣"bogus␣link:␣$File::Find::name\n";
␣␣␣␣}

See␣also␣the␣script␣C<pfind>␣on␣CPAN␣for␣a␣nice␣application␣of␣this
module.

=head1␣WARNINGS

If␣you␣run␣your␣program␣with␣the␣C<-w>␣switch,␣or␣if␣you␣use␣the
C<warnings>␣pragma,␣File::Find␣will␣report␣warnings␣for␣several␣weird
situations.␣You␣can␣disable␣these␣warnings␣by␣putting␣the␣statement

␣␣␣␣no␣warnings␣'File::Find';

in␣the␣appropriate␣scope.␣See␣L<perllexwarn>␣for␣more␣info␣about␣lexical
warnings.

=head1␣CAVEAT

=over␣2

=item␣$dont_use_nlink

You␣can␣set␣the␣variable␣C<$File::Find::dont_use_nlink>␣to␣1,␣if␣you␣want␣to
force␣File::Find␣to␣always␣stat␣directories.␣This␣was␣used␣for␣file␣systems
that␣do␣not␣have␣an␣C<nlink>␣count␣matching␣the␣number␣of␣sub-directories.
Examples␣are␣ISO-9660␣(CD-ROM),␣AFS,␣HPFS␣(OS/2␣file␣system),␣FAT␣(DOS␣file
system)␣and␣a␣couple␣of␣others.

You␣shouldn't␣need␣to␣set␣this␣variable,␣since␣File::Find␣should␣now␣detect
such␣file␣systems␣on-the-fly␣and␣switch␣itself␣to␣using␣stat.␣This␣works␣even
for␣parts␣of␣your␣file␣system,␣like␣a␣mounted␣CD-ROM.

If␣you␣do␣set␣C<$File::Find::dont_use_nlink>␣to␣1,␣you␣will␣notice␣slow-downs.

=item␣symlinks

Be␣aware␣that␣the␣option␣to␣follow␣symbolic␣links␣can␣be␣dangerous.
Depending␣on␣the␣structure␣of␣the␣directory␣tree␣(including␣symbolic
links␣to␣directories)␣you␣might␣traverse␣a␣given␣(physical)␣directory
more␣than␣once␣(only␣if␣C<follow_fast>␣is␣in␣effect).
Furthermore,␣deleting␣or␣changing␣files␣in␣a␣symbolically␣linked␣directory
might␣cause␣very␣unpleasant␣surprises,␣since␣you␣delete␣or␣change␣files
in␣an␣unknown␣directory.

=back

=head1␣NOTES

=over␣4

=item␣*

Mac␣OS␣(Classic)␣users␣should␣note␣a␣few␣differences:

=over␣4

=item␣*

The␣path␣separator␣is␣':',␣not␣'/',␣and␣the␣current␣directory␣is␣denoted
as␣':',␣not␣'.'.␣You␣should␣be␣careful␣about␣specifying␣relative␣pathnames.
While␣a␣full␣path␣always␣begins␣with␣a␣volume␣name,␣a␣relative␣pathname
should␣always␣begin␣with␣a␣':'.␣␣If␣specifying␣a␣volume␣name␣only,␣a
trailing␣':'␣is␣required.

=item␣*

C<$File::Find::dir>␣is␣guaranteed␣to␣end␣with␣a␣':'.␣If␣C<$_>
contains␣the␣name␣of␣a␣directory,␣that␣name␣may␣or␣may␣not␣end␣with␣a
':'.␣Likewise,␣C<$File::Find::name>,␣which␣contains␣the␣complete
pathname␣to␣that␣directory,␣and␣C<$File::Find::fullname>,␣which␣holds
the␣absolute␣pathname␣of␣that␣directory␣with␣all␣symbolic␣links␣resolved,
may␣or␣may␣not␣end␣with␣a␣':'.

=item␣*

The␣default␣C<untaint_pattern>␣(see␣above)␣on␣Mac␣OS␣is␣set␣to
C<qr|^(.+)$|>.␣Note␣that␣the␣parentheses␣are␣vital.

=item␣*

The␣invisible␣system␣file␣"Icon\015"␣is␣ignored.␣While␣this␣file␣may
appear␣in␣every␣directory,␣there␣are␣some␣more␣invisible␣system␣files
on␣every␣volume,␣which␣are␣all␣located␣at␣the␣volume␣root␣level␣(i.e.
"MacintoshHD:").␣These␣system␣files␣are␣B<not>␣excluded␣automatically.
Your␣filter␣may␣use␣the␣following␣code␣to␣recognize␣invisible␣files␣or
directories␣(requires␣Mac::Files):

␣use␣Mac::Files;

␣#␣invisible()␣--␣␣returns␣1␣if␣file/directory␣is␣invisible,
␣#␣0␣if␣it's␣visible␣or␣undef␣if␣an␣error␣occurred

␣sub␣invisible($)␣{
␣␣␣my␣$file␣=␣shift;
␣␣␣my␣($fileCat,␣$fileInfo);
␣␣␣my␣$invisible_flag␣=␣␣1␣<<␣14;

␣␣␣if␣(␣$fileCat␣=␣FSpGetCatInfo($file)␣)␣{
␣␣␣␣␣if␣($fileInfo␣=␣$fileCat->ioFlFndrInfo()␣)␣{
␣␣␣␣␣␣␣return␣(($fileInfo->fdFlags␣&␣$invisible_flag)␣&&␣1);
␣␣␣␣␣}
␣␣␣}
␣␣␣return␣undef;
␣}

Generally,␣invisible␣files␣are␣system␣files,␣unless␣an␣odd␣application
decides␣to␣use␣invisible␣files␣for␣its␣own␣purposes.␣To␣distinguish
such␣files␣from␣system␣files,␣you␣have␣to␣look␣at␣the␣B<type>␣and␣B<creator>
file␣attributes.␣The␣MacPerl␣built-in␣functions␣C<GetFileInfo(FILE)>␣and
C<SetFileInfo(CREATOR,␣TYPE,␣FILES)>␣offer␣access␣to␣these␣attributes
(see␣MacPerl.pm␣for␣details).

Files␣that␣appear␣on␣the␣desktop␣actually␣reside␣in␣an␣(hidden)␣directory
named␣"Desktop␣Folder"␣on␣the␣particular␣disk␣volume.␣Note␣that,␣although
all␣desktop␣files␣appear␣to␣be␣on␣the␣same␣"virtual"␣desktop,␣each␣disk
volume␣actually␣maintains␣its␣own␣"Desktop␣Folder"␣directory.

=back

=back

=head1␣BUGS␣AND␣CAVEATS

Despite␣the␣name␣of␣the␣C<finddepth()>␣function,␣both␣C<find()>␣and
C<finddepth()>␣perform␣a␣depth-first␣search␣of␣the␣directory
hierarchy.

=head1␣HISTORY

File::Find␣used␣to␣produce␣incorrect␣results␣if␣called␣recursively.
During␣the␣development␣of␣perl␣5.8␣this␣bug␣was␣fixed.
The␣first␣fixed␣version␣of␣File::Find␣was␣1.01.

=head1␣SEE␣ALSO

find,␣find2perl.

=cut
----------
Range: (2805671,2812984) (7313)
=head1␣NAME

AutoSplit␣-␣split␣a␣package␣for␣autoloading

=head1␣SYNOPSIS

␣autosplit($file,␣$dir,␣$keep,␣$check,␣$modtime);

␣autosplit_lib_modules(@modules);

=head1␣DESCRIPTION

This␣function␣will␣split␣up␣your␣program␣into␣files␣that␣the␣AutoLoader
module␣can␣handle.␣It␣is␣used␣by␣both␣the␣standard␣perl␣libraries␣and␣by
the␣MakeMaker␣utility,␣to␣automatically␣configure␣libraries␣for␣autoloading.

The␣C<autosplit>␣interface␣splits␣the␣specified␣file␣into␣a␣hierarchy␣
rooted␣at␣the␣directory␣C<$dir>.␣It␣creates␣directories␣as␣needed␣to␣reflect
class␣hierarchy,␣and␣creates␣the␣file␣F<autosplit.ix>.␣This␣file␣acts␣as
both␣forward␣declaration␣of␣all␣package␣routines,␣and␣as␣timestamp␣for␣the
last␣update␣of␣the␣hierarchy.

The␣remaining␣three␣arguments␣to␣C<autosplit>␣govern␣other␣options␣to
the␣autosplitter.

=over␣2

=item␣$keep

If␣the␣third␣argument,␣I<$keep>,␣is␣false,␣then␣any
pre-existing␣C<*.al>␣files␣in␣the␣autoload␣directory␣are␣removed␣if
they␣are␣no␣longer␣part␣of␣the␣module␣(obsoleted␣functions).
$keep␣defaults␣to␣0.

=item␣$check

The
fourth␣argument,␣I<$check>,␣instructs␣C<autosplit>␣to␣check␣the␣module
currently␣being␣split␣to␣ensure␣that␣it␣includes␣a␣C<use>
specification␣for␣the␣AutoLoader␣module,␣and␣skips␣the␣module␣if
AutoLoader␣is␣not␣detected.
$check␣defaults␣to␣1.

=item␣$modtime

Lastly,␣the␣I<$modtime>␣argument␣specifies
that␣C<autosplit>␣is␣to␣check␣the␣modification␣time␣of␣the␣module
against␣that␣of␣the␣C<autosplit.ix>␣file,␣and␣only␣split␣the␣module␣if
it␣is␣newer.
$modtime␣defaults␣to␣1.

=back

Typical␣use␣of␣AutoSplit␣in␣the␣perl␣MakeMaker␣utility␣is␣via␣the␣command-line
with:

␣perl␣-e␣'use␣AutoSplit;␣autosplit($ARGV[0],␣$ARGV[1],␣0,␣1,␣1)'

Defined␣as␣a␣Make␣macro,␣it␣is␣invoked␣with␣file␣and␣directory␣arguments;
C<autosplit>␣will␣split␣the␣specified␣file␣into␣the␣specified␣directory␣and
delete␣obsolete␣C<.al>␣files,␣after␣checking␣first␣that␣the␣module␣does␣use
the␣AutoLoader,␣and␣ensuring␣that␣the␣module␣is␣not␣already␣currently␣split
in␣its␣current␣form␣(the␣modtime␣test).

The␣C<autosplit_lib_modules>␣form␣is␣used␣in␣the␣building␣of␣perl.␣It␣takes
as␣input␣a␣list␣of␣files␣(modules)␣that␣are␣assumed␣to␣reside␣in␣a␣directory
B<lib>␣relative␣to␣the␣current␣directory.␣Each␣file␣is␣sent␣to␣the␣
autosplitter␣one␣at␣a␣time,␣to␣be␣split␣into␣the␣directory␣B<lib/auto>.

In␣both␣usages␣of␣the␣autosplitter,␣only␣subroutines␣defined␣following␣the
perl␣I<__END__>␣token␣are␣split␣out␣into␣separate␣files.␣Some
routines␣may␣be␣placed␣prior␣to␣this␣marker␣to␣force␣their␣immediate␣loading
and␣parsing.

=head2␣Multiple␣packages

As␣of␣version␣1.01␣of␣the␣AutoSplit␣module␣it␣is␣possible␣to␣have
multiple␣packages␣within␣a␣single␣file.␣Both␣of␣the␣following␣cases
are␣supported:

␣␣␣package␣NAME;
␣␣␣__END__
␣␣␣sub␣AAA␣{␣...␣}
␣␣␣package␣NAME::option1;
␣␣␣sub␣BBB␣{␣...␣}
␣␣␣package␣NAME::option2;
␣␣␣sub␣BBB␣{␣...␣}

␣␣␣package␣NAME;
␣␣␣__END__
␣␣␣sub␣AAA␣{␣...␣}
␣␣␣sub␣NAME::option1::BBB␣{␣...␣}
␣␣␣sub␣NAME::option2::BBB␣{␣...␣}

=head1␣DIAGNOSTICS

C<AutoSplit>␣will␣inform␣the␣user␣if␣it␣is␣necessary␣to␣create␣the
top-level␣directory␣specified␣in␣the␣invocation.␣It␣is␣preferred␣that
the␣script␣or␣installation␣process␣that␣invokes␣C<AutoSplit>␣have
created␣the␣full␣directory␣path␣ahead␣of␣time.␣This␣warning␣may
indicate␣that␣the␣module␣is␣being␣split␣into␣an␣incorrect␣path.

C<AutoSplit>␣will␣warn␣the␣user␣of␣all␣subroutines␣whose␣name␣causes
potential␣file␣naming␣conflicts␣on␣machines␣with␣drastically␣limited
(8␣characters␣or␣less)␣file␣name␣length.␣Since␣the␣subroutine␣name␣is
used␣as␣the␣file␣name,␣these␣warnings␣can␣aid␣in␣portability␣to␣such
systems.

Warnings␣are␣issued␣and␣the␣file␣skipped␣if␣C<AutoSplit>␣cannot␣locate
either␣the␣I<__END__>␣marker␣or␣a␣"package␣Name;"-style␣specification.

C<AutoSplit>␣will␣also␣emit␣general␣diagnostics␣for␣inability␣to
create␣directories␣or␣files.

=head1␣AUTHOR

C<AutoSplit>␣is␣maintained␣by␣the␣perl5-porters.␣Please␣direct
any␣questions␣to␣the␣canonical␣mailing␣list.␣Anything␣that
is␣applicable␣to␣the␣CPAN␣release␣can␣be␣sent␣to␣its␣maintainer,
though.

Author␣and␣Maintainer:␣The␣Perl5-Porters␣<perl5-porters@perl.org>

Maintainer␣of␣the␣CPAN␣release:␣Steffen␣Mueller␣<smueller@cpan.org>

=head1␣COPYRIGHT␣AND␣LICENSE

This␣package␣has␣been␣part␣of␣the␣perl␣core␣since␣the␣first␣release
of␣perl5.␣It␣has␣been␣released␣separately␣to␣CPAN␣so␣older␣installations
can␣benefit␣from␣bug␣fixes.

This␣package␣has␣the␣same␣copyright␣and␣license␣as␣the␣perl␣core:

␣␣␣␣␣␣␣␣␣␣␣␣␣Copyright␣(C)␣1993,␣1994,␣1995,␣1996,␣1997,␣1998,␣1999,
␣␣␣␣␣␣␣␣2000,␣2001,␣2002,␣2003,␣2004,␣2005,␣2006,␣2007,␣2008
␣␣␣␣␣␣␣␣by␣Larry␣Wall␣and␣others
␣␣␣␣
			␣␣␣␣All␣rights␣reserved.
␣␣␣␣
␣␣␣␣This␣program␣is␣free␣software;␣you␣can␣redistribute␣it␣and/or␣modify
␣␣␣␣it␣under␣the␣terms␣of␣either:
␣␣␣␣
	a)␣the␣GNU␣General␣Public␣License␣as␣published␣by␣the␣Free
	Software␣Foundation;␣either␣version␣1,␣or␣(at␣your␣option)␣any
	later␣version,␣or
␣␣␣␣
	b)␣the␣"Artistic␣License"␣which␣comes␣with␣this␣Kit.
␣␣␣␣
␣␣␣␣This␣program␣is␣distributed␣in␣the␣hope␣that␣it␣will␣be␣useful,
␣␣␣␣but␣WITHOUT␣ANY␣WARRANTY;␣without␣even␣the␣implied␣warranty␣of
␣␣␣␣MERCHANTABILITY␣or␣FITNESS␣FOR␣A␣PARTICULAR␣PURPOSE.␣␣See␣either
␣␣␣␣the␣GNU␣General␣Public␣License␣or␣the␣Artistic␣License␣for␣more␣details.
␣␣␣␣
␣␣␣␣You␣should␣have␣received␣a␣copy␣of␣the␣Artistic␣License␣with␣this
␣␣␣␣Kit,␣in␣the␣file␣named␣"Artistic".␣␣If␣not,␣I'll␣be␣glad␣to␣provide␣one.
␣␣␣␣
␣␣␣␣You␣should␣also␣have␣received␣a␣copy␣of␣the␣GNU␣General␣Public␣License
␣␣␣␣along␣with␣this␣program␣in␣the␣file␣named␣"Copying".␣If␣not,␣write␣to␣the␣
␣␣␣␣Free␣Software␣Foundation,␣Inc.,␣59␣Temple␣Place,␣Suite␣330,␣Boston,␣MA␣
␣␣␣␣02111-1307,␣USA␣or␣visit␣their␣web␣page␣on␣the␣internet␣at
␣␣␣␣http://www.gnu.org/copyleft/gpl.html.
␣␣␣␣
␣␣␣␣For␣those␣of␣you␣that␣choose␣to␣use␣the␣GNU␣General␣Public␣License,
␣␣␣␣my␣interpretation␣of␣the␣GNU␣General␣Public␣License␣is␣that␣no␣Perl
␣␣␣␣script␣falls␣under␣the␣terms␣of␣the␣GPL␣unless␣you␣explicitly␣put
␣␣␣␣said␣script␣under␣the␣terms␣of␣the␣GPL␣yourself.␣␣Furthermore,␣any
␣␣␣␣object␣code␣linked␣with␣perl␣does␣not␣automatically␣fall␣under␣the
␣␣␣␣terms␣of␣the␣GPL,␣provided␣such␣object␣code␣only␣adds␣definitions
␣␣␣␣of␣subroutines␣and␣variables,␣and␣does␣not␣otherwise␣impair␣the
␣␣␣␣resulting␣interpreter␣from␣executing␣any␣standard␣Perl␣script.␣␣I
␣␣␣␣consider␣linking␣in␣C␣subroutines␣in␣this␣manner␣to␣be␣the␣moral
␣␣␣␣equivalent␣of␣defining␣subroutines␣in␣the␣Perl␣language␣itself.␣␣You
␣␣␣␣may␣sell␣such␣an␣object␣file␣as␣proprietary␣provided␣that␣you␣provide
␣␣␣␣or␣offer␣to␣provide␣the␣Perl␣source,␣as␣specified␣by␣the␣GNU␣General
␣␣␣␣Public␣License.␣␣(This␣is␣merely␣an␣alternate␣way␣of␣specifying␣input
␣␣␣␣to␣the␣program.)␣␣You␣may␣also␣sell␣a␣binary␣produced␣by␣the␣dumping␣of
␣␣␣␣a␣running␣Perl␣script␣that␣belongs␣to␣you,␣provided␣that␣you␣provide␣or
␣␣␣␣offer␣to␣provide␣the␣Perl␣source␣as␣specified␣by␣the␣GPL.␣␣(The
␣␣␣␣fact␣that␣a␣Perl␣interpreter␣and␣your␣code␣are␣in␣the␣same␣binary␣file
␣␣␣␣is,␣in␣this␣case,␣a␣form␣of␣mere␣aggregation.)␣␣This␣is␣my␣interpretation
␣␣␣␣of␣the␣GPL.␣␣If␣you␣still␣have␣concerns␣or␣difficulties␣understanding
␣␣␣␣my␣intent,␣feel␣free␣to␣contact␣me.␣␣Of␣course,␣the␣Artistic␣License
␣␣␣␣spells␣all␣this␣out␣for␣your␣protection,␣so␣you␣may␣prefer␣to␣use␣that.

=cut
----------
Range: (2871029,2909432) (38403)
=head1␣NAME

Getopt::Long␣-␣Extended␣processing␣of␣command␣line␣options

=head1␣SYNOPSIS

␣␣use␣Getopt::Long;
␣␣my␣$data␣␣␣=␣"file.dat";
␣␣my␣$length␣=␣24;
␣␣my␣$verbose;
␣␣$result␣=␣GetOptions␣("length=i"␣=>␣\$length,␣␣␣␣#␣numeric
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"file=s"␣␣␣=>␣\$data,␣␣␣␣␣␣#␣string
			"verbose"␣␣=>␣\$verbose);␣␣#␣flag

=head1␣DESCRIPTION

The␣Getopt::Long␣module␣implements␣an␣extended␣getopt␣function␣called
GetOptions().␣This␣function␣adheres␣to␣the␣POSIX␣syntax␣for␣command
line␣options,␣with␣GNU␣extensions.␣In␣general,␣this␣means␣that␣options
have␣long␣names␣instead␣of␣single␣letters,␣and␣are␣introduced␣with␣a
double␣dash␣"--".␣Support␣for␣bundling␣of␣command␣line␣options,␣as␣was
the␣case␣with␣the␣more␣traditional␣single-letter␣approach,␣is␣provided
but␣not␣enabled␣by␣default.

=head1␣Command␣Line␣Options,␣an␣Introduction

Command␣line␣operated␣programs␣traditionally␣take␣their␣arguments␣from
the␣command␣line,␣for␣example␣filenames␣or␣other␣information␣that␣the
program␣needs␣to␣know.␣Besides␣arguments,␣these␣programs␣often␣take
command␣line␣I<options>␣as␣well.␣Options␣are␣not␣necessary␣for␣the
program␣to␣work,␣hence␣the␣name␣'option',␣but␣are␣used␣to␣modify␣its
default␣behaviour.␣For␣example,␣a␣program␣could␣do␣its␣job␣quietly,
but␣with␣a␣suitable␣option␣it␣could␣provide␣verbose␣information␣about
what␣it␣did.

Command␣line␣options␣come␣in␣several␣flavours.␣Historically,␣they␣are
preceded␣by␣a␣single␣dash␣C<->,␣and␣consist␣of␣a␣single␣letter.

␣␣␣␣-l␣-a␣-c

Usually,␣these␣single-character␣options␣can␣be␣bundled:

␣␣␣␣-lac

Options␣can␣have␣values,␣the␣value␣is␣placed␣after␣the␣option
character.␣Sometimes␣with␣whitespace␣in␣between,␣sometimes␣not:

␣␣␣␣-s␣24␣-s24

Due␣to␣the␣very␣cryptic␣nature␣of␣these␣options,␣another␣style␣was
developed␣that␣used␣long␣names.␣So␣instead␣of␣a␣cryptic␣C<-l>␣one
could␣use␣the␣more␣descriptive␣C<--long>.␣To␣distinguish␣between␣a
bundle␣of␣single-character␣options␣and␣a␣long␣one,␣two␣dashes␣are␣used
to␣precede␣the␣option␣name.␣Early␣implementations␣of␣long␣options␣used
a␣plus␣C<+>␣instead.␣Also,␣option␣values␣could␣be␣specified␣either
like

␣␣␣␣--size=24

or

␣␣␣␣--size␣24

The␣C<+>␣form␣is␣now␣obsolete␣and␣strongly␣deprecated.

=head1␣Getting␣Started␣with␣Getopt::Long

Getopt::Long␣is␣the␣Perl5␣successor␣of␣C<newgetopt.pl>.␣This␣was␣the
first␣Perl␣module␣that␣provided␣support␣for␣handling␣the␣new␣style␣of
command␣line␣options,␣hence␣the␣name␣Getopt::Long.␣This␣module␣also
supports␣single-character␣options␣and␣bundling.␣Single␣character
options␣may␣be␣any␣alphabetic␣character,␣a␣question␣mark,␣and␣a␣dash.
Long␣options␣may␣consist␣of␣a␣series␣of␣letters,␣digits,␣and␣dashes.
Although␣this␣is␣currently␣not␣enforced␣by␣Getopt::Long,␣multiple
consecutive␣dashes␣are␣not␣allowed,␣and␣the␣option␣name␣must␣not␣end
with␣a␣dash.

To␣use␣Getopt::Long␣from␣a␣Perl␣program,␣you␣must␣include␣the
following␣line␣in␣your␣Perl␣program:

␣␣␣␣use␣Getopt::Long;

This␣will␣load␣the␣core␣of␣the␣Getopt::Long␣module␣and␣prepare␣your
program␣for␣using␣it.␣Most␣of␣the␣actual␣Getopt::Long␣code␣is␣not
loaded␣until␣you␣really␣call␣one␣of␣its␣functions.

In␣the␣default␣configuration,␣options␣names␣may␣be␣abbreviated␣to
uniqueness,␣case␣does␣not␣matter,␣and␣a␣single␣dash␣is␣sufficient,
even␣for␣long␣option␣names.␣Also,␣options␣may␣be␣placed␣between
non-option␣arguments.␣See␣L<Configuring␣Getopt::Long>␣for␣more
details␣on␣how␣to␣configure␣Getopt::Long.

=head2␣Simple␣options

The␣most␣simple␣options␣are␣the␣ones␣that␣take␣no␣values.␣Their␣mere
presence␣on␣the␣command␣line␣enables␣the␣option.␣Popular␣examples␣are:

␣␣␣␣--all␣--verbose␣--quiet␣--debug

Handling␣simple␣options␣is␣straightforward:

␣␣␣␣my␣$verbose␣=␣'';	#␣option␣variable␣with␣default␣value␣(false)
␣␣␣␣my␣$all␣=␣'';	#␣option␣variable␣with␣default␣value␣(false)
␣␣␣␣GetOptions␣('verbose'␣=>␣\$verbose,␣'all'␣=>␣\$all);

The␣call␣to␣GetOptions()␣parses␣the␣command␣line␣arguments␣that␣are
present␣in␣C<@ARGV>␣and␣sets␣the␣option␣variable␣to␣the␣value␣C<1>␣if
the␣option␣did␣occur␣on␣the␣command␣line.␣Otherwise,␣the␣option
variable␣is␣not␣touched.␣Setting␣the␣option␣value␣to␣true␣is␣often
called␣I<enabling>␣the␣option.

The␣option␣name␣as␣specified␣to␣the␣GetOptions()␣function␣is␣called
the␣option␣I<specification>.␣Later␣we'll␣see␣that␣this␣specification
can␣contain␣more␣than␣just␣the␣option␣name.␣The␣reference␣to␣the
variable␣is␣called␣the␣option␣I<destination>.

GetOptions()␣will␣return␣a␣true␣value␣if␣the␣command␣line␣could␣be
processed␣successfully.␣Otherwise,␣it␣will␣write␣error␣messages␣to
STDERR,␣and␣return␣a␣false␣result.

=head2␣A␣little␣bit␣less␣simple␣options

Getopt::Long␣supports␣two␣useful␣variants␣of␣simple␣options:
I<negatable>␣options␣and␣I<incremental>␣options.

A␣negatable␣option␣is␣specified␣with␣an␣exclamation␣mark␣C<!>␣after␣the
option␣name:

␣␣␣␣my␣$verbose␣=␣'';	#␣option␣variable␣with␣default␣value␣(false)
␣␣␣␣GetOptions␣('verbose!'␣=>␣\$verbose);

Now,␣using␣C<--verbose>␣on␣the␣command␣line␣will␣enable␣C<$verbose>,
as␣expected.␣But␣it␣is␣also␣allowed␣to␣use␣C<--noverbose>,␣which␣will
disable␣C<$verbose>␣by␣setting␣its␣value␣to␣C<0>.␣Using␣a␣suitable
default␣value,␣the␣program␣can␣find␣out␣whether␣C<$verbose>␣is␣false
by␣default,␣or␣disabled␣by␣using␣C<--noverbose>.

An␣incremental␣option␣is␣specified␣with␣a␣plus␣C<+>␣after␣the
option␣name:

␣␣␣␣my␣$verbose␣=␣'';	#␣option␣variable␣with␣default␣value␣(false)
␣␣␣␣GetOptions␣('verbose+'␣=>␣\$verbose);

Using␣C<--verbose>␣on␣the␣command␣line␣will␣increment␣the␣value␣of
C<$verbose>.␣This␣way␣the␣program␣can␣keep␣track␣of␣how␣many␣times␣the
option␣occurred␣on␣the␣command␣line.␣For␣example,␣each␣occurrence␣of
C<--verbose>␣could␣increase␣the␣verbosity␣level␣of␣the␣program.

=head2␣Mixing␣command␣line␣option␣with␣other␣arguments

Usually␣programs␣take␣command␣line␣options␣as␣well␣as␣other␣arguments,
for␣example,␣file␣names.␣It␣is␣good␣practice␣to␣always␣specify␣the
options␣first,␣and␣the␣other␣arguments␣last.␣Getopt::Long␣will,
however,␣allow␣the␣options␣and␣arguments␣to␣be␣mixed␣and␣'filter␣out'
all␣the␣options␣before␣passing␣the␣rest␣of␣the␣arguments␣to␣the
program.␣To␣stop␣Getopt::Long␣from␣processing␣further␣arguments,
insert␣a␣double␣dash␣C<-->␣on␣the␣command␣line:

␣␣␣␣--size␣24␣--␣--all

In␣this␣example,␣C<--all>␣will␣I<not>␣be␣treated␣as␣an␣option,␣but
passed␣to␣the␣program␣unharmed,␣in␣C<@ARGV>.

=head2␣Options␣with␣values

For␣options␣that␣take␣values␣it␣must␣be␣specified␣whether␣the␣option
value␣is␣required␣or␣not,␣and␣what␣kind␣of␣value␣the␣option␣expects.

Three␣kinds␣of␣values␣are␣supported:␣integer␣numbers,␣floating␣point
numbers,␣and␣strings.

If␣the␣option␣value␣is␣required,␣Getopt::Long␣will␣take␣the
command␣line␣argument␣that␣follows␣the␣option␣and␣assign␣this␣to␣the
option␣variable.␣If,␣however,␣the␣option␣value␣is␣specified␣as
optional,␣this␣will␣only␣be␣done␣if␣that␣value␣does␣not␣look␣like␣a
valid␣command␣line␣option␣itself.

␣␣␣␣my␣$tag␣=␣'';	#␣option␣variable␣with␣default␣value
␣␣␣␣GetOptions␣('tag=s'␣=>␣\$tag);

In␣the␣option␣specification,␣the␣option␣name␣is␣followed␣by␣an␣equals
sign␣C<=>␣and␣the␣letter␣C<s>.␣The␣equals␣sign␣indicates␣that␣this
option␣requires␣a␣value.␣The␣letter␣C<s>␣indicates␣that␣this␣value␣is
an␣arbitrary␣string.␣Other␣possible␣value␣types␣are␣C<i>␣for␣integer
values,␣and␣C<f>␣for␣floating␣point␣values.␣Using␣a␣colon␣C<:>␣instead
of␣the␣equals␣sign␣indicates␣that␣the␣option␣value␣is␣optional.␣In
this␣case,␣if␣no␣suitable␣value␣is␣supplied,␣string␣valued␣options␣get
an␣empty␣string␣C<''>␣assigned,␣while␣numeric␣options␣are␣set␣to␣C<0>.

=head2␣Options␣with␣multiple␣values

Options␣sometimes␣take␣several␣values.␣For␣example,␣a␣program␣could
use␣multiple␣directories␣to␣search␣for␣library␣files:

␣␣␣␣--library␣lib/stdlib␣--library␣lib/extlib

To␣accomplish␣this␣behaviour,␣simply␣specify␣an␣array␣reference␣as␣the
destination␣for␣the␣option:

␣␣␣␣GetOptions␣("library=s"␣=>␣\@libfiles);

Alternatively,␣you␣can␣specify␣that␣the␣option␣can␣have␣multiple
values␣by␣adding␣a␣"@",␣and␣pass␣a␣scalar␣reference␣as␣the
destination:

␣␣␣␣GetOptions␣("library=s@"␣=>␣\$libfiles);

Used␣with␣the␣example␣above,␣C<@libfiles>␣(or␣C<@$libfiles>)␣would
contain␣two␣strings␣upon␣completion:␣C<"lib/srdlib">␣and
C<"lib/extlib">,␣in␣that␣order.␣It␣is␣also␣possible␣to␣specify␣that
only␣integer␣or␣floating␣point␣numbers␣are␣acceptable␣values.

Often␣it␣is␣useful␣to␣allow␣comma-separated␣lists␣of␣values␣as␣well␣as
multiple␣occurrences␣of␣the␣options.␣This␣is␣easy␣using␣Perl's␣split()
and␣join()␣operators:

␣␣␣␣GetOptions␣("library=s"␣=>␣\@libfiles);
␣␣␣␣@libfiles␣=␣split(/,/,join(',',@libfiles));

Of␣course,␣it␣is␣important␣to␣choose␣the␣right␣separator␣string␣for
each␣purpose.

Warning:␣What␣follows␣is␣an␣experimental␣feature.

Options␣can␣take␣multiple␣values␣at␣once,␣for␣example

␣␣␣␣--coordinates␣52.2␣16.4␣--rgbcolor␣255␣255␣149

This␣can␣be␣accomplished␣by␣adding␣a␣repeat␣specifier␣to␣the␣option
specification.␣Repeat␣specifiers␣are␣very␣similar␣to␣the␣C<{...}>
repeat␣specifiers␣that␣can␣be␣used␣with␣regular␣expression␣patterns.
For␣example,␣the␣above␣command␣line␣would␣be␣handled␣as␣follows:

␣␣␣␣GetOptions('coordinates=f{2}'␣=>␣\@coor,␣'rgbcolor=i{3}'␣=>␣\@color);

The␣destination␣for␣the␣option␣must␣be␣an␣array␣or␣array␣reference.

It␣is␣also␣possible␣to␣specify␣the␣minimal␣and␣maximal␣number␣of
arguments␣an␣option␣takes.␣C<foo=s{2,4}>␣indicates␣an␣option␣that
takes␣at␣least␣two␣and␣at␣most␣4␣arguments.␣C<foo=s{,}>␣indicates␣one
or␣more␣values;␣C<foo:s{,}>␣indicates␣zero␣or␣more␣option␣values.

=head2␣Options␣with␣hash␣values

If␣the␣option␣destination␣is␣a␣reference␣to␣a␣hash,␣the␣option␣will
take,␣as␣value,␣strings␣of␣the␣form␣I<key>C<=>I<value>.␣The␣value␣will
be␣stored␣with␣the␣specified␣key␣in␣the␣hash.

␣␣␣␣GetOptions␣("define=s"␣=>␣\%defines);

Alternatively␣you␣can␣use:

␣␣␣␣GetOptions␣("define=s%"␣=>␣\$defines);

When␣used␣with␣command␣line␣options:

␣␣␣␣--define␣os=linux␣--define␣vendor=redhat

the␣hash␣C<%defines>␣(or␣C<%$defines>)␣will␣contain␣two␣keys,␣C<"os">
with␣value␣C<"linux">␣and␣C<"vendor">␣with␣value␣C<"redhat">.␣It␣is
also␣possible␣to␣specify␣that␣only␣integer␣or␣floating␣point␣numbers
are␣acceptable␣values.␣The␣keys␣are␣always␣taken␣to␣be␣strings.

=head2␣User-defined␣subroutines␣to␣handle␣options

Ultimate␣control␣over␣what␣should␣be␣done␣when␣(actually:␣each␣time)
an␣option␣is␣encountered␣on␣the␣command␣line␣can␣be␣achieved␣by
designating␣a␣reference␣to␣a␣subroutine␣(or␣an␣anonymous␣subroutine)
as␣the␣option␣destination.␣When␣GetOptions()␣encounters␣the␣option,␣it
will␣call␣the␣subroutine␣with␣two␣or␣three␣arguments.␣The␣first
argument␣is␣the␣name␣of␣the␣option.␣(Actually,␣it␣is␣an␣object␣that
stringifies␣to␣the␣name␣of␣the␣option.)␣For␣a␣scalar␣or␣array␣destination,
the␣second␣argument␣is␣the␣value␣to␣be␣stored.␣For␣a␣hash␣destination,
the␣second␣arguments␣is␣the␣key␣to␣the␣hash,␣and␣the␣third␣argument
the␣value␣to␣be␣stored.␣It␣is␣up␣to␣the␣subroutine␣to␣store␣the␣value,
or␣do␣whatever␣it␣thinks␣is␣appropriate.

A␣trivial␣application␣of␣this␣mechanism␣is␣to␣implement␣options␣that
are␣related␣to␣each␣other.␣For␣example:

␣␣␣␣my␣$verbose␣=␣'';	#␣option␣variable␣with␣default␣value␣(false)
␣␣␣␣GetOptions␣('verbose'␣=>␣\$verbose,
	␣␣␣␣␣␣␣␣'quiet'␣␣␣=>␣sub␣{␣$verbose␣=␣0␣});

Here␣C<--verbose>␣and␣C<--quiet>␣control␣the␣same␣variable
C<$verbose>,␣but␣with␣opposite␣values.

If␣the␣subroutine␣needs␣to␣signal␣an␣error,␣it␣should␣call␣die()␣with
the␣desired␣error␣message␣as␣its␣argument.␣GetOptions()␣will␣catch␣the
die(),␣issue␣the␣error␣message,␣and␣record␣that␣an␣error␣result␣must
be␣returned␣upon␣completion.

If␣the␣text␣of␣the␣error␣message␣starts␣with␣an␣exclamation␣mark␣C<!>
it␣is␣interpreted␣specially␣by␣GetOptions().␣There␣is␣currently␣one
special␣command␣implemented:␣C<die("!FINISH")>␣will␣cause␣GetOptions()
to␣stop␣processing␣options,␣as␣if␣it␣encountered␣a␣double␣dash␣C<-->.

In␣version␣2.37␣the␣first␣argument␣to␣the␣callback␣function␣was
changed␣from␣string␣to␣object.␣This␣was␣done␣to␣make␣room␣for
extensions␣and␣more␣detailed␣control.␣The␣object␣stringifies␣to␣the
option␣name␣so␣this␣change␣should␣not␣introduce␣compatibility
problems.

=head2␣Options␣with␣multiple␣names

Often␣it␣is␣user␣friendly␣to␣supply␣alternate␣mnemonic␣names␣for
options.␣For␣example␣C<--height>␣could␣be␣an␣alternate␣name␣for
C<--length>.␣Alternate␣names␣can␣be␣included␣in␣the␣option
specification,␣separated␣by␣vertical␣bar␣C<|>␣characters.␣To␣implement
the␣above␣example:

␣␣␣␣GetOptions␣('length|height=f'␣=>␣\$length);

The␣first␣name␣is␣called␣the␣I<primary>␣name,␣the␣other␣names␣are
called␣I<aliases>.␣When␣using␣a␣hash␣to␣store␣options,␣the␣key␣will
always␣be␣the␣primary␣name.

Multiple␣alternate␣names␣are␣possible.

=head2␣Case␣and␣abbreviations

Without␣additional␣configuration,␣GetOptions()␣will␣ignore␣the␣case␣of
option␣names,␣and␣allow␣the␣options␣to␣be␣abbreviated␣to␣uniqueness.

␣␣␣␣GetOptions␣('length|height=f'␣=>␣\$length,␣"head"␣=>␣\$head);

This␣call␣will␣allow␣C<--l>␣and␣C<--L>␣for␣the␣length␣option,␣but
requires␣a␣least␣C<--hea>␣and␣C<--hei>␣for␣the␣head␣and␣height␣options.

=head2␣Summary␣of␣Option␣Specifications

Each␣option␣specifier␣consists␣of␣two␣parts:␣the␣name␣specification
and␣the␣argument␣specification.

The␣name␣specification␣contains␣the␣name␣of␣the␣option,␣optionally
followed␣by␣a␣list␣of␣alternative␣names␣separated␣by␣vertical␣bar
characters.

␣␣␣␣length	␣␣␣␣␣␣option␣name␣is␣"length"
␣␣␣␣length|size|l␣␣␣␣␣name␣is␣"length",␣aliases␣are␣"size"␣and␣"l"

The␣argument␣specification␣is␣optional.␣If␣omitted,␣the␣option␣is
considered␣boolean,␣a␣value␣of␣1␣will␣be␣assigned␣when␣the␣option␣is
used␣on␣the␣command␣line.

The␣argument␣specification␣can␣be

=over␣4

=item␣!

The␣option␣does␣not␣take␣an␣argument␣and␣may␣be␣negated␣by␣prefixing
it␣with␣"no"␣or␣"no-".␣E.g.␣C<"foo!">␣will␣allow␣C<--foo>␣(a␣value␣of
1␣will␣be␣assigned)␣as␣well␣as␣C<--nofoo>␣and␣C<--no-foo>␣(a␣value␣of
0␣will␣be␣assigned).␣If␣the␣option␣has␣aliases,␣this␣applies␣to␣the
aliases␣as␣well.

Using␣negation␣on␣a␣single␣letter␣option␣when␣bundling␣is␣in␣effect␣is
pointless␣and␣will␣result␣in␣a␣warning.

=item␣+

The␣option␣does␣not␣take␣an␣argument␣and␣will␣be␣incremented␣by␣1
every␣time␣it␣appears␣on␣the␣command␣line.␣E.g.␣C<"more+">,␣when␣used
with␣C<--more␣--more␣--more>,␣will␣increment␣the␣value␣three␣times,
resulting␣in␣a␣value␣of␣3␣(provided␣it␣was␣0␣or␣undefined␣at␣first).

The␣C<+>␣specifier␣is␣ignored␣if␣the␣option␣destination␣is␣not␣a␣scalar.

=item␣=␣I<type>␣[␣I<desttype>␣]␣[␣I<repeat>␣]

The␣option␣requires␣an␣argument␣of␣the␣given␣type.␣Supported␣types
are:

=over␣4

=item␣s

String.␣An␣arbitrary␣sequence␣of␣characters.␣It␣is␣valid␣for␣the
argument␣to␣start␣with␣C<->␣or␣C<-->.

=item␣i

Integer.␣An␣optional␣leading␣plus␣or␣minus␣sign,␣followed␣by␣a
sequence␣of␣digits.

=item␣o

Extended␣integer,␣Perl␣style.␣This␣can␣be␣either␣an␣optional␣leading
plus␣or␣minus␣sign,␣followed␣by␣a␣sequence␣of␣digits,␣or␣an␣octal
string␣(a␣zero,␣optionally␣followed␣by␣'0',␣'1',␣..␣'7'),␣or␣a
hexadecimal␣string␣(C<0x>␣followed␣by␣'0'␣..␣'9',␣'a'␣..␣'f',␣case
insensitive),␣or␣a␣binary␣string␣(C<0b>␣followed␣by␣a␣series␣of␣'0'
and␣'1').

=item␣f

Real␣number.␣For␣example␣C<3.14>,␣C<-6.23E24>␣and␣so␣on.

=back

The␣I<desttype>␣can␣be␣C<@>␣or␣C<%>␣to␣specify␣that␣the␣option␣is
list␣or␣a␣hash␣valued.␣This␣is␣only␣needed␣when␣the␣destination␣for
the␣option␣value␣is␣not␣otherwise␣specified.␣It␣should␣be␣omitted␣when
not␣needed.

The␣I<repeat>␣specifies␣the␣number␣of␣values␣this␣option␣takes␣per
occurrence␣on␣the␣command␣line.␣It␣has␣the␣format␣C<{>␣[␣I<min>␣]␣[␣C<,>␣[␣I<max>␣]␣]␣C<}>.

I<min>␣denotes␣the␣minimal␣number␣of␣arguments.␣It␣defaults␣to␣1␣for
options␣with␣C<=>␣and␣to␣0␣for␣options␣with␣C<:>,␣see␣below.␣Note␣that
I<min>␣overrules␣the␣C<=>␣/␣C<:>␣semantics.

I<max>␣denotes␣the␣maximum␣number␣of␣arguments.␣It␣must␣be␣at␣least
I<min>.␣If␣I<max>␣is␣omitted,␣I<but␣the␣comma␣is␣not>,␣there␣is␣no
upper␣bound␣to␣the␣number␣of␣argument␣values␣taken.

=item␣:␣I<type>␣[␣I<desttype>␣]

Like␣C<=>,␣but␣designates␣the␣argument␣as␣optional.
If␣omitted,␣an␣empty␣string␣will␣be␣assigned␣to␣string␣values␣options,
and␣the␣value␣zero␣to␣numeric␣options.

Note␣that␣if␣a␣string␣argument␣starts␣with␣C<->␣or␣C<-->,␣it␣will␣be
considered␣an␣option␣on␣itself.

=item␣:␣I<number>␣[␣I<desttype>␣]

Like␣C<:i>,␣but␣if␣the␣value␣is␣omitted,␣the␣I<number>␣will␣be␣assigned.

=item␣:␣+␣[␣I<desttype>␣]

Like␣C<:i>,␣but␣if␣the␣value␣is␣omitted,␣the␣current␣value␣for␣the
option␣will␣be␣incremented.

=back

=head1␣Advanced␣Possibilities

=head2␣Object␣oriented␣interface

Getopt::Long␣can␣be␣used␣in␣an␣object␣oriented␣way␣as␣well:

␣␣␣␣use␣Getopt::Long;
␣␣␣␣$p␣=␣new␣Getopt::Long::Parser;
␣␣␣␣$p->configure(...configuration␣options...);
␣␣␣␣if␣($p->getoptions(...options␣descriptions...))␣...

Configuration␣options␣can␣be␣passed␣to␣the␣constructor:

␣␣␣␣$p␣=␣new␣Getopt::Long::Parser
␣␣␣␣␣␣␣␣␣␣␣␣␣config␣=>␣[...configuration␣options...];

=head2␣Thread␣Safety

Getopt::Long␣is␣thread␣safe␣when␣using␣ithreads␣as␣of␣Perl␣5.8.␣␣It␣is
I<not>␣thread␣safe␣when␣using␣the␣older␣(experimental␣and␣now
obsolete)␣threads␣implementation␣that␣was␣added␣to␣Perl␣5.005.

=head2␣Documentation␣and␣help␣texts

Getopt::Long␣encourages␣the␣use␣of␣Pod::Usage␣to␣produce␣help
messages.␣For␣example:

␣␣␣␣use␣Getopt::Long;
␣␣␣␣use␣Pod::Usage;

␣␣␣␣my␣$man␣=␣0;
␣␣␣␣my␣$help␣=␣0;

␣␣␣␣GetOptions('help|?'␣=>␣\$help,␣man␣=>␣\$man)␣or␣pod2usage(2);
␣␣␣␣pod2usage(1)␣if␣$help;
␣␣␣␣pod2usage(-exitstatus␣=>␣0,␣-verbose␣=>␣2)␣if␣$man;

␣␣␣␣__END__

␣␣␣␣=head1␣NAME

␣␣␣␣sample␣-␣Using␣Getopt::Long␣and␣Pod::Usage

␣␣␣␣=head1␣SYNOPSIS

␣␣␣␣sample␣[options]␣[file␣...]

␣␣␣␣␣Options:
␣␣␣␣␣␣␣-help␣␣␣␣␣␣␣␣␣␣␣␣brief␣help␣message
␣␣␣␣␣␣␣-man␣␣␣␣␣␣␣␣␣␣␣␣␣full␣documentation

␣␣␣␣=head1␣OPTIONS

␣␣␣␣=over␣8

␣␣␣␣=item␣B<-help>

␣␣␣␣Print␣a␣brief␣help␣message␣and␣exits.

␣␣␣␣=item␣B<-man>

␣␣␣␣Prints␣the␣manual␣page␣and␣exits.

␣␣␣␣=back

␣␣␣␣=head1␣DESCRIPTION

␣␣␣␣B<This␣program>␣will␣read␣the␣given␣input␣file(s)␣and␣do␣something
␣␣␣␣useful␣with␣the␣contents␣thereof.

␣␣␣␣=cut

See␣L<Pod::Usage>␣for␣details.

=head2␣Parsing␣options␣from␣an␣arbitrary␣array

By␣default,␣GetOptions␣parses␣the␣options␣that␣are␣present␣in␣the
global␣array␣C<@ARGV>.␣A␣special␣entry␣C<GetOptionsFromArray>␣can␣be
used␣to␣parse␣options␣from␣an␣arbitrary␣array.

␣␣␣␣use␣Getopt::Long␣qw(GetOptionsFromArray);
␣␣␣␣$ret␣=␣GetOptionsFromArray(\@myopts,␣...);

When␣used␣like␣this,␣the␣global␣C<@ARGV>␣is␣not␣touched␣at␣all.

The␣following␣two␣calls␣behave␣identically:

␣␣␣␣$ret␣=␣GetOptions(␣...␣);
␣␣␣␣$ret␣=␣GetOptionsFromArray(\@ARGV,␣...␣);

=head2␣Parsing␣options␣from␣an␣arbitrary␣string

A␣special␣entry␣C<GetOptionsFromString>␣can␣be␣used␣to␣parse␣options
from␣an␣arbitrary␣string.

␣␣␣␣use␣Getopt::Long␣qw(GetOptionsFromString);
␣␣␣␣$ret␣=␣GetOptionsFromString($string,␣...);

The␣contents␣of␣the␣string␣are␣split␣into␣arguments␣using␣a␣call␣to
C<Text::ParseWords::shellwords>.␣As␣with␣C<GetOptionsFromArray>,␣the
global␣C<@ARGV>␣is␣not␣touched.

It␣is␣possible␣that,␣upon␣completion,␣not␣all␣arguments␣in␣the␣string
have␣been␣processed.␣C<GetOptionsFromString>␣will,␣when␣called␣in␣list
context,␣return␣both␣the␣return␣status␣and␣an␣array␣reference␣to␣any
remaining␣arguments:

␣␣␣␣($ret,␣$args)␣=␣GetOptionsFromString($string,␣...␣);

If␣any␣arguments␣remain,␣and␣C<GetOptionsFromString>␣was␣not␣called␣in
list␣context,␣a␣message␣will␣be␣given␣and␣C<GetOptionsFromString>␣will
return␣failure.

=head2␣Storing␣options␣values␣in␣a␣hash

Sometimes,␣for␣example␣when␣there␣are␣a␣lot␣of␣options,␣having␣a
separate␣variable␣for␣each␣of␣them␣can␣be␣cumbersome.␣GetOptions()
supports,␣as␣an␣alternative␣mechanism,␣storing␣options␣values␣in␣a
hash.

To␣obtain␣this,␣a␣reference␣to␣a␣hash␣must␣be␣passed␣I<as␣the␣first
argument>␣to␣GetOptions().␣For␣each␣option␣that␣is␣specified␣on␣the
command␣line,␣the␣option␣value␣will␣be␣stored␣in␣the␣hash␣with␣the
option␣name␣as␣key.␣Options␣that␣are␣not␣actually␣used␣on␣the␣command
line␣will␣not␣be␣put␣in␣the␣hash,␣on␣other␣words,
C<exists($h{option})>␣(or␣defined())␣can␣be␣used␣to␣test␣if␣an␣option
was␣used.␣The␣drawback␣is␣that␣warnings␣will␣be␣issued␣if␣the␣program
runs␣under␣C<use␣strict>␣and␣uses␣C<$h{option}>␣without␣testing␣with
exists()␣or␣defined()␣first.

␣␣␣␣my␣%h␣=␣();
␣␣␣␣GetOptions␣(\%h,␣'length=i');	#␣will␣store␣in␣$h{length}

For␣options␣that␣take␣list␣or␣hash␣values,␣it␣is␣necessary␣to␣indicate
this␣by␣appending␣an␣C<@>␣or␣C<%>␣sign␣after␣the␣type:

␣␣␣␣GetOptions␣(\%h,␣'colours=s@');	#␣will␣push␣to␣@{$h{colours}}

To␣make␣things␣more␣complicated,␣the␣hash␣may␣contain␣references␣to
the␣actual␣destinations,␣for␣example:

␣␣␣␣my␣$len␣=␣0;
␣␣␣␣my␣%h␣=␣('length'␣=>␣\$len);
␣␣␣␣GetOptions␣(\%h,␣'length=i');	#␣will␣store␣in␣$len

This␣example␣is␣fully␣equivalent␣with:

␣␣␣␣my␣$len␣=␣0;
␣␣␣␣GetOptions␣('length=i'␣=>␣\$len);	#␣will␣store␣in␣$len

Any␣mixture␣is␣possible.␣For␣example,␣the␣most␣frequently␣used␣options
could␣be␣stored␣in␣variables␣while␣all␣other␣options␣get␣stored␣in␣the
hash:

␣␣␣␣my␣$verbose␣=␣0;			#␣frequently␣referred
␣␣␣␣my␣$debug␣=␣0;			#␣frequently␣referred
␣␣␣␣my␣%h␣=␣('verbose'␣=>␣\$verbose,␣'debug'␣=>␣\$debug);
␣␣␣␣GetOptions␣(\%h,␣'verbose',␣'debug',␣'filter',␣'size=i');
␣␣␣␣if␣(␣$verbose␣)␣{␣...␣}
␣␣␣␣if␣(␣exists␣$h{filter}␣)␣{␣...␣option␣'filter'␣was␣specified␣...␣}

=head2␣Bundling

With␣bundling␣it␣is␣possible␣to␣set␣several␣single-character␣options
at␣once.␣For␣example␣if␣C<a>,␣C<v>␣and␣C<x>␣are␣all␣valid␣options,

␣␣␣␣-vax

would␣set␣all␣three.

Getopt::Long␣supports␣two␣levels␣of␣bundling.␣To␣enable␣bundling,␣a
call␣to␣Getopt::Long::Configure␣is␣required.

The␣first␣level␣of␣bundling␣can␣be␣enabled␣with:

␣␣␣␣Getopt::Long::Configure␣("bundling");

Configured␣this␣way,␣single-character␣options␣can␣be␣bundled␣but␣long
options␣B<must>␣always␣start␣with␣a␣double␣dash␣C<-->␣to␣avoid
ambiguity.␣For␣example,␣when␣C<vax>,␣C<a>,␣C<v>␣and␣C<x>␣are␣all␣valid
options,

␣␣␣␣-vax

would␣set␣C<a>,␣C<v>␣and␣C<x>,␣but

␣␣␣␣--vax

would␣set␣C<vax>.

The␣second␣level␣of␣bundling␣lifts␣this␣restriction.␣It␣can␣be␣enabled
with:

␣␣␣␣Getopt::Long::Configure␣("bundling_override");

Now,␣C<-vax>␣would␣set␣the␣option␣C<vax>.

When␣any␣level␣of␣bundling␣is␣enabled,␣option␣values␣may␣be␣inserted
in␣the␣bundle.␣For␣example:

␣␣␣␣-h24w80

is␣equivalent␣to

␣␣␣␣-h␣24␣-w␣80

When␣configured␣for␣bundling,␣single-character␣options␣are␣matched
case␣sensitive␣while␣long␣options␣are␣matched␣case␣insensitive.␣To
have␣the␣single-character␣options␣matched␣case␣insensitive␣as␣well,
use:

␣␣␣␣Getopt::Long::Configure␣("bundling",␣"ignorecase_always");

It␣goes␣without␣saying␣that␣bundling␣can␣be␣quite␣confusing.

=head2␣The␣lonesome␣dash

Normally,␣a␣lone␣dash␣C<->␣on␣the␣command␣line␣will␣not␣be␣considered
an␣option.␣Option␣processing␣will␣terminate␣(unless␣"permute"␣is
configured)␣and␣the␣dash␣will␣be␣left␣in␣C<@ARGV>.

It␣is␣possible␣to␣get␣special␣treatment␣for␣a␣lone␣dash.␣This␣can␣be
achieved␣by␣adding␣an␣option␣specification␣with␣an␣empty␣name,␣for
example:

␣␣␣␣GetOptions␣(''␣=>␣\$stdio);

A␣lone␣dash␣on␣the␣command␣line␣will␣now␣be␣a␣legal␣option,␣and␣using
it␣will␣set␣variable␣C<$stdio>.

=head2␣Argument␣callback

A␣special␣option␣'name'␣C<<␣<>␣>>␣can␣be␣used␣to␣designate␣a␣subroutine
to␣handle␣non-option␣arguments.␣When␣GetOptions()␣encounters␣an
argument␣that␣does␣not␣look␣like␣an␣option,␣it␣will␣immediately␣call␣this
subroutine␣and␣passes␣it␣one␣parameter:␣the␣argument␣name.␣Well,␣actually
it␣is␣an␣object␣that␣stringifies␣to␣the␣argument␣name.

For␣example:

␣␣␣␣my␣$width␣=␣80;
␣␣␣␣sub␣process␣{␣...␣}
␣␣␣␣GetOptions␣('width=i'␣=>␣\$width,␣'<>'␣=>␣\&process);

When␣applied␣to␣the␣following␣command␣line:

␣␣␣␣arg1␣--width=72␣arg2␣--width=60␣arg3

This␣will␣call
C<process("arg1")>␣while␣C<$width>␣is␣C<80>,
C<process("arg2")>␣while␣C<$width>␣is␣C<72>,␣and
C<process("arg3")>␣while␣C<$width>␣is␣C<60>.

This␣feature␣requires␣configuration␣option␣B<permute>,␣see␣section
L<Configuring␣Getopt::Long>.

=head1␣Configuring␣Getopt::Long

Getopt::Long␣can␣be␣configured␣by␣calling␣subroutine
Getopt::Long::Configure().␣This␣subroutine␣takes␣a␣list␣of␣quoted
strings,␣each␣specifying␣a␣configuration␣option␣to␣be␣enabled,␣e.g.
C<ignore_case>,␣or␣disabled,␣e.g.␣C<no_ignore_case>.␣Case␣does␣not
matter.␣Multiple␣calls␣to␣Configure()␣are␣possible.

Alternatively,␣as␣of␣version␣2.24,␣the␣configuration␣options␣may␣be
passed␣together␣with␣the␣C<use>␣statement:

␣␣␣␣use␣Getopt::Long␣qw(:config␣no_ignore_case␣bundling);

The␣following␣options␣are␣available:

=over␣12

=item␣default

This␣option␣causes␣all␣configuration␣options␣to␣be␣reset␣to␣their
default␣values.

=item␣posix_default

This␣option␣causes␣all␣configuration␣options␣to␣be␣reset␣to␣their
default␣values␣as␣if␣the␣environment␣variable␣POSIXLY_CORRECT␣had
been␣set.

=item␣auto_abbrev

Allow␣option␣names␣to␣be␣abbreviated␣to␣uniqueness.
Default␣is␣enabled␣unless␣environment␣variable
POSIXLY_CORRECT␣has␣been␣set,␣in␣which␣case␣C<auto_abbrev>␣is␣disabled.

=item␣getopt_compat

Allow␣C<+>␣to␣start␣options.
Default␣is␣enabled␣unless␣environment␣variable
POSIXLY_CORRECT␣has␣been␣set,␣in␣which␣case␣C<getopt_compat>␣is␣disabled.

=item␣gnu_compat

C<gnu_compat>␣controls␣whether␣C<--opt=>␣is␣allowed,␣and␣what␣it␣should
do.␣Without␣C<gnu_compat>,␣C<--opt=>␣gives␣an␣error.␣With␣C<gnu_compat>,
C<--opt=>␣will␣give␣option␣C<opt>␣and␣empty␣value.
This␣is␣the␣way␣GNU␣getopt_long()␣does␣it.

=item␣gnu_getopt

This␣is␣a␣short␣way␣of␣setting␣C<gnu_compat>␣C<bundling>␣C<permute>
C<no_getopt_compat>.␣With␣C<gnu_getopt>,␣command␣line␣handling␣should␣be
fully␣compatible␣with␣GNU␣getopt_long().

=item␣require_order

Whether␣command␣line␣arguments␣are␣allowed␣to␣be␣mixed␣with␣options.
Default␣is␣disabled␣unless␣environment␣variable
POSIXLY_CORRECT␣has␣been␣set,␣in␣which␣case␣C<require_order>␣is␣enabled.

See␣also␣C<permute>,␣which␣is␣the␣opposite␣of␣C<require_order>.

=item␣permute

Whether␣command␣line␣arguments␣are␣allowed␣to␣be␣mixed␣with␣options.
Default␣is␣enabled␣unless␣environment␣variable
POSIXLY_CORRECT␣has␣been␣set,␣in␣which␣case␣C<permute>␣is␣disabled.
Note␣that␣C<permute>␣is␣the␣opposite␣of␣C<require_order>.

If␣C<permute>␣is␣enabled,␣this␣means␣that

␣␣␣␣--foo␣arg1␣--bar␣arg2␣arg3

is␣equivalent␣to

␣␣␣␣--foo␣--bar␣arg1␣arg2␣arg3

If␣an␣argument␣callback␣routine␣is␣specified,␣C<@ARGV>␣will␣always␣be
empty␣upon␣successful␣return␣of␣GetOptions()␣since␣all␣options␣have␣been
processed.␣The␣only␣exception␣is␣when␣C<-->␣is␣used:

␣␣␣␣--foo␣arg1␣--bar␣arg2␣--␣arg3

This␣will␣call␣the␣callback␣routine␣for␣arg1␣and␣arg2,␣and␣then
terminate␣GetOptions()␣leaving␣C<"arg3">␣in␣C<@ARGV>.

If␣C<require_order>␣is␣enabled,␣options␣processing
terminates␣when␣the␣first␣non-option␣is␣encountered.

␣␣␣␣--foo␣arg1␣--bar␣arg2␣arg3

is␣equivalent␣to

␣␣␣␣--foo␣--␣arg1␣--bar␣arg2␣arg3

If␣C<pass_through>␣is␣also␣enabled,␣options␣processing␣will␣terminate
at␣the␣first␣unrecognized␣option,␣or␣non-option,␣whichever␣comes
first.

=item␣bundling␣(default:␣disabled)

Enabling␣this␣option␣will␣allow␣single-character␣options␣to␣be
bundled.␣To␣distinguish␣bundles␣from␣long␣option␣names,␣long␣options
I<must>␣be␣introduced␣with␣C<-->␣and␣bundles␣with␣C<->.

Note␣that,␣if␣you␣have␣options␣C<a>,␣C<l>␣and␣C<all>,␣and
auto_abbrev␣enabled,␣possible␣arguments␣and␣option␣settings␣are:

␣␣␣␣using␣argument␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣sets␣option(s)
␣␣␣␣------------------------------------------
␣␣␣␣-a,␣--a␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣a
␣␣␣␣-l,␣--l␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣l
␣␣␣␣-al,␣-la,␣-ala,␣-all,...␣␣␣␣␣a,␣l
␣␣␣␣--al,␣--all␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣all

The␣surprising␣part␣is␣that␣C<--a>␣sets␣option␣C<a>␣(due␣to␣auto
completion),␣not␣C<all>.

Note:␣disabling␣C<bundling>␣also␣disables␣C<bundling_override>.

=item␣bundling_override␣(default:␣disabled)

If␣C<bundling_override>␣is␣enabled,␣bundling␣is␣enabled␣as␣with
C<bundling>␣but␣now␣long␣option␣names␣override␣option␣bundles.

Note:␣disabling␣C<bundling_override>␣also␣disables␣C<bundling>.

B<Note:>␣Using␣option␣bundling␣can␣easily␣lead␣to␣unexpected␣results,
especially␣when␣mixing␣long␣options␣and␣bundles.␣Caveat␣emptor.

=item␣ignore_case␣␣(default:␣enabled)

If␣enabled,␣case␣is␣ignored␣when␣matching␣long␣option␣names.␣If,
however,␣bundling␣is␣enabled␣as␣well,␣single␣character␣options␣will␣be
treated␣case-sensitive.

With␣C<ignore_case>,␣option␣specifications␣for␣options␣that␣only
differ␣in␣case,␣e.g.,␣C<"foo">␣and␣C<"Foo">,␣will␣be␣flagged␣as
duplicates.

Note:␣disabling␣C<ignore_case>␣also␣disables␣C<ignore_case_always>.

=item␣ignore_case_always␣(default:␣disabled)

When␣bundling␣is␣in␣effect,␣case␣is␣ignored␣on␣single-character
options␣also.

Note:␣disabling␣C<ignore_case_always>␣also␣disables␣C<ignore_case>.

=item␣auto_version␣(default:disabled)

Automatically␣provide␣support␣for␣the␣B<--version>␣option␣if
the␣application␣did␣not␣specify␣a␣handler␣for␣this␣option␣itself.

Getopt::Long␣will␣provide␣a␣standard␣version␣message␣that␣includes␣the
program␣name,␣its␣version␣(if␣$main::VERSION␣is␣defined),␣and␣the
versions␣of␣Getopt::Long␣and␣Perl.␣The␣message␣will␣be␣written␣to
standard␣output␣and␣processing␣will␣terminate.

C<auto_version>␣will␣be␣enabled␣if␣the␣calling␣program␣explicitly
specified␣a␣version␣number␣higher␣than␣2.32␣in␣the␣C<use>␣or
C<require>␣statement.

=item␣auto_help␣(default:disabled)

Automatically␣provide␣support␣for␣the␣B<--help>␣and␣B<-?>␣options␣if
the␣application␣did␣not␣specify␣a␣handler␣for␣this␣option␣itself.

Getopt::Long␣will␣provide␣a␣help␣message␣using␣module␣L<Pod::Usage>.␣The
message,␣derived␣from␣the␣SYNOPSIS␣POD␣section,␣will␣be␣written␣to
standard␣output␣and␣processing␣will␣terminate.

C<auto_help>␣will␣be␣enabled␣if␣the␣calling␣program␣explicitly
specified␣a␣version␣number␣higher␣than␣2.32␣in␣the␣C<use>␣or
C<require>␣statement.

=item␣pass_through␣(default:␣disabled)

Options␣that␣are␣unknown,␣ambiguous␣or␣supplied␣with␣an␣invalid␣option
value␣are␣passed␣through␣in␣C<@ARGV>␣instead␣of␣being␣flagged␣as
errors.␣This␣makes␣it␣possible␣to␣write␣wrapper␣scripts␣that␣process
only␣part␣of␣the␣user␣supplied␣command␣line␣arguments,␣and␣pass␣the
remaining␣options␣to␣some␣other␣program.

If␣C<require_order>␣is␣enabled,␣options␣processing␣will␣terminate␣at
the␣first␣unrecognized␣option,␣or␣non-option,␣whichever␣comes␣first.
However,␣if␣C<permute>␣is␣enabled␣instead,␣results␣can␣become␣confusing.

Note␣that␣the␣options␣terminator␣(default␣C<-->),␣if␣present,␣will
also␣be␣passed␣through␣in␣C<@ARGV>.

=item␣prefix

The␣string␣that␣starts␣options.␣If␣a␣constant␣string␣is␣not
sufficient,␣see␣C<prefix_pattern>.

=item␣prefix_pattern

A␣Perl␣pattern␣that␣identifies␣the␣strings␣that␣introduce␣options.
Default␣is␣C<--|-|\+>␣unless␣environment␣variable
POSIXLY_CORRECT␣has␣been␣set,␣in␣which␣case␣it␣is␣C<--|->.

=item␣long_prefix_pattern

A␣Perl␣pattern␣that␣allows␣the␣disambiguation␣of␣long␣and␣short
prefixes.␣Default␣is␣C<-->.

Typically␣you␣only␣need␣to␣set␣this␣if␣you␣are␣using␣nonstandard
prefixes␣and␣want␣some␣or␣all␣of␣them␣to␣have␣the␣same␣semantics␣as
'--'␣does␣under␣normal␣circumstances.

For␣example,␣setting␣prefix_pattern␣to␣C<--|-|\+|\/>␣and
long_prefix_pattern␣to␣C<--|\/>␣would␣add␣Win32␣style␣argument
handling.

=item␣debug␣(default:␣disabled)

Enable␣debugging␣output.

=back

=head1␣Exportable␣Methods

=over

=item␣VersionMessage

This␣subroutine␣provides␣a␣standard␣version␣message.␣Its␣argument␣can␣be:

=over␣4

=item␣*

A␣string␣containing␣the␣text␣of␣a␣message␣to␣print␣I<before>␣printing
the␣standard␣message.

=item␣*

A␣numeric␣value␣corresponding␣to␣the␣desired␣exit␣status.

=item␣*

A␣reference␣to␣a␣hash.

=back

If␣more␣than␣one␣argument␣is␣given␣then␣the␣entire␣argument␣list␣is
assumed␣to␣be␣a␣hash.␣␣If␣a␣hash␣is␣supplied␣(either␣as␣a␣reference␣or
as␣a␣list)␣it␣should␣contain␣one␣or␣more␣elements␣with␣the␣following
keys:

=over␣4

=item␣C<-message>

=item␣C<-msg>

The␣text␣of␣a␣message␣to␣print␣immediately␣prior␣to␣printing␣the
program's␣usage␣message.

=item␣C<-exitval>

The␣desired␣exit␣status␣to␣pass␣to␣the␣B<exit()>␣function.
This␣should␣be␣an␣integer,␣or␣else␣the␣string␣"NOEXIT"␣to
indicate␣that␣control␣should␣simply␣be␣returned␣without
terminating␣the␣invoking␣process.

=item␣C<-output>

A␣reference␣to␣a␣filehandle,␣or␣the␣pathname␣of␣a␣file␣to␣which␣the
usage␣message␣should␣be␣written.␣The␣default␣is␣C<\*STDERR>␣unless␣the
exit␣value␣is␣less␣than␣2␣(in␣which␣case␣the␣default␣is␣C<\*STDOUT>).

=back

You␣cannot␣tie␣this␣routine␣directly␣to␣an␣option,␣e.g.:

␣␣␣␣GetOptions("version"␣=>␣\&VersionMessage);

Use␣this␣instead:

␣␣␣␣GetOptions("version"␣=>␣sub␣{␣VersionMessage()␣});

=item␣HelpMessage

This␣subroutine␣produces␣a␣standard␣help␣message,␣derived␣from␣the
program's␣POD␣section␣SYNOPSIS␣using␣L<Pod::Usage>.␣It␣takes␣the␣same
arguments␣as␣VersionMessage().␣In␣particular,␣you␣cannot␣tie␣it
directly␣to␣an␣option,␣e.g.:

␣␣␣␣GetOptions("help"␣=>␣\&HelpMessage);

Use␣this␣instead:

␣␣␣␣GetOptions("help"␣=>␣sub␣{␣HelpMessage()␣});

=back

=head1␣Return␣values␣and␣Errors

Configuration␣errors␣and␣errors␣in␣the␣option␣definitions␣are
signalled␣using␣die()␣and␣will␣terminate␣the␣calling␣program␣unless
the␣call␣to␣Getopt::Long::GetOptions()␣was␣embedded␣in␣C<eval␣{␣...
}>,␣or␣die()␣was␣trapped␣using␣C<$SIG{__DIE__}>.

GetOptions␣returns␣true␣to␣indicate␣success.
It␣returns␣false␣when␣the␣function␣detected␣one␣or␣more␣errors␣during
option␣parsing.␣These␣errors␣are␣signalled␣using␣warn()␣and␣can␣be
trapped␣with␣C<$SIG{__WARN__}>.

=head1␣Legacy

The␣earliest␣development␣of␣C<newgetopt.pl>␣started␣in␣1990,␣with␣Perl
version␣4.␣As␣a␣result,␣its␣development,␣and␣the␣development␣of
Getopt::Long,␣has␣gone␣through␣several␣stages.␣Since␣backward
compatibility␣has␣always␣been␣extremely␣important,␣the␣current␣version
of␣Getopt::Long␣still␣supports␣a␣lot␣of␣constructs␣that␣nowadays␣are
no␣longer␣necessary␣or␣otherwise␣unwanted.␣This␣section␣describes
briefly␣some␣of␣these␣'features'.

=head2␣Default␣destinations

When␣no␣destination␣is␣specified␣for␣an␣option,␣GetOptions␣will␣store
the␣resultant␣value␣in␣a␣global␣variable␣named␣C<opt_>I<XXX>,␣where
I<XXX>␣is␣the␣primary␣name␣of␣this␣option.␣When␣a␣progam␣executes
under␣C<use␣strict>␣(recommended),␣these␣variables␣must␣be
pre-declared␣with␣our()␣or␣C<use␣vars>.

␣␣␣␣our␣$opt_length␣=␣0;
␣␣␣␣GetOptions␣('length=i');	#␣will␣store␣in␣$opt_length

To␣yield␣a␣usable␣Perl␣variable,␣characters␣that␣are␣not␣part␣of␣the
syntax␣for␣variables␣are␣translated␣to␣underscores.␣For␣example,
C<--fpp-struct-return>␣will␣set␣the␣variable
C<$opt_fpp_struct_return>.␣Note␣that␣this␣variable␣resides␣in␣the
namespace␣of␣the␣calling␣program,␣not␣necessarily␣C<main>.␣For
example:

␣␣␣␣GetOptions␣("size=i",␣"sizes=i@");

with␣command␣line␣"-size␣10␣-sizes␣24␣-sizes␣48"␣will␣perform␣the
equivalent␣of␣the␣assignments

␣␣␣␣$opt_size␣=␣10;
␣␣␣␣@opt_sizes␣=␣(24,␣48);

=head2␣Alternative␣option␣starters

A␣string␣of␣alternative␣option␣starter␣characters␣may␣be␣passed␣as␣the
first␣argument␣(or␣the␣first␣argument␣after␣a␣leading␣hash␣reference
argument).

␣␣␣␣my␣$len␣=␣0;
␣␣␣␣GetOptions␣('/',␣'length=i'␣=>␣$len);

Now␣the␣command␣line␣may␣look␣like:

␣␣␣␣/length␣24␣--␣arg

Note␣that␣to␣terminate␣options␣processing␣still␣requires␣a␣double␣dash
C<-->.

GetOptions()␣will␣not␣interpret␣a␣leading␣C<<␣"<>"␣>>␣as␣option␣starters
if␣the␣next␣argument␣is␣a␣reference.␣To␣force␣C<<␣"<"␣>>␣and␣C<<␣">"␣>>␣as
option␣starters,␣use␣C<<␣"><"␣>>.␣Confusing?␣Well,␣B<using␣a␣starter
argument␣is␣strongly␣deprecated>␣anyway.

=head2␣Configuration␣variables

Previous␣versions␣of␣Getopt::Long␣used␣variables␣for␣the␣purpose␣of
configuring.␣Although␣manipulating␣these␣variables␣still␣work,␣it␣is
strongly␣encouraged␣to␣use␣the␣C<Configure>␣routine␣that␣was␣introduced
in␣version␣2.17.␣Besides,␣it␣is␣much␣easier.

=head1␣Tips␣and␣Techniques

=head2␣Pushing␣multiple␣values␣in␣a␣hash␣option

Sometimes␣you␣want␣to␣combine␣the␣best␣of␣hashes␣and␣arrays.␣For
example,␣the␣command␣line:

␣␣--list␣add=first␣--list␣add=second␣--list␣add=third

where␣each␣successive␣'list␣add'␣option␣will␣push␣the␣value␣of␣add
into␣array␣ref␣$list->{'add'}.␣The␣result␣would␣be␣like

␣␣$list->{add}␣=␣[qw(first␣second␣third)];

This␣can␣be␣accomplished␣with␣a␣destination␣routine:

␣␣GetOptions('list=s%'␣=>
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣sub␣{␣push(@{$list{$_[1]}},␣$_[2])␣});

=head1␣Troubleshooting

=head2␣GetOptions␣does␣not␣return␣a␣false␣result␣when␣an␣option␣is␣not␣supplied

That's␣why␣they're␣called␣'options'.

=head2␣GetOptions␣does␣not␣split␣the␣command␣line␣correctly

The␣command␣line␣is␣not␣split␣by␣GetOptions,␣but␣by␣the␣command␣line
interpreter␣(CLI).␣On␣Unix,␣this␣is␣the␣shell.␣On␣Windows,␣it␣is
COMMAND.COM␣or␣CMD.EXE.␣Other␣operating␣systems␣have␣other␣CLIs.

It␣is␣important␣to␣know␣that␣these␣CLIs␣may␣behave␣different␣when␣the
command␣line␣contains␣special␣characters,␣in␣particular␣quotes␣or
backslashes.␣For␣example,␣with␣Unix␣shells␣you␣can␣use␣single␣quotes
(C<'>)␣and␣double␣quotes␣(C<">)␣to␣group␣words␣together.␣The␣following
alternatives␣are␣equivalent␣on␣Unix:

␣␣␣␣"two␣words"
␣␣␣␣'two␣words'
␣␣␣␣two\␣words

In␣case␣of␣doubt,␣insert␣the␣following␣statement␣in␣front␣of␣your␣Perl
program:

␣␣␣␣print␣STDERR␣(join("|",@ARGV),"\n");

to␣verify␣how␣your␣CLI␣passes␣the␣arguments␣to␣the␣program.

=head2␣Undefined␣subroutine␣&main::GetOptions␣called

Are␣you␣running␣Windows,␣and␣did␣you␣write

␣␣␣␣use␣GetOpt::Long;

(note␣the␣capital␣'O')?

=head2␣How␣do␣I␣put␣a␣"-?"␣option␣into␣a␣Getopt::Long?

You␣can␣only␣obtain␣this␣using␣an␣alias,␣and␣Getopt::Long␣of␣at␣least
version␣2.13.

␣␣␣␣use␣Getopt::Long;
␣␣␣␣GetOptions␣("help|?");␣␣␣␣#␣-help␣and␣-?␣will␣both␣set␣$opt_help

=head1␣AUTHOR

Johan␣Vromans␣<jvromans@squirrel.nl>

=head1␣COPYRIGHT␣AND␣DISCLAIMER

This␣program␣is␣Copyright␣1990,2009␣by␣Johan␣Vromans.
This␣program␣is␣free␣software;␣you␣can␣redistribute␣it␣and/or
modify␣it␣under␣the␣terms␣of␣the␣Perl␣Artistic␣License␣or␣the
GNU␣General␣Public␣License␣as␣published␣by␣the␣Free␣Software
Foundation;␣either␣version␣2␣of␣the␣License,␣or␣(at␣your␣option)␣any
later␣version.

This␣program␣is␣distributed␣in␣the␣hope␣that␣it␣will␣be␣useful,
but␣WITHOUT␣ANY␣WARRANTY;␣without␣even␣the␣implied␣warranty␣of
MERCHANTABILITY␣or␣FITNESS␣FOR␣A␣PARTICULAR␣PURPOSE.␣␣See␣the
GNU␣General␣Public␣License␣for␣more␣details.

If␣you␣do␣not␣have␣a␣copy␣of␣the␣GNU␣General␣Public␣License␣write␣to
the␣Free␣Software␣Foundation,␣Inc.,␣675␣Mass␣Ave,␣Cambridge,
MA␣02139,␣USA.

=cut
----------
Range: (3167127,3177238) (10111)
=head1␣NAME

autodie::hints␣-␣Provide␣hints␣about␣user␣subroutines␣to␣autodie

=head1␣SYNOPSIS

␣␣␣␣package␣Your::Module;

␣␣␣␣our␣%DOES␣=␣(␣'autodie::hints::provider'␣=>␣1␣);

␣␣␣␣sub␣AUTODIE_HINTS␣{
␣␣␣␣␣␣␣␣return␣{
␣␣␣␣␣␣␣␣␣␣␣␣foo␣=>␣{␣scalar␣=>␣HINTS,␣list␣=>␣SOME_HINTS␣},
␣␣␣␣␣␣␣␣␣␣␣␣bar␣=>␣{␣scalar␣=>␣HINTS,␣list␣=>␣MORE_HINTS␣},
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣#␣Later,␣in␣your␣main␣program...

␣␣␣␣use␣Your::Module␣qw(foo␣bar);
␣␣␣␣use␣autodie␣␣␣␣␣␣qw(:default␣foo␣bar);

␣␣␣␣foo();␣␣␣␣␣␣␣␣␣#␣succeeds␣or␣dies␣based␣on␣scalar␣hints

␣␣␣␣#␣Alternatively,␣hints␣can␣be␣set␣on␣subroutines␣we've
␣␣␣␣#␣imported.

␣␣␣␣use␣autodie::hints;
␣␣␣␣use␣Some::Module␣qw(think_positive);

␣␣␣␣BEGIN␣{
␣␣␣␣␣␣␣␣autodie::hints->set_hints_for(
␣␣␣␣␣␣␣␣␣␣␣␣\&think_positive,
␣␣␣␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣fail␣=>␣sub␣{␣$_[0]␣<=␣0␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣)
␣␣␣␣}
␣␣␣␣use␣autodie␣qw(think_positive);

␣␣␣␣think_positive(...);␣␣␣␣#␣Returns␣positive␣or␣dies.


=head1␣DESCRIPTION

=head2␣Introduction

The␣L<autodie>␣pragma␣is␣very␣smart␣when␣it␣comes␣to␣working␣with
Perl's␣built-in␣functions.␣␣The␣behaviour␣for␣these␣functions␣are
fixed,␣and␣C<autodie>␣knows␣exactly␣how␣they␣try␣to␣signal␣failure.

But␣what␣about␣user-defined␣subroutines␣from␣modules?␣␣If␣you␣use
C<autodie>␣on␣a␣user-defined␣subroutine␣then␣it␣assumes␣the␣following
behaviour␣to␣demonstrate␣failure:

=over

=item␣*

A␣false␣value,␣in␣scalar␣context

=item␣*␣

An␣empty␣list,␣in␣list␣context

=item␣*

A␣list␣containing␣a␣single␣undef,␣in␣list␣context

=back

All␣other␣return␣values␣(including␣the␣list␣of␣the␣single␣zero,␣and␣the
list␣containing␣a␣single␣empty␣string)␣are␣considered␣successful.␣␣However,
real-world␣code␣isn't␣always␣that␣easy.␣␣Perhaps␣the␣code␣you're␣working
with␣returns␣a␣string␣containing␣the␣word␣"FAIL"␣upon␣failure,␣or␣a
two␣element␣list␣containing␣C<(undef,␣"human␣error␣message")>.␣␣To␣make
autodie␣work␣with␣these␣sorts␣of␣subroutines,␣we␣have
the␣I<hinting␣interface>.

The␣hinting␣interface␣allows␣I<hints>␣to␣be␣provided␣to␣C<autodie>
on␣how␣it␣should␣detect␣failure␣from␣user-defined␣subroutines.␣␣While
these␣I<can>␣be␣provided␣by␣the␣end-user␣of␣C<autodie>,␣they␣are␣ideally
written␣into␣the␣module␣itself,␣or␣into␣a␣helper␣module␣or␣sub-class
of␣C<autodie>␣itself.

=head2␣What␣are␣hints?

A␣I<hint>␣is␣a␣subroutine␣or␣value␣that␣is␣checked␣against␣the
return␣value␣of␣an␣autodying␣subroutine.␣␣If␣the␣match␣returns␣true,
C<autodie>␣considers␣the␣subroutine␣to␣have␣failed.

If␣the␣hint␣provided␣is␣a␣subroutine,␣then␣C<autodie>␣will␣pass
the␣complete␣return␣value␣to␣that␣subroutine.␣␣If␣the␣hint␣is
any␣other␣value,␣then␣C<autodie>␣will␣smart-match␣against␣the
value␣provided.␣␣In␣Perl␣5.8.x␣there␣is␣no␣smart-match␣operator,␣and␣as␣such
only␣subroutine␣hints␣are␣supported␣in␣these␣versions.

Hints␣can␣be␣provided␣for␣both␣scalar␣and␣list␣contexts.␣␣Note
that␣an␣autodying␣subroutine␣will␣never␣see␣a␣void␣context,␣as
C<autodie>␣always␣needs␣to␣capture␣the␣return␣value␣for␣examination.
Autodying␣subroutines␣called␣in␣void␣context␣act␣as␣if␣they're␣called
in␣a␣scalar␣context,␣but␣their␣return␣value␣is␣discarded␣after␣it
has␣been␣checked.

=head2␣Example␣hints

Hints␣may␣consist␣of␣scalars,␣array␣references,␣regular␣expressions␣and
subroutine␣references.␣␣You␣can␣specify␣different␣hints␣for␣how
failure␣should␣be␣identified␣in␣scalar␣and␣list␣contexts.

These␣examples␣apply␣for␣use␣in␣the␣C<AUTODIE_HINTS>␣subroutine␣and␣when
calling␣C<autodie::hints->set_hints_for()>.

The␣most␣common␣context-specific␣hints␣are:

␣␣␣␣␣␣␣␣#␣Scalar␣failures␣always␣return␣undef:
␣␣␣␣␣␣␣␣␣␣␣␣{␣␣scalar␣=>␣undef␣␣}

␣␣␣␣␣␣␣␣#␣Scalar␣failures␣return␣any␣false␣value␣[default␣expectation]:
␣␣␣␣␣␣␣␣␣␣␣␣{␣␣scalar␣=>␣sub␣{␣!␣$_[0]␣}␣␣}

␣␣␣␣␣␣␣␣#␣Scalar␣failures␣always␣return␣zero␣explicitly:
␣␣␣␣␣␣␣␣␣␣␣␣{␣␣scalar␣=>␣'0'␣␣}

␣␣␣␣␣␣␣␣#␣List␣failures␣always␣return␣an␣empty␣list:
␣␣␣␣␣␣␣␣␣␣␣␣{␣␣list␣=>␣[]␣␣}

␣␣␣␣␣␣␣␣#␣List␣failures␣return␣()␣or␣(undef)␣[default␣expectation]:
␣␣␣␣␣␣␣␣␣␣␣␣{␣␣list␣=>␣sub␣{␣!␣@_␣||␣@_␣==␣1␣&&␣!defined␣$_[0]␣}␣␣}

␣␣␣␣␣␣␣␣#␣List␣failures␣return␣()␣or␣a␣single␣false␣value:
␣␣␣␣␣␣␣␣␣␣␣␣{␣␣list␣=>␣sub␣{␣!␣@_␣||␣@_␣==␣1␣&&␣!$_[0]␣}␣␣}

␣␣␣␣␣␣␣␣#␣List␣failures␣return␣(undef,␣"some␣string")
␣␣␣␣␣␣␣␣␣␣␣␣{␣␣list␣=>␣sub␣{␣@_␣==␣2␣&&␣!defined␣$_[0]␣}␣␣}

␣␣␣␣␣␣␣␣#␣Unsuccessful␣foo()␣returns␣'FAIL'␣or␣'_FAIL'␣in␣scalar␣context,
␣␣␣␣␣␣␣␣#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣returns␣(-1)␣in␣list␣context...
␣␣␣␣␣␣␣␣autodie::hints->set_hints_for(
␣␣␣␣␣␣␣␣␣␣␣␣\&foo,
␣␣␣␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣scalar␣=>␣qr/^␣_?␣FAIL␣$/xms,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣list␣␣␣=>␣[-1],
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣);

␣␣␣␣␣␣␣␣#␣Unsuccessful␣foo()␣returns␣0␣in␣all␣contexts...
␣␣␣␣␣␣␣␣autodie::hints->set_hints_for(
␣␣␣␣␣␣␣␣␣␣␣␣\&foo,
␣␣␣␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣scalar␣=>␣0,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣list␣␣␣=>␣[0],
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣);

This␣"in␣all␣contexts"␣construction␣is␣very␣common,␣and␣can␣be
abbreviated,␣using␣the␣'fail'␣key.␣␣This␣sets␣both␣the␣C<scalar>
and␣C<list>␣hints␣to␣the␣same␣value:

␣␣␣␣␣␣␣␣#␣Unsuccessful␣foo()␣returns␣0␣in␣all␣contexts...
␣␣␣␣␣␣␣␣autodie::hints->set_hints_for(
␣␣␣␣␣␣␣␣␣␣␣␣\&foo,
␣␣␣␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣fail␣=>␣sub␣{␣@_␣==␣1␣and␣defined␣$_[0]␣and␣$_[0]␣==␣0␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
	);

␣␣␣␣␣␣␣␣#␣Unsuccessful␣think_positive()␣returns␣negative␣number␣on␣failure...
␣␣␣␣␣␣␣␣autodie::hints->set_hints_for(
␣␣␣␣␣␣␣␣␣␣␣␣\&think_positive,
␣␣␣␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣fail␣=>␣sub␣{␣$_[0]␣<␣0␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
	);

␣␣␣␣␣␣␣␣#␣Unsuccessful␣my_system()␣returns␣non-zero␣on␣failure...
␣␣␣␣␣␣␣␣autodie::hints->set_hints_for(
␣␣␣␣␣␣␣␣␣␣␣␣\&my_system,
␣␣␣␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣fail␣=>␣sub␣{␣$_[0]␣!=␣0␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
	);

=head1␣Manually␣setting␣hints␣from␣within␣your␣program

If␣you␣are␣using␣a␣module␣which␣returns␣something␣special␣on␣failure,␣then
you␣can␣manually␣create␣hints␣for␣each␣of␣the␣desired␣subroutines.␣␣Once
the␣hints␣are␣specified,␣they␣are␣available␣for␣all␣files␣and␣modules␣loaded
thereafter,␣thus␣you␣can␣move␣this␣work␣into␣a␣module␣and␣it␣will␣still
work.

	use␣Some::Module␣qw(foo␣bar);
	use␣autodie::hints;

	autodie::hints->set_hints_for(
		\&foo,
		{
			scalar␣=>␣SCALAR_HINT,
			list␣␣␣=>␣LIST_HINT,
		}
	);
	autodie::hints->set_hints_for(
		\&bar,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣fail␣=>␣SOME_HINT,␣}
	);

It␣is␣possible␣to␣pass␣either␣a␣subroutine␣reference␣(recommended)␣or␣a␣fully
qualified␣subroutine␣name␣as␣the␣first␣argument.␣␣This␣means␣you␣can␣set␣hints
on␣modules␣that␣I<might>␣get␣loaded:

	use␣autodie::hints;
	autodie::hints->set_hints_for(
		'Some::Module:bar',␣{␣fail␣=>␣SCALAR_HINT,␣}
	);

This␣technique␣is␣most␣useful␣when␣you␣have␣a␣project␣that␣uses␣a
lot␣of␣third-party␣modules.␣␣You␣can␣define␣all␣your␣possible␣hints
in␣one-place.␣␣This␣can␣even␣be␣in␣a␣sub-class␣of␣autodie.␣␣For
example:

␣␣␣␣␣␣␣␣package␣my::autodie;

␣␣␣␣␣␣␣␣use␣parent␣qw(autodie);
␣␣␣␣␣␣␣␣use␣autodie::hints;

␣␣␣␣␣␣␣␣autodie::hints->set_hints_for(...);

␣␣␣␣␣␣␣␣1;

You␣can␣now␣C<use␣my::autodie>,␣which␣will␣work␣just␣like␣the␣standard
C<autodie>,␣but␣is␣now␣aware␣of␣any␣hints␣that␣you've␣set.

=head1␣Adding␣hints␣to␣your␣module

C<autodie>␣provides␣a␣passive␣interface␣to␣allow␣you␣to␣declare␣hints␣for
your␣module.␣␣These␣hints␣will␣be␣found␣and␣used␣by␣C<autodie>␣if␣it
is␣loaded,␣but␣otherwise␣have␣no␣effect␣(or␣dependencies)␣without␣autodie.
To␣set␣these,␣your␣module␣needs␣to␣declare␣that␣it␣I<does>␣the
C<autodie::hints::provider>␣role.␣␣This␣can␣be␣done␣by␣writing␣your
own␣C<DOES>␣method,␣using␣a␣system␣such␣as␣C<Class::DOES>␣to␣handle
the␣heavy-lifting␣for␣you,␣or␣declaring␣a␣C<%DOES>␣package␣variable
with␣a␣C<autodie::hints::provider>␣key␣and␣a␣corresponding␣true␣value.

Note␣that␣checking␣for␣a␣C<%DOES>␣hash␣is␣an␣C<autodie>-only
short-cut.␣␣Other␣modules␣do␣not␣use␣this␣mechanism␣for␣checking
roles,␣although␣you␣can␣use␣the␣C<Class::DOES>␣module␣from␣the
CPAN␣to␣allow␣it.

In␣addition,␣you␣must␣define␣a␣C<AUTODIE_HINTS>␣subroutine␣that␣returns
a␣hash-reference␣containing␣the␣hints␣for␣your␣subroutines:

␣␣␣␣␣␣␣␣package␣Your::Module;

␣␣␣␣␣␣␣␣#␣We␣can␣use␣the␣Class::DOES␣from␣the␣CPAN␣to␣declare␣adherence
␣␣␣␣␣␣␣␣#␣to␣a␣role.

␣␣␣␣␣␣␣␣use␣Class::DOES␣'autodie::hints::provider'␣=>␣1;

␣␣␣␣␣␣␣␣#␣Alternatively,␣we␣can␣declare␣the␣role␣in␣%DOES.␣␣Note␣that
␣␣␣␣␣␣␣␣#␣this␣is␣an␣autodie␣specific␣optimisation,␣although␣Class::DOES
␣␣␣␣␣␣␣␣#␣can␣be␣used␣to␣promote␣this␣to␣a␣true␣role␣declaration.

␣␣␣␣␣␣␣␣our␣%DOES␣=␣(␣'autodie::hints::provider'␣=>␣1␣);

␣␣␣␣␣␣␣␣#␣Finally,␣we␣must␣define␣the␣hints␣themselves.

	sub␣AUTODIE_HINTS␣{
	␣␣␣␣return␣{
	␣␣␣␣␣␣␣␣foo␣=>␣{␣scalar␣=>␣HINTS,␣list␣=>␣SOME_HINTS␣},
	␣␣␣␣␣␣␣␣bar␣=>␣{␣scalar␣=>␣HINTS,␣list␣=>␣MORE_HINTS␣},
	␣␣␣␣␣␣␣␣baz␣=>␣{␣fail␣=>␣HINTS␣},
	␣␣␣␣}
	}

This␣allows␣your␣code␣to␣set␣hints␣without␣relying␣on␣C<autodie>␣and
C<autodie::hints>␣being␣loaded,␣or␣even␣installed.␣␣In␣this␣way␣your
code␣can␣do␣the␣right␣thing␣when␣C<autodie>␣is␣installed,␣but␣does␣not
need␣to␣depend␣upon␣it␣to␣function.

=head1␣Insisting␣on␣hints

When␣a␣user-defined␣subroutine␣is␣wrapped␣by␣C<autodie>,␣it␣will
use␣hints␣if␣they␣are␣available,␣and␣otherwise␣reverts␣to␣the
I<default␣behaviour>␣described␣in␣the␣introduction␣of␣this␣document.
This␣can␣be␣problematic␣if␣we␣expect␣a␣hint␣to␣exist,␣but␣(for
whatever␣reason)␣it␣has␣not␣been␣loaded.

We␣can␣ask␣autodie␣to␣I<insist>␣that␣a␣hint␣be␣used␣by␣prefixing
an␣exclamation␣mark␣to␣the␣start␣of␣the␣subroutine␣name.␣␣A␣lone
exclamation␣mark␣indicates␣that␣I<all>␣subroutines␣after␣it␣must
have␣hints␣declared.

	#␣foo()␣and␣bar()␣must␣have␣their␣hints␣defined
	use␣autodie␣qw(␣!foo␣!bar␣baz␣);

	#␣Everything␣must␣have␣hints␣(recommended).
	use␣autodie␣qw(␣!␣foo␣bar␣baz␣);

	#␣bar()␣and␣baz()␣must␣have␣their␣hints␣defined
	use␣autodie␣qw(␣foo␣!␣bar␣baz␣);

␣␣␣␣␣␣␣␣#␣Enable␣autodie␣for␣all␣of␣Perl's␣supported␣built-ins,
␣␣␣␣␣␣␣␣#␣as␣well␣as␣for␣foo(),␣bar()␣and␣baz().␣␣Everything␣must
␣␣␣␣␣␣␣␣#␣have␣hints.
␣␣␣␣␣␣␣␣use␣autodie␣qw(␣!␣:all␣foo␣bar␣baz␣);

If␣hints␣are␣not␣available␣for␣the␣specified␣subroutines,␣this␣will␣cause␣a
compile-time␣error.␣␣Insisting␣on␣hints␣for␣Perl's␣built-in␣functions
(eg,␣C<open>␣and␣C<close>)␣is␣always␣successful.

Insisting␣on␣hints␣is␣I<strongly>␣recommended.

=cut
----------
Range: (3356389,3363686) (7297)
}
}

=head1␣INDIVIDUAL␣RESULTS

If␣you've␣read␣this␣far␣in␣the␣docs,␣you've␣seen␣this:

␣␣␣␣while␣(␣my␣$result␣=␣$parser->next␣)␣{
␣␣␣␣␣␣␣␣print␣$result->as_string;
␣␣␣␣}

Each␣result␣returned␣is␣a␣L<TAP::Parser::Result>␣subclass,␣referred␣to␣as
I<result␣types>.

=head2␣Result␣types

Basically,␣you␣fetch␣individual␣results␣from␣the␣TAP.␣␣The␣six␣types,␣with
examples␣of␣each,␣are␣as␣follows:

=over␣4

=item␣*␣Version

␣TAP␣version␣12

=item␣*␣Plan

␣1..42

=item␣*␣Pragma

␣pragma␣+strict

=item␣*␣Test

␣ok␣3␣-␣We␣should␣start␣with␣some␣foobar!

=item␣*␣Comment

␣#␣Hope␣we␣don't␣use␣up␣the␣foobar.

=item␣*␣Bailout

␣Bail␣out!␣␣We␣ran␣out␣of␣foobar!

=item␣*␣Unknown

␣...␣yo,␣this␣ain't␣TAP!␣...

=back

Each␣result␣fetched␣is␣a␣result␣object␣of␣a␣different␣type.␣␣There␣are␣common
methods␣to␣each␣result␣object␣and␣different␣types␣may␣have␣methods␣unique␣to
their␣type.␣␣Sometimes␣a␣type␣method␣may␣be␣overridden␣in␣a␣subclass,␣but␣its
use␣is␣guaranteed␣to␣be␣identical.

=head2␣Common␣type␣methods

=head3␣C<type>

Returns␣the␣type␣of␣result,␣such␣as␣C<comment>␣or␣C<test>.

=head3␣C<as_string>

Prints␣a␣string␣representation␣of␣the␣token.␣␣This␣might␣not␣be␣the␣exact
output,␣however.␣␣Tests␣will␣have␣test␣numbers␣added␣if␣not␣present,␣TODO␣and
SKIP␣directives␣will␣be␣capitalized␣and,␣in␣general,␣things␣will␣be␣cleaned
up.␣␣If␣you␣need␣the␣original␣text␣for␣the␣token,␣see␣the␣C<raw>␣method.

=head3␣␣C<raw>

Returns␣the␣original␣line␣of␣text␣which␣was␣parsed.

=head3␣C<is_plan>

Indicates␣whether␣or␣not␣this␣is␣the␣test␣plan␣line.

=head3␣C<is_test>

Indicates␣whether␣or␣not␣this␣is␣a␣test␣line.

=head3␣C<is_comment>

Indicates␣whether␣or␣not␣this␣is␣a␣comment.␣Comments␣will␣generally␣only
appear␣in␣the␣TAP␣stream␣if␣STDERR␣is␣merged␣to␣STDOUT.␣See␣the
C<merge>␣option.

=head3␣C<is_bailout>

Indicates␣whether␣or␣not␣this␣is␣bailout␣line.

=head3␣C<is_yaml>

Indicates␣whether␣or␣not␣the␣current␣item␣is␣a␣YAML␣block.

=head3␣C<is_unknown>

Indicates␣whether␣or␣not␣the␣current␣line␣could␣be␣parsed.

=head3␣C<is_ok>

␣␣if␣(␣$result->is_ok␣)␣{␣...␣}

Reports␣whether␣or␣not␣a␣given␣result␣has␣passed.␣␣Anything␣which␣is␣B<not>␣a
test␣result␣returns␣true.␣␣This␣is␣merely␣provided␣as␣a␣convenient␣shortcut
which␣allows␣you␣to␣do␣this:

␣my␣$parser␣=␣TAP::Parser->new(␣{␣source␣=>␣$source␣}␣);
␣while␣(␣my␣$result␣=␣$parser->next␣)␣{
␣␣␣␣␣#␣only␣print␣failing␣results
␣␣␣␣␣print␣$result->as_string␣unless␣$result->is_ok;
␣}

=head2␣C<plan>␣methods

␣if␣(␣$result->is_plan␣)␣{␣...␣}

If␣the␣above␣evaluates␣as␣true,␣the␣following␣methods␣will␣be␣available␣on␣the
C<$result>␣object.

=head3␣C<plan>

␣␣if␣(␣$result->is_plan␣)␣{
␣␣␣␣␣print␣$result->plan;
␣␣}

This␣is␣merely␣a␣synonym␣for␣C<as_string>.

=head3␣C<directive>

␣my␣$directive␣=␣$result->directive;

If␣a␣SKIP␣directive␣is␣included␣with␣the␣plan,␣this␣method␣will␣return␣it.

␣1..0␣#␣SKIP:␣why␣bother?

=head3␣C<explanation>

␣my␣$explanation␣=␣$result->explanation;

If␣a␣SKIP␣directive␣was␣included␣with␣the␣plan,␣this␣method␣will␣return␣the
explanation,␣if␣any.

=head2␣C<pragma>␣methods

␣if␣(␣$result->is_pragma␣)␣{␣...␣}

If␣the␣above␣evaluates␣as␣true,␣the␣following␣methods␣will␣be␣available␣on␣the
C<$result>␣object.

=head3␣C<pragmas>

Returns␣a␣list␣of␣pragmas␣each␣of␣which␣is␣a␣+␣or␣-␣followed␣by␣the
pragma␣name.
␣
=head2␣C<commment>␣methods

␣if␣(␣$result->is_comment␣)␣{␣...␣}

If␣the␣above␣evaluates␣as␣true,␣the␣following␣methods␣will␣be␣available␣on␣the
C<$result>␣object.

=head3␣C<comment>

␣␣if␣(␣$result->is_comment␣)␣{
␣␣␣␣␣␣my␣$comment␣=␣$result->comment;
␣␣␣␣␣␣print␣"I␣have␣something␣to␣say:␣␣$comment";
␣␣}

=head2␣C<bailout>␣methods

␣if␣(␣$result->is_bailout␣)␣{␣...␣}

If␣the␣above␣evaluates␣as␣true,␣the␣following␣methods␣will␣be␣available␣on␣the
C<$result>␣object.

=head3␣C<explanation>

␣␣if␣(␣$result->is_bailout␣)␣{
␣␣␣␣␣␣my␣$explanation␣=␣$result->explanation;
␣␣␣␣␣␣print␣"We␣bailed␣out␣because␣($explanation)";
␣␣}

If,␣and␣only␣if,␣a␣token␣is␣a␣bailout␣token,␣you␣can␣get␣an␣"explanation"␣via
this␣method.␣␣The␣explanation␣is␣the␣text␣after␣the␣mystical␣"Bail␣out!"␣words
which␣appear␣in␣the␣tap␣output.

=head2␣C<unknown>␣methods

␣if␣(␣$result->is_unknown␣)␣{␣...␣}

There␣are␣no␣unique␣methods␣for␣unknown␣results.

=head2␣C<test>␣methods

␣if␣(␣$result->is_test␣)␣{␣...␣}

If␣the␣above␣evaluates␣as␣true,␣the␣following␣methods␣will␣be␣available␣on␣the
C<$result>␣object.

=head3␣C<ok>

␣␣my␣$ok␣=␣$result->ok;

Returns␣the␣literal␣text␣of␣the␣C<ok>␣or␣C<not␣ok>␣status.

=head3␣C<number>

␣␣my␣$test_number␣=␣$result->number;

Returns␣the␣number␣of␣the␣test,␣even␣if␣the␣original␣TAP␣output␣did␣not␣supply
that␣number.

=head3␣C<description>

␣␣my␣$description␣=␣$result->description;

Returns␣the␣description␣of␣the␣test,␣if␣any.␣␣This␣is␣the␣portion␣after␣the
test␣number␣but␣before␣the␣directive.

=head3␣C<directive>

␣␣my␣$directive␣=␣$result->directive;

Returns␣either␣C<TODO>␣or␣C<SKIP>␣if␣either␣directive␣was␣present␣for␣a␣test
line.

=head3␣C<explanation>

␣␣my␣$explanation␣=␣$result->explanation;

If␣a␣test␣had␣either␣a␣C<TODO>␣or␣C<SKIP>␣directive,␣this␣method␣will␣return
the␣accompanying␣explantion,␣if␣present.

␣␣not␣ok␣17␣-␣'Pigs␣can␣fly'␣#␣TODO␣not␣enough␣acid

For␣the␣above␣line,␣the␣explanation␣is␣I<not␣enough␣acid>.

=head3␣C<is_ok>

␣␣if␣(␣$result->is_ok␣)␣{␣...␣}

Returns␣a␣boolean␣value␣indicating␣whether␣or␣not␣the␣test␣passed.␣␣Remember
that␣for␣TODO␣tests,␣the␣test␣always␣passes.

B<Note:>␣␣this␣was␣formerly␣C<passed>.␣␣The␣latter␣method␣is␣deprecated␣and
will␣issue␣a␣warning.

=head3␣C<is_actual_ok>

␣␣if␣(␣$result->is_actual_ok␣)␣{␣...␣}

Returns␣a␣boolean␣value␣indicating␣whether␣or␣not␣the␣test␣passed,␣regardless
of␣its␣TODO␣status.

B<Note:>␣␣this␣was␣formerly␣C<actual_passed>.␣␣The␣latter␣method␣is␣deprecated
and␣will␣issue␣a␣warning.

=head3␣C<is_unplanned>

␣␣if␣(␣$test->is_unplanned␣)␣{␣...␣}

If␣a␣test␣number␣is␣greater␣than␣the␣number␣of␣planned␣tests,␣this␣method␣will
return␣true.␣␣Unplanned␣tests␣will␣I<always>␣return␣false␣for␣C<is_ok>,
regardless␣of␣whether␣or␣not␣the␣test␣C<has_todo>␣(see
L<TAP::Parser::Result::Test>␣for␣more␣information␣about␣this).

=head3␣C<has_skip>

␣␣if␣(␣$result->has_skip␣)␣{␣...␣}

Returns␣a␣boolean␣value␣indicating␣whether␣or␣not␣this␣test␣had␣a␣SKIP
directive.

=head3␣C<has_todo>

␣␣if␣(␣$result->has_todo␣)␣{␣...␣}

Returns␣a␣boolean␣value␣indicating␣whether␣or␣not␣this␣test␣had␣a␣TODO
directive.

Note␣that␣TODO␣tests␣I<always>␣pass.␣␣If␣you␣need␣to␣know␣whether␣or␣not
they␣really␣passed,␣check␣the␣C<is_actual_ok>␣method.

=head3␣C<in_todo>

␣␣if␣(␣$parser->in_todo␣)␣{␣...␣}

True␣while␣the␣most␣recent␣result␣was␣a␣TODO.␣Becomes␣true␣before␣the
TODO␣result␣is␣returned␣and␣stays␣true␣until␣just␣before␣the␣next␣non-
TODO␣test␣is␣returned.

=head1␣TOTAL␣RESULTS

After␣parsing␣the␣TAP,␣there␣are␣many␣methods␣available␣to␣let␣you␣dig␣through
the␣results␣and␣determine␣what␣is␣meaningful␣to␣you.

=head2␣Individual␣Results

These␣results␣refer␣to␣individual␣tests␣which␣are␣run.

=head3␣C<passed>

␣my␣@passed␣=␣$parser->passed;␣#␣the␣test␣numbers␣which␣passed
␣my␣$passed␣=␣$parser->passed;␣#␣the␣number␣of␣tests␣which␣passed

This␣method␣lets␣you␣know␣which␣(or␣how␣many)␣tests␣passed.␣␣If␣a␣test␣failed
but␣had␣a␣TODO␣directive,␣it␣will␣be␣counted␣as␣a␣passed␣test.

=cut
----------
Range: (3383552,3392927) (9375)
=head1␣CALLBACKS

As␣mentioned␣earlier,␣a␣"callback"␣key␣may␣be␣added␣to␣the
C<TAP::Parser>␣constructor.␣If␣present,␣each␣callback␣corresponding␣to␣a
given␣result␣type␣will␣be␣called␣with␣the␣result␣as␣the␣argument␣if␣the
C<run>␣method␣is␣used.␣The␣callback␣is␣expected␣to␣be␣a␣subroutine
reference␣(or␣anonymous␣subroutine)␣which␣is␣invoked␣with␣the␣parser
result␣as␣its␣argument.

␣my␣%callbacks␣=␣(
␣␣␣␣␣test␣␣␣␣=>␣\&test_callback,
␣␣␣␣␣plan␣␣␣␣=>␣\&plan_callback,
␣␣␣␣␣comment␣=>␣\&comment_callback,
␣␣␣␣␣bailout␣=>␣\&bailout_callback,
␣␣␣␣␣unknown␣=>␣\&unknown_callback,
␣);

␣my␣$aggregator␣=␣TAP::Parser::Aggregator->new;
␣foreach␣my␣$file␣(␣@test_files␣)␣{
␣␣␣␣␣my␣$parser␣=␣TAP::Parser->new(
␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣source␣␣␣␣=>␣$file,
␣␣␣␣␣␣␣␣␣␣␣␣␣callbacks␣=>␣\%callbacks,
␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣);
␣␣␣␣␣$parser->run;
␣␣␣␣␣$aggregator->add(␣$file,␣$parser␣);
␣}

Callbacks␣may␣also␣be␣added␣like␣this:

␣$parser->callback(␣test␣=>␣\&test_callback␣);
␣$parser->callback(␣plan␣=>␣\&plan_callback␣);

The␣following␣keys␣allowed␣for␣callbacks.␣These␣keys␣are␣case-sensitive.

=over␣4

=item␣*␣C<test>

Invoked␣if␣C<<␣$result->is_test␣>>␣returns␣true.

=item␣*␣C<version>

Invoked␣if␣C<<␣$result->is_version␣>>␣returns␣true.

=item␣*␣C<plan>

Invoked␣if␣C<<␣$result->is_plan␣>>␣returns␣true.

=item␣*␣C<comment>

Invoked␣if␣C<<␣$result->is_comment␣>>␣returns␣true.

=item␣*␣C<bailout>

Invoked␣if␣C<<␣$result->is_unknown␣>>␣returns␣true.

=item␣*␣C<yaml>

Invoked␣if␣C<<␣$result->is_yaml␣>>␣returns␣true.

=item␣*␣C<unknown>

Invoked␣if␣C<<␣$result->is_unknown␣>>␣returns␣true.

=item␣*␣C<ELSE>

If␣a␣result␣does␣not␣have␣a␣callback␣defined␣for␣it,␣this␣callback␣will
be␣invoked.␣Thus,␣if␣all␣of␣the␣previous␣result␣types␣are␣specified␣as
callbacks,␣this␣callback␣will␣I<never>␣be␣invoked.

=item␣*␣C<ALL>

This␣callback␣will␣always␣be␣invoked␣and␣this␣will␣happen␣for␣each
result␣after␣one␣of␣the␣above␣callbacks␣is␣invoked.␣␣For␣example,␣if
L<Term::ANSIColor>␣is␣loaded,␣you␣could␣use␣the␣following␣to␣color␣your
test␣output:

␣my␣%callbacks␣=␣(
␣␣␣␣␣test␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣my␣$test␣=␣shift;
␣␣␣␣␣␣␣␣␣if␣(␣$test->is_ok␣&&␣not␣$test->directive␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣#␣normal␣passing␣test
␣␣␣␣␣␣␣␣␣␣␣␣␣print␣color␣'green';
␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣elsif␣(␣!$test->is_ok␣)␣{␣␣␣␣#␣even␣if␣it's␣TODO
␣␣␣␣␣␣␣␣␣␣␣␣␣print␣color␣'white␣on_red';
␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣elsif␣(␣$test->has_skip␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣print␣color␣'white␣on_blue';

␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣elsif␣(␣$test->has_todo␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣print␣color␣'white';
␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣},
␣␣␣␣␣ELSE␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣#␣plan,␣comment,␣and␣so␣on␣(anything␣which␣isn't␣a␣test␣line)
␣␣␣␣␣␣␣␣␣print␣color␣'black␣on_white';
␣␣␣␣␣},
␣␣␣␣␣ALL␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣#␣now␣print␣them
␣␣␣␣␣␣␣␣␣print␣shift->as_string;
␣␣␣␣␣␣␣␣␣print␣color␣'reset';
␣␣␣␣␣␣␣␣␣print␣"\n";
␣␣␣␣␣},
␣);

=item␣*␣C<EOF>

Invoked␣when␣there␣are␣no␣more␣lines␣to␣be␣parsed.␣Since␣there␣is␣no
accompanying␣L<TAP::Parser::Result>␣object␣the␣C<TAP::Parser>␣object␣is
passed␣instead.

=back

=head1␣TAP␣GRAMMAR

If␣you're␣looking␣for␣an␣EBNF␣grammar,␣see␣L<TAP::Parser::Grammar>.

=head1␣BACKWARDS␣COMPATABILITY

The␣Perl-QA␣list␣attempted␣to␣ensure␣backwards␣compatability␣with
L<Test::Harness>.␣␣However,␣there␣are␣some␣minor␣differences.

=head2␣Differences

=over␣4

=item␣*␣TODO␣plans

A␣little-known␣feature␣of␣L<Test::Harness>␣is␣that␣it␣supported␣TODO
lists␣in␣the␣plan:

␣1..2␣todo␣2
␣ok␣1␣-␣We␣have␣liftoff
␣not␣ok␣2␣-␣Anti-gravity␣device␣activated

Under␣L<Test::Harness>,␣test␣number␣2␣would␣I<pass>␣because␣it␣was
listed␣as␣a␣TODO␣test␣on␣the␣plan␣line.␣However,␣we␣are␣not␣aware␣of
anyone␣actually␣using␣this␣feature␣and␣hard-coding␣test␣numbers␣is
discouraged␣because␣it's␣very␣easy␣to␣add␣a␣test␣and␣break␣the␣test
number␣sequence.␣This␣makes␣test␣suites␣very␣fragile.␣Instead,␣the
following␣should␣be␣used:

␣1..2
␣ok␣1␣-␣We␣have␣liftoff
␣not␣ok␣2␣-␣Anti-gravity␣device␣activated␣#␣TODO

=item␣*␣'Missing'␣tests

It␣rarely␣happens,␣but␣sometimes␣a␣harness␣might␣encounter
'missing␣tests:

␣ok␣1
␣ok␣2
␣ok␣15
␣ok␣16
␣ok␣17

L<Test::Harness>␣would␣report␣tests␣3-14␣as␣having␣failed.␣For␣the
C<TAP::Parser>,␣these␣tests␣are␣not␣considered␣failed␣because␣they've
never␣run.␣They're␣reported␣as␣parse␣failures␣(tests␣out␣of␣sequence).

=back

=head1␣SUBCLASSING

If␣you␣find␣you␣need␣to␣provide␣custom␣functionality␣(as␣you␣would␣have␣using
L<Test::Harness::Straps>),␣you're␣in␣luck:␣C<TAP::Parser>␣and␣friends␣are
designed␣to␣be␣easily␣subclassed.

Before␣you␣start,␣it's␣important␣to␣know␣a␣few␣things:

=over␣2

=item␣1

All␣C<TAP::*>␣objects␣inherit␣from␣L<TAP::Object>.

=item␣2

Most␣C<TAP::*>␣classes␣have␣a␣I<SUBCLASSING>␣section␣to␣guide␣you.

=item␣3

Note␣that␣C<TAP::Parser>␣is␣designed␣to␣be␣the␣central␣'maker'␣-␣ie:␣it␣is
responsible␣for␣creating␣new␣objects␣in␣the␣C<TAP::Parser::*>␣namespace.

This␣makes␣it␣possible␣for␣you␣to␣have␣a␣single␣point␣of␣configuring␣what
subclasses␣should␣be␣used,␣which␣in␣turn␣means␣that␣in␣many␣cases␣you'll␣find
you␣only␣need␣to␣sub-class␣one␣of␣the␣parser's␣components.

=item␣4

By␣subclassing,␣you␣may␣end␣up␣overriding␣undocumented␣methods.␣␣That's␣not
a␣bad␣thing␣per␣se,␣but␣be␣forewarned␣that␣undocumented␣methods␣may␣change
without␣warning␣from␣one␣release␣to␣the␣next␣-␣we␣cannot␣guarantee␣backwards
compatability.␣␣If␣any␣I<documented>␣method␣needs␣changing,␣it␣will␣be
deprecated␣first,␣and␣changed␣in␣a␣later␣release.

=back

=head2␣Parser␣Components

=head3␣Sources

A␣TAP␣parser␣consumes␣input␣from␣a␣I<source>.␣␣There␣are␣currently␣two␣types
of␣sources:␣L<TAP::Parser::Source>␣for␣general␣non-perl␣commands,␣and
L<TAP::Parser::Source::Perl>.␣␣You␣can␣subclass␣both␣of␣them.␣␣You'll␣need␣to
customize␣your␣parser␣by␣setting␣the␣C<source_class>␣&␣C<perl_source_class>
parameters.␣␣See␣L</new>␣for␣more␣details.

If␣you␣need␣to␣customize␣the␣objects␣on␣creation,␣subclass␣L<TAP::Parser>␣and
override␣L</make_source>␣or␣L</make_perl_source>.

=head3␣Iterators

A␣TAP␣parser␣uses␣I<iterators>␣to␣loop␣through␣the␣I<stream>␣provided␣by␣the
parser's␣I<source>.␣␣There␣are␣quite␣a␣few␣types␣of␣Iterators␣available.
Choosing␣which␣class␣to␣use␣is␣the␣responsibility␣of␣the␣I<iterator␣factory>.

To␣create␣your␣own␣iterators␣you'll␣have␣to␣subclass
L<TAP::Parser::IteratorFactory>␣and␣L<TAP::Parser::Iterator>.␣␣Then␣you'll
need␣to␣customize␣the␣class␣used␣by␣your␣parser␣by␣setting␣the
C<iterator_factory_class>␣parameter.␣␣See␣L</new>␣for␣more␣details.

If␣you␣need␣to␣customize␣the␣objects␣on␣creation,␣subclass␣L<TAP::Parser>␣and
override␣L</make_iterator>.

=head3␣Results

A␣TAP␣parser␣creates␣L<TAP::Parser::Result>s␣as␣it␣iterates␣through␣the
input␣I<stream>.␣␣There␣are␣quite␣a␣few␣result␣types␣available;␣choosing
which␣class␣to␣use␣is␣the␣responsibility␣of␣the␣I<result␣factory>.

To␣create␣your␣own␣result␣types␣you␣have␣two␣options:

=over␣2

=item␣option␣1

Subclass␣L<TAP::Parser::Result>␣and␣register␣your␣new␣result␣type/class␣with
the␣default␣L<TAP::Parser::ResultFactory>.

=item␣option␣2

Subclass␣L<TAP::Parser::ResultFactory>␣itself␣and␣implement␣your␣own
L<TAP::Parser::Result>␣creation␣logic.␣␣Then␣you'll␣need␣to␣customize␣the
class␣used␣by␣your␣parser␣by␣setting␣the␣C<result_factory_class>␣parameter.
See␣L</new>␣for␣more␣details.

=back

If␣you␣need␣to␣customize␣the␣objects␣on␣creation,␣subclass␣L<TAP::Parser>␣and
override␣L</make_result>.

=head3␣Grammar

L<TAP::Parser::Grammar>␣is␣the␣heart␣of␣the␣parser␣-␣it␣tokenizes␣the␣TAP
input␣I<stream>␣and␣produces␣results.␣␣If␣you␣need␣to␣customize␣its␣behaviour
you␣should␣probably␣familiarize␣yourself␣with␣the␣source␣first.␣␣Enough
lecturing.

Subclass␣L<TAP::Parser::Grammar>␣and␣customize␣your␣parser␣by␣setting␣the
C<grammar_class>␣parameter.␣␣See␣L</new>␣for␣more␣details.

If␣you␣need␣to␣customize␣the␣objects␣on␣creation,␣subclass␣L<TAP::Parser>␣and
override␣L</make_grammar>

=head1␣ACKNOWLEDGEMENTS

All␣of␣the␣following␣have␣helped.␣Bug␣reports,␣patches,␣(im)moral
support,␣or␣just␣words␣of␣encouragement␣have␣all␣been␣forthcoming.

=over␣4

=item␣*␣Michael␣Schwern

=item␣*␣Andy␣Lester

=item␣*␣chromatic

=item␣*␣GEOFFR

=item␣*␣Shlomi␣Fish

=item␣*␣Torsten␣Schoenfeld

=item␣*␣Jerry␣Gay

=item␣*␣Aristotle

=item␣*␣Adam␣Kennedy

=item␣*␣Yves␣Orton

=item␣*␣Adrian␣Howard

=item␣*␣Sean␣&␣Lil

=item␣*␣Andreas␣J.␣Koenig

=item␣*␣Florian␣Ragwitz

=item␣*␣Corion

=item␣*␣Mark␣Stosberg

=item␣*␣Matt␣Kraai

=item␣*␣David␣Wheeler

=item␣*␣Alex␣Vandiver

=back

=head1␣AUTHORS

Curtis␣"Ovid"␣Poe␣<ovid@cpan.org>

Andy␣Armstong␣<andy@hexten.net>

Eric␣Wilhelm␣@␣<ewilhelm␣at␣cpan␣dot␣org>

Michael␣Peters␣<mpeters␣at␣plusthree␣dot␣com>

Leif␣Eriksen␣<leif␣dot␣eriksen␣at␣bigpond␣dot␣com>

Steve␣Purkis␣<spurkis@cpan.org>

Nicholas␣Clark␣<nick@ccl4.org>

=head1␣BUGS

Please␣report␣any␣bugs␣or␣feature␣requests␣to
C<bug-test-harness@rt.cpan.org>,␣or␣through␣the␣web␣interface␣at
L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness>.
We␣will␣be␣notified,␣and␣then␣you'll␣automatically␣be␣notified␣of
progress␣on␣your␣bug␣as␣we␣make␣changes.

Obviously,␣bugs␣which␣include␣patches␣are␣best.␣If␣you␣prefer,␣you␣can
patch␣against␣bleed␣by␣via␣anonymous␣checkout␣of␣the␣latest␣version:

␣svn␣checkout␣http://svn.hexten.net/tapx

=head1␣COPYRIGHT␣&␣LICENSE

Copyright␣2006-2008␣Curtis␣"Ovid"␣Poe,␣all␣rights␣reserved.

This␣program␣is␣free␣software;␣you␣can␣redistribute␣it␣and/or␣modify␣it
under␣the␣same␣terms␣as␣Perl␣itself.

=cut
----------
Range: (3544453,3551501) (7048)
=head1␣NAME

IO::Zlib␣-␣IO::␣style␣interface␣to␣L<Compress::Zlib>

=head1␣SYNOPSIS

With␣any␣version␣of␣Perl␣5␣you␣can␣use␣the␣basic␣OO␣interface:

␣␣␣␣use␣IO::Zlib;

␣␣␣␣$fh␣=␣new␣IO::Zlib;
␣␣␣␣if␣($fh->open("file.gz",␣"rb"))␣{
␣␣␣␣␣␣␣␣print␣<$fh>;
␣␣␣␣␣␣␣␣$fh->close;
␣␣␣␣}

␣␣␣␣$fh␣=␣IO::Zlib->new("file.gz",␣"wb9");
␣␣␣␣if␣(defined␣$fh)␣{
␣␣␣␣␣␣␣␣print␣$fh␣"bar\n";
␣␣␣␣␣␣␣␣$fh->close;
␣␣␣␣}

␣␣␣␣$fh␣=␣IO::Zlib->new("file.gz",␣"rb");
␣␣␣␣if␣(defined␣$fh)␣{
␣␣␣␣␣␣␣␣print␣<$fh>;
␣␣␣␣␣␣␣␣undef␣$fh;␣␣␣␣␣␣␣#␣automatically␣closes␣the␣file
␣␣␣␣}

With␣Perl␣5.004␣you␣can␣also␣use␣the␣TIEHANDLE␣interface␣to␣access
compressed␣files␣just␣like␣ordinary␣files:

␣␣␣␣use␣IO::Zlib;

␣␣␣␣tie␣*FILE,␣'IO::Zlib',␣"file.gz",␣"wb";
␣␣␣␣print␣FILE␣"line␣1\nline2\n";

␣␣␣␣tie␣*FILE,␣'IO::Zlib',␣"file.gz",␣"rb";
␣␣␣␣while␣(<FILE>)␣{␣print␣"LINE:␣",␣$_␣};

=head1␣DESCRIPTION

C<IO::Zlib>␣provides␣an␣IO::␣style␣interface␣to␣L<Compress::Zlib>␣and
hence␣to␣gzip/zlib␣compressed␣files.␣It␣provides␣many␣of␣the␣same␣methods
as␣the␣L<IO::Handle>␣interface.

Starting␣from␣IO::Zlib␣version␣1.02,␣IO::Zlib␣can␣also␣use␣an
external␣F<gzip>␣command.␣␣The␣default␣behaviour␣is␣to␣try␣to␣use
an␣external␣F<gzip>␣if␣no␣C<Compress::Zlib>␣can␣be␣loaded,␣unless
explicitly␣disabled␣by

␣␣␣␣use␣IO::Zlib␣qw(:gzip_external␣0);

If␣explicitly␣enabled␣by

␣␣␣␣use␣IO::Zlib␣qw(:gzip_external␣1);

then␣the␣external␣F<gzip>␣is␣used␣B<instead>␣of␣C<Compress::Zlib>.

=head1␣CONSTRUCTOR

=over␣4

=item␣new␣(␣[ARGS]␣)

Creates␣an␣C<IO::Zlib>␣object.␣If␣it␣receives␣any␣parameters,␣they␣are
passed␣to␣the␣method␣C<open>;␣if␣the␣open␣fails,␣the␣object␣is␣destroyed.
Otherwise,␣it␣is␣returned␣to␣the␣caller.

=back

=head1␣OBJECT␣METHODS

=over␣4

=item␣open␣(␣FILENAME,␣MODE␣)

C<open>␣takes␣two␣arguments.␣The␣first␣is␣the␣name␣of␣the␣file␣to␣open
and␣the␣second␣is␣the␣open␣mode.␣The␣mode␣can␣be␣anything␣acceptable␣to
L<Compress::Zlib>␣and␣by␣extension␣anything␣acceptable␣to␣I<zlib>␣(that
basically␣means␣POSIX␣fopen()␣style␣mode␣strings␣plus␣an␣optional␣number
to␣indicate␣the␣compression␣level).

=item␣opened

Returns␣true␣if␣the␣object␣currently␣refers␣to␣a␣opened␣file.

=item␣close

Close␣the␣file␣associated␣with␣the␣object␣and␣disassociate
the␣file␣from␣the␣handle.
Done␣automatically␣on␣destroy.

=item␣getc

Return␣the␣next␣character␣from␣the␣file,␣or␣undef␣if␣none␣remain.

=item␣getline

Return␣the␣next␣line␣from␣the␣file,␣or␣undef␣on␣end␣of␣string.
Can␣safely␣be␣called␣in␣an␣array␣context.
Currently␣ignores␣$/␣($INPUT_RECORD_SEPARATOR␣or␣$RS␣when␣L<English>
is␣in␣use)␣and␣treats␣lines␣as␣delimited␣by␣"\n".

=item␣getlines

Get␣all␣remaining␣lines␣from␣the␣file.
It␣will␣croak()␣if␣accidentally␣called␣in␣a␣scalar␣context.

=item␣print␣(␣ARGS...␣)

Print␣ARGS␣to␣the␣␣file.

=item␣read␣(␣BUF,␣NBYTES,␣[OFFSET]␣)

Read␣some␣bytes␣from␣the␣file.
Returns␣the␣number␣of␣bytes␣actually␣read,␣0␣on␣end-of-file,␣undef␣on␣error.

=item␣eof

Returns␣true␣if␣the␣handle␣is␣currently␣positioned␣at␣end␣of␣file?

=item␣seek␣(␣OFFSET,␣WHENCE␣)

Seek␣to␣a␣given␣position␣in␣the␣stream.
Not␣yet␣supported.

=item␣tell

Return␣the␣current␣position␣in␣the␣stream,␣as␣a␣numeric␣offset.
Not␣yet␣supported.

=item␣setpos␣(␣POS␣)

Set␣the␣current␣position,␣using␣the␣opaque␣value␣returned␣by␣C<getpos()>.
Not␣yet␣supported.

=item␣getpos␣(␣POS␣)

Return␣the␣current␣position␣in␣the␣string,␣as␣an␣opaque␣object.
Not␣yet␣supported.

=back

=head1␣USING␣THE␣EXTERNAL␣GZIP

If␣the␣external␣F<gzip>␣is␣used,␣the␣following␣C<open>s␣are␣used:

␣␣␣␣open(FH,␣"gzip␣-dc␣$filename␣|")␣␣#␣for␣read␣opens
␣␣␣␣open(FH,␣"␣|␣gzip␣>␣$filename")␣␣␣#␣for␣write␣opens

You␣can␣modify␣the␣'commands'␣for␣example␣to␣hardwire
an␣absolute␣path␣by␣e.g.

␣␣␣␣use␣IO::Zlib␣':gzip_read_open'␣␣=>␣'/some/where/gunzip␣-c␣%s␣|';
␣␣␣␣use␣IO::Zlib␣':gzip_write_open'␣=>␣'|␣/some/where/gzip.exe␣>␣%s';

The␣C<%s>␣is␣expanded␣to␣be␣the␣filename␣(C<sprintf>␣is␣used,␣so␣be
careful␣to␣escape␣any␣other␣C<%>␣signs).␣␣The␣'commands'␣are␣checked
for␣sanity␣-␣they␣must␣contain␣the␣C<%s>,␣and␣the␣read␣open␣must␣end
with␣the␣pipe␣sign,␣and␣the␣write␣open␣must␣begin␣with␣the␣pipe␣sign.

=head1␣CLASS␣METHODS

=over␣4

=item␣has_Compress_Zlib

Returns␣true␣if␣C<Compress::Zlib>␣is␣available.␣␣Note␣that␣this␣does
not␣mean␣that␣C<Compress::Zlib>␣is␣being␣used:␣see␣L</gzip_external>
and␣L<gzip_used>.

=item␣gzip_external

Undef␣if␣an␣external␣F<gzip>␣B<can>␣be␣used␣if␣C<Compress::Zlib>␣is
not␣available␣(see␣L</has_Compress_Zlib>),␣true␣if␣an␣external␣F<gzip>
is␣explicitly␣used,␣false␣if␣an␣external␣F<gzip>␣must␣not␣be␣used.
See␣L</gzip_used>.

=item␣gzip_used

True␣if␣an␣external␣F<gzip>␣is␣being␣used,␣false␣if␣not.

=item␣gzip_read_open

Return␣the␣'command'␣being␣used␣for␣opening␣a␣file␣for␣reading␣using␣an
external␣F<gzip>.

=item␣gzip_write_open

Return␣the␣'command'␣being␣used␣for␣opening␣a␣file␣for␣writing␣using␣an
external␣F<gzip>.

=back

=head1␣DIAGNOSTICS

=over␣4

=item␣IO::Zlib::getlines:␣must␣be␣called␣in␣list␣context

If␣you␣want␣read␣lines,␣you␣must␣read␣in␣list␣context.

=item␣IO::Zlib::gzopen_external:␣mode␣'...'␣is␣illegal

Use␣only␣modes␣'rb'␣or␣'wb'␣or␣/wb[1-9]/.

=item␣IO::Zlib::import:␣'...'␣is␣illegal

The␣known␣import␣symbols␣are␣the␣C<:gzip_external>,␣C<:gzip_read_open>,
and␣C<:gzip_write_open>.␣␣Anything␣else␣is␣not␣recognized.

=item␣IO::Zlib::import:␣':gzip_external'␣requires␣an␣argument

The␣C<:gzip_external>␣requires␣one␣boolean␣argument.

=item␣IO::Zlib::import:␣'gzip_read_open'␣requires␣an␣argument

The␣C<:gzip_external>␣requires␣one␣string␣argument.

=item␣IO::Zlib::import:␣'gzip_read'␣'...'␣is␣illegal

The␣C<:gzip_read_open>␣argument␣must␣end␣with␣the␣pipe␣sign␣(|)
and␣have␣the␣C<%s>␣for␣the␣filename.␣␣See␣L</"USING␣THE␣EXTERNAL␣GZIP">.

=item␣IO::Zlib::import:␣'gzip_write_open'␣requires␣an␣argument

The␣C<:gzip_external>␣requires␣one␣string␣argument.

=item␣IO::Zlib::import:␣'gzip_write_open'␣'...'␣is␣illegal

The␣C<:gzip_write_open>␣argument␣must␣begin␣with␣the␣pipe␣sign␣(|)
and␣have␣the␣C<%s>␣for␣the␣filename.␣␣An␣output␣redirect␣(>)␣is␣also
often␣a␣good␣idea,␣depending␣on␣your␣operating␣system␣shell␣syntax.
See␣L</"USING␣THE␣EXTERNAL␣GZIP">.

=item␣IO::Zlib::import:␣no␣Compress::Zlib␣and␣no␣external␣gzip

Given␣that␣we␣failed␣to␣load␣C<Compress::Zlib>␣and␣that␣the␣use␣of
␣an␣external␣F<gzip>␣was␣disabled,␣IO::Zlib␣has␣not␣much␣chance␣of␣working.

=item␣IO::Zlib::open:␣needs␣a␣filename

No␣filename,␣no␣open.

=item␣IO::Zlib::READ:␣NBYTES␣must␣be␣specified

We␣must␣know␣how␣much␣to␣read.

=item␣IO::Zlib::WRITE:␣too␣long␣LENGTH

The␣LENGTH␣must␣be␣less␣than␣or␣equal␣to␣the␣buffer␣size.

=back

=head1␣SEE␣ALSO

L<perlfunc>,
L<perlop/"I/O␣Operators">,
L<IO::Handle>,
L<Compress::Zlib>

=head1␣HISTORY

Created␣by␣Tom␣Hughes␣E<lt>F<tom@compton.nu>E<gt>.

Support␣for␣external␣gzip␣added␣by␣Jarkko␣Hietaniemi␣E<lt>F<jhi@iki.fi>E<gt>.

=head1␣COPYRIGHT

Copyright␣(c)␣1998-2004␣Tom␣Hughes␣E<lt>F<tom@compton.nu>E<gt>.
All␣rights␣reserved.␣This␣program␣is␣free␣software;␣you␣can␣redistribute
it␣and/or␣modify␣it␣under␣the␣same␣terms␣as␣Perl␣itself.

=cut
----------
Range: (3849855,3937918) (88063)
<<'END_OF_AUTOLOAD';

%SUBS␣=␣(

'URL_ENCODED'=>␣<<'END_OF_FUNC',
sub␣URL_ENCODED␣{␣'application/x-www-form-urlencoded';␣}
END_OF_FUNC

'MULTIPART'␣=>␣<<'END_OF_FUNC',
sub␣MULTIPART␣{␣␣'multipart/form-data';␣}
END_OF_FUNC

'SERVER_PUSH'␣=>␣<<'END_OF_FUNC',
sub␣SERVER_PUSH␣{␣'multipart/x-mixed-replace;boundary="'␣.␣shift()␣.␣'"';␣}
END_OF_FUNC

'new_MultipartBuffer'␣=>␣<<'END_OF_FUNC',
#␣Create␣a␣new␣multipart␣buffer
sub␣new_MultipartBuffer␣{
␣␣␣␣my($self,$boundary,$length)␣=␣@_;
␣␣␣␣return␣MultipartBuffer->new($self,$boundary,$length);
}
END_OF_FUNC

'read_from_client'␣=>␣<<'END_OF_FUNC',
#␣Read␣data␣from␣a␣file␣handle
sub␣read_from_client␣{
␣␣␣␣my($self,␣$buff,␣$len,␣$offset)␣=␣@_;
␣␣␣␣local␣$^W=0;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣prevent␣a␣warning
␣␣␣␣return␣$MOD_PERL
␣␣␣␣␣␣␣␣?␣$self->r->read($$buff,␣$len,␣$offset)
␣␣␣␣␣␣␣␣:␣read(\*STDIN,␣$$buff,␣$len,␣$offset);
}
END_OF_FUNC

'read_from_stdin'␣=>␣<<'END_OF_FUNC',
#␣Read␣data␣from␣stdin␣until␣all␣is␣read
sub␣read_from_stdin␣{
␣␣␣␣my($self,␣$buff)␣=␣@_;
␣␣␣␣local␣$^W=0;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣prevent␣a␣warning

␣␣␣␣#
␣␣␣␣#␣TODO:␣loop␣over␣STDIN␣until␣all␣is␣read
␣␣␣␣#

␣␣␣␣my($eoffound)␣=␣0;
␣␣␣␣my($localbuf)␣=␣'';
␣␣␣␣my($tempbuf)␣=␣'';
␣␣␣␣my($bufsiz)␣=␣1024;
␣␣␣␣my($res);
␣␣␣␣while␣($eoffound␣==␣0)␣{
	if␣(␣$MOD_PERL␣)␣{
	␣␣␣␣$res␣=␣$self->r->read($tempbuf,␣$bufsiz,␣0)
	}
	else␣{
	␣␣␣␣$res␣=␣read(\*STDIN,␣$tempbuf,␣$bufsiz);
	}

	if␣(␣!defined($res)␣)␣{
	␣␣␣␣#␣TODO:␣how␣to␣do␣error␣reporting␣?
	␣␣␣␣$eoffound␣=␣1;
	␣␣␣␣last;
	}
	if␣(␣$res␣==␣0␣)␣{
	␣␣␣␣$eoffound␣=␣1;
	␣␣␣␣last;
	}
	$localbuf␣.=␣$tempbuf;
␣␣␣␣}

␣␣␣␣$$buff␣=␣$localbuf;

␣␣␣␣return␣$res;
}
END_OF_FUNC

'delete'␣=>␣<<'END_OF_FUNC',
####␣Method:␣delete
#␣Deletes␣the␣named␣parameter␣entirely.
####
sub␣delete␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my(@names)␣=␣rearrange([NAME],@p);
␣␣␣␣my␣@to_delete␣=␣ref($names[0])␣eq␣'ARRAY'␣?␣@$names[0]␣:␣@names;
␣␣␣␣my␣%to_delete;
␣␣␣␣for␣my␣$name␣(@to_delete)
␣␣␣␣{
␣␣␣␣␣␣␣␣CORE::delete␣$self->{param}{$name};
␣␣␣␣␣␣␣␣CORE::delete␣$self->{'.fieldnames'}->{$name};
␣␣␣␣␣␣␣␣$to_delete{$name}++;
␣␣␣␣}
␣␣␣␣@{$self->{'.parameters'}}=grep␣{␣!exists($to_delete{$_})␣}␣$self->param();
␣␣␣␣return;
}
END_OF_FUNC

####␣Method:␣import_names
#␣Import␣all␣parameters␣into␣the␣given␣namespace.
#␣Assumes␣namespace␣'Q'␣if␣not␣specified
####
'import_names'␣=>␣<<'END_OF_FUNC',
sub␣import_names␣{
␣␣␣␣my($self,$namespace,$delete)␣=␣self_or_default(@_);
␣␣␣␣$namespace␣=␣'Q'␣unless␣defined($namespace);
␣␣␣␣die␣"Can't␣import␣names␣into␣\"main\"\n"␣if␣\%{"${namespace}::"}␣==␣\%::;
␣␣␣␣if␣($delete␣||␣$MOD_PERL␣||␣exists␣$ENV{'FCGI_ROLE'})␣{
	#␣can␣anyone␣find␣an␣easier␣way␣to␣do␣this?
	for␣(keys␣%{"${namespace}::"})␣{
	␣␣␣␣local␣*symbol␣=␣"${namespace}::${_}";
	␣␣␣␣undef␣$symbol;
	␣␣␣␣undef␣@symbol;
	␣␣␣␣undef␣%symbol;
	}
␣␣␣␣}
␣␣␣␣my($param,@value,$var);
␣␣␣␣for␣$param␣($self->param)␣{
	#␣protect␣against␣silly␣names
	($var␣=␣$param)=~tr/a-zA-Z0-9_/_/c;
	$var␣=~␣s/^(?=\d)/_/;
	local␣*symbol␣=␣"${namespace}::$var";
	@value␣=␣$self->param($param);
	@symbol␣=␣@value;
	$symbol␣=␣$value[0];
␣␣␣␣}
}
END_OF_FUNC

####␣Method:␣keywords
#␣Keywords␣acts␣a␣bit␣differently.␣␣Calling␣it␣in␣a␣list␣context
#␣returns␣the␣list␣of␣keywords.␣␣
#␣Calling␣it␣in␣a␣scalar␣context␣gives␣you␣the␣size␣of␣the␣list.
####
'keywords'␣=>␣<<'END_OF_FUNC',
sub␣keywords␣{
␣␣␣␣my($self,@values)␣=␣self_or_default(@_);
␣␣␣␣#␣If␣values␣is␣provided,␣then␣we␣set␣it.
␣␣␣␣$self->{param}{'keywords'}=[@values]␣if␣@values;
␣␣␣␣my(@result)␣=␣defined($self->{param}{'keywords'})␣?␣@{$self->{param}{'keywords'}}␣:␣();
␣␣␣␣@result;
}
END_OF_FUNC

#␣These␣are␣some␣tie()␣interfaces␣for␣compatibility
#␣with␣Steve␣Brenner's␣cgi-lib.pl␣routines
'Vars'␣=>␣<<'END_OF_FUNC',
sub␣Vars␣{
␣␣␣␣my␣$q␣=␣shift;
␣␣␣␣my␣%in;
␣␣␣␣tie(%in,CGI,$q);
␣␣␣␣return␣%in␣if␣wantarray;
␣␣␣␣return␣\%in;
}
END_OF_FUNC

#␣These␣are␣some␣tie()␣interfaces␣for␣compatibility
#␣with␣Steve␣Brenner's␣cgi-lib.pl␣routines
'ReadParse'␣=>␣<<'END_OF_FUNC',
sub␣ReadParse␣{
␣␣␣␣local(*in);
␣␣␣␣if␣(@_)␣{
	*in␣=␣$_[0];
␣␣␣␣}␣else␣{
	my␣$pkg␣=␣caller();
	*in=*{"${pkg}::in"};
␣␣␣␣}
␣␣␣␣tie(%in,CGI);
␣␣␣␣return␣scalar(keys␣%in);
}
END_OF_FUNC

'PrintHeader'␣=>␣<<'END_OF_FUNC',
sub␣PrintHeader␣{
␣␣␣␣my($self)␣=␣self_or_default(@_);
␣␣␣␣return␣$self->header();
}
END_OF_FUNC

'HtmlTop'␣=>␣<<'END_OF_FUNC',
sub␣HtmlTop␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣return␣$self->start_html(@p);
}
END_OF_FUNC

'HtmlBot'␣=>␣<<'END_OF_FUNC',
sub␣HtmlBot␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣return␣$self->end_html(@p);
}
END_OF_FUNC

'SplitParam'␣=>␣<<'END_OF_FUNC',
sub␣SplitParam␣{
␣␣␣␣my␣($param)␣=␣@_;
␣␣␣␣my␣(@params)␣=␣split␣("\0",␣$param);
␣␣␣␣return␣(wantarray␣?␣@params␣:␣$params[0]);
}
END_OF_FUNC

'MethGet'␣=>␣<<'END_OF_FUNC',
sub␣MethGet␣{
␣␣␣␣return␣request_method()␣eq␣'GET';
}
END_OF_FUNC

'MethPost'␣=>␣<<'END_OF_FUNC',
sub␣MethPost␣{
␣␣␣␣return␣request_method()␣eq␣'POST';
}
END_OF_FUNC

'MethPut'␣=>␣<<'END_OF_FUNC',
sub␣MethPut␣{
␣␣␣␣return␣request_method()␣eq␣'PUT';
}
END_OF_FUNC

'TIEHASH'␣=>␣<<'END_OF_FUNC',
sub␣TIEHASH␣{
␣␣␣␣my␣$class␣=␣shift;
␣␣␣␣my␣$arg␣␣␣=␣$_[0];
␣␣␣␣if␣(ref($arg)␣&&␣UNIVERSAL::isa($arg,'CGI'))␣{
␣␣␣␣␣␣␣return␣$arg;
␣␣␣␣}
␣␣␣␣return␣$Q␣||=␣$class->new(@_);
}
END_OF_FUNC

'STORE'␣=>␣<<'END_OF_FUNC',
sub␣STORE␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$tag␣␣=␣shift;
␣␣␣␣my␣$vals␣=␣shift;
␣␣␣␣my␣@vals␣=␣index($vals,"\0")!=-1␣?␣split("\0",$vals)␣:␣$vals;
␣␣␣␣$self->param(-name=>$tag,-value=>\@vals);
}
END_OF_FUNC

'FETCH'␣=>␣<<'END_OF_FUNC',
sub␣FETCH␣{
␣␣␣␣return␣$_[0]␣if␣$_[1]␣eq␣'CGI';
␣␣␣␣return␣undef␣unless␣defined␣$_[0]->param($_[1]);
␣␣␣␣return␣join("\0",$_[0]->param($_[1]));
}
END_OF_FUNC

'FIRSTKEY'␣=>␣<<'END_OF_FUNC',
sub␣FIRSTKEY␣{
␣␣␣␣$_[0]->{'.iterator'}=0;
␣␣␣␣$_[0]->{'.parameters'}->[$_[0]->{'.iterator'}++];
}
END_OF_FUNC

'NEXTKEY'␣=>␣<<'END_OF_FUNC',
sub␣NEXTKEY␣{
␣␣␣␣$_[0]->{'.parameters'}->[$_[0]->{'.iterator'}++];
}
END_OF_FUNC

'EXISTS'␣=>␣<<'END_OF_FUNC',
sub␣EXISTS␣{
␣␣␣␣exists␣$_[0]->{param}{$_[1]};
}
END_OF_FUNC

'DELETE'␣=>␣<<'END_OF_FUNC',
sub␣DELETE␣{
␣␣␣␣$_[0]->delete($_[1]);
}
END_OF_FUNC

'CLEAR'␣=>␣<<'END_OF_FUNC',
sub␣CLEAR␣{
␣␣␣␣%{$_[0]}=();
}
####
END_OF_FUNC

####
#␣Append␣a␣new␣value␣to␣an␣existing␣query
####
'append'␣=>␣<<'EOF',
sub␣append␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my($name,$value)␣=␣rearrange([NAME,[VALUE,VALUES]],@p);
␣␣␣␣my(@values)␣=␣defined($value)␣?␣(ref($value)␣?␣@{$value}␣:␣$value)␣:␣();
␣␣␣␣if␣(@values)␣{
	$self->add_parameter($name);
	push(@{$self->{param}{$name}},@values);
␣␣␣␣}
␣␣␣␣return␣$self->param($name);
}
EOF

####␣Method:␣delete_all
#␣Delete␣all␣parameters
####
'delete_all'␣=>␣<<'EOF',
sub␣delete_all␣{
␣␣␣␣my($self)␣=␣self_or_default(@_);
␣␣␣␣my␣@param␣=␣$self->param();
␣␣␣␣$self->delete(@param);
}
EOF

'Delete'␣=>␣<<'EOF',
sub␣Delete␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣$self->delete(@p);
}
EOF

'Delete_all'␣=>␣<<'EOF',
sub␣Delete_all␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣$self->delete_all(@p);
}
EOF

####␣Method:␣autoescape
#␣If␣you␣want␣to␣turn␣off␣the␣autoescaping␣features,
#␣call␣this␣method␣with␣undef␣as␣the␣argument
'autoEscape'␣=>␣<<'END_OF_FUNC',
sub␣autoEscape␣{
␣␣␣␣my($self,$escape)␣=␣self_or_default(@_);
␣␣␣␣my␣$d␣=␣$self->{'escape'};
␣␣␣␣$self->{'escape'}␣=␣$escape;
␣␣␣␣$d;
}
END_OF_FUNC


####␣Method:␣version
#␣Return␣the␣current␣version
####
'version'␣=>␣<<'END_OF_FUNC',
sub␣version␣{
␣␣␣␣return␣$VERSION;
}
END_OF_FUNC

####␣Method:␣url_param
#␣Return␣a␣parameter␣in␣the␣QUERY_STRING,␣regardless␣of
#␣whether␣this␣was␣a␣POST␣or␣a␣GET
####
'url_param'␣=>␣<<'END_OF_FUNC',
sub␣url_param␣{
␣␣␣␣my␣($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my␣$name␣=␣shift(@p);
␣␣␣␣return␣undef␣unless␣exists($ENV{QUERY_STRING});
␣␣␣␣unless␣(exists($self->{'.url_param'}))␣{
	$self->{'.url_param'}={};␣#␣empty␣hash
	if␣($ENV{QUERY_STRING}␣=~␣/=/)␣{
	␣␣␣␣my(@pairs)␣=␣split(/[&;]/,$ENV{QUERY_STRING});
	␣␣␣␣my($param,$value);
	␣␣␣␣for␣(@pairs)␣{
		($param,$value)␣=␣split('=',$_,2);
		$param␣=␣unescape($param);
		$value␣=␣unescape($value);
		push(@{$self->{'.url_param'}->{$param}},$value);
	␣␣␣␣}
	}␣else␣{
␣␣␣␣␣␣␣␣my␣@keywords␣=␣$self->parse_keywordlist($ENV{QUERY_STRING});
	␣␣␣␣$self->{'.url_param'}{'keywords'}␣=␣\@keywords␣if␣@keywords;
	}
␣␣␣␣}
␣␣␣␣return␣keys␣%{$self->{'.url_param'}}␣unless␣defined($name);
␣␣␣␣return␣()␣unless␣$self->{'.url_param'}->{$name};
␣␣␣␣return␣wantarray␣?␣@{$self->{'.url_param'}->{$name}}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣$self->{'.url_param'}->{$name}->[0];
}
END_OF_FUNC

####␣Method:␣Dump
#␣Returns␣a␣string␣in␣which␣all␣the␣known␣parameter/value␣
#␣pairs␣are␣represented␣as␣nested␣lists,␣mainly␣for␣the␣purposes␣
#␣of␣debugging.
####
'Dump'␣=>␣<<'END_OF_FUNC',
sub␣Dump␣{
␣␣␣␣my($self)␣=␣self_or_default(@_);
␣␣␣␣my($param,$value,@result);
␣␣␣␣return␣'<ul></ul>'␣unless␣$self->param;
␣␣␣␣push(@result,"<ul>");
␣␣␣␣for␣$param␣($self->param)␣{
	my($name)=$self->_maybe_escapeHTML($param);
	push(@result,"<li><strong>$name</strong></li>");
	push(@result,"<ul>");
	for␣$value␣($self->param($param))␣{
	␣␣␣␣$value␣=␣$self->_maybe_escapeHTML($value);
␣␣␣␣␣␣␣␣␣␣␣␣$value␣=~␣s/\n/<br␣\/>\n/g;
	␣␣␣␣push(@result,"<li>$value</li>");
	}
	push(@result,"</ul>");
␣␣␣␣}
␣␣␣␣push(@result,"</ul>");
␣␣␣␣return␣join("\n",@result);
}
END_OF_FUNC

####␣Method␣as_string
#
#␣synonym␣for␣"dump"
####
'as_string'␣=>␣<<'END_OF_FUNC',
sub␣as_string␣{
␣␣␣␣&Dump(@_);
}
END_OF_FUNC

####␣Method:␣save
#␣Write␣values␣out␣to␣a␣filehandle␣in␣such␣a␣way␣that␣they␣can
#␣be␣reinitialized␣by␣the␣filehandle␣form␣of␣the␣new()␣method
####
'save'␣=>␣<<'END_OF_FUNC',
sub␣save␣{
␣␣␣␣my($self,$filehandle)␣=␣self_or_default(@_);
␣␣␣␣$filehandle␣=␣to_filehandle($filehandle);
␣␣␣␣my($param);
␣␣␣␣local($,)␣=␣'';␣␣#␣set␣print␣field␣separator␣back␣to␣a␣sane␣value
␣␣␣␣local($\)␣=␣'';␣␣#␣set␣output␣line␣separator␣to␣a␣sane␣value
␣␣␣␣for␣$param␣($self->param)␣{
	my($escaped_param)␣=␣escape($param);
	my($value);
	for␣$value␣($self->param($param))␣{
	␣␣␣␣print␣$filehandle␣"$escaped_param=",escape("$value"),"\n"
	␣␣␣␣␣␣␣␣if␣length($escaped_param)␣or␣length($value);
	}
␣␣␣␣}
␣␣␣␣for␣(keys␣%{$self->{'.fieldnames'}})␣{
␣␣␣␣␣␣␣␣␣␣print␣$filehandle␣".cgifields=",escape("$_"),"\n";
␣␣␣␣}
␣␣␣␣print␣$filehandle␣"=\n";␣␣␣␣#␣end␣of␣record
}
END_OF_FUNC


####␣Method:␣save_parameters
#␣An␣alias␣for␣save()␣that␣is␣a␣better␣name␣for␣exportation.
#␣Only␣intended␣to␣be␣used␣with␣the␣function␣(non-OO)␣interface.
####
'save_parameters'␣=>␣<<'END_OF_FUNC',
sub␣save_parameters␣{
␣␣␣␣my␣$fh␣=␣shift;
␣␣␣␣return␣save(to_filehandle($fh));
}
END_OF_FUNC

####␣Method:␣restore_parameters
#␣A␣way␣to␣restore␣CGI␣parameters␣from␣an␣initializer.
#␣Only␣intended␣to␣be␣used␣with␣the␣function␣(non-OO)␣interface.
####
'restore_parameters'␣=>␣<<'END_OF_FUNC',
sub␣restore_parameters␣{
␣␣␣␣$Q␣=␣$CGI::DefaultClass->new(@_);
}
END_OF_FUNC

####␣Method:␣multipart_init
#␣Return␣a␣Content-Type:␣style␣header␣for␣server-push
#␣This␣has␣to␣be␣NPH␣on␣most␣web␣servers,␣and␣it␣is␣advisable␣to␣set␣$|␣=␣1
#
#␣Many␣thanks␣to␣Ed␣Jordan␣<ed@fidalgo.net>␣for␣this
#␣contribution,␣updated␣by␣Andrew␣Benham␣(adsb@bigfoot.com)
####
'multipart_init'␣=>␣<<'END_OF_FUNC',
sub␣multipart_init␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my($boundary,@other)␣=␣rearrange_header([BOUNDARY],@p);
␣␣␣␣if␣(!$boundary)␣{
␣␣␣␣␣␣␣␣$boundary␣=␣'-------␣=_';
␣␣␣␣␣␣␣␣my␣@chrs␣=␣('0'..'9',␣'A'..'Z',␣'a'..'z');
␣␣␣␣␣␣␣␣for␣(1..17)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$boundary␣.=␣$chrs[rand(scalar␣@chrs)];
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣$self->{'separator'}␣=␣"$CRLF--$boundary$CRLF";
␣␣␣␣$self->{'final_separator'}␣=␣"$CRLF--$boundary--$CRLF";
␣␣␣␣$type␣=␣SERVER_PUSH($boundary);
␣␣␣␣return␣$self->header(
	-nph␣=>␣0,
	-type␣=>␣$type,
	(map␣{␣split␣"=",␣$_,␣2␣}␣@other),
␣␣␣␣)␣.␣"WARNING:␣YOUR␣BROWSER␣DOESN'T␣SUPPORT␣THIS␣SERVER-PUSH␣TECHNOLOGY."␣.␣$self->multipart_end;
}
END_OF_FUNC


####␣Method:␣multipart_start
#␣Return␣a␣Content-Type:␣style␣header␣for␣server-push,␣start␣of␣section
#
#␣Many␣thanks␣to␣Ed␣Jordan␣<ed@fidalgo.net>␣for␣this
#␣contribution,␣updated␣by␣Andrew␣Benham␣(adsb@bigfoot.com)
####
'multipart_start'␣=>␣<<'END_OF_FUNC',
sub␣multipart_start␣{
␣␣␣␣my(@header);
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my($type,@other)␣=␣rearrange([TYPE],@p);
␣␣␣␣$type␣=␣$type␣||␣'text/html';
␣␣␣␣push(@header,"Content-Type:␣$type");

␣␣␣␣#␣rearrange()␣was␣designed␣for␣the␣HTML␣portion,␣so␣we
␣␣␣␣#␣need␣to␣fix␣it␣up␣a␣little.
␣␣␣␣for␣(@other)␣{
␣␣␣␣␣␣␣␣#␣Don't␣use␣\s␣because␣of␣perl␣bug␣21951
␣␣␣␣␣␣␣␣next␣unless␣my($header,$value)␣=␣/([^␣\r\n\t=]+)=\"?(.+?)\"?$/;
	($_␣=␣$header)␣=~␣s/^(\w)(.*)/$1␣.␣lc␣($2)␣.␣':␣'.$self->unescapeHTML($value)/e;
␣␣␣␣}
␣␣␣␣push(@header,@other);
␣␣␣␣my␣$header␣=␣join($CRLF,@header)."${CRLF}${CRLF}";
␣␣␣␣return␣$header;
}
END_OF_FUNC


####␣Method:␣multipart_end
#␣Return␣a␣MIME␣boundary␣separator␣for␣server-push,␣end␣of␣section
#
#␣Many␣thanks␣to␣Ed␣Jordan␣<ed@fidalgo.net>␣for␣this
#␣contribution
####
'multipart_end'␣=>␣<<'END_OF_FUNC',
sub␣multipart_end␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣return␣$self->{'separator'};
}
END_OF_FUNC


####␣Method:␣multipart_final
#␣Return␣a␣MIME␣boundary␣separator␣for␣server-push,␣end␣of␣all␣sections
#
#␣Contributed␣by␣Andrew␣Benham␣(adsb@bigfoot.com)
####
'multipart_final'␣=>␣<<'END_OF_FUNC',
sub␣multipart_final␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣return␣$self->{'final_separator'}␣.␣"WARNING:␣YOUR␣BROWSER␣DOESN'T␣SUPPORT␣THIS␣SERVER-PUSH␣TECHNOLOGY."␣.␣$CRLF;
}
END_OF_FUNC


####␣Method:␣header
#␣Return␣a␣Content-Type:␣style␣header
#
####
'header'␣=>␣<<'END_OF_FUNC',
sub␣header␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my(@header);

␣␣␣␣return␣""␣if␣$self->{'.header_printed'}++␣and␣$HEADERS_ONCE;

␣␣␣␣my($type,$status,$cookie,$target,$expires,$nph,$charset,$attachment,$p3p,@other)␣=␣
	rearrange([['TYPE','CONTENT_TYPE','CONTENT-TYPE'],
			␣␣␣␣'STATUS',['COOKIE','COOKIES'],'TARGET',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'EXPIRES','NPH','CHARSET',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'ATTACHMENT','P3P'],@p);

␣␣␣␣#␣CR␣escaping␣for␣values,␣per␣RFC␣822
␣␣␣␣for␣my␣$header␣($type,$status,$cookie,$target,$expires,$nph,$charset,$attachment,$p3p,@other)␣{
␣␣␣␣␣␣␣␣if␣(defined␣$header)␣{
␣␣␣␣␣␣␣␣␣␣␣␣#␣From␣RFC␣822:
␣␣␣␣␣␣␣␣␣␣␣␣#␣Unfolding␣␣is␣␣accomplished␣␣by␣regarding␣␣␣CRLF␣␣␣immediately
␣␣␣␣␣␣␣␣␣␣␣␣#␣followed␣␣by␣␣a␣␣LWSP-char␣␣as␣equivalent␣to␣the␣LWSP-char.
␣␣␣␣␣␣␣␣␣␣␣␣$header␣=~␣s/$CRLF(\s)/$1/g;

␣␣␣␣␣␣␣␣␣␣␣␣#␣All␣other␣uses␣of␣newlines␣are␣invalid␣input.␣
␣␣␣␣␣␣␣␣␣␣␣␣if␣($header␣=~␣m/$CRLF|\015|\012/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣shorten␣very␣long␣values␣in␣the␣diagnostic
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$header␣=␣substr($header,0,72).'...'␣if␣(length␣$header␣>␣72);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣die␣"Invalid␣header␣value␣contains␣a␣newline␣not␣followed␣by␣whitespace:␣$header";
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣
␣␣␣}

␣␣␣␣$nph␣␣␣␣␣||=␣$NPH;

␣␣␣␣$type␣||=␣'text/html'␣unless␣defined($type);

␣␣␣␣if␣(defined␣$charset)␣{
␣␣␣␣␣␣$self->charset($charset);
␣␣␣␣}␣else␣{
␣␣␣␣␣␣$charset␣=␣$self->charset␣if␣$type␣=~␣/^text\//;
␣␣␣␣}
␣␣␣$charset␣||=␣'';

␣␣␣␣#␣rearrange()␣was␣designed␣for␣the␣HTML␣portion,␣so␣we
␣␣␣␣#␣need␣to␣fix␣it␣up␣a␣little.
␣␣␣␣for␣(@other)␣{
␣␣␣␣␣␣␣␣#␣Don't␣use␣\s␣because␣of␣perl␣bug␣21951
␣␣␣␣␣␣␣␣next␣unless␣my($header,$value)␣=␣/([^␣\r\n\t=]+)=\"?(.+?)\"?$/s;
␣␣␣␣␣␣␣␣($_␣=␣$header)␣=~␣s/^(\w)(.*)/"\u$1\L$2"␣.␣':␣'.$self->unescapeHTML($value)/e;
␣␣␣␣}

␣␣␣␣$type␣.=␣";␣charset=$charset"
␣␣␣␣␣␣if␣␣␣␣␣$type␣ne␣''
␣␣␣␣␣␣␣␣␣and␣$type␣!~␣/\bcharset\b/
␣␣␣␣␣␣␣␣␣and␣defined␣$charset
␣␣␣␣␣␣␣␣␣and␣$charset␣ne␣'';

␣␣␣␣#␣Maybe␣future␣compatibility.␣␣Maybe␣not.
␣␣␣␣my␣$protocol␣=␣$ENV{SERVER_PROTOCOL}␣||␣'HTTP/1.0';
␣␣␣␣push(@header,$protocol␣.␣'␣'␣.␣($status␣||␣'200␣OK'))␣if␣$nph;
␣␣␣␣push(@header,"Server:␣"␣.␣&server_software())␣if␣$nph;

␣␣␣␣push(@header,"Status:␣$status")␣if␣$status;
␣␣␣␣push(@header,"Window-Target:␣$target")␣if␣$target;
␣␣␣␣if␣($p3p)␣{
␣␣␣␣␣␣␣$p3p␣=␣join␣'␣',@$p3p␣if␣ref($p3p)␣eq␣'ARRAY';
␣␣␣␣␣␣␣push(@header,qq(P3P:␣policyref="/w3c/p3p.xml",␣CP="$p3p"));
␣␣␣␣}
␣␣␣␣#␣push␣all␣the␣cookies␣--␣there␣may␣be␣several
␣␣␣␣if␣($cookie)␣{
	my(@cookie)␣=␣ref($cookie)␣&&␣ref($cookie)␣eq␣'ARRAY'␣?␣@{$cookie}␣:␣$cookie;
	for␣(@cookie)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$cs␣=␣UNIVERSAL::isa($_,'CGI::Cookie')␣?␣$_->as_string␣:␣$_;
	␣␣␣␣push(@header,"Set-Cookie:␣$cs")␣if␣$cs␣ne␣'';
	}
␣␣␣␣}
␣␣␣␣#␣if␣the␣user␣indicates␣an␣expiration␣time,␣then␣we␣need
␣␣␣␣#␣both␣an␣Expires␣and␣a␣Date␣header␣(so␣that␣the␣browser␣is
␣␣␣␣#␣uses␣OUR␣clock)
␣␣␣␣push(@header,"Expires:␣"␣.␣expires($expires,'http'))
	if␣$expires;
␣␣␣␣push(@header,"Date:␣"␣.␣expires(0,'http'))␣if␣$expires␣||␣$cookie␣||␣$nph;
␣␣␣␣push(@header,"Pragma:␣no-cache")␣if␣$self->cache();
␣␣␣␣push(@header,"Content-Disposition:␣attachment;␣filename=\"$attachment\"")␣if␣$attachment;
␣␣␣␣push(@header,map␣{ucfirst␣$_}␣@other);
␣␣␣␣push(@header,"Content-Type:␣$type")␣if␣$type␣ne␣'';
␣␣␣␣my␣$header␣=␣join($CRLF,@header)."${CRLF}${CRLF}";
␣␣␣␣if␣(($MOD_PERL␣>=␣1)␣&&␣!$nph)␣{
␣␣␣␣␣␣␣␣$self->r->send_cgi_header($header);
␣␣␣␣␣␣␣␣return␣'';
␣␣␣␣}
␣␣␣␣return␣$header;
}
END_OF_FUNC


####␣Method:␣cache
#␣Control␣whether␣header()␣will␣produce␣the␣no-cache
#␣Pragma␣directive.
####
'cache'␣=>␣<<'END_OF_FUNC',
sub␣cache␣{
␣␣␣␣my($self,$new_value)␣=␣self_or_default(@_);
␣␣␣␣$new_value␣=␣''␣unless␣$new_value;
␣␣␣␣if␣($new_value␣ne␣'')␣{
	$self->{'cache'}␣=␣$new_value;
␣␣␣␣}
␣␣␣␣return␣$self->{'cache'};
}
END_OF_FUNC


####␣Method:␣redirect
#␣Return␣a␣Location:␣style␣header
#
####
'redirect'␣=>␣<<'END_OF_FUNC',
sub␣redirect␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my($url,$target,$status,$cookie,$nph,@other)␣=␣
␣␣␣␣␣␣␣␣␣rearrange([[LOCATION,URI,URL],TARGET,STATUS,['COOKIE','COOKIES'],NPH],@p);
␣␣␣␣$status␣=␣'302␣Found'␣unless␣defined␣$status;
␣␣␣␣$url␣||=␣$self->self_url;
␣␣␣␣my(@o);
␣␣␣␣for␣(@other)␣{␣tr/\"//d;␣push(@o,split("=",$_,2));␣}
␣␣␣␣unshift(@o,
	␣'-Status'␣␣=>␣$status,
	␣'-Location'=>␣$url,
	␣'-nph'␣␣␣␣␣=>␣$nph);
␣␣␣␣unshift(@o,'-Target'=>$target)␣if␣$target;
␣␣␣␣unshift(@o,'-Type'=>'');
␣␣␣␣my␣@unescaped;
␣␣␣␣unshift(@unescaped,'-Cookie'=>$cookie)␣if␣$cookie;
␣␣␣␣return␣$self->header((map␣{$self->unescapeHTML($_)}␣@o),@unescaped);
}
END_OF_FUNC


####␣Method:␣start_html
#␣Canned␣HTML␣header
#
#␣Parameters:
#␣$title␣->␣(optional)␣The␣title␣for␣this␣HTML␣document␣(-title)
#␣$author␣->␣(optional)␣e-mail␣address␣of␣the␣author␣(-author)
#␣$base␣->␣(optional)␣if␣set␣to␣true,␣will␣enter␣the␣BASE␣address␣of␣this␣document
#␣␣␣␣␣␣␣␣␣␣for␣resolving␣relative␣references␣(-base)␣
#␣$xbase␣->␣(optional)␣alternative␣base␣at␣some␣remote␣location␣(-xbase)
#␣$target␣->␣(optional)␣target␣window␣to␣load␣all␣links␣into␣(-target)
#␣$script␣->␣(option)␣Javascript␣code␣(-script)
#␣$no_script␣->␣(option)␣Javascript␣<noscript>␣tag␣(-noscript)
#␣$meta␣->␣(optional)␣Meta␣information␣tags
#␣$head␣->␣(optional)␣any␣other␣elements␣you'd␣like␣to␣incorporate␣into␣the␣<head>␣tag
#␣␣␣␣␣␣␣␣␣␣␣(a␣scalar␣or␣array␣ref)
#␣$style␣->␣(optional)␣reference␣to␣an␣external␣style␣sheet
#␣@other␣->␣(optional)␣any␣other␣named␣parameters␣you'd␣like␣to␣incorporate␣into
#␣␣␣␣␣␣␣␣␣␣␣the␣<body>␣tag.
####
'start_html'␣=>␣<<'END_OF_FUNC',
sub␣start_html␣{
␣␣␣␣my($self,@p)␣=␣&self_or_default(@_);
␣␣␣␣my($title,$author,$base,$xbase,$script,$noscript,
␣␣␣␣␣␣␣␣$target,$meta,$head,$style,$dtd,$lang,$encoding,$declare_xml,@other)␣=␣
	rearrange([TITLE,AUTHOR,BASE,XBASE,SCRIPT,NOSCRIPT,TARGET,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣META,HEAD,STYLE,DTD,LANG,ENCODING,DECLARE_XML],@p);

␣␣␣␣$self->element_id(0);
␣␣␣␣$self->element_tab(0);

␣␣␣␣$encoding␣=␣lc($self->charset)␣unless␣defined␣$encoding;

␣␣␣␣#␣Need␣to␣sort␣out␣the␣DTD␣before␣it's␣okay␣to␣call␣escapeHTML().
␣␣␣␣my(@result,$xml_dtd);
␣␣␣␣if␣($dtd)␣{
␣␣␣␣␣␣␣␣if␣(defined(ref($dtd))␣and␣(ref($dtd)␣eq␣'ARRAY'))␣{
␣␣␣␣␣␣␣␣␣␣␣␣$dtd␣=␣$DEFAULT_DTD␣unless␣$dtd->[0]␣=~␣m|^-//|;
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$dtd␣=␣$DEFAULT_DTD␣unless␣$dtd␣=~␣m|^-//|;
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣$dtd␣=␣$XHTML␣?␣XHTML_DTD␣:␣$DEFAULT_DTD;
␣␣␣␣}

␣␣␣␣$xml_dtd++␣if␣ref($dtd)␣eq␣'ARRAY'␣&&␣$dtd->[0]␣=~␣/\bXHTML\b/i;
␣␣␣␣$xml_dtd++␣if␣ref($dtd)␣eq␣''␣&&␣$dtd␣=~␣/\bXHTML\b/i;
␣␣␣␣push␣@result,qq(<?xml␣version="1.0"␣encoding="$encoding"?>)␣if␣$xml_dtd␣&&␣$declare_xml;

␣␣␣␣if␣(ref($dtd)␣&&␣ref($dtd)␣eq␣'ARRAY')␣{
␣␣␣␣␣␣␣␣push(@result,qq(<!DOCTYPE␣html\n\tPUBLIC␣"$dtd->[0]"\n\t␣"$dtd->[1]">));
	$DTD_PUBLIC_IDENTIFIER␣=␣$dtd->[0];
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣push(@result,qq(<!DOCTYPE␣html\n\tPUBLIC␣"$dtd">));
	$DTD_PUBLIC_IDENTIFIER␣=␣$dtd;
␣␣␣␣}

␣␣␣␣#␣Now␣that␣we␣know␣whether␣we're␣using␣the␣HTML␣3.2␣DTD␣or␣not,␣it's␣okay␣to
␣␣␣␣#␣call␣escapeHTML().␣␣Strangely␣enough,␣the␣title␣needs␣to␣be␣escaped␣as
␣␣␣␣#␣HTML␣while␣the␣author␣needs␣to␣be␣escaped␣as␣a␣URL.
␣␣␣␣$title␣=␣$self->_maybe_escapeHTML($title␣||␣'Untitled␣Document');
␣␣␣␣$author␣=␣$self->escape($author);

␣␣␣␣if␣($DTD_PUBLIC_IDENTIFIER␣=~␣/[^X]HTML␣(2\.0|3\.2|4\.01?)/i)␣{
	$lang␣=␣""␣unless␣defined␣$lang;
	$XHTML␣=␣0;
␣␣␣␣}
␣␣␣␣else␣{
	$lang␣=␣'en-US'␣unless␣defined␣$lang;
␣␣␣␣}

␣␣␣␣my␣$lang_bits␣=␣$lang␣ne␣''␣?␣qq(␣lang="$lang"␣xml:lang="$lang")␣:␣'';
␣␣␣␣my␣$meta_bits␣=␣qq(<meta␣http-equiv="Content-Type"␣content="text/html;␣charset=$encoding"␣/>)␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣$XHTML␣&&␣$encoding␣&&␣!$declare_xml;

␣␣␣␣push(@result,$XHTML␣?␣qq(<html␣xmlns="http://www.w3.org/1999/xhtml"$lang_bits>\n<head>\n<title>$title</title>)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣($lang␣?␣qq(<html␣lang="$lang">)␣:␣"<html>")
	␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣.␣"<head><title>$title</title>");
	if␣(defined␣$author)␣{
␣␣␣␣push(@result,$XHTML␣?␣"<link␣rev=\"made\"␣href=\"mailto:$author\"␣/>"
			:␣"<link␣rev=\"made\"␣href=\"mailto:$author\">");
	}

␣␣␣␣if␣($base␣||␣$xbase␣||␣$target)␣{
	my␣$href␣=␣$xbase␣||␣$self->url('-path'=>1);
	my␣$t␣=␣$target␣?␣qq/␣target="$target"/␣:␣'';
	push(@result,$XHTML␣?␣qq(<base␣href="$href"$t␣/>)␣:␣qq(<base␣href="$href"$t>));
␣␣␣␣}

␣␣␣␣if␣($meta␣&&␣ref($meta)␣&&␣(ref($meta)␣eq␣'HASH'))␣{
	for␣(keys␣%$meta)␣{␣push(@result,$XHTML␣?␣qq(<meta␣name="$_"␣content="$meta->{$_}"␣/>)␣
			:␣qq(<meta␣name="$_"␣content="$meta->{$_}">));␣}
␣␣␣␣}

␣␣␣␣my␣$meta_bits_set␣=␣0;
␣␣␣␣if(␣$head␣)␣{
␣␣␣␣␣␣␣␣if(␣ref␣$head␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣push␣@result,␣@$head;
␣␣␣␣␣␣␣␣␣␣␣␣$meta_bits_set␣=␣1␣if␣grep␣{␣/http-equiv=["']Content-Type/i␣}@$head;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣push␣@result,␣$head;
␣␣␣␣␣␣␣␣␣␣␣␣$meta_bits_set␣=␣1␣if␣$head␣=~␣/http-equiv=["']Content-Type/i;
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣#␣handle␣the␣infrequently-used␣-style␣and␣-script␣parameters
␣␣␣␣push(@result,$self->_style($style))␣␣␣if␣defined␣$style;
␣␣␣␣push(@result,$self->_script($script))␣if␣defined␣$script;
␣␣␣␣push(@result,$meta_bits)␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣defined␣$meta_bits␣and␣!$meta_bits_set;

␣␣␣␣#␣handle␣-noscript␣parameter
␣␣␣␣push(@result,<<END)␣if␣$noscript;
<noscript>
$noscript
</noscript>
END
␣␣␣␣;
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';
␣␣␣␣push(@result,"</head>\n<body$other>\n");
␣␣␣␣return␣join("\n",@result);
}
END_OF_FUNC

###␣Method:␣_style
#␣internal␣method␣for␣generating␣a␣CSS␣style␣section
####
'_style'␣=>␣<<'END_OF_FUNC',
sub␣_style␣{
␣␣␣␣my␣($self,$style)␣=␣@_;
␣␣␣␣my␣(@result);

␣␣␣␣my␣$type␣=␣'text/css';
␣␣␣␣my␣$rel␣␣=␣'stylesheet';


␣␣␣␣my␣$cdata_start␣=␣$XHTML␣?␣"\n<!--/*␣<![CDATA[␣*/"␣:␣"\n<!--␣";
␣␣␣␣my␣$cdata_end␣␣␣=␣$XHTML␣?␣"\n/*␣]]>␣*/-->\n"␣:␣"␣-->\n";

␣␣␣␣my␣@s␣=␣ref($style)␣eq␣'ARRAY'␣?␣@$style␣:␣$style;
␣␣␣␣my␣$other␣=␣'';

␣␣␣␣for␣my␣$s␣(@s)␣{
␣␣␣␣␣␣if␣(ref($s))␣{
␣␣␣␣␣␣␣my($src,$code,$verbatim,$stype,$alternate,$foo,@other)␣=
␣␣␣␣␣␣␣␣␣␣␣rearrange([qw(SRC␣CODE␣VERBATIM␣TYPE␣ALTERNATE␣FOO)],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣('-foo'=>'bar',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣ref($s)␣eq␣'ARRAY'␣?␣@$s␣:␣%$s));
␣␣␣␣␣␣␣my␣$type␣=␣defined␣$stype␣?␣$stype␣:␣'text/css';
␣␣␣␣␣␣␣my␣$rel␣␣=␣$alternate␣?␣'alternate␣stylesheet'␣:␣'stylesheet';
␣␣␣␣␣␣␣$other␣=␣"@other"␣if␣@other;

␣␣␣␣␣␣␣if␣(ref($src)␣eq␣"ARRAY")␣#␣Check␣to␣see␣if␣the␣$src␣variable␣is␣an␣array␣reference
␣␣␣␣␣␣␣{␣#␣If␣it␣is,␣push␣a␣LINK␣tag␣for␣each␣one
␣␣␣␣␣␣␣␣␣␣␣for␣$src␣(@$src)
␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣push(@result,$XHTML␣?␣qq(<link␣rel="$rel"␣type="$type"␣href="$src"␣$other/>)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣qq(<link␣rel="$rel"␣type="$type"␣href="$src"$other>))␣if␣$src;
␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣else
␣␣␣␣␣␣␣{␣#␣Otherwise,␣push␣the␣single␣-src,␣if␣it␣exists.
␣␣␣␣␣␣␣␣␣push(@result,$XHTML␣?␣qq(<link␣rel="$rel"␣type="$type"␣href="$src"␣$other/>)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣qq(<link␣rel="$rel"␣type="$type"␣href="$src"$other>)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣if␣$src;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣if␣($verbatim)␣{
␣␣␣␣␣␣␣␣␣␣␣my␣@v␣=␣ref($verbatim)␣eq␣'ARRAY'␣?␣@$verbatim␣:␣$verbatim;
␣␣␣␣␣␣␣␣␣␣␣push(@result,␣"<style␣type=\"text/css\">\n$_\n</style>")␣for␣@v;
␣␣␣␣␣␣}
␣␣␣␣␣␣my␣@c␣=␣ref($code)␣eq␣'ARRAY'␣?␣@$code␣:␣$code␣if␣$code;
␣␣␣␣␣␣push(@result,style({'type'=>$type},"$cdata_start\n$_\n$cdata_end"))␣for␣@c;

␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣my␣$src␣=␣$s;
␣␣␣␣␣␣␣␣␣␣␣push(@result,$XHTML␣?␣qq(<link␣rel="$rel"␣type="$type"␣href="$src"␣$other/>)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣qq(<link␣rel="$rel"␣type="$type"␣href="$src"$other>));
␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣@result;
}
END_OF_FUNC

'_script'␣=>␣<<'END_OF_FUNC',
sub␣_script␣{
␣␣␣␣my␣($self,$script)␣=␣@_;
␣␣␣␣my␣(@result);

␣␣␣␣my␣(@scripts)␣=␣ref($script)␣eq␣'ARRAY'␣?␣@$script␣:␣($script);
␣␣␣␣for␣$script␣(@scripts)␣{
	my($src,$code,$language);
	if␣(ref($script))␣{␣#␣script␣is␣a␣hash
	␣␣␣␣($src,$code,$type)␣=
		rearrange(['SRC','CODE',['LANGUAGE','TYPE']],
				␣'-foo'=>'bar',	#␣a␣trick␣to␣allow␣the␣'-'␣to␣be␣omitted
				␣ref($script)␣eq␣'ARRAY'␣?␣@$script␣:␣%$script);
␣␣␣␣␣␣␣␣␣␣␣␣$type␣||=␣'text/javascript';
␣␣␣␣␣␣␣␣␣␣␣␣unless␣($type␣=~␣m!\w+/\w+!)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$type␣=~␣s/[\d.]+$//;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$type␣=␣"text/$type";
␣␣␣␣␣␣␣␣␣␣␣␣}
	}␣else␣{
	␣␣␣␣($src,$code,$type)␣=␣('',$script,␣'text/javascript');
	}

␣␣␣␣my␣$comment␣=␣'//';␣␣#␣javascript␣by␣default
␣␣␣␣$comment␣=␣'#'␣if␣$type=~/perl|tcl/i;
␣␣␣␣$comment␣=␣"'"␣if␣$type=~/vbscript/i;

␣␣␣␣my␣($cdata_start,$cdata_end);
␣␣␣␣if␣($XHTML)␣{
␣␣␣␣␣␣␣$cdata_start␣␣␣␣=␣"$comment<![CDATA[\n";
␣␣␣␣␣␣␣$cdata_end␣␣␣␣␣.=␣"\n$comment]]>";
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣$cdata_start␣␣=␣␣"\n<!--␣Hide␣script\n";
␣␣␣␣␣␣␣$cdata_end␣␣␣␣=␣$comment;
␣␣␣␣␣␣␣$cdata_end␣␣␣.=␣"␣End␣script␣hiding␣-->\n";
␣␣␣}
␣␣␣␣␣my(@satts);
␣␣␣␣␣push(@satts,'src'=>$src)␣if␣$src;
␣␣␣␣␣push(@satts,'type'=>$type);
␣␣␣␣␣$code␣=␣$cdata_start␣.␣$code␣.␣$cdata_end␣if␣defined␣$code;
␣␣␣␣␣push(@result,$self->script({@satts},$code␣||␣''));
␣␣␣␣}
␣␣␣␣@result;
}
END_OF_FUNC

####␣Method:␣end_html
#␣End␣an␣HTML␣document.
#␣Trivial␣method␣for␣completeness.␣␣Just␣returns␣"</body>"
####
'end_html'␣=>␣<<'END_OF_FUNC',
sub␣end_html␣{
␣␣␣␣return␣"\n</body>\n</html>";
}
END_OF_FUNC


################################
#␣METHODS␣USED␣IN␣BUILDING␣FORMS
################################

####␣Method:␣isindex
#␣Just␣prints␣out␣the␣isindex␣tag.
#␣Parameters:
#␣␣$action␣->␣optional␣URL␣of␣script␣to␣run
#␣Returns:
#␣␣␣A␣string␣containing␣a␣<isindex>␣tag
'isindex'␣=>␣<<'END_OF_FUNC',
sub␣isindex␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my($action,@other)␣=␣rearrange([ACTION],@p);
␣␣␣␣$action␣=␣qq/␣action="$action"/␣if␣$action;
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';
␣␣␣␣return␣$XHTML␣?␣"<isindex$action$other␣/>"␣:␣"<isindex$action$other>";
}
END_OF_FUNC


####␣Method:␣startform
#␣This␣method␣is␣DEPRECATED
#␣Start␣a␣form
#␣Parameters:
#␣␣␣$method␣->␣optional␣submission␣method␣to␣use␣(GET␣or␣POST)
#␣␣␣$action␣->␣optional␣URL␣of␣script␣to␣run
#␣␣␣$enctype␣->encoding␣to␣use␣(URL_ENCODED␣or␣MULTIPART)
'startform'␣=>␣<<'END_OF_FUNC',
sub␣startform␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);

␣␣␣␣my($method,$action,$enctype,@other)␣=␣
	rearrange([METHOD,ACTION,ENCTYPE],@p);

␣␣␣␣$method␣␣=␣$self->_maybe_escapeHTML(lc($method␣||␣'post'));
␣␣␣␣$enctype␣=␣$self->_maybe_escapeHTML($enctype␣||␣&URL_ENCODED);
␣␣␣␣if␣(defined␣$action)␣{
␣␣␣␣␣␣␣$action␣=␣$self->_maybe_escapeHTML($action);
␣␣␣␣}
␣␣␣␣else␣{
␣␣␣␣␣␣␣$action␣=␣$self->_maybe_escapeHTML($self->request_uri␣||␣$self->self_url);
␣␣␣␣}
␣␣␣␣$action␣=␣qq(action="$action");
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';
␣␣␣␣$self->{'.parametersToAdd'}={};
␣␣␣␣return␣qq/<form␣method="$method"␣$action␣enctype="$enctype"$other>\n/;
}
END_OF_FUNC

####␣Method:␣start_form
#␣Start␣a␣form
#␣Parameters:
#␣␣␣$method␣->␣optional␣submission␣method␣to␣use␣(GET␣or␣POST)
#␣␣␣$action␣->␣optional␣URL␣of␣script␣to␣run
#␣␣␣$enctype␣->encoding␣to␣use␣(URL_ENCODED␣or␣MULTIPART)
'start_form'␣=>␣<<'END_OF_FUNC',
sub␣start_form␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);

␣␣␣␣my($method,$action,$enctype,@other)␣=␣
	rearrange([METHOD,ACTION,ENCTYPE],@p);

␣␣␣␣$method␣␣=␣$self->_maybe_escapeHTML(lc($method␣||␣'post'));

␣␣␣␣if(␣$XHTML␣){
␣␣␣␣␣␣␣␣$enctype␣=␣$self->_maybe_escapeHTML($enctype␣||␣&MULTIPART);
␣␣␣␣}else{
␣␣␣␣␣␣␣␣$enctype␣=␣$self->_maybe_escapeHTML($enctype␣||␣&URL_ENCODED);
␣␣␣␣}

␣␣␣␣if␣(defined␣$action)␣{
␣␣␣␣␣␣␣$action␣=␣$self->_maybe_escapeHTML($action);
␣␣␣␣}
␣␣␣␣else␣{
␣␣␣␣␣␣␣$action␣=␣$self->_maybe_escapeHTML($self->request_uri␣||␣$self->self_url);
␣␣␣␣}
␣␣␣␣$action␣=␣qq(action="$action");
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';
␣␣␣␣$self->{'.parametersToAdd'}={};
␣␣␣␣return␣qq/<form␣method="$method"␣$action␣enctype="$enctype"$other>\n/;
}
END_OF_FUNC

####␣Method:␣start_multipart_form
'start_multipart_form'␣=>␣<<'END_OF_FUNC',
sub␣start_multipart_form␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣if␣(defined($p[0])␣&&␣substr($p[0],0,1)␣eq␣'-')␣{
␣␣␣␣␣␣return␣$self->start_form(-enctype=>&MULTIPART,@p);
␣␣␣␣}␣else␣{
	my($method,$action,@other)␣=␣
	␣␣␣␣rearrange([METHOD,ACTION],@p);
	return␣$self->start_form($method,$action,&MULTIPART,@other);
␣␣␣␣}
}
END_OF_FUNC



####␣Method:␣end_form
#␣End␣a␣form
'end_form'␣=>␣<<'END_OF_FUNC',
sub␣end_form␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣if␣(␣$NOSTICKY␣)␣{
␣␣␣␣␣␣␣␣return␣wantarray␣?␣("</form>")␣:␣"\n</form>";
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣if␣(my␣@fields␣=␣$self->get_fields)␣{
␣␣␣␣␣␣␣␣␣␣␣␣return␣wantarray␣?␣("<div>",@fields,"</div>","</form>")
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣"<div>".(join␣'',@fields)."</div>\n</form>";
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣return␣"</form>";
␣␣␣␣␣␣␣␣}
␣␣␣␣}
}
END_OF_FUNC

####␣Method:␣end_multipart_form
#␣end␣a␣multipart␣form
'end_multipart_form'␣=>␣<<'END_OF_FUNC',
sub␣end_multipart_form␣{
␣␣␣␣&end_form;
}
END_OF_FUNC


'_textfield'␣=>␣<<'END_OF_FUNC',
sub␣_textfield␣{
␣␣␣␣my($self,$tag,@p)␣=␣self_or_default(@_);
␣␣␣␣my($name,$default,$size,$maxlength,$override,$tabindex,@other)␣=␣
	rearrange([NAME,[DEFAULT,VALUE,VALUES],SIZE,MAXLENGTH,[OVERRIDE,FORCE],TABINDEX],@p);

␣␣␣␣my␣$current␣=␣$override␣?␣$default␣:␣
	(defined($self->param($name))␣?␣$self->param($name)␣:␣$default);

␣␣␣␣$current␣=␣defined($current)␣?␣$self->_maybe_escapeHTML($current,1)␣:␣'';
␣␣␣␣$name␣=␣defined($name)␣?␣$self->_maybe_escapeHTML($name)␣:␣'';
␣␣␣␣my($s)␣=␣defined($size)␣?␣qq/␣size="$size"/␣:␣'';
␣␣␣␣my($m)␣=␣defined($maxlength)␣?␣qq/␣maxlength="$maxlength"/␣:␣'';
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';
␣␣␣␣#␣this␣entered␣at␣cristy's␣request␣to␣fix␣problems␣with␣file␣upload␣fields
␣␣␣␣#␣and␣WebTV␣--␣not␣sure␣it␣won't␣break␣stuff
␣␣␣␣my($value)␣=␣$current␣ne␣''␣?␣qq(value="$current")␣:␣'';
␣␣␣␣$tabindex␣=␣$self->element_tab($tabindex);
␣␣␣␣return␣$XHTML␣?␣qq(<input␣type="$tag"␣name="$name"␣$tabindex$value$s$m$other␣/>)␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣qq(<input␣type="$tag"␣name="$name"␣$value$s$m$other>);
}
END_OF_FUNC

####␣Method:␣textfield
#␣Parameters:
#␣␣␣$name␣->␣Name␣of␣the␣text␣field
#␣␣␣$default␣->␣Optional␣default␣value␣of␣the␣field␣if␣not
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣already␣defined.
#␣␣␣$size␣->␣␣Optional␣width␣of␣field␣in␣characaters.
#␣␣␣$maxlength␣->␣Optional␣maximum␣number␣of␣characters.
#␣Returns:
#␣␣␣A␣string␣containing␣a␣<input␣type="text">␣field
#
'textfield'␣=>␣<<'END_OF_FUNC',
sub␣textfield␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣$self->_textfield('text',@p);
}
END_OF_FUNC


####␣Method:␣filefield
#␣Parameters:
#␣␣␣$name␣->␣Name␣of␣the␣file␣upload␣field
#␣␣␣$size␣->␣␣Optional␣width␣of␣field␣in␣characaters.
#␣␣␣$maxlength␣->␣Optional␣maximum␣number␣of␣characters.
#␣Returns:
#␣␣␣A␣string␣containing␣a␣<input␣type="file">␣field
#
'filefield'␣=>␣<<'END_OF_FUNC',
sub␣filefield␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣$self->_textfield('file',@p);
}
END_OF_FUNC


####␣Method:␣password
#␣Create␣a␣"secret␣password"␣entry␣field
#␣Parameters:
#␣␣␣$name␣->␣Name␣of␣the␣field
#␣␣␣$default␣->␣Optional␣default␣value␣of␣the␣field␣if␣not
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣already␣defined.
#␣␣␣$size␣->␣␣Optional␣width␣of␣field␣in␣characters.
#␣␣␣$maxlength␣->␣Optional␣maximum␣characters␣that␣can␣be␣entered.
#␣Returns:
#␣␣␣A␣string␣containing␣a␣<input␣type="password">␣field
#
'password_field'␣=>␣<<'END_OF_FUNC',
sub␣password_field␣{
␣␣␣␣my␣($self,@p)␣=␣self_or_default(@_);
␣␣␣␣$self->_textfield('password',@p);
}
END_OF_FUNC

####␣Method:␣textarea
#␣Parameters:
#␣␣␣$name␣->␣Name␣of␣the␣text␣field
#␣␣␣$default␣->␣Optional␣default␣value␣of␣the␣field␣if␣not
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣already␣defined.
#␣␣␣$rows␣->␣␣Optional␣number␣of␣rows␣in␣text␣area
#␣␣␣$columns␣->␣Optional␣number␣of␣columns␣in␣text␣area
#␣Returns:
#␣␣␣A␣string␣containing␣a␣<textarea></textarea>␣tag
#
'textarea'␣=>␣<<'END_OF_FUNC',
sub␣textarea␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my($name,$default,$rows,$cols,$override,$tabindex,@other)␣=
	rearrange([NAME,[DEFAULT,VALUE],ROWS,[COLS,COLUMNS],[OVERRIDE,FORCE],TABINDEX],@p);

␣␣␣␣my($current)=␣$override␣?␣$default␣:
	(defined($self->param($name))␣?␣$self->param($name)␣:␣$default);

␣␣␣␣$name␣=␣defined($name)␣?␣$self->_maybe_escapeHTML($name)␣:␣'';
␣␣␣␣$current␣=␣defined($current)␣?␣$self->_maybe_escapeHTML($current)␣:␣'';
␣␣␣␣my($r)␣=␣$rows␣?␣qq/␣rows="$rows"/␣:␣'';
␣␣␣␣my($c)␣=␣$cols␣?␣qq/␣cols="$cols"/␣:␣'';
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';
␣␣␣␣$tabindex␣=␣$self->element_tab($tabindex);
␣␣␣␣return␣qq{<textarea␣name="$name"␣$tabindex$r$c$other>$current</textarea>};
}
END_OF_FUNC


####␣Method:␣button
#␣Create␣a␣javascript␣button.
#␣Parameters:
#␣␣␣$name␣->␣␣(optional)␣Name␣for␣the␣button.␣(-name)
#␣␣␣$value␣->␣(optional)␣Value␣of␣the␣button␣when␣selected␣(and␣visible␣name)␣(-value)
#␣␣␣$onclick␣->␣(optional)␣Text␣of␣the␣JavaScript␣to␣run␣when␣the␣button␣is
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣clicked.
#␣Returns:
#␣␣␣A␣string␣containing␣a␣<input␣type="button">␣tag
####
'button'␣=>␣<<'END_OF_FUNC',
sub␣button␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);

␣␣␣␣my($label,$value,$script,$tabindex,@other)␣=␣rearrange([NAME,[VALUE,LABEL],
						␣␣␣␣␣␣␣␣␣␣␣␣[ONCLICK,SCRIPT],TABINDEX],@p);

␣␣␣␣$label=$self->_maybe_escapeHTML($label);
␣␣␣␣$value=$self->_maybe_escapeHTML($value,1);
␣␣␣␣$script=$self->_maybe_escapeHTML($script);

␣␣␣␣$script␣||=␣'';

␣␣␣␣my($name)␣=␣'';
␣␣␣␣$name␣=␣qq/␣name="$label"/␣if␣$label;
␣␣␣␣$value␣=␣$value␣||␣$label;
␣␣␣␣my($val)␣=␣'';
␣␣␣␣$val␣=␣qq/␣value="$value"/␣if␣$value;
␣␣␣␣$script␣=␣qq/␣onclick="$script"/␣if␣$script;
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';
␣␣␣␣$tabindex␣=␣$self->element_tab($tabindex);
␣␣␣␣return␣$XHTML␣?␣qq(<input␣type="button"␣$tabindex$name$val$script$other␣/>)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣qq(<input␣type="button"$name$val$script$other>);
}
END_OF_FUNC


####␣Method:␣submit
#␣Create␣a␣"submit␣query"␣button.
#␣Parameters:
#␣␣␣$name␣->␣␣(optional)␣Name␣for␣the␣button.
#␣␣␣$value␣->␣(optional)␣Value␣of␣the␣button␣when␣selected␣(also␣doubles␣as␣label).
#␣␣␣$label␣->␣(optional)␣Label␣printed␣on␣the␣button(also␣doubles␣as␣the␣value).
#␣Returns:
#␣␣␣A␣string␣containing␣a␣<input␣type="submit">␣tag
####
'submit'␣=>␣<<'END_OF_FUNC',
sub␣submit␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);

␣␣␣␣my($label,$value,$tabindex,@other)␣=␣rearrange([NAME,[VALUE,LABEL],TABINDEX],@p);

␣␣␣␣$label=$self->_maybe_escapeHTML($label);
␣␣␣␣$value=$self->_maybe_escapeHTML($value,1);

␣␣␣␣my␣$name␣=␣$NOSTICKY␣?␣''␣:␣'name=".submit"␣';
␣␣␣␣$name␣=␣qq/name="$label"␣/␣if␣defined($label);
␣␣␣␣$value␣=␣defined($value)␣?␣$value␣:␣$label;
␣␣␣␣my␣$val␣=␣'';
␣␣␣␣$val␣=␣qq/value="$value"␣/␣if␣defined($value);
␣␣␣␣$tabindex␣=␣$self->element_tab($tabindex);
␣␣␣␣my($other)␣=␣@other␣?␣"@other␣"␣:␣'';
␣␣␣␣return␣$XHTML␣?␣qq(<input␣type="submit"␣$tabindex$name$val$other/>)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣qq(<input␣type="submit"␣$name$val$other>);
}
END_OF_FUNC


####␣Method:␣reset
#␣Create␣a␣"reset"␣button.
#␣Parameters:
#␣␣␣$name␣->␣(optional)␣Name␣for␣the␣button.
#␣Returns:
#␣␣␣A␣string␣containing␣a␣<input␣type="reset">␣tag
####
'reset'␣=>␣<<'END_OF_FUNC',
sub␣reset␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my($label,$value,$tabindex,@other)␣=␣rearrange(['NAME',['VALUE','LABEL'],TABINDEX],@p);
␣␣␣␣$label=$self->_maybe_escapeHTML($label);
␣␣␣␣$value=$self->_maybe_escapeHTML($value,1);
␣␣␣␣my␣($name)␣=␣'␣name=".reset"';
␣␣␣␣$name␣=␣qq/␣name="$label"/␣if␣defined($label);
␣␣␣␣$value␣=␣defined($value)␣?␣$value␣:␣$label;
␣␣␣␣my($val)␣=␣'';
␣␣␣␣$val␣=␣qq/␣value="$value"/␣if␣defined($value);
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';
␣␣␣␣$tabindex␣=␣$self->element_tab($tabindex);
␣␣␣␣return␣$XHTML␣?␣qq(<input␣type="reset"␣$tabindex$name$val$other␣/>)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣qq(<input␣type="reset"$name$val$other>);
}
END_OF_FUNC


####␣Method:␣defaults
#␣Create␣a␣"defaults"␣button.
#␣Parameters:
#␣␣␣$name␣->␣(optional)␣Name␣for␣the␣button.
#␣Returns:
#␣␣␣A␣string␣containing␣a␣<input␣type="submit"␣name=".defaults">␣tag
#
#␣Note:␣this␣button␣has␣a␣special␣meaning␣to␣the␣initialization␣script,
#␣and␣tells␣it␣to␣ERASE␣the␣current␣query␣string␣so␣that␣your␣defaults
#␣are␣used␣again!
####
'defaults'␣=>␣<<'END_OF_FUNC',
sub␣defaults␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);

␣␣␣␣my($label,$tabindex,@other)␣=␣rearrange([[NAME,VALUE],TABINDEX],@p);

␣␣␣␣$label=$self->_maybe_escapeHTML($label,1);
␣␣␣␣$label␣=␣$label␣||␣"Defaults";
␣␣␣␣my($value)␣=␣qq/␣value="$label"/;
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';
␣␣␣␣$tabindex␣=␣$self->element_tab($tabindex);
␣␣␣␣return␣$XHTML␣?␣qq(<input␣type="submit"␣name=".defaults"␣$tabindex$value$other␣/>)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣qq/<input␣type="submit"␣NAME=".defaults"$value$other>/;
}
END_OF_FUNC


####␣Method:␣comment
#␣Create␣an␣HTML␣<!--␣comment␣-->
#␣Parameters:␣a␣string
'comment'␣=>␣<<'END_OF_FUNC',
sub␣comment␣{
␣␣␣␣my($self,@p)␣=␣self_or_CGI(@_);
␣␣␣␣return␣"<!--␣@p␣-->";
}
END_OF_FUNC

####␣Method:␣checkbox
#␣Create␣a␣checkbox␣that␣is␣not␣logically␣linked␣to␣any␣others.
#␣The␣field␣value␣is␣"on"␣when␣the␣button␣is␣checked.
#␣Parameters:
#␣␣␣$name␣->␣Name␣of␣the␣checkbox
#␣␣␣$checked␣->␣(optional)␣turned␣on␣by␣default␣if␣true
#␣␣␣$value␣->␣(optional)␣value␣of␣the␣checkbox,␣'on'␣by␣default
#␣␣␣$label␣->␣(optional)␣a␣user-readable␣label␣printed␣next␣to␣the␣box.
#␣␣␣␣␣␣␣␣␣␣␣␣␣Otherwise␣the␣checkbox␣name␣is␣used.
#␣Returns:
#␣␣␣A␣string␣containing␣a␣<input␣type="checkbox">␣field
####
'checkbox'␣=>␣<<'END_OF_FUNC',
sub␣checkbox␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);

␣␣␣␣my($name,$checked,$value,$label,$labelattributes,$override,$tabindex,@other)␣=
␣␣␣␣␣␣␣rearrange([NAME,[CHECKED,SELECTED,ON],VALUE,LABEL,LABELATTRIBUTES,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣[OVERRIDE,FORCE],TABINDEX],@p);

␣␣␣␣$value␣=␣defined␣$value␣?␣$value␣:␣'on';

␣␣␣␣if␣(!$override␣&&␣($self->{'.fieldnames'}->{$name}␣||␣
		␣␣␣␣␣␣␣defined␣$self->param($name)))␣{
	$checked␣=␣grep($_␣eq␣$value,$self->param($name))␣?␣$self->_checked(1)␣:␣'';
␣␣␣␣}␣else␣{
	$checked␣=␣$self->_checked($checked);
␣␣␣␣}
␣␣␣␣my($the_label)␣=␣defined␣$label␣?␣$label␣:␣$name;
␣␣␣␣$name␣=␣$self->_maybe_escapeHTML($name);
␣␣␣␣$value␣=␣$self->_maybe_escapeHTML($value,1);
␣␣␣␣$the_label␣=␣$self->_maybe_escapeHTML($the_label);
␣␣␣␣my($other)␣=␣@other␣?␣"@other␣"␣:␣'';
␣␣␣␣$tabindex␣=␣$self->element_tab($tabindex);
␣␣␣␣$self->register_parameter($name);
␣␣␣␣return␣$XHTML␣?␣CGI::label($labelattributes,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{<input␣type="checkbox"␣name="$name"␣value="$value"␣$tabindex$checked$other/>$the_label})
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣qq{<input␣type="checkbox"␣name="$name"␣value="$value"$checked$other>$the_label};
}
END_OF_FUNC



#␣Escape␣HTML
'escapeHTML'␣=>␣<<'END_OF_FUNC',
sub␣escapeHTML␣{
␣␣␣␣␣#␣hack␣to␣work␣around␣␣earlier␣hacks
␣␣␣␣␣push␣@_,$_[0]␣if␣@_==1␣&&␣$_[0]␣eq␣'CGI';
␣␣␣␣␣my␣($self,$toencode,$newlinestoo)␣=␣CGI::self_or_default(@_);
␣␣␣␣␣return␣undef␣unless␣defined($toencode);
␣␣␣␣␣$toencode␣=~␣s{&}{&amp;}gso;
␣␣␣␣␣$toencode␣=~␣s{<}{&lt;}gso;
␣␣␣␣␣$toencode␣=~␣s{>}{&gt;}gso;
␣␣␣␣␣if␣($DTD_PUBLIC_IDENTIFIER␣=~␣/[^X]HTML␣3\.2/i)␣{
␣␣␣␣␣#␣$quot;␣was␣accidentally␣omitted␣from␣the␣HTML␣3.2␣DTD␣--␣see
␣␣␣␣␣#␣<http://validator.w3.org/docs/errors.html#bad-entity>␣/
␣␣␣␣␣#␣<http://lists.w3.org/Archives/Public/www-html/1997Mar/0003.html>.
␣␣␣␣␣␣␣␣$toencode␣=~␣s{"}{&#34;}gso;
␣␣␣␣␣}
␣␣␣␣␣else␣{
␣␣␣␣␣␣␣␣$toencode␣=~␣s{"}{&quot;}gso;
␣␣␣␣␣}

␣␣␣␣#␣Handle␣bug␣in␣some␣browsers␣with␣Latin␣charsets
␣␣␣␣if␣($self->{'.charset'}␣
␣␣␣␣␣␣␣␣␣␣␣␣&&␣(uc($self->{'.charset'})␣eq␣'ISO-8859-1'␣
␣␣␣␣␣␣␣␣␣␣␣␣||␣uc($self->{'.charset'})␣eq␣'WINDOWS-1252'))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$toencode␣=~␣s{'}{&#39;}gso;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$toencode␣=~␣s{\x8b}{&#8249;}gso;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$toencode␣=~␣s{\x9b}{&#8250;}gso;
␣␣␣␣␣␣␣␣if␣(defined␣$newlinestoo␣&&␣$newlinestoo)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$toencode␣=~␣s{\012}{&#10;}gso;
␣␣␣␣␣␣␣␣␣␣␣␣$toencode␣=~␣s{\015}{&#13;}gso;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣return␣$toencode;
}
END_OF_FUNC

#␣unescape␣HTML␣--␣used␣internally
'unescapeHTML'␣=>␣<<'END_OF_FUNC',
sub␣unescapeHTML␣{
␣␣␣␣#␣hack␣to␣work␣around␣␣earlier␣hacks
␣␣␣␣push␣@_,$_[0]␣if␣@_==1␣&&␣$_[0]␣eq␣'CGI';
␣␣␣␣my␣($self,$string)␣=␣CGI::self_or_default(@_);
␣␣␣␣return␣undef␣unless␣defined($string);
␣␣␣␣my␣$latin␣=␣defined␣$self->{'.charset'}␣?␣$self->{'.charset'}␣=~␣/^(ISO-8859-1|WINDOWS-1252)$/i
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣1;
␣␣␣␣#␣thanks␣to␣Randal␣Schwartz␣for␣the␣correct␣solution␣to␣this␣one
␣␣␣␣$string=~␣s[&(\S*?);]{
	local␣$_␣=␣$1;
	/^amp$/i	?␣"&"␣:
	/^quot$/i	?␣'"'␣:
␣␣␣␣␣␣␣␣/^gt$/i		?␣">"␣:
	/^lt$/i		?␣"<"␣:
	/^#(\d+)$/␣&&␣$latin	␣␣␣␣␣?␣chr($1)␣:
	/^#x([0-9a-f]+)$/i␣&&␣$latin␣?␣chr(hex($1))␣:
	$_
	}gex;
␣␣␣␣return␣$string;
}
END_OF_FUNC

#␣Internal␣procedure␣-␣don't␣use
'_tableize'␣=>␣<<'END_OF_FUNC',
sub␣_tableize␣{
␣␣␣␣my($rows,$columns,$rowheaders,$colheaders,@elements)␣=␣@_;
␣␣␣␣my␣@rowheaders␣=␣$rowheaders␣?␣@$rowheaders␣:␣();
␣␣␣␣my␣@colheaders␣=␣$colheaders␣?␣@$colheaders␣:␣();
␣␣␣␣my($result);

␣␣␣␣if␣(defined($columns))␣{
	$rows␣=␣int(0.99␣+␣@elements/$columns)␣unless␣defined($rows);
␣␣␣␣}
␣␣␣␣if␣(defined($rows))␣{
	$columns␣=␣int(0.99␣+␣@elements/$rows)␣unless␣defined($columns);
␣␣␣␣}

␣␣␣␣#␣rearrange␣into␣a␣pretty␣table
␣␣␣␣$result␣=␣"<table>";
␣␣␣␣my($row,$column);
␣␣␣␣unshift(@colheaders,'')␣if␣@colheaders␣&&␣@rowheaders;
␣␣␣␣$result␣.=␣"<tr>"␣if␣@colheaders;
␣␣␣␣for␣(@colheaders)␣{
	$result␣.=␣"<th>$_</th>";
␣␣␣␣}
␣␣␣␣for␣($row=0;$row<$rows;$row++)␣{
	$result␣.=␣"<tr>";
	$result␣.=␣"<th>$rowheaders[$row]</th>"␣if␣@rowheaders;
	for␣($column=0;$column<$columns;$column++)␣{
	␣␣␣␣$result␣.=␣"<td>"␣.␣$elements[$column*$rows␣+␣$row]␣.␣"</td>"
		if␣defined($elements[$column*$rows␣+␣$row]);
	}
	$result␣.=␣"</tr>";
␣␣␣␣}
␣␣␣␣$result␣.=␣"</table>";
␣␣␣␣return␣$result;
}
END_OF_FUNC


####␣Method:␣radio_group
#␣Create␣a␣list␣of␣logically-linked␣radio␣buttons.
#␣Parameters:
#␣␣␣$name␣->␣Common␣name␣for␣all␣the␣buttons.
#␣␣␣$values␣->␣A␣pointer␣to␣a␣regular␣array␣containing␣the
#␣␣␣␣␣␣␣␣␣␣␣␣␣values␣for␣each␣button␣in␣the␣group.
#␣␣␣$default␣->␣(optional)␣Value␣of␣the␣button␣to␣turn␣on␣by␣default.␣␣Pass␣'-'
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣to␣turn␣_nothing_␣on.
#␣␣␣$linebreak␣->␣(optional)␣Set␣to␣true␣to␣place␣linebreaks
#␣␣␣␣␣␣␣␣␣␣␣␣␣between␣the␣buttons.
#␣␣␣$labels␣->␣(optional)
#␣␣␣␣␣␣␣␣␣␣␣␣␣A␣pointer␣to␣a␣hash␣of␣labels␣to␣print␣next␣to␣each␣checkbox
#␣␣␣␣␣␣␣␣␣␣␣␣␣in␣the␣form␣$label{'value'}="Long␣explanatory␣label".
#␣␣␣␣␣␣␣␣␣␣␣␣␣Otherwise␣the␣provided␣values␣are␣used␣as␣the␣labels.
#␣Returns:
#␣␣␣An␣ARRAY␣containing␣a␣series␣of␣<input␣type="radio">␣fields
####
'radio_group'␣=>␣<<'END_OF_FUNC',
sub␣radio_group␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣$self->_box_group('radio',@p);
}
END_OF_FUNC

####␣Method:␣checkbox_group
#␣Create␣a␣list␣of␣logically-linked␣checkboxes.
#␣Parameters:
#␣␣␣$name␣->␣Common␣name␣for␣all␣the␣check␣boxes
#␣␣␣$values␣->␣A␣pointer␣to␣a␣regular␣array␣containing␣the
#␣␣␣␣␣␣␣␣␣␣␣␣␣values␣for␣each␣checkbox␣in␣the␣group.
#␣␣␣$defaults␣->␣(optional)
#␣␣␣␣␣␣␣␣␣␣␣␣␣1.␣If␣a␣pointer␣to␣a␣regular␣array␣of␣checkbox␣values,
#␣␣␣␣␣␣␣␣␣␣␣␣␣then␣this␣will␣be␣used␣to␣decide␣which
#␣␣␣␣␣␣␣␣␣␣␣␣␣checkboxes␣to␣turn␣on␣by␣default.
#␣␣␣␣␣␣␣␣␣␣␣␣␣2.␣If␣a␣scalar,␣will␣be␣assumed␣to␣hold␣the
#␣␣␣␣␣␣␣␣␣␣␣␣␣value␣of␣a␣single␣checkbox␣in␣the␣group␣to␣turn␣on.␣
#␣␣␣$linebreak␣->␣(optional)␣Set␣to␣true␣to␣place␣linebreaks
#␣␣␣␣␣␣␣␣␣␣␣␣␣between␣the␣buttons.
#␣␣␣$labels␣->␣(optional)
#␣␣␣␣␣␣␣␣␣␣␣␣␣A␣pointer␣to␣a␣hash␣of␣labels␣to␣print␣next␣to␣each␣checkbox
#␣␣␣␣␣␣␣␣␣␣␣␣␣in␣the␣form␣$label{'value'}="Long␣explanatory␣label".
#␣␣␣␣␣␣␣␣␣␣␣␣␣Otherwise␣the␣provided␣values␣are␣used␣as␣the␣labels.
#␣Returns:
#␣␣␣An␣ARRAY␣containing␣a␣series␣of␣<input␣type="checkbox">␣fields
####

'checkbox_group'␣=>␣<<'END_OF_FUNC',
sub␣checkbox_group␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣$self->_box_group('checkbox',@p);
}
END_OF_FUNC

'_box_group'␣=>␣<<'END_OF_FUNC',
sub␣_box_group␣{
␣␣␣␣my␣$self␣␣␣␣␣=␣shift;
␣␣␣␣my␣$box_type␣=␣shift;

␣␣␣␣my($name,$values,$defaults,$linebreak,$labels,$labelattributes,
␣␣␣␣␣␣␣$attributes,$rows,$columns,$rowheaders,$colheaders,
␣␣␣␣␣␣␣$override,$nolabels,$tabindex,$disabled,@other)␣=
␣␣␣␣␣␣␣␣rearrange([NAME,[VALUES,VALUE],[DEFAULT,DEFAULTS],LINEBREAK,LABELS,LABELATTRIBUTES,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣ATTRIBUTES,ROWS,[COLUMNS,COLS],[ROWHEADERS,ROWHEADER],[COLHEADERS,COLHEADER],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣[OVERRIDE,FORCE],NOLABELS,TABINDEX,DISABLED
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣],@_);


␣␣␣␣my($result,$checked,@elements,@values);

␣␣␣␣@values␣=␣$self->_set_values_and_labels($values,\$labels,$name);
␣␣␣␣my␣%checked␣=␣$self->previous_or_default($name,$defaults,$override);

␣␣␣␣#␣If␣no␣check␣array␣is␣specified,␣check␣the␣first␣by␣default
␣␣␣␣$checked{$values[0]}++␣if␣$box_type␣eq␣'radio'␣&&␣!%checked;

␣␣␣␣$name=$self->_maybe_escapeHTML($name);

␣␣␣␣my␣%tabs␣=␣();
␣␣␣␣if␣($TABINDEX␣&&␣$tabindex)␣{
␣␣␣␣␣␣if␣(!ref␣$tabindex)␣{
␣␣␣␣␣␣␣␣␣␣$self->element_tab($tabindex);
␣␣␣␣␣␣}␣elsif␣(ref␣$tabindex␣eq␣'ARRAY')␣{
␣␣␣␣␣␣␣␣␣␣%tabs␣=␣map␣{$_=>$self->element_tab}␣@$tabindex;
␣␣␣␣␣␣}␣elsif␣(ref␣$tabindex␣eq␣'HASH')␣{
␣␣␣␣␣␣␣␣␣␣%tabs␣=␣%$tabindex;
␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣%tabs␣=␣map␣{$_=>$self->element_tab}␣@values␣unless␣%tabs;
␣␣␣␣my␣$other␣=␣@other␣?␣"@other␣"␣:␣'';
␣␣␣␣my␣$radio_checked;

␣␣␣␣#␣for␣disabling␣groups␣of␣radio/checkbox␣buttons
␣␣␣␣my␣%disabled;
␣␣␣␣for␣(@{$disabled})␣{
␣␣␣	$disabled{$_}=1;
␣␣␣␣}

␣␣␣␣for␣(@values)␣{
␣␣␣␣	␣my␣$disable="";
	␣if␣($disabled{$_})␣{
		$disable="disabled='1'";
	␣}

␣␣␣␣␣␣␣␣my␣$checkit␣=␣$self->_checked($box_type␣eq␣'radio'␣?␣($checked{$_}␣&&␣!$radio_checked++)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣$checked{$_});
	my($break);
	if␣($linebreak)␣{
␣␣␣␣␣␣␣␣␣␣$break␣=␣$XHTML␣?␣"<br␣/>"␣:␣"<br>";
	}
	else␣{
	␣␣$break␣=␣'';
	}
	my($label)='';
	unless␣(defined($nolabels)␣&&␣$nolabels)␣{
	␣␣␣␣$label␣=␣$_;
	␣␣␣␣$label␣=␣$labels->{$_}␣if␣defined($labels)␣&&␣defined($labels->{$_});
	␣␣␣␣$label␣=␣$self->_maybe_escapeHTML($label,1);
␣␣␣␣␣␣␣␣␣␣␣␣$label␣=␣"<span␣style=\"color:gray\">$label</span>"␣if␣$disabled{$_};
	}
␣␣␣␣␣␣␣␣my␣$attribs␣=␣$self->_set_attributes($_,␣$attributes);
␣␣␣␣␣␣␣␣my␣$tab␣␣␣␣␣=␣$tabs{$_};
	$_=$self->_maybe_escapeHTML($_);

␣␣␣␣␣␣␣␣if␣($XHTML)␣{
␣␣␣␣␣␣␣␣␣␣␣push␣@elements,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣CGI::label($labelattributes,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq(<input␣type="$box_type"␣name="$name"␣value="$_"␣$checkit$other$tab$attribs$disable/>$label)).${break};
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣push(@elements,qq/<input␣type="$box_type"␣name="$name"␣value="$_"␣$checkit$other$tab$attribs$disable>${label}${break}/);
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣$self->register_parameter($name);
␣␣␣␣return␣wantarray␣?␣@elements␣:␣"@elements"
␣␣␣␣␣␣␣␣␣␣␣unless␣defined($columns)␣||␣defined($rows);
␣␣␣␣return␣_tableize($rows,$columns,$rowheaders,$colheaders,@elements);
}
END_OF_FUNC


####␣Method:␣popup_menu
#␣Create␣a␣popup␣menu.
#␣Parameters:
#␣␣␣$name␣->␣Name␣for␣all␣the␣menu
#␣␣␣$values␣->␣A␣pointer␣to␣a␣regular␣array␣containing␣the
#␣␣␣␣␣␣␣␣␣␣␣␣␣text␣of␣each␣menu␣item.
#␣␣␣$default␣->␣(optional)␣Default␣item␣to␣display
#␣␣␣$labels␣->␣(optional)
#␣␣␣␣␣␣␣␣␣␣␣␣␣A␣pointer␣to␣a␣hash␣of␣labels␣to␣print␣next␣to␣each␣checkbox
#␣␣␣␣␣␣␣␣␣␣␣␣␣in␣the␣form␣$label{'value'}="Long␣explanatory␣label".
#␣␣␣␣␣␣␣␣␣␣␣␣␣Otherwise␣the␣provided␣values␣are␣used␣as␣the␣labels.
#␣Returns:
#␣␣␣A␣string␣containing␣the␣definition␣of␣a␣popup␣menu.
####
'popup_menu'␣=>␣<<'END_OF_FUNC',
sub␣popup_menu␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);

␣␣␣␣my($name,$values,$default,$labels,$attributes,$override,$tabindex,@other)␣=
␣␣␣␣␣␣␣rearrange([NAME,[VALUES,VALUE],[DEFAULT,DEFAULTS],LABELS,
␣␣␣␣␣␣␣ATTRIBUTES,[OVERRIDE,FORCE],TABINDEX],@p);
␣␣␣␣my($result,%selected);

␣␣␣␣if␣(!$override␣&&␣defined($self->param($name)))␣{
	$selected{$self->param($name)}++;
␣␣␣␣}␣elsif␣(defined␣$default)␣{
	%selected␣=␣map␣{$_=>1}␣ref($default)␣eq␣'ARRAY'␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣@$default␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣$default;
␣␣␣␣}
␣␣␣␣$name=$self->_maybe_escapeHTML($name);
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';

␣␣␣␣my(@values);
␣␣␣␣@values␣=␣$self->_set_values_and_labels($values,\$labels,$name);
␣␣␣␣$tabindex␣=␣$self->element_tab($tabindex);
␣␣␣␣$name␣=␣q{}␣if␣!␣defined␣$name;
␣␣␣␣$result␣=␣qq/<select␣name="$name"␣$tabindex$other>\n/;
␣␣␣␣for␣(@values)␣{
␣␣␣␣␣␣␣␣if␣(/<optgroup/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣for␣my␣$v␣(split(/\n/))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$selectit␣=␣$XHTML␣?␣'selected="selected"'␣:␣'selected';
		for␣my␣$selected␣(keys␣%selected)␣{
		␣␣␣␣$v␣=~␣s/(value="\Q$selected\E")/$selectit␣$1/;
		}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$result␣.=␣"$v\n";
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣else␣{
␣␣␣␣␣␣␣␣␣␣my␣$attribs␣␣␣=␣$self->_set_attributes($_,␣$attributes);
	␣␣my($selectit)␣=␣$self->_selected($selected{$_});
	␣␣my($label)␣␣␣␣=␣$_;
	␣␣$label␣␣␣␣␣␣␣␣=␣$labels->{$_}␣if␣defined($labels)␣&&␣defined($labels->{$_});
	␣␣my($value)␣␣␣␣=␣$self->_maybe_escapeHTML($_);
	␣␣$label␣␣␣␣␣␣␣␣=␣$self->_maybe_escapeHTML($label,1);
␣␣␣␣␣␣␣␣␣␣$result␣␣␣␣␣␣.=␣"<option${attribs}␣${selectit}value=\"$value\">$label</option>\n";
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣$result␣.=␣"</select>";
␣␣␣␣return␣$result;
}
END_OF_FUNC


####␣Method:␣optgroup
#␣Create␣a␣optgroup.
#␣Parameters:
#␣␣␣$name␣->␣Label␣for␣the␣group
#␣␣␣$values␣->␣A␣pointer␣to␣a␣regular␣array␣containing␣the
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣values␣for␣each␣option␣line␣in␣the␣group.
#␣␣␣$labels␣->␣(optional)
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣A␣pointer␣to␣a␣hash␣of␣labels␣to␣print␣next␣to␣each␣item
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣in␣the␣form␣$label{'value'}="Long␣explanatory␣label".
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣Otherwise␣the␣provided␣values␣are␣used␣as␣the␣labels.
#␣␣␣$labeled␣->␣(optional)
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣A␣true␣value␣indicates␣the␣value␣should␣be␣used␣as␣the␣label␣attribute
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣in␣the␣option␣elements.
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣The␣label␣attribute␣specifies␣the␣option␣label␣presented␣to␣the␣user.
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣This␣defaults␣to␣the␣content␣of␣the␣<option>␣element,␣but␣the␣label
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣attribute␣allows␣authors␣to␣more␣easily␣use␣optgroup␣without␣sacrificing
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣compatibility␣with␣browsers␣that␣do␣not␣support␣option␣groups.
#␣␣␣$novals␣->␣(optional)
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣A␣true␣value␣indicates␣to␣suppress␣the␣val␣attribute␣in␣the␣option␣elements
#␣Returns:
#␣␣␣A␣string␣containing␣the␣definition␣of␣an␣option␣group.
####
'optgroup'␣=>␣<<'END_OF_FUNC',
sub␣optgroup␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my($name,$values,$attributes,$labeled,$noval,$labels,@other)
␣␣␣␣␣␣␣␣=␣rearrange([NAME,[VALUES,VALUE],ATTRIBUTES,LABELED,NOVALS,LABELS],@p);

␣␣␣␣my($result,@values);
␣␣␣␣@values␣=␣$self->_set_values_and_labels($values,\$labels,$name,$labeled,$novals);
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';

␣␣␣␣$name␣=␣$self->_maybe_escapeHTML($name)␣||␣q{};
␣␣␣␣$result␣=␣qq/<optgroup␣label="$name"$other>\n/;
␣␣␣␣for␣(@values)␣{
␣␣␣␣␣␣␣␣if␣(/<optgroup/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣for␣(split(/\n/))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$selectit␣=␣$XHTML␣?␣'selected="selected"'␣:␣'selected';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣s/(value="$selected")/$selectit␣$1/␣if␣defined␣$selected;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$result␣.=␣"$_\n";
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$attribs␣=␣$self->_set_attributes($_,␣$attributes);
␣␣␣␣␣␣␣␣␣␣␣␣my($label)␣=␣$_;
␣␣␣␣␣␣␣␣␣␣␣␣$label␣=␣$labels->{$_}␣if␣defined($labels)␣&&␣defined($labels->{$_});
␣␣␣␣␣␣␣␣␣␣␣␣$label=$self->_maybe_escapeHTML($label);
␣␣␣␣␣␣␣␣␣␣␣␣my($value)=$self->_maybe_escapeHTML($_,1);
␣␣␣␣␣␣␣␣␣␣␣␣$result␣.=␣$labeled␣?␣$novals␣?␣"<option$attribs␣label=\"$value\">$label</option>\n"
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣"<option$attribs␣label=\"$value\"␣value=\"$value\">$label</option>\n"
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣$novals␣?␣"<option$attribs>$label</option>\n"
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣"<option$attribs␣value=\"$value\">$label</option>\n";
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣$result␣.=␣"</optgroup>";
␣␣␣␣return␣$result;
}
END_OF_FUNC


####␣Method:␣scrolling_list
#␣Create␣a␣scrolling␣list.
#␣Parameters:
#␣␣␣$name␣->␣name␣for␣the␣list
#␣␣␣$values␣->␣A␣pointer␣to␣a␣regular␣array␣containing␣the
#␣␣␣␣␣␣␣␣␣␣␣␣␣values␣for␣each␣option␣line␣in␣the␣list.
#␣␣␣$defaults␣->␣(optional)
#␣␣␣␣␣␣␣␣␣␣␣␣␣1.␣If␣a␣pointer␣to␣a␣regular␣array␣of␣options,
#␣␣␣␣␣␣␣␣␣␣␣␣␣then␣this␣will␣be␣used␣to␣decide␣which
#␣␣␣␣␣␣␣␣␣␣␣␣␣lines␣to␣turn␣on␣by␣default.
#␣␣␣␣␣␣␣␣␣␣␣␣␣2.␣Otherwise␣holds␣the␣value␣of␣the␣single␣line␣to␣turn␣on.
#␣␣␣$size␣->␣(optional)␣Size␣of␣the␣list.
#␣␣␣$multiple␣->␣(optional)␣If␣set,␣allow␣multiple␣selections.
#␣␣␣$labels␣->␣(optional)
#␣␣␣␣␣␣␣␣␣␣␣␣␣A␣pointer␣to␣a␣hash␣of␣labels␣to␣print␣next␣to␣each␣checkbox
#␣␣␣␣␣␣␣␣␣␣␣␣␣in␣the␣form␣$label{'value'}="Long␣explanatory␣label".
#␣␣␣␣␣␣␣␣␣␣␣␣␣Otherwise␣the␣provided␣values␣are␣used␣as␣the␣labels.
#␣Returns:
#␣␣␣A␣string␣containing␣the␣definition␣of␣a␣scrolling␣list.
####
'scrolling_list'␣=>␣<<'END_OF_FUNC',
sub␣scrolling_list␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my($name,$values,$defaults,$size,$multiple,$labels,$attributes,$override,$tabindex,@other)
	=␣rearrange([NAME,[VALUES,VALUE],[DEFAULTS,DEFAULT],
␣␣␣␣␣␣␣␣␣␣SIZE,MULTIPLE,LABELS,ATTRIBUTES,[OVERRIDE,FORCE],TABINDEX],@p);

␣␣␣␣my($result,@values);
␣␣␣␣@values␣=␣$self->_set_values_and_labels($values,\$labels,$name);

␣␣␣␣$size␣=␣$size␣||␣scalar(@values);

␣␣␣␣my(%selected)␣=␣$self->previous_or_default($name,$defaults,$override);

␣␣␣␣my($is_multiple)␣=␣$multiple␣?␣qq/␣multiple="multiple"/␣:␣'';
␣␣␣␣my($has_size)␣=␣$size␣?␣qq/␣size="$size"/:␣'';
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';

␣␣␣␣$name=$self->_maybe_escapeHTML($name);
␣␣␣␣$tabindex␣=␣$self->element_tab($tabindex);
␣␣␣␣$result␣=␣qq/<select␣name="$name"␣$tabindex$has_size$is_multiple$other>\n/;
␣␣␣␣for␣(@values)␣{
␣␣␣␣␣␣␣␣if␣(/<optgroup/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣for␣my␣$v␣(split(/\n/))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$selectit␣=␣$XHTML␣?␣'selected="selected"'␣:␣'selected';
		for␣my␣$selected␣(keys␣%selected)␣{
		␣␣␣␣$v␣=~␣s/(value="$selected")/$selectit␣$1/;
		}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$result␣.=␣"$v\n";
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣else␣{
␣␣␣␣␣␣␣␣␣␣my␣$attribs␣␣␣=␣$self->_set_attributes($_,␣$attributes);
	␣␣my($selectit)␣=␣$self->_selected($selected{$_});
	␣␣my($label)␣␣␣␣=␣$_;
	␣␣$label␣␣␣␣␣␣␣␣=␣$labels->{$_}␣if␣defined($labels)␣&&␣defined($labels->{$_});
	␣␣my($value)␣␣␣␣=␣$self->_maybe_escapeHTML($_);
	␣␣$label␣␣␣␣␣␣␣␣=␣$self->_maybe_escapeHTML($label,1);
␣␣␣␣␣␣␣␣␣␣$result␣␣␣␣␣␣.=␣"<option${attribs}␣${selectit}value=\"$value\">$label</option>\n";
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣$result␣.=␣"</select>";
␣␣␣␣$self->register_parameter($name);
␣␣␣␣return␣$result;
}
END_OF_FUNC


####␣Method:␣hidden
#␣Parameters:
#␣␣␣$name␣->␣Name␣of␣the␣hidden␣field
#␣␣␣@default␣->␣(optional)␣Initial␣values␣of␣field␣(may␣be␣an␣array)
#␣␣␣␣␣␣or
#␣␣␣$default->[initial␣values␣of␣field]
#␣Returns:
#␣␣␣A␣string␣containing␣a␣<input␣type="hidden"␣name="name"␣value="value">
####
'hidden'␣=>␣<<'END_OF_FUNC',
sub␣hidden␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);

␣␣␣␣#␣this␣is␣the␣one␣place␣where␣we␣departed␣from␣our␣standard
␣␣␣␣#␣calling␣scheme,␣so␣we␣have␣to␣special-case␣(darn)
␣␣␣␣my(@result,@value);
␣␣␣␣my($name,$default,$override,@other)␣=␣
	rearrange([NAME,[DEFAULT,VALUE,VALUES],[OVERRIDE,FORCE]],@p);

␣␣␣␣my␣$do_override␣=␣0;
␣␣␣␣if␣(␣ref($p[0])␣||␣substr($p[0],0,1)␣eq␣'-')␣{
	@value␣=␣ref($default)␣?␣@{$default}␣:␣$default;
	$do_override␣=␣$override;
␣␣␣␣}␣else␣{
	for␣($default,$override,@other)␣{
	␣␣␣␣push(@value,$_)␣if␣defined($_);
	}
␣␣␣␣␣␣␣␣undef␣@other;
␣␣␣␣}

␣␣␣␣#␣use␣previous␣values␣if␣override␣is␣not␣set
␣␣␣␣my␣@prev␣=␣$self->param($name);
␣␣␣␣@value␣=␣@prev␣if␣!$do_override␣&&␣@prev;

␣␣␣␣$name=$self->_maybe_escapeHTML($name);
␣␣␣␣for␣(@value)␣{
	$_␣=␣defined($_)␣?␣$self->_maybe_escapeHTML($_,1)␣:␣'';
	push␣@result,$XHTML␣?␣qq(<input␣type="hidden"␣name="$name"␣value="$_"␣@other␣/>)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣qq(<input␣type="hidden"␣name="$name"␣value="$_"␣@other>);
␣␣␣␣}
␣␣␣␣return␣wantarray␣?␣@result␣:␣join('',@result);
}
END_OF_FUNC


####␣Method:␣image_button
#␣Parameters:
#␣␣␣$name␣->␣Name␣of␣the␣button
#␣␣␣$src␣->␣␣URL␣of␣the␣image␣source
#␣␣␣$align␣->␣Alignment␣style␣(TOP,␣BOTTOM␣or␣MIDDLE)
#␣Returns:
#␣␣␣A␣string␣containing␣a␣<input␣type="image"␣name="name"␣src="url"␣align="alignment">
####
'image_button'␣=>␣<<'END_OF_FUNC',
sub␣image_button␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);

␣␣␣␣my($name,$src,$alignment,@other)␣=
	rearrange([NAME,SRC,ALIGN],@p);

␣␣␣␣my($align)␣=␣$alignment␣?␣"␣align=\L\"$alignment\""␣:␣'';
␣␣␣␣my($other)␣=␣@other␣?␣"␣@other"␣:␣'';
␣␣␣␣$name=$self->_maybe_escapeHTML($name);
␣␣␣␣return␣$XHTML␣?␣qq(<input␣type="image"␣name="$name"␣src="$src"$align$other␣/>)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣qq/<input␣type="image"␣name="$name"␣src="$src"$align$other>/;
}
END_OF_FUNC


####␣Method:␣self_url
#␣Returns␣a␣URL␣containing␣the␣current␣script␣and␣all␣its
#␣param/value␣pairs␣arranged␣as␣a␣query.␣␣You␣can␣use␣this
#␣to␣create␣a␣link␣that,␣when␣selected,␣will␣reinvoke␣the
#␣script␣with␣all␣its␣state␣information␣preserved.
####
'self_url'␣=>␣<<'END_OF_FUNC',
sub␣self_url␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣return␣$self->url('-path_info'=>1,'-query'=>1,'-full'=>1,@p);
}
END_OF_FUNC


#␣This␣is␣provided␣as␣a␣synonym␣to␣self_url()␣for␣people␣unfortunate
#␣enough␣to␣have␣incorporated␣it␣into␣their␣programs␣already!
'state'␣=>␣<<'END_OF_FUNC',
sub␣state␣{
␣␣␣␣&self_url;
}
END_OF_FUNC


####␣Method:␣url
#␣Like␣self_url,␣but␣doesn't␣return␣the␣query␣string␣part␣of
#␣the␣URL.
####
'url'␣=>␣<<'END_OF_FUNC',
sub␣url␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my␣($relative,$absolute,$full,$path_info,$query,$base,$rewrite)␣=␣
	rearrange(['RELATIVE','ABSOLUTE','FULL',['PATH','PATH_INFO'],['QUERY','QUERY_STRING'],'BASE','REWRITE'],@p);
␣␣␣␣my␣$url␣␣=␣'';
␣␣␣␣$full++␣␣␣␣␣␣if␣$base␣||␣!($relative␣||␣$absolute);
␣␣␣␣$rewrite++␣␣␣unless␣defined␣$rewrite;

␣␣␣␣my␣$path␣␣␣␣␣␣␣␣=␣␣$self->path_info;
␣␣␣␣my␣$script_name␣=␣␣$self->script_name;
␣␣␣␣my␣$request_uri␣=␣␣unescape($self->request_uri)␣||␣'';
␣␣␣␣my␣$query_str␣␣␣=␣␣$self->query_string;

␣␣␣␣my␣$rewrite_in_use␣=␣$request_uri␣&&␣$request_uri␣!~␣/^\Q$script_name/;
␣␣␣␣undef␣$path␣if␣$rewrite_in_use␣&&␣$rewrite;␣␣#␣path␣not␣valid␣when␣rewriting␣active

␣␣␣␣my␣$uri␣␣␣␣␣␣␣␣␣=␣␣$rewrite␣&&␣$request_uri␣?␣$request_uri␣:␣$script_name;
␣␣␣␣$uri␣␣␣␣␣␣␣␣␣␣␣␣=~␣s/\?.*$//s;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣remove␣query␣string
␣␣␣␣$uri␣␣␣␣␣␣␣␣␣␣␣␣=~␣s/\Q$ENV{PATH_INFO}\E$//␣if␣defined␣$ENV{PATH_INFO};
#␣␣␣␣$uri␣␣␣␣␣␣␣␣␣␣␣␣=~␣s/\Q$path\E$//␣␣␣␣␣␣if␣defined␣$path;␣␣␣␣␣␣#␣remove␣path

␣␣␣␣if␣($full)␣{
␣␣␣␣␣␣␣␣my␣$protocol␣=␣$self->protocol();
␣␣␣␣␣␣␣␣$url␣=␣"$protocol://";
␣␣␣␣␣␣␣␣my␣$vh␣=␣http('x_forwarded_host')␣||␣http('host')␣||␣'';
␣␣␣␣␣␣␣␣␣␣␣␣$vh␣=~␣s/\:\d+$//;␣␣#␣some␣clients␣add␣the␣port␣number␣(incorrectly).␣Get␣rid␣of␣it.

␣␣␣␣␣␣␣␣$url␣.=␣$vh␣||␣server_name();

␣␣␣␣␣␣␣␣my␣$port␣=␣$self->virtual_port;

␣␣␣␣␣␣␣␣#␣add␣the␣port␣to␣the␣url␣unless␣it's␣the␣protocol's␣default␣port
␣␣␣␣␣␣␣␣$url␣.=␣':'␣.␣$port␣unless␣(lc($protocol)␣eq␣'http'␣␣&&␣$port␣==␣80)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣or␣(lc($protocol)␣eq␣'https'␣&&␣$port␣==␣443);

␣␣␣␣␣␣␣␣return␣$url␣if␣$base;

␣␣␣␣␣␣␣␣$url␣.=␣$uri;
␣␣␣␣}␣elsif␣($relative)␣{
	($url)␣=␣$uri␣=~␣m!([^/]+)$!;
␣␣␣␣}␣elsif␣($absolute)␣{
	$url␣=␣$uri;
␣␣␣␣}

␣␣␣␣$url␣.=␣$path␣␣␣␣␣␣␣␣␣if␣$path_info␣and␣defined␣$path;
␣␣␣␣$url␣.=␣"?$query_str"␣if␣$query␣␣␣␣␣and␣$query_str␣ne␣'';
␣␣␣␣$url␣||=␣'';
␣␣␣␣$url␣=~␣s/([^a-zA-Z0-9_.%;&?\/\\:+=~-])/sprintf("%%%02X",ord($1))/eg;
␣␣␣␣return␣$url;
}

END_OF_FUNC

####␣Method:␣cookie
#␣Set␣or␣read␣a␣cookie␣from␣the␣specified␣name.
#␣Cookie␣can␣then␣be␣passed␣to␣header().
#␣Usual␣rules␣apply␣to␣the␣stickiness␣of␣-value.
#␣␣Parameters:
#␣␣␣-name␣->␣name␣for␣this␣cookie␣(optional)
#␣␣␣-value␣->␣value␣of␣this␣cookie␣(scalar,␣array␣or␣hash)␣
#␣␣␣-path␣->␣paths␣for␣which␣this␣cookie␣is␣valid␣(optional)
#␣␣␣-domain␣->␣internet␣domain␣in␣which␣this␣cookie␣is␣valid␣(optional)
#␣␣␣-secure␣->␣if␣true,␣cookie␣only␣passed␣through␣secure␣channel␣(optional)
#␣␣␣-expires␣->␣expiry␣date␣in␣format␣Wdy,␣DD-Mon-YYYY␣HH:MM:SS␣GMT␣(optional)
####
'cookie'␣=>␣<<'END_OF_FUNC',
sub␣cookie␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my($name,$value,$path,$domain,$secure,$expires,$httponly)␣=
	rearrange([NAME,[VALUE,VALUES],PATH,DOMAIN,SECURE,EXPIRES,HTTPONLY],@p);

␣␣␣␣require␣CGI::Cookie;

␣␣␣␣#␣if␣no␣value␣is␣supplied,␣then␣we␣retrieve␣the
␣␣␣␣#␣value␣of␣the␣cookie,␣if␣any.␣␣For␣efficiency,␣we␣cache␣the␣parsed
␣␣␣␣#␣cookies␣in␣our␣state␣variables.
␣␣␣␣unless␣(␣defined($value)␣)␣{
	$self->{'.cookies'}␣=␣CGI::Cookie->fetch;
	
	#␣If␣no␣name␣is␣supplied,␣then␣retrieve␣the␣names␣of␣all␣our␣cookies.
	return␣()␣unless␣$self->{'.cookies'};
	return␣keys␣%{$self->{'.cookies'}}␣unless␣$name;
	return␣()␣unless␣$self->{'.cookies'}->{$name};
	return␣$self->{'.cookies'}->{$name}->value␣if␣defined($name)␣&&␣$name␣ne␣'';
␣␣␣␣}

␣␣␣␣#␣If␣we␣get␣here,␣we're␣creating␣a␣new␣cookie
␣␣␣␣return␣undef␣unless␣defined($name)␣&&␣$name␣ne␣'';	#␣this␣is␣an␣error

␣␣␣␣my␣@param;
␣␣␣␣push(@param,'-name'=>$name);
␣␣␣␣push(@param,'-value'=>$value);
␣␣␣␣push(@param,'-domain'=>$domain)␣if␣$domain;
␣␣␣␣push(@param,'-path'=>$path)␣if␣$path;
␣␣␣␣push(@param,'-expires'=>$expires)␣if␣$expires;
␣␣␣␣push(@param,'-secure'=>$secure)␣if␣$secure;
␣␣␣␣push(@param,'-httponly'=>$httponly)␣if␣$httponly;

␣␣␣␣return␣CGI::Cookie->new(@param);
}
END_OF_FUNC

'parse_keywordlist'␣=>␣<<'END_OF_FUNC',
sub␣parse_keywordlist␣{
␣␣␣␣my($self,$tosplit)␣=␣@_;
␣␣␣␣$tosplit␣=␣unescape($tosplit);␣#␣unescape␣the␣keywords
␣␣␣␣$tosplit=~tr/+/␣/;␣␣␣␣␣␣␣␣␣␣#␣pluses␣to␣spaces
␣␣␣␣my(@keywords)␣=␣split(/\s+/,$tosplit);
␣␣␣␣return␣@keywords;
}
END_OF_FUNC

'param_fetch'␣=>␣<<'END_OF_FUNC',
sub␣param_fetch␣{
␣␣␣␣my($self,@p)␣=␣self_or_default(@_);
␣␣␣␣my($name)␣=␣rearrange([NAME],@p);
␣␣␣␣unless␣(exists($self->{param}{$name}))␣{
	$self->add_parameter($name);
	$self->{param}{$name}␣=␣[];
␣␣␣␣}
␣␣␣␣
␣␣␣␣return␣$self->{param}{$name};
}
END_OF_FUNC

###############################################
#␣OTHER␣INFORMATION␣PROVIDED␣BY␣THE␣ENVIRONMENT
###############################################

####␣Method:␣path_info
#␣Return␣the␣extra␣virtual␣path␣information␣provided
#␣after␣the␣URL␣(if␣any)
####
'path_info'␣=>␣<<'END_OF_FUNC',
sub␣path_info␣{
␣␣␣␣my␣($self,$info)␣=␣self_or_default(@_);
␣␣␣␣if␣(defined($info))␣{
	$info␣=␣"/$info"␣if␣$info␣ne␣''␣&&␣␣substr($info,0,1)␣ne␣'/';
	$self->{'.path_info'}␣=␣$info;
␣␣␣␣}␣elsif␣(!␣defined($self->{'.path_info'})␣)␣{
␣␣␣␣␣␣␣␣my␣(undef,$path_info)␣=␣$self->_name_and_path_from_env;
	$self->{'.path_info'}␣=␣$path_info␣||␣'';
␣␣␣␣}
␣␣␣␣return␣$self->{'.path_info'};
}
END_OF_FUNC

#␣This␣function␣returns␣a␣potentially␣modified␣version␣of␣SCRIPT_NAME
#␣and␣PATH_INFO.␣Some␣HTTP␣servers␣do␣sanitise␣the␣paths␣in␣those
#␣variables.␣It␣is␣the␣case␣of␣at␣least␣Apache␣2.␣If␣for␣instance␣the
#␣user␣requests:␣/path/./to/script.cgi/x//y/z/../x?y,␣Apache␣will␣set:
#␣REQUEST_URI=/path/./to/script.cgi/x//y/z/../x?y
#␣SCRIPT_NAME=/path/to/env.cgi
#␣PATH_INFO=/x/y/x
#
#␣This␣is␣all␣fine␣except␣that␣some␣bogus␣CGI␣scripts␣expect
#␣PATH_INFO=/http://foo␣when␣the␣user␣requests
#␣http://xxx/script.cgi/http://foo
#
#␣Old␣versions␣of␣this␣module␣used␣to␣accomodate␣with␣those␣scripts,␣so
#␣this␣is␣why␣we␣do␣this␣here␣to␣keep␣those␣scripts␣backward␣compatible.
#␣Basically,␣we␣accomodate␣with␣those␣scripts␣but␣within␣limits,␣that␣is
#␣we␣only␣try␣to␣preserve␣the␣number␣of␣/␣that␣were␣provided␣by␣the␣user
#␣if␣$REQUEST_URI␣and␣"$SCRIPT_NAME$PATH_INFO"␣only␣differ␣by␣the␣number
#␣of␣consecutive␣/.
#
#␣So␣for␣instance,␣in:␣http://foo/x//y/script.cgi/a//b,␣we'll␣return␣a
#␣script_name␣of␣/x//y/script.cgi␣and␣a␣path_info␣of␣/a//b,␣but␣in:
#␣http://foo/./x//z/script.cgi/a/../b//c,␣we'll␣return␣the␣versions
#␣possibly␣sanitised␣by␣the␣HTTP␣server,␣so␣in␣the␣case␣of␣Apache␣2:
#␣script_name␣==␣/foo/x/z/script.cgi␣and␣path_info␣==␣/b/c.
#
#␣Future␣versions␣of␣this␣module␣may␣no␣longer␣do␣that,␣so␣one␣should
#␣avoid␣relying␣on␣the␣browser,␣proxy,␣server,␣and␣CGI.pm␣preserving␣the
#␣number␣of␣consecutive␣slashes␣as␣no␣guarantee␣can␣be␣made␣there.
'_name_and_path_from_env'␣=>␣<<'END_OF_FUNC',
sub␣_name_and_path_from_env␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$script_name␣=␣$ENV{SCRIPT_NAME}␣␣||␣'';
␣␣␣␣my␣$path_info␣␣␣=␣$ENV{PATH_INFO}␣␣␣␣||␣'';
␣␣␣␣my␣$uri␣␣␣␣␣␣␣␣␣=␣$self->request_uri␣||␣'';

␣␣␣␣$uri␣=~␣s/\?.*//s;
␣␣␣␣$uri␣=␣unescape($uri);

␣␣␣␣if␣($uri␣ne␣"$script_name$path_info")␣{
␣␣␣␣␣␣␣␣my␣$script_name_pattern␣=␣quotemeta($script_name);
␣␣␣␣␣␣␣␣my␣$path_info_pattern␣=␣quotemeta($path_info);
␣␣␣␣␣␣␣␣$script_name_pattern␣=~␣s{(?:\\/)+}{/+}g;
␣␣␣␣␣␣␣␣$path_info_pattern␣=~␣s{(?:\\/)+}{/+}g;

␣␣␣␣␣␣␣␣if␣($uri␣=~␣/^($script_name_pattern)($path_info_pattern)$/s)␣{
␣␣␣␣␣␣␣␣␣␣␣␣#␣REQUEST_URI␣and␣SCRIPT_NAME␣.␣PATH_INFO␣only␣differ␣by␣the
␣␣␣␣␣␣␣␣␣␣␣␣#␣numer␣of␣consecutive␣slashes,␣so␣we␣can␣extract␣the␣info␣from
␣␣␣␣␣␣␣␣␣␣␣␣#␣REQUEST_URI:
␣␣␣␣␣␣␣␣␣␣␣␣($script_name,␣$path_info)␣=␣($1,␣$2);
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣return␣($script_name,$path_info);
}
END_OF_FUNC


####␣Method:␣request_method
#␣Returns␣'POST',␣'GET',␣'PUT'␣or␣'HEAD'
####
'request_method'␣=>␣<<'END_OF_FUNC',
sub␣request_method␣{
␣␣␣␣return␣(defined␣$ENV{'REQUEST_METHOD'})␣?␣$ENV{'REQUEST_METHOD'}␣:␣undef;
}
END_OF_FUNC

####␣Method:␣content_type
#␣Returns␣the␣content_type␣string
####
'content_type'␣=>␣<<'END_OF_FUNC',
sub␣content_type␣{
␣␣␣␣return␣(defined␣$ENV{'CONTENT_TYPE'})␣?␣$ENV{'CONTENT_TYPE'}␣:␣undef;
}
END_OF_FUNC

####␣Method:␣path_translated
#␣Return␣the␣physical␣path␣information␣provided
#␣by␣the␣URL␣(if␣any)
####
'path_translated'␣=>␣<<'END_OF_FUNC',
sub␣path_translated␣{
␣␣␣␣return␣(defined␣$ENV{'PATH_TRANSLATED'})␣?␣$ENV{'PATH_TRANSLATED'}␣:␣undef;
}
END_OF_FUNC


####␣Method:␣request_uri
#␣Return␣the␣literal␣request␣URI
####
'request_uri'␣=>␣<<'END_OF_FUNC',
sub␣request_uri␣{
␣␣␣␣return␣(defined␣$ENV{'REQUEST_URI'})␣?␣$ENV{'REQUEST_URI'}␣:␣undef;
}
END_OF_FUNC


####␣Method:␣query_string
#␣Synthesize␣a␣query␣string␣from␣our␣current
#␣parameters
####
'query_string'␣=>␣<<'END_OF_FUNC',
sub␣query_string␣{
␣␣␣␣my($self)␣=␣self_or_default(@_);
␣␣␣␣my($param,$value,@pairs);
␣␣␣␣for␣$param␣($self->param)␣{
␣␣␣␣␣␣␣my($eparam)␣=␣escape($param);
␣␣␣␣␣␣␣for␣$value␣($self->param($param))␣{
␣␣␣␣␣␣␣␣␣␣␣$value␣=␣escape($value);
␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣defined␣$value;
␣␣␣␣␣␣␣␣␣␣␣push(@pairs,"$eparam=$value");
␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣for␣(keys␣%{$self->{'.fieldnames'}})␣{
␣␣␣␣␣␣push(@pairs,".cgifields=".escape("$_"));
␣␣␣␣}
␣␣␣␣return␣join($USE_PARAM_SEMICOLONS␣?␣';'␣:␣'&',@pairs);
}
END_OF_FUNC


####␣Method:␣accept
#␣Without␣parameters,␣returns␣an␣array␣of␣the
#␣MIME␣types␣the␣browser␣accepts.
#␣With␣a␣single␣parameter␣equal␣to␣a␣MIME
#␣type,␣will␣return␣undef␣if␣the␣browser␣won't
#␣accept␣it,␣1␣if␣the␣browser␣accepts␣it␣but
#␣doesn't␣give␣a␣preference,␣or␣a␣floating␣point
#␣value␣between␣0.0␣and␣1.0␣if␣the␣browser
#␣declares␣a␣quantitative␣score␣for␣it.
#␣This␣handles␣MIME␣type␣globs␣correctly.
####
'Accept'␣=>␣<<'END_OF_FUNC',
sub␣Accept␣{
␣␣␣␣my($self,$search)␣=␣self_or_CGI(@_);
␣␣␣␣my(%prefs,$type,$pref,$pat);
␣␣␣␣
␣␣␣␣my(@accept)␣=␣defined␣$self->http('accept')␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣split(',',$self->http('accept'))
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣();

␣␣␣␣for␣(@accept)␣{
	($pref)␣=␣/q=(\d\.\d+|\d+)/;
	($type)␣=␣m#(\S+/[^;]+)#;
	next␣unless␣$type;
	$prefs{$type}=$pref␣||␣1;
␣␣␣␣}

␣␣␣␣return␣keys␣%prefs␣unless␣$search;
␣␣␣␣
␣␣␣␣#␣if␣a␣search␣type␣is␣provided,␣we␣may␣need␣to
␣␣␣␣#␣perform␣a␣pattern␣matching␣operation.
␣␣␣␣#␣The␣MIME␣types␣use␣a␣glob␣mechanism,␣which
␣␣␣␣#␣is␣easily␣translated␣into␣a␣perl␣pattern␣match

␣␣␣␣#␣First␣return␣the␣preference␣for␣directly␣supported
␣␣␣␣#␣types:
␣␣␣␣return␣$prefs{$search}␣if␣$prefs{$search};

␣␣␣␣#␣Didn't␣get␣it,␣so␣try␣pattern␣matching.
␣␣␣␣for␣(keys␣%prefs)␣{
	next␣unless␣/\*/;␣␣␣␣␣␣␣#␣not␣a␣pattern␣match
	($pat␣=␣$_)␣=~␣s/([^\w*])/\\$1/g;␣#␣escape␣meta␣characters
	$pat␣=~␣s/\*/.*/g;␣#␣turn␣it␣into␣a␣pattern
	return␣$prefs{$_}␣if␣$search=~/$pat/;
␣␣␣␣}
}
END_OF_FUNC


####␣Method:␣user_agent
#␣If␣called␣with␣no␣parameters,␣returns␣the␣user␣agent.
#␣If␣called␣with␣one␣parameter,␣does␣a␣pattern␣match␣(case
#␣insensitive)␣on␣the␣user␣agent.
####
'user_agent'␣=>␣<<'END_OF_FUNC',
sub␣user_agent␣{
␣␣␣␣my($self,$match)=self_or_CGI(@_);
␣␣␣␣my␣$user_agent␣=␣$self->http('user_agent');
␣␣␣␣return␣$user_agent␣unless␣$match␣&&␣$user_agent;
␣␣␣␣return␣$user_agent␣=~␣/$match/i;
}
END_OF_FUNC


####␣Method:␣raw_cookie
#␣Returns␣the␣magic␣cookies␣for␣the␣session.
#␣The␣cookies␣are␣not␣parsed␣or␣altered␣in␣any␣way,␣i.e.
#␣cookies␣are␣returned␣exactly␣as␣given␣in␣the␣HTTP
#␣headers.␣␣If␣a␣cookie␣name␣is␣given,␣only␣that␣cookie's
#␣value␣is␣returned,␣otherwise␣the␣entire␣raw␣cookie
#␣is␣returned.
####
'raw_cookie'␣=>␣<<'END_OF_FUNC',
sub␣raw_cookie␣{
␣␣␣␣my($self,$key)␣=␣self_or_CGI(@_);

␣␣␣␣require␣CGI::Cookie;

␣␣␣␣if␣(defined($key))␣{
	$self->{'.raw_cookies'}␣=␣CGI::Cookie->raw_fetch
	␣␣␣␣unless␣$self->{'.raw_cookies'};

	return␣()␣unless␣$self->{'.raw_cookies'};
	return␣()␣unless␣$self->{'.raw_cookies'}->{$key};
	return␣$self->{'.raw_cookies'}->{$key};
␣␣␣␣}
␣␣␣␣return␣$self->http('cookie')␣||␣$ENV{'COOKIE'}␣||␣'';
}
END_OF_FUNC

####␣Method:␣virtual_host
#␣Return␣the␣name␣of␣the␣virtual_host,␣which
#␣is␣not␣always␣the␣same␣as␣the␣server
######
'virtual_host'␣=>␣<<'END_OF_FUNC',
sub␣virtual_host␣{
␣␣␣␣my␣$vh␣=␣http('x_forwarded_host')␣||␣http('host')␣||␣server_name();
␣␣␣␣$vh␣=~␣s/:\d+$//;		#␣get␣rid␣of␣port␣number
␣␣␣␣return␣$vh;
}
END_OF_FUNC

####␣Method:␣remote_host
#␣Return␣the␣name␣of␣the␣remote␣host,␣or␣its␣IP
#␣address␣if␣unavailable.␣␣If␣this␣variable␣isn't
#␣defined,␣it␣returns␣"localhost"␣for␣debugging
#␣purposes.
####
'remote_host'␣=>␣<<'END_OF_FUNC',
sub␣remote_host␣{
␣␣␣␣return␣$ENV{'REMOTE_HOST'}␣||␣$ENV{'REMOTE_ADDR'}␣
␣␣␣␣||␣'localhost';
}
END_OF_FUNC


####␣Method:␣remote_addr
#␣Return␣the␣IP␣addr␣of␣the␣remote␣host.
####
'remote_addr'␣=>␣<<'END_OF_FUNC',
sub␣remote_addr␣{
␣␣␣␣return␣$ENV{'REMOTE_ADDR'}␣||␣'127.0.0.1';
}
END_OF_FUNC


####␣Method:␣script_name
#␣Return␣the␣partial␣URL␣to␣this␣script␣for
#␣self-referencing␣scripts.␣␣Also␣see
#␣self_url(),␣which␣returns␣a␣URL␣with␣all␣state␣information
#␣preserved.
####
'script_name'␣=>␣<<'END_OF_FUNC',
sub␣script_name␣{
␣␣␣␣my␣($self,@p)␣=␣self_or_default(@_);
␣␣␣␣if␣(@p)␣{
␣␣␣␣␣␣␣␣$self->{'.script_name'}␣=␣shift␣@p;
␣␣␣␣}␣elsif␣(!exists␣$self->{'.script_name'})␣{
␣␣␣␣␣␣␣␣my␣($script_name,$path_info)␣=␣$self->_name_and_path_from_env();
␣␣␣␣␣␣␣␣$self->{'.script_name'}␣=␣$script_name;
␣␣␣␣}
␣␣␣␣return␣$self->{'.script_name'};
}
END_OF_FUNC


####␣Method:␣referer
#␣Return␣the␣HTTP_REFERER:␣useful␣for␣generating
#␣a␣GO␣BACK␣button.
####
'referer'␣=>␣<<'END_OF_FUNC',
sub␣referer␣{
␣␣␣␣my($self)␣=␣self_or_CGI(@_);
␣␣␣␣return␣$self->http('referer');
}
END_OF_FUNC


####␣Method:␣server_name
#␣Return␣the␣name␣of␣the␣server
####
'server_name'␣=>␣<<'END_OF_FUNC',
sub␣server_name␣{
␣␣␣␣return␣$ENV{'SERVER_NAME'}␣||␣'localhost';
}
END_OF_FUNC

####␣Method:␣server_software
#␣Return␣the␣name␣of␣the␣server␣software
####
'server_software'␣=>␣<<'END_OF_FUNC',
sub␣server_software␣{
␣␣␣␣return␣$ENV{'SERVER_SOFTWARE'}␣||␣'cmdline';
}
END_OF_FUNC

####␣Method:␣virtual_port
#␣Return␣the␣server␣port,␣taking␣virtual␣hosts␣into␣account
####
'virtual_port'␣=>␣<<'END_OF_FUNC',
sub␣virtual_port␣{
␣␣␣␣my($self)␣=␣self_or_default(@_);
␣␣␣␣my␣$vh␣=␣$self->http('x_forwarded_host')␣||␣$self->http('host');
␣␣␣␣my␣$protocol␣=␣$self->protocol;
␣␣␣␣if␣($vh)␣{
␣␣␣␣␣␣␣␣return␣($vh␣=~␣/:(\d+)$/)[0]␣||␣($protocol␣eq␣'https'␣?␣443␣:␣80);
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣return␣$self->server_port();
␣␣␣␣}
}
END_OF_FUNC

####␣Method:␣server_port
#␣Return␣the␣tcp/ip␣port␣the␣server␣is␣running␣on
####
'server_port'␣=>␣<<'END_OF_FUNC',
sub␣server_port␣{
␣␣␣␣return␣$ENV{'SERVER_PORT'}␣||␣80;␣#␣for␣debugging
}
END_OF_FUNC

####␣Method:␣server_protocol
#␣Return␣the␣protocol␣(usually␣HTTP/1.0)
####
'server_protocol'␣=>␣<<'END_OF_FUNC',
sub␣server_protocol␣{
␣␣␣␣return␣$ENV{'SERVER_PROTOCOL'}␣||␣'HTTP/1.0';␣#␣for␣debugging
}
END_OF_FUNC

####␣Method:␣http
#␣Return␣the␣value␣of␣an␣HTTP␣variable,␣or
#␣the␣list␣of␣variables␣if␣none␣provided
####
'http'␣=>␣<<'END_OF_FUNC',
sub␣http␣{
␣␣␣␣my␣($self,$parameter)␣=␣self_or_CGI(@_);
␣␣␣␣if␣(␣defined($parameter)␣)␣{
␣␣␣␣␣␣␣␣$parameter␣=~␣tr/-a-z/_A-Z/;
␣␣␣␣␣␣␣␣if␣(␣$parameter␣=~␣/^HTTP(?:_|$)/␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣return␣$ENV{$parameter};
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣return␣$ENV{"HTTP_$parameter"};
␣␣␣␣}
␣␣␣␣return␣grep␣{␣/^HTTP(?:_|$)/␣}␣keys␣%ENV;
}
END_OF_FUNC

####␣Method:␣https
#␣Return␣the␣value␣of␣HTTPS,␣or
#␣the␣value␣of␣an␣HTTPS␣variable,␣or
#␣the␣list␣of␣variables
####
'https'␣=>␣<<'END_OF_FUNC',
sub␣https␣{
␣␣␣␣my␣($self,$parameter)␣=␣self_or_CGI(@_);
␣␣␣␣if␣(␣defined($parameter)␣)␣{
␣␣␣␣␣␣␣␣$parameter␣=~␣tr/-a-z/_A-Z/;
␣␣␣␣␣␣␣␣if␣(␣$parameter␣=~␣/^HTTPS(?:_|$)/␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣return␣$ENV{$parameter};
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣return␣$ENV{"HTTPS_$parameter"};
␣␣␣␣}
␣␣␣␣return␣wantarray
␣␣␣␣␣␣␣␣?␣grep␣{␣/^HTTPS(?:_|$)/␣}␣keys␣%ENV
␣␣␣␣␣␣␣␣:␣$ENV{'HTTPS'};
}
END_OF_FUNC

####␣Method:␣protocol
#␣Return␣the␣protocol␣(http␣or␣https␣currently)
####
'protocol'␣=>␣<<'END_OF_FUNC',
sub␣protocol␣{
␣␣␣␣local($^W)=0;
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣return␣'https'␣if␣uc($self->https())␣eq␣'ON';␣
␣␣␣␣return␣'https'␣if␣$self->server_port␣==␣443;
␣␣␣␣my␣$prot␣=␣$self->server_protocol;
␣␣␣␣my($protocol,$version)␣=␣split('/',$prot);
␣␣␣␣return␣"\L$protocol\E";
}
END_OF_FUNC

####␣Method:␣remote_ident
#␣Return␣the␣identity␣of␣the␣remote␣user
#␣(but␣only␣if␣his␣host␣is␣running␣identd)
####
'remote_ident'␣=>␣<<'END_OF_FUNC',
sub␣remote_ident␣{
␣␣␣␣return␣(defined␣$ENV{'REMOTE_IDENT'})␣?␣$ENV{'REMOTE_IDENT'}␣:␣undef;
}
END_OF_FUNC


####␣Method:␣auth_type
#␣Return␣the␣type␣of␣use␣verification/authorization␣in␣use,␣if␣any.
####
'auth_type'␣=>␣<<'END_OF_FUNC',
sub␣auth_type␣{
␣␣␣␣return␣(defined␣$ENV{'AUTH_TYPE'})␣?␣$ENV{'AUTH_TYPE'}␣:␣undef;
}
END_OF_FUNC


####␣Method:␣remote_user
#␣Return␣the␣authorization␣name␣used␣for␣user
#␣verification.
####
'remote_user'␣=>␣<<'END_OF_FUNC',
sub␣remote_user␣{
␣␣␣␣return␣(defined␣$ENV{'REMOTE_USER'})␣?␣$ENV{'REMOTE_USER'}␣:␣undef;
}
END_OF_FUNC


####␣Method:␣user_name
#␣Try␣to␣return␣the␣remote␣user's␣name␣by␣hook␣or␣by
#␣crook
####
'user_name'␣=>␣<<'END_OF_FUNC',
sub␣user_name␣{
␣␣␣␣my␣($self)␣=␣self_or_CGI(@_);
␣␣␣␣return␣$self->http('from')␣||␣$ENV{'REMOTE_IDENT'}␣||␣$ENV{'REMOTE_USER'};
}
END_OF_FUNC

####␣Method:␣nosticky
#␣Set␣or␣return␣the␣NOSTICKY␣global␣flag
####
'nosticky'␣=>␣<<'END_OF_FUNC',
sub␣nosticky␣{
␣␣␣␣my␣($self,$param)␣=␣self_or_CGI(@_);
␣␣␣␣$CGI::NOSTICKY␣=␣$param␣if␣defined($param);
␣␣␣␣return␣$CGI::NOSTICKY;
}
END_OF_FUNC

####␣Method:␣nph
#␣Set␣or␣return␣the␣NPH␣global␣flag
####
'nph'␣=>␣<<'END_OF_FUNC',
sub␣nph␣{
␣␣␣␣my␣($self,$param)␣=␣self_or_CGI(@_);
␣␣␣␣$CGI::NPH␣=␣$param␣if␣defined($param);
␣␣␣␣return␣$CGI::NPH;
}
END_OF_FUNC

####␣Method:␣private_tempfiles
#␣Set␣or␣return␣the␣private_tempfiles␣global␣flag
####
'private_tempfiles'␣=>␣<<'END_OF_FUNC',
sub␣private_tempfiles␣{
␣␣␣␣my␣($self,$param)␣=␣self_or_CGI(@_);
␣␣␣␣$CGI::PRIVATE_TEMPFILES␣=␣$param␣if␣defined($param);
␣␣␣␣return␣$CGI::PRIVATE_TEMPFILES;
}
END_OF_FUNC
####␣Method:␣close_upload_files
#␣Set␣or␣return␣the␣close_upload_files␣global␣flag
####
'close_upload_files'␣=>␣<<'END_OF_FUNC',
sub␣close_upload_files␣{
␣␣␣␣my␣($self,$param)␣=␣self_or_CGI(@_);
␣␣␣␣$CGI::CLOSE_UPLOAD_FILES␣=␣$param␣if␣defined($param);
␣␣␣␣return␣$CGI::CLOSE_UPLOAD_FILES;
}
END_OF_FUNC


####␣Method:␣default_dtd
#␣Set␣or␣return␣the␣default_dtd␣global
####
'default_dtd'␣=>␣<<'END_OF_FUNC',
sub␣default_dtd␣{
␣␣␣␣my␣($self,$param,$param2)␣=␣self_or_CGI(@_);
␣␣␣␣if␣(defined␣$param2␣&&␣defined␣$param)␣{
␣␣␣␣␣␣␣␣$CGI::DEFAULT_DTD␣=␣[␣$param,␣$param2␣];
␣␣␣␣}␣elsif␣(defined␣$param)␣{
␣␣␣␣␣␣␣␣$CGI::DEFAULT_DTD␣=␣$param;
␣␣␣␣}
␣␣␣␣return␣$CGI::DEFAULT_DTD;
}
END_OF_FUNC

#␣--------------␣really␣private␣subroutines␣-----------------
'_maybe_escapeHTML'␣=>␣<<'END_OF_FUNC',
sub␣_maybe_escapeHTML␣{
␣␣␣␣#␣hack␣to␣work␣around␣␣earlier␣hacks
␣␣␣␣push␣@_,$_[0]␣if␣@_==1␣&&␣$_[0]␣eq␣'CGI';
␣␣␣␣my␣($self,$toencode,$newlinestoo)␣=␣CGI::self_or_default(@_);
␣␣␣␣return␣undef␣unless␣defined($toencode);
␣␣␣␣return␣$toencode␣if␣ref($self)␣&&␣!$self->{'escape'};
␣␣␣␣return␣$self->escapeHTML($toencode,␣$newlinestoo);
}
END_OF_FUNC

'previous_or_default'␣=>␣<<'END_OF_FUNC',
sub␣previous_or_default␣{
␣␣␣␣my($self,$name,$defaults,$override)␣=␣@_;
␣␣␣␣my(%selected);

␣␣␣␣if␣(!$override␣&&␣($self->{'.fieldnames'}->{$name}␣||␣
		␣␣␣␣␣␣␣defined($self->param($name))␣)␣)␣{
	$selected{$_}++␣for␣$self->param($name);
␣␣␣␣}␣elsif␣(defined($defaults)␣&&␣ref($defaults)␣&&␣
	␣␣␣␣␣(ref($defaults)␣eq␣'ARRAY'))␣{
	$selected{$_}++␣for␣@{$defaults};
␣␣␣␣}␣else␣{
	$selected{$defaults}++␣if␣defined($defaults);
␣␣␣␣}

␣␣␣␣return␣%selected;
}
END_OF_FUNC

'register_parameter'␣=>␣<<'END_OF_FUNC',
sub␣register_parameter␣{
␣␣␣␣my($self,$param)␣=␣@_;
␣␣␣␣$self->{'.parametersToAdd'}->{$param}++;
}
END_OF_FUNC

'get_fields'␣=>␣<<'END_OF_FUNC',
sub␣get_fields␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣return␣$self->CGI::hidden('-name'=>'.cgifields',
			␣␣␣␣␣␣'-values'=>[keys␣%{$self->{'.parametersToAdd'}}],
			␣␣␣␣␣␣'-override'=>1);
}
END_OF_FUNC

'read_from_cmdline'␣=>␣<<'END_OF_FUNC',
sub␣read_from_cmdline␣{
␣␣␣␣my($input,@words);
␣␣␣␣my($query_string);
␣␣␣␣my($subpath);
␣␣␣␣if␣($DEBUG␣&&␣@ARGV)␣{
	@words␣=␣@ARGV;
␣␣␣␣}␣elsif␣($DEBUG␣>␣1)␣{
	require␣"shellwords.pl";
	print␣STDERR␣"(offline␣mode:␣enter␣name=value␣pairs␣on␣standard␣input;␣press␣^D␣or␣^Z␣when␣done)\n";
	chomp(@lines␣=␣<STDIN>);␣#␣remove␣newlines
	$input␣=␣join("␣",@lines);
	@words␣=␣&shellwords($input);␣␣␣␣
␣␣␣␣}
␣␣␣␣for␣(@words)␣{
	s/\\=/%3D/g;
	s/\\&/%26/g;	␣␣␣␣
␣␣␣␣}

␣␣␣␣if␣("@words"=~/=/)␣{
	$query_string␣=␣join('&',@words);
␣␣␣␣}␣else␣{
	$query_string␣=␣join('+',@words);
␣␣␣␣}
␣␣␣␣if␣($query_string␣=~␣/^(.*?)\?(.*)$/)
␣␣␣␣{
␣␣␣␣␣␣␣␣$query_string␣=␣$2;
␣␣␣␣␣␣␣␣$subpath␣=␣$1;
␣␣␣␣}
␣␣␣␣return␣{␣'query_string'␣=>␣$query_string,␣'subpath'␣=>␣$subpath␣};
}
END_OF_FUNC

#####
#␣subroutine:␣read_multipart
#
#␣Read␣multipart␣data␣and␣store␣it␣into␣our␣parameters.
#␣An␣interesting␣feature␣is␣that␣if␣any␣of␣the␣parts␣is␣a␣file,␣we
#␣create␣a␣temporary␣file␣and␣open␣up␣a␣filehandle␣on␣it␣so␣that␣the
#␣caller␣can␣read␣from␣it␣if␣necessary.
#####
'read_multipart'␣=>␣<<'END_OF_FUNC',
sub␣read_multipart␣{
␣␣␣␣my($self,$boundary,$length)␣=␣@_;
␣␣␣␣my($buffer)␣=␣$self->new_MultipartBuffer($boundary,$length);
␣␣␣␣return␣unless␣$buffer;
␣␣␣␣my(%header,$body);
␣␣␣␣my␣$filenumber␣=␣0;
␣␣␣␣while␣(!$buffer->eof)␣{
	%header␣=␣$buffer->readHeader;

	unless␣(%header)␣{
	␣␣␣␣$self->cgi_error("400␣Bad␣request␣(malformed␣multipart␣POST)");
	␣␣␣␣return;
	}

	$header{'Content-Disposition'}␣||=␣'';␣#␣quench␣uninit␣variable␣warning

	my($param)=␣$header{'Content-Disposition'}=~/[\s;]name="([^"]*)"/;
␣␣␣␣␣␣␣␣$param␣.=␣$TAINTED;

␣␣␣␣␣␣␣␣#␣See␣RFC␣1867,␣2183,␣2045
␣␣␣␣␣␣␣␣#␣NB:␣File␣content␣will␣be␣loaded␣into␣memory␣should
␣␣␣␣␣␣␣␣#␣content-disposition␣parsing␣fail.
␣␣␣␣␣␣␣␣my␣($filename)␣=␣$header{'Content-Disposition'}
	␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=~/␣filename=(("[^"]*")|([a-z\d!\#'\*\+,\.^_\`\{\}\|\~]*))/i;

	$filename␣||=␣'';␣#␣quench␣uninit␣variable␣warning

␣␣␣␣␣␣␣␣$filename␣=~␣s/^"([^"]*)"$/$1/;
	#␣Test␣for␣Opera's␣multiple␣upload␣feature
	my($multipart)␣=␣(␣defined(␣$header{'Content-Type'}␣)␣&&
		$header{'Content-Type'}␣=~␣/multipart\/mixed/␣)␣?
		1␣:␣0;

	#␣add␣this␣parameter␣to␣our␣list
	$self->add_parameter($param);

	#␣If␣no␣filename␣specified,␣then␣just␣read␣the␣data␣and␣assign␣it
	#␣to␣our␣parameter␣list.
	if␣(␣(␣!defined($filename)␣||␣$filename␣eq␣''␣)␣&&␣!$multipart␣)␣{
	␣␣␣␣my($value)␣=␣$buffer->readBody;
␣␣␣␣␣␣␣␣␣␣␣␣$value␣.=␣$TAINTED;
	␣␣␣␣push(@{$self->{param}{$param}},$value);
	␣␣␣␣next;
	}

	my␣($tmpfile,$tmp,$filehandle);
␣␣␣␣␣␣UPLOADS:␣{
	␣␣#␣If␣we␣get␣here,␣then␣we␣are␣dealing␣with␣a␣potentially␣large
	␣␣#␣uploaded␣form.␣␣Save␣the␣data␣to␣a␣temporary␣file,␣then␣open
	␣␣#␣the␣file␣for␣reading.

	␣␣#␣skip␣the␣file␣if␣uploads␣disabled
	␣␣if␣($DISABLE_UPLOADS)␣{
	␣␣␣␣␣␣while␣(defined($data␣=␣$buffer->read))␣{␣}
	␣␣␣␣␣␣last␣UPLOADS;
	␣␣}

	␣␣#␣set␣the␣filename␣to␣some␣recognizable␣value
␣␣␣␣␣␣␣␣␣␣if␣(␣(␣!defined($filename)␣||␣$filename␣eq␣''␣)␣&&␣$multipart␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$filename␣=␣"multipart/mixed";
␣␣␣␣␣␣␣␣␣␣}

	␣␣#␣choose␣a␣relatively␣unpredictable␣tmpfile␣sequence␣number
␣␣␣␣␣␣␣␣␣␣my␣$seqno␣=␣unpack("%16C*",join('',localtime,grep␣{defined␣$_}␣values␣%ENV));
␣␣␣␣␣␣␣␣␣␣for␣(my␣$cnt=10;$cnt>0;$cnt--)␣{
	␣␣␣␣next␣unless␣$tmpfile␣=␣CGITempFile->new($seqno);
	␣␣␣␣$tmp␣=␣$tmpfile->as_string;
	␣␣␣␣last␣if␣defined($filehandle␣=␣Fh->new($filename,$tmp,$PRIVATE_TEMPFILES));
␣␣␣␣␣␣␣␣␣␣␣␣$seqno␣+=␣int␣rand(100);
␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣die␣"CGI␣open␣of␣tmpfile:␣$!\n"␣unless␣defined␣$filehandle;
	␣␣$CGI::DefaultClass->binmode($filehandle)␣if␣$CGI::needs_binmode␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣&&␣defined␣fileno($filehandle);

	␣␣#␣if␣this␣is␣an␣multipart/mixed␣attachment,␣save␣the␣header
	␣␣#␣together␣with␣the␣body␣for␣later␣parsing␣with␣an␣external
	␣␣#␣MIME␣parser␣module
	␣␣if␣(␣$multipart␣)␣{
	␣␣␣␣␣␣for␣(␣keys␣%header␣)␣{
		␣␣print␣$filehandle␣"$_:␣$header{$_}${CRLF}";
	␣␣␣␣␣␣}
	␣␣␣␣␣␣print␣$filehandle␣"${CRLF}";
	␣␣}

	␣␣my␣($data);
	␣␣local($\)␣=␣'';
␣␣␣␣␣␣␣␣␣␣my␣$totalbytes␣=␣0;
␣␣␣␣␣␣␣␣␣␣while␣(defined($data␣=␣$buffer->read))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(defined␣$self->{'.upload_hook'})
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$totalbytes␣+=␣length($data);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣&{$self->{'.upload_hook'}}($filename␣,$data,␣$totalbytes,␣$self->{'.upload_data'});
␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣print␣$filehandle␣$data␣if␣($self->{'use_tempfile'});
␣␣␣␣␣␣␣␣␣␣}

	␣␣#␣back␣up␣to␣beginning␣of␣file
	␣␣seek($filehandle,0,0);

␣␣␣␣␣␣##␣Close␣the␣filehandle␣if␣requested␣this␣allows␣a␣multipart␣MIME
␣␣␣␣␣␣##␣upload␣to␣contain␣many␣files,␣and␣we␣won't␣die␣due␣to␣too␣many
␣␣␣␣␣␣##␣open␣file␣handles.␣The␣user␣can␣access␣the␣files␣using␣the␣hash
␣␣␣␣␣␣##␣below.
␣␣␣␣␣␣close␣$filehandle␣if␣$CLOSE_UPLOAD_FILES;
	␣␣$CGI::DefaultClass->binmode($filehandle)␣if␣$CGI::needs_binmode;

	␣␣#␣Save␣some␣information␣about␣the␣uploaded␣file␣where␣we␣can␣get
	␣␣#␣at␣it␣later.
	␣␣#␣Use␣the␣typeglob␣as␣the␣key,␣as␣this␣is␣guaranteed␣to␣be
	␣␣#␣unique␣for␣each␣filehandle.␣␣Don't␣use␣the␣file␣descriptor␣as
	␣␣#␣this␣will␣be␣re-used␣for␣each␣filehandle␣if␣the
	␣␣#␣close_upload_files␣feature␣is␣used.
	␣␣$self->{'.tmpfiles'}->{$$filehandle}=␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣hndl␣=>␣$filehandle,
	␣␣␣␣␣␣name␣=>␣$tmpfile,
	␣␣␣␣␣␣info␣=>␣{%header},
	␣␣};
	␣␣push(@{$self->{param}{$param}},$filehandle);
␣␣␣␣␣␣}
␣␣␣␣}
}
END_OF_FUNC

#####
#␣subroutine:␣read_multipart_related
#
#␣Read␣multipart/related␣data␣and␣store␣it␣into␣our␣parameters.␣␣The
#␣first␣parameter␣sets␣the␣start␣of␣the␣data.␣The␣part␣identified␣by
#␣this␣Content-ID␣will␣not␣be␣stored␣as␣a␣file␣upload,␣but␣will␣be
#␣returned␣by␣this␣method.␣␣All␣other␣parts␣will␣be␣available␣as␣file
#␣uploads␣accessible␣by␣their␣Content-ID
#####
'read_multipart_related'␣=>␣<<'END_OF_FUNC',
sub␣read_multipart_related␣{
␣␣␣␣my($self,$start,$boundary,$length)␣=␣@_;
␣␣␣␣my($buffer)␣=␣$self->new_MultipartBuffer($boundary,$length);
␣␣␣␣return␣unless␣$buffer;
␣␣␣␣my(%header,$body);
␣␣␣␣my␣$filenumber␣=␣0;
␣␣␣␣my␣$returnvalue;
␣␣␣␣while␣(!$buffer->eof)␣{
	%header␣=␣$buffer->readHeader;

	unless␣(%header)␣{
	␣␣␣␣$self->cgi_error("400␣Bad␣request␣(malformed␣multipart␣POST)");
	␣␣␣␣return;
	}

	my($param)␣=␣$header{'Content-ID'}=~/\<([^\>]*)\>/;
␣␣␣␣␣␣␣␣$param␣.=␣$TAINTED;

	#␣If␣this␣is␣the␣start␣part,␣then␣just␣read␣the␣data␣and␣assign␣it
	#␣to␣our␣return␣variable.
	if␣(␣$param␣eq␣$start␣)␣{
	␣␣␣␣$returnvalue␣=␣$buffer->readBody;
␣␣␣␣␣␣␣␣␣␣␣␣$returnvalue␣.=␣$TAINTED;
	␣␣␣␣next;
	}

	#␣add␣this␣parameter␣to␣our␣list
	$self->add_parameter($param);

	my␣($tmpfile,$tmp,$filehandle);
␣␣␣␣␣␣UPLOADS:␣{
	␣␣#␣If␣we␣get␣here,␣then␣we␣are␣dealing␣with␣a␣potentially␣large
	␣␣#␣uploaded␣form.␣␣Save␣the␣data␣to␣a␣temporary␣file,␣then␣open
	␣␣#␣the␣file␣for␣reading.

	␣␣#␣skip␣the␣file␣if␣uploads␣disabled
	␣␣if␣($DISABLE_UPLOADS)␣{
	␣␣␣␣␣␣while␣(defined($data␣=␣$buffer->read))␣{␣}
	␣␣␣␣␣␣last␣UPLOADS;
	␣␣}

	␣␣#␣choose␣a␣relatively␣unpredictable␣tmpfile␣sequence␣number
␣␣␣␣␣␣␣␣␣␣my␣$seqno␣=␣unpack("%16C*",join('',localtime,grep␣{defined␣$_}␣values␣%ENV));
␣␣␣␣␣␣␣␣␣␣for␣(my␣$cnt=10;$cnt>0;$cnt--)␣{
	␣␣␣␣next␣unless␣$tmpfile␣=␣CGITempFile->new($seqno);
	␣␣␣␣$tmp␣=␣$tmpfile->as_string;
	␣␣␣␣last␣if␣defined($filehandle␣=␣Fh->new($param,$tmp,$PRIVATE_TEMPFILES));
␣␣␣␣␣␣␣␣␣␣␣␣$seqno␣+=␣int␣rand(100);
␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣die␣"CGI␣open␣of␣tmpfile:␣$!\n"␣unless␣defined␣$filehandle;
	␣␣$CGI::DefaultClass->binmode($filehandle)␣if␣$CGI::needs_binmode␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣&&␣defined␣fileno($filehandle);

	␣␣my␣($data);
	␣␣local($\)␣=␣'';
␣␣␣␣␣␣␣␣␣␣my␣$totalbytes;
␣␣␣␣␣␣␣␣␣␣while␣(defined($data␣=␣$buffer->read))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(defined␣$self->{'.upload_hook'})
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$totalbytes␣+=␣length($data);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣&{$self->{'.upload_hook'}}($param␣,$data,␣$totalbytes,␣$self->{'.upload_data'});
␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣print␣$filehandle␣$data␣if␣($self->{'use_tempfile'});
␣␣␣␣␣␣␣␣␣␣}

	␣␣#␣back␣up␣to␣beginning␣of␣file
	␣␣seek($filehandle,0,0);

␣␣␣␣␣␣##␣Close␣the␣filehandle␣if␣requested␣this␣allows␣a␣multipart␣MIME
␣␣␣␣␣␣##␣upload␣to␣contain␣many␣files,␣and␣we␣won't␣die␣due␣to␣too␣many
␣␣␣␣␣␣##␣open␣file␣handles.␣The␣user␣can␣access␣the␣files␣using␣the␣hash
␣␣␣␣␣␣##␣below.
␣␣␣␣␣␣close␣$filehandle␣if␣$CLOSE_UPLOAD_FILES;
	␣␣$CGI::DefaultClass->binmode($filehandle)␣if␣$CGI::needs_binmode;

	␣␣#␣Save␣some␣information␣about␣the␣uploaded␣file␣where␣we␣can␣get
	␣␣#␣at␣it␣later.
	␣␣#␣Use␣the␣typeglob␣as␣the␣key,␣as␣this␣is␣guaranteed␣to␣be
	␣␣#␣unique␣for␣each␣filehandle.␣␣Don't␣use␣the␣file␣descriptor␣as
	␣␣#␣this␣will␣be␣re-used␣for␣each␣filehandle␣if␣the
	␣␣#␣close_upload_files␣feature␣is␣used.
	␣␣$self->{'.tmpfiles'}->{$$filehandle}=␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣hndl␣=>␣$filehandle,
	␣␣␣␣␣␣name␣=>␣$tmpfile,
	␣␣␣␣␣␣info␣=>␣{%header},
	␣␣};
	␣␣push(@{$self->{param}{$param}},$filehandle);
␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣return␣$returnvalue;
}
END_OF_FUNC


'upload'␣=><<'END_OF_FUNC',
sub␣upload␣{
␣␣␣␣my($self,$param_name)␣=␣self_or_default(@_);
␣␣␣␣my␣@param␣=␣grep␣{ref($_)␣&&␣defined(fileno($_))}␣$self->param($param_name);
␣␣␣␣return␣unless␣@param;
␣␣␣␣return␣wantarray␣?␣@param␣:␣$param[0];
}
END_OF_FUNC

'tmpFileName'␣=>␣<<'END_OF_FUNC',
sub␣tmpFileName␣{
␣␣␣␣my($self,$filename)␣=␣self_or_default(@_);
␣␣␣␣return␣$self->{'.tmpfiles'}->{$$filename}->{name}␣?
	$self->{'.tmpfiles'}->{$$filename}->{name}->as_string
	␣␣␣␣:␣'';
}
END_OF_FUNC

'uploadInfo'␣=>␣<<'END_OF_FUNC',
sub␣uploadInfo␣{
␣␣␣␣my($self,$filename)␣=␣self_or_default(@_);
␣␣␣␣return␣$self->{'.tmpfiles'}->{$$filename}->{info};
}
END_OF_FUNC

#␣internal␣routine,␣don't␣use
'_set_values_and_labels'␣=>␣<<'END_OF_FUNC',
sub␣_set_values_and_labels␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣($v,$l,$n)␣=␣@_;
␣␣␣␣$$l␣=␣$v␣if␣ref($v)␣eq␣'HASH'␣&&␣!ref($$l);
␣␣␣␣return␣$self->param($n)␣if␣!defined($v);
␣␣␣␣return␣$v␣if␣!ref($v);
␣␣␣␣return␣ref($v)␣eq␣'HASH'␣?␣keys␣%$v␣:␣@$v;
}
END_OF_FUNC

#␣internal␣routine,␣don't␣use
'_set_attributes'␣=>␣<<'END_OF_FUNC',
sub␣_set_attributes␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my($element,␣$attributes)␣=␣@_;
␣␣␣␣return␣''␣unless␣defined($attributes->{$element});
␣␣␣␣$attribs␣=␣'␣';
␣␣␣␣for␣my␣$attrib␣(keys␣%{$attributes->{$element}})␣{
␣␣␣␣␣␣␣␣(my␣$clean_attrib␣=␣$attrib)␣=~␣s/^-//;
␣␣␣␣␣␣␣␣$attribs␣.=␣"@{[lc($clean_attrib)]}=\"$attributes->{$element}{$attrib}\"␣";
␣␣␣␣}
␣␣␣␣$attribs␣=~␣s/␣$//;
␣␣␣␣return␣$attribs;
}
END_OF_FUNC

'_compile_all'␣=>␣<<'END_OF_FUNC',
sub␣_compile_all␣{
␣␣␣␣for␣(@_)␣{
	next␣if␣defined(&$_);
	$AUTOLOAD␣=␣"CGI::$_";
	_compile();
␣␣␣␣}
}
END_OF_FUNC

);
END_OF_AUTOLOAD
----------
Range: (3940846,3948476) (7630)
<<'END_OF_AUTOLOAD';
%SUBS␣=␣␣(

'new'␣=>␣<<'END_OF_FUNC',
sub␣new␣{
␣␣␣␣my($package,$interface,$boundary,$length)␣=␣@_;
␣␣␣␣$FILLUNIT␣=␣$INITIAL_FILLUNIT;
␣␣␣␣$CGI::DefaultClass->binmode($IN);␣#␣if␣$CGI::needs_binmode;␣␣#␣just␣do␣it␣always

␣␣␣␣#␣If␣the␣user␣types␣garbage␣into␣the␣file␣upload␣field,
␣␣␣␣#␣then␣Netscape␣passes␣NOTHING␣to␣the␣server␣(not␣good).
␣␣␣␣#␣We␣may␣hang␣on␣this␣read␣in␣that␣case.␣So␣we␣implement
␣␣␣␣#␣a␣read␣timeout.␣␣If␣nothing␣is␣ready␣to␣read
␣␣␣␣#␣by␣then,␣we␣return.

␣␣␣␣#␣Netscape␣seems␣to␣be␣a␣little␣bit␣unreliable
␣␣␣␣#␣about␣providing␣boundary␣strings.
␣␣␣␣my␣$boundary_read␣=␣0;
␣␣␣␣if␣($boundary)␣{

	#␣Under␣the␣MIME␣spec,␣the␣boundary␣consists␣of␣the␣
	#␣characters␣"--"␣PLUS␣the␣Boundary␣string

	#␣BUG:␣IE␣3.01␣on␣the␣Macintosh␣uses␣just␣the␣boundary␣--␣not
	#␣the␣two␣extra␣hyphens.␣␣We␣do␣a␣special␣case␣here␣on␣the␣user-agent!!!!
	$boundary␣=␣"--$boundary"␣unless␣CGI::user_agent('MSIE\s+3\.0[12];\s*Mac|DreamPassport');

␣␣␣␣}␣else␣{␣#␣otherwise␣we␣find␣it␣ourselves
	my($old);
	($old,$/)␣=␣($/,$CRLF);␣#␣read␣a␣CRLF-delimited␣line
	$boundary␣=␣<STDIN>;␣␣␣␣␣␣#␣BUG:␣This␣won't␣work␣correctly␣under␣mod_perl
	$length␣-=␣length($boundary);
	chomp($boundary);␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣remove␣the␣CRLF
	$/␣=␣$old;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣restore␣old␣line␣separator
␣␣␣␣␣␣␣␣$boundary_read++;
␣␣␣␣}

␣␣␣␣my␣$self␣=␣{LENGTH=>$length,
		CHUNKED=>!$length,
		BOUNDARY=>$boundary,
		INTERFACE=>$interface,
		BUFFER=>'',
	␣␣␣␣};

␣␣␣␣$FILLUNIT␣=␣length($boundary)
	if␣length($boundary)␣>␣$FILLUNIT;

␣␣␣␣my␣$retval␣=␣bless␣$self,ref␣$package␣||␣$package;

␣␣␣␣#␣Read␣the␣preamble␣and␣the␣topmost␣(boundary)␣line␣plus␣the␣CRLF.
␣␣␣␣unless␣($boundary_read)␣{
␣␣␣␣␣␣while␣($self->read(0))␣{␣}
␣␣␣␣}
␣␣␣␣die␣"Malformed␣multipart␣POST:␣data␣truncated\n"␣if␣$self->eof;

␣␣␣␣return␣$retval;
}
END_OF_FUNC

'readHeader'␣=>␣<<'END_OF_FUNC',
sub␣readHeader␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣my($end);
␣␣␣␣my($ok)␣=␣0;
␣␣␣␣my($bad)␣=␣0;

␣␣␣␣local($CRLF)␣=␣"\015\012"␣if␣$CGI::OS␣eq␣'VMS'␣||␣$CGI::EBCDIC;

␣␣␣␣do␣{
	$self->fillBuffer($FILLUNIT);
	$ok++␣if␣($end␣=␣index($self->{BUFFER},"${CRLF}${CRLF}"))␣>=␣0;
	$ok++␣if␣$self->{BUFFER}␣eq␣'';
	$bad++␣if␣!$ok␣&&␣$self->{LENGTH}␣<=␣0;
	#␣this␣was␣a␣bad␣idea
	#␣$FILLUNIT␣*=␣2␣if␣length($self->{BUFFER})␣>=␣$FILLUNIT;␣
␣␣␣␣}␣until␣$ok␣||␣$bad;
␣␣␣␣return␣()␣if␣$bad;

␣␣␣␣#EBCDIC␣NOTE:␣translate␣header␣into␣EBCDIC,␣but␣watch␣out␣for␣continuation␣lines!

␣␣␣␣my($header)␣=␣substr($self->{BUFFER},0,$end+2);
␣␣␣␣substr($self->{BUFFER},0,$end+4)␣=␣'';
␣␣␣␣my␣%return;

␣␣␣␣if␣($CGI::EBCDIC)␣{
␣␣␣␣␣␣warn␣"untranslated␣header=$header\n"␣if␣DEBUG;
␣␣␣␣␣␣$header␣=␣CGI::Util::ascii2ebcdic($header);
␣␣␣␣␣␣warn␣"translated␣header=$header\n"␣if␣DEBUG;
␣␣␣␣}

␣␣␣␣#␣See␣RFC␣2045␣Appendix␣A␣and␣RFC␣822␣sections␣3.4.8
␣␣␣␣#␣␣␣(Folding␣Long␣Header␣Fields),␣3.4.3␣(Comments)
␣␣␣␣#␣␣␣and␣3.4.5␣(Quoted-Strings).

␣␣␣␣my␣$token␣=␣'[-\w!\#$%&\'*+.^_\`|{}~]';
␣␣␣␣$header=~s/$CRLF\s+/␣/og;		#␣merge␣continuation␣lines

␣␣␣␣while␣($header=~/($token+):\s+([^$CRLF]*)/mgox)␣{
␣␣␣␣␣␣␣␣my␣($field_name,$field_value)␣=␣($1,$2);
	$field_name␣=~␣s/\b(\w)/uc($1)/eg;␣#canonicalize
	$return{$field_name}=$field_value;
␣␣␣␣}
␣␣␣␣return␣%return;
}
END_OF_FUNC

#␣This␣reads␣and␣returns␣the␣body␣as␣a␣single␣scalar␣value.
'readBody'␣=>␣<<'END_OF_FUNC',
sub␣readBody␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣my($data);
␣␣␣␣my($returnval)='';

␣␣␣␣#EBCDIC␣NOTE:␣want␣to␣translate␣returnval␣into␣EBCDIC␣HERE

␣␣␣␣while␣(defined($data␣=␣$self->read))␣{
	$returnval␣.=␣$data;
␣␣␣␣}

␣␣␣␣if␣($CGI::EBCDIC)␣{
␣␣␣␣␣␣warn␣"untranslated␣body=$returnval\n"␣if␣DEBUG;
␣␣␣␣␣␣$returnval␣=␣CGI::Util::ascii2ebcdic($returnval);
␣␣␣␣␣␣warn␣"translated␣body=$returnval\n"␣␣␣if␣DEBUG;
␣␣␣␣}
␣␣␣␣return␣$returnval;
}
END_OF_FUNC

#␣This␣will␣read␣$bytes␣or␣until␣the␣boundary␣is␣hit,␣whichever␣happens
#␣first.␣␣After␣the␣boundary␣is␣hit,␣we␣return␣undef.␣␣The␣next␣read␣will
#␣skip␣over␣the␣boundary␣and␣begin␣reading␣again;
'read'␣=>␣<<'END_OF_FUNC',
sub␣read␣{
␣␣␣␣my($self,$bytes)␣=␣@_;

␣␣␣␣#␣default␣number␣of␣bytes␣to␣read
␣␣␣␣$bytes␣=␣$bytes␣||␣$FILLUNIT;

␣␣␣␣#␣Fill␣up␣our␣internal␣buffer␣in␣such␣a␣way␣that␣the␣boundary
␣␣␣␣#␣is␣never␣split␣between␣reads.
␣␣␣␣$self->fillBuffer($bytes);

␣␣␣␣my␣$boundary_start␣=␣$CGI::EBCDIC␣?␣CGI::Util::ebcdic2ascii($self->{BOUNDARY})␣␣␣␣␣␣:␣$self->{BOUNDARY};
␣␣␣␣my␣$boundary_end␣␣␣=␣$CGI::EBCDIC␣?␣CGI::Util::ebcdic2ascii($self->{BOUNDARY}.'--')␣:␣$self->{BOUNDARY}.'--';

␣␣␣␣#␣Find␣the␣boundary␣in␣the␣buffer␣(it␣may␣not␣be␣there).
␣␣␣␣my␣$start␣=␣index($self->{BUFFER},$boundary_start);

␣␣␣␣warn␣"boundary=$self->{BOUNDARY}␣length=$self->{LENGTH}␣start=$start\n"␣if␣DEBUG;

␣␣␣␣#␣protect␣against␣malformed␣multipart␣POST␣operations
␣␣␣␣die␣"Malformed␣multipart␣POST\n"␣unless␣$self->{CHUNKED}␣||␣($start␣>=␣0␣||␣$self->{LENGTH}␣>␣0);

␣␣␣␣#EBCDIC␣NOTE:␣want␣to␣translate␣boundary␣search␣into␣ASCII␣here.

␣␣␣␣#␣If␣the␣boundary␣begins␣the␣data,␣then␣skip␣past␣it
␣␣␣␣#␣and␣return␣undef.
␣␣␣␣if␣($start␣==␣0)␣{

	#␣clear␣us␣out␣completely␣if␣we've␣hit␣the␣last␣boundary.
	if␣(index($self->{BUFFER},$boundary_end)==0)␣{
	␣␣␣␣$self->{BUFFER}='';
	␣␣␣␣$self->{LENGTH}=0;
	␣␣␣␣return␣undef;
	}

	#␣just␣remove␣the␣boundary.
	substr($self->{BUFFER},0,length($boundary_start))='';
␣␣␣␣␣␣␣␣$self->{BUFFER}␣=~␣s/^\012\015?//;
	return␣undef;
␣␣␣␣}

␣␣␣␣my␣$bytesToReturn;
␣␣␣␣if␣($start␣>␣0)␣{␣␣␣␣␣␣␣␣␣␣␣#␣read␣up␣to␣the␣boundary
␣␣␣␣␣␣␣␣$bytesToReturn␣=␣$start-2␣>␣$bytes␣?␣$bytes␣:␣$start;
␣␣␣␣}␣else␣{␣␣␣␣#␣read␣the␣requested␣number␣of␣bytes
	#␣leave␣enough␣bytes␣in␣the␣buffer␣to␣allow␣us␣to␣read
	#␣the␣boundary.␣␣Thanks␣to␣Kevin␣Hendrick␣for␣finding
	#␣this␣one.
	$bytesToReturn␣=␣$bytes␣-␣(length($boundary_start)+1);
␣␣␣␣}

␣␣␣␣my␣$returnval=substr($self->{BUFFER},0,$bytesToReturn);
␣␣␣␣substr($self->{BUFFER},0,$bytesToReturn)='';
␣␣␣␣
␣␣␣␣#␣If␣we␣hit␣the␣boundary,␣remove␣the␣CRLF␣from␣the␣end.
␣␣␣␣return␣($bytesToReturn==$start)
␣␣␣␣␣␣␣␣␣␣␣?␣substr($returnval,0,-2)␣:␣$returnval;
}
END_OF_FUNC


#␣This␣fills␣up␣our␣internal␣buffer␣in␣such␣a␣way␣that␣the
#␣boundary␣is␣never␣split␣between␣reads
'fillBuffer'␣=>␣<<'END_OF_FUNC',
sub␣fillBuffer␣{
␣␣␣␣my($self,$bytes)␣=␣@_;
␣␣␣␣return␣unless␣$self->{CHUNKED}␣||␣$self->{LENGTH};

␣␣␣␣my($boundaryLength)␣=␣length($self->{BOUNDARY});
␣␣␣␣my($bufferLength)␣=␣length($self->{BUFFER});
␣␣␣␣my($bytesToRead)␣=␣$bytes␣-␣$bufferLength␣+␣$boundaryLength␣+␣2;
␣␣␣␣$bytesToRead␣=␣$self->{LENGTH}␣if␣!$self->{CHUNKED}␣&&␣$self->{LENGTH}␣<␣$bytesToRead;

␣␣␣␣#␣Try␣to␣read␣some␣data.␣␣We␣may␣hang␣here␣if␣the␣browser␣is␣screwed␣up.
␣␣␣␣my␣$bytesRead␣=␣$self->{INTERFACE}->read_from_client(\$self->{BUFFER},
							␣$bytesToRead,
							␣$bufferLength);
␣␣␣␣warn␣"bytesToRead=$bytesToRead,␣bufferLength=$bufferLength,␣buffer=$self->{BUFFER}\n"␣if␣DEBUG;
␣␣␣␣$self->{BUFFER}␣=␣''␣unless␣defined␣$self->{BUFFER};

␣␣␣␣#␣An␣apparent␣bug␣in␣the␣Apache␣server␣causes␣the␣read()
␣␣␣␣#␣to␣return␣zero␣bytes␣repeatedly␣without␣blocking␣if␣the
␣␣␣␣#␣remote␣user␣aborts␣during␣a␣file␣transfer.␣␣I␣don't␣know␣how
␣␣␣␣#␣they␣manage␣this,␣but␣the␣workaround␣is␣to␣abort␣if␣we␣get
␣␣␣␣#␣more␣than␣SPIN_LOOP_MAX␣consecutive␣zero␣reads.
␣␣␣␣if␣($bytesRead␣<=␣0)␣{
	die␣␣"CGI.pm:␣Server␣closed␣socket␣during␣multipart␣read␣(client␣aborted?).\n"
	␣␣␣␣if␣($self->{ZERO_LOOP_COUNTER}++␣>=␣$SPIN_LOOP_MAX);
␣␣␣␣}␣else␣{
	$self->{ZERO_LOOP_COUNTER}=0;
␣␣␣␣}

␣␣␣␣$self->{LENGTH}␣-=␣$bytesRead␣if␣!$self->{CHUNKED}␣&&␣$bytesRead;
}
END_OF_FUNC


#␣Return␣true␣when␣we've␣finished␣reading
'eof'␣=>␣<<'END_OF_FUNC'
sub␣eof␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣return␣1␣if␣(length($self->{BUFFER})␣==␣0)
		␣&&␣($self->{LENGTH}␣<=␣0);
␣␣␣␣undef;
}
END_OF_FUNC

);
END_OF_AUTOLOAD
----------
Range: (3999536,4016785) (17249)
=head1␣NAME

Module::Build::Cookbook␣-␣Examples␣of␣Module::Build␣Usage

=head1␣DESCRIPTION

C<Module::Build>␣isn't␣conceptually␣very␣complicated,␣but␣examples␣are
always␣helpful.␣␣The␣following␣recipes␣should␣help␣developers␣and/or
installers␣put␣together␣the␣pieces␣from␣the␣other␣parts␣of␣the
documentation.


=head1␣BASIC␣RECIPES


=head2␣Installing␣modules␣that␣use␣Module::Build

In␣most␣cases,␣you␣can␣just␣issue␣the␣following␣commands:

␣␣perl␣Build.PL
␣␣./Build
␣␣./Build␣test
␣␣./Build␣install

There's␣nothing␣complicated␣here␣-␣first␣you're␣running␣a␣script
called␣F<Build.PL>,␣then␣you're␣running␣a␣(newly-generated)␣script
called␣F<Build>␣and␣passing␣it␣various␣arguments.

The␣exact␣commands␣may␣vary␣a␣bit␣depending␣on␣how␣you␣invoke␣perl
scripts␣on␣your␣system.␣␣For␣instance,␣if␣you␣have␣multiple␣versions
of␣perl␣installed,␣you␣can␣install␣to␣one␣particular␣perl's␣library
directories␣like␣so:

␣␣/usr/bin/perl5.8.1␣Build.PL
␣␣./Build
␣␣./Build␣test
␣␣./Build␣install

If␣you're␣on␣Windows␣where␣the␣current␣directory␣is␣always␣searched
first␣for␣scripts,␣you'll␣probably␣do␣something␣like␣this:

␣␣perl␣Build.PL
␣␣Build
␣␣Build␣test
␣␣Build␣install

On␣the␣old␣Mac␣OS␣(version␣9␣or␣lower)␣using␣MacPerl,␣you␣can
double-click␣on␣the␣F<Build.PL>␣script␣to␣create␣the␣F<Build>␣script,
then␣double-click␣on␣the␣F<Build>␣script␣to␣run␣its␣C<build>,␣C<test>,
and␣C<install>␣actions.

The␣F<Build>␣script␣knows␣what␣perl␣was␣used␣to␣run␣F<Build.PL>,␣so
you␣don't␣need␣to␣re-invoke␣the␣F<Build>␣script␣with␣the␣complete␣perl
path␣each␣time.␣␣If␣you␣invoke␣it␣with␣the␣I<wrong>␣perl␣path,␣you'll
get␣a␣warning␣or␣a␣fatal␣error.

=head2␣Modifying␣Config.pm␣values

C<Module::Build>␣relies␣heavily␣on␣various␣values␣from␣perl's
C<Config.pm>␣to␣do␣its␣work.␣␣For␣example,␣default␣installation␣paths
are␣given␣by␣C<installsitelib>␣and␣C<installvendorman3dir>␣and
friends,␣C␣linker␣&␣compiler␣settings␣are␣given␣by␣C<ld>,
C<lddlflags>,␣C<cc>,␣C<ccflags>,␣and␣so␣on.␣␣I<If␣you're␣pretty␣sure
you␣know␣what␣you're␣doing>,␣you␣can␣tell␣C<Module::Build>␣to␣pretend
there␣are␣different␣values␣in␣F<Config.pm>␣than␣what's␣really␣there,
by␣passing␣arguments␣for␣the␣C<--config>␣parameter␣on␣the␣command
line:

␣␣perl␣Build.PL␣--config␣cc=gcc␣--config␣ld=gcc

Inside␣the␣C<Build.PL>␣script␣the␣same␣thing␣can␣be␣accomplished␣by
passing␣values␣for␣the␣C<config>␣parameter␣to␣C<new()>:

␣my␣$build␣=␣Module::Build->new
␣␣␣(
␣␣␣␣...
␣␣␣␣config␣=>␣{␣cc␣=>␣'gcc',␣ld␣=>␣'gcc'␣},
␣␣␣␣...
␣␣␣);

In␣custom␣build␣code,␣the␣same␣thing␣can␣be␣accomplished␣by␣calling
the␣L<Module::Build/config>␣method:

␣$build->config(␣cc␣=>␣'gcc'␣);␣␣␣␣␣#␣Set
␣$build->config(␣ld␣=>␣'gcc'␣);␣␣␣␣␣#␣Set
␣...
␣my␣$linker␣=␣$build->config('ld');␣#␣Get


=head2␣Installing␣modules␣using␣the␣programmatic␣interface

If␣you␣need␣to␣build,␣test,␣and/or␣install␣modules␣from␣within␣some
other␣perl␣code␣(as␣opposed␣to␣having␣the␣user␣type␣installation
commands␣at␣the␣shell),␣you␣can␣use␣the␣programmatic␣interface.
Create␣a␣Module::Build␣object␣(or␣an␣object␣of␣a␣custom␣Module::Build
subclass)␣and␣then␣invoke␣its␣C<dispatch()>␣method␣to␣run␣various
actions.

␣␣my␣$build␣=␣Module::Build->new
␣␣␣␣(
␣␣␣␣␣module_name␣=>␣'Foo::Bar',
␣␣␣␣␣license␣␣␣␣␣=>␣'perl',
␣␣␣␣␣requires␣␣␣␣=>␣{␣'Some::Module'␣␣␣=>␣'1.23'␣},
␣␣␣␣);
␣␣$build->dispatch('build');
␣␣$build->dispatch('test',␣verbose␣=>␣1);
␣␣$build->dispatch('install');

The␣first␣argument␣to␣C<dispatch()>␣is␣the␣name␣of␣the␣action,␣and␣any
following␣arguments␣are␣named␣parameters.

This␣is␣the␣interface␣we␣use␣to␣test␣Module::Build␣itself␣in␣the
regression␣tests.


=head2␣Installing␣to␣a␣temporary␣directory

To␣create␣packages␣for␣package␣managers␣like␣RedHat's␣C<rpm>␣or
Debian's␣C<deb>,␣you␣may␣need␣to␣install␣to␣a␣temporary␣directory
first␣and␣then␣create␣the␣package␣from␣that␣temporary␣installation.
To␣do␣this,␣specify␣the␣C<destdir>␣parameter␣to␣the␣C<install>␣action:

␣␣./Build␣install␣--destdir␣/tmp/my-package-1.003

This␣essentially␣just␣prepends␣all␣the␣installation␣paths␣with␣the
F</tmp/my-package-1.003>␣directory.


=head2␣Installing␣to␣a␣non-standard␣directory

To␣install␣to␣a␣non-standard␣directory␣(for␣example,␣if␣you␣don't␣have
permission␣to␣install␣in␣the␣system-wide␣directories),␣you␣can␣use␣the
C<install_base>␣or␣C<prefix>␣parameters:

␣␣./Build␣install␣--install_base␣/foo/bar

See␣L<Module::Build/"INSTALL␣PATHS">␣for␣a␣much␣more␣complete
discussion␣of␣how␣installation␣paths␣are␣determined.


=head2␣Installing␣in␣the␣same␣location␣as␣ExtUtils::MakeMaker

With␣the␣introduction␣of␣C<--prefix>␣in␣Module::Build␣0.28␣and
C<INSTALL_BASE>␣in␣C<ExtUtils::MakeMaker>␣6.31␣its␣easy␣to␣get␣them␣both
to␣install␣to␣the␣same␣locations.

First,␣ensure␣you␣have␣at␣least␣version␣0.28␣of␣Module::Build
installed␣and␣6.31␣of␣C<ExtUtils::MakeMaker>.␣␣Prior␣versions␣have
differing␣(and␣in␣some␣cases␣quite␣strange)␣installation␣behaviors.

The␣following␣installation␣flags␣are␣equivalent␣between
C<ExtUtils::MakeMaker>␣and␣C<Module::Build>.

␣␣␣␣MakeMaker␣␣␣␣␣␣␣␣␣␣␣␣␣Module::Build
␣␣␣␣PREFIX=...␣␣␣␣␣␣␣␣␣␣␣␣--prefix␣...
␣␣␣␣INSTALL_BASE=...␣␣␣␣␣␣--install_base␣...
␣␣␣␣DESTDIR=...␣␣␣␣␣␣␣␣␣␣␣--destdir␣...
␣␣␣␣LIB=...␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣--install_path␣lib=...
␣␣␣␣INSTALLDIRS=...␣␣␣␣␣␣␣--installdirs␣...
␣␣␣␣INSTALLDIRS=perl␣␣␣␣␣␣--installdirs␣core
␣␣␣␣UNINST=...␣␣␣␣␣␣␣␣␣␣␣␣--uninst␣...
␣␣␣␣INC=...␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣--extra_compiler_flags␣...
␣␣␣␣POLLUTE=1␣␣␣␣␣␣␣␣␣␣␣␣␣--extra_compiler_flags␣-DPERL_POLLUTE

For␣example,␣if␣you␣are␣currently␣installing␣C<MakeMaker>␣modules␣with
this␣command:

␣␣␣␣perl␣Makefile.PL␣PREFIX=~
␣␣␣␣make␣test
␣␣␣␣make␣install␣UNINST=1

You␣can␣install␣into␣the␣same␣location␣with␣Module::Build␣using␣this:

␣␣␣␣perl␣Build.PL␣--prefix␣~
␣␣␣␣./Build␣test
␣␣␣␣./Build␣install␣--uninst␣1

=head3␣C<prefix>␣vs␣C<install_base>

The␣behavior␣of␣C<prefix>␣is␣complicated␣and␣depends␣on
how␣your␣Perl␣is␣configured.␣␣The␣resulting␣installation␣locations
will␣vary␣from␣machine␣to␣machine␣and␣even␣different␣installations␣of
Perl␣on␣the␣same␣machine.␣␣Because␣of␣this,␣it's␣difficult␣to␣document
where␣C<prefix>␣will␣place␣your␣modules.

In␣contrast,␣C<install_base>␣has␣predictable,␣easy␣to␣explain
installation␣locations.␣␣Now␣that␣C<Module::Build>␣and␣C<MakeMaker>␣both
have␣C<install_base>␣there␣is␣little␣reason␣to␣use␣C<prefix>␣other
than␣to␣preserve␣your␣existing␣installation␣locations.␣␣If␣you␣are
starting␣a␣fresh␣Perl␣installation␣we␣encourage␣you␣to␣use
C<install_base>.␣␣If␣you␣have␣an␣existing␣installation␣installed␣via
C<prefix>,␣consider␣moving␣it␣to␣an␣installation␣structure␣matching
C<install_base>␣and␣using␣that␣instead.


=head2␣Running␣a␣single␣test␣file

C<Module::Build>␣supports␣running␣a␣single␣test,␣which␣enables␣you␣to
track␣down␣errors␣more␣quickly.␣␣Use␣the␣following␣format:

␣␣./Build␣test␣--test_files␣t/mytest.t

In␣addition,␣you␣may␣want␣to␣run␣the␣test␣in␣verbose␣mode␣to␣get␣more
informative␣output:

␣␣./Build␣test␣--test_files␣t/mytest.t␣--verbose␣1

I␣run␣this␣so␣frequently␣that␣I␣define␣the␣following␣shell␣alias:

␣␣alias␣t␣'./Build␣test␣--verbose␣1␣--test_files'

So␣then␣I␣can␣just␣execute␣C<t␣t/mytest.t>␣to␣run␣a␣single␣test.


=head1␣ADVANCED␣RECIPES


=head2␣Making␣a␣CPAN.pm-compatible␣distribution

New␣versions␣of␣CPAN.pm␣understand␣how␣to␣use␣a␣F<Build.PL>␣script,
but␣old␣versions␣don't.␣␣If␣authors␣want␣to␣help␣users␣who␣have␣old
versions,␣some␣form␣of␣F<Makefile.PL>␣should␣be␣supplied.␣␣The␣easiest
way␣to␣accomplish␣this␣is␣to␣use␣the␣C<create_makefile_pl>␣parameter␣to
C<<␣Module::Build->new()␣>>␣in␣the␣C<Build.PL>␣script,␣which␣can
create␣various␣flavors␣of␣F<Makefile.PL>␣during␣the␣C<dist>␣action.

As␣a␣best␣practice,␣we␣recommend␣using␣the␣"traditional"␣style␣of
F<Makefile.PL>␣unless␣your␣distribution␣has␣needs␣that␣can't␣be
accomplished␣that␣way.

The␣C<Module::Build::Compat>␣module,␣which␣is␣part␣of
C<Module::Build>'s␣distribution,␣is␣responsible␣for␣creating␣these
F<Makefile.PL>s.␣␣Please␣see␣L<Module::Build::Compat>␣for␣the␣details.


=head2␣Changing␣the␣order␣of␣the␣build␣process

The␣C<build_elements>␣property␣specifies␣the␣steps␣C<Module::Build>
will␣take␣when␣building␣a␣distribution.␣␣To␣change␣the␣build␣order,
change␣the␣order␣of␣the␣entries␣in␣that␣property:

␣␣#␣Process␣pod␣files␣first
␣␣my␣@e␣=␣@{$build->build_elements};
␣␣my␣($i)␣=␣grep␣{$e[$_]␣eq␣'pod'}␣0..$#e;
␣␣unshift␣@e,␣splice␣@e,␣$i,␣1;

Currently,␣C<build_elements>␣has␣the␣following␣default␣value:

␣␣[qw(␣PL␣support␣pm␣xs␣pod␣script␣)]

Do␣take␣care␣when␣altering␣this␣property,␣since␣there␣may␣be
non-obvious␣(and␣non-documented!)␣ordering␣dependencies␣in␣the
C<Module::Build>␣code.


=head2␣Adding␣new␣file␣types␣to␣the␣build␣process

Sometimes␣you␣might␣have␣extra␣types␣of␣files␣that␣you␣want␣to␣install
alongside␣the␣standard␣types␣like␣F<.pm>␣and␣F<.pod>␣files.␣␣For
instance,␣you␣might␣have␣a␣F<Bar.dat>␣file␣containing␣some␣data
related␣to␣the␣C<Foo::Bar>␣module␣and␣you'd␣like␣for␣it␣to␣end␣up␣as
F<Foo/Bar.dat>␣somewhere␣in␣perl's␣C<@INC>␣path␣so␣C<Foo::Bar>␣can
access␣it␣easily␣at␣runtime.␣␣The␣following␣code␣from␣a␣sample
C<Build.PL>␣file␣demonstrates␣how␣to␣accomplish␣this:

␣␣use␣Module::Build;
␣␣my␣$build␣=␣Module::Build->new
␣␣␣␣(
␣␣␣␣␣module_name␣=>␣'Foo::Bar',
␣␣␣␣␣...other␣stuff␣here...
␣␣␣␣);
␣␣$build->add_build_element('dat');
␣␣$build->create_build_script;

This␣will␣find␣all␣F<.dat>␣files␣in␣the␣F<lib/>␣directory,␣copy␣them
to␣the␣F<blib/lib/>␣directory␣during␣the␣C<build>␣action,␣and␣install
them␣during␣the␣C<install>␣action.

If␣your␣extra␣files␣aren't␣located␣in␣the␣C<lib/>␣directory␣in␣your
distribution,␣you␣can␣explicitly␣say␣where␣they␣are,␣just␣as␣you'd␣do
with␣F<.pm>␣or␣F<.pod>␣files:

␣␣use␣Module::Build;
␣␣my␣$build␣=␣new␣Module::Build
␣␣␣␣(
␣␣␣␣␣module_name␣=>␣'Foo::Bar',
␣␣␣␣␣dat_files␣=>␣{'some/dir/Bar.dat'␣=>␣'lib/Foo/Bar.dat'},
␣␣␣␣␣...other␣stuff␣here...
␣␣␣␣);
␣␣$build->add_build_element('dat');
␣␣$build->create_build_script;

If␣your␣extra␣files␣actually␣need␣to␣be␣created␣on␣the␣user's␣machine,
or␣if␣they␣need␣some␣other␣kind␣of␣special␣processing,␣you'll␣probably
want␣to␣subclass␣C<Module::Build>␣and␣create␣a␣special␣method␣to
process␣them,␣named␣C<process_${kind}_files()>:

␣␣use␣Module::Build;
␣␣my␣$class␣=␣Module::Build->subclass(code␣=>␣<<'EOF');
␣␣␣␣sub␣process_dat_files␣{
␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣...␣locate␣and␣process␣*.dat␣files,
␣␣␣␣␣␣...␣and␣create␣something␣in␣blib/lib/
␣␣␣␣}
␣␣EOF
␣␣my␣$build␣=␣$class->new
␣␣␣␣(
␣␣␣␣␣module_name␣=>␣'Foo::Bar',
␣␣␣␣␣...other␣stuff␣here...
␣␣␣␣);
␣␣$build->add_build_element('dat');
␣␣$build->create_build_script;

If␣your␣extra␣files␣don't␣go␣in␣F<lib/>␣but␣in␣some␣other␣place,␣see
L<"Adding␣new␣elements␣to␣the␣install␣process">␣for␣how␣to␣actually
get␣them␣installed.

Please␣note␣that␣these␣examples␣use␣some␣capabilities␣of␣Module::Build
that␣first␣appeared␣in␣version␣0.26.␣␣Before␣that␣it␣could
still␣be␣done,␣but␣the␣simple␣cases␣took␣a␣bit␣more␣work.


=head2␣Adding␣new␣elements␣to␣the␣install␣process

By␣default,␣Module::Build␣creates␣seven␣subdirectories␣of␣the␣F<blib>
directory␣during␣the␣build␣process:␣F<lib>,␣F<arch>,␣F<bin>,
F<script>,␣F<bindoc>,␣F<libdoc>,␣and␣F<html>␣(some␣of␣these␣may␣be
missing␣or␣empty␣if␣there's␣nothing␣to␣go␣in␣them).␣␣Anything␣copied
to␣these␣directories␣during␣the␣build␣will␣eventually␣be␣installed
during␣the␣C<install>␣action␣(see␣L<Module::Build/"INSTALL␣PATHS">.

If␣you␣need␣to␣create␣a␣new␣custom␣type␣of␣installable␣element,␣e.g.␣C<conf>,
then␣you␣need␣to␣tell␣Module::Build␣where␣things␣in␣F<blib/conf/>
should␣be␣installed.␣␣To␣do␣this,␣use␣the␣C<install_path>␣parameter␣to
the␣C<new()>␣method:

␣␣my␣$build␣=␣Module::Build->new
␣␣␣␣(
␣␣␣␣␣...other␣stuff␣here...
␣␣␣␣␣install_path␣=>␣{␣conf␣=>␣$installation_path␣}
␣␣␣␣);

Or␣you␣can␣call␣the␣C<install_path()>␣method␣later:

␣␣$build->install_path(conf␣=>␣$installation_path);

The␣user␣may␣also␣specify␣the␣path␣on␣the␣command␣line:

␣␣perl␣Build.PL␣--install_path␣conf=/foo/path/etc

The␣important␣part,␣though,␣is␣that␣I<somehow>␣the␣install␣path␣needs
to␣be␣set,␣or␣else␣nothing␣in␣the␣F<blib/conf/>␣directory␣will␣get
installed,␣and␣a␣runtime␣error␣during␣the␣C<install>␣action␣will
result.

See␣also␣L<"Adding␣new␣file␣types␣to␣the␣build␣process">␣for␣how␣to
create␣the␣stuff␣in␣F<blib/conf/>␣in␣the␣first␣place.


=head1␣EXAMPLES␣ON␣CPAN

Several␣distributions␣on␣CPAN␣are␣making␣good␣use␣of␣various␣features
of␣Module::Build.␣␣They␣can␣serve␣as␣real-world␣examples␣for␣others.


=head2␣SVN-Notify-Mirror

L<http://search.cpan.org/~jpeacock/SVN-Notify-Mirror/>

John␣Peacock,␣author␣of␣the␣C<SVN-Notify-Mirror>␣distribution,␣says:

=over␣4

=item␣1.␣Using␣C<auto_features>,␣I␣check␣to␣see␣whether␣two␣optional
modules␣are␣available␣-␣SVN::Notify::Config␣and␣Net::SSH;

=item␣2.␣If␣the␣S::N::Config␣module␣is␣loaded,␣I␣automatically
generate␣test␣files␣for␣it␣during␣Build␣(using␣the␣C<PL_files>
property).

=item␣3.␣If␣the␣C<ssh_feature>␣is␣available,␣I␣ask␣if␣the␣user␣wishes
to␣perform␣the␣ssh␣tests␣(since␣it␣requires␣a␣little␣preliminary
setup);

=item␣4.␣Only␣if␣the␣user␣has␣C<ssh_feature>␣and␣answers␣yes␣to␣the
testing,␣do␣I␣generate␣a␣test␣file.

I'm␣sure␣I␣could␣not␣have␣handled␣this␣complexity␣with␣EU::MM,␣but␣it
was␣very␣easy␣to␣do␣with␣M::B.

=back


=head2␣Modifying␣an␣action

Sometimes␣you␣might␣need␣an␣to␣have␣an␣action,␣say␣C<./Build␣install>,
do␣something␣unusual.␣␣For␣instance,␣you␣might␣need␣to␣change␣the
ownership␣of␣a␣file␣or␣do␣something␣else␣peculiar␣to␣your␣application.

You␣can␣subclass␣C<Module::Build>␣on␣the␣fly␣using␣the␣C<subclass()>
method␣and␣override␣the␣methods␣that␣perform␣the␣actions.␣␣You␣may
need␣to␣read␣through␣C<Module::Build::Authoring>␣and
C<Module::Build::API>␣to␣find␣the␣methods␣you␣want␣to␣override.␣␣All
"action"␣methods␣are␣implemented␣by␣a␣method␣called␣"ACTION_"␣followed
by␣the␣action's␣name,␣so␣here's␣an␣example␣of␣how␣it␣would␣work␣for
the␣C<install>␣action:

␣␣#␣Build.PL
␣␣use␣Module::Build;
␣␣my␣$class␣=␣Module::Build->subclass(
␣␣␣␣␣␣class␣=>␣"Module::Build::Custom",
␣␣␣␣␣␣code␣=>␣<<'SUBCLASS'␣);

␣␣sub␣ACTION_install␣{
␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣#␣YOUR␣CODE␣HERE
␣␣␣␣␣␣$self->SUPER::ACTION_install;
␣␣}
␣␣SUBCLASS

␣␣$class->new(
␣␣␣␣␣␣module_name␣=>␣'Your::Module',
␣␣␣␣␣␣#␣rest␣of␣the␣usual␣Module::Build␣parameters
␣␣)->create_build_script;


=head2␣Adding␣an␣action

You␣can␣add␣a␣new␣C<./Build>␣action␣simply␣by␣writing␣the␣method␣for
it␣in␣your␣subclass.␣␣Use␣C<depends_on>␣to␣declare␣that␣another␣action
must␣have␣been␣run␣before␣your␣action.

For␣example,␣let's␣say␣you␣wanted␣to␣be␣able␣to␣write␣C<./Build
commit>␣to␣test␣your␣code␣and␣commit␣it␣to␣Subversion.

␣␣#␣Build.PL
␣␣use␣Module::Build;
␣␣my␣$class␣=␣Module::Build->subclass(
␣␣␣␣␣␣class␣=>␣"Module::Build::Custom",
␣␣␣␣␣␣code␣=>␣<<'SUBCLASS'␣);

␣␣sub␣ACTION_commit␣{
␣␣␣␣␣␣my␣$self␣=␣shift;

␣␣␣␣␣␣$self->depends_on("test");
␣␣␣␣␣␣$self->do_system(qw(svn␣commit));
␣␣}
␣␣SUBCLASS


=head2␣Bundling␣Module::Build

Note:␣This␣section␣probably␣needs␣an␣update␣as␣the␣technology␣improves
(see␣contrib/bundle.pl␣in␣the␣distribution).

Suppose␣you␣want␣to␣use␣some␣new-ish␣features␣of␣Module::Build,
e.g.␣newer␣than␣the␣version␣of␣Module::Build␣your␣users␣are␣likely␣to
already␣have␣installed␣on␣their␣systems.␣␣The␣first␣thing␣you␣should
do␣is␣set␣C<configure_requires>␣to␣your␣minimum␣version␣of
Module::Build.␣␣See␣L<Module::Build::Authoring>.

But␣not␣every␣build␣system␣honors␣C<configure_requires>␣yet.␣␣Here's
how␣you␣can␣ship␣a␣copy␣of␣Module::Build,␣but␣still␣use␣a␣newer
installed␣version␣to␣take␣advantage␣of␣any␣bug␣fixes␣and␣upgrades.

First,␣install␣Module::Build␣into␣F<Your-Project/inc/Module-Build>.
CPAN␣will␣not␣index␣anything␣in␣the␣F<inc>␣directory␣so␣this␣copy␣will
not␣show␣up␣in␣CPAN␣searches.

␣␣␣␣cd␣Module-Build
␣␣␣␣perl␣Build.PL␣--install_base␣/path/to/Your-Project/inc/Module-Build
␣␣␣␣./Build␣test
␣␣␣␣./Build␣install

You␣should␣now␣have␣all␣the␣Module::Build␣.pm␣files␣in
F<Your-Project/inc/Module-Build/lib/perl5>.

Next,␣add␣this␣to␣the␣top␣of␣your␣F<Build.PL>.

␣␣␣␣my␣$Bundled_MB␣=␣0.30;␣␣#␣or␣whatever␣version␣it␣was.

␣␣␣␣#␣Find␣out␣what␣version␣of␣Module::Build␣is␣installed␣or␣fail␣quietly.
␣␣␣␣#␣This␣should␣be␣cross-platform.
␣␣␣␣my␣$Installed_MB␣=
␣␣␣␣␣␣␣␣`$^X␣-e␣"eval␣q{require␣Module::Build;␣print␣Module::Build->VERSION}␣or␣exit␣1";

␣␣␣␣#␣some␣operating␣systems␣put␣a␣newline␣at␣the␣end␣of␣every␣print.
␣␣␣␣chomp␣$Installed_MB;

␣␣␣␣$Installed_MB␣=␣0␣if␣$?;

␣␣␣␣#␣Use␣our␣bundled␣copy␣of␣Module::Build␣if␣it's␣newer␣than␣the␣installed.
␣␣␣␣unshift␣@INC,␣"inc/Module-Build/lib/perl5"␣if␣$Bundled_MB␣>␣$Installed_MB;

␣␣␣␣require␣Module::Build;

And␣write␣the␣rest␣of␣your␣F<Build.PL>␣normally.␣␣Module::Build␣will
remember␣your␣change␣to␣C<@INC>␣and␣use␣it␣when␣you␣run␣F<./Build>.

In␣the␣future,␣we␣hope␣to␣provide␣a␣more␣automated␣solution␣for␣this
scenario;␣see␣C<inc/latest.pm>␣in␣the␣Module::Build␣distribution␣for
one␣indication␣of␣the␣direction␣we're␣moving.


=head1␣AUTHOR

Ken␣Williams␣<kwilliams@cpan.org>


=head1␣COPYRIGHT

Copyright␣(c)␣2001-2008␣Ken␣Williams.␣␣All␣rights␣reserved.

This␣library␣is␣free␣software;␣you␣can␣redistribute␣it␣and/or
modify␣it␣under␣the␣same␣terms␣as␣Perl␣itself.


=head1␣SEE␣ALSO

perl(1),␣L<Module::Build>(3),␣L<Module::Build::Authoring>(3),
L<Module::Build::API>(3)

=cut
----------
Range: (5384519,5391545) (7026)
=pod

=head1␣NAME

Module::Pluggable␣-␣automatically␣give␣your␣module␣the␣ability␣to␣have␣plugins

=head1␣SYNOPSIS


Simple␣use␣Module::Pluggable␣-

␣␣␣␣package␣MyClass;
␣␣␣␣use␣Module::Pluggable;
␣␣␣␣

and␣then␣later␣...

␣␣␣␣use␣MyClass;
␣␣␣␣my␣$mc␣=␣MyClass->new();
␣␣␣␣#␣returns␣the␣names␣of␣all␣plugins␣installed␣under␣MyClass::Plugin::*
␣␣␣␣my␣@plugins␣=␣$mc->plugins();␣

=head1␣EXAMPLE

Why␣would␣you␣want␣to␣do␣this?␣Say␣you␣have␣something␣that␣wants␣to␣pass␣an
object␣to␣a␣number␣of␣different␣plugins␣in␣turn.␣For␣example␣you␣may␣
want␣to␣extract␣meta-data␣from␣every␣email␣you␣get␣sent␣and␣do␣something
with␣it.␣Plugins␣make␣sense␣here␣because␣then␣you␣can␣keep␣adding␣new␣
meta␣data␣parsers␣and␣all␣the␣logic␣and␣docs␣for␣each␣one␣will␣be␣
self␣contained␣and␣new␣handlers␣are␣easy␣to␣add␣without␣changing␣the␣
core␣code.␣For␣that,␣you␣might␣do␣something␣like␣...

␣␣␣␣package␣Email::Examiner;

␣␣␣␣use␣strict;
␣␣␣␣use␣Email::Simple;
␣␣␣␣use␣Module::Pluggable␣require␣=>␣1;

␣␣␣␣sub␣handle_email␣{
␣␣␣␣␣␣␣␣my␣$self␣␣=␣shift;
␣␣␣␣␣␣␣␣my␣$email␣=␣shift;

␣␣␣␣␣␣␣␣foreach␣my␣$plugin␣($self->plugins)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$plugin->examine($email);
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}



..␣and␣all␣the␣plugins␣will␣get␣a␣chance␣in␣turn␣to␣look␣at␣it.

This␣can␣be␣trivally␣extended␣so␣that␣plugins␣could␣save␣the␣email
somewhere␣and␣then␣no␣other␣plugin␣should␣try␣and␣do␣that.␣
Simply␣have␣it␣so␣that␣the␣C<examine>␣method␣returns␣C<1>␣if␣
it␣has␣saved␣the␣email␣somewhere.␣You␣might␣also␣wnat␣to␣be␣paranoid
and␣check␣to␣see␣if␣the␣plugin␣has␣an␣C<examine>␣method.

␣␣␣␣␣␣␣␣foreach␣my␣$plugin␣($self->plugins)␣{
␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣$plugin->can('examine');
␣␣␣␣␣␣␣␣␣␣␣␣last␣if␣␣␣␣␣$plugin->examine($email);
␣␣␣␣␣␣␣␣}


And␣so␣on.␣The␣sky's␣the␣limit.


=head1␣DESCRIPTION

Provides␣a␣simple␣but,␣hopefully,␣extensible␣way␣of␣having␣'plugins'␣for␣
your␣module.␣Obviously␣this␣isn't␣going␣to␣be␣the␣be␣all␣and␣end␣all␣of
solutions␣but␣it␣works␣for␣me.

Essentially␣all␣it␣does␣is␣export␣a␣method␣into␣your␣namespace␣that␣
looks␣through␣a␣search␣path␣for␣.pm␣files␣and␣turn␣those␣into␣class␣names.␣

Optionally␣it␣instantiates␣those␣classes␣for␣you.

=head1␣ADVANCED␣USAGE

␣␣␣␣
Alternatively,␣if␣you␣don't␣want␣to␣use␣'plugins'␣as␣the␣method␣...
␣␣␣␣
␣␣␣␣package␣MyClass;
␣␣␣␣use␣Module::Pluggable␣sub_name␣=>␣'foo';


and␣then␣later␣...

␣␣␣␣my␣@plugins␣=␣$mc->foo();


Or␣if␣you␣want␣to␣look␣in␣another␣namespace

␣␣␣␣package␣MyClass;
␣␣␣␣use␣Module::Pluggable␣search_path␣=>␣['Acme::MyClass::Plugin',␣'MyClass::Extend'];

or␣directory␣

␣␣␣␣use␣Module::Pluggable␣search_dirs␣=>␣['mylibs/Foo'];


Or␣if␣you␣want␣to␣instantiate␣each␣plugin␣rather␣than␣just␣return␣the␣name

␣␣␣␣package␣MyClass;
␣␣␣␣use␣Module::Pluggable␣instantiate␣=>␣'new';

and␣then

␣␣␣␣#␣whatever␣is␣passed␣to␣'plugins'␣will␣be␣passed␣
␣␣␣␣#␣to␣'new'␣for␣each␣plugin␣
␣␣␣␣my␣@plugins␣=␣$mc->plugins(@options);␣


alternatively␣you␣can␣just␣require␣the␣module␣without␣instantiating␣it

␣␣␣␣package␣MyClass;
␣␣␣␣use␣Module::Pluggable␣require␣=>␣1;

since␣requiring␣automatically␣searches␣inner␣packages,␣which␣may␣not␣be␣desirable,␣you␣can␣turn␣this␣off


␣␣␣␣package␣MyClass;
␣␣␣␣use␣Module::Pluggable␣require␣=>␣1,␣inner␣=>␣0;


You␣can␣limit␣the␣plugins␣loaded␣using␣the␣except␣option,␣either␣as␣a␣string,
array␣ref␣or␣regex

␣␣␣␣package␣MyClass;
␣␣␣␣use␣Module::Pluggable␣except␣=>␣'MyClass::Plugin::Foo';

or

␣␣␣␣package␣MyClass;
␣␣␣␣use␣Module::Pluggable␣except␣=>␣['MyClass::Plugin::Foo',␣'MyClass::Plugin::Bar'];

or

␣␣␣␣package␣MyClass;
␣␣␣␣use␣Module::Pluggable␣except␣=>␣qr/^MyClass::Plugin::(Foo|Bar)$/;


and␣similarly␣for␣only␣which␣will␣only␣load␣plugins␣which␣match.

Remember␣you␣can␣use␣the␣module␣more␣than␣once

␣␣␣␣package␣MyClass;
␣␣␣␣use␣Module::Pluggable␣search_path␣=>␣'MyClass::Filters'␣sub_name␣=>␣'filters';
␣␣␣␣use␣Module::Pluggable␣search_path␣=>␣'MyClass::Plugins'␣sub_name␣=>␣'plugins';

and␣then␣later␣...

␣␣␣␣my␣@filters␣=␣$self->filters;
␣␣␣␣my␣@plugins␣=␣$self->plugins;

=head1␣INNER␣PACKAGES

If␣you␣have,␣for␣example,␣a␣file␣B<lib/Something/Plugin/Foo.pm>␣that
contains␣package␣definitions␣for␣both␣C<Something::Plugin::Foo>␣and␣
C<Something::Plugin::Bar>␣then␣as␣long␣as␣you␣either␣have␣either␣
the␣B<require>␣or␣B<instantiate>␣option␣set␣then␣we'll␣also␣find␣
C<Something::Plugin::Bar>.␣Nifty!

=head1␣OPTIONS

You␣can␣pass␣a␣hash␣of␣options␣when␣importing␣this␣module.

The␣options␣can␣be␣...

=head2␣sub_name

The␣name␣of␣the␣subroutine␣to␣create␣in␣your␣namespace.␣

By␣default␣this␣is␣'plugins'

=head2␣search_path

An␣array␣ref␣of␣namespaces␣to␣look␣in.␣

=head2␣search_dirs␣

An␣array␣ref␣of␣directorys␣to␣look␣in␣before␣@INC.

=head2␣instantiate

Call␣this␣method␣on␣the␣class.␣In␣general␣this␣will␣probably␣be␣'new'
but␣it␣can␣be␣whatever␣you␣want.␣Whatever␣arguments␣are␣passed␣to␣'plugins'␣
will␣be␣passed␣to␣the␣method.

The␣default␣is␣'undef'␣i.e␣just␣return␣the␣class␣name.

=head2␣require

Just␣require␣the␣class,␣don't␣instantiate␣(overrides␣'instantiate');

=head2␣inner

If␣set␣to␣0␣will␣B<not>␣search␣inner␣packages.␣
If␣set␣to␣1␣will␣override␣C<require>.

=head2␣only

Takes␣a␣string,␣array␣ref␣or␣regex␣describing␣the␣names␣of␣the␣only␣plugins␣to␣
return.␣Whilst␣this␣may␣seem␣perverse␣...␣well,␣it␣is.␣But␣it␣also␣
makes␣sense.␣Trust␣me.

=head2␣except

Similar␣to␣C<only>␣it␣takes␣a␣description␣of␣plugins␣to␣exclude␣
from␣returning.␣This␣is␣slightly␣less␣perverse.

=head2␣package

This␣is␣for␣use␣by␣extension␣modules␣which␣build␣on␣C<Module::Pluggable>:
passing␣a␣C<package>␣option␣allows␣you␣to␣place␣the␣plugin␣method␣in␣a
different␣package␣other␣than␣your␣own.

=head2␣file_regex

By␣default␣C<Module::Pluggable>␣only␣looks␣for␣I<.pm>␣files.

By␣supplying␣a␣new␣C<file_regex>␣then␣you␣can␣change␣this␣behaviour␣e.g

␣␣␣␣file_regex␣=>␣qr/\.plugin$/

=head2␣include_editor_junk

By␣default␣C<Module::Pluggable>␣ignores␣files␣that␣look␣like␣they␣were
left␣behind␣by␣editors.␣Currently␣this␣means␣files␣ending␣in␣F<~>␣(~),
the␣extensions␣F<.swp>␣or␣F<.swo>,␣or␣files␣beginning␣with␣F<.#>.

Setting␣C<include_editor_junk>␣changes␣C<Module::Pluggable>␣so␣it␣does
not␣ignore␣any␣files␣it␣finds.


=head1␣METHODs

=head2␣search_path

The␣method␣C<search_path>␣is␣exported␣into␣you␣namespace␣as␣well.␣
You␣can␣call␣that␣at␣any␣time␣to␣change␣or␣replace␣the␣
search_path.

␣␣␣␣$self->search_path(␣add␣=>␣"New::Path"␣);␣#␣add
␣␣␣␣$self->search_path(␣new␣=>␣"New::Path"␣);␣#␣replace



=head1␣FUTURE␣PLANS

This␣does␣everything␣I␣need␣and␣I␣can't␣really␣think␣of␣any␣other␣
features␣I␣want␣to␣add.␣Famous␣last␣words␣of␣course

Recently␣tried␣fixed␣to␣find␣inner␣packages␣and␣to␣make␣it␣
'just␣work'␣with␣PAR␣but␣there␣are␣still␣some␣issues.


However␣suggestions␣(and␣patches)␣are␣welcome.

=head1␣AUTHOR

Simon␣Wistow␣<simon@thegestalt.org>

=head1␣COPYING

Copyright,␣2006␣Simon␣Wistow

Distributed␣under␣the␣same␣terms␣as␣Perl␣itself.

=head1␣BUGS

None␣known.

=head1␣SEE␣ALSO

L<File::Spec>,␣L<File::Find>,␣L<File::Basename>,␣L<Class::Factory::Util>,␣L<Module::Pluggable::Ordered>

=cut␣
----------
Range: (5781658,6180523) (398865)
print␣$fh␣<<EOF;
package␣$name;

\$VERSION␣=␣'0.01';

1;

package␣CPANPLUS::Module::Signature;

use␣strict;


use␣Cwd;
use␣CPANPLUS::Error;
use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[check];
use␣Module::Load::Conditional␣␣␣qw[can_load];


###␣detached␣sig,␣not␣actually␣used␣afaik␣--kane␣###
#sub␣get_signature␣{
#␣␣␣␣my␣$self␣=␣shift;
#
#␣␣␣␣my␣$clone␣=␣$self->clone;
#␣␣␣␣$clone->package(␣$self->package␣.␣'.sig'␣);
#
#␣␣␣␣return␣$clone->fetch;
#}

sub␣check_signature␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$cb␣=␣$self->parent;
␣␣␣␣my␣$conf␣=␣$cb->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$verbose;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣verbose␣=>␣{default␣=>␣$conf->get_conf('verbose'),␣store␣=>␣\$verbose},
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣my␣$dir␣=␣$self->status->extract␣or␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(␣loc(␣"Do␣not␣know␣what␣dir␣'%1'␣was␣extracted␣to;␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Cannot␣check␣signature",␣$self->module␣)␣),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣);

␣␣␣␣my␣$cwd␣=␣cwd();
␣␣␣␣unless(␣$cb->_chdir(␣dir␣=>␣$dir␣)␣)␣{
␣␣␣␣␣␣␣␣error(loc(␣␣"Could␣not␣chdir␣to␣'%1',␣cannot␣verify␣distribution␣'%2'",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$dir,␣$self->module␣));
␣␣␣␣␣␣␣␣return;
␣␣␣␣}


␣␣␣␣###␣check␣prerequisites
␣␣␣␣my␣$flag;
␣␣␣␣my␣$use_list␣=␣{␣'Module::Signature'␣=>␣'0.06'␣};
␣␣␣␣if(␣can_load(␣modules␣=>␣$use_list,␣verbose␣=>␣1␣)␣)␣{
␣␣␣␣␣␣␣␣my␣$rv␣=␣Module::Signature::verify();

␣␣␣␣␣␣␣␣unless␣($rv␣eq␣Module::Signature::SIGNATURE_OK()␣or
␣␣␣␣␣␣␣␣␣␣␣␣$rv␣eq␣Module::Signature::SIGNATURE_MISSING()
␣␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$flag++;␣␣␣␣#␣whoops,␣bad␣sig
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣$cb->_chdir(␣dir␣=>␣$cwd␣);
␣␣␣␣return␣$flag␣?␣0␣:␣1;
}

1;
package␣CPANPLUS::Module::Author::Fake;


use␣CPANPLUS::Module::Author;
use␣CPANPLUS::Internals;
use␣CPANPLUS::Error;

use␣strict;
use␣vars␣␣␣␣␣␣␣␣␣␣␣␣qw[@ISA];
use␣Params::Check␣␣␣qw[check];

@ISA␣=␣qw[CPANPLUS::Module::Author];

$Params::Check::VERBOSE␣=␣1;

=pod

=head1␣NAME

CPANPLUS::Module::Author::Fake

=head1␣SYNOPSIS

␣␣␣␣my␣$auth␣=␣CPANPLUS::Module::Author::Fake->new(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣author␣␣=>␣'Foo␣Bar',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣email␣␣␣=>␣'luser@foo.com',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣cpanid␣␣=>␣'FOO',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣_id␣␣␣␣␣=>␣$cpan->id,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

=head1␣DESCRIPTION

A␣class␣for␣creating␣fake␣author␣objects,␣for␣shortcut␣use␣internally
by␣CPANPLUS.

Inherits␣from␣C<CPANPLUS::Module::Author>.

=head1␣METHODS

=head2␣new(␣_id␣=>␣DIGIT␣)

Creates␣a␣dummy␣author␣object.␣It␣can␣take␣the␣same␣options␣as
C<<␣CPANPLUS::Module::Author->new␣>>,␣but␣will␣fill␣in␣default␣ones
if␣none␣are␣provided.␣Only␣the␣_id␣key␣is␣required.

=cut

sub␣new␣{
␣␣␣␣my␣$class␣=␣shift;
␣␣␣␣my␣%hash␣␣=␣@_;

␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣author␣␣=>␣{␣default␣=>␣'CPANPLUS␣Internals'␣},
␣␣␣␣␣␣␣␣email␣␣␣=>␣{␣default␣=>␣'cpanplus-info@lists.sf.net'␣},
␣␣␣␣␣␣␣␣cpanid␣␣=>␣{␣default␣=>␣'CPANPLUS'␣},
␣␣␣␣␣␣␣␣_id␣␣␣␣␣=>␣{␣default␣=>␣CPANPLUS::Internals->_last_id␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣my␣$obj␣=␣CPANPLUS::Module::Author->new(␣%$args␣)␣or␣return;

␣␣␣␣unless(␣$obj->_id␣)␣{
␣␣␣␣␣␣␣␣error(loc("No␣'%1'␣specified␣--␣No␣CPANPLUS␣object␣associated!",'_id'));
␣␣␣␣␣␣␣␣return;
␣␣␣␣}␣

␣␣␣␣###␣rebless␣object␣###
␣␣␣␣return␣bless␣$obj,␣$class;
}

1;


#␣Local␣variables:
#␣c-indentation-style:␣bsd
#␣c-basic-offset:␣4
#␣indent-tabs-mode:␣nil
#␣End:
#␣vim:␣expandtab␣shiftwidth=4:
package␣CPANPLUS::Module::Fake;


use␣CPANPLUS::Error;
use␣CPANPLUS::Module;
use␣CPANPLUS::Module::Author::Fake;
use␣CPANPLUS::Internals;

use␣strict;
use␣vars␣␣␣␣␣␣␣␣␣␣␣␣qw[@ISA];
use␣Params::Check␣␣␣qw[check];

@ISA␣=␣qw[CPANPLUS::Module];
$Params::Check::VERBOSE␣=␣1;

=pod

=head1␣NAME

CPANPLUS::Module::Fake

=head1␣SYNOPSIS

␣␣␣␣my␣$obj␣=␣CPANPLUS::Module::Fake->new(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣module␣␣=>␣'Foo',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣=>␣'ftp/path/to/foo',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣author␣␣=>␣CPANPLUS::Module::Author::Fake->new,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣package␣=>␣'fake-1.1.tgz',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣_id␣␣␣␣␣=>␣$cpan->_id,
␣␣␣␣␣␣␣␣␣␣␣␣);

=head1␣DESCRIPTION

A␣class␣for␣creating␣fake␣module␣objects,␣for␣shortcut␣use␣internally
by␣CPANPLUS.

Inherits␣from␣C<CPANPLUS::Module>.

=head1␣METHODS

=head2␣new(␣module␣=>␣$mod,␣path␣=>␣$path,␣package␣=>␣$pkg,␣[_id␣=>␣DIGIT]␣)

Creates␣a␣dummy␣module␣object␣from␣the␣above␣parameters.␣It␣can
take␣more␣options␣(same␣as␣C<<␣CPANPLUS::Module->new␣>>␣but␣the␣above
are␣required.

=cut

sub␣new␣{
␣␣␣␣my␣$class␣=␣shift;
␣␣␣␣my␣%hash␣␣=␣@_;
␣␣␣␣
␣␣␣␣local␣$Params::Check::ALLOW_UNKNOWN␣=␣1;
␣␣␣␣
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣module␣␣=>␣{␣required␣=>␣1␣},
␣␣␣␣␣␣␣␣path␣␣␣␣=>␣{␣required␣=>␣1␣},
␣␣␣␣␣␣␣␣package␣=>␣{␣required␣=>␣1␣},
␣␣␣␣␣␣␣␣_id␣␣␣␣␣=>␣{␣default␣=>␣CPANPLUS::Internals->_last_id␣},
␣␣␣␣␣␣␣␣author␣␣=>␣{␣default␣=>␣''␣},
␣␣␣␣};
␣␣␣␣
␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣
␣␣␣␣$args->{author}␣||=␣CPANPLUS::Module::Author::Fake->new(␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣_id␣=>␣$args->{_id}␣);
␣␣␣␣
␣␣␣␣my␣$obj␣=␣CPANPLUS::Module->new(␣%$args␣)␣or␣return;
␣␣␣␣
␣␣␣␣unless(␣$obj->_id␣)␣{
␣␣␣␣␣␣␣␣error(loc("No␣'%1'␣specified␣--␣No␣CPANPLUS␣object␣associated!",'_id'));
␣␣␣␣␣␣␣␣return;
␣␣␣␣}␣␣␣␣␣␣␣␣
␣␣␣␣
␣␣␣␣###␣rebless␣object␣###
␣␣␣␣return␣bless␣$obj,␣$class;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
}␣␣␣␣

1;

#␣Local␣variables:
#␣c-indentation-style:␣bsd
#␣c-basic-offset:␣4
#␣indent-tabs-mode:␣nil
#␣End:
#␣vim:␣expandtab␣shiftwidth=4:␣␣␣␣
package␣CPANPLUS::Module::Checksums;

use␣strict;
use␣vars␣qw[@ISA];


use␣CPANPLUS::Error;
use␣CPANPLUS::Internals::Constants;

use␣FileHandle;

use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';
use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[check];
use␣Module::Load::Conditional␣␣␣qw[can_load];

$Params::Check::VERBOSE␣=␣1;

@ISA␣=␣qw[␣CPANPLUS::Module::Signature␣];

=head1␣NAME

CPANPLUS::Module::Checksums

=head1␣SYNOPSIS

␣␣␣␣$file␣␣␣=␣$modobj->checksums;
␣␣␣␣$bool␣␣␣=␣$mobobj->_validate_checksum;

=head1␣DESCRIPTION

This␣is␣a␣class␣that␣provides␣functions␣for␣checking␣the␣checksum␣
of␣a␣distribution.␣Should␣not␣be␣loaded␣directly,␣but␣used␣via␣the
interface␣provided␣via␣C<CPANPLUS::Module>.

=head1␣METHODS

=head2␣$mod->checksums

Fetches␣the␣checksums␣file␣for␣this␣module␣object.
For␣the␣options␣it␣can␣take,␣see␣C<CPANPLUS::Module::fetch()>.

Returns␣the␣location␣of␣the␣checksums␣file␣on␣success␣and␣false
on␣error.

The␣location␣of␣the␣checksums␣file␣is␣also␣stored␣as

␣␣␣␣$mod->status->checksums

=cut

sub␣checksums␣{
␣␣␣␣my␣$mod␣=␣shift␣or␣return;

␣␣␣␣my␣$file␣=␣$mod->_get_checksums_file(␣@_␣);

␣␣␣␣return␣$mod->status->checksums(␣$file␣)␣if␣$file;

␣␣␣␣return;
}

###␣checks␣if␣the␣package␣checksum␣matches␣the␣one
###␣from␣the␣checksums␣file
sub␣_validate_checksum␣{
␣␣␣␣my␣$self␣=␣shift;␣#must␣be␣isa␣CPANPLUS::Module
␣␣␣␣my␣$conf␣=␣$self->parent->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$verbose;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣verbose␣=>␣{␣␣␣␣default␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣=>␣\$verbose␣},
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣###␣if␣we␣can't␣check␣it,␣we␣must␣assume␣it's␣ok␣###
␣␣␣␣return␣$self->status->checksum_ok(1)
␣␣␣␣␣␣␣␣␣␣␣␣unless␣can_load(␣modules␣=>␣{␣'Digest::MD5'␣=>␣'0.0'␣}␣);
␣␣␣␣#class␣CPANPLUS::Module::Status␣is␣runtime-generated

␣␣␣␣my␣$file␣=␣$self->_get_checksums_file(␣verbose␣=>␣$verbose␣)␣or␣(
␣␣␣␣␣␣␣␣error(loc(q[Could␣not␣fetch␣'%1'␣file],␣CHECKSUMS)),␣return␣);

␣␣␣␣$self->_check_signature_for_checksum_file(␣file␣=>␣$file␣)␣or␣(
␣␣␣␣␣␣␣␣error(loc(q[Could␣not␣verify␣'%1'␣file],␣CHECKSUMS)),␣return␣);
␣␣␣␣#for␣whole␣CHECKSUMS␣file

␣␣␣␣my␣$href␣=␣$self->_parse_checksums_file(␣file␣=>␣$file␣)␣or␣(
␣␣␣␣␣␣␣␣error(loc(q[Could␣not␣parse␣'%1'␣file],␣CHECKSUMS)),␣return␣);

␣␣␣␣my␣$size␣=␣$href->{␣$self->package␣}->{'size'};

␣␣␣␣###␣the␣checksums␣file␣tells␣us␣the␣size␣of␣the␣archive
␣␣␣␣###␣but␣the␣downloaded␣file␣is␣of␣different␣size
␣␣␣␣if(␣defined␣$size␣)␣{
␣␣␣␣␣␣␣␣if(␣not␣(-s␣$self->status->fetch␣==␣$size)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc(␣␣"Archive␣size␣does␣not␣match␣for␣'%1':␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"size␣is␣'%2'␣but␣should␣be␣'%3'",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->package,␣-s␣$self->status->fetch,␣$size));
␣␣␣␣␣␣␣␣␣␣␣␣return␣$self->status->checksum_ok(0);
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣msg(loc("Archive␣size␣is␣not␣known␣for␣'%1'",$self->package),$verbose);
␣␣␣␣}
␣␣␣␣
␣␣␣␣my␣$md5␣=␣$href->{␣$self->package␣}->{'md5'};

␣␣␣␣unless(␣defined␣$md5␣)␣{
␣␣␣␣␣␣␣␣msg(loc("No␣'md5'␣checksum␣known␣for␣'%1'",$self->package),$verbose);

␣␣␣␣␣␣␣␣return␣$self->status->checksum_ok(1);
␣␣␣␣}

␣␣␣␣$self->status->checksum_value($md5);


␣␣␣␣my␣$fh␣=␣FileHandle->new(␣$self->status->fetch␣)␣or␣return;
␣␣␣␣binmode␣$fh;

␣␣␣␣my␣$ctx␣=␣Digest::MD5->new;
␣␣␣␣$ctx->addfile(␣$fh␣);

␣␣␣␣my␣$flag␣=␣$ctx->hexdigest␣eq␣$md5;
␣␣␣␣$flag
␣␣␣␣␣␣␣␣?␣msg(loc("Checksum␣matches␣for␣'%1'",␣$self->package),$verbose)
␣␣␣␣␣␣␣␣:␣error(loc("Checksum␣does␣not␣match␣for␣'%1':␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"MD5␣is␣'%2'␣but␣should␣be␣'%3'",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->package,␣$ctx->hexdigest,␣$md5),$verbose);


␣␣␣␣return␣$self->status->checksum_ok(1)␣if␣$flag;
␣␣␣␣return␣$self->status->checksum_ok(0);
}


###␣fetches␣the␣module␣objects␣checksum␣file␣###
sub␣_get_checksums_file␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$clone␣=␣$self->clone;
␣␣␣␣$clone->package(␣CHECKSUMS␣);

␣␣␣␣my␣$file␣=␣$clone->fetch(␣ttl␣=>␣3600,␣%hash␣)␣or␣return;

␣␣␣␣return␣$file;
}

sub␣_parse_checksums_file␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$file;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣file␣␣␣␣=>␣{␣required␣=>␣1,␣allow␣=>␣FILE_READABLE,␣store␣=>␣\$file␣},
␣␣␣␣};
␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣);

␣␣␣␣my␣$fh␣=␣OPEN_FILE->(␣$file␣)␣or␣return;

␣␣␣␣###␣loop␣over␣the␣header,␣there␣might␣be␣a␣pgp␣signature␣###
␣␣␣␣my␣$signed;
␣␣␣␣while␣(local␣$_␣=␣<$fh>)␣{
␣␣␣␣␣␣␣␣last␣if␣/^\$cksum␣=␣\{\s*$/;␣␣␣␣#␣skip␣till␣this␣line
␣␣␣␣␣␣␣␣my␣$header␣=␣PGP_HEADER;␣␣␣␣␣␣␣␣#␣but␣be␣tolerant␣of␣whitespace
␣␣␣␣␣␣␣␣$signed␣=␣1␣if␣/^${header}\s*$/;#␣due␣to␣crossplatform␣linebreaks
␣␣␣}

␣␣␣␣###␣read␣the␣filehandle,␣parse␣it␣rather␣than␣eval␣it,␣even␣though␣it
␣␣␣␣###␣*should*␣be␣valid␣perl␣code
␣␣␣␣my␣$dist;
␣␣␣␣my␣$cksum␣=␣{};
␣␣␣␣while␣(local␣$_␣=␣<$fh>)␣{

␣␣␣␣␣␣␣␣if␣(/^\s*'([^']+)'␣=>␣\{\s*$/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$dist␣=␣$1;

␣␣␣␣␣␣␣␣}␣elsif␣(/^\s*'([^']+)'␣=>␣'?([^'\n]+)'?,?\s*$/␣and␣defined␣$dist)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$cksum->{$dist}{$1}␣=␣$2;

␣␣␣␣␣␣␣␣}␣elsif␣(/^\s*}[,;]?\s*$/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣undef␣$dist;

␣␣␣␣␣␣␣␣}␣elsif␣(/^__END__\s*$/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣last;

␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(␣loc("Malformed␣%1␣line:␣%2",␣CHECKSUMS,␣$_)␣);
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣return␣$cksum;
}

sub␣_check_signature_for_checksum_file␣{
␣␣␣␣my␣$self␣=␣shift;

␣␣␣␣my␣$conf␣=␣$self->parent->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣###␣you␣don't␣want␣to␣check␣signatures,
␣␣␣␣###␣so␣let's␣just␣return␣true;
␣␣␣␣return␣1␣unless␣$conf->get_conf('signature');

␣␣␣␣my($force,$file,$verbose);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣file␣␣␣␣=>␣{␣required␣=>␣1,␣allow␣=>␣FILE_READABLE,␣store␣=>␣\$file␣},
␣␣␣␣␣␣␣␣force␣␣␣=>␣{␣default␣=>␣$conf->get_conf('force'),␣store␣=>␣\$force␣},
␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),␣store␣=>␣\$verbose␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣my␣$fh␣=␣OPEN_FILE->($file)␣or␣return;

␣␣␣␣my␣$signed;
␣␣␣␣while␣(local␣$_␣=␣<$fh>)␣{
␣␣␣␣␣␣␣␣my␣$header␣=␣PGP_HEADER;
␣␣␣␣␣␣␣␣$signed␣=␣1␣if␣/^$header$/;
␣␣␣␣}

␣␣␣␣if␣(␣!$signed␣)␣{
␣␣␣␣␣␣␣␣msg(loc("No␣signature␣found␣in␣%1␣file␣'%2'",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CHECKSUMS,␣$file),␣$verbose);

␣␣␣␣␣␣␣␣return␣1␣unless␣$force;

␣␣␣␣␣␣␣␣error(␣loc(␣"%1␣file␣'%2'␣is␣not␣signed␣--␣aborting",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CHECKSUMS,␣$file␣)␣);
␣␣␣␣␣␣␣␣return;

␣␣␣␣}

␣␣␣␣if(␣can_load(␣modules␣=>␣{␣'Module::Signature'␣=>␣'0.06'␣}␣)␣)␣{
␣␣␣␣␣␣␣␣#␣local␣$Module::Signature::SIGNATURE␣=␣$file;
␣␣␣␣␣␣␣␣#␣...␣check␣signatures␣...
␣␣␣␣}

␣␣␣␣return␣1;
}



#␣Local␣variables:
#␣c-indentation-style:␣bsd
#␣c-basic-offset:␣4
#␣indent-tabs-mode:␣nil
#␣End:
#␣vim:␣expandtab␣shiftwidth=4:

1;
package␣CPANPLUS::Module::Author;

use␣strict;

use␣CPANPLUS::Error;
use␣CPANPLUS::Internals::Constants;
use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[check];
use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';

local␣$Params::Check::VERBOSE␣=␣1;

=pod

=head1␣NAME

CPANPLUS::Module::Author

=head1␣SYNOPSIS

␣␣␣␣my␣$author␣=␣CPANPLUS::Module::Author->new(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣author␣␣=>␣'Jack␣Ashton',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣cpanid␣␣=>␣'JACKASH',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣_id␣␣␣␣␣=>␣INTERNALS_OBJECT_ID,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣$author->cpanid;
␣␣␣␣$author->author;
␣␣␣␣$author->email;

␣␣␣␣@dists␣␣=␣$author->distributions;
␣␣␣␣@mods␣␣␣=␣$author->modules;

␣␣␣␣@accessors␣=␣CPANPLUS::Module::Author->accessors;

=head1␣DESCRIPTION

C<CPANPLUS::Module::Author>␣creates␣objects␣from␣the␣information␣in␣the
source␣files.␣These␣can␣then␣be␣used␣to␣query␣on.

These␣objects␣should␣only␣be␣created␣internally.␣For␣C<fake>␣objects,
there's␣the␣C<CPANPLUS::Module::Author::Fake>␣class.

=head1␣ACCESSORS

An␣objects␣of␣this␣class␣has␣the␣following␣accessors:

=over␣4

=item␣author

Name␣of␣the␣author.

=item␣cpanid

The␣CPAN␣id␣of␣the␣author.

=item␣email

The␣email␣address␣of␣the␣author,␣which␣defaults␣to␣''␣if␣not␣provided.

=item␣parent

The␣C<CPANPLUS::Internals::Object>␣that␣spawned␣this␣module␣object.

=back

=cut

my␣$tmpl␣=␣{
␣␣␣␣author␣␣␣␣␣␣=>␣{␣required␣=>␣1␣},␣␣␣#␣full␣name␣of␣the␣author
␣␣␣␣cpanid␣␣␣␣␣␣=>␣{␣required␣=>␣1␣},␣␣␣#␣cpan␣id
␣␣␣␣email␣␣␣␣␣␣␣=>␣{␣default␣=>␣''␣},␣␣␣#␣email␣address␣of␣the␣author
␣␣␣␣_id␣␣␣␣␣␣␣␣␣=>␣{␣required␣=>␣1␣},␣␣␣#␣id␣of␣the␣Internals␣object␣that␣spawned␣us
};

###␣autogenerate␣accessors␣###
for␣my␣$key␣(␣keys␣%$tmpl␣)␣{
␣␣␣␣no␣strict␣'refs';
␣␣␣␣*{__PACKAGE__."::$key"}␣=␣sub␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣$self->{$key}␣=␣$_[0]␣if␣@_;
␣␣␣␣␣␣␣␣return␣$self->{$key};
␣␣␣␣}
}

sub␣parent␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$obj␣␣=␣CPANPLUS::Internals->_retrieve_id(␣$self->_id␣);

␣␣␣␣return␣$obj;
}

=pod

=head1␣METHODS

=head2␣$auth␣=␣CPANPLUS::Module::Author->new(␣author␣=>␣AUTHOR_NAME,␣cpanid␣=>␣CPAN_ID,␣_id␣=>␣INTERNALS_ID␣[,␣email␣=>␣AUTHOR_EMAIL]␣)

This␣method␣returns␣a␣C<CPANPLUS::Module::Author>␣object,␣based␣on␣the␣given
parameters.

Returns␣false␣on␣failure.

=cut

sub␣new␣{
␣␣␣␣my␣$class␣␣␣=␣shift;
␣␣␣␣my␣%hash␣␣␣␣=␣@_;

␣␣␣␣###␣don't␣check␣the␣template␣for␣sanity
␣␣␣␣###␣--␣we␣know␣it's␣good␣and␣saves␣a␣lot␣of␣performance
␣␣␣␣local␣$Params::Check::SANITY_CHECK_TEMPLATE␣=␣0;

␣␣␣␣my␣$object␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣return␣bless␣$object,␣$class;
}

=pod

=head2␣@mod_objs␣=␣$auth->modules()

Return␣a␣list␣of␣module␣objects␣this␣author␣has␣released.

=cut

sub␣modules␣{
␣␣␣␣my␣$self␣␣␣␣=␣shift;
␣␣␣␣my␣$cb␣␣␣␣␣␣=␣$self->parent;

␣␣␣␣my␣$aref␣=␣$cb->_search_module_tree(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣type␣␣␣␣=>␣'author',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣XXX,␣depending␣on␣backend,␣this␣is␣either␣an␣object
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣or␣the␣cpanid␣string.␣Dont␣know␣an␣elegant␣way␣to
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣solve␣this␣right␣now,␣so␣passing␣both
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣allow␣␣␣=>␣[$self,␣$self->cpanid],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣return␣@$aref␣if␣$aref;
␣␣␣␣return;
}

=pod

=head2␣@dists␣=␣$auth->distributions()

Returns␣a␣list␣of␣module␣objects␣representing␣all␣the␣distributions
this␣author␣has␣released.

=cut

sub␣distributions␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣local␣$Params::Check::ALLOW_UNKNOWN␣=␣1;
␣␣␣␣local␣$Params::Check::NO_DUPLICATES␣=␣1;

␣␣␣␣my␣$mod;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣module␣␣=>␣{␣default␣=>␣'',␣store␣=>␣\$mod␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣###␣if␣we␣didn't␣get␣a␣module␣object␣passed,␣we'll␣find␣one␣ourselves␣###
␣␣␣␣unless(␣$mod␣)␣{
␣␣␣␣␣␣␣␣my␣@list␣=␣$self->modules;
␣␣␣␣␣␣␣␣if(␣@list␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$mod␣=␣$list[0];
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(␣loc(␣"This␣author␣has␣released␣no␣modules"␣)␣);
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣my␣$file␣=␣$mod->checksums(␣%hash␣);
␣␣␣␣my␣$href␣=␣$mod->_parse_checksums_file(␣file␣=>␣$file␣)␣or␣return;

␣␣␣␣my␣@rv;
␣␣␣␣for␣my␣$name␣(␣keys␣%$href␣)␣{

␣␣␣␣␣␣␣␣###␣shortcut␣asap,␣so␣we␣avoid␣extra␣ops.␣On␣big␣checksums␣files
␣␣␣␣␣␣␣␣###␣the␣call␣to␣clone()␣takes␣up␣a␣lot␣of␣time.
␣␣␣␣␣␣␣␣###␣.meta␣files␣are␣now␣also␣in␣the␣checksums␣file,
␣␣␣␣␣␣␣␣###␣which␣means␣we␣have␣to␣filter␣out␣things␣that␣dont
␣␣␣␣␣␣␣␣###␣match␣our␣regex
␣␣␣␣␣␣␣␣next␣if␣$mod->package_extension(␣$name␣)␣eq␣META_EXT;

␣␣␣␣␣␣␣␣###␣used␣to␣do␣this␣wiht␣->clone.␣However,␣that␣calls␣->dslip,
␣␣␣␣␣␣␣␣###␣(which␣is␣wrong␣anyway,␣as␣we're␣doing␣a␣different␣module),
␣␣␣␣␣␣␣␣###␣which␣in␣turn␣calls␣->contains,␣which␣scans␣the␣entire
␣␣␣␣␣␣␣␣###␣module␣tree␣using␣_search_module_tree,␣which␣uses␣P::C
␣␣␣␣␣␣␣␣###␣and␣is␣therefor␣VERY␣VERY␣slow.
␣␣␣␣␣␣␣␣###␣so␣let's␣do␣this␣the␣direct␣way␣for␣speed␣ups.
␣␣␣␣␣␣␣␣my␣$dist␣=␣CPANPLUS::Module::Fake->new(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣module␣␣=>␣␣do␣{␣my␣$m␣=␣$mod->package_name(␣$name␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$m␣=~␣s/-/::/g;␣$m;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣},␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣version␣=>␣␣$mod->package_version(␣␣$name␣),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣package␣=>␣␣$name,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣=>␣␣$mod->path,␣␣␣␣␣#␣same␣author␣after␣all
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣author␣␣=>␣␣$mod->author,␣␣␣#␣same␣author␣after␣all
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣mtime␣␣␣=>␣␣$href->{$name}->{'mtime'},␣␣#␣release␣date
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣␣␣␣␣push␣@rv,␣$dist;
␣␣␣␣}

␣␣␣␣return␣@rv;
}


=pod

=head1␣CLASS␣METHODS

=head2␣accessors␣()

Returns␣a␣list␣of␣all␣accessor␣methods␣to␣the␣object

=cut

sub␣accessors␣{␣return␣keys␣%$tmpl␣};

1;

#␣Local␣variables:
#␣c-indentation-style:␣bsd
#␣c-basic-offset:␣4
#␣indent-tabs-mode:␣nil
#␣End:
#␣vim:␣expandtab␣shiftwidth=4:
package␣CPANPLUS::Internals::Utils::Autoflush;

BEGIN␣{␣$|++␣};

1;
package␣CPANPLUS::Internals::Search;

use␣strict;

use␣CPANPLUS::Error;
use␣CPANPLUS::Internals::Constants;
use␣CPANPLUS::Module;
use␣CPANPLUS::Module::Author;

use␣File::Find;
use␣File::Spec;

use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[check␣allow];
use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';

$Params::Check::VERBOSE␣=␣1;

=pod

=head1␣NAME

CPANPLUS::Internals::Search

=head1␣SYNOPSIS

␣␣␣␣my␣$aref␣=␣$cpan->_search_module_tree(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣type␣␣␣␣=>␣'package',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣allow␣␣␣=>␣[qr/DBI/],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣my␣$aref␣=␣$cpan->_search_author_tree(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣type␣␣␣␣=>␣'cpanid',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣data␣␣␣␣=>␣\@old_results,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣allow␣␣␣=>␣[qw|KANE␣AUTRIJUS|],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣my␣$aref␣=␣$cpan->_all_installed(␣);

=head1␣DESCRIPTION

The␣functions␣in␣this␣module␣are␣designed␣to␣find␣module(objects)
based␣on␣certain␣criteria␣and␣return␣them.

=head1␣METHODS

=head2␣_search_module_tree(␣type␣=>␣TYPE,␣allow␣=>␣\@regexes,␣[data␣=>␣\@previous_results␣]␣)

Searches␣the␣moduletree␣for␣module␣objects␣matching␣the␣criteria␣you
specify.␣Returns␣an␣array␣ref␣of␣module␣objects␣on␣success,␣and␣false
on␣failure.

It␣takes␣the␣following␣arguments:

=over␣4

=item␣type

This␣can␣be␣any␣of␣the␣accessors␣for␣the␣C<CPANPLUS::Module>␣objects.
This␣is␣a␣required␣argument.

=item␣allow

A␣set␣of␣rules,␣or␣more␣precisely,␣a␣list␣of␣regexes␣(via␣C<qr//>␣or
plain␣strings),␣that␣the␣C<type>␣must␣adhere␣too.␣You␣can␣specify␣as
many␣as␣you␣like,␣and␣it␣will␣be␣treated␣as␣an␣C<OR>␣search.
For␣an␣C<AND>␣search,␣see␣the␣C<data>␣argument.

This␣is␣a␣required␣argument.

=item␣data

An␣arrayref␣of␣previous␣search␣results.␣This␣is␣the␣way␣to␣do␣an␣C<AND>
search␣--␣C<_search_module_tree>␣will␣only␣search␣the␣module␣objects
specified␣in␣C<data>␣if␣provided,␣rather␣than␣the␣moduletree␣itself.

=back

=cut

#␣Although␣the␣Params::Check␣solution␣is␣more␣graceful,␣it␣is␣WAY␣too␣slow.
#
#␣This␣sample␣script:
#
#␣␣␣␣␣use␣CPANPLUS::Backend;
#␣␣␣␣␣my␣$cb␣=␣new␣CPANPLUS::Backend;
#␣␣␣␣␣$cb->module_tree;
#␣␣␣␣␣my␣@list␣=␣$cb->search(␣type␣=>␣'module',␣allow␣=>␣[qr/^Acme/]␣);
#␣␣␣␣␣print␣$_->module,␣$/␣for␣@list;
#
#␣Produced␣the␣following␣output␣using␣Dprof␣WITH␣params::check␣code
#
#␣␣␣␣␣Total␣Elapsed␣Time␣=␣3.670024␣Seconds
#␣␣␣␣␣␣␣User+System␣Time␣=␣3.390373␣Seconds
#␣␣␣␣␣Exclusive␣Times
#␣␣␣␣␣%Time␣ExclSec␣CumulS␣#Calls␣sec/call␣Csec/c␣␣Name
#␣␣␣␣␣␣88.7␣␣␣3.008␣␣4.463␣␣20610␣␣␣0.0001␣0.0002␣␣Params::Check::check
#␣␣␣␣␣␣47.4␣␣␣1.610␣␣1.610␣␣␣␣␣␣1␣␣␣1.6100␣1.6100␣␣Storable::net_pstore
#␣␣␣␣␣␣25.6␣␣␣0.869␣␣0.737␣␣20491␣␣␣0.0000␣0.0000␣␣Locale::Maketext::Simple::_default
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣_gettext
#␣␣␣␣␣␣23.2␣␣␣0.789␣␣0.524␣␣40976␣␣␣0.0000␣0.0000␣␣Params::Check::_who_was_it
#␣␣␣␣␣␣23.2␣␣␣0.789␣␣0.677␣␣20610␣␣␣0.0000␣0.0000␣␣Params::Check::_sanity_check
#␣␣␣␣␣␣19.7␣␣␣0.670␣␣0.670␣␣␣␣␣␣1␣␣␣0.6700␣0.6700␣␣Storable::pretrieve
#␣␣␣␣␣␣14.1␣␣␣0.480␣␣0.211␣␣41350␣␣␣0.0000␣0.0000␣␣Params::Check::_convert_case
#␣␣␣␣␣␣11.5␣␣␣0.390␣␣0.256␣␣20610␣␣␣0.0000␣0.0000␣␣Params::Check::_hashdefs
#␣␣␣␣␣␣11.5␣␣␣0.390␣␣0.255␣␣20697␣␣␣0.0000␣0.0000␣␣Params::Check::_listreqs
#␣␣␣␣␣␣11.4␣␣␣0.389␣␣0.177␣␣20653␣␣␣0.0000␣0.0000␣␣Params::Check::_canon_key
#␣␣␣␣␣␣10.9␣␣␣0.370␣␣0.356␣␣20697␣␣␣0.0000␣0.0000␣␣Params::Check::_hasreq
#␣␣␣␣␣␣8.02␣␣␣0.272␣␣4.750␣␣␣␣␣␣1␣␣␣0.2723␣4.7501␣␣CPANPLUS::Internals::Search::_sear
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣ch_module_tree
#␣␣␣␣␣␣6.49␣␣␣0.220␣␣0.086␣␣20653␣␣␣0.0000␣0.0000␣␣Params::Check::_iskey
#␣␣␣␣␣␣6.19␣␣␣0.210␣␣0.077␣␣20488␣␣␣0.0000␣0.0000␣␣Params::Check::_store_error
#␣␣␣␣␣␣5.01␣␣␣0.170␣␣0.036␣␣20680␣␣␣0.0000␣0.0000␣␣CPANPLUS::Module::__ANON__
#
#␣and␣this␣output␣/without/
#
#␣␣␣␣␣Total␣Elapsed␣Time␣=␣2.803426␣Seconds
#␣␣␣␣␣␣␣User+System␣Time␣=␣2.493426␣Seconds
#␣␣␣␣␣Exclusive␣Times
#␣␣␣␣␣%Time␣ExclSec␣CumulS␣#Calls␣sec/call␣Csec/c␣␣Name
#␣␣␣␣␣␣56.9␣␣␣1.420␣␣1.420␣␣␣␣␣␣1␣␣␣1.4200␣1.4200␣␣Storable::net_pstore
#␣␣␣␣␣␣25.6␣␣␣0.640␣␣0.640␣␣␣␣␣␣1␣␣␣0.6400␣0.6400␣␣Storable::pretrieve
#␣␣␣␣␣␣9.22␣␣␣0.230␣␣0.096␣␣20680␣␣␣0.0000␣0.0000␣␣CPANPLUS::Module::__ANON__
#␣␣␣␣␣␣7.06␣␣␣0.176␣␣0.272␣␣␣␣␣␣1␣␣␣0.1762␣0.2719␣␣CPANPLUS::Internals::Search::_sear
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣ch_module_tree
#␣␣␣␣␣␣3.21␣␣␣0.080␣␣0.098␣␣␣␣␣10␣␣␣0.0080␣0.0098␣␣IPC::Cmd::BEGIN
#␣␣␣␣␣␣1.60␣␣␣0.040␣␣0.205␣␣␣␣␣13␣␣␣0.0031␣0.0158␣␣CPANPLUS::Internals::BEGIN
#␣␣␣␣␣␣1.20␣␣␣0.030␣␣0.030␣␣␣␣␣29␣␣␣0.0010␣0.0010␣␣vars::BEGIN
#␣␣␣␣␣␣1.20␣␣␣0.030␣␣0.117␣␣␣␣␣10␣␣␣0.0030␣0.0117␣␣Log::Message::BEGIN
#␣␣␣␣␣␣1.20␣␣␣0.030␣␣0.029␣␣␣␣␣␣9␣␣␣0.0033␣0.0033␣␣CPANPLUS::Internals::Search::BEGIN
#␣␣␣␣␣␣0.80␣␣␣0.020␣␣0.020␣␣␣␣␣␣5␣␣␣0.0040␣0.0040␣␣DynaLoader::dl_load_file
#␣␣␣␣␣␣0.80␣␣␣0.020␣␣0.127␣␣␣␣␣10␣␣␣0.0020␣0.0127␣␣CPANPLUS::Module::BEGIN
#␣␣␣␣␣␣0.80␣␣␣0.020␣␣0.389␣␣␣␣␣␣2␣␣␣0.0099␣0.1944␣␣main::BEGIN
#␣␣␣␣␣␣0.80␣␣␣0.020␣␣0.359␣␣␣␣␣12␣␣␣0.0017␣0.0299␣␣CPANPLUS::Backend::BEGIN
#␣␣␣␣␣␣0.40␣␣␣0.010␣␣0.010␣␣␣␣␣30␣␣␣0.0003␣0.0003␣␣Config::FETCH
#␣␣␣␣␣␣0.40␣␣␣0.010␣␣0.010␣␣␣␣␣18␣␣␣0.0006␣0.0005␣␣Locale::Maketext::Simple::load_loc
#

sub␣_search_module_tree␣{

␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my($mods,$list,$verbose,$type);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣data␣␣␣␣=>␣{␣default␣␣␣␣=>␣[],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣strict_type=>␣1,␣store␣␣␣␣␣=>␣\$mods␣},
␣␣␣␣␣␣␣␣allow␣␣␣=>␣{␣required␣␣␣=>␣1,␣default␣␣␣=>␣[␣],␣strict_type␣=>␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣=>␣\$list␣},
␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣␣␣␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣type␣␣␣␣=>␣{␣required␣␣␣=>␣1,␣allow␣=>␣[CPANPLUS::Module->accessors()],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣=>␣\$type␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣do␣{
␣␣␣␣␣␣␣␣###␣don't␣check␣the␣template␣for␣sanity
␣␣␣␣␣␣␣␣###␣--␣we␣know␣it's␣good␣and␣saves␣a␣lot␣of␣performance
␣␣␣␣␣␣␣␣local␣$Params::Check::SANITY_CHECK_TEMPLATE␣=␣0;

␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣);
␣␣␣␣}␣or␣return;

␣␣␣␣###␣a␣list␣of␣module␣objects␣was␣supplied
␣␣␣␣if(␣@$mods␣)␣{␣␣␣
␣␣␣␣␣␣␣␣local␣$Params::Check::VERBOSE␣=␣0;

␣␣␣␣␣␣␣␣my␣@rv;
␣␣␣␣␣␣␣␣for␣my␣$mod␣(@$mods)␣{
␣␣␣␣␣␣␣␣␣␣␣␣#push␣@rv,␣$mod␣if␣check(
␣␣␣␣␣␣␣␣␣␣␣␣#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣$type␣=>␣{␣allow␣=>␣$list␣}␣},
␣␣␣␣␣␣␣␣␣␣␣␣#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣$type␣=>␣$mod->$type()␣}
␣␣␣␣␣␣␣␣␣␣␣␣#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣push␣@rv,␣$mod␣if␣allow(␣$mod->$type()␣=>␣$list␣);

␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣return␣\@rv;

␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣@rv␣=␣$self->_source_search_module_tree(
␣␣␣␣␣␣␣␣␣␣␣␣allow␣␣␣=>␣$list,
␣␣␣␣␣␣␣␣␣␣␣␣type␣␣␣␣=>␣$type,
␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣return␣\@rv;
␣␣␣␣}
}

=pod

=head2␣_search_author_tree(␣type␣=>␣TYPE,␣allow␣=>␣\@regexex,␣[data␣=>␣\@previous_results␣]␣)

Searches␣the␣authortree␣for␣author␣objects␣matching␣the␣criteria␣you
specify.␣Returns␣an␣array␣ref␣of␣author␣objects␣on␣success,␣and␣false
on␣failure.

It␣takes␣the␣following␣arguments:

=over␣4

=item␣type

This␣can␣be␣any␣of␣the␣accessors␣for␣the␣C<CPANPLUS::Module::Author>
objects.␣This␣is␣a␣required␣argument.

=item␣allow


A␣set␣of␣rules,␣or␣more␣precisely,␣a␣list␣of␣regexes␣(via␣C<qr//>␣or
plain␣strings),␣that␣the␣C<type>␣must␣adhere␣too.␣You␣can␣specify␣as
many␣as␣you␣like,␣and␣it␣will␣be␣treated␣as␣an␣C<OR>␣search.
For␣an␣C<AND>␣search,␣see␣the␣C<data>␣argument.

This␣is␣a␣required␣argument.

=item␣data

An␣arrayref␣of␣previous␣search␣results.␣This␣is␣the␣way␣to␣do␣an␣C<and>
search␣--␣C<_search_author_tree>␣will␣only␣search␣the␣author␣objects
specified␣in␣C<data>␣if␣provided,␣rather␣than␣the␣authortree␣itself.

=back

=cut

sub␣_search_author_tree␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my($authors,$list,$verbose,$type);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣data␣␣␣␣=>␣{␣default␣␣␣␣=>␣[],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣strict_type=>␣1,␣store␣␣␣␣␣=>␣\$authors␣},
␣␣␣␣␣␣␣␣allow␣␣␣=>␣{␣required␣␣␣=>␣1,␣default␣␣␣=>␣[␣],␣strict_type␣=>␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣=>␣\$list␣},
␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣␣␣␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣type␣␣␣␣=>␣{␣required␣␣␣=>␣1,␣allow␣=>␣[CPANPLUS::Module::Author->accessors()],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣=>␣\$type␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣if(␣@$authors␣)␣{␣␣␣
␣␣␣␣␣␣␣␣local␣$Params::Check::VERBOSE␣=␣0;

␣␣␣␣␣␣␣␣my␣@rv;
␣␣␣␣␣␣␣␣for␣my␣$auth␣(@$authors)␣{
␣␣␣␣␣␣␣␣␣␣␣␣#push␣@rv,␣$auth␣if␣check(
␣␣␣␣␣␣␣␣␣␣␣␣#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣$type␣=>␣{␣allow␣=>␣$list␣}␣},
␣␣␣␣␣␣␣␣␣␣␣␣#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣$type␣=>␣$auth->$type␣}
␣␣␣␣␣␣␣␣␣␣␣␣#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣push␣@rv,␣$auth␣if␣allow(␣$auth->$type()␣=>␣$list␣);
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣return␣\@rv;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣@rv␣=␣$self->_source_search_author_tree(
␣␣␣␣␣␣␣␣␣␣␣␣allow␣␣␣=>␣$list,
␣␣␣␣␣␣␣␣␣␣␣␣type␣␣␣␣=>␣$type,
␣␣␣␣␣␣␣␣);␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣return␣\@rv;
␣␣␣␣}
}

=pod

=head2␣_all_installed()

This␣function␣returns␣an␣array␣ref␣of␣module␣objects␣of␣modules␣that
are␣installed␣on␣this␣system.

=cut

sub␣_all_installed␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣###␣File::Find␣uses␣follow_skip␣=>␣1␣by␣default,␣which␣doesn't␣die
␣␣␣␣###␣on␣duplicates,␣unless␣they␣are␣directories␣or␣symlinks.
␣␣␣␣###␣Ticket␣#29796␣shows␣this␣code␣dying␣on␣Alien::WxWidgets,
␣␣␣␣###␣which␣uses␣symlinks.
␣␣␣␣###␣File::Find␣doc␣says␣to␣use␣follow_skip␣=>␣2␣to␣ignore␣duplicates
␣␣␣␣###␣so␣this␣will␣stop␣it␣from␣dying.
␣␣␣␣my␣%find_args␣=␣(␣follow_skip␣=>␣2␣);

␣␣␣␣###␣File::Find␣uses␣lstat,␣which␣quietly␣becomes␣stat␣on␣win32
␣␣␣␣###␣it␣then␣uses␣-l␣_␣which␣is␣not␣allowed␣by␣the␣statbuffer␣because
␣␣␣␣###␣you␣did␣a␣stat,␣not␣an␣lstat␣(duh!).␣so␣don't␣tell␣win32␣to
␣␣␣␣###␣follow␣symlinks,␣as␣that␣will␣break␣badly
␣␣␣␣$find_args{'follow_fast'}␣=␣1␣unless␣ON_WIN32;

␣␣␣␣###␣never␣use␣the␣@INC␣hooks␣to␣find␣installed␣versions␣of
␣␣␣␣###␣modules␣--␣they're␣just␣there␣in␣case␣they're␣not␣on␣the
␣␣␣␣###␣perl␣install,␣but␣the␣user␣shouldn't␣trust␣them␣for␣*other*
␣␣␣␣###␣modules!
␣␣␣␣###␣XXX␣CPANPLUS::inc␣is␣now␣obsolete,␣remove␣the␣calls
␣␣␣␣#local␣@INC␣=␣CPANPLUS::inc->original_inc;

␣␣␣␣my␣%seen;␣my␣@rv;
␣␣␣␣for␣my␣$dir␣(@INC␣)␣{
␣␣␣␣␣␣␣␣next␣if␣$dir␣eq␣'.';

␣␣␣␣␣␣␣␣###␣not␣a␣directory␣after␣all␣
␣␣␣␣␣␣␣␣###␣may␣be␣coderef␣or␣some␣such
␣␣␣␣␣␣␣␣next␣unless␣-d␣$dir;

␣␣␣␣␣␣␣␣###␣make␣sure␣to␣clean␣up␣the␣directories␣just␣in␣case,
␣␣␣␣␣␣␣␣###␣as␣we're␣making␣assumptions␣about␣the␣length
␣␣␣␣␣␣␣␣###␣This␣solves␣rt.cpan␣issue␣#19738
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣John␣M.␣notes:␣On␣VMS␣cannonpath␣can␣not␣currently␣handle␣
␣␣␣␣␣␣␣␣###␣the␣$dir␣values␣that␣are␣in␣UNIX␣format.
␣␣␣␣␣␣␣␣$dir␣=␣File::Spec->canonpath(␣$dir␣)␣unless␣ON_VMS;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣have␣to␣use␣F::S::Unix␣on␣VMS,␣or␣things␣will␣break
␣␣␣␣␣␣␣␣my␣$file_spec␣=␣ON_VMS␣?␣'File::Spec::Unix'␣:␣'File::Spec';

␣␣␣␣␣␣␣␣###␣XXX␣in␣some␣cases␣File::Find␣can␣actually␣die!
␣␣␣␣␣␣␣␣###␣so␣be␣safe␣and␣wrap␣it␣in␣an␣eval.
␣␣␣␣␣␣␣␣eval␣{␣File::Find::find(
␣␣␣␣␣␣␣␣␣␣␣␣{␣␣␣%find_args,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣wanted␣␣␣␣␣␣=>␣sub␣{

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣unless␣/\.pm$/i;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$mod␣=␣$File::Find::name;

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣make␣sure␣it's␣in␣Unix␣format,␣as␣it
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣may␣be␣in␣VMS␣format␣on␣VMS;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mod␣=␣VMS::Filespec::unixify(␣$mod␣)␣if␣ON_VMS;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mod␣=␣substr($mod,␣length($dir)␣+␣1,␣-3);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mod␣=␣join␣'::',␣$file_spec->splitdir($mod);

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣if␣$seen{$mod}++;

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$modobj␣=␣$self->module_tree($mod);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣seperate␣return,␣a␣list␣context␣return␣with␣one␣''
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣in␣it,␣is␣also␣true!
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣unless␣$modobj;

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@rv,␣$modobj;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣},
␣␣␣␣␣␣␣␣␣␣␣␣},␣$dir
␣␣␣␣␣␣␣␣)␣};

␣␣␣␣␣␣␣␣###␣report␣the␣error␣if␣file::find␣died
␣␣␣␣␣␣␣␣error(loc("Error␣finding␣installed␣files␣in␣'%1':␣%2",␣$dir,␣$@))␣if␣$@;
␣␣␣␣}

␣␣␣␣return␣\@rv;
}

1;

#␣Local␣variables:
#␣c-indentation-style:␣bsd
#␣c-basic-offset:␣4
#␣indent-tabs-mode:␣nil
#␣End:
#␣vim:␣expandtab␣shiftwidth=4:
package␣CPANPLUS::Internals::Source;

use␣strict;

use␣CPANPLUS::Error;
use␣CPANPLUS::Module;
use␣CPANPLUS::Module::Fake;
use␣CPANPLUS::Module::Author;
use␣CPANPLUS::Internals::Constants;

use␣File::Fetch;
use␣Archive::Extract;

use␣IPC::Cmd␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[can_run];
use␣File::Temp␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[tempdir];
use␣File::Basename␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[dirname];
use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[check];
use␣Module::Load::Conditional␣␣␣qw[can_load];
use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';

$Params::Check::VERBOSE␣=␣1;

###␣list␣of␣methods␣the␣parent␣class␣must␣implement
{␣␣␣for␣my␣$sub␣(␣qw[_init_trees␣_finalize_trees␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣_standard_trees_completed␣_custom_trees_completed
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣_add_module_object␣_add_author_object␣_save_state
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣]␣
␣␣␣␣)␣{
␣␣␣␣␣␣␣␣no␣strict␣'refs';
␣␣␣␣␣␣␣␣*$sub␣=␣sub␣{␣
␣␣␣␣␣␣␣␣␣␣␣␣my␣$self␣␣␣␣=␣shift;
␣␣␣␣␣␣␣␣␣␣␣␣my␣$class␣␣␣=␣ref␣$self␣||␣$self;
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣require␣Carp;␣
␣␣␣␣␣␣␣␣␣␣␣␣Carp::croak(␣loc(␣"Class␣%1␣must␣implement␣method␣'%2'",␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$class,␣$sub␣)␣);
␣␣␣␣␣␣␣␣}
␣␣␣␣}
}␣␣␣␣

{
␣␣␣␣my␣$recurse;␣#␣flag␣to␣prevent␣recursive␣calls␣to␣*_tree␣functions

␣␣␣␣###␣lazy␣loading␣of␣module␣tree
␣␣␣␣sub␣_module_tree␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣$_[0];

␣␣␣␣␣␣␣␣unless␣($self->_mtree␣or␣$recurse++␣>␣0)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$uptodate␣=␣$self->_check_trees(␣@_[1..$#_]␣);
␣␣␣␣␣␣␣␣␣␣␣␣$self->_build_trees(uptodate␣=>␣$uptodate);
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣$recurse--;
␣␣␣␣␣␣␣␣return␣$self->_mtree;
␣␣␣␣}

␣␣␣␣###␣lazy␣loading␣of␣author␣tree
␣␣␣␣sub␣_author_tree␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣$_[0];

␣␣␣␣␣␣␣␣unless␣($self->_atree␣or␣$recurse++␣>␣0)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$uptodate␣=␣$self->_check_trees(␣@_[1..$#_]␣);
␣␣␣␣␣␣␣␣␣␣␣␣$self->_build_trees(uptodate␣=>␣$uptodate);
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣$recurse--;
␣␣␣␣␣␣␣␣return␣$self->_atree;
␣␣␣␣}

}


=pod

=head1␣NAME

CPANPLUS::Internals::Source

=head1␣SYNOPSIS

␣␣␣␣###␣lazy␣load␣author/module␣trees␣###

␣␣␣␣$cb->_author_tree;
␣␣␣␣$cb->_module_tree;

=head1␣DESCRIPTION

CPANPLUS::Internals::Source␣controls␣the␣updating␣of␣source␣files␣and
the␣parsing␣of␣them␣into␣usable␣module/author␣trees␣to␣be␣used␣by
C<CPANPLUS>.

Functions␣exist␣to␣check␣if␣source␣files␣are␣still␣C<good␣to␣use>␣as
well␣as␣update␣them,␣and␣then␣parse␣them.

The␣flow␣looks␣like␣this:

␣␣␣␣$cb->_author_tree␣||␣$cb->_module_tree
␣␣␣␣␣␣␣␣$cb->_check_trees
␣␣␣␣␣␣␣␣␣␣␣␣$cb->__check_uptodate
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$cb->_update_source
␣␣␣␣␣␣␣␣␣␣␣␣$cb->__update_custom_module_sources␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$cb->__update_custom_module_source
␣␣␣␣␣␣␣␣$cb->_build_trees
␣␣␣␣␣␣␣␣␣␣␣␣###␣engine␣methods
␣␣␣␣␣␣␣␣␣␣␣␣{␣␣␣$cb->_init_trees;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$cb->_standard_trees_completed
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$cb->_custom_trees_completed
␣␣␣␣␣␣␣␣␣␣␣␣}␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣$cb->__create_author_tree
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣engine␣methods
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣$cb->_add_author_object␣}
␣␣␣␣␣␣␣␣␣␣␣␣$cb->__create_module_tree
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$cb->__create_dslip_tree
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣engine␣methods
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣$cb->_add_module_object␣}
␣␣␣␣␣␣␣␣␣␣␣␣$cb->__create_custom_module_entries␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣

␣␣␣␣$cb->_dslip_defs

=head1␣METHODS

=cut

=pod

=head2␣$cb->_build_trees(␣uptodate␣=>␣BOOL,␣[use_stored␣=>␣BOOL,␣path␣=>␣$path,␣verbose␣=>␣BOOL]␣)

This␣method␣rebuilds␣the␣author-␣and␣module-trees␣from␣source.

It␣takes␣the␣following␣arguments:

=over␣4

=item␣uptodate

Indicates␣whether␣any␣on␣disk␣caches␣are␣still␣ok␣to␣use.

=item␣path

The␣absolute␣path␣to␣the␣directory␣holding␣the␣source␣files.

=item␣verbose

A␣boolean␣flag␣indicating␣whether␣or␣not␣to␣be␣verbose.

=item␣use_stored

A␣boolean␣flag␣indicating␣whether␣or␣not␣it␣is␣ok␣to␣use␣previously
stored␣trees.␣Defaults␣to␣true.

=back

Returns␣a␣boolean␣indicating␣success.

=cut

###␣(re)build␣the␣trees␣###
sub␣_build_trees␣{
␣␣␣␣my␣($self,␣%hash)␣␣␣=␣@_;
␣␣␣␣my␣$conf␣␣␣␣␣␣␣␣␣␣␣␣=␣$self->configure_object;

␣␣␣␣my($path,$uptodate,$use_stored,$verbose);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣path␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('base'),␣store␣=>␣\$path␣},
␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),␣store␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣uptodate␣␣␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$uptodate␣},
␣␣␣␣␣␣␣␣use_stored␣␣=>␣{␣default␣=>␣1,␣store␣=>␣\$use_stored␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣$self->_init_trees(
␣␣␣␣␣␣␣␣path␣␣␣␣␣␣␣␣=>␣$path,
␣␣␣␣␣␣␣␣uptodate␣␣␣␣=>␣$uptodate,
␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣$verbose,
␣␣␣␣␣␣␣␣use_stored␣␣=>␣$use_stored,
␣␣␣␣)␣or␣do␣{
␣␣␣␣␣␣␣␣error(␣loc("Could␣not␣initialize␣trees"␣)␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣};␣␣␣␣␣␣␣␣

␣␣␣␣###␣return␣if␣we␣weren't␣able␣to␣build␣the␣trees␣###
␣␣␣␣return␣unless␣$self->_mtree␣&&␣$self->_atree;
␣
␣␣␣␣###␣did␣we␣get␣everything␣from␣a␣stored␣state?␣if␣not,
␣␣␣␣###␣process␣them␣now.
␣␣␣␣if(␣not␣$self->_standard_trees_completed␣)␣{
␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣first,␣prep␣the␣author␣tree
␣␣␣␣␣␣␣␣$self->__create_author_tree(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣uptodate␣␣␣␣=>␣$uptodate,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣␣␣␣␣=>␣$path,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣$verbose,␣
␣␣␣␣␣␣␣␣)␣or␣return;

␣␣␣␣␣␣␣␣###␣and␣now␣the␣module␣tree
␣␣␣␣␣␣␣␣$self->_create_mod_tree(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣uptodate␣␣␣␣=>␣$uptodate,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣␣␣␣␣=>␣$path,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣$verbose,␣
␣␣␣␣␣␣␣␣)␣or␣return;
␣␣␣␣}
␣␣␣␣
␣␣␣␣###␣XXX␣unpleasant␣hack.␣since␣custom␣sources␣uses␣->parse_module,␣we
␣␣␣␣###␣already␣have␣a␣special␣module␣object␣with␣extra␣meta␣data.␣that␣
␣␣␣␣###␣doesn't␣gelwell␣with␣the␣sqlite␣storage␣engine.␣So,␣we␣check␣'normal'
␣␣␣␣###␣trees␣from␣seperate␣trees,␣so␣the␣engine␣can␣treat␣them␣differently.
␣␣␣␣###␣Effectively␣this␣means␣that␣with␣the␣SQLite␣engine,␣for␣now,␣custom
␣␣␣␣###␣sources␣are␣continuously␣reparsed␣=/␣-kane
␣␣␣␣if(␣not␣$self->_custom_trees_completed␣)␣{
␣␣␣␣
␣␣␣␣␣␣␣␣###␣update␣them␣if␣the␣other␣sources␣are␣also␣deemed␣out␣of␣date
␣␣␣␣␣␣␣␣if(␣$conf->get_conf('enable_custom_sources')␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$self->__update_custom_module_sources(␣verbose␣=>␣$verbose␣)␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣or␣error(loc("Could␣not␣update␣custom␣module␣sources"));
␣␣␣␣␣␣␣␣}␣␣␣␣␣␣

␣␣␣␣␣␣␣␣###␣add␣custom␣sources␣here␣if␣enabled
␣␣␣␣␣␣␣␣if(␣$conf->get_conf('enable_custom_sources')␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$self->__create_custom_module_entries(␣verbose␣=>␣$verbose␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣or␣error(loc("Could␣not␣create␣custom␣module␣entries"));
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣###␣give␣the␣source␣engine␣a␣chance␣to␣wrap␣up␣creation
␣␣␣␣$self->_finalize_trees(
␣␣␣␣␣␣␣␣path␣␣␣␣␣␣␣␣=>␣$path,
␣␣␣␣␣␣␣␣uptodate␣␣␣␣=>␣$uptodate,
␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣$verbose,␣␣␣␣
␣␣␣␣␣␣␣␣use_stored␣␣=>␣$use_stored,
␣␣␣␣)␣or␣do␣{
␣␣␣␣␣␣␣␣error(loc(␣"Could␣not␣finalize␣trees"␣));
␣␣␣␣␣␣␣␣return;
␣␣␣␣};␣␣␣␣␣␣␣␣
␣␣␣␣
␣␣␣␣###␣still␣necessary?␣can␣only␣run␣one␣instance␣now␣###
␣␣␣␣###␣will␣probably␣stay␣that␣way␣--kane
#␣␣␣␣␣my␣$id␣=␣$self->_store_id(␣$self␣);
#
#␣␣␣␣␣unless␣(␣$id␣==␣$self->_id␣)␣{
#␣␣␣␣␣␣␣␣␣error(␣loc("IDs␣do␣not␣match:␣%1␣!=␣%2.␣Storage␣failed!",␣$id,␣$self->_id)␣);
#␣␣␣␣␣}

␣␣␣␣return␣1;
}

=pod

=head2␣$cb->_check_trees(␣[update_source␣=>␣BOOL,␣path␣=>␣PATH,␣verbose␣=>␣BOOL]␣)

Retrieve␣source␣files␣and␣return␣a␣boolean␣indicating␣whether␣or␣not
the␣source␣files␣are␣up␣to␣date.

Takes␣several␣arguments:

=over␣4

=item␣update_source

A␣flag␣to␣force␣re-fetching␣of␣the␣source␣files,␣even
if␣they␣are␣still␣up␣to␣date.

=item␣path

The␣absolute␣path␣to␣the␣directory␣holding␣the␣source␣files.

=item␣verbose

A␣boolean␣flag␣indicating␣whether␣or␣not␣to␣be␣verbose.

=back

Will␣get␣information␣from␣the␣config␣file␣by␣default.

=cut

###␣retrieve␣source␣files,␣and␣returns␣a␣boolean␣indicating␣if␣it's␣up␣to␣date
sub␣_check_trees␣{
␣␣␣␣my␣($self,␣%hash)␣=␣@_;
␣␣␣␣my␣$conf␣␣␣␣␣␣␣␣␣␣=␣$self->configure_object;

␣␣␣␣my␣$update_source;
␣␣␣␣my␣$verbose;
␣␣␣␣my␣$path;

␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣path␣␣␣␣␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('base'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$path
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣},
␣␣␣␣␣␣␣␣verbose␣␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$verbose
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣},
␣␣␣␣␣␣␣␣update_source␣␣␣=>␣{␣default␣=>␣0,␣store␣=>␣\$update_source␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣###␣if␣the␣user␣never␣wants␣to␣update␣their␣source␣without␣explicitly
␣␣␣␣###␣telling␣us,␣shortcircuit␣here
␣␣␣␣return␣1␣if␣$conf->get_conf('no_update')␣&&␣!$update_source;

␣␣␣␣###␣a␣check␣to␣see␣if␣our␣source␣files␣are␣still␣up␣to␣date␣###
␣␣␣␣msg(␣loc("Checking␣if␣source␣files␣are␣up␣to␣date"),␣$verbose␣);

␣␣␣␣my␣$uptodate␣=␣1;␣#␣default␣return␣value

␣␣␣␣for␣my␣$name␣(qw[auth␣dslip␣mod])␣{
␣␣␣␣␣␣␣␣for␣my␣$file␣(␣$conf->_get_source(␣$name␣)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$self->__check_uptodate(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣file␣␣␣␣␣␣␣␣␣␣␣␣=>␣File::Spec->catfile(␣$path,␣$file␣),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣name␣␣␣␣␣␣␣␣␣␣␣␣=>␣$name,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣update_source␣␣␣=>␣$update_source,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣␣␣␣␣␣␣␣␣=>␣$verbose,
␣␣␣␣␣␣␣␣␣␣␣␣)␣or␣$uptodate␣=␣0;
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣###␣if␣we're␣explicitly␣asked␣to␣update␣the␣sources,␣or␣if␣the
␣␣␣␣###␣standard␣source␣files␣are␣out␣of␣date,␣update␣the␣custom␣sources
␣␣␣␣###␣as␣well
␣␣␣␣###␣RT␣#47820:␣Don't␣try␣to␣update␣custom␣sources␣if␣they␣are␣disabled
␣␣␣␣###␣in␣the␣configuration.
␣␣␣␣$self->__update_custom_module_sources(␣verbose␣=>␣$verbose␣)␣
␣␣␣␣␣␣␣␣if␣$conf->get_conf('enable_custom_sources')␣and␣(␣$update_source␣or␣!$uptodate␣);

␣␣␣␣return␣$uptodate;
}

=pod

=head2␣$cb->__check_uptodate(␣file␣=>␣$file,␣name␣=>␣$name,␣[update_source␣=>␣BOOL,␣verbose␣=>␣BOOL]␣)

C<__check_uptodate>␣checks␣if␣a␣given␣source␣file␣is␣still␣up-to-date
and␣if␣not,␣or␣when␣C<update_source>␣is␣true,␣will␣re-fetch␣the␣source
file.

Takes␣the␣following␣arguments:

=over␣4

=item␣file

The␣source␣file␣to␣check.

=item␣name

The␣internal␣shortcut␣name␣for␣the␣source␣file␣(used␣for␣config
lookups).

=item␣update_source

Flag␣to␣force␣updating␣of␣sourcefiles␣regardless.

=item␣verbose

Boolean␣to␣indicate␣whether␣to␣be␣verbose␣or␣not.

=back

Returns␣a␣boolean␣value␣indicating␣whether␣the␣current␣files␣are␣up
to␣date␣or␣not.

=cut

###␣this␣method␣checks␣whether␣or␣not␣the␣source␣files␣we␣are␣using␣are␣still␣up␣to␣date
sub␣__check_uptodate␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣my␣$conf␣=␣$self->configure_object;


␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣file␣␣␣␣␣␣␣␣␣␣␣␣=>␣{␣required␣=>␣1␣},
␣␣␣␣␣␣␣␣name␣␣␣␣␣␣␣␣␣␣␣␣=>␣{␣required␣=>␣1␣},
␣␣␣␣␣␣␣␣update_source␣␣␣=>␣{␣default␣=>␣0␣},
␣␣␣␣␣␣␣␣verbose␣␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose')␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣my␣$flag;
␣␣␣␣unless␣(␣-e␣$args->{'file'}␣&&␣(
␣␣␣␣␣␣␣␣␣␣␣␣(␣stat␣$args->{'file'}␣)[9]
␣␣␣␣␣␣␣␣␣␣␣␣+␣$conf->_get_source('update')␣)
␣␣␣␣␣␣␣␣␣␣␣␣>␣time␣)␣{
␣␣␣␣␣␣␣␣$flag␣=␣1;
␣␣␣␣}

␣␣␣␣if␣(␣$flag␣or␣$args->{'update_source'}␣)␣{

␣␣␣␣␣␣␣␣␣if␣(␣$self->_update_source(␣name␣=>␣$args->{'name'}␣)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣0;␣␣␣␣␣␣␣#␣return␣0␣so␣'uptodate'␣will␣be␣set␣to␣0,␣meaning␣no␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣use␣of␣previously␣stored␣hashrefs!
␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣msg(␣loc("Unable␣to␣update␣source,␣attempting␣to␣get␣away␣with␣using␣old␣source␣file!"),␣$args->{verbose}␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣␣␣␣␣␣}

␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}
}

=pod

=head2␣$cb->_update_source(␣name␣=>␣$name,␣[path␣=>␣$path,␣verbose␣=>␣BOOL]␣)

This␣method␣does␣the␣actual␣fetching␣of␣source␣files.

It␣takes␣the␣following␣arguments:

=over␣4

=item␣name

The␣internal␣shortcut␣name␣for␣the␣source␣file␣(used␣for␣config
lookups).

=item␣path

The␣full␣path␣where␣to␣write␣the␣files.

=item␣verbose

Boolean␣to␣indicate␣whether␣to␣be␣verbose␣or␣not.

=back

Returns␣a␣boolean␣to␣indicate␣success.

=cut

###␣this␣sub␣fetches␣new␣source␣files␣###
sub␣_update_source␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣my␣$conf␣=␣$self->configure_object;

␣␣␣␣my␣$verbose;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣name␣␣␣␣=>␣{␣required␣=>␣1␣},
␣␣␣␣␣␣␣␣path␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('base')␣},
␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),␣store␣=>␣\$verbose␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;


␣␣␣␣my␣$path␣=␣$args->{path};
␣␣␣␣{␣␣␣###␣this␣could␣use␣a␣clean␣up␣-␣Kane
␣␣␣␣␣␣␣␣###␣no␣worries␣about␣the␣/␣->␣we␣get␣it␣from␣the␣_ftp␣configuration,␣so
␣␣␣␣␣␣␣␣###␣it's␣not␣platform␣dependant.␣-kane
␣␣␣␣␣␣␣␣my␣($dir,␣$file)␣=␣$conf->_get_mirror(␣$args->{'name'}␣)␣=~␣m|(.+/)(.+)$|sg;

␣␣␣␣␣␣␣␣msg(␣loc("Updating␣source␣file␣'%1'",␣$file),␣$verbose␣);

␣␣␣␣␣␣␣␣my␣$fake␣=␣CPANPLUS::Module::Fake->new(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣module␣␣=>␣$args->{'name'},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣=>␣$dir,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣package␣=>␣$file,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣_id␣␣␣␣␣=>␣$self->_id,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣␣␣␣␣###␣can't␣use␣$fake->fetch␣here,␣since␣->parent␣won't␣work␣--
␣␣␣␣␣␣␣␣###␣the␣sources␣haven't␣been␣saved␣yet
␣␣␣␣␣␣␣␣my␣$rv␣=␣$self->_fetch(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣module␣␣␣␣␣␣=>␣$fake,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣fetchdir␣␣␣␣=>␣$path,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣force␣␣␣␣␣␣␣=>␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);


␣␣␣␣␣␣␣␣unless␣($rv)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(␣loc("Couldn't␣fetch␣'%1'",␣$file)␣);
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣$self->_update_timestamp(␣file␣=>␣File::Spec->catfile($path,␣$file)␣);
␣␣␣␣}

␣␣␣␣return␣1;
}

=pod

=head2␣$cb->__create_author_tree([path␣=>␣$path,␣uptodate␣=>␣BOOL,␣verbose␣=>␣BOOL])

This␣method␣opens␣a␣source␣files␣and␣parses␣its␣contents␣into␣a
searchable␣author-tree␣or␣restores␣a␣file-cached␣version␣of␣a
previous␣parse,␣if␣the␣sources␣are␣uptodate␣and␣the␣file-cache␣exists.

It␣takes␣the␣following␣arguments:

=over␣4

=item␣uptodate

A␣flag␣indicating␣whether␣the␣file-cache␣is␣uptodate␣or␣not.

=item␣path

The␣absolute␣path␣to␣the␣directory␣holding␣the␣source␣files.

=item␣verbose

A␣boolean␣flag␣indicating␣whether␣or␣not␣to␣be␣verbose.

=back

Will␣get␣information␣from␣the␣config␣file␣by␣default.

Returns␣a␣tree␣on␣success,␣false␣on␣failure.

=cut

sub␣__create_author_tree␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣my␣$conf␣=␣$self->configure_object;


␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣path␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('base')␣},
␣␣␣␣␣␣␣␣verbose␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose')␣},
␣␣␣␣␣␣␣␣uptodate␣=>␣{␣default␣=>␣0␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣my␣$file␣=␣File::Spec->catfile(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$args->{path},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$conf->_get_source('auth')
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣msg(loc("Rebuilding␣author␣tree,␣this␣might␣take␣a␣while"),
␣␣␣␣␣␣␣␣$args->{verbose});

␣␣␣␣###␣extract␣the␣file␣###
␣␣␣␣my␣$ae␣␣␣␣␣␣=␣Archive::Extract->new(␣archive␣=>␣$file␣)␣or␣return;
␣␣␣␣my␣$out␣␣␣␣␣=␣STRIP_GZ_SUFFIX->($file);

␣␣␣␣###␣make␣sure␣to␣set␣the␣PREFER_BIN␣flag␣if␣desired␣###
␣␣␣␣{␣␣␣local␣$Archive::Extract::PREFER_BIN␣=␣$conf->get_conf('prefer_bin');
␣␣␣␣␣␣␣␣$ae->extract(␣to␣=>␣$out␣)␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣or␣return;
␣␣␣␣}

␣␣␣␣my␣$cont␣␣␣␣=␣$self->_get_file_contents(␣file␣=>␣$out␣)␣or␣return;

␣␣␣␣###␣don't␣need␣it␣anymore␣###
␣␣␣␣unlink␣$out;

␣␣␣␣for␣(␣split␣/\n/,␣$cont␣)␣{
␣␣␣␣␣␣␣␣my($id,␣$name,␣$email)␣=␣m/^alias␣\s+
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(\S+)␣\s+
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"\s*␣([^\"\<]+?)␣\s*␣<(.+)>␣\s*"
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/x;

␣␣␣␣␣␣␣␣$self->_add_author_object(
␣␣␣␣␣␣␣␣␣␣␣␣author␣␣=>␣$name,␣␣␣␣␣␣␣␣␣␣␣#authors␣name
␣␣␣␣␣␣␣␣␣␣␣␣email␣␣␣=>␣$email,␣␣␣␣␣␣␣␣␣␣#authors␣email␣address
␣␣␣␣␣␣␣␣␣␣␣␣cpanid␣␣=>␣$id,␣␣␣␣␣␣␣␣␣␣␣␣␣#authors␣CPAN␣ID
␣␣␣␣␣␣␣␣)␣or␣error(␣loc("Could␣not␣add␣author␣'%1'",␣$name␣)␣);

␣␣␣␣}

␣␣␣␣return␣$self->_atree;

}␣#__create_author_tree

=pod

=head2␣$cb->_create_mod_tree([path␣=>␣$path,␣uptodate␣=>␣BOOL,␣verbose␣=>␣BOOL])

This␣method␣opens␣a␣source␣files␣and␣parses␣its␣contents␣into␣a
searchable␣module-tree␣or␣restores␣a␣file-cached␣version␣of␣a
previous␣parse,␣if␣the␣sources␣are␣uptodate␣and␣the␣file-cache␣exists.

It␣takes␣the␣following␣arguments:

=over␣4

=item␣uptodate

A␣flag␣indicating␣whether␣the␣file-cache␣is␣up-to-date␣or␣not.

=item␣path

The␣absolute␣path␣to␣the␣directory␣holding␣the␣source␣files.

=item␣verbose

A␣boolean␣flag␣indicating␣whether␣or␣not␣to␣be␣verbose.

=back

Will␣get␣information␣from␣the␣config␣file␣by␣default.

Returns␣a␣tree␣on␣success,␣false␣on␣failure.

=cut

###␣this␣builds␣a␣hash␣reference␣with␣the␣structure␣of␣the␣cpan␣module␣tree␣###
sub␣_create_mod_tree␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣my␣$conf␣=␣$self->configure_object;


␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣path␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('base')␣},
␣␣␣␣␣␣␣␣verbose␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose')␣},
␣␣␣␣␣␣␣␣uptodate␣=>␣{␣default␣=>␣0␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return␣undef;
␣␣␣␣my␣$file␣=␣File::Spec->catfile($args->{path},␣$conf->_get_source('mod'));

␣␣␣␣msg(loc("Rebuilding␣module␣tree,␣this␣might␣take␣a␣while"),
␣␣␣␣␣␣␣␣$args->{verbose});


␣␣␣␣my␣$dslip_tree␣=␣$self->__create_dslip_tree(␣%$args␣);

␣␣␣␣###␣extract␣the␣file␣###
␣␣␣␣my␣$ae␣␣␣␣␣␣=␣Archive::Extract->new(␣archive␣=>␣$file␣)␣or␣return;
␣␣␣␣my␣$out␣␣␣␣␣=␣STRIP_GZ_SUFFIX->($file);

␣␣␣␣###␣make␣sure␣to␣set␣the␣PREFER_BIN␣flag␣if␣desired␣###
␣␣␣␣{␣␣␣local␣$Archive::Extract::PREFER_BIN␣=␣$conf->get_conf('prefer_bin');
␣␣␣␣␣␣␣␣$ae->extract(␣to␣=>␣$out␣)␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣or␣return;
␣␣␣␣}

␣␣␣␣my␣$content␣=␣$self->_get_file_contents(␣file␣=>␣$out␣)␣or␣return;
␣␣␣␣my␣$lines␣␣␣=␣$content␣=~␣tr/\n/\n/;

␣␣␣␣###␣don't␣need␣it␣anymore␣###
␣␣␣␣unlink␣$out;

␣␣␣␣my($past_header,␣$count);
␣␣␣␣for␣(␣split␣/\n/,␣$content␣)␣{

␣␣␣␣␣␣␣␣###␣quick␣hack␣to␣read␣past␣the␣header␣of␣the␣file␣###
␣␣␣␣␣␣␣␣###␣this␣is␣still␣rather␣evil...␣fix␣some␣time␣-␣Kane
␣␣␣␣␣␣␣␣if(␣m|^\s*$|␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣unless(␣$count␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Could␣not␣determine␣line␣count␣from␣%1",␣$file));
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$past_header␣=␣1;
␣␣␣␣␣␣␣␣}␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣we're␣still␣in␣the␣header␣--␣find␣the␣amount␣of␣lines␣we␣expect
␣␣␣␣␣␣␣␣unless(␣$past_header␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣if␣the␣line␣count␣doesn't␣match␣what␣we␣expect,␣bail␣out
␣␣␣␣␣␣␣␣␣␣␣␣###␣this␣should␣address:␣#45644:␣detect␣broken␣index
␣␣␣␣␣␣␣␣␣␣␣␣$count␣=␣$1␣if␣/^Line-Count:\s+(\d+)/;
␣␣␣␣␣␣␣␣␣␣␣␣if(␣$count␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣$lines␣<␣$count␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Expected␣to␣read␣at␣least␣%1␣lines,␣but␣%2␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"contains␣only␣%3␣lines!",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$count,␣$file,␣$lines␣));
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣␣
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣###␣still␣in␣the␣header,␣keep␣moving
␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣skip␣empty␣lines␣###
␣␣␣␣␣␣␣␣next␣unless␣/\S/;
␣␣␣␣␣␣␣␣chomp;

␣␣␣␣␣␣␣␣my␣@data␣=␣split␣/\s+/;

␣␣␣␣␣␣␣␣###␣filter␣out␣the␣author␣and␣filename␣as␣well␣###
␣␣␣␣␣␣␣␣###␣authors␣can␣apparently␣have␣digits␣in␣their␣names,
␣␣␣␣␣␣␣␣###␣and␣dirs␣can␣have␣dots...␣blah!
␣␣␣␣␣␣␣␣my␣($author,␣$package)␣=␣$data[2]␣=~
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣m|␣␣(?:[A-Z\d-]/)?
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(?:[A-Z\d-]{2}/)?
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣([A-Z\d-]+)␣(?:/[\S]+)?/
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣([^/]+)$
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣|xsg;

␣␣␣␣␣␣␣␣###␣remove␣file␣name␣from␣the␣path
␣␣␣␣␣␣␣␣$data[2]␣=~␣s|/[^/]+$||;

␣␣␣␣␣␣␣␣my␣$aobj␣=␣$self->author_tree($author);
␣␣␣␣␣␣␣␣unless(␣$aobj␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(␣loc(␣"No␣such␣author␣'%1'␣--␣can't␣make␣module␣object␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"'%2'␣that␣is␣supposed␣to␣belong␣to␣this␣author",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$author,␣$data[0]␣)␣);
␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣###␣adding␣the␣dslip␣info
␣␣␣␣␣␣␣␣###␣probably␣can␣use␣some␣optimization
␣␣␣␣␣␣␣␣my␣$dslip;
␣␣␣␣␣␣␣␣for␣my␣$item␣(␣qw[␣statd␣stats␣statl␣stati␣statp␣]␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣###␣checking␣if␣there's␣an␣entry␣in␣the␣dslip␣info␣before
␣␣␣␣␣␣␣␣␣␣␣␣###␣catting␣it␣on.␣appeasing␣warnings␣this␣way
␣␣␣␣␣␣␣␣␣␣␣␣$dslip␣.=␣␣␣$dslip_tree->{␣$data[0]␣}->{$item}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣$dslip_tree->{␣$data[0]␣}->{$item}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣'␣';
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣XXX␣this␣could␣be␣sped␣up␣if␣we␣used␣author␣names,␣not␣author
␣␣␣␣␣␣␣␣###␣objects␣in␣creation,␣and␣then␣look␣them␣up␣in␣the␣author␣tree
␣␣␣␣␣␣␣␣###␣when␣needed.␣This␣will␣need␣a␣fix␣to␣all␣the␣places␣that␣create
␣␣␣␣␣␣␣␣###␣fake␣author/module␣objects␣as␣well.

␣␣␣␣␣␣␣␣###␣callback␣to␣store␣the␣individual␣object
␣␣␣␣␣␣␣␣$self->_add_module_object(
␣␣␣␣␣␣␣␣␣␣␣␣module␣␣␣␣␣␣=>␣$data[0],␣␣␣␣␣␣␣␣␣␣␣␣#␣full␣module␣name
␣␣␣␣␣␣␣␣␣␣␣␣version␣␣␣␣␣=>␣($data[1]␣eq␣'undef'␣#␣version␣number␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣'0.0'␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣$data[1]),␣
␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣␣␣␣␣=>␣File::Spec::Unix->catfile(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$conf->_get_mirror('base'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$data[2],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣),␣␣␣␣␣␣␣␣␣␣#␣extended␣path␣on␣the␣cpan␣mirror,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣like␣/A/AB/ABIGAIL
␣␣␣␣␣␣␣␣␣␣␣␣comment␣␣␣␣␣=>␣$data[3],␣␣␣␣#␣comment␣on␣the␣module
␣␣␣␣␣␣␣␣␣␣␣␣author␣␣␣␣␣␣=>␣$aobj,
␣␣␣␣␣␣␣␣␣␣␣␣package␣␣␣␣␣=>␣$package,␣␣␣␣#␣package␣name,␣like
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣'foo-bar-baz-1.03.tar.gz'
␣␣␣␣␣␣␣␣␣␣␣␣description␣=>␣$dslip_tree->{␣$data[0]␣}->{'description'},
␣␣␣␣␣␣␣␣␣␣␣␣dslip␣␣␣␣␣␣␣=>␣$dslip,
␣␣␣␣␣␣␣␣␣␣␣␣mtime␣␣␣␣␣␣␣=>␣'',
␣␣␣␣␣␣␣␣)␣or␣error(␣loc(␣"Could␣not␣add␣module␣'%1'",␣$data[0]␣)␣);

␣␣␣␣}␣#for

␣␣␣␣return␣$self->_mtree;

}␣#_create_mod_tree

=pod

=head2␣$cb->__create_dslip_tree([path␣=>␣$path,␣uptodate␣=>␣BOOL,␣verbose␣=>␣BOOL])

This␣method␣opens␣a␣source␣files␣and␣parses␣its␣contents␣into␣a
searchable␣dslip-tree␣or␣restores␣a␣file-cached␣version␣of␣a
previous␣parse,␣if␣the␣sources␣are␣uptodate␣and␣the␣file-cache␣exists.

It␣takes␣the␣following␣arguments:

=over␣4

=item␣uptodate

A␣flag␣indicating␣whether␣the␣file-cache␣is␣uptodate␣or␣not.

=item␣path

The␣absolute␣path␣to␣the␣directory␣holding␣the␣source␣files.

=item␣verbose

A␣boolean␣flag␣indicating␣whether␣or␣not␣to␣be␣verbose.

=back

Will␣get␣information␣from␣the␣config␣file␣by␣default.

Returns␣a␣tree␣on␣success,␣false␣on␣failure.

=cut

sub␣__create_dslip_tree␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣my␣$conf␣=␣$self->configure_object;

␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣path␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('base')␣},
␣␣␣␣␣␣␣␣verbose␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose')␣},
␣␣␣␣␣␣␣␣uptodate␣=>␣{␣default␣=>␣0␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣###␣get␣the␣file␣name␣of␣the␣source␣###
␣␣␣␣my␣$file␣=␣File::Spec->catfile($args->{path},␣$conf->_get_source('dslip'));

␣␣␣␣###␣extract␣the␣file␣###
␣␣␣␣my␣$ae␣␣␣␣␣␣=␣Archive::Extract->new(␣archive␣=>␣$file␣)␣or␣return;
␣␣␣␣my␣$out␣␣␣␣␣=␣STRIP_GZ_SUFFIX->($file);

␣␣␣␣###␣make␣sure␣to␣set␣the␣PREFER_BIN␣flag␣if␣desired␣###
␣␣␣␣{␣␣␣local␣$Archive::Extract::PREFER_BIN␣=␣$conf->get_conf('prefer_bin');
␣␣␣␣␣␣␣␣$ae->extract(␣to␣=>␣$out␣)␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣or␣return;
␣␣␣␣}

␣␣␣␣my␣$in␣␣␣␣␣␣=␣$self->_get_file_contents(␣file␣=>␣$out␣)␣or␣return;

␣␣␣␣###␣don't␣need␣it␣anymore␣###
␣␣␣␣unlink␣$out;


␣␣␣␣###␣get␣rid␣of␣the␣comments␣and␣the␣code␣###
␣␣␣␣###␣need␣a␣smarter␣parser,␣some␣people␣have␣this␣in␣their␣dslip␣info:
␣␣␣␣#␣[
␣␣␣␣#␣'Statistics::LTU',
␣␣␣␣#␣'R',
␣␣␣␣#␣'d',
␣␣␣␣#␣'p',
␣␣␣␣#␣'O',
␣␣␣␣#␣'?',
␣␣␣␣#␣'Implements␣Linear␣Threshold␣Units',
␣␣␣␣#␣...skipping...
␣␣␣␣#␣"\x{c4}dd␣\x{fc}ml\x{e4}\x{fc}ts␣t\x{f6}␣\x{eb}v\x{eb}r\x{ff}th\x{ef}ng!",
␣␣␣␣#␣'BENNIE',
␣␣␣␣#␣'11'
␣␣␣␣#␣],
␣␣␣␣###␣also,␣older␣versions␣say:
␣␣␣␣###␣$cols␣=␣[....]
␣␣␣␣###␣and␣newer␣versions␣say:
␣␣␣␣###␣$CPANPLUS::Modulelist::cols␣=␣[...]
␣␣␣␣###␣split␣'$cols'␣and␣'$data'␣into␣2␣variables␣###
␣␣␣␣###␣use␣this␣regex␣to␣make␣sure␣dslips␣with␣';'␣in␣them␣don't␣cause
␣␣␣␣###␣parser␣errors
␣␣␣␣my␣($ds_one,␣$ds_two)␣=␣($in␣=~␣m|.+}\s+
										(\$(?:CPAN::Modulelist::)?cols.*?)
										(\$(?:CPAN::Modulelist::)?data.*)
									|sx);

␣␣␣␣###␣eval␣them␣into␣existence␣###
␣␣␣␣###␣still␣not␣too␣fond␣of␣this␣solution␣-␣kane␣###
␣␣␣␣my␣($cols,␣$data);
␣␣␣␣{␣␣␣#local␣$@;␣can't␣use␣this,␣it's␣buggy␣-kane

␣␣␣␣␣␣␣␣$cols␣=␣eval␣$ds_one;
␣␣␣␣␣␣␣␣error(␣loc("Error␣in␣eval␣of␣dslip␣source␣files:␣%1",␣$@)␣)␣if␣$@;

␣␣␣␣␣␣␣␣$data␣=␣eval␣$ds_two;
␣␣␣␣␣␣␣␣error(␣loc("Error␣in␣eval␣of␣dslip␣source␣files:␣%1",␣$@)␣)␣if␣$@;

␣␣␣␣}

␣␣␣␣my␣$tree␣=␣{};
␣␣␣␣my␣$primary␣=␣"modid";

␣␣␣␣###␣this␣comes␣from␣CPAN::Modulelist
␣␣␣␣###␣which␣is␣in␣03modlist.data.gz
␣␣␣␣for␣(@$data){
␣␣␣␣␣␣␣␣my␣%hash;
␣␣␣␣␣␣␣␣@hash{@$cols}␣=␣@$_;
␣␣␣␣␣␣␣␣$tree->{$hash{$primary}}␣=␣\%hash;
␣␣␣␣}

␣␣␣␣return␣$tree;

}␣#__create_dslip_tree

=pod

=head2␣$cb->_dslip_defs␣()

This␣function␣returns␣the␣definition␣structure␣(ARRAYREF)␣of␣the
dslip␣tree.

=cut

###␣these␣are␣the␣definitions␣used␣for␣dslip␣info
###␣they␣shouldn't␣change␣over␣time..␣so␣hardcoding␣them␣doesn't␣appear␣to
###␣be␣a␣problem.␣if␣it␣is,␣we␣need␣to␣parse␣03modlist.data␣better␣to␣filter
###␣all␣this␣out.
###␣right␣now,␣this␣is␣just␣used␣to␣look␣up␣dslip␣info␣from␣a␣module
sub␣_dslip_defs␣{
␣␣␣␣my␣$self␣=␣shift;

␣␣␣␣my␣$aref␣=␣[

␣␣␣␣␣␣␣␣#␣D
␣␣␣␣␣␣␣␣[␣q|Development␣Stage|,␣{
␣␣␣␣␣␣␣␣␣␣␣␣i␣␣␣=>␣loc('Idea,␣listed␣to␣gain␣consensus␣or␣as␣a␣placeholder'),
␣␣␣␣␣␣␣␣␣␣␣␣c␣␣␣=>␣loc('under␣construction␣but␣pre-alpha␣(not␣yet␣released)'),
␣␣␣␣␣␣␣␣␣␣␣␣a␣␣␣=>␣loc('Alpha␣testing'),
␣␣␣␣␣␣␣␣␣␣␣␣b␣␣␣=>␣loc('Beta␣testing'),
␣␣␣␣␣␣␣␣␣␣␣␣R␣␣␣=>␣loc('Released'),
␣␣␣␣␣␣␣␣␣␣␣␣M␣␣␣=>␣loc('Mature␣(no␣rigorous␣definition)'),
␣␣␣␣␣␣␣␣␣␣␣␣S␣␣␣=>␣loc('Standard,␣supplied␣with␣Perl␣5'),
␣␣␣␣␣␣␣␣}],

␣␣␣␣␣␣␣␣#␣S
␣␣␣␣␣␣␣␣[␣q|Support␣Level|,␣{
␣␣␣␣␣␣␣␣␣␣␣␣m␣␣␣=>␣loc('Mailing-list'),
␣␣␣␣␣␣␣␣␣␣␣␣d␣␣␣=>␣loc('Developer'),
␣␣␣␣␣␣␣␣␣␣␣␣u␣␣␣=>␣loc('Usenet␣newsgroup␣comp.lang.perl.modules'),
␣␣␣␣␣␣␣␣␣␣␣␣n␣␣␣=>␣loc('None␣known,␣try␣comp.lang.perl.modules'),
␣␣␣␣␣␣␣␣␣␣␣␣a␣␣␣=>␣loc('Abandoned;␣volunteers␣welcome␣to␣take␣over␣maintainance'),
␣␣␣␣␣␣␣␣}],

␣␣␣␣␣␣␣␣#␣L
␣␣␣␣␣␣␣␣[␣q|Language␣Used|,␣{
␣␣␣␣␣␣␣␣␣␣␣␣p␣␣␣=>␣loc('Perl-only,␣no␣compiler␣needed,␣should␣be␣platform␣independent'),
␣␣␣␣␣␣␣␣␣␣␣␣c␣␣␣=>␣loc('C␣and␣perl,␣a␣C␣compiler␣will␣be␣needed'),
␣␣␣␣␣␣␣␣␣␣␣␣h␣␣␣=>␣loc('Hybrid,␣written␣in␣perl␣with␣optional␣C␣code,␣no␣compiler␣needed'),
␣␣␣␣␣␣␣␣␣␣␣␣'+'␣=>␣loc('C++␣and␣perl,␣a␣C++␣compiler␣will␣be␣needed'),
␣␣␣␣␣␣␣␣␣␣␣␣o␣␣␣=>␣loc('perl␣and␣another␣language␣other␣than␣C␣or␣C++'),
␣␣␣␣␣␣␣␣}],

␣␣␣␣␣␣␣␣#␣I
␣␣␣␣␣␣␣␣[␣q|Interface␣Style|,␣{
␣␣␣␣␣␣␣␣␣␣␣␣f␣␣␣=>␣loc('plain␣Functions,␣no␣references␣used'),
␣␣␣␣␣␣␣␣␣␣␣␣h␣␣␣=>␣loc('hybrid,␣object␣and␣function␣interfaces␣available'),
␣␣␣␣␣␣␣␣␣␣␣␣n␣␣␣=>␣loc('no␣interface␣at␣all␣(huh?)'),
␣␣␣␣␣␣␣␣␣␣␣␣r␣␣␣=>␣loc('some␣use␣of␣unblessed␣References␣or␣ties'),
␣␣␣␣␣␣␣␣␣␣␣␣O␣␣␣=>␣loc('Object␣oriented␣using␣blessed␣references␣and/or␣inheritance'),
␣␣␣␣␣␣␣␣}],

␣␣␣␣␣␣␣␣#␣P
␣␣␣␣␣␣␣␣[␣q|Public␣License|,␣{
␣␣␣␣␣␣␣␣␣␣␣␣p␣␣␣=>␣loc('Standard-Perl:␣user␣may␣choose␣between␣GPL␣and␣Artistic'),
␣␣␣␣␣␣␣␣␣␣␣␣g␣␣␣=>␣loc('GPL:␣GNU␣General␣Public␣License'),
␣␣␣␣␣␣␣␣␣␣␣␣l␣␣␣=>␣loc('LGPL:␣"GNU␣Lesser␣General␣Public␣License"␣(previously␣known␣as␣"GNU␣Library␣General␣Public␣License")'),
␣␣␣␣␣␣␣␣␣␣␣␣b␣␣␣=>␣loc('BSD:␣The␣BSD␣License'),
␣␣␣␣␣␣␣␣␣␣␣␣a␣␣␣=>␣loc('Artistic␣license␣alone'),
␣␣␣␣␣␣␣␣␣␣␣␣o␣␣␣=>␣loc('other␣(but␣distribution␣allowed␣without␣restrictions)'),
␣␣␣␣␣␣␣␣}],
␣␣␣␣];

␣␣␣␣return␣$aref;
}

=head2␣$file␣=␣$cb->_add_custom_module_source(␣uri␣=>␣URI,␣[verbose␣=>␣BOOL]␣);␣

Adds␣a␣custom␣source␣index␣and␣updates␣it␣based␣on␣the␣provided␣URI.

Returns␣the␣full␣path␣to␣the␣index␣file␣on␣success␣or␣false␣on␣failure.

=cut

sub␣_add_custom_module_source␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣my($verbose,$uri);
␣␣␣␣my␣$tmpl␣=␣{␣␣␣
␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣uri␣␣␣␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$uri␣}
␣␣␣␣};
␣␣␣␣
␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣
␣␣␣␣###␣what␣index␣file␣should␣we␣use␣on␣disk?
␣␣␣␣my␣$index␣=␣$self->__custom_module_source_index_file(␣uri␣=>␣$uri␣);

␣␣␣␣###␣already␣have␣it.
␣␣␣␣if(␣IS_FILE->(␣$index␣)␣)␣{
␣␣␣␣␣␣␣␣msg(loc("Source␣'%1'␣already␣added",␣$uri));
␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣
␣␣␣␣###␣do␣we␣need␣to␣create␣the␣targe␣dir?␣␣␣␣␣␣␣␣
␣␣␣␣{␣␣␣my␣$dir␣=␣dirname(␣$index␣);
␣␣␣␣␣␣␣␣unless(␣IS_DIR->(␣$dir␣)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$self->_mkdir(␣dir␣=>␣$dir␣)␣or␣return
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣␣
␣␣␣␣
␣␣␣␣###␣write␣the␣file
␣␣␣␣my␣$fh␣=␣OPEN_FILE->(␣$index␣=>␣'>'␣)␣or␣do␣{
␣␣␣␣␣␣␣␣error(loc("Could␣not␣open␣index␣file␣for␣'%1'",␣$uri));
␣␣␣␣␣␣␣␣return;
␣␣␣␣};
␣␣␣␣
␣␣␣␣###␣basically␣we␣'touched'␣it.␣Check␣the␣return␣value,␣may␣be␣
␣␣␣␣###␣important␣on␣win32␣and␣similar␣OS,␣where␣there's␣file␣length
␣␣␣␣###␣limits
␣␣␣␣close␣$fh␣or␣do␣{
␣␣␣␣␣␣␣␣error(loc("Could␣not␣write␣index␣file␣to␣disk␣for␣'%1'",␣$uri));
␣␣␣␣␣␣␣␣return;
␣␣␣␣};␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣
␣␣␣␣$self->__update_custom_module_source(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣remote␣␣=>␣$uri,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣local␣␣␣=>␣$index,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣$verbose,
␣␣␣␣␣␣␣␣␣␣␣␣)␣or␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣we␣faild␣to␣update␣it,␣we␣probably␣have␣an␣empty
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣possibly␣silly␣filename␣on␣disk␣now␣--␣remove␣it
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣1␣while␣unlink␣$index;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣return␣$index;
}

=head2␣$index␣=␣$cb->__custom_module_source_index_file(␣uri␣=>␣$uri␣);

Returns␣the␣full␣path␣to␣the␣encoded␣index␣file␣for␣C<$uri>,␣as␣used␣by
all␣C<custom␣module␣source>␣routines.

=cut

sub␣__custom_module_source_index_file␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣my($verbose,$uri);
␣␣␣␣my␣$tmpl␣=␣{␣␣␣
␣␣␣␣␣␣␣␣uri␣␣␣␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$uri␣}
␣␣␣␣};
␣␣␣␣
␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣
␣␣␣␣my␣$index␣=␣File::Spec->catfile(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$conf->get_conf('base'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$conf->_get_build('custom_sources'),␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->_uri_encode(␣uri␣=>␣$uri␣),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);␣␣␣␣␣

␣␣␣␣return␣$index;
}

=head2␣$file␣=␣$cb->_remove_custom_module_source(␣uri␣=>␣URI,␣[verbose␣=>␣BOOL]␣);␣

Removes␣a␣custom␣index␣file␣based␣on␣the␣URI␣provided.

Returns␣the␣full␣path␣to␣the␣index␣file␣on␣success␣or␣false␣on␣failure.

=cut

sub␣_remove_custom_module_source␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣my($verbose,$uri);
␣␣␣␣my␣$tmpl␣=␣{␣␣␣
␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣uri␣␣␣␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$uri␣}
␣␣␣␣};
␣␣␣␣
␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣###␣use␣uri␣=>␣local,␣instead␣of␣the␣other␣way␣around
␣␣␣␣my␣%files␣=␣reverse␣$self->__list_custom_module_sources;
␣␣␣␣
␣␣␣␣###␣On␣VMS␣the␣case␣of␣key␣to␣%files␣can␣be␣either␣exact␣or␣lower␣case
␣␣␣␣###␣XXX␣abstract␣this␣lookup␣out?␣--kane
␣␣␣␣my␣$file␣=␣$files{␣$uri␣};
␣␣␣␣$file␣␣␣␣=␣$files{␣lc␣$uri␣}␣if␣!defined($file)␣&&␣ON_VMS;

␣␣␣␣unless␣(defined␣$file)␣{
␣␣␣␣␣␣␣␣error(loc("No␣such␣custom␣source␣'%1'",␣$uri));
␣␣␣␣␣␣␣␣return;
␣␣␣␣};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣1␣while␣unlink␣$file;
␣
␣␣␣␣if(␣IS_FILE->(␣$file␣)␣)␣{
␣␣␣␣␣␣␣␣error(loc("Could␣not␣remove␣index␣file␣'%1'␣for␣custom␣source␣'%2'",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$file,␣$uri));
␣␣␣␣␣␣␣␣return;
␣␣␣␣}␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣msg(loc("Successfully␣removed␣index␣file␣for␣'%1'",␣$uri),␣$verbose);

␣␣␣␣return␣$file;
}

=head2␣%files␣=␣$cb->__list_custom_module_sources

This␣method␣scans␣the␣'custom-sources'␣directory␣in␣your␣base␣directory
for␣additional␣sources␣to␣include␣in␣your␣module␣tree.

Returns␣a␣list␣of␣key␣value␣pairs␣as␣follows:

␣␣/full/path/to/source/file%3Fencoded␣=>␣http://decoded/mirror/path

=cut

sub␣__list_custom_module_sources␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣
␣␣␣␣my($verbose);
␣␣␣␣my␣$tmpl␣=␣{␣␣␣
␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣=>␣\$verbose␣},
␣␣␣␣};␣␣␣␣

␣␣␣␣my␣$dir␣=␣File::Spec->catdir(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$conf->get_conf('base'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$conf->_get_build('custom_sources'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣unless(␣IS_DIR->(␣$dir␣)␣)␣{
␣␣␣␣␣␣␣␣msg(loc("No␣'%1'␣dir,␣skipping␣custom␣sources",␣$dir),␣$verbose);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
␣␣␣␣
␣␣␣␣###␣unencode␣the␣files
␣␣␣␣###␣skip␣ones␣starting␣with␣#␣though
␣␣␣␣my␣%files␣=␣map␣{␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my␣$org␣=␣$_;␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my␣$dec␣=␣$self->_uri_decode(␣uri␣=>␣$_␣);␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣File::Spec->catfile(␣$dir,␣$org␣)␣=>␣$dec
␣␣␣␣}␣grep␣{␣$_␣!~␣/^#/␣}␣READ_DIR->(␣$dir␣);␣␣␣␣␣␣␣␣

␣␣␣␣return␣%files;␣␣␣␣
}

=head2␣$bool␣=␣$cb->__update_custom_module_sources(␣[verbose␣=>␣BOOL]␣);

Attempts␣to␣update␣all␣the␣index␣files␣to␣your␣custom␣module␣sources.

If␣the␣index␣is␣missing,␣and␣it's␣a␣C<file://>␣uri,␣it␣will␣generate
a␣new␣local␣index␣for␣you.

Return␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣__update_custom_module_sources␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣my␣$verbose;
␣␣␣␣my␣$tmpl␣=␣{␣␣␣
␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣=>␣\$verbose␣}
␣␣␣␣};
␣␣␣␣
␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣
␣␣␣␣my␣%files␣=␣$self->__list_custom_module_sources;
␣␣␣␣
␣␣␣␣###␣uptodate␣check␣has␣been␣done␣a␣few␣levels␣up.␣␣␣
␣␣␣␣my␣$fail;
␣␣␣␣while(␣my($local,$remote)␣=␣each␣%files␣)␣{
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣$self->__update_custom_module_source(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣remote␣␣=>␣$remote,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣local␣␣␣=>␣$local,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣$verbose,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣or␣(␣$fail++,␣next␣);␣␣␣␣␣␣␣␣␣
␣␣␣␣}
␣␣␣␣
␣␣␣␣error(loc("Failed␣updating␣one␣or␣more␣remote␣sources␣files"))␣if␣$fail;
␣␣␣␣
␣␣␣␣return␣if␣$fail;
␣␣␣␣return␣1;
}

=head2␣$ok␣=␣$cb->__update_custom_module_source␣

Attempts␣to␣update␣all␣the␣index␣files␣to␣your␣custom␣module␣sources.

If␣the␣index␣is␣missing,␣and␣it's␣a␣C<file://>␣uri,␣it␣will␣generate
a␣new␣local␣index␣for␣you.

Return␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣__update_custom_module_source␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣my($verbose,$local,$remote);
␣␣␣␣my␣$tmpl␣=␣{␣␣␣
␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣local␣␣␣=>␣{␣store␣␣␣␣=>␣\$local,␣allow␣=>␣FILE_EXISTS␣},
␣␣␣␣␣␣␣␣remote␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$remote␣},
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣msg(␣loc("Updating␣sources␣from␣'%1'",␣$remote),␣$verbose);
␣␣␣␣
␣␣␣␣###␣if␣you␣didn't␣provide␣a␣local␣file,␣we'll␣look␣in␣your␣custom
␣␣␣␣###␣dir␣to␣find␣the␣local␣encoded␣version␣for␣you
␣␣␣␣$local␣||=␣do␣{
␣␣␣␣␣␣␣␣###␣find␣all␣files␣we␣know␣of
␣␣␣␣␣␣␣␣my␣%files␣=␣reverse␣$self->__list_custom_module_sources␣or␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("No␣custom␣modules␣sources␣defined␣--␣need␣'%1'␣argument",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'local'));
␣␣␣␣␣␣␣␣␣␣␣␣return;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣};

␣␣␣␣␣␣␣␣###␣On␣VMS␣the␣case␣of␣key␣to␣%files␣can␣be␣either␣exact␣or␣lower␣case
␣␣␣␣␣␣␣␣###␣XXX␣abstract␣this␣lookup␣out?␣--kane
␣␣␣␣␣␣␣␣my␣$file␣=␣$files{␣$remote␣};
␣␣␣␣␣␣␣␣$file␣␣␣␣=␣$files{␣lc␣$remote␣}␣if␣!defined␣($file)␣&&␣ON_VMS;

␣␣␣␣␣␣␣␣###␣return␣the␣local␣file␣we're␣supposed␣to␣use
␣␣␣␣␣␣␣␣$file␣or␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Remote␣source␣'%1'␣unknown␣--␣needs␣'%2'␣argument",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$remote,␣'local'));
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣␣
␣␣␣␣};
␣␣␣␣
␣␣␣␣my␣$uri␣=␣␣join␣'/',␣$remote,␣$conf->_get_source('custom_index');
␣␣␣␣my␣$ff␣␣=␣␣File::Fetch->new(␣uri␣=>␣$uri␣);␣␣␣␣␣␣␣␣␣␣␣

␣␣␣␣###␣tempdir␣doesn't␣clean␣up␣by␣default,␣as␣opposed␣to␣tempfile()
␣␣␣␣###␣so␣add␣it␣explicitly.
␣␣␣␣my␣$dir␣=␣␣tempdir(␣CLEANUP␣=>␣1␣);
␣␣␣␣
␣␣␣␣my␣$res␣=␣␣do␣{␣␣local␣$File::Fetch::WARN␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣local␣$File::Fetch::WARN␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$ff->fetch(␣to␣=>␣$dir␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};

␣␣␣␣###␣couldn't␣get␣the␣file
␣␣␣␣unless(␣$res␣)␣{
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣it's␣not␣a␣local␣scheme,␣so␣can't␣auto␣index
␣␣␣␣␣␣␣␣unless(␣$ff->scheme␣eq␣'file'␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Could␣not␣update␣sources␣from␣'%1':␣%2",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$remote,␣$ff->error␣));
␣␣␣␣␣␣␣␣␣␣␣␣return;␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣it's␣a␣local␣uri,␣we␣can␣index␣it␣ourselves
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣msg(loc("No␣index␣file␣found␣at␣'%1',␣generating␣one",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$ff->uri),␣$verbose␣);
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣ON␣VMS,␣if␣you␣are␣working␣with␣a␣UNIX␣file␣specification,
␣␣␣␣␣␣␣␣␣␣␣␣###␣you␣need␣currently␣use␣the␣UNIX␣variants␣of␣the␣File::Spec.
␣␣␣␣␣␣␣␣␣␣␣␣my␣$ff_path␣=␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$file_class␣=␣'File::Spec';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$file_class␣.=␣'::Unix'␣if␣ON_VMS;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$file_class->catdir(␣File::Spec::Unix->splitdir(␣$ff->path␣)␣);
␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣

␣␣␣␣␣␣␣␣␣␣␣␣$self->__write_custom_module_index(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣=>␣$ff_path,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣to␣␣␣␣␣␣=>␣$local,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣$verbose,
␣␣␣␣␣␣␣␣␣␣␣␣)␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣XXX␣don't␣write␣that␣here,␣__write_custom_module_index
␣␣␣␣␣␣␣␣␣␣␣␣###␣already␣prints␣this␣out
␣␣␣␣␣␣␣␣␣␣␣␣#msg(loc("Index␣file␣written␣to␣'%1'",␣$to),␣$verbose);
␣␣␣␣␣␣␣␣}
␣␣␣␣
␣␣␣␣###␣copy␣it␣to␣the␣real␣spot␣and␣update␣its␣timestamp
␣␣␣␣}␣else␣{␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣$self->_move(␣file␣=>␣$res,␣to␣=>␣$local␣)␣or␣return;
␣␣␣␣␣␣␣␣$self->_update_timestamp(␣file␣=>␣$local␣);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣msg(loc("Index␣file␣saved␣to␣'%1'",␣$local),␣$verbose);
␣␣␣␣}
␣␣␣␣
␣␣␣␣return␣$local;
}

=head2␣$bool␣=␣$cb->__write_custom_module_index(␣path␣=>␣/path/to/packages,␣[to␣=>␣/path/to/index/file,␣verbose␣=>␣BOOL]␣)

Scans␣the␣C<path>␣you␣provided␣for␣packages␣and␣writes␣an␣index␣with␣all␣
the␣available␣packages␣to␣C<$path/packages.txt>.␣If␣you'd␣like␣the␣index
to␣be␣written␣to␣a␣different␣file,␣provide␣the␣C<to>␣argument.

Returns␣true␣on␣success␣and␣false␣on␣failure.

=cut

sub␣__write_custom_module_index␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣my␣($verbose,␣$path,␣$to);
␣␣␣␣my␣$tmpl␣=␣{␣␣␣
␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣path␣␣␣␣=>␣{␣required␣=>␣1,␣allow␣=>␣DIR_EXISTS,␣store␣=>␣\$path␣},
␣␣␣␣␣␣␣␣to␣␣␣␣␣␣=>␣{␣store␣=>␣\$to␣},
␣␣␣␣};
␣␣␣␣
␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;␣␣␣␣

␣␣␣␣###␣no␣explicit␣to?␣then␣we'll␣use␣our␣default
␣␣␣␣$to␣||=␣File::Spec->catfile(␣$path,␣$conf->_get_source('custom_index')␣);

␣␣␣␣my␣@files;
␣␣␣␣require␣File::Find;
␣␣␣␣File::Find::find(␣sub␣{␣
␣␣␣␣␣␣␣␣###␣let's␣see␣if␣A::E␣can␣even␣parse␣it
␣␣␣␣␣␣␣␣my␣$ae␣=␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣local␣$Archive::Extract::WARN␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣local␣$Archive::Extract::WARN␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣Archive::Extract->new(␣archive␣=>␣$File::Find::name␣)␣
␣␣␣␣␣␣␣␣}␣or␣return;␣

␣␣␣␣␣␣␣␣###␣it's␣a␣type␣A::E␣recognize,␣so␣we␣can␣add␣it
␣␣␣␣␣␣␣␣$ae->type␣or␣return;

␣␣␣␣␣␣␣␣###␣neither␣$_␣nor␣$File::Find::name␣have␣the␣chunk␣of␣the␣path␣in
␣␣␣␣␣␣␣␣###␣it␣starting␣$path␣--␣it's␣either␣only␣the␣filename,␣or␣the␣full
␣␣␣␣␣␣␣␣###␣path,␣so␣we␣have␣to␣strip␣it␣ourselves
␣␣␣␣␣␣␣␣###␣make␣sure␣to␣remove␣the␣leading␣slash␣as␣well.
␣␣␣␣␣␣␣␣my␣$copy␣=␣$File::Find::name;
␣␣␣␣␣␣␣␣my␣$re␣␣␣=␣quotemeta($path);␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣$copy␣␣␣␣=~␣s|^$re[\\/]?||i;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣push␣@files,␣$copy;
␣␣␣␣␣␣␣␣
␣␣␣␣},␣$path␣);

␣␣␣␣###␣does␣the␣dir␣exist?␣if␣not,␣create␣it.
␣␣␣␣{␣␣␣my␣$dir␣=␣dirname(␣$to␣);
␣␣␣␣␣␣␣␣unless(␣IS_DIR->(␣$dir␣)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$self->_mkdir(␣dir␣=>␣$dir␣)␣or␣return
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣␣␣␣␣␣␣␣

␣␣␣␣###␣create␣the␣index␣file
␣␣␣␣my␣$fh␣=␣OPEN_FILE->(␣$to␣=>␣'>'␣)␣or␣return;
␣␣␣␣
␣␣␣␣print␣$fh␣"$_\n"␣for␣@files;
␣␣␣␣close␣$fh;
␣␣␣␣
␣␣␣␣msg(loc("Successfully␣written␣index␣file␣to␣'%1'",␣$to),␣$verbose);
␣␣␣␣
␣␣␣␣return␣$to;
}


=head2␣$bool␣=␣$cb->__create_custom_module_entries(␣[verbose␣=>␣BOOL]␣)␣

Creates␣entries␣in␣the␣module␣tree␣based␣upon␣the␣files␣as␣returned
by␣C<__list_custom_module_sources>.

Returns␣true␣on␣success,␣false␣on␣failure.

=cut␣

###␣use␣$auth_obj␣as␣a␣persistant␣version,␣so␣we␣don't␣have␣to␣recreate
###␣modules␣all␣the␣time
{␣␣␣my␣$auth_obj;␣

␣␣␣␣sub␣__create_custom_module_entries␣{
␣␣␣␣␣␣␣␣my␣$self␣␣␣␣=␣shift;
␣␣␣␣␣␣␣␣my␣$conf␣␣␣␣=␣$self->configure_object;
␣␣␣␣␣␣␣␣my␣%hash␣␣␣␣=␣@_;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my␣$verbose;
␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),␣store␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣};
␣␣␣␣
␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return␣undef;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my␣%files␣=␣$self->__list_custom_module_sources;␣␣␣␣␣
␣␣␣␣
␣␣␣␣␣␣␣␣while(␣my($file,$name)␣=␣each␣%files␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣msg(loc("Adding␣packages␣from␣custom␣source␣'%1'",␣$name),␣$verbose);
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣my␣$fh␣=␣OPEN_FILE->(␣$file␣)␣or␣next;
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣while(␣local␣$_␣=␣<$fh>␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣chomp;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣if␣/^#/;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣/\S+/;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣join␣on␣/␣--␣it's␣a␣URI␣after␣all!
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$parse␣=␣join␣'/',␣$name,␣$_;
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣try␣to␣make␣a␣module␣object␣out␣of␣it
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$mod␣=␣$self->parse_module(␣module␣=>␣$parse␣)␣or␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Could␣not␣parse␣'%1'",␣$_)),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣mark␣this␣object␣with␣a␣custom␣author
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$auth_obj␣||=␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$id␣=␣CUSTOM_AUTHOR_ID;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣if␣the␣object␣is␣being␣created␣for␣the␣first␣time,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣make␣sure␣there's␣an␣entry␣in␣the␣author␣tree␣as
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣well,␣so␣we␣can␣search␣on␣the␣CPAN␣ID
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->author_tree->{␣$id␣}␣=␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CPANPLUS::Module::Author::Fake->new(␣cpanid␣=>␣$id␣);␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mod->author(␣$auth_obj␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣and␣now␣add␣it␣to␣the␣modlue␣tree␣--␣this␣MAY
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣override␣things␣of␣course
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣my␣$old_mod␣=␣$self->module_tree(␣$mod->module␣)␣)␣{

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣On␣VMS␣use␣the␣old␣module␣name␣to␣get␣the␣real␣case
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mod->module(␣$old_mod->module␣)␣if␣ON_VMS;

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣msg(loc("About␣to␣overwrite␣module␣tree␣entry␣for␣'%1'␣with␣'%2'",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mod->module,␣$mod->package),␣$verbose);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣mark␣where␣it␣came␣from
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mod->description(␣loc("Custom␣source␣from␣'%1'",$name)␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣store␣it␣in␣the␣module␣tree
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->module_tree->{␣$mod->module␣}␣=␣$mod;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}
}

1;
package␣CPANPLUS::Internals::Extract;

use␣strict;

use␣CPANPLUS::Error;
use␣CPANPLUS::Internals::Constants;

use␣File::Spec␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣();
use␣File::Basename␣␣␣␣␣␣␣␣␣␣␣␣␣␣();
use␣Archive::Extract;
use␣IPC::Cmd␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[run];
use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[check];
use␣Module::Load::Conditional␣␣␣qw[can_load␣check_install];
use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';

local␣$Params::Check::VERBOSE␣=␣1;

=pod

=head1␣NAME

CPANPLUS::Internals::Extract

=head1␣SYNOPSIS

␣␣␣␣###␣for␣source␣files␣###
␣␣␣␣$self->_gunzip(␣file␣=>␣'foo.gz',␣output␣=>␣'blah.txt'␣);
␣␣␣␣
␣␣␣␣###␣for␣modules/packages␣###
␣␣␣␣$dir␣=␣$self->_extract(␣module␣␣␣␣␣␣=>␣$modobj,␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣extractdir␣␣=>␣'/some/where'␣);

=head1␣DESCRIPTION

CPANPLUS::Internals::Extract␣extracts␣compressed␣files␣for␣CPANPLUS.
It␣can␣do␣this␣by␣either␣a␣pure␣perl␣solution␣(preferred)␣with␣the␣
use␣of␣C<Archive::Tar>␣and␣C<Compress::Zlib>,␣or␣with␣binaries,␣like
C<gzip>␣and␣C<tar>.
␣
The␣flow␣looks␣like␣this:

␣␣␣␣$cb->_extract
␣␣␣␣␣␣␣␣Delegate␣to␣Archive::Extract
␣
=head1␣METHODS

=head2␣$dir␣=␣_extract(␣module␣=>␣$modobj,␣[perl␣=>␣'/path/to/perl',␣extractdir␣=>␣'/path/to/extract/to',␣prefer_bin␣=>␣BOOL,␣verbose␣=>␣BOOL,␣force␣=>␣BOOL]␣)

C<_extract>␣will␣take␣a␣module␣object␣and␣extract␣it␣to␣C<extractdir>
if␣provided,␣or␣the␣default␣location␣which␣is␣obtained␣from␣your␣
config.

The␣file␣name␣is␣obtained␣by␣looking␣at␣C<<␣$modobj->status->fetch␣>>
and␣will␣be␣parsed␣to␣see␣if␣it's␣a␣tar␣or␣zip␣archive.

If␣it's␣a␣zip␣archive,␣C<__unzip>␣will␣be␣called,␣otherwise␣C<__untar>
will␣be␣called.␣In␣the␣unlikely␣event␣the␣file␣is␣of␣neither␣format,
an␣error␣will␣be␣thrown.

C<_extract>␣takes␣the␣following␣options:

=over␣4

=item␣module

A␣C<CPANPLUS::Module>␣object.␣This␣is␣required.

=item␣extractdir

The␣directory␣to␣extract␣the␣archive␣to.␣By␣default␣this␣looks␣
something␣like:
␣␣␣␣/CPANPLUS_BASE/PERL_VERSION/BUILD/MODULE_NAME

=item␣prefer_bin

A␣flag␣indicating␣whether␣you␣prefer␣a␣pure␣perl␣solution,␣ie
C<Archive::Tar>␣or␣C<Archive::Zip>␣respectively,␣or␣a␣binary␣solution
like␣C<unzip>␣and␣C<tar>.

=item␣perl

The␣path␣to␣the␣perl␣executable␣to␣use␣for␣any␣perl␣calls.␣Also␣used
to␣determine␣the␣build␣version␣directory␣for␣extraction.

=item␣verbose

Specifies␣whether␣to␣be␣verbose␣or␣not.␣Defaults␣to␣your␣corresponding
config␣entry.

=item␣force

Specifies␣whether␣to␣force␣the␣extraction␣or␣not.␣Defaults␣to␣your
corresponding␣config␣entry.

=back

All␣other␣options␣are␣passed␣on␣verbatim␣to␣C<__unzip>␣or␣C<__untar>.

Returns␣the␣directory␣the␣file␣was␣extracted␣to␣on␣success␣and␣false
on␣failure.

=cut

sub␣_extract␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣local␣$Params::Check::ALLOW_UNKNOWN␣=␣1;
␣␣␣␣
␣␣␣␣my(␣$mod,␣$verbose,␣$force␣);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣force␣␣␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('force'),␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$force␣},
␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣prefer_bin␣␣=>␣{␣default␣=>␣$conf->get_conf('prefer_bin')␣},
␣␣␣␣␣␣␣␣extractdir␣␣=>␣{␣default␣=>␣$conf->get_conf('extractdir')␣},
␣␣␣␣␣␣␣␣module␣␣␣␣␣␣=>␣{␣required␣=>␣1,␣allow␣=>␣IS_MODOBJ,␣store␣=>␣\$mod␣},
␣␣␣␣␣␣␣␣perl␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣$^X␣},
␣␣␣␣};
␣␣␣␣
␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣
␣␣␣␣###␣did␣we␣already␣extract␣it␣?␣###
␣␣␣␣my␣$loc␣=␣$mod->status->extract();
␣␣␣␣
␣␣␣␣if(␣$loc␣&&␣!$force␣)␣{
␣␣␣␣␣␣␣␣msg(loc("Already␣extracted␣'%1'␣to␣'%2'.␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Won't␣extract␣again␣without␣force",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mod->module,␣$loc),␣$verbose);
␣␣␣␣␣␣␣␣return␣$loc;
␣␣␣␣}

␣␣␣␣###␣did␣we␣already␣fetch␣the␣file?␣###
␣␣␣␣my␣$file␣=␣$mod->status->fetch();
␣␣␣␣unless(␣-s␣$file␣)␣{
␣␣␣␣␣␣␣␣error(␣loc(␣"File␣'%1'␣has␣zero␣size:␣cannot␣extract",␣$file␣)␣);␣␣␣␣
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣###␣the␣dir␣to␣extract␣to␣###
␣␣␣␣my␣$to␣=␣␣␣␣$args->{'extractdir'}␣||
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣File::Spec->catdir(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$conf->get_conf('base'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->_perl_version(␣perl␣=>␣$args->{'perl'}␣),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$conf->_get_build('moddir'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣
␣␣␣␣###␣delegate␣to␣Archive::Extract␣###
␣␣␣␣###␣set␣up␣some␣flags␣for␣archive::extract␣###
␣␣␣␣local␣$Archive::Extract::PREFER_BIN␣=␣$args->{'prefer_bin'};
␣␣␣␣local␣$Archive::Extract::DEBUG␣␣␣␣␣␣=␣$conf->get_conf('debug');
␣␣␣␣local␣$Archive::Extract::WARN␣␣␣␣␣␣␣=␣$verbose;

␣␣␣␣my␣$ae␣=␣Archive::Extract->new(␣archive␣=>␣$file␣);

␣␣␣␣unless(␣$ae->extract(␣to␣=>␣$to␣)␣)␣{
␣␣␣␣␣␣␣␣error(␣loc(␣"Unable␣to␣extract␣'%1'␣to␣'%2':␣%3",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$file,␣$to,␣$ae->error␣)␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
␣␣␣␣
␣␣␣␣###␣if␣->files␣is␣not␣filled,␣we␣dont␣know␣what␣the␣hell␣was
␣␣␣␣###␣extracted..␣try␣to␣offer␣a␣suggestion␣and␣bail␣:(
␣␣␣␣unless␣(␣$ae->files␣)␣{
␣␣␣␣␣␣␣␣error(␣loc(␣"'%1'␣was␣not␣able␣to␣determine␣extracted␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"files␣from␣the␣archive.␣Instal␣'%2'␣and␣ensure␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"it␣works␣properly␣and␣try␣again",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$ae->is_zip␣?␣'Archive::Zip'␣:␣'Archive::Tar'␣)␣);
␣␣␣␣␣␣␣␣return;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣}␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣
␣␣␣␣
␣␣␣␣###␣print␣out␣what␣files␣we␣extracted␣###␣␣
␣␣␣␣msg(loc("Extracted␣'%1'",$_),$verbose)␣for␣@{$ae->files};␣␣
␣␣␣␣
␣␣␣␣###␣set␣them␣all␣to␣be␣+w␣for␣the␣owner,␣so␣we␣don't␣get␣permission
␣␣␣␣###␣denied␣for␣overwriting␣files␣that␣are␣just␣+r
␣␣␣␣
␣␣␣␣###␣this␣is␣to␣rigurous␣--␣just␣change␣to␣+w␣for␣the␣owner␣[cpan␣#13358]␣
␣␣␣␣#chmod␣0755,␣map␣{␣File::Spec->rel2abs(␣File::Spec->catdir($to,␣$_)␣)␣}
␣␣␣␣#␣␣␣␣␣␣␣␣␣␣␣␣@{$ae->files};
␣␣␣␣
␣␣␣␣for␣my␣$file␣(␣@{$ae->files}␣)␣{␣
␣␣␣␣␣␣␣␣my␣$path␣=␣File::Spec->rel2abs(␣File::Spec->catfile($to,␣$file)␣);
␣␣␣␣
␣␣␣␣␣␣␣␣$self->_mode_plus_w(␣file␣=>␣$path␣);
␣␣␣␣}
␣␣␣␣
␣␣␣␣###␣check␣the␣return␣value␣for␣the␣extracted␣path␣###
␣␣␣␣###␣Make␣an␣educated␣guess␣if␣we␣didn't␣get␣an␣extract_path
␣␣␣␣###␣back
␣␣␣␣###␣XXX␣apparently␣some␣people␣make␣their␣own␣dists␣and␣they␣
␣␣␣␣###␣pack␣up␣'.'␣which␣means␣the␣leading␣directory␣is␣'.'␣
␣␣␣␣###␣and␣only␣the␣second␣directory␣is␣the␣actual␣module␣directory
␣␣␣␣###␣so,␣we'll␣have␣to␣check␣if␣our␣educated␣guess␣exists␣first,␣
␣␣␣␣###␣then␣see␣if␣the␣extract␣path␣works..␣and␣if␣nothing␣works...
␣␣␣␣###␣well,␣then␣we␣really␣don't␣know.

␣␣␣␣my␣$dir;
␣␣␣␣for␣my␣$try␣(
␣␣␣␣␣␣␣␣File::Spec->rel2abs(␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣_safe_path␣must␣be␣called␣before␣catdir␣because␣catdir␣on␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣VMS␣currently␣will␣not␣handle␣the␣extra␣dots␣in␣the␣directories.
␣␣␣␣␣␣␣␣␣␣␣␣File::Spec->catdir(␣$self->_safe_path(␣path␣=>␣$to␣)␣,␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->_safe_path(␣path␣=>
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mod->package_name␣.'-'.␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mod->package_version
␣␣␣␣␣␣␣␣)␣)␣)␣,
␣␣␣␣␣␣␣␣File::Spec->rel2abs(␣$ae->extract_path␣),
␣␣␣␣)␣{
␣␣␣␣␣␣␣␣($dir␣=␣$try)␣&&␣last␣if␣-d␣$try;
␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣###␣test␣if␣the␣dir␣exists␣###
␣␣␣␣unless(␣$dir␣&&␣-d␣$dir␣)␣{
␣␣␣␣␣␣␣␣error(loc("Unable␣to␣determine␣extract␣dir␣for␣'%1'",$mod->module));
␣␣␣␣␣␣␣␣return;
␣␣␣␣
␣␣␣␣}␣else␣{␣␣␣␣
␣␣␣␣␣␣␣␣msg(loc("Extracted␣'%1'␣to␣'%2'",␣$mod->module,␣$dir),␣$verbose);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣register␣where␣we␣extracted␣the␣files␣to,
␣␣␣␣␣␣␣␣###␣also␣store␣what␣files␣were␣extracted
␣␣␣␣␣␣␣␣$mod->status->extract(␣$dir␣);␣
␣␣␣␣␣␣␣␣$mod->status->files(␣$ae->files␣);
␣␣␣␣}
␣␣␣␣␣␣
␣␣␣␣###␣also,␣figure␣out␣what␣kind␣of␣install␣we're␣dealing␣with␣###
␣␣␣␣$mod->get_installer_type();

␣␣␣␣return␣$mod->status->extract();
}

1;

#␣Local␣variables:
#␣c-indentation-style:␣bsd
#␣c-basic-offset:␣4
#␣indent-tabs-mode:␣nil
#␣End:
#␣vim:␣expandtab␣shiftwidth=4:
package␣CPANPLUS::Internals::Constants::Report;

use␣strict;
use␣CPANPLUS::Error;

use␣File::Spec;
use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';

require␣Exporter;
use␣vars␣␣␣␣qw[$VERSION␣@ISA␣@EXPORT];

use␣Package::Constants;

###␣for␣the␣version
require␣CPANPLUS::Internals;

$VERSION␣␣␣␣=␣$CPANPLUS::Internals::VERSION␣=␣$CPANPLUS::Internals::VERSION;
@ISA␣␣␣␣␣␣␣␣=␣qw[Exporter];
@EXPORT␣␣␣␣␣=␣Package::Constants->list(␣__PACKAGE__␣);


###␣OS␣to␣regex␣map␣###
my␣%OS␣=␣(
␣␣␣␣Amiga␣␣␣␣␣␣␣=>␣'amigaos',
␣␣␣␣Atari␣␣␣␣␣␣␣=>␣'mint',
␣␣␣␣BSD␣␣␣␣␣␣␣␣␣=>␣'bsdos|darwin|freebsd|openbsd|netbsd',
␣␣␣␣Be␣␣␣␣␣␣␣␣␣␣=>␣'beos',
␣␣␣␣BeOS␣␣␣␣␣␣␣␣=>␣'beos',
␣␣␣␣Cygwin␣␣␣␣␣␣=>␣'cygwin',
␣␣␣␣Darwin␣␣␣␣␣␣=>␣'darwin',
␣␣␣␣EBCDIC␣␣␣␣␣␣=>␣'os390|os400|posix-bc|vmesa',
␣␣␣␣HPUX␣␣␣␣␣␣␣␣=>␣'hpux',
␣␣␣␣Linux␣␣␣␣␣␣␣=>␣'linux',
␣␣␣␣MSDOS␣␣␣␣␣␣␣=>␣'dos|os2|MSWin32|cygwin',
␣␣␣␣'bin\\d*Mac'=>␣'MacOS|darwin',␣#␣binMac,␣bin56Mac,␣bin58Mac...
␣␣␣␣Mac␣␣␣␣␣␣␣␣␣=>␣'MacOS|darwin',
␣␣␣␣MacPerl␣␣␣␣␣=>␣'MacOS',
␣␣␣␣MacOS␣␣␣␣␣␣␣=>␣'MacOS|darwin',
␣␣␣␣MacOSX␣␣␣␣␣␣=>␣'darwin',
␣␣␣␣MPE␣␣␣␣␣␣␣␣␣=>␣'mpeix',
␣␣␣␣MPEiX␣␣␣␣␣␣␣=>␣'mpeix',
␣␣␣␣OS2␣␣␣␣␣␣␣␣␣=>␣'os2',
␣␣␣␣Plan9␣␣␣␣␣␣␣=>␣'plan9',
␣␣␣␣RISCOS␣␣␣␣␣␣=>␣'riscos',
␣␣␣␣SGI␣␣␣␣␣␣␣␣␣=>␣'irix',
␣␣␣␣Solaris␣␣␣␣␣=>␣'solaris',
␣␣␣␣Unix␣␣␣␣␣␣␣␣=>␣'aix|bsdos|darwin|dgux|dynixptx|freebsd|'.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'linux|hpux|machten|netbsd|next|openbsd|dec_osf|'.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'svr4|sco_sv|unicos|unicosmk|solaris|sunos',
␣␣␣␣VMS␣␣␣␣␣␣␣␣␣=>␣'VMS',
␣␣␣␣VOS␣␣␣␣␣␣␣␣␣=>␣'VOS',
␣␣␣␣Win32␣␣␣␣␣␣␣=>␣'MSWin32|cygwin',
␣␣␣␣Win32API␣␣␣␣=>␣'MSWin32|cygwin',
);

use␣constant␣GRADE_FAIL␣␣␣␣␣=>␣'fail';
use␣constant␣GRADE_PASS␣␣␣␣␣=>␣'pass';
use␣constant␣GRADE_NA␣␣␣␣␣␣␣=>␣'na';
use␣constant␣GRADE_UNKNOWN␣␣=>␣'unknown';

use␣constant␣MAX_REPORT_SEND
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣2;

use␣constant␣CPAN_TESTERS_EMAIL
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣'cpan-testers@perl.org';

###␣the␣cpan␣mail␣account␣for␣this␣user␣###
use␣constant␣CPAN_MAIL_ACCOUNT
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$username␣=␣shift␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$username␣.␣'@cpan.org';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};

###␣check␣if␣this␣module␣is␣platform␣specific␣and␣if␣we're␣on␣that
###␣specific␣platform.␣Alternately,␣the␣module␣is␣not␣platform␣specific
###␣and␣we're␣always␣OK␣to␣send␣out␣test␣results.
use␣constant␣RELEVANT_TEST_RESULT
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$mod␣␣=␣shift␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$name␣=␣$mod->module;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$specific;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣for␣my␣$platform␣(keys␣%OS)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣$name␣=~␣/\b$platform\b/i␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣beware␣the␣Mac␣!=␣MAC
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣if($platform␣eq␣'Mac'␣&&
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$name␣!~␣/\b$platform\b/);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$specific++;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣1␣if
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$^O␣=~␣/^(?:$OS{$platform})$/
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$specific␣?␣0␣:␣1;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};

use␣constant␣UNSUPPORTED_OS
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$buffer␣=␣shift␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣$buffer␣=~
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/No␣support␣for␣OS|OS␣unsupported/im␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣0;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣

use␣constant␣PERL_VERSION_TOO_LOW
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$buffer␣=␣shift␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣ExtUtils::MakeMaker␣format
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣$buffer␣=~
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/Perl␣.*?␣required--this␣is␣only␣.*?/m␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣Module::Build␣format
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣$buffer␣=~
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/ERROR:(␣perl:)?␣Version␣.*?(␣of␣perl)?␣is␣installed,␣but␣we␣need␣version␣>=␣.*?/m␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣0;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣

use␣constant␣NO_TESTS_DEFINED
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$buffer␣=␣shift␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣$buffer␣=~
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/(No␣tests␣defined(␣for␣[\w:]+␣extension)?\.)/
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣and␣$buffer␣!~␣/\*\.t/m␣and
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$buffer␣!~␣/test\.pl/m
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣{␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$1␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};

###␣what␣stage␣did␣the␣test␣fail?␣###
use␣constant␣TEST_FAIL_STAGE
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$buffer␣=␣shift␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$buffer␣=~␣/(MAKE␣[A-Z]+).*/
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣lc␣$1␣:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'fetch';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};


use␣constant␣MISSING_PREREQS_LIST
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$buffer␣=␣shift;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$last␣=␣(␣split␣/\[ERROR\]␣.+?␣MAKE␣TEST/,␣$buffer␣)[-1];
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣@list␣=␣map␣{␣s/.pm$//;␣s|/|::|g;␣$_␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣($last␣=~
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣m/\bCan\'t␣locate␣(\S+)␣in␣\@INC/g);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣make␣sure␣every␣missing␣prereq␣is␣only␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣listed␣once
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣␣␣my␣%seen;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣@list␣=␣grep␣{␣!$seen{$_}++␣}␣@list
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣@list;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};

use␣constant␣MISSING_EXTLIBS_LIST
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$buffer␣=␣shift;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣@list␣=␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣($buffer␣=~
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣m/No␣library␣found␣for␣-l([-\w]+)/g);

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣@list;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};

use␣constant␣REPORT_MESSAGE_HEADER
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣($version,␣$author)␣=␣@_;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣<<␣".";

Dear␣$author,
␣␣␣␣
This␣is␣a␣computer-generated␣error␣report␣created␣automatically␣by
CPANPLUS,␣version␣$version.␣Testers␣personal␣comments␣may␣appear␣
at␣the␣end␣of␣this␣report.

.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};

use␣constant␣REPORT_MESSAGE_FAIL_HEADER
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my($stage,␣$buffer)␣=␣@_;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣<<␣".";

Thank␣you␣for␣uploading␣your␣work␣to␣CPAN.␣␣However,␣it␣appears␣that
there␣were␣some␣problems␣testing␣your␣distribution.

TEST␣RESULTS:

Below␣is␣the␣error␣stack␣from␣stage␣'$stage':

$buffer

.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};

use␣constant␣REPORT_MISSING_PREREQS
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣($author,$email,@missing)␣=␣@_;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$author␣=␣($author␣&&␣$email)␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣"$author␣($email)"␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣'Your␣Name␣Here';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$modules␣=␣join␣"\n",␣@missing;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$prereqs␣=␣join␣"\n",␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣map␣{"\t'$_'\t=>␣'0',".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"␣#␣or␣a␣minimum␣working␣version"}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣@missing;

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣<<␣".";

MISSING␣PREREQUISITES:

It␣was␣observed␣that␣the␣test␣suite␣seem␣to␣fail␣without␣these␣modules:

$modules

As␣such,␣adding␣the␣prerequisite␣module(s)␣to␣'PREREQ_PM'␣in␣your
Makefile.PL␣should␣solve␣this␣problem.␣␣For␣example:

WriteMakefile(
␣␣␣␣AUTHOR␣␣␣␣␣␣=>␣'$author',
␣␣␣␣...␣#␣other␣information
␣␣␣␣PREREQ_PM␣␣␣=>␣{
$prereqs
␣␣␣␣}
);

Thanks!␣:-)

.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};

use␣constant␣REPORT_MISSING_TESTS
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣<<␣".";
RECOMMENDATIONS:

It␣would␣be␣very␣helpful␣if␣you␣could␣include␣even␣a␣simple␣test␣
script␣in␣the␣next␣release,␣so␣people␣can␣verify␣which␣platforms
can␣successfully␣install␣them,␣as␣well␣as␣avoid␣regression␣bugs?

A␣simple␣'t/use.t'␣that␣says:

#!/usr/bin/env␣perl␣-w
use␣strict;
use␣Test;
BEGIN␣{␣plan␣tests␣=>␣1␣}

use␣Your::Module::Here;␣ok(1);
exit;
package␣CPANPLUS::Internals::Report;

use␣strict;

use␣CPANPLUS::Error;
use␣CPANPLUS::Internals::Constants;
use␣CPANPLUS::Internals::Constants::Report;

use␣Data::Dumper;

use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[check];
use␣Module::Load::Conditional␣␣␣qw[can_load];
use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';

$Params::Check::VERBOSE␣=␣1;

###␣for␣the␣version␣###
require␣CPANPLUS::Internals;

=head1␣NAME

CPANPLUS::Internals::Report

=head1␣SYNOPSIS

␣␣###␣enable␣test␣reporting
␣␣$cb->configure_object->set_conf(␣cpantest␣=>␣1␣);
␣␣␣␣
␣␣###␣set␣custom␣mx␣host,␣shouldn't␣normally␣be␣needed
␣␣$cb->configure_object->set_conf(␣cpantest_mx␣=>␣'smtp.example.com'␣);

=head1␣DESCRIPTION

This␣module␣provides␣all␣the␣functionality␣to␣send␣test␣reports␣to
C<http://testers.cpan.org>␣using␣the␣C<Test::Reporter>␣module.

All␣methods␣will␣be␣called␣automatically␣if␣you␣have␣C<CPANPLUS>
configured␣to␣enable␣test␣reporting␣(see␣the␣C<SYNOPSIS>).

=head1␣METHODS

=head2␣$bool␣=␣$cb->_have_query_report_modules

This␣function␣checks␣if␣all␣the␣required␣modules␣are␣here␣for␣querying
reports.␣It␣returns␣true␣and␣loads␣them␣if␣they␣are,␣or␣returns␣false
otherwise.

=head2␣$bool␣=␣$cb->_have_send_report_modules

This␣function␣checks␣if␣all␣the␣required␣modules␣are␣here␣for␣sending
reports.␣It␣returns␣true␣and␣loads␣them␣if␣they␣are,␣or␣returns␣false
otherwise.

=cut

###␣XXX␣remove␣this␣list␣and␣move␣it␣into␣selfupdate,␣somehow..
###␣this␣is␣dual␣administration
{␣␣␣my␣$query_list␣=␣{
␣␣␣␣␣␣␣␣'File::Fetch'␣␣␣␣␣␣␣␣␣␣=>␣'0.13_02',
␣␣␣␣␣␣␣␣'Parse::CPAN::Meta'␣␣␣␣=>␣'0.0',
␣␣␣␣␣␣␣␣'File::Temp'␣␣␣␣␣␣␣␣␣␣␣=>␣'0.0',
␣␣␣␣};

␣␣␣␣my␣$send_list␣=␣{
␣␣␣␣␣␣␣␣%$query_list,
␣␣␣␣␣␣␣␣'Test::Reporter'␣=>␣'1.34',
␣␣␣␣};

␣␣␣␣sub␣_have_query_report_modules␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣=>␣$conf->get_conf('verbose')␣},
␣␣␣␣␣␣␣␣};

␣␣␣␣␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣␣␣␣␣return␣can_load(␣modules␣=>␣$query_list,␣verbose␣=>␣$args->{verbose}␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣1
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣0;
␣␣␣␣}

␣␣␣␣sub␣_have_send_report_modules␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣=>␣$conf->get_conf('verbose')␣},
␣␣␣␣␣␣␣␣};

␣␣␣␣␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣␣␣␣␣return␣can_load(␣modules␣=>␣$send_list,␣verbose␣=>␣$args->{verbose}␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣1
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣0;
␣␣␣␣}
}

=head2␣@list␣=␣$cb->_query_report(␣module␣=>␣$modobj,␣[all_versions␣=>␣BOOL,␣verbose␣=>␣BOOL]␣)

This␣function␣queries␣the␣CPAN␣testers␣database␣at
I<http://testers.cpan.org/>␣for␣test␣results␣of␣specified␣module␣objects,
module␣names␣or␣distributions.␣

The␣optional␣argument␣C<all_versions>␣controls␣whether␣all␣versions␣of
a␣given␣distribution␣should␣be␣grabbed.␣␣It␣defaults␣to␣false
(fetching␣only␣reports␣for␣the␣current␣version).

Returns␣the␣a␣list␣with␣the␣following␣data␣structures␣(for␣CPANPLUS
version␣0.042)␣on␣success,␣or␣false␣on␣failure.␣The␣contents␣of␣the
data␣structure␣depends␣on␣what␣I<http://testers.cpan.org>␣returns,
but␣generally␣looks␣like␣this:

␣␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣'grade'␣=>␣'PASS',
␣␣␣␣␣␣␣␣␣␣␣␣'dist'␣=>␣'CPANPLUS-0.042',
␣␣␣␣␣␣␣␣␣␣␣␣'platform'␣=>␣'i686-pld-linux-thread-multi'
␣␣␣␣␣␣␣␣␣␣␣␣'details'␣=>␣'http://nntp.x.perl.org/group/perl.cpan.testers/98316'
␣␣␣␣␣␣␣␣␣␣␣␣...
␣␣␣␣␣␣␣␣␣␣},
␣␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣'grade'␣=>␣'PASS',
␣␣␣␣␣␣␣␣␣␣␣␣'dist'␣=>␣'CPANPLUS-0.042',
␣␣␣␣␣␣␣␣␣␣␣␣'platform'␣=>␣'i686-linux-thread-multi'
␣␣␣␣␣␣␣␣␣␣␣␣'details'␣=>␣'http://nntp.x.perl.org/group/perl.cpan.testers/99416'
␣␣␣␣␣␣␣␣␣␣␣␣...
␣␣␣␣␣␣␣␣␣␣},
␣␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣'grade'␣=>␣'FAIL',
␣␣␣␣␣␣␣␣␣␣␣␣'dist'␣=>␣'CPANPLUS-0.042',
␣␣␣␣␣␣␣␣␣␣␣␣'platform'␣=>␣'cygwin-multi-64int',
␣␣␣␣␣␣␣␣␣␣␣␣'details'␣=>␣'http://nntp.x.perl.org/group/perl.cpan.testers/99371'
␣␣␣␣␣␣␣␣␣␣␣␣...
␣␣␣␣␣␣␣␣␣␣},
␣␣␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣'grade'␣=>␣'FAIL',
␣␣␣␣␣␣␣␣␣␣␣␣'dist'␣=>␣'CPANPLUS-0.042',
␣␣␣␣␣␣␣␣␣␣␣␣'platform'␣=>␣'i586-linux',
␣␣␣␣␣␣␣␣␣␣␣␣'details'␣=>␣'http://nntp.x.perl.org/group/perl.cpan.testers/99396'
␣␣␣␣␣␣␣␣␣␣␣␣...
␣␣␣␣␣␣␣␣␣␣},

The␣status␣of␣the␣test␣can␣be␣one␣of␣the␣following:
UNKNOWN,␣PASS,␣FAIL␣or␣NA␣(not␣applicable).

=cut

sub␣_query_report␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my($mod,␣$verbose,␣$all);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣module␣␣␣␣␣␣␣␣␣␣=>␣{␣required␣=>␣1,␣allow␣=>␣IS_MODOBJ,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$mod␣},
␣␣␣␣␣␣␣␣verbose␣␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣all_versions␣␣␣␣=>␣{␣default␣=>␣0,␣store␣=>␣\$all␣},
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣###␣check␣if␣we␣have␣the␣modules␣we␣need␣for␣querying
␣␣␣␣return␣unless␣$self->_have_query_report_modules(␣verbose␣=>␣1␣);


␣␣␣␣###␣XXX␣no␣longer␣use␣LWP␣here.␣However,␣that␣means␣we␣don't
␣␣␣␣###␣automagically␣set␣proxies␣anymore!!!
␣␣␣␣#␣my␣$ua␣=␣LWP::UserAgent->new;
␣␣␣␣#␣$ua->agent(␣CPANPLUS_UA->()␣);
␣␣␣␣#
␣␣␣␣###␣set␣proxies␣if␣we␣have␣them␣###
␣␣␣␣#␣$ua->env_proxy();

␣␣␣␣my␣$url␣=␣TESTERS_URL->($mod->package_name);
␣␣␣␣my␣$ff␣␣=␣File::Fetch->new(␣uri␣=>␣$url␣);

␣␣␣␣msg(␣loc("Fetching:␣'%1'",␣$url),␣$verbose␣);

␣␣␣␣my␣$res␣=␣do␣{
␣␣␣␣␣␣␣␣my␣$tempdir␣=␣File::Temp::tempdir();
␣␣␣␣␣␣␣␣my␣$where␣␣␣=␣$ff->fetch(␣to␣=>␣$tempdir␣);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣unless(␣$where␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(␣loc(␣"Fetching␣report␣for␣'%1'␣failed:␣%2",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$url,␣$ff->error␣)␣);
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣my␣$fh␣=␣OPEN_FILE->(␣$where␣);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣do␣{␣local␣$/;␣<$fh>␣};
␣␣␣␣};

␣␣␣␣my␣($aref)␣=␣eval␣{␣Parse::CPAN::Meta::Load(␣$res␣)␣};

␣␣␣␣if(␣$@␣)␣{
␣␣␣␣␣␣␣␣error(loc("Error␣reading␣result:␣%1",␣$@));
␣␣␣␣␣␣␣␣return;
␣␣␣␣};

␣␣␣␣my␣$dist␣␣␣␣=␣$mod->package_name␣.'-'.␣$mod->package_version;
␣␣␣␣my␣$details␣=␣TESTERS_DETAILS_URL->($mod->package_name);

␣␣␣␣my␣@rv;
␣␣␣␣for␣my␣$href␣(␣@$aref␣)␣{
␣␣␣␣␣␣␣␣next␣unless␣$all␣or␣defined␣$href->{'distversion'}␣&&␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$href->{'distversion'}␣eq␣$dist;

␣␣␣␣␣␣␣␣$href->{'details'}␣␣=␣$details;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣backwards␣compatibility␣:(
␣␣␣␣␣␣␣␣$href->{'dist'}␣␣␣␣␣||=␣$href->{'distversion'};
␣␣␣␣␣␣␣␣$href->{'grade'}␣␣␣␣||=␣$href->{'action'}␣||␣$href->{'status'};

␣␣␣␣␣␣␣␣push␣@rv,␣$href;
␣␣␣␣}

␣␣␣␣return␣@rv␣if␣@rv;
␣␣␣␣return;
}

=pod

=head2␣$bool␣=␣$cb->_send_report(␣module␣=>␣$modobj,␣buffer␣=>␣$make_output,␣failed␣=>␣BOOL,␣[save␣=>␣BOOL,␣address␣=>␣$email_to,␣verbose␣=>␣BOOL,␣force␣=>␣BOOL]);

This␣function␣sends␣a␣testers␣report␣to␣C<cpan-testers@perl.org>␣for␣a
particular␣distribution.
It␣returns␣true␣on␣success,␣and␣false␣on␣failure.

It␣takes␣the␣following␣options:

=over␣4

=item␣module

The␣module␣object␣of␣this␣particular␣distribution

=item␣buffer

The␣output␣buffer␣from␣the␣'make/make␣test'␣process

=item␣failed

Boolean␣indicating␣if␣the␣'make/make␣test'␣went␣wrong

=item␣save

Boolean␣indicating␣if␣the␣report␣should␣be␣saved␣locally␣instead␣of
mailed␣out.␣If␣provided,␣this␣function␣will␣return␣the␣location␣the
report␣was␣saved␣to,␣rather␣than␣a␣simple␣boolean␣'TRUE'.

Defaults␣to␣false.

=item␣address

The␣email␣address␣to␣mail␣the␣report␣for.␣You␣should␣never␣need␣to
override␣this,␣but␣it␣might␣be␣useful␣for␣debugging␣purposes.

Defaults␣to␣C<cpan-testers@perl.org>.

=item␣verbose

Boolean␣indicating␣on␣whether␣or␣not␣to␣be␣verbose.

Defaults␣to␣your␣configuration␣settings

=item␣force

Boolean␣indicating␣whether␣to␣force␣the␣sending,␣even␣if␣the␣max
amount␣of␣reports␣for␣fails␣have␣already␣been␣reached,␣or␣if␣you
may␣already␣have␣sent␣it␣before.

Defaults␣to␣your␣configuration␣settings

=back

=cut

sub␣_send_report␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣###␣do␣you␣even␣/have/␣test::reporter?␣###
␣␣␣␣unless(␣$self->_have_send_report_modules(verbose␣=>␣1)␣)␣{
␣␣␣␣␣␣␣␣error(␣loc(␣"You␣don't␣have␣'%1'␣(or␣modules␣required␣by␣'%2')␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"installed,␣you␣cannot␣report␣test␣results.",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'Test::Reporter',␣'Test::Reporter'␣)␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣###␣check␣arguments␣###
␣␣␣␣my␣($buffer,␣$failed,␣$mod,␣$verbose,␣$force,␣$address,␣$save,␣
␣␣␣␣␣␣␣␣$tests_skipped␣);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣module␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$mod,␣allow␣=>␣IS_MODOBJ␣},
␣␣␣␣␣␣␣␣␣␣␣␣buffer␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$buffer␣},
␣␣␣␣␣␣␣␣␣␣␣␣failed␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$failed␣},
␣␣␣␣␣␣␣␣␣␣␣␣address␣=>␣{␣default␣␣=>␣CPAN_TESTERS_EMAIL,␣store␣=>␣\$address␣},
␣␣␣␣␣␣␣␣␣␣␣␣save␣␣␣␣=>␣{␣default␣␣=>␣0,␣store␣=>␣\$save␣},
␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣␣␣␣␣force␣␣␣=>␣{␣default␣␣=>␣$conf->get_conf('force'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$force␣},
␣␣␣␣␣␣␣␣␣␣␣␣tests_skipped␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣0,␣store␣=>␣\$tests_skipped␣},
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣###␣get␣the␣data␣to␣fill␣the␣email␣with␣###
␣␣␣␣my␣$name␣␣␣␣=␣$mod->module;
␣␣␣␣my␣$dist␣␣␣␣=␣$mod->package_name␣.␣'-'␣.␣$mod->package_version;
␣␣␣␣my␣$author␣␣=␣$mod->author->author;
␣␣␣␣my␣$email␣␣␣=␣$mod->author->email␣||␣CPAN_MAIL_ACCOUNT->(␣$author␣);
␣␣␣␣my␣$cp_conf␣=␣$conf->get_conf('cpantest')␣||␣'';
␣␣␣␣my␣$int_ver␣=␣$CPANPLUS::Internals::VERSION;
␣␣␣␣my␣$cb␣␣␣␣␣␣=␣$mod->parent;


␣␣␣␣###␣will␣be␣'fetch',␣'make',␣'test',␣'install',␣etc␣###
␣␣␣␣my␣$stage␣␣␣=␣TEST_FAIL_STAGE->($buffer);

␣␣␣␣###␣determine␣the␣grade␣now␣###

␣␣␣␣my␣$grade;
␣␣␣␣###␣check␣if␣this␣is␣a␣platform␣specific␣module␣###
␣␣␣␣###␣if␣we␣failed␣the␣test,␣there␣may␣be␣reasons␣why␣
␣␣␣␣###␣an␣'NA'␣might␣have␣to␣be␣insted
␣␣␣␣GRADE:␣{␣if␣(␣$failed␣)␣{
␣␣␣␣␣␣␣␣

␣␣␣␣␣␣␣␣###␣XXX␣duplicated␣logic␣between␣this␣block
␣␣␣␣␣␣␣␣###␣and␣REPORTED_LOADED_PREREQS␣:(
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣figure␣out␣if␣the␣prereqs␣are␣on␣CPAN␣at␣all
␣␣␣␣␣␣␣␣###␣--␣if␣not,␣send␣NA␣grade
␣␣␣␣␣␣␣␣###␣Also,␣if␣our␣version␣of␣prereqs␣is␣too␣low,
␣␣␣␣␣␣␣␣###␣--␣send␣NA␣grade.
␣␣␣␣␣␣␣␣###␣This␣is␣to␣address␣bug:␣#25327:␣do␣not␣count␣
␣␣␣␣␣␣␣␣###␣as␣FAIL␣modules␣where␣prereqs␣are␣not␣filled
␣␣␣␣␣␣␣␣{␣␣␣my␣$prq␣=␣$mod->status->prereqs␣||␣{};
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣while(␣my($prq_name,$prq_ver)␣=␣each␣%$prq␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$obj␣=␣$cb->module_tree(␣$prq_name␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$sub␣=␣CPANPLUS::Module->can(␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'module_is_supplied_with_perl_core'␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣if␣we␣can't␣find␣the␣module␣and␣it's␣not␣supplied␣with␣core.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣this␣addresses:␣#32064:␣NA␣reports␣generated␣for␣failing
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣tests␣where␣core␣prereqs␣are␣specified
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣Note␣that␣due␣to␣a␣bug␣in␣Module::CoreList,␣in␣some␣released
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣version␣of␣perl␣(5.8.6+␣and␣5.9.2-4␣at␣the␣time␣of␣writing)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣'Config'␣is␣not␣recognized␣as␣a␣core␣module.␣See␣this␣bug:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣␣␣␣http://rt.cpan.org/Ticket/Display.html?id=32155
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣!$obj␣and␣!$sub->(␣$prq_name␣)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣msg(loc(␣"Prerequisite␣'%1'␣for␣'%2'␣could␣not␣be␣obtained".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"␣from␣CPAN␣--␣sending␣N/A␣grade",␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$prq_name,␣$name␣),␣$verbose␣);

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$grade␣=␣GRADE_NA;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣last␣GRADE;␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(␣!$obj␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$vcore␣=␣$sub->(␣$prq_name␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(␣$cb->_vcmp(␣$prq_ver,␣$vcore␣)␣>␣0␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣msg(loc(␣"Version␣of␣core␣module␣'%1'␣('%2')␣is␣too␣low␣for␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"'%3'␣(needs␣'%4')␣--␣sending␣N/A␣grade",␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$prq_name,␣$vcore,␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$name,␣$prq_ver␣),␣$verbose␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$grade␣=␣GRADE_NA;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣last␣GRADE;␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣$obj␣and␣$cb->_vcmp(␣$prq_ver,␣$obj->installed_version␣)␣>␣0␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣msg(loc(␣"Installed␣version␣of␣'%1'␣('%2')␣is␣too␣low␣for␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"'%3'␣(needs␣'%4')␣--␣sending␣N/A␣grade",␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$prq_name,␣$obj->installed_version,␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$name,␣$prq_ver␣),␣$verbose␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$grade␣=␣GRADE_NA;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣last␣GRADE;␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣unless(␣RELEVANT_TEST_RESULT->($mod)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣msg(loc(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"'%1'␣is␣a␣platform␣specific␣module,␣and␣the␣test␣results␣on".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"␣your␣platform␣are␣not␣relevant␣--sending␣N/A␣grade.",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$name),␣$verbose);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣$grade␣=␣GRADE_NA;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣}␣elsif␣(␣UNSUPPORTED_OS->(␣$buffer␣)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣msg(loc(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"'%1'␣is␣a␣platform␣specific␣module,␣and␣the␣test␣results␣on".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"␣your␣platform␣are␣not␣relevant␣--sending␣N/A␣grade.",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$name),␣$verbose);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣$grade␣=␣GRADE_NA;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣you␣dont␣have␣a␣high␣enough␣perl␣version?␣␣␣␣
␣␣␣␣␣␣␣␣}␣elsif␣(␣PERL_VERSION_TOO_LOW->(␣$buffer␣)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣msg(loc("'%1'␣requires␣a␣higher␣version␣of␣perl␣than␣your␣current␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"version␣--␣sending␣N/A␣grade.",␣$name),␣$verbose);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣$grade␣=␣GRADE_NA;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣

␣␣␣␣␣␣␣␣###␣perhaps␣where␣were␣no␣tests...
␣␣␣␣␣␣␣␣###␣see␣if␣the␣thing␣even␣had␣tests␣###
␣␣␣␣␣␣␣␣}␣elsif␣(␣NO_TESTS_DEFINED->(␣$buffer␣)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$grade␣=␣GRADE_UNKNOWN;
␣␣␣␣␣␣␣␣###␣failures␣in␣PL␣or␣make/build␣stage␣are␣now␣considered␣UNKNOWN
␣␣␣␣␣␣␣␣}␣elsif␣(␣$stage␣!~␣/\btest\b/␣)␣{

␣␣␣␣␣␣␣␣␣␣␣␣$grade␣=␣GRADE_UNKNOWN

␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣$grade␣=␣GRADE_FAIL;
␣␣␣␣␣␣␣␣}

␣␣␣␣###␣if␣we␣got␣here,␣it␣didn't␣fail␣and␣tests␣were␣present..␣so␣a␣PASS
␣␣␣␣###␣is␣in␣order
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣$grade␣=␣GRADE_PASS;
␣␣␣␣}␣}

␣␣␣␣###␣so␣an␣error␣occurred,␣let's␣see␣what␣stage␣it␣went␣wrong␣in␣###

␣␣␣␣###␣the␣header␣--␣always␣include␣so␣the␣CPANPLUS␣version␣is␣apparent
␣␣␣␣my␣$message␣=␣␣REPORT_MESSAGE_HEADER->(␣$int_ver,␣$author␣);

␣␣␣␣if(␣$grade␣eq␣GRADE_FAIL␣or␣$grade␣eq␣GRADE_UNKNOWN)␣{

␣␣␣␣␣␣␣␣###␣return␣if␣one␣or␣more␣missing␣external␣libraries
␣␣␣␣␣␣␣␣if(␣my␣@missing␣=␣MISSING_EXTLIBS_LIST->($buffer)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣msg(loc("Not␣sending␣test␣report␣-␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"external␣libraries␣not␣pre-installed"));
␣␣␣␣␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣###␣return␣if␣we're␣only␣supposed␣to␣report␣make_test␣failures␣###
␣␣␣␣␣␣␣␣return␣1␣if␣$cp_conf␣=~␣␣/\bmaketest_only\b/i
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣and␣($stage␣!~␣/\btest\b/);

␣␣␣␣␣␣␣␣###␣the␣bit␣where␣we␣inform␣what␣went␣wrong
␣␣␣␣␣␣␣␣$message␣.=␣REPORT_MESSAGE_FAIL_HEADER->(␣$stage,␣$buffer␣);

␣␣␣␣␣␣␣␣###␣was␣it␣missing␣prereqs?␣###
␣␣␣␣␣␣␣␣if(␣my␣@missing␣=␣MISSING_PREREQS_LIST->($buffer)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣if(!$self->_verify_missing_prereqs(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣module␣␣=>␣$mod,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣missing␣=>␣\@missing
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣msg(loc("Not␣sending␣test␣report␣-␣"␣␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"bogus␣missing␣prerequisites␣report"));
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$message␣.=␣REPORT_MISSING_PREREQS->($author,$email,@missing);
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣###␣was␣it␣missing␣test␣files?␣###
␣␣␣␣␣␣␣␣if(␣NO_TESTS_DEFINED->($buffer)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$message␣.=␣REPORT_MISSING_TESTS->();
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣###␣add␣a␣list␣of␣what␣modules␣have␣been␣loaded␣of␣your␣prereqs␣list
␣␣␣␣␣␣␣␣$message␣.=␣REPORT_LOADED_PREREQS->($mod);

␣␣␣␣␣␣␣␣###␣add␣a␣list␣of␣versions␣of␣toolchain␣modules
␣␣␣␣␣␣␣␣$message␣.=␣REPORT_TOOLCHAIN_VERSIONS->($mod);

␣␣␣␣␣␣␣␣###␣the␣footer
␣␣␣␣␣␣␣␣$message␣.=␣REPORT_MESSAGE_FOOTER->();

␣␣␣␣###␣it␣may␣be␣another␣grade␣than␣fail/unknown..␣may␣be␣worth␣noting
␣␣␣␣###␣that␣tests␣got␣skipped,␣since␣the␣buffer␣is␣not␣added␣in
␣␣␣␣}␣elsif␣(␣$tests_skipped␣)␣{
␣␣␣␣␣␣␣␣$message␣.=␣REPORT_TESTS_SKIPPED->();
␣␣␣␣}␣elsif(␣$grade␣eq␣GRADE_NA)␣{
␣␣␣␣
␣␣␣␣␣␣␣␣###␣the␣bit␣where␣we␣inform␣what␣went␣wrong
␣␣␣␣␣␣␣␣$message␣.=␣REPORT_MESSAGE_FAIL_HEADER->(␣$stage,␣$buffer␣);

␣␣␣␣␣␣␣␣###␣the␣footer
␣␣␣␣␣␣␣␣$message␣.=␣REPORT_MESSAGE_FOOTER->();

␣␣␣␣}

␣␣␣␣msg(␣loc("Sending␣test␣report␣for␣'%1'",␣$dist),␣$verbose);

␣␣␣␣###␣reporter␣object␣###
␣␣␣␣my␣$reporter␣=␣do␣{
␣␣␣␣␣␣␣␣my␣$args␣=␣$conf->get_conf('cpantest_reporter_args')␣||␣{};
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣unless(␣UNIVERSAL::isa(␣$args,␣'HASH'␣)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("'%1'␣must␣be␣a␣hashref,␣ignoring...",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'cpantest_reporter_args'));
␣␣␣␣␣␣␣␣␣␣␣␣$args␣=␣{};
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣Test::Reporter->new(
␣␣␣␣␣␣␣␣␣␣␣␣grade␣␣␣␣␣␣␣␣␣␣␣=>␣$grade,
␣␣␣␣␣␣␣␣␣␣␣␣distribution␣␣␣␣=>␣$dist,
␣␣␣␣␣␣␣␣␣␣␣␣via␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣"CPANPLUS␣$int_ver",
␣␣␣␣␣␣␣␣␣␣␣␣timeout␣␣␣␣␣␣␣␣␣=>␣$conf->get_conf('timeout')␣||␣60,
␣␣␣␣␣␣␣␣␣␣␣␣debug␣␣␣␣␣␣␣␣␣␣␣=>␣$conf->get_conf('debug'),
␣␣␣␣␣␣␣␣␣␣␣␣%$args,
␣␣␣␣␣␣␣␣);
␣␣␣␣};
␣␣␣␣
␣␣␣␣###␣set␣a␣custom␣mx,␣if␣requested
␣␣␣␣$reporter->mx(␣[␣$conf->get_conf('cpantest_mx')␣]␣)␣
␣␣␣␣␣␣␣␣if␣$conf->get_conf('cpantest_mx');

␣␣␣␣###␣set␣the␣from␣address␣###
␣␣␣␣$reporter->from(␣$conf->get_conf('email')␣)
␣␣␣␣␣␣␣␣if␣$conf->get_conf('email')␣!~␣/\@example\.\w+$/i;

␣␣␣␣###␣give␣the␣user␣a␣chance␣to␣programattically␣alter␣the␣message
␣␣␣␣$message␣=␣$self->_callbacks->munge_test_report->($mod,␣$message,␣$grade);

␣␣␣␣###␣add␣the␣body␣if␣we␣have␣any␣###
␣␣␣␣$reporter->comments(␣$message␣)␣if␣defined␣$message␣&&␣length␣$message;

␣␣␣␣###␣do␣a␣callback␣to␣ask␣if␣we␣should␣send␣the␣report
␣␣␣␣unless␣($self->_callbacks->send_test_report->($mod,␣$grade))␣{
␣␣␣␣␣␣␣␣msg(loc("Ok,␣not␣sending␣test␣report"));
␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}

␣␣␣␣###␣do␣a␣callback␣to␣ask␣if␣we␣should␣edit␣the␣report
␣␣␣␣if␣($self->_callbacks->edit_test_report->($mod,␣$grade))␣{
␣␣␣␣␣␣␣␣###␣test::reporter␣1.20␣and␣lower␣don't␣have␣a␣way␣to␣set
␣␣␣␣␣␣␣␣###␣the␣preferred␣editor␣with␣a␣method␣call,␣but␣it␣does
␣␣␣␣␣␣␣␣###␣respect␣your␣env␣variable,␣so␣let's␣set␣that.
␣␣␣␣␣␣␣␣local␣$ENV{VISUAL}␣=␣$conf->get_program('editor')
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣$conf->get_program('editor');

␣␣␣␣␣␣␣␣$reporter->edit_comments;
␣␣␣␣}

␣␣␣␣###␣allow␣to␣be␣overridden,␣but␣default␣to␣the␣normal␣address␣###
␣␣␣␣$reporter->address(␣$address␣);

␣␣␣␣###␣should␣we␣save␣it␣locally?␣###
␣␣␣␣if(␣$save␣)␣{
␣␣␣␣␣␣␣␣if(␣my␣$file␣=␣$reporter->write()␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣msg(loc("Successfully␣wrote␣report␣for␣'%1'␣to␣'%2'",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$dist,␣$file),␣$verbose);
␣␣␣␣␣␣␣␣␣␣␣␣return␣$file;

␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Failed␣to␣write␣report␣for␣'%1'",␣$dist));
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}

␣␣␣␣###␣XXX␣should␣we␣do␣an␣'already␣sent'␣check?␣###
␣␣␣␣###␣something␣broke␣:(␣###
␣␣␣␣}␣
␣␣␣␣else␣{
␣␣␣␣␣␣␣␣my␣$status;
␣␣␣␣␣␣␣␣eval␣{␣
␣␣␣␣␣␣␣␣␣␣␣␣$status␣=␣$reporter->send();
␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣if␣(␣$@␣)␣{
␣␣␣␣␣␣␣␣␣␣␣error(loc("Could␣not␣send␣'%1'␣report␣for␣'%2':␣%3",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$grade,␣$dist,␣$@));
␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣(␣$status␣)␣{
␣␣␣␣␣␣␣␣␣␣␣msg(loc("Successfully␣sent␣'%1'␣report␣for␣'%2'",␣$grade,␣$dist),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$verbose);
␣␣␣␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣error(loc("Could␣not␣send␣'%1'␣report␣for␣'%2':␣%3",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$grade,␣$dist,␣$reporter->errstr));
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
}

sub␣_verify_missing_prereqs␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣###␣check␣arguments␣###
␣␣␣␣my␣($mod,␣$missing);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣module␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$mod␣},
␣␣␣␣␣␣␣␣␣␣␣␣missing␣=>␣{␣required␣=>␣1,␣store␣=>␣\$missing␣},
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣
␣␣␣␣my␣%missing␣=␣map␣{$_␣=>␣1}␣@$missing;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣$extract␣=␣$mod->status->extract;

␣␣␣␣###␣Read␣pre-requisites␣from␣Makefile.PL␣or␣Build.PL␣(if␣there␣is␣one),
␣␣␣␣###␣of␣the␣form:
␣␣␣␣###␣␣␣␣␣'PREREQ_PM'␣=>␣{
␣␣␣␣###␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'Compress::Zlib'␣␣␣␣␣␣␣␣=>␣'1.20',
␣␣␣␣###␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'Test::More'␣␣␣␣␣␣␣␣␣␣␣␣=>␣0,
␣␣␣␣###␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣},
␣␣␣␣###␣␣Build.PL␣uses␣'requires'␣instead␣of␣'PREREQ_PM'.

␣␣␣␣my␣@search;
␣␣␣␣push␣@search,␣($extract␣?␣MAKEFILE_PL->(␣$extract␣)␣:␣MAKEFILE_PL->());
␣␣␣␣push␣@search,␣($extract␣?␣BUILD_PL->(␣$extract␣)␣:␣BUILD_PL->());

␣␣␣␣for␣my␣$file␣(␣@search␣)␣{
␣␣␣␣␣␣␣␣if(-e␣$file␣and␣-r␣$file)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$slurp␣=␣$self->_get_file_contents(file␣=>␣$file);
␣␣␣␣␣␣␣␣␣␣␣␣my␣($prereq)␣=␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣($slurp␣=~␣/'?(?:PREREQ_PM|requires)'?\s*=>\s*{(.*?)}/s);
␣␣␣␣␣␣␣␣␣␣␣␣my␣@prereq␣=␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣($prereq␣=~␣/'?([\w\:]+)'?\s*=>\s*'?\d[\d\.\-\_]*'?/sg);
␣␣␣␣␣␣␣␣␣␣␣␣delete␣$missing{$_}␣for(@prereq);
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣return␣1␣␣␣␣if(keys␣%missing);␣␣#␣There␣ARE␣missing␣prerequisites
␣␣␣␣return;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣All␣prerequisites␣accounted␣for
}

1;


#␣Local␣variables:
#␣c-indentation-style:␣bsd
#␣c-basic-offset:␣4
#␣indent-tabs-mode:␣nil
#␣End:
#␣vim:␣expandtab␣shiftwidth=4:
package␣CPANPLUS::Internals::Constants;

use␣strict;

use␣CPANPLUS::Error;

use␣Config;
use␣File::Spec;
use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';

require␣Exporter;
use␣vars␣␣␣␣qw[$VERSION␣@ISA␣@EXPORT];

use␣Package::Constants;

@ISA␣␣␣␣␣␣␣␣=␣qw[Exporter];
@EXPORT␣␣␣␣␣=␣Package::Constants->list(␣__PACKAGE__␣);


sub␣constants␣{␣@EXPORT␣};

use␣constant␣INSTALLER_BUILD
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣'CPANPLUS::Dist::Build';
use␣constant␣INSTALLER_MM␣␣␣=>␣'CPANPLUS::Dist::MM';␣␣␣␣
use␣constant␣INSTALLER_SAMPLE␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣'CPANPLUS::Dist::Sample';
use␣constant␣INSTALLER_BASE␣=>␣'CPANPLUS::Dist::Base';␣␣
use␣constant␣INSTALLER_AUTOBUNDLE
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣'CPANPLUS::Dist::Autobundle';

use␣constant␣SHELL_DEFAULT␣␣=>␣'CPANPLUS::Shell::Default';
use␣constant␣SHELL_CLASSIC␣␣=>␣'CPANPLUS::Shell::Classic';

use␣constant␣CONFIG␣␣␣␣␣␣␣␣␣=>␣'CPANPLUS::Config';
use␣constant␣CONFIG_USER␣␣␣␣=>␣'CPANPLUS::Config::User';
use␣constant␣CONFIG_SYSTEM␣␣=>␣'CPANPLUS::Config::System';
use␣constant␣CONFIG_BOXED␣␣␣=>␣'CPANPLUS::Config::Boxed';

use␣constant␣DEFAULT_SOURCE_ENGINE
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣'CPANPLUS::Internals::Source::Memory';

use␣constant␣TARGET_INIT␣␣␣␣=>␣'init';
use␣constant␣TARGET_CREATE␣␣=>␣'create';
use␣constant␣TARGET_PREPARE␣=>␣'prepare';
use␣constant␣TARGET_INSTALL␣=>␣'install';
use␣constant␣TARGET_IGNORE␣␣=>␣'ignore';

use␣constant␣ON_WIN32␣␣␣␣␣␣␣=>␣$^O␣eq␣'MSWin32';
use␣constant␣ON_NETWARE␣␣␣␣␣=>␣$^O␣eq␣'NetWare';
use␣constant␣ON_CYGWIN␣␣␣␣␣␣=>␣$^O␣eq␣'cygwin';
use␣constant␣ON_VMS␣␣␣␣␣␣␣␣␣=>␣$^O␣eq␣'VMS';

use␣constant␣DOT_CPANPLUS␣␣␣=>␣ON_VMS␣?␣'_cpanplus'␣:␣'.cpanplus';␣

use␣constant␣OPT_AUTOFLUSH␣␣=>␣'-MCPANPLUS::Internals::Utils::Autoflush';

use␣constant␣UNKNOWN_DL_LOCATION
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣'UNKNOWN-ORIGIN';␣␣␣

use␣constant␣NMAKE␣␣␣␣␣␣␣␣␣␣=>␣'nmake.exe';
use␣constant␣NMAKE_URL␣␣␣␣␣␣=>␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'ftp://ftp.microsoft.com/Softlib/MSLFILES/nmake15.exe';

use␣constant␣INSTALL_VIA_PACKAGE_MANAGER␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{␣my␣$fmt␣=␣$_[0]␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣1␣if␣$fmt␣ne␣INSTALLER_BUILD␣and
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$fmt␣ne␣INSTALLER_MM;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣

use␣constant␣IS_CODEREF␣␣␣␣␣=>␣sub␣{␣ref␣$_[-1]␣eq␣'CODE'␣};
use␣constant␣IS_MODOBJ␣␣␣␣␣␣=>␣sub␣{␣UNIVERSAL::isa($_[-1],␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'CPANPLUS::Module')␣};␣
use␣constant␣IS_FAKE_MODOBJ␣=>␣sub␣{␣UNIVERSAL::isa($_[-1],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'CPANPLUS::Module::Fake')␣};
use␣constant␣IS_AUTHOBJ␣␣␣␣␣=>␣sub␣{␣UNIVERSAL::isa($_[-1],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'CPANPLUS::Module::Author')␣};
use␣constant␣IS_FAKE_AUTHOBJ
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{␣UNIVERSAL::isa($_[-1],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'CPANPLUS::Module::Author::Fake')␣};

use␣constant␣IS_CONFOBJ␣␣␣␣␣=>␣sub␣{␣UNIVERSAL::isa($_[-1],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'CPANPLUS::Configure')␣};

use␣constant␣IS_RVOBJ␣␣␣␣␣␣␣=>␣sub␣{␣UNIVERSAL::isa($_[-1],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'CPANPLUS::Backend::RV')␣};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
use␣constant␣IS_INTERNALS_OBJ
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{␣UNIVERSAL::isa($_[-1],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'CPANPLUS::Internals')␣};␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
use␣constant␣IS_FILE␣␣␣␣␣␣␣␣=>␣sub␣{␣return␣1␣if␣-e␣$_[-1]␣};␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣

use␣constant␣FILE_EXISTS␣␣␣␣=>␣sub␣{␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$file␣=␣$_[-1];
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣1␣if␣IS_FILE->($file);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣local␣$Carp::CarpLevel␣=␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$Carp::CarpLevel+2;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(loc(␣␣q[File␣'%1'␣does␣not␣exist],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$file));
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣

use␣constant␣FILE_READABLE␣␣=>␣sub␣{␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$file␣=␣$_[-1];
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣1␣if␣-e␣$file␣&&␣-r␣_;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣local␣$Carp::CarpLevel␣=␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$Carp::CarpLevel+2;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(␣loc(␣q[File␣'%1'␣is␣not␣readable␣].
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣q[or␣does␣not␣exist],␣$file));
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣
use␣constant␣IS_DIR␣␣␣␣␣␣␣␣␣=>␣sub␣{␣return␣1␣if␣-d␣$_[-1]␣};

use␣constant␣DIR_EXISTS␣␣␣␣␣=>␣sub␣{␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$dir␣=␣$_[-1];
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣1␣if␣IS_DIR->($dir);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣local␣$Carp::CarpLevel␣=␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$Carp::CarpLevel+2;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(loc(q[Dir␣'%1'␣does␣not␣exist],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$dir));
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣On␣VMS,␣if␣the␣$Config{make}␣is␣either␣MMK␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣or␣MMS,␣then␣the␣makefile␣is␣'DESCRIP.MMS'.
use␣constant␣MAKEFILE␣␣␣␣␣␣␣=>␣sub␣{␣my␣$file␣=
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(ON_VMS␣and␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$Config::Config{make}␣=~␣/MM[S|K]/i)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣'DESCRIP.MMS'
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣'Makefile';

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣@_
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣File::Spec->catfile(␣@_,␣$file␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣$file;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
use␣constant␣MAKEFILE_PL␣␣␣␣=>␣sub␣{␣return␣@_
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣File::Spec->catfile(␣@_,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'Makefile.PL'␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣'Makefile.PL';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣
use␣constant␣BUILD_PL␣␣␣␣␣␣␣=>␣sub␣{␣return␣@_
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣File::Spec->catfile(␣@_,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'Build.PL'␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣'Build.PL';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
use␣constant␣META_YML␣␣␣␣␣␣␣=>␣sub␣{␣return␣@_
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣File::Spec->catfile(␣@_,␣'META.yml'␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣'META.yml';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣

use␣constant␣MYMETA_YML␣␣␣␣␣=>␣sub␣{␣return␣@_
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣File::Spec->catfile(␣@_,␣'MYMETA.yml'␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣'MYMETA.yml';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣

use␣constant␣BLIB␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{␣return␣@_
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣File::Spec->catfile(@_,␣'blib')
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣'blib';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣

use␣constant␣LIB␣␣␣␣␣␣␣␣␣␣␣␣=>␣'lib';
use␣constant␣LIB_DIR␣␣␣␣␣␣␣␣=>␣sub␣{␣return␣@_
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣File::Spec->catdir(@_,␣LIB)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣LIB;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣
use␣constant␣AUTO␣␣␣␣␣␣␣␣␣␣␣=>␣'auto';␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
use␣constant␣LIB_AUTO_DIR␣␣␣=>␣sub␣{␣return␣@_
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣File::Spec->catdir(@_,␣LIB,␣AUTO)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣File::Spec->catdir(LIB,␣AUTO)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣
use␣constant␣ARCH␣␣␣␣␣␣␣␣␣␣␣=>␣'arch';
use␣constant␣ARCH_DIR␣␣␣␣␣␣␣=>␣sub␣{␣return␣@_
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣File::Spec->catdir(@_,␣ARCH)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣ARCH;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣
use␣constant␣ARCH_AUTO_DIR␣␣=>␣sub␣{␣return␣@_
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣File::Spec->catdir(@_,ARCH,AUTO)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣File::Spec->catdir(ARCH,AUTO)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣

use␣constant␣BLIB_LIBDIR␣␣␣␣=>␣sub␣{␣return␣@_
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣File::Spec->catdir(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣@_,␣BLIB->(),␣LIB␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣File::Spec->catdir(␣BLIB->(),␣LIB␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣

use␣constant␣CONFIG_USER_LIB_DIR␣=>␣sub␣{␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣require␣CPANPLUS::Internals::Utils;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣LIB_DIR->(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CPANPLUS::Internals::Utils->_home_dir,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣DOT_CPANPLUS
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣
use␣constant␣CONFIG_USER_FILE␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣File::Spec->catfile(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CONFIG_USER_LIB_DIR->(),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣split('::',␣CONFIG_USER),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣.␣'.pm';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};
use␣constant␣CONFIG_SYSTEM_FILE␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣require␣CPANPLUS::Internals;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣require␣File::Basename;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$dir␣=␣File::Basename::dirname(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$INC{'CPANPLUS/Internals.pm'}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣XXX␣use␣constants
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣File::Spec->catfile(␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$dir,␣qw[Config␣System.pm]
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣
␣␣␣␣␣␣
use␣constant␣README␣␣␣␣␣␣␣␣␣=>␣sub␣{␣my␣$obj␣=␣$_[0];
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$pkg␣=␣$obj->package_name;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$pkg␣.=␣'-'␣.␣$obj->package_version␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'.readme';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$pkg;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};
use␣constant␣META_EXT␣␣␣␣␣␣␣=>␣'meta';

use␣constant␣META␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{␣my␣$obj␣=␣$_[0];
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$pkg␣=␣$obj->package_name;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$pkg␣.=␣'-'␣.␣$obj->package_version␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'.'␣.␣META_EXT;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$pkg;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
use␣constant␣OPEN_FILE␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my($file,␣$mode)␣=␣(@_,␣'');
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$fh;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣open␣$fh,␣"$mode"␣.␣$file
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣or␣error(loc(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Could␣not␣open␣file␣'%1':␣%2",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$file,␣$!));
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$fh␣if␣$fh;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣
use␣constant␣OPEN_DIR␣␣␣␣␣␣␣=>␣sub␣{␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$dir␣=␣shift;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$dh;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣opendir␣$dh,␣$dir␣or␣error(loc(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Could␣not␣open␣dir␣'%1':␣%2",␣$dir,␣$!
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣));
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$dh␣if␣$dh;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};

use␣constant␣READ_DIR␣␣␣␣␣␣␣=>␣sub␣{␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$dir␣=␣shift;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$dh␣␣=␣OPEN_DIR->(␣$dir␣)␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣exclude␣.␣and␣..
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣@files␣=␣␣grep␣{␣$_␣!~␣/^\.{1,2}/␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣readdir($dh);

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣Remove␣trailing␣dot␣on␣VMS␣when
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣using␣VMS␣syntax.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣ON_VMS␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣s/(?<!\^)\.$//␣for␣@files;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣@files;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣

use␣constant␣STRIP_GZ_SUFFIX␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$file␣=␣$_[0]␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$file␣=~␣s/.gz$//i;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$file;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
use␣constant␣CHECKSUMS␣␣␣␣␣␣=>␣'CHECKSUMS';
use␣constant␣PGP_HEADER␣␣␣␣␣=>␣'-----BEGIN␣PGP␣SIGNED␣MESSAGE-----';
use␣constant␣ENV_CPANPLUS_CONFIG
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣'PERL5_CPANPLUS_CONFIG';
use␣constant␣ENV_CPANPLUS_IS_EXECUTING
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣'PERL5_CPANPLUS_IS_EXECUTING';
use␣constant␣DEFAULT_EMAIL␣␣=>␣'cpanplus@example.com';␣␣␣
use␣constant␣CPANPLUS_UA␣␣␣␣=>␣sub␣{␣###␣for␣the␣version␣number␣###
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣require␣CPANPLUS::Internals;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"CPANPLUS/$CPANPLUS::Internals::VERSION"␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};
use␣constant␣TESTERS_URL␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'http://cpantesters.org/distro/'.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣uc(substr($_[0],0,1))␣.'/'.␣$_[0]␣.␣'.yaml';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};
use␣constant␣TESTERS_DETAILS_URL
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'http://cpantesters.org/distro/'.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣uc(substr($_[0],0,1))␣.'/'.␣$_[0];
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣␣

use␣constant␣CREATE_FILE_URI␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$dir␣=␣$_[0]␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$dir␣=~␣m|^/|␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣'file://'␣␣.␣$dir
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣'file:///'␣.␣$dir;␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣

use␣constant␣EMPTY_DSLIP␣␣␣␣=>␣'␣␣␣␣␣';

use␣constant␣CUSTOM_AUTHOR_ID
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣'LOCAL';

use␣constant␣DOT_SHELL_DEFAULT_RC
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣'.shell-default.rc';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
use␣constant␣SOURCE_SQLITE_DB
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣'db.sql';

use␣constant␣PREREQ_IGNORE␣␣=>␣0;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
use␣constant␣PREREQ_INSTALL␣=>␣1;
use␣constant␣PREREQ_ASK␣␣␣␣␣=>␣2;
use␣constant␣PREREQ_BUILD␣␣␣=>␣3;
use␣constant␣BOOLEANS␣␣␣␣␣␣␣=>␣[0,1];
use␣constant␣CALLING_FUNCTION␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{␣my␣$lvl␣=␣$_[0]␣||␣0;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣join␣'::',␣(caller(2+$lvl))[3]␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};
use␣constant␣PERL_CORE␣␣␣␣␣␣=>␣'perl';
use␣constant␣STORABLE_EXT␣␣␣=>␣'.stored';

use␣constant␣GET_XS_FILES␣␣␣=>␣sub␣{␣my␣$dir␣=␣$_[0]␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣require␣File::Find;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣@files;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣File::Find::find(␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣sub␣{␣push␣@files,␣$File::Find::name
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣$File::Find::name␣=~␣/\.xs$/i
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣},␣$dir␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣@files;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣

use␣constant␣INSTALL_LOG_FILE␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{␣my␣$obj␣␣=␣shift␣or␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$name␣=␣$obj->name;␣$name␣=~␣s/::/-/g;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$name␣.=␣'-'.␣$obj->version;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$name␣.=␣'-'.␣scalar(time)␣.␣'.log';
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$name;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣

use␣constant␣ON_OLD_CYGWIN␣␣=>␣do␣{␣ON_CYGWIN␣and␣$]␣<␣5.008␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣loc(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Your␣perl␣version␣for␣%1␣is␣too␣low;␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Require␣%2␣or␣higher␣for␣this␣function",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$^O,␣'5.8.0'␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣'';␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};

###␣XXX␣these␣2␣are␣probably␣obsolete␣--␣check␣&␣remove;
use␣constant␣DOT_EXISTS␣␣␣␣␣=>␣'.exists';␣

use␣constant␣QUOTE_PERL_ONE_LINER␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣sub␣{␣my␣$line␣=␣shift␣or␣return;

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣use␣double␣quotes␣on␣these␣systems
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣qq["$line"]␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣ON_WIN32␣||␣ON_NETWARE␣||␣ON_VMS;

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣single␣quotes␣on␣the␣rest
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣qq['$line'];
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};␣␣␣

1;␣␣␣␣␣␣␣␣␣␣␣␣␣␣

#␣Local␣variables:
#␣c-indentation-style:␣bsd
#␣c-basic-offset:␣4
#␣indent-tabs-mode:␣nil
#␣End:
#␣vim:␣expandtab␣shiftwidth=4:
package␣CPANPLUS::Internals::Utils;

use␣strict;

use␣CPANPLUS::Error;
use␣CPANPLUS::Internals::Constants;

use␣Cwd␣qw[chdir];
use␣File::Copy;
use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[check];
use␣Module::Load::Conditional␣␣␣qw[can_load];
use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';

local␣$Params::Check::VERBOSE␣=␣1;

=pod

=head1␣NAME

CPANPLUS::Internals::Utils

=head1␣SYNOPSIS

␣␣␣␣my␣$bool␣=␣$cb->_mkdir(␣dir␣=>␣'blah'␣);
␣␣␣␣my␣$bool␣=␣$cb->_chdir(␣dir␣=>␣'blah'␣);
␣␣␣␣my␣$bool␣=␣$cb->_rmdir(␣dir␣=>␣'blah'␣);

␣␣␣␣my␣$bool␣=␣$cb->_move(␣from␣=>␣'/some/file',␣to␣=>␣'/other/file'␣);
␣␣␣␣my␣$bool␣=␣$cb->_move(␣from␣=>␣'/some/dir',␣␣to␣=>␣'/other/dir'␣);

␣␣␣␣my␣$cont␣=␣$cb->_get_file_contents(␣file␣=>␣'/path/to/file'␣);


␣␣␣␣my␣$version␣=␣$cb->_perl_version(␣perl␣=>␣$^X␣);

=head1␣DESCRIPTION

C<CPANPLUS::Internals::Utils>␣holds␣a␣few␣convenience␣functions␣for
CPANPLUS␣libraries.

=head1␣METHODS

=head2␣$cb->_mkdir(␣dir␣=>␣'/some/dir'␣)

C<_mkdir>␣creates␣a␣full␣path␣to␣a␣directory.

Returns␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣_mkdir␣{
␣␣␣␣my␣$self␣=␣shift;

␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣dir␣␣␣␣␣=>␣{␣required␣=>␣1␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣(
␣␣␣␣␣␣␣␣error(loc(␣Params::Check->last_error␣)␣),␣return
␣␣␣␣);␣␣␣␣␣␣␣

␣␣␣␣unless(␣can_load(␣modules␣=>␣{␣'File::Path'␣=>␣0.0␣}␣)␣)␣{
␣␣␣␣␣␣␣␣error(␣loc("Could␣not␣use␣File::Path!␣This␣module␣should␣be␣core!")␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣eval␣{␣File::Path::mkpath($args->{dir})␣};

␣␣␣␣if($@)␣{
␣␣␣␣␣␣␣␣chomp($@);
␣␣␣␣␣␣␣␣error(loc(qq[Could␣not␣create␣directory␣'%1':␣%2],␣$args->{dir},␣$@␣));
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣return␣1;
}

=pod

=head2␣$cb->_chdir(␣dir␣=>␣'/some/dir'␣)

C<_chdir>␣changes␣directory␣to␣a␣dir.

Returns␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣_chdir␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣dir␣␣␣␣␣=>␣{␣required␣=>␣1,␣allow␣=>␣DIR_EXISTS␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣unless(␣chdir␣$args->{dir}␣)␣{
␣␣␣␣␣␣␣␣error(␣loc(q[Could␣not␣chdir␣into␣'%1'],␣$args->{dir})␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣return␣1;
}

=pod

=head2␣$cb->_rmdir(␣dir␣=>␣'/some/dir'␣);

Removes␣a␣directory␣completely,␣even␣if␣it␣is␣non-empty.

Returns␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣_rmdir␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣dir␣␣␣␣␣=>␣{␣required␣=>␣1,␣allow␣=>␣IS_DIR␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣unless(␣can_load(␣modules␣=>␣{␣'File::Path'␣=>␣0.0␣}␣)␣)␣{
␣␣␣␣␣␣␣␣error(␣loc("Could␣not␣use␣File::Path!␣This␣module␣should␣be␣core!")␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣eval␣{␣File::Path::rmtree($args->{dir})␣};

␣␣␣␣if($@)␣{
␣␣␣␣␣␣␣␣chomp($@);
␣␣␣␣␣␣␣␣error(loc(qq[Could␣not␣delete␣directory␣'%1':␣%2],␣$args->{dir},␣$@␣));
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣return␣1;
}

=pod

=head2␣$cb->_perl_version␣(␣perl␣=>␣'some/perl/binary'␣);

C<_perl_version>␣returns␣the␣version␣of␣a␣certain␣perl␣binary.
It␣does␣this␣by␣actually␣running␣a␣command.

Returns␣the␣perl␣version␣on␣success␣and␣false␣on␣failure.

=cut

sub␣_perl_version␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$perl;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣perl␣␣␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$perl␣},
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣
␣␣␣␣my␣$perl_version;
␣␣␣␣###␣special␣perl,␣or␣the␣one␣we␣are␣running␣under?
␣␣␣␣if(␣$perl␣eq␣$^X␣)␣{
␣␣␣␣␣␣␣␣###␣just␣load␣the␣config␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣require␣Config;
␣␣␣␣␣␣␣␣$perl_version␣=␣$Config::Config{version};
␣␣␣␣␣␣␣␣
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣$cmd␣␣=␣$perl␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'␣-MConfig␣-eprint+Config::config_vars+version';
␣␣␣␣␣␣␣␣($perl_version)␣=␣(`$cmd`␣=~␣/version='(.*)'/);
␣␣␣␣}
␣␣␣␣
␣␣␣␣return␣$perl_version␣if␣defined␣$perl_version;
␣␣␣␣return;
}

=pod

=head2␣$cb->_version_to_number(␣version␣=>␣$version␣);

Returns␣a␣proper␣module␣version,␣or␣'0.0'␣if␣none␣was␣available.

=cut

sub␣_version_to_number␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$version;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣version␣=>␣{␣default␣=>␣'0.0',␣store␣=>␣\$version␣},
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣return␣$version␣if␣$version␣=~␣/^\.?\d/;
␣␣␣␣return␣'0.0';
}

=pod

=head2␣$cb->_whoami

Returns␣the␣name␣of␣the␣subroutine␣you're␣currently␣in.

=cut

sub␣_whoami␣{␣my␣$name␣=␣(caller␣1)[3];␣$name␣=~␣s/.+:://;␣$name␣}

=pod

=head2␣_get_file_contents(␣file␣=>␣$file␣);

Returns␣the␣contents␣of␣a␣file

=cut

sub␣_get_file_contents␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$file;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣file␣=>␣{␣required␣=>␣1,␣store␣=>␣\$file␣}
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣my␣$fh␣=␣OPEN_FILE->($file)␣or␣return;
␣␣␣␣my␣$contents␣=␣do␣{␣local␣$/;␣<$fh>␣};

␣␣␣␣return␣$contents;
}

=pod␣$cb->_move(␣from␣=>␣$file|$dir,␣to␣=>␣$target␣);

Moves␣a␣file␣or␣directory␣to␣the␣target.

Returns␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣_move␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$from;␣my␣$to;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣file␣␣␣␣=>␣{␣required␣=>␣1,␣allow␣=>␣[IS_FILE,IS_DIR],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$from␣},
␣␣␣␣␣␣␣␣to␣␣␣␣␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$to␣}
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣if(␣File::Copy::move(␣$from,␣$to␣)␣)␣{
␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣error(loc("Failed␣to␣move␣'%1'␣to␣'%2':␣%3",␣$from,␣$to,␣$!));
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
}

=pod␣$cb->_copy(␣from␣=>␣$file|$dir,␣to␣=>␣$target␣);

Moves␣a␣file␣or␣directory␣to␣the␣target.

Returns␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣_copy␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣my($from,$to);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣file␣␣␣␣=>{␣required␣=>␣1,␣allow␣=>␣[IS_FILE,IS_DIR],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$from␣},
␣␣␣␣␣␣␣␣to␣␣␣␣␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$to␣}
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣if(␣File::Copy::copy(␣$from,␣$to␣)␣)␣{
␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣error(loc("Failed␣to␣copy␣'%1'␣to␣'%2':␣%3",␣$from,␣$to,␣$!));
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
}

=head2␣$cb->_mode_plus_w(␣file␣=>␣'/path/to/file'␣);

Sets␣the␣+w␣bit␣for␣the␣file.

Returns␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣_mode_plus_w␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣require␣File::stat;
␣␣␣␣
␣␣␣␣my␣$file;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣file␣␣␣␣=>␣{␣required␣=>␣1,␣allow␣=>␣IS_FILE,␣store␣=>␣\$file␣},
␣␣␣␣};
␣␣␣␣
␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣
␣␣␣␣###␣set␣the␣mode␣to␣+w␣for␣a␣file␣and␣+wx␣for␣a␣dir
␣␣␣␣my␣$x␣␣␣␣␣␣␣=␣File::stat::stat(␣$file␣);
␣␣␣␣my␣$mask␣␣␣␣=␣-d␣$file␣?␣0100␣:␣0200;
␣␣␣␣
␣␣␣␣if(␣$x␣and␣chmod(␣$x->mode|$mask,␣$file␣)␣)␣{
␣␣␣␣␣␣␣␣return␣1;

␣␣␣␣}␣else␣{␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣error(loc("Failed␣to␣'%1'␣'%2':␣'%3'",␣'chmod␣+w',␣$file,␣$!));
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
}␣␣␣␣

=head2␣$uri␣=␣$cb->_host_to_uri(␣scheme␣=>␣SCHEME,␣host␣=>␣HOST,␣path␣=>␣PATH␣);

Turns␣a␣CPANPLUS::Config␣style␣C<host>␣entry␣into␣an␣URI␣string.

Returns␣the␣uri␣on␣success,␣and␣false␣on␣failure

=cut

sub␣_host_to_uri␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣my($scheme,␣$host,␣$path);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣scheme␣␣=>␣{␣required␣=>␣1,␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$scheme␣},
␣␣␣␣␣␣␣␣host␣␣␣␣=>␣{␣default␣␣=>␣'localhost',␣␣␣store␣=>␣\$host␣},
␣␣␣␣␣␣␣␣path␣␣␣␣=>␣{␣default␣␣=>␣'',␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$path␣},
␣␣␣␣};␣␣␣␣␣␣␣

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣###␣it's␣an␣URI,␣so␣unixify␣the␣path.
␣␣␣␣###␣VMS␣has␣a␣special␣method␣for␣just␣that
␣␣␣␣$path␣=␣ON_VMS
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣VMS::Filespec::unixify($path)␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣File::Spec::Unix->catdir(␣File::Spec->splitdir(␣$path␣)␣);

␣␣␣␣return␣"$scheme://"␣.␣File::Spec::Unix->catdir(␣$host,␣$path␣);␣
}

=head2␣$cb->_vcmp(␣VERSION,␣VERSION␣);

Normalizes␣the␣versions␣passed␣and␣does␣a␣'<=>'␣on␣them,␣returning␣the␣result.

=cut

sub␣_vcmp␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣($x,␣$y)␣=␣@_;
␣␣␣␣
␣␣␣␣s/_//g␣foreach␣$x,␣$y;

␣␣␣␣return␣$x␣<=>␣$y;
}

=head2␣$cb->_home_dir

Returns␣the␣user's␣homedir,␣or␣C<cwd>␣if␣it␣could␣not␣be␣found

=cut

sub␣_home_dir␣{
␣␣␣␣my␣@os_home_envs␣=␣qw(␣APPDATA␣HOME␣USERPROFILE␣WINDIR␣SYS$LOGIN␣);

␣␣␣␣for␣my␣$env␣(␣@os_home_envs␣)␣{
␣␣␣␣␣␣␣␣next␣unless␣exists␣$ENV{␣$env␣};
␣␣␣␣␣␣␣␣next␣unless␣defined␣$ENV{␣$env␣}␣&&␣length␣$ENV{␣$env␣};
␣␣␣␣␣␣␣␣return␣$ENV{␣$env␣}␣if␣-d␣$ENV{␣$env␣};
␣␣␣␣}

␣␣␣␣return␣cwd();
}

=head2␣$path␣=␣$cb->_safe_path(␣path␣=>␣$path␣);

Returns␣a␣path␣that's␣safe␣to␣us␣on␣Win32␣and␣VMS.␣

Only␣cleans␣up␣the␣path␣on␣Win32␣if␣the␣path␣exists.

On␣VMS,␣it␣encodes␣dots␣to␣_␣using␣C<VMS::Filespec::vmsify>

=cut

sub␣_safe_path␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣my␣$path;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣path␣␣=>␣{␣required␣=>␣1,␣␣␣␣␣store␣=>␣\$path␣},
␣␣␣␣};␣␣␣␣␣␣␣

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣
␣␣␣␣if(␣ON_WIN32␣)␣{
␣␣␣␣␣␣␣␣###␣only␣need␣to␣fix␣it␣up␣if␣there's␣spaces␣in␣the␣path␣␣␣
␣␣␣␣␣␣␣␣return␣$path␣unless␣$path␣=~␣/\s+/;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣clean␣up␣paths␣if␣we␣are␣on␣win32
␣␣␣␣␣␣␣␣return␣Win32::GetShortPathName(␣$path␣)␣||␣$path;

␣␣␣␣}␣elsif␣(␣ON_VMS␣)␣{
␣␣␣␣␣␣␣␣###␣XXX␣According␣to␣John␣Malmberg,␣there's␣an␣VMS␣issue:
␣␣␣␣␣␣␣␣###␣catdir␣on␣VMS␣can␣not␣currently␣deal␣with␣directory␣components
␣␣␣␣␣␣␣␣###␣with␣dots␣in␣them.␣␣
␣␣␣␣␣␣␣␣###␣Fixing␣this␣is␣a␣a␣three␣step␣procedure,␣which␣will␣work␣for␣
␣␣␣␣␣␣␣␣###␣VMS␣in␣its␣traditional␣ODS-2␣mode,␣and␣it␣will␣also␣work␣if␣
␣␣␣␣␣␣␣␣###␣VMS␣is␣in␣the␣ODS-5␣mode␣that␣is␣being␣implemented.
␣␣␣␣␣␣␣␣###␣If␣the␣path␣is␣already␣in␣VMS␣syntax,␣assume␣that␣we␣are␣done.
␣
␣␣␣␣␣␣␣␣###␣VMS␣format␣is␣a␣path␣with␣a␣trailing␣']'␣or␣':'
␣␣␣␣␣␣␣␣return␣$path␣if␣$path␣=~␣/\:|\]$/;

␣␣␣␣␣␣␣␣###␣1.␣Make␣sure␣that␣the␣value␣to␣be␣converted,␣$path␣is␣
␣␣␣␣␣␣␣␣###␣in␣UNIX␣directory␣syntax␣by␣appending␣a␣'/'␣to␣it.
␣␣␣␣␣␣␣␣$path␣.=␣'/'␣unless␣$path␣=~␣m|/$|;

␣␣␣␣␣␣␣␣###␣2.␣Use␣VMS::Filespec::vmsify($path␣.␣'/')␣to␣convert␣the␣dots␣to
␣␣␣␣␣␣␣␣###␣underscores␣if␣needed.␣␣The␣trailing␣'/'␣is␣needed␣as␣so␣that
␣␣␣␣␣␣␣␣###␣C<vmsify>␣knows␣that␣it␣should␣use␣directory␣translation␣instead␣of
␣␣␣␣␣␣␣␣###␣filename␣translation,␣as␣filename␣translation␣leaves␣one␣dot.
␣␣␣␣␣␣␣␣$path␣=␣VMS::Filespec::vmsify(␣$path␣);

␣␣␣␣␣␣␣␣###␣3.␣Use␣$path␣=␣File::Spec->splitdir(␣VMS::Filespec::vmsify(␣
␣␣␣␣␣␣␣␣###␣$path␣.␣'/')␣to␣remove␣the␣directory␣delimiters.

␣␣␣␣␣␣␣␣###␣From␣John␣Malmberg:
␣␣␣␣␣␣␣␣###␣File::Spec->catdir␣will␣put␣the␣path␣back␣together.
␣␣␣␣␣␣␣␣###␣The␣'/'␣trick␣only␣works␣if␣the␣string␣is␣a␣directory␣name␣
␣␣␣␣␣␣␣␣###␣with␣UNIX␣style␣directory␣delimiters␣or␣no␣directory␣delimiters.␣␣
␣␣␣␣␣␣␣␣###␣It␣is␣to␣force␣vmsify␣to␣treat␣the␣input␣specification␣as␣UNIX.
␣␣␣␣␣␣␣␣###
␣␣␣␣␣␣␣␣###␣There␣is␣a␣VMS::Filespec::unixpath()␣to␣do␣the␣appending␣of␣the␣'/'
␣␣␣␣␣␣␣␣###␣to␣the␣specification,␣which␣will␣do␣a␣VMS::Filespec::vmsify()␣
␣␣␣␣␣␣␣␣###␣if␣needed.
␣␣␣␣␣␣␣␣###␣However␣it␣is␣not␣a␣good␣idea␣to␣call␣vmsify()␣on␣a␣pathname
␣␣␣␣␣␣␣␣###␣returned␣by␣unixify(),␣and␣it␣is␣not␣a␣good␣idea␣to␣call␣unixify()
␣␣␣␣␣␣␣␣###␣on␣a␣pathname␣returned␣by␣vmsify().␣␣Because␣of␣the␣nature␣of␣the
␣␣␣␣␣␣␣␣###␣conversion,␣not␣all␣file␣specifications␣can␣make␣the␣round␣trip.
␣␣␣␣␣␣␣␣###
␣␣␣␣␣␣␣␣###␣I␣think␣that␣directory␣specifications␣can␣safely␣make␣the␣round
␣␣␣␣␣␣␣␣###␣trip,␣but␣not␣ones␣containing␣filenames.
␣␣␣␣␣␣␣␣$path␣=␣File::Spec->catdir(␣File::Spec->splitdir(␣$path␣)␣)
␣␣␣␣}
␣␣␣␣
␣␣␣␣return␣$path;
}


=head2␣($pkg,␣$version,␣$ext)␣=␣$cb->_split_package_string(␣package␣=>␣PACKAGE_STRING␣);

Splits␣the␣name␣of␣a␣CPAN␣package␣string␣up␣into␣its␣package,␣version␣
and␣extension␣parts.

For␣example,␣C<Foo-Bar-1.2.tar.gz>␣would␣return␣the␣following␣parts:

␣␣␣␣Package:␣␣␣␣Foo-Bar
␣␣␣␣Version:␣␣␣␣1.2
␣␣␣␣Extension:␣␣tar.gz

=cut

{␣␣␣my␣$del_re␣=␣qr/[-_\+]/i;␣␣␣␣␣␣␣␣␣␣␣#␣delimiter␣between␣elements
␣␣␣␣my␣$pkg_re␣=␣qr/[a-z]␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣any␣letters␣followed␣by␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣[a-z\d]*␣␣␣␣␣␣␣␣␣␣␣␣#␣any␣letters,␣numbers
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(?i:\.pm)?␣␣␣␣␣␣␣␣␣␣#␣followed␣by␣'.pm'--authors␣do␣this␣:(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(?:␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣optionally␣repeating:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$del_re␣␣␣␣␣␣␣␣␣#␣␣␣followed␣by␣a␣delimiter
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣[a-z]␣␣␣␣␣␣␣␣␣␣␣#␣␣␣any␣letters␣followed␣by␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣[a-z\d]*␣␣␣␣␣␣␣␣#␣␣␣any␣letters,␣numbers␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(?i:\.pm)?␣␣␣␣␣␣#␣followed␣by␣'.pm'--authors␣do␣this␣:(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)*
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/xi;␣␣␣
␣␣␣␣
␣␣␣␣my␣$ver_re␣=␣qr/[a-z]*\d*?[a-z]*␣␣␣␣#␣contains␣a␣digit␣and␣possibly␣letters
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(?:␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣however,␣some␣start␣with␣a␣.␣only␣:(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣[-._]␣␣␣␣␣␣␣␣␣␣␣#␣followed␣by␣a␣delimiter
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣[a-z\d]+␣␣␣␣␣␣␣␣#␣and␣more␣digits␣and␣or␣letters
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)*?
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/xi;
␣
␣␣␣␣my␣$ext_re␣=␣qr/[a-z]␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣a␣letter,␣followed␣by
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣[a-z\d]*␣␣␣␣␣␣␣␣␣␣␣␣#␣letters␣and␣or␣digits,␣optionally
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(?:␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣\.␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣␣␣followed␣by␣a␣dot␣and␣letters
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣[a-z\d]+␣␣␣␣␣␣␣␣#␣␣␣and␣or␣digits␣(like␣.tar.bz2)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)?␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣␣␣optionally
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/xi;

␣␣␣␣my␣$ver_ext_re␣=␣qr/
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣($ver_re+)␣␣␣␣␣␣#␣version,␣optional
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(?:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣\.␣␣␣␣␣␣␣␣␣␣#␣a␣literal␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣($ext_re)␣␣␣#␣extension,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)?␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣optional,␣but␣requires␣version
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/xi;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣###␣composed␣regex␣for␣CPAN␣packages
␣␣␣␣my␣$full_re␣=␣qr/
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣^
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣the␣whole␣thing
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣($pkg_re+)␣␣␣␣␣␣␣␣␣␣#␣package
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(?:␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$del_re␣␣␣␣␣␣␣␣␣#␣delimiter
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$ver_ext_re␣␣␣␣␣#␣version␣+␣extension
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)?
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/xi;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣###␣composed␣regex␣for␣perl␣packages
␣␣␣␣my␣$perl␣␣␣␣=␣PERL_CORE;
␣␣␣␣my␣$perl_re␣=␣qr/
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣^
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣the␣whole␣thing
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣($perl)␣␣␣␣␣␣␣␣␣␣␣␣␣#␣package␣name␣for␣'perl'
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(?:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$ver_ext_re␣␣␣␣␣#␣version␣+␣extension
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)?
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣/xi;␣␣␣␣␣␣␣


sub␣_split_package_string␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my␣$str;
␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{␣package␣=>␣{␣required␣=>␣1,␣store␣=>␣\$str␣}␣};
␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣2␣different␣regexes,␣one␣for␣the␣'perl'␣package,␣
␣␣␣␣␣␣␣␣###␣one␣for␣ordinary␣CPAN␣packages..␣try␣them␣both,␣
␣␣␣␣␣␣␣␣###␣first␣match␣wins.
␣␣␣␣␣␣␣␣for␣my␣$re␣(␣$full_re,␣$perl_re␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣try␣the␣next␣if␣the␣match␣fails
␣␣␣␣␣␣␣␣␣␣␣␣$str␣=~␣$re␣or␣next;

␣␣␣␣␣␣␣␣␣␣␣␣my␣$full␣␣␣␣=␣$1␣||␣'';
␣␣␣␣␣␣␣␣␣␣␣␣my␣$pkg␣␣␣␣␣=␣$2␣||␣'';␣
␣␣␣␣␣␣␣␣␣␣␣␣my␣$ver␣␣␣␣␣=␣$3␣||␣'';
␣␣␣␣␣␣␣␣␣␣␣␣my␣$ext␣␣␣␣␣=␣$4␣||␣'';

␣␣␣␣␣␣␣␣␣␣␣␣###␣this␣regex␣resets␣the␣capture␣markers!
␣␣␣␣␣␣␣␣␣␣␣␣###␣strip␣the␣trailing␣delimiter
␣␣␣␣␣␣␣␣␣␣␣␣$pkg␣=~␣s/$del_re$//;
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣strip␣the␣.pm␣package␣suffix␣some␣authors␣insist␣on␣adding
␣␣␣␣␣␣␣␣␣␣␣␣$pkg␣=~␣s/\.pm$//i;

␣␣␣␣␣␣␣␣␣␣␣␣return␣($pkg,␣$ver,␣$ext,␣$full␣);
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
}

{␣␣␣my␣%escapes␣=␣map␣{
␣␣␣␣␣␣␣␣chr($_)␣=>␣sprintf("%%%02X",␣$_)
␣␣␣␣}␣0␣..␣255;␣␣
␣␣␣␣
␣␣␣␣sub␣_uri_encode␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my␣$str;
␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣uri␣=>␣{␣store␣=>␣\$str,␣required␣=>␣1␣}
␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣␣␣␣␣###␣XXX␣taken␣straight␣from␣URI::Encode
␣␣␣␣␣␣␣␣###␣Default␣unsafe␣characters.␣␣RFC␣2732␣^(uric␣-␣reserved)
␣␣␣␣␣␣␣␣$str␣=~␣s|([^A-Za-z0-9\-_.!~*'()])|$escapes{$1}|g;
␣␣␣␣
␣␣␣␣␣␣␣␣return␣$str;␣␣␣␣␣␣␣␣␣␣
␣␣␣␣}
␣␣␣␣
␣␣␣␣
␣␣␣␣sub␣_uri_decode␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my␣$str;
␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣uri␣=>␣{␣store␣=>␣\$str,␣required␣=>␣1␣}
␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣
␣␣␣␣␣␣␣␣###␣XXX␣use␣unencode␣routine␣in␣utils?
␣␣␣␣␣␣␣␣$str␣=~␣s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;␣
␣␣␣␣
␣␣␣␣␣␣␣␣return␣$str;␣␣␣␣
␣␣␣␣}
}

sub␣_update_timestamp␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣my␣$file;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣file␣=>␣{␣required␣=>␣1,␣store␣=>␣\$file,␣allow␣=>␣FILE_EXISTS␣}
␣␣␣␣};
␣␣␣␣
␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣
␣␣␣␣###␣`touch`␣the␣file,␣so␣windoze␣knows␣it's␣new␣-jmb
␣␣␣␣###␣works␣on␣*nix␣too,␣good␣fix␣-Kane
␣␣␣␣###␣make␣sure␣it␣is␣writable␣first,␣otherwise␣the␣`touch`␣will␣fail

␣␣␣␣my␣$now␣=␣time;
␣␣␣␣unless(␣chmod(␣0644,␣$file)␣&&␣utime␣($now,␣$now,␣$file)␣)␣{
␣␣␣␣␣␣␣␣error(␣loc("Couldn't␣touch␣%1",␣$file)␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
␣␣␣␣
␣␣␣␣return␣1;
}


1;

#␣Local␣variables:
#␣c-indentation-style:␣bsd
#␣c-basic-offset:␣4
#␣indent-tabs-mode:␣nil
#␣End:
#␣vim:␣expandtab␣shiftwidth=4:
package␣CPANPLUS::Internals::Fetch;

use␣strict;

use␣CPANPLUS::Error;
use␣CPANPLUS::Internals::Constants;

use␣File::Fetch;
use␣File::Spec;
use␣Cwd␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[cwd];
use␣IPC::Cmd␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[run];
use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[check];
use␣Module::Load::Conditional␣␣␣qw[can_load];
use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';

$Params::Check::VERBOSE␣=␣1;

=pod

=head1␣NAME

CPANPLUS::Internals::Fetch

=head1␣SYNOPSIS

␣␣␣␣my␣$output␣=␣$cb->_fetch(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣module␣␣␣␣␣␣=>␣$modobj,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣fetchdir␣␣␣␣=>␣'/path/to/save/to',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣BOOL,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣force␣␣␣␣␣␣␣=>␣BOOL,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣$cb->_add_fail_host(␣host␣=>␣'foo.com'␣);
␣␣␣␣$cb->_host_ok(␣␣␣␣␣␣␣host␣=>␣'foo.com'␣);


=head1␣DESCRIPTION

CPANPLUS::Internals::Fetch␣fetches␣files␣from␣either␣ftp,␣http,␣file
or␣rsync␣mirrors.

This␣is␣the␣rough␣flow:

␣␣␣␣$cb->_fetch
␣␣␣␣␣␣␣␣Delegate␣to␣File::Fetch;


=head1␣METHODS

=cut

=head1␣$path␣=␣_fetch(␣module␣=>␣$modobj,␣[fetchdir␣=>␣'/path/to/save/to',␣fetch_from␣=>␣'scheme://path/to/fetch/from',␣verbose␣=>␣BOOL,␣force␣=>␣BOOL,␣prefer_bin␣=>␣BOOL,␣ttl␣=>␣$seconds]␣)

C<_fetch>␣will␣fetch␣files␣based␣on␣the␣information␣in␣a␣module
object.␣You␣always␣need␣a␣module␣object.␣If␣you␣want␣a␣fake␣module
object␣for␣a␣one-off␣fetch,␣look␣at␣C<CPANPLUS::Module::Fake>.

C<fetchdir>␣is␣the␣place␣to␣save␣the␣file␣to.␣Usually␣this
information␣comes␣from␣your␣configuration,␣but␣you␣can␣override␣it
expressly␣if␣needed.

C<fetch_from>␣lets␣you␣specify␣an␣URI␣to␣get␣this␣file␣from.␣If␣you
do␣not␣specify␣one,␣your␣list␣of␣configured␣hosts␣will␣be␣probed␣to
download␣the␣file␣from.

C<force>␣forces␣a␣new␣download,␣even␣if␣the␣file␣already␣exists.

C<verbose>␣simply␣indicates␣whether␣or␣not␣to␣print␣extra␣messages.

C<prefer_bin>␣indicates␣whether␣you␣prefer␣the␣use␣of␣commandline
programs␣over␣perl␣modules.␣Defaults␣to␣your␣corresponding␣config
setting.

C<ttl>␣(in␣seconds)␣indicates␣how␣long␣a␣cached␣copy␣is␣valid␣for.␣If
the␣fetch␣time␣of␣the␣local␣copy␣is␣within␣the␣ttl,␣the␣cached␣copy␣is
returned.␣Otherwise,␣the␣file␣is␣refetched.

C<_fetch>␣figures␣out,␣based␣on␣the␣host␣list,␣what␣scheme␣to␣use␣and
from␣there,␣delegates␣to␣C<File::Fetch>␣do␣the␣actual␣fetching.

Returns␣the␣path␣of␣the␣output␣file␣on␣success,␣false␣on␣failure.

Note␣that␣you␣can␣set␣a␣C<blacklist>␣on␣certain␣methods␣in␣the␣config.
Simply␣add␣the␣identifying␣name␣of␣the␣method␣(ie,␣C<lwp>)␣to:
␣␣␣␣$conf->_set_fetch(␣blacklist␣=>␣['lwp']␣);

And␣the␣C<LWP>␣function␣will␣be␣skipped␣by␣C<File::Fetch>.

=cut

sub␣_fetch␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣local␣$Params::Check::NO_DUPLICATES␣=␣0;

␣␣␣␣my␣($modobj,␣$verbose,␣$force,␣$fetch_from,␣$ttl);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣module␣␣␣␣␣␣=>␣{␣required␣=>␣1,␣allow␣=>␣IS_MODOBJ,␣store␣=>␣\$modobj␣},
␣␣␣␣␣␣␣␣fetchdir␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('fetchdir')␣},
␣␣␣␣␣␣␣␣fetch_from␣␣=>␣{␣default␣=>␣'',␣store␣=>␣\$fetch_from␣},
␣␣␣␣␣␣␣␣force␣␣␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('force'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$force␣},
␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣prefer_bin␣␣=>␣{␣default␣=>␣$conf->get_conf('prefer_bin')␣},
␣␣␣␣␣␣␣␣ttl␣␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣0,␣store␣=>␣\$ttl␣},
␣␣␣␣};


␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣###␣check␣if␣we␣already␣downloaded␣the␣thing␣###
␣␣␣␣if(␣(my␣$where␣=␣$modobj->status->fetch())␣and␣not␣$force␣and␣not␣$ttl␣)␣{

␣␣␣␣␣␣␣␣msg(loc("Already␣fetched␣'%1'␣to␣'%2',␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"won't␣fetch␣again␣without␣force",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$modobj->module,␣$where␣),␣$verbose␣);
␣␣␣␣␣␣␣␣return␣$where;
␣␣␣␣}

␣␣␣␣my␣($remote_file,␣$local_file,␣$local_path);

␣␣␣␣###␣build␣the␣local␣path␣to␣downlaod␣to␣###
␣␣␣␣{
␣␣␣␣␣␣␣␣$local_path␣=␣␣␣$args->{fetchdir}␣||
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣File::Spec->catdir(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$conf->get_conf('base'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$modobj->path,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣␣␣␣␣###␣create␣the␣path␣if␣it␣doesn't␣exist␣###
␣␣␣␣␣␣␣␣unless(␣-d␣$local_path␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣unless(␣$self->_mkdir(␣dir␣=>␣$local_path␣)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣msg(␣loc("Could␣not␣create␣path␣'%1'",␣$local_path),␣$verbose);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣$local_file␣=␣File::Spec->rel2abs(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣File::Spec->catfile(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$local_path,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$modobj->package,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣␣␣␣␣###␣do␣we␣already␣have␣the␣file?␣if␣so,␣can␣we␣use␣the␣cached␣version,
␣␣␣␣␣␣␣␣###␣or␣do␣we␣need␣to␣refetch?
␣␣␣␣␣␣␣␣if(␣-e␣$local_file␣)␣{
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣my␣$unlink␣␣␣␣␣␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣my␣$use_cached␣␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣if␣force␣is␣in␣effect,␣we␣have␣to␣refetch
␣␣␣␣␣␣␣␣␣␣␣␣if(␣$force␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$unlink++
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣if␣you␣provided␣a␣ttl,␣and␣it␣was␣exceeded,␣we'll␣refetch,␣
␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif(␣$ttl␣and␣([stat␣$local_file]->[9]␣+␣$ttl␣>␣time)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣msg(loc("Using␣cached␣file␣'%1'␣on␣disk;␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"ttl␣(%2s)␣is␣not␣exceeded",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$local_file,␣$ttl),␣$verbose␣);
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$use_cached++;

␣␣␣␣␣␣␣␣␣␣␣␣###␣if␣you␣provided␣a␣ttl,␣and␣the␣above␣conditional␣didn't␣match,
␣␣␣␣␣␣␣␣␣␣␣␣###␣we␣exceeded␣the␣ttl,␣so␣we␣refetch
␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣(␣$ttl␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$unlink++;
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣otherwise␣we␣can␣use␣the␣cached␣version
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$use_cached++;
␣␣␣␣␣␣␣␣␣␣␣␣}␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣

␣␣␣␣␣␣␣␣␣␣␣␣if(␣$unlink␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣some␣fetches␣will␣fail␣if␣the␣files␣exist␣already,␣so␣let's
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣delete␣them␣first
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣1␣while␣unlink␣$local_file;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣msg(loc("Could␣not␣delete␣%1,␣some␣methods␣may␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"fail␣to␣force␣a␣download",␣$local_file),␣$verbose)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣-e␣$local_file;
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣store␣where␣we␣fetched␣it␣###
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$modobj->status->fetch(␣$local_file␣);
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$local_file;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣}


␣␣␣␣###␣we␣got␣a␣custom␣URI␣
␣␣␣␣if␣(␣$fetch_from␣)␣{
␣␣␣␣␣␣␣␣my␣$abs␣=␣$self->__file_fetch(␣␣from␣␣␣␣=>␣$fetch_from,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣to␣␣␣␣␣␣=>␣$local_path,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣$verbose␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣unless(␣$abs␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Unable␣to␣download␣'%1'",␣$fetch_from));
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}␣␣␣␣␣␣␣␣␣␣␣␣

␣␣␣␣␣␣␣␣###␣store␣where␣we␣fetched␣it␣###
␣␣␣␣␣␣␣␣$modobj->status->fetch(␣$abs␣);

␣␣␣␣␣␣␣␣return␣$abs;

␣␣␣␣###␣we␣will␣get␣it␣from␣one␣of␣our␣mirrors
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣###␣build␣the␣remote␣path␣to␣download␣from␣###
␣␣␣␣␣␣␣␣{␣␣␣$remote_file␣=␣File::Spec::Unix->catfile(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$modobj->path,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$modobj->package,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣unless(␣$remote_file␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(␣loc('No␣remote␣file␣given␣for␣download')␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣
␣␣␣␣␣␣␣␣###␣see␣if␣we␣even␣have␣a␣host␣or␣a␣method␣to␣use␣to␣download␣with␣###
␣␣␣␣␣␣␣␣my␣$found_host;
␣␣␣␣␣␣␣␣my␣@maybe_bad_host;
␣␣␣␣
␣␣␣␣␣␣␣␣HOST:␣{
␣␣␣␣␣␣␣␣␣␣␣␣###␣F*CKING␣PIECE␣OF␣F*CKING␣p4␣SHIT␣makes␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣'$File␣::␣Fetch::SOME_VAR'
␣␣␣␣␣␣␣␣␣␣␣␣###␣into␣a␣meta␣variable␣and␣starts␣substituting␣the␣file␣name...
␣␣␣␣␣␣␣␣␣␣␣␣###␣GRAAAAAAAAAAAAAAAAAAAAAAH!
␣␣␣␣␣␣␣␣␣␣␣␣###␣use␣'␣to␣combat␣it!
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣set␣up␣some␣flags␣for␣File::Fetch␣###
␣␣␣␣␣␣␣␣␣␣␣␣local␣$File'Fetch::BLACKLIST␣␣␣␣=␣$conf->_get_fetch('blacklist');
␣␣␣␣␣␣␣␣␣␣␣␣local␣$File'Fetch::TIMEOUT␣␣␣␣␣␣=␣$conf->get_conf('timeout');
␣␣␣␣␣␣␣␣␣␣␣␣local␣$File'Fetch::DEBUG␣␣␣␣␣␣␣␣=␣$conf->get_conf('debug');
␣␣␣␣␣␣␣␣␣␣␣␣local␣$File'Fetch::FTP_PASSIVE␣␣=␣$conf->get_conf('passive');
␣␣␣␣␣␣␣␣␣␣␣␣local␣$File'Fetch::FROM_EMAIL␣␣␣=␣$conf->get_conf('email');
␣␣␣␣␣␣␣␣␣␣␣␣local␣$File'Fetch::PREFER_BIN␣␣␣=␣$conf->get_conf('prefer_bin');
␣␣␣␣␣␣␣␣␣␣␣␣local␣$File'Fetch::WARN␣␣␣␣␣␣␣␣␣=␣$verbose;
␣␣␣␣
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣loop␣over␣all␣hosts␣we␣have␣###
␣␣␣␣␣␣␣␣␣␣␣␣for␣my␣$host␣(␣@{$conf->get_conf('hosts')}␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$found_host++;
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$where;

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣file://␣uris␣are␣special␣and␣need␣parsing
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣$host->{'scheme'}␣eq␣'file'␣)␣{␣␣␣␣
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣the␣full␣path␣in␣the␣native␣format␣of␣the␣OS
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$host_spec␣=␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣File::Spec->file_name_is_absolute(␣$host->{'path'}␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣$host->{'path'}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣File::Spec->rel2abs(␣$host->{'path'}␣);
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣there␣might␣be␣volumes␣involved␣on␣vms/win32
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣ON_WIN32␣or␣ON_VMS␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣now␣extract␣the␣volume␣in␣order␣to␣be␣Win32␣and␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣VMS␣friendly.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣'no_file'␣indicates␣that␣there's␣no␣file␣part
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣of␣this␣path,␣so␣we␣only␣get␣2␣bits␣returned.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣($vol,␣$host_path)␣=␣File::Spec->splitpath(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$host_spec,␣'no_file'␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣and␣split␣up␣the␣directories
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣@host_dirs␣=␣File::Spec->splitdir(␣$host_path␣);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣if␣we␣got␣a␣volume␣we␣pretend␣its␣a␣directory␣for␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣the␣sake␣of␣the␣file://␣url
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣defined␣$vol␣and␣$vol␣)␣{
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣D:\foo\bar␣needs␣to␣be␣encoded␣as␣D|\foo\bar
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣For␣details,␣see␣the␣following␣link:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣␣␣http://en.wikipedia.org/wiki/File://
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣The␣RFC␣doesnt␣seem␣to␣address␣Windows␣volume
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣descriptors␣but␣it␣does␣address␣VMS␣volume
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣descriptors,␣however␣wikipedia␣covers␣a␣bit␣of
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣history␣regarding␣win32
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$vol␣=~␣s/:$/|/␣if␣ON_WIN32;␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$vol␣=~␣s/://␣if␣ON_VMS;
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣XXX␣i'm␣not␣sure␣what␣cases␣this␣is␣addressing.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣this␣comes␣straight␣from␣dmq's␣file://␣patches
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣for␣win32.␣--kane
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣According␣to␣dmq,␣the␣best␣summary␣is:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣"if␣file://␣urls␣dont␣look␣right␣on␣VMS␣reuse
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣the␣win32␣logic␣and␣see␣if␣that␣fixes␣things"
␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣first␣element␣not␣empty?␣Might␣happen␣on␣VMS.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣prepend␣the␣volume␣in␣that␣case.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣$host_dirs[0]␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣unshift␣@host_dirs,␣$vol;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣element␣empty?␣reuse␣it␣to␣store␣the␣volume
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣encoded␣as␣a␣directory␣name.␣(Win32/VMS)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$host_dirs[0]␣=␣$vol;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣now␣it's␣in␣UNIX␣format,␣which␣is␣the␣same␣format
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣as␣used␣for␣URIs
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$host_spec␣=␣File::Spec::Unix->catdir(␣@host_dirs␣);␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣now␣create␣the␣file://␣uri␣from␣the␣components␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$where␣=␣CREATE_FILE_URI->(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣File::Spec::Unix->catfile(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$host->{'host'}␣||␣'',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$host_spec,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$remote_file,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);␣␣␣␣␣

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣its␣components␣will␣be␣in␣unix␣format,␣for␣a␣http://,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣ftp://␣or␣any␣other␣style␣of␣URI
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$mirror_path␣=␣File::Spec::Unix->catfile(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$host->{'path'},␣$remote_file
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣%args␣=␣(␣scheme␣=>␣$host->{scheme},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣host␣␣␣=>␣$host->{host},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣=>␣$mirror_path,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$where␣=␣$self->_host_to_uri(␣%args␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$abs␣=␣$self->__file_fetch(␣␣from␣␣␣␣=>␣$where,␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣to␣␣␣␣␣␣=>␣$local_path,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣$verbose␣);␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣we␣got␣a␣path␣back?
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if(␣$abs␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣store␣where␣we␣fetched␣it␣###
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$modobj->status->fetch(␣$abs␣);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣this␣host␣is␣good,␣the␣previous␣ones␣are␣apparently
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣not,␣so␣mark␣them␣as␣such.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->_add_fail_host(␣host␣=>␣$_␣)␣for␣@maybe_bad_host;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣$abs;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣so␣we␣tried␣to␣get␣the␣file␣but␣didn't␣actually␣fetch␣it␣--
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣there's␣a␣chance␣this␣host␣is␣bad.␣mark␣it␣as␣such␣and␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣actually␣flag␣it␣back␣if␣we␣manage␣to␣get␣the␣file␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣somewhere␣else
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@maybe_bad_host,␣$host;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣
␣␣␣␣␣␣␣␣$found_host
␣␣␣␣␣␣␣␣␣␣␣␣?␣error(loc("Fetch␣failed:␣host␣list␣exhausted␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"--␣are␣you␣connected␣today?"))
␣␣␣␣␣␣␣␣␣␣␣␣:␣error(loc("No␣hosts␣found␣to␣download␣from␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"--␣check␣your␣config"));
␣␣␣␣}
␣␣␣␣
␣␣␣␣return;
}

sub␣__file_fetch␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣($where,␣$local_path,␣$verbose);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣from␣␣␣␣=>␣{␣required␣␣␣=>␣1,␣store␣=>␣\$where␣},
␣␣␣␣␣␣␣␣to␣␣␣␣␣␣=>␣{␣required␣␣␣=>␣1,␣store␣=>␣\$local_path␣},
␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣␣␣␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣=>␣\$verbose␣},
␣␣␣␣};
␣␣␣␣
␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣msg(loc("Trying␣to␣get␣'%1'",␣$where␣),␣$verbose␣);

␣␣␣␣###␣build␣the␣object␣###
␣␣␣␣my␣$ff␣=␣File::Fetch->new(␣uri␣=>␣$where␣);

␣␣␣␣###␣sanity␣check␣###
␣␣␣␣error(loc("Bad␣uri␣'%1'",$where)),␣return␣unless␣$ff;

␣␣␣␣if(␣my␣$file␣=␣$ff->fetch(␣to␣=>␣$local_path␣)␣)␣{
␣␣␣␣␣␣␣␣unless(␣-e␣$file␣&&␣-s␣_␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣msg(loc("'%1'␣said␣it␣fetched␣'%2',␣but␣it␣was␣not␣created",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'File::Fetch',␣$file),␣$verbose);

␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$abs␣=␣File::Spec->rel2abs(␣$file␣);
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣so␣TTLs␣will␣work
␣␣␣␣␣␣␣␣␣␣␣␣$self->_update_timestamp(␣file␣=>␣$abs␣);
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣return␣$abs;
␣␣␣␣␣␣␣␣}

␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣error(loc("Fetching␣of␣'%1'␣failed:␣%2",␣$where,␣$ff->error));
␣␣␣␣}

␣␣␣␣return;
}

=pod

=head2␣_add_fail_host(␣host␣=>␣$host_hashref␣)

Mark␣a␣particular␣host␣as␣bad.␣This␣makes␣C<CPANPLUS::Internals::Fetch>
skip␣it␣in␣fetches␣until␣this␣cache␣is␣flushed.

=head2␣_host_ok(␣host␣=>␣$host_hashref␣)

Query␣the␣cache␣to␣see␣if␣this␣host␣is␣ok,␣or␣if␣it␣has␣been␣flagged
as␣bad.

Returns␣true␣if␣the␣host␣is␣ok,␣false␣otherwise.

=cut

{␣␣␣###␣caching␣functions␣###

␣␣␣␣sub␣_add_fail_host␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣␣␣␣␣my␣$host;
␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣host␣=>␣{␣required␣␣␣␣␣␣=>␣1,␣default␣␣␣=>␣{},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣strict_type␣␣␣=>␣1,␣store␣␣␣␣␣=>␣\$host␣},
␣␣␣␣␣␣␣␣};

␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣␣␣␣␣return␣$self->_hosts->{$host}␣=␣1;
␣␣␣␣}

␣␣␣␣sub␣_host_ok␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣␣␣␣␣my␣$host;
␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣host␣=>␣{␣required␣=>␣1,␣store␣=>␣\$host␣},
␣␣␣␣␣␣␣␣};

␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣␣␣␣␣return␣$self->_hosts->{$host}␣?␣0␣:␣1;
␣␣␣␣}
}


1;

#␣Local␣variables:
#␣c-indentation-style:␣bsd
#␣c-basic-offset:␣4
#␣indent-tabs-mode:␣nil
#␣End:
#␣vim:␣expandtab␣shiftwidth=4:
package␣CPANPLUS::Internals::Source::Memory;

use␣base␣'CPANPLUS::Internals::Source';

use␣strict;

use␣CPANPLUS::Error;
use␣CPANPLUS::Module;
use␣CPANPLUS::Module::Fake;
use␣CPANPLUS::Module::Author;
use␣CPANPLUS::Internals::Constants;

use␣File::Fetch;
use␣Archive::Extract;

use␣IPC::Cmd␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[can_run];
use␣File::Temp␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[tempdir];
use␣File::Basename␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[dirname];
use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[allow␣check];
use␣Module::Load::Conditional␣␣␣qw[can_load];
use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';

$Params::Check::VERBOSE␣=␣1;

=head1␣NAME␣

CPANPLUS::Internals::Source::Memory␣-␣In␣memory␣implementation

=cut

###␣flag␣to␣show␣if␣init_trees␣got␣its'␣data␣from␣storable.␣This␣allows
###␣us␣to␣not␣write␣an␣existing␣stored␣file␣back␣to␣disk
{␣␣␣my␣$from_storable;

␣␣␣␣sub␣_init_trees␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣␣␣␣␣my($path,$uptodate,$verbose,$use_stored);
␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('base'),␣store␣=>␣\$path␣},
␣␣␣␣␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),␣store␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣␣␣␣␣uptodate␣␣␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$uptodate␣},
␣␣␣␣␣␣␣␣␣␣␣␣use_stored␣␣=>␣{␣default␣␣=>␣1,␣store␣=>␣\$use_stored␣},
␣␣␣␣␣␣␣␣};
␣␣␣␣
␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣
␣␣␣␣␣␣␣␣###␣retrieve␣the␣stored␣source␣files␣###
␣␣␣␣␣␣␣␣my␣$stored␣␣␣␣␣␣=␣$self->__memory_retrieve_source(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣␣␣␣␣=>␣$path,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣uptodate␣␣␣␣=>␣$uptodate␣&&␣$use_stored,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣$verbose,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣||␣{};
␣␣␣␣
␣␣␣␣␣␣␣␣###␣we␣got␣this␣from␣storable␣if␣$stored␣has␣keys..
␣␣␣␣␣␣␣␣$from_storable␣=␣keys␣%$stored␣?␣1␣:␣0;
␣␣␣␣
␣␣␣␣␣␣␣␣###␣set␣up␣the␣trees
␣␣␣␣␣␣␣␣$self->_atree(␣$stored->{_atree}␣||␣{}␣);␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣$self->_mtree(␣$stored->{_mtree}␣||␣{}␣);

␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}

␣␣␣␣sub␣_standard_trees_completed␣{␣return␣$from_storable␣}
␣␣␣␣sub␣_custom_trees_completed␣␣␣{␣return␣$from_storable␣}

␣␣␣␣sub␣_finalize_trees␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣␣␣␣␣my($path,$uptodate,$verbose);
␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('base'),␣store␣=>␣\$path␣},
␣␣␣␣␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),␣store␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣␣␣␣␣uptodate␣␣␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$uptodate␣},
␣␣␣␣␣␣␣␣};

␣␣␣␣␣␣␣␣{␣␣␣local␣$Params::Check::ALLOW_UNKNOWN␣=␣1;␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣write␣the␣stored␣files␣to␣disk,␣so␣we␣can␣keep␣using␣them
␣␣␣␣␣␣␣␣###␣from␣now␣on,␣till␣they␣become␣invalid
␣␣␣␣␣␣␣␣###␣write␣them␣if␣the␣original␣sources␣weren't␣uptodate,␣or
␣␣␣␣␣␣␣␣###␣we␣didn't␣just␣load␣storable␣files
␣␣␣␣␣␣␣␣$self->__memory_save_source()␣if␣!$uptodate␣or␣not␣$from_storable;
␣␣␣␣
␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}
␣␣␣␣
␣␣␣␣###␣saves␣current␣memory␣state
␣␣␣␣sub␣_save_state␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣return␣$self->_finalize_trees(␣@_,␣uptodate␣=>␣0␣);
␣␣␣␣}␣␣␣␣␣␣␣␣
}

sub␣_add_author_object␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣my␣$class;
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣class␣␣␣=>␣{␣default␣=>␣'CPANPLUS::Module::Author',␣store␣=>␣\$class␣},
␣␣␣␣␣␣␣␣map␣{␣$_␣=>␣{␣required␣=>␣1␣}␣}␣
␣␣␣␣␣␣␣␣␣␣␣␣qw[␣author␣cpanid␣email␣]
␣␣␣␣};

␣␣␣␣my␣$href␣=␣do␣{
␣␣␣␣␣␣␣␣local␣$Params::Check::NO_DUPLICATES␣=␣1;
␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣};
␣␣␣␣
␣␣␣␣my␣$obj␣=␣$class->new(␣%$href,␣_id␣=>␣$self->_id␣);
␣␣␣␣
␣␣␣␣$self->author_tree->{␣$href->{'cpanid'}␣}␣=␣$obj␣or␣return;

␣␣␣␣return␣$obj;
}

sub␣_add_module_object␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$class;␣␣␣␣
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣class␣␣␣=>␣{␣default␣=>␣'CPANPLUS::Module',␣store␣=>␣\$class␣},
␣␣␣␣␣␣␣␣map␣{␣$_␣=>␣{␣required␣=>␣1␣}␣}␣
␣␣␣␣␣␣␣␣␣␣␣␣qw[␣module␣version␣path␣comment␣author␣package␣description␣dslip␣mtime␣]
␣␣␣␣};

␣␣␣␣my␣$href␣=␣do␣{
␣␣␣␣␣␣␣␣local␣$Params::Check::NO_DUPLICATES␣=␣1;
␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣};
␣␣␣␣
␣␣␣␣my␣$obj␣=␣$class->new(␣%$href,␣_id␣=>␣$self->_id␣);
␣␣␣␣
␣␣␣␣###␣Every␣module␣get's␣stored␣as␣a␣module␣object␣###
␣␣␣␣$self->module_tree->{␣$href->{module}␣}␣=␣$obj␣or␣return;

␣␣␣␣return␣$obj;␣␣␣␣
}

{␣␣␣my␣%map␣=␣(
␣␣␣␣␣␣␣␣_source_search_module_tree␣␣=>␣[␣module_tree␣=>␣'CPANPLUS::Module'␣],
␣␣␣␣␣␣␣␣_source_search_author_tree␣␣=>␣[␣author_tree␣=>␣'CPANPLUS::Module::Author'␣],
␣␣␣␣);␣␣␣␣␣␣␣␣

␣␣␣␣while(␣my($sub,␣$aref)␣=␣each␣%map␣)␣{
␣␣␣␣␣␣␣␣no␣strict␣'refs';
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my($meth,␣$class)␣=␣@$aref;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣*$sub␣=␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣my($authors,$list,$verbose,$type);
␣␣␣␣␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣data␣␣␣␣=>␣{␣default␣␣␣␣=>␣[],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣strict_type=>␣1,␣store␣␣␣␣␣=>␣\$authors␣},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣allow␣␣␣=>␣{␣required␣␣␣=>␣1,␣default␣␣␣=>␣[␣],␣strict_type␣=>␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣=>␣\$list␣},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣␣␣␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣type␣␣␣␣=>␣{␣required␣␣␣=>␣1,␣allow␣=>␣[$class->accessors()],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣=>␣\$type␣},
␣␣␣␣␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣my␣@rv;
␣␣␣␣␣␣␣␣␣␣␣␣for␣my␣$obj␣(␣values␣%{␣$self->$meth␣}␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#push␣@rv,␣$auth␣if␣check(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣$type␣=>␣{␣allow␣=>␣$list␣}␣},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣$type␣=>␣$auth->$type␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@rv,␣$obj␣if␣allow(␣$obj->$type()␣=>␣$list␣);
␣␣␣␣␣␣␣␣␣␣␣␣}␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣return␣@rv;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
}

=pod

=head2␣$cb->__memory_retrieve_source(name␣=>␣$name,␣[path␣=>␣$path,␣uptodate␣=>␣BOOL,␣verbose␣=>␣BOOL])

This␣method␣retrieves␣a␣I<storable>d␣tree␣identified␣by␣C<$name>.

It␣takes␣the␣following␣arguments:

=over␣4

=item␣name

The␣internal␣name␣for␣the␣source␣file␣to␣retrieve.

=item␣uptodate

A␣flag␣indicating␣whether␣the␣file-cache␣is␣up-to-date␣or␣not.

=item␣path

The␣absolute␣path␣to␣the␣directory␣holding␣the␣source␣files.

=item␣verbose

A␣boolean␣flag␣indicating␣whether␣or␣not␣to␣be␣verbose.

=back

Will␣get␣information␣from␣the␣config␣file␣by␣default.

Returns␣a␣tree␣on␣success,␣false␣on␣failure.

=cut

sub␣__memory_retrieve_source␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣my␣$conf␣=␣$self->configure_object;

␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣path␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('base')␣},
␣␣␣␣␣␣␣␣verbose␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose')␣},
␣␣␣␣␣␣␣␣uptodate␣=>␣{␣default␣=>␣0␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣###␣check␣if␣we␣can␣retrieve␣a␣frozen␣data␣structure␣with␣storable␣###
␣␣␣␣my␣$storable␣=␣can_load(␣modules␣=>␣{'Storable'␣=>␣'0.0'}␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣$conf->get_conf('storable');

␣␣␣␣return␣unless␣$storable;

␣␣␣␣###␣$stored␣is␣the␣name␣of␣the␣frozen␣data␣structure␣###
␣␣␣␣my␣$stored␣=␣$self->__memory_storable_file(␣$args->{path}␣);

␣␣␣␣if␣($storable␣&&␣-e␣$stored␣&&␣-s␣_␣&&␣$args->{'uptodate'})␣{
␣␣␣␣␣␣␣␣msg(␣loc("Retrieving␣%1",␣$stored),␣$args->{'verbose'}␣);

␣␣␣␣␣␣␣␣my␣$href␣=␣Storable::retrieve($stored);
␣␣␣␣␣␣␣␣return␣$href;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
}

=pod

=head2␣$cb->__memory_save_source([verbose␣=>␣BOOL,␣path␣=>␣$path])

This␣method␣saves␣all␣the␣parsed␣trees␣in␣I<storable>d␣format␣if
C<Storable>␣is␣available.

It␣takes␣the␣following␣arguments:

=over␣4

=item␣path

The␣absolute␣path␣to␣the␣directory␣holding␣the␣source␣files.

=item␣verbose

A␣boolean␣flag␣indicating␣whether␣or␣not␣to␣be␣verbose.

=back

Will␣get␣information␣from␣the␣config␣file␣by␣default.

Returns␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣__memory_save_source␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣my␣$conf␣=␣$self->configure_object;


␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣path␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('base'),␣allow␣=>␣DIR_EXISTS␣},
␣␣␣␣␣␣␣␣verbose␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose')␣},
␣␣␣␣␣␣␣␣force␣␣␣␣=>␣{␣default␣=>␣1␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣my␣$aref␣=␣[qw[_mtree␣_atree]];

␣␣␣␣###␣check␣if␣we␣can␣retrieve␣a␣frozen␣data␣structure␣with␣storable␣###
␣␣␣␣my␣$storable;
␣␣␣␣$storable␣=␣can_load(␣modules␣=>␣{'Storable'␣=>␣'0.0'}␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣$conf->get_conf('storable');
␣␣␣␣return␣unless␣$storable;

␣␣␣␣my␣$to_write␣=␣{};
␣␣␣␣foreach␣my␣$key␣(␣@$aref␣)␣{
␣␣␣␣␣␣␣␣next␣unless␣ref(␣$self->$key␣);
␣␣␣␣␣␣␣␣$to_write->{$key}␣=␣$self->$key;
␣␣␣␣}

␣␣␣␣return␣unless␣keys␣%$to_write;

␣␣␣␣###␣$stored␣is␣the␣name␣of␣the␣frozen␣data␣structure␣###
␣␣␣␣my␣$stored␣=␣$self->__memory_storable_file(␣$args->{path}␣);

␣␣␣␣if␣(-e␣$stored␣&&␣not␣-w␣$stored)␣{
␣␣␣␣␣␣␣␣msg(␣loc("%1␣not␣writable;␣skipped.",␣$stored),␣$args->{'verbose'}␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣msg(␣loc("Writing␣compiled␣source␣information␣to␣disk.␣This␣might␣take␣a␣little␣while."),
	␣␣␣␣$args->{'verbose'}␣);

␣␣␣␣my␣$flag;
␣␣␣␣unless(␣Storable::nstore(␣$to_write,␣$stored␣)␣)␣{
␣␣␣␣␣␣␣␣error(␣loc("could␣not␣store␣%1!",␣$stored)␣);
␣␣␣␣␣␣␣␣$flag++;
␣␣␣␣}

␣␣␣␣return␣$flag␣?␣0␣:␣1;
}

sub␣__memory_storable_file␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣my␣$path␣=␣shift␣or␣return;

␣␣␣␣###␣check␣if␣we␣can␣retrieve␣a␣frozen␣data␣structure␣with␣storable␣###
␣␣␣␣my␣$storable␣=␣$conf->get_conf('storable')
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣can_load(␣modules␣=>␣{'Storable'␣=>␣'0.0'}␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣0;

␣␣␣␣return␣unless␣$storable;
␣␣␣␣
␣␣␣␣###␣$stored␣is␣the␣name␣of␣the␣frozen␣data␣structure␣###
␣␣␣␣###␣changed␣to␣use␣File::Spec->catfile␣-jmb
␣␣␣␣my␣$stored␣=␣File::Spec->rel2abs(
␣␣␣␣␣␣␣␣File::Spec->catfile(
␣␣␣␣␣␣␣␣␣␣␣␣$path,␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#base␣dir
␣␣␣␣␣␣␣␣␣␣␣␣$conf->_get_source('stored')␣␣␣␣#file
␣␣␣␣␣␣␣␣␣␣␣␣.␣'.s'␣.
␣␣␣␣␣␣␣␣␣␣␣␣$Storable::VERSION␣␣␣␣␣␣␣␣␣␣␣␣␣␣#the␣version␣of␣storable␣
␣␣␣␣␣␣␣␣␣␣␣␣.␣'.c'␣.
␣␣␣␣␣␣␣␣␣␣␣␣$self->VERSION␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#the␣version␣of␣CPANPLUS
␣␣␣␣␣␣␣␣␣␣␣␣.␣STORABLE_EXT␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#append␣a␣suffix
␣␣␣␣␣␣␣␣)
␣␣␣␣);

␣␣␣␣return␣$stored;
}




#␣Local␣variables:
#␣c-indentation-style:␣bsd
#␣c-basic-offset:␣4
#␣indent-tabs-mode:␣nil
#␣End:
#␣vim:␣expandtab␣shiftwidth=4:

1;
package␣CPANPLUS::Internals::Source::SQLite::Tie;

use␣strict;
use␣warnings;

use␣CPANPLUS::Error;
use␣CPANPLUS::Module;
use␣CPANPLUS::Module::Fake;
use␣CPANPLUS::Module::Author::Fake;
use␣CPANPLUS::Internals::Constants;


use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[check];
use␣Module::Load::Conditional␣␣␣qw[can_load];
use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';


use␣Data::Dumper;
$Data::Dumper::Indent␣=␣1;

require␣Tie::Hash;
use␣vars␣qw[@ISA];
push␣@ISA,␣'Tie::StdHash';


sub␣TIEHASH␣{
␣␣␣␣my␣$class␣=␣shift;
␣␣␣␣my␣%hash␣␣=␣@_;
␣␣␣␣
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣dbh␣␣␣␣␣=>␣{␣required␣=>␣1␣},
␣␣␣␣␣␣␣␣table␣␣␣=>␣{␣required␣=>␣1␣},
␣␣␣␣␣␣␣␣key␣␣␣␣␣=>␣{␣required␣=>␣1␣},
␣␣␣␣␣␣␣␣cb␣␣␣␣␣␣=>␣{␣required␣=>␣1␣},
␣␣␣␣␣␣␣␣offset␣␣=>␣{␣default␣␣=>␣0␣},
␣␣␣␣};
␣␣␣␣
␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣my␣$obj␣␣=␣bless␣{␣%$args,␣store␣=>␣{}␣}␣,␣$class;

␣␣␣␣return␣$obj;
}␣␣␣␣

sub␣FETCH␣{
␣␣␣␣my␣$self␣␣␣␣=␣shift;
␣␣␣␣my␣$key␣␣␣␣␣=␣shift␣or␣return;
␣␣␣␣my␣$dbh␣␣␣␣␣=␣$self->{dbh};
␣␣␣␣my␣$cb␣␣␣␣␣␣=␣$self->{cb};
␣␣␣␣my␣$table␣␣␣=␣$self->{table};
␣␣␣␣
␣␣␣␣
␣␣␣␣###␣did␣we␣look␣this␣one␣up␣before?
␣␣␣␣if(␣my␣$obj␣=␣$self->{store}->{$key}␣)␣{
␣␣␣␣␣␣␣␣return␣$obj;
␣␣␣␣}
␣␣␣␣
␣␣␣␣my␣$res␣␣=␣$dbh->query(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"SELECT␣*␣from␣$table␣where␣$self->{key}␣=␣?",␣$key
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣or␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(␣$dbh->error␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣my␣$href␣=␣$res->hash;
␣␣␣␣
␣␣␣␣###␣get␣rid␣of␣the␣primary␣key
␣␣␣␣delete␣$href->{'id'};
␣␣␣␣
␣␣␣␣###␣no␣results?
␣␣␣␣return␣unless␣keys␣%$href;
␣␣␣␣
␣␣␣␣###␣expand␣author␣if␣needed
␣␣␣␣###␣XXX␣no␣longer␣generic␣:(
␣␣␣␣if(␣$table␣eq␣'module'␣)␣{
␣␣␣␣␣␣␣␣$href->{author}␣=␣$cb->author_tree(␣$href->{author␣}␣)␣or␣return;
␣␣␣␣}

␣␣␣␣my␣$class␣=␣{
␣␣␣␣␣␣␣␣module␣␣=>␣'CPANPLUS::Module',
␣␣␣␣␣␣␣␣author␣␣=>␣'CPANPLUS::Module::Author',
␣␣␣␣}->{␣$table␣};

␣␣␣␣my␣$obj␣=␣$self->{store}->{$key}␣=␣$class->new(␣%$href,␣_id␣=>␣$cb->_id␣);␣␣␣
␣␣␣␣
␣␣␣␣return␣$obj;
}

sub␣STORE␣{␣
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$key␣␣=␣shift;
␣␣␣␣my␣$val␣␣=␣shift;
␣␣␣␣
␣␣␣␣$self->{store}->{$key}␣=␣$val;
}

1;

sub␣FIRSTKEY␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$dbh␣␣=␣$self->{'dbh'};

␣␣␣␣my␣$res␣␣=␣$dbh->query(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"select␣$self->{key}␣from␣$self->{table}␣order␣by␣$self->{key}␣limit␣1"
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣$self->{offset}␣=␣0;
␣␣␣␣
␣␣␣␣my␣$key␣=␣$res->flat->[0];

␣␣␣␣return␣$key;
}

sub␣NEXTKEY␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$dbh␣␣=␣$self->{'dbh'};

␣␣␣␣my␣$res␣␣=␣$dbh->query(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"select␣$self->{key}␣from␣$self->{table}␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"order␣by␣$self->{key}␣limit␣1␣offset␣$self->{offset}"
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣$self->{offset}␣+=1;

␣␣␣␣my␣$key␣=␣$res->flat->[0];
␣␣␣␣my␣$val␣=␣$self->FETCH(␣$key␣);

␣␣␣␣###␣use␣each()␣semantics
␣␣␣␣return␣wantarray␣?␣(␣$key,␣$val␣)␣:␣$key;
}

sub␣EXISTS␣␣␣{␣!!$_[0]->FETCH(␣$_[1]␣)␣}

sub␣SCALAR␣␣␣{␣
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$dbh␣␣=␣$self->{'dbh'};

␣␣␣␣my␣$res␣␣=␣$dbh->query(␣"select␣count(*)␣from␣$self->{table}"␣);

␣␣␣␣return␣$res->flat;
}

###␣intentionally␣left␣blank
sub␣DELETE␣␣␣{␣␣}
sub␣CLEAR␣␣␣␣{␣␣}

package␣CPANPLUS::Internals::Source::SQLite;

use␣strict;
use␣warnings;

use␣base␣'CPANPLUS::Internals::Source';

use␣CPANPLUS::Error;
use␣CPANPLUS::Internals::Constants;
use␣CPANPLUS::Internals::Source::SQLite::Tie;

use␣Data::Dumper;
use␣DBIx::Simple;
use␣DBD::SQLite;

use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[allow␣check];
use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';

use␣constant␣TXN_COMMIT␣=>␣1000;

=head1␣NAME␣

CPANPLUS::Internals::Source::SQLite␣-␣SQLite␣implementation

=cut

{␣␣␣my␣$Dbh;
␣␣␣␣my␣$DbFile;

␣␣␣␣sub␣__sqlite_file␣{␣
␣␣␣␣␣␣␣␣return␣$DbFile␣if␣$DbFile;

␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣$conf␣=␣$self->configure_object;

␣␣␣␣␣␣␣␣$DbFile␣=␣File::Spec->catdir(␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$conf->get_conf('base'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣SOURCE_SQLITE_DB
␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣
␣␣␣␣␣␣␣␣return␣$DbFile;
␣␣␣␣};

␣␣␣␣sub␣__sqlite_dbh␣{␣
␣␣␣␣␣␣␣␣return␣$Dbh␣if␣$Dbh;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣$Dbh␣␣␣␣␣=␣DBIx::Simple->connect(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"dbi:SQLite:dbname="␣.␣$self->__sqlite_file,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'',␣'',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣AutoCommit␣=>␣1␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣#$Dbh->dbh->trace(1);

␣␣␣␣␣␣␣␣return␣$Dbh;␣␣␣␣␣␣␣␣
␣␣␣␣};
}

{␣␣␣my␣$used_old_copy␣=␣0;

␣␣␣␣sub␣_init_trees␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣$conf␣=␣$self->configure_object;
␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣
␣␣␣␣␣␣␣␣my($path,$uptodate,$verbose,$use_stored);
␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('base'),␣store␣=>␣\$path␣},
␣␣␣␣␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),␣store␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣␣␣␣␣uptodate␣␣␣␣=>␣{␣required␣=>␣1,␣store␣=>␣\$uptodate␣},
␣␣␣␣␣␣␣␣␣␣␣␣use_stored␣␣=>␣{␣default␣␣=>␣1,␣store␣=>␣\$use_stored␣},
␣␣␣␣␣␣␣␣};
␣␣␣␣
␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣␣␣␣␣###␣if␣it's␣not␣uptodate,␣or␣the␣file␣doesn't␣exist,␣we␣need␣to␣create
␣␣␣␣␣␣␣␣###␣a␣new␣sqlite␣db
␣␣␣␣␣␣␣␣if(␣not␣$uptodate␣or␣not␣-e␣$self->__sqlite_file␣)␣{␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣$used_old_copy␣=␣0;

␣␣␣␣␣␣␣␣␣␣␣␣###␣chuck␣the␣file
␣␣␣␣␣␣␣␣␣␣␣␣1␣while␣unlink␣$self->__sqlite_file;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣and␣create␣a␣new␣one
␣␣␣␣␣␣␣␣␣␣␣␣$self->__sqlite_create_db␣or␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Could␣not␣create␣new␣SQLite␣DB"));
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣}␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$used_old_copy␣=␣1;
␣␣␣␣␣␣␣␣}␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣
␣␣␣␣␣␣␣␣###␣set␣up␣the␣author␣tree
␣␣␣␣␣␣␣␣{␣␣␣my␣%at;
␣␣␣␣␣␣␣␣␣␣␣␣tie␣%at,␣'CPANPLUS::Internals::Source::SQLite::Tie',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣dbh␣=>␣$self->__sqlite_dbh,␣table␣=>␣'author',␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣key␣=>␣'cpanid',␣␣␣␣␣␣␣␣␣␣␣␣cb␣=>␣$self;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣$self->_atree(␣\%at␣␣);
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣###␣set␣up␣the␣author␣tree
␣␣␣␣␣␣␣␣{␣␣␣my␣%mt;
␣␣␣␣␣␣␣␣␣␣␣␣tie␣%mt,␣'CPANPLUS::Internals::Source::SQLite::Tie',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣dbh␣=>␣$self->__sqlite_dbh,␣table␣=>␣'module',␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣key␣=>␣'module',␣␣␣␣␣␣␣␣␣␣␣␣cb␣=>␣$self;

␣␣␣␣␣␣␣␣␣␣␣␣$self->_mtree(␣\%mt␣␣);
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣start␣a␣transaction
␣␣␣␣␣␣␣␣$self->__sqlite_dbh->query('BEGIN');
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣return␣1;␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣
␣␣␣␣}
␣␣␣␣
␣␣␣␣sub␣_standard_trees_completed␣␣␣{␣return␣$used_old_copy␣}
␣␣␣␣sub␣_custom_trees_completed␣␣␣␣␣{␣return␣}
␣␣␣␣###␣finish␣transaction
␣␣␣␣sub␣_finalize_trees␣␣␣␣␣␣␣␣␣␣␣␣␣{␣$_[0]->__sqlite_dbh->query('COMMIT');␣return␣1␣}

␣␣␣␣###␣saves␣current␣memory␣state,␣but␣not␣implemented␣in␣sqlite
␣␣␣␣sub␣_save_state␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣
␣␣␣␣␣␣␣␣error(loc("%1␣has␣not␣implemented␣writing␣state␣to␣disk",␣__PACKAGE__));␣
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
}

{␣␣␣my␣$txn_count␣=␣0;

␣␣␣␣###␣XXX␣move␣this␣outside␣the␣sub,␣so␣we␣only␣compute␣it␣once
␣␣␣␣my␣$class;
␣␣␣␣my␣@keys␣␣␣␣=␣qw[␣author␣cpanid␣email␣];
␣␣␣␣my␣$tmpl␣␣␣␣=␣{
␣␣␣␣␣␣␣␣class␣␣␣=>␣{␣default␣=>␣'CPANPLUS::Module::Author',␣store␣=>␣\$class␣},
␣␣␣␣␣␣␣␣map␣{␣$_␣=>␣{␣required␣=>␣1␣}␣}␣@keys
␣␣␣␣␣};
␣␣␣␣
␣␣␣␣###␣dbix::simple's␣expansion␣of␣(??)␣is␣REALLY␣expensive,␣so␣do␣it␣manually
␣␣␣␣my␣$ph␣␣␣␣␣␣=␣join␣',',␣map␣{␣'?'␣}␣@keys;


␣␣␣␣sub␣_add_author_object␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣␣␣␣␣my␣$dbh␣␣=␣$self->__sqlite_dbh;
␣␣␣␣
␣␣␣␣␣␣␣␣my␣$href␣=␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣local␣$Params::Check::NO_DUPLICATES␣␣␣␣␣␣␣␣␣=␣1;␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣local␣$Params::Check::SANITY_CHECK_TEMPLATE␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣␣␣␣␣};

␣␣␣␣␣␣␣␣###␣keep␣counting␣how␣many␣we␣inserted
␣␣␣␣␣␣␣␣unless(␣++$txn_count␣%␣TXN_COMMIT␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣#warn␣"Committing␣transaction␣$txn_count";
␣␣␣␣␣␣␣␣␣␣␣␣$dbh->query('COMMIT')␣or␣error(␣$dbh->error␣);␣#␣commit␣previous␣transaction
␣␣␣␣␣␣␣␣␣␣␣␣$dbh->query('BEGIN')␣␣or␣error(␣$dbh->error␣);␣#␣and␣start␣a␣new␣one
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣$dbh->query(␣
␣␣␣␣␣␣␣␣␣␣␣␣"INSERT␣INTO␣author␣(".␣join(',',keys(%$href))␣.")␣VALUES␣($ph)",
␣␣␣␣␣␣␣␣␣␣␣␣values␣%$href
␣␣␣␣␣␣␣␣)␣or␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(␣$dbh->error␣);
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣␣}
}

{␣␣␣my␣$txn_count␣=␣0;

␣␣␣␣###␣XXX␣move␣this␣outside␣the␣sub,␣so␣we␣only␣compute␣it␣once
␣␣␣␣my␣$class;␣␣␣␣
␣␣␣␣my␣@keys␣=␣qw[␣module␣version␣path␣comment␣author␣package␣description␣dslip␣mtime␣];
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣class␣␣␣=>␣{␣default␣=>␣'CPANPLUS::Module',␣store␣=>␣\$class␣},
␣␣␣␣␣␣␣␣map␣{␣$_␣=>␣{␣required␣=>␣1␣}␣}␣@keys
␣␣␣␣};
␣␣␣␣
␣␣␣␣###␣dbix::simple's␣expansion␣of␣(??)␣is␣REALLY␣expensive,␣so␣do␣it␣manually
␣␣␣␣my␣$ph␣␣␣␣␣␣=␣join␣',',␣map␣{␣'?'␣}␣@keys;

␣␣␣␣sub␣_add_module_object␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣␣␣␣␣my␣$dbh␣␣=␣$self->__sqlite_dbh;
␣␣␣␣
␣␣␣␣␣␣␣␣my␣$href␣=␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣local␣$Params::Check::NO_DUPLICATES␣␣␣␣␣␣␣␣␣=␣1;
␣␣␣␣␣␣␣␣␣␣␣␣local␣$Params::Check::SANITY_CHECK_TEMPLATE␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣fix␣up␣author␣to␣be␣'plain'␣string
␣␣␣␣␣␣␣␣$href->{'author'}␣=␣$href->{'author'}->cpanid;

␣␣␣␣␣␣␣␣###␣keep␣counting␣how␣many␣we␣inserted
␣␣␣␣␣␣␣␣unless(␣++$txn_count␣%␣TXN_COMMIT␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣#warn␣"Committing␣transaction␣$txn_count";
␣␣␣␣␣␣␣␣␣␣␣␣$dbh->query('COMMIT')␣or␣error(␣$dbh->error␣);␣#␣commit␣previous␣transaction
␣␣␣␣␣␣␣␣␣␣␣␣$dbh->query('BEGIN')␣␣or␣error(␣$dbh->error␣);␣#␣and␣start␣a␣new␣one
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣$dbh->query(␣
␣␣␣␣␣␣␣␣␣␣␣␣"INSERT␣INTO␣module␣(".␣join(',',keys(%$href))␣.")␣VALUES␣($ph)",␣
␣␣␣␣␣␣␣␣␣␣␣␣values␣%$href
␣␣␣␣␣␣␣␣)␣or␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(␣$dbh->error␣);
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}
}

{␣␣␣my␣%map␣=␣(
␣␣␣␣␣␣␣␣_source_search_module_tree␣␣
␣␣␣␣␣␣␣␣␣␣␣␣=>␣[␣module␣=>␣module␣=>␣'CPANPLUS::Module'␣],
␣␣␣␣␣␣␣␣_source_search_author_tree␣␣
␣␣␣␣␣␣␣␣␣␣␣␣=>␣[␣author␣=>␣cpanid␣=>␣'CPANPLUS::Module::Author'␣],
␣␣␣␣);␣␣␣␣␣␣␣␣

␣␣␣␣while(␣my($sub,␣$aref)␣=␣each␣%map␣)␣{
␣␣␣␣␣␣␣␣no␣strict␣'refs';
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my($table,␣$key,␣$class)␣=␣@$aref;
␣␣␣␣␣␣␣␣*$sub␣=␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣␣␣␣␣my␣%hash␣=␣@_;
␣␣␣␣␣␣␣␣␣␣␣␣my␣$dbh␣␣=␣$self->__sqlite_dbh;
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣my($list,$type);
␣␣␣␣␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣allow␣␣␣=>␣{␣required␣␣␣=>␣1,␣default␣␣␣=>␣[␣],␣strict_type␣=>␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣=>␣\$list␣},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣type␣␣␣␣=>␣{␣required␣␣␣=>␣1,␣allow␣=>␣[$class->accessors()],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣=>␣\$type␣},
␣␣␣␣␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣we␣aliased␣'module'␣to␣'name',␣so␣change␣that␣here␣too
␣␣␣␣␣␣␣␣␣␣␣␣$type␣=␣'module'␣if␣$type␣eq␣'name';
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣my␣$res␣=␣$dbh->query(␣"SELECT␣*␣from␣$table"␣);
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣my␣$meth␣=␣$table␣.'_tree';
␣␣␣␣␣␣␣␣␣␣␣␣my␣@rv␣=␣map␣␣{␣$self->$meth(␣$_->{$key}␣)␣}␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣grep␣{␣allow(␣$_->{$type}␣=>␣$list␣)␣}␣$res->hashes;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣return␣@rv;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
}



sub␣__sqlite_create_db␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$dbh␣␣=␣$self->__sqlite_dbh;
␣␣␣␣
␣␣␣␣###␣we␣can␣ignore␣the␣result/error;␣not␣all␣sqlite␣implemantation
␣␣␣␣###␣support␣this␣␣␣␣
␣␣␣␣$dbh->query(␣qq[
␣␣␣␣␣␣␣␣DROP␣TABLE␣IF␣EXISTS␣author;
␣␣␣␣␣␣␣␣\n]
␣␣␣␣␣)␣or␣do␣{
␣␣␣␣␣␣␣␣msg(␣$dbh->error␣);
␣␣␣␣};␣
␣␣␣␣$dbh->query(␣qq[
␣␣␣␣␣␣␣␣DROP␣TABLE␣IF␣EXISTS␣module;
␣␣␣␣␣␣␣␣\n]
␣␣␣␣␣)␣or␣do␣{
␣␣␣␣␣␣␣␣msg(␣$dbh->error␣);
␣␣␣␣};␣


␣␣␣␣
␣␣␣␣$dbh->query(␣qq[
␣␣␣␣␣␣␣␣/*␣the␣author␣information␣*/
␣␣␣␣␣␣␣␣CREATE␣TABLE␣author␣(
␣␣␣␣␣␣␣␣␣␣␣␣id␣INTEGER␣PRIMARY␣KEY␣AUTOINCREMENT,
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣author␣␣varchar(255),
␣␣␣␣␣␣␣␣␣␣␣␣email␣␣␣varchar(255),
␣␣␣␣␣␣␣␣␣␣␣␣cpanid␣␣varchar(255)
␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣\n]

␣␣␣␣)␣or␣do␣{
␣␣␣␣␣␣␣␣error(␣$dbh->error␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣};

␣␣␣␣$dbh->query(␣qq[
␣␣␣␣␣␣␣␣/*␣the␣module␣information␣*/
␣␣␣␣␣␣␣␣CREATE␣TABLE␣module␣(
␣␣␣␣␣␣␣␣␣␣␣␣id␣INTEGER␣PRIMARY␣KEY␣AUTOINCREMENT,
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣module␣␣␣␣␣␣varchar(255),
␣␣␣␣␣␣␣␣␣␣␣␣version␣␣␣␣␣varchar(255),
␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣␣␣␣␣varchar(255),
␣␣␣␣␣␣␣␣␣␣␣␣comment␣␣␣␣␣varchar(255),
␣␣␣␣␣␣␣␣␣␣␣␣author␣␣␣␣␣␣varchar(255),
␣␣␣␣␣␣␣␣␣␣␣␣package␣␣␣␣␣varchar(255),
␣␣␣␣␣␣␣␣␣␣␣␣description␣varchar(255),
␣␣␣␣␣␣␣␣␣␣␣␣dslip␣␣␣␣␣␣␣varchar(255),
␣␣␣␣␣␣␣␣␣␣␣␣mtime␣␣␣␣␣␣␣varchar(255)
␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣\n]

␣␣␣␣)␣or␣do␣{
␣␣␣␣␣␣␣␣error(␣$dbh->error␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣};␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣
␣␣␣␣return␣1;␣␣␣␣
}

1;
package␣CPANPLUS::Module;

use␣strict;
use␣vars␣qw[@ISA];


use␣CPANPLUS::Dist;
use␣CPANPLUS::Error;
use␣CPANPLUS::Module::Signature;
use␣CPANPLUS::Module::Checksums;
use␣CPANPLUS::Internals::Constants;

use␣FileHandle;

use␣Locale::Maketext::Simple␣␣␣␣Class␣=>␣'CPANPLUS',␣Style␣=>␣'gettext';
use␣IPC::Cmd␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[can_run␣run];
use␣File::Find␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[find];
use␣Params::Check␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[check];
use␣File::Basename␣␣␣␣␣␣␣␣␣␣␣␣␣␣qw[dirname];
use␣Module::Load::Conditional␣␣␣qw[can_load␣check_install];

$Params::Check::VERBOSE␣=␣1;

@ISA␣=␣qw[␣CPANPLUS::Module::Signature␣CPANPLUS::Module::Checksums];

=pod

=head1␣NAME

CPANPLUS::Module

=head1␣SYNOPSIS

␣␣␣␣###␣get␣a␣module␣object␣from␣the␣CPANPLUS::Backend␣object
␣␣␣␣my␣$mod␣=␣$cb->module_tree('Some::Module');

␣␣␣␣###␣accessors
␣␣␣␣$mod->version;
␣␣␣␣$mod->package;

␣␣␣␣###␣methods
␣␣␣␣$mod->fetch;
␣␣␣␣$mod->extract;
␣␣␣␣$mod->install;


=head1␣DESCRIPTION

C<CPANPLUS::Module>␣creates␣objects␣from␣the␣information␣in␣the
source␣files.␣These␣can␣then␣be␣used␣to␣query␣and␣perform␣actions
on,␣like␣fetching␣or␣installing.

These␣objects␣should␣only␣be␣created␣internally.␣For␣C<fake>␣objects,
there's␣the␣C<CPANPLUS::Module::Fake>␣class.␣To␣obtain␣a␣module␣object
consult␣the␣C<CPANPLUS::Backend>␣documentation.

=cut

my␣$tmpl␣=␣{
␣␣␣␣module␣␣␣␣␣␣=>␣{␣default␣=>␣'',␣required␣=>␣1␣},␣␣␣␣#␣full␣module␣name
␣␣␣␣version␣␣␣␣␣=>␣{␣default␣=>␣'0.0'␣},␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣version␣number
␣␣␣␣path␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣'',␣required␣=>␣1␣},␣␣␣␣#␣extended␣path␣on␣the
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣cpan␣mirror,␣like
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣/author/id/K/KA/KANE
␣␣␣␣comment␣␣␣␣␣=>␣{␣default␣=>␣''},␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣comment␣on␣module
␣␣␣␣package␣␣␣␣␣=>␣{␣default␣=>␣'',␣required␣=>␣1␣},␣␣␣␣#␣package␣name,␣like
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣'bar-baz-1.03.tgz'
␣␣␣␣description␣=>␣{␣default␣=>␣''␣},␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣description␣of␣the
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣module
␣␣␣␣dslip␣␣␣␣␣␣␣=>␣{␣default␣=>␣EMPTY_DSLIP␣},␣␣␣␣␣␣␣␣␣␣#␣dslip␣information
␣␣␣␣_id␣␣␣␣␣␣␣␣␣=>␣{␣required␣=>␣1␣},␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣id␣of␣the␣Internals
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣parent␣object
␣␣␣␣_status␣␣␣␣␣=>␣{␣no_override␣=>␣1␣},␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣stores␣status␣object
␣␣␣␣author␣␣␣␣␣␣=>␣{␣default␣=>␣'',␣required␣=>␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣allow␣=>␣IS_AUTHOBJ␣},␣␣␣␣␣␣␣␣␣␣␣␣␣#␣module␣author
␣␣␣␣mtime␣␣␣␣␣␣␣=>␣{␣default␣=>␣''␣},
};

###␣some␣of␣these␣will␣be␣resolved␣by␣wrapper␣functions␣that
###␣do␣Clever␣Things␣to␣find␣the␣actual␣value,␣so␣don't␣create
###␣an␣autogenerated␣sub␣for␣that␣just␣here,␣take␣an␣alternate
###␣name␣to␣allow␣for␣a␣wrapper
{␣␣␣my␣%rename␣=␣(
␣␣␣␣␣␣␣␣dslip␣␣␣=>␣'_dslip'
␣␣␣␣);

␣␣␣␣###␣autogenerate␣accessors␣###
␣␣␣␣for␣my␣$key␣(␣keys␣%$tmpl␣)␣{
␣␣␣␣␣␣␣␣no␣strict␣'refs';
␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my␣$sub␣=␣$rename{$key}␣||␣$key;
␣␣␣␣␣␣
␣␣␣␣␣␣␣␣*{__PACKAGE__."::$sub"}␣=␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣$_[0]->{$key}␣=␣$_[1]␣if␣@_␣>␣1;
␣␣␣␣␣␣␣␣␣␣␣␣return␣$_[0]->{$key};
␣␣␣␣␣␣␣␣}
␣␣␣␣}
}


=pod

=head1␣CLASS␣METHODS

=head2␣accessors␣()

Returns␣a␣list␣of␣all␣accessor␣methods␣to␣the␣object

=cut

###␣*name␣is␣an␣alias,␣include␣it␣explicitly
sub␣accessors␣{␣return␣('name',␣keys␣%$tmpl)␣};

=head1␣ACCESSORS

An␣objects␣of␣this␣class␣has␣the␣following␣accessors:

=over␣4

=item␣name

Name␣of␣the␣module.

=item␣module

Name␣of␣the␣module.

=item␣version

Version␣of␣the␣module.␣Defaults␣to␣'0.0'␣if␣none␣was␣provided.

=item␣path

Extended␣path␣on␣the␣mirror.

=item␣comment

Any␣comment␣about␣the␣module␣--␣largely␣unused.

=item␣package

The␣name␣of␣the␣package.

=item␣description

Description␣of␣the␣module␣--␣only␣registered␣modules␣have␣this.

=item␣dslip

The␣five␣character␣dslip␣string,␣that␣represents␣meta-data␣of␣the
module␣--␣again,␣only␣registered␣modules␣have␣this.

=cut

sub␣dslip␣{
␣␣␣␣my␣$self␣␣␣␣=␣shift;␣␣␣

␣␣␣␣###␣if␣this␣module␣has␣relevant␣dslip␣info,␣return␣it
␣␣␣␣return␣$self->_dslip␣if␣$self->_dslip␣ne␣EMPTY_DSLIP;

␣␣␣␣###␣if␣not,␣look␣at␣other␣modules␣in␣the␣same␣package,
␣␣␣␣###␣see␣if␣*they*␣have␣any␣dslip␣info
␣␣␣␣for␣my␣$mod␣(␣$self->contains␣)␣{
␣␣␣␣␣␣␣␣return␣$mod->_dslip␣if␣$mod->_dslip␣ne␣EMPTY_DSLIP;
␣␣␣␣}
␣␣␣␣
␣␣␣␣###␣ok,␣really␣no␣dslip␣info␣found,␣return␣the␣default
␣␣␣␣return␣EMPTY_DSLIP;
}


=pod

=item␣status

The␣C<CPANPLUS::Module::Status>␣object␣associated␣with␣this␣object.
(see␣below).

=item␣author

The␣C<CPANPLUS::Module::Author>␣object␣associated␣with␣this␣object.

=item␣parent

The␣C<CPANPLUS::Internals>␣object␣that␣spawned␣this␣module␣object.

=back

=cut

###␣Alias␣->name␣to␣->module,␣for␣human␣beings.
*name␣=␣*module;

sub␣parent␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$obj␣␣=␣CPANPLUS::Internals->_retrieve_id(␣$self->_id␣);

␣␣␣␣return␣$obj;
}

=head1␣STATUS␣ACCESSORS

C<CPANPLUS>␣caches␣a␣lot␣of␣results␣from␣method␣calls␣and␣saves␣data
it␣collected␣along␣the␣road␣for␣later␣reuse.

C<CPANPLUS>␣uses␣this␣internally,␣but␣it␣is␣also␣available␣for␣the␣end
user.␣You␣can␣get␣a␣status␣object␣by␣calling:

␣␣␣␣$modobj->status

You␣can␣then␣query␣the␣object␣as␣follows:

=over␣4

=item␣installer_type

The␣installer␣type␣used␣for␣this␣distribution.␣Will␣be␣one␣of
'makemaker'␣or␣'build'.␣This␣determines␣whether␣C<CPANPLUS::Dist::MM>
or␣C<CPANPLUS::Dist::Build>␣will␣be␣used␣to␣build␣this␣distribution.

=item␣dist_cpan

The␣dist␣object␣used␣to␣do␣the␣CPAN-side␣of␣the␣installation.␣Either
a␣C<CPANPLUS::Dist::MM>␣or␣C<CPANPLUS::Dist::Build>␣object.

=item␣dist

The␣custom␣dist␣object␣used␣to␣do␣the␣operating␣specific␣side␣of␣the
installation,␣if␣you've␣chosen␣to␣use␣this.␣For␣example,␣if␣you've
chosen␣to␣install␣using␣the␣C<ports>␣format,␣this␣may␣be␣a
C<CPANPLUS::Dist::Ports>␣object.

Undefined␣if␣you␣didn't␣specify␣a␣separate␣format␣to␣install␣through.

=item␣prereqs␣|␣requires

A␣hashref␣of␣prereqs␣this␣distribution␣was␣found␣to␣have.␣Will␣look
something␣like␣this:

␣␣␣␣{␣Carp␣␣=>␣0.01,␣strict␣=>␣0␣}

Might␣be␣undefined␣if␣the␣distribution␣didn't␣have␣any␣prerequisites.

=item␣configure_requires

Like␣prereqs,␣but␣these␣are␣necessary␣to␣be␣installed␣before␣the
build␣process␣can␣even␣begin.

=item␣signature

Flag␣indicating,␣if␣a␣signature␣check␣was␣done,␣whether␣it␣was␣OK␣or
not.

=item␣extract

The␣directory␣this␣distribution␣was␣extracted␣to.

=item␣fetch

The␣location␣this␣distribution␣was␣fetched␣to.

=item␣readme

The␣text␣of␣this␣distributions␣README␣file.

=item␣uninstall

Flag␣indicating␣if␣an␣uninstall␣call␣was␣done␣successfully.

=item␣created

Flag␣indicating␣if␣the␣C<create>␣call␣to␣your␣dist␣object␣was␣done
successfully.

=item␣installed

Flag␣indicating␣if␣the␣C<install>␣call␣to␣your␣dist␣object␣was␣done
successfully.

=item␣checksums

The␣location␣of␣this␣distributions␣CHECKSUMS␣file.

=item␣checksum_ok

Flag␣indicating␣if␣the␣checksums␣check␣was␣done␣successfully.

=item␣checksum_value

The␣checksum␣value␣this␣distribution␣is␣expected␣to␣have

=back

=head1␣METHODS

=head2␣$self␣=␣CPANPLUS::Module->new(␣OPTIONS␣)

This␣method␣returns␣a␣C<CPANPLUS::Module>␣object.␣Normal␣users
should␣never␣call␣this␣method␣directly,␣but␣instead␣use␣the
C<CPANPLUS::Backend>␣to␣obtain␣module␣objects.

This␣example␣illustrates␣a␣C<new()>␣call␣with␣all␣required␣arguments:

␣␣␣␣␣␣␣␣CPANPLUS::Module->new(
␣␣␣␣␣␣␣␣␣␣␣␣module␣␣=>␣'Foo',
␣␣␣␣␣␣␣␣␣␣␣␣path␣␣␣␣=>␣'authors/id/A/AA/AAA',
␣␣␣␣␣␣␣␣␣␣␣␣package␣=>␣'Foo-1.0.tgz',
␣␣␣␣␣␣␣␣␣␣␣␣author␣␣=>␣$author_object,
␣␣␣␣␣␣␣␣␣␣␣␣_id␣␣␣␣␣=>␣INTERNALS_OBJECT_ID,
␣␣␣␣␣␣␣␣);

Every␣accessor␣is␣also␣a␣valid␣option␣to␣pass␣to␣C<new>.

Returns␣a␣module␣object␣on␣success␣and␣false␣on␣failure.

=cut


sub␣new␣{
␣␣␣␣my($class,␣%hash)␣=␣@_;

␣␣␣␣###␣don't␣check␣the␣template␣for␣sanity
␣␣␣␣###␣--␣we␣know␣it's␣good␣and␣saves␣a␣lot␣of␣performance
␣␣␣␣local␣$Params::Check::SANITY_CHECK_TEMPLATE␣=␣0;

␣␣␣␣my␣$object␣␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣bless␣$object,␣$class;

␣␣␣␣return␣$object;
}

###␣only␣create␣status␣objects␣when␣they're␣actually␣asked␣for
sub␣status␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣return␣$self->_status␣if␣$self->_status;
␣␣␣␣
␣␣␣␣my␣$acc␣=␣Object::Accessor->new;
␣␣␣␣$acc->mk_accessors(␣qw[␣installer_type␣dist_cpan␣dist␣prereqs
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣signature␣extract␣fetch␣readme␣uninstall
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣created␣installed␣prepared␣checksums␣files
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣checksum_ok␣checksum_value␣_fetch_from
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣configure_requires
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣]␣);

␣␣␣␣###␣create␣an␣alias␣from␣'requires'␣to␣'prereqs',␣so␣it's␣more␣in
␣␣␣␣###␣line␣with␣'configure_requires';
␣␣␣␣$acc->mk_aliases(␣requires␣=>␣'prereqs'␣);

␣␣␣␣$self->_status(␣$acc␣);

␣␣␣␣return␣$self->_status;
}


###␣flush␣the␣cache␣of␣this␣object␣###
sub␣_flush␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣$self->status->mk_flush;
␣␣␣␣return␣1;
}

=head2␣$mod->package_name(␣[$package_string]␣)

Returns␣the␣name␣of␣the␣package␣a␣module␣is␣in.␣For␣C<Acme::Bleach>
that␣might␣be␣C<Acme-Bleach>.

=head2␣$mod->package_version(␣[$package_string]␣)

Returns␣the␣version␣of␣the␣package␣a␣module␣is␣in.␣For␣a␣module
in␣the␣package␣C<Acme-Bleach-1.1.tar.gz>␣this␣would␣be␣C<1.1>.

=head2␣$mod->package_extension(␣[$package_string]␣)

Returns␣the␣suffix␣added␣by␣the␣compression␣method␣of␣a␣package␣a
certain␣module␣is␣in.␣For␣a␣module␣in␣C<Acme-Bleach-1.1.tar.gz>,␣this
would␣be␣C<tar.gz>.

=head2␣$mod->package_is_perl_core

Returns␣a␣boolean␣indicating␣of␣the␣package␣a␣particular␣module␣is␣in,
is␣actually␣a␣core␣perl␣distribution.

=head2␣$mod->module_is_supplied_with_perl_core(␣[version␣=>␣$]]␣)

Returns␣a␣boolean␣indicating␣whether␣C<ANY␣VERSION>␣of␣this␣module
was␣supplied␣with␣the␣current␣running␣perl's␣core␣package.

=head2␣$mod->is_bundle

Returns␣a␣boolean␣indicating␣if␣the␣module␣you␣are␣looking␣at,␣is
actually␣a␣bundle.␣Bundles␣are␣identified␣as␣modules␣whose␣name␣starts
with␣C<Bundle::>.

=head2␣$mod->is_autobundle;

Returns␣a␣boolean␣indicating␣if␣the␣module␣you␣are␣looking␣at,␣is
actually␣an␣autobundle␣as␣generated␣by␣C<<␣$cb->autobundle␣>>.␣

=head2␣$mod->is_third_party

Returns␣a␣boolean␣indicating␣whether␣the␣package␣is␣a␣known␣third-party␣
module␣(i.e.␣it's␣not␣provided␣by␣the␣standard␣Perl␣distribution␣and␣
is␣not␣available␣on␣the␣CPAN,␣but␣on␣a␣third␣party␣software␣provider).
See␣L<Module::ThirdParty>␣for␣more␣details.

=head2␣$mod->third_party_information

Returns␣a␣reference␣to␣a␣hash␣with␣more␣information␣about␣a␣third-party
module.␣See␣the␣documentation␣about␣C<module_information()>␣in␣
L<Module::ThirdParty>␣for␣more␣details.

=cut

{␣␣␣###␣fetches␣the␣test␣reports␣for␣a␣certain␣module␣###
␣␣␣␣my␣%map␣=␣(
␣␣␣␣␣␣␣␣name␣␣␣␣␣␣␣␣=>␣0,
␣␣␣␣␣␣␣␣version␣␣␣␣␣=>␣1,
␣␣␣␣␣␣␣␣extension␣␣␣=>␣2,
␣␣␣␣);␣␣␣␣␣␣␣␣
␣␣␣␣
␣␣␣␣while␣(␣my($type,␣$index)␣=␣each␣%map␣)␣{
␣␣␣␣␣␣␣␣my␣$name␣␣␣␣=␣'package_'␣.␣$type;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣no␣strict␣'refs';
␣␣␣␣␣␣␣␣*$name␣=␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣␣␣␣␣my␣$val␣␣=␣shift␣||␣$self->package;
␣␣␣␣␣␣␣␣␣␣␣␣my␣@res␣␣=␣$self->parent->_split_package_string(␣package␣=>␣$val␣);
␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣return␣the␣corresponding␣index␣from␣the␣result
␣␣␣␣␣␣␣␣␣␣␣␣return␣$res[$index]␣if␣@res;
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣};
␣␣␣␣}␣␣␣␣␣␣␣␣

␣␣␣␣sub␣package_is_perl_core␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣$cb␣␣␣=␣$self->parent;

␣␣␣␣␣␣␣␣###␣check␣if␣the␣package␣looks␣like␣a␣perl␣core␣package
␣␣␣␣␣␣␣␣return␣1␣if␣$self->package_name␣eq␣PERL_CORE;

␣␣␣␣␣␣␣␣###␣address␣#44562:␣::Module->package_is_perl_code␣:␣problem␣comparing␣
␣␣␣␣␣␣␣␣###␣version␣strings␣--␣use␣$cb->_vcmp␣to␣avoid␣warnings␣when␣version␣
␣␣␣␣␣␣␣␣###␣have␣_␣in␣them

␣␣␣␣␣␣␣␣my␣$core␣=␣$self->module_is_supplied_with_perl_core;
␣␣␣␣␣␣␣␣###␣ok,␣so␣it's␣found␣in␣the␣core,␣BUT␣it␣could␣be␣dual-lifed
␣␣␣␣␣␣␣␣if␣($core)␣{
␣␣␣␣␣␣␣␣␣␣␣␣###␣if␣the␣package␣is␣newer␣than␣installed,␣then␣it's␣dual-lifed
␣␣␣␣␣␣␣␣␣␣␣␣return␣if␣$cb->_vcmp($self->version,␣$self->installed_version)␣>␣0;
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣if␣the␣package␣is␣newer␣or␣equal␣to␣the␣corelist,␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣then␣it's␣dual-lifed
␣␣␣␣␣␣␣␣␣␣␣␣return␣if␣$cb->_vcmp(␣$self->version,␣$core␣)␣>=␣0;␣

␣␣␣␣␣␣␣␣␣␣␣␣###␣otherwise,␣it's␣older␣than␣corelist,␣thus␣unsuitable.
␣␣␣␣␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣###␣not␣in␣corelist,␣not␣a␣perl␣core␣package.
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣sub␣module_is_supplied_with_perl_core␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣my␣$ver␣␣=␣shift␣||␣$];

␣␣␣␣␣␣␣␣###␣allow␣it␣to␣be␣called␣as␣a␣package␣function␣as␣well␣like:
␣␣␣␣␣␣␣␣###␣␣␣CPANPLUS::Module::module_is_supplied_with_perl_core('Config')
␣␣␣␣␣␣␣␣###␣so␣that␣we␣can␣check␣the␣status␣of␣modules␣that␣aren't␣released
␣␣␣␣␣␣␣␣###␣to␣CPAN,␣but␣are␣part␣of␣the␣core.
␣␣␣␣␣␣␣␣my␣$name␣=␣ref␣$self␣?␣$self->module␣:␣$self;

␣␣␣␣␣␣␣␣###␣check␣Module::CoreList␣to␣see␣if␣it's␣a␣core␣package
␣␣␣␣␣␣␣␣require␣Module::CoreList;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣Address␣#41157:␣Module::module_is_supplied_with_perl_core()␣
␣␣␣␣␣␣␣␣###␣broken␣for␣perl␣5.10:␣Module::CoreList's␣version␣key␣for␣the␣
␣␣␣␣␣␣␣␣###␣hash␣has␣a␣different␣number␣of␣trailing␣zero␣than␣$]␣aka
␣␣␣␣␣␣␣␣###␣$PERL_VERSION.
␣␣␣␣␣␣␣␣my␣$core␣=␣$Module::CoreList::version{␣0+$ver␣}->{␣$name␣};

␣␣␣␣␣␣␣␣return␣$core;
␣␣␣␣}

␣␣␣␣###␣make␣sure␣Bundle-Foo␣also␣gets␣flagged␣as␣bundle
␣␣␣␣sub␣is_bundle␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣cpan'd␣bundle
␣␣␣␣␣␣␣␣return␣1␣if␣$self->module␣=~␣/^bundle(?:-|::)/i;
␣␣␣␣
␣␣␣␣␣␣␣␣###␣autobundle
␣␣␣␣␣␣␣␣return␣1␣if␣$self->is_autobundle;
␣␣␣␣
␣␣␣␣␣␣␣␣###␣neither
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣###␣full␣path␣to␣a␣generated␣autobundle
␣␣␣␣sub␣is_autobundle␣{
␣␣␣␣␣␣␣␣my␣$self␣␣␣␣=␣shift;
␣␣␣␣␣␣␣␣my␣$conf␣␣␣␣=␣$self->parent->configure_object;
␣␣␣␣␣␣␣␣my␣$prefix␣␣=␣$conf->_get_build('autobundle_prefix');

␣␣␣␣␣␣␣␣return␣1␣if␣$self->module␣eq␣$prefix;
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣sub␣is_third_party␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣return␣unless␣can_load(␣modules␣=>␣{␣'Module::ThirdParty'␣=>␣0␣}␣);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣return␣Module::ThirdParty::is_3rd_party(␣$self->name␣);
␣␣␣␣}

␣␣␣␣sub␣third_party_information␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;

␣␣␣␣␣␣␣␣return␣unless␣$self->is_third_party;␣

␣␣␣␣␣␣␣␣return␣Module::ThirdParty::module_information(␣$self->name␣);
␣␣␣␣}
}

=pod

=head2␣$clone␣=␣$self->clone

Clones␣the␣current␣module␣object␣for␣tinkering␣with.
It␣will␣have␣a␣clean␣C<CPANPLUS::Module::Status>␣object,␣as␣well␣as
a␣fake␣C<CPANPLUS::Module::Author>␣object.

=cut

{␣␣␣###␣accessors␣dont␣change␣during␣run␣time,␣so␣only␣compute␣once
␣␣␣␣my␣@acc␣=␣grep␣!/status/,␣__PACKAGE__->accessors();
␣␣␣␣
␣␣␣␣sub␣clone␣{
␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣
␣␣␣␣␣␣␣␣###␣clone␣the␣object␣###
␣␣␣␣␣␣␣␣my␣%data␣=␣map␣{␣$_␣=>␣$self->$_␣}␣@acc;
␣␣␣␣
␣␣␣␣␣␣␣␣my␣$obj␣=␣CPANPLUS::Module::Fake->new(␣%data␣);
␣␣␣␣
␣␣␣␣␣␣␣␣return␣$obj;
␣␣␣␣}
}

=pod

=head2␣$where␣=␣$self->fetch

Fetches␣the␣module␣from␣a␣CPAN␣mirror.
Look␣at␣L<CPANPLUS::Internals::Fetch::_fetch()>␣for␣details␣on␣the
options␣you␣can␣pass.

=cut

sub␣fetch␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$cb␣␣␣=␣$self->parent;

␣␣␣␣###␣custom␣args
␣␣␣␣my␣%args␣␣␣␣␣␣␣␣␣␣␣␣=␣(␣module␣=>␣$self␣);

␣␣␣␣###␣if␣a␣custom␣fetch␣location␣got␣specified␣before,␣add␣that␣here
␣␣␣␣$args{fetch_from}␣␣␣=␣$self->status->_fetch_from␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣$self->status->_fetch_from;

␣␣␣␣my␣$where␣=␣$cb->_fetch(␣@_,␣%args␣)␣or␣return;

␣␣␣␣###␣do␣an␣md5␣check␣###
␣␣␣␣if(␣!$self->status->_fetch_from␣and␣
␣␣␣␣␣␣␣␣$cb->configure_object->get_conf('md5')␣and
␣␣␣␣␣␣␣␣$self->package␣ne␣CHECKSUMS
␣␣␣␣)␣{
␣␣␣␣␣␣␣␣unless(␣$self->_validate_checksum␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(␣loc(␣"Checksum␣error␣for␣'%1'␣--␣will␣not␣trust␣package",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->package)␣);
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣return␣$where;
}

=pod

=head2␣$path␣=␣$self->extract

Extracts␣the␣fetched␣module.
Look␣at␣L<CPANPLUS::Internals::Extract::_extract()>␣for␣details␣on
the␣options␣you␣can␣pass.

=cut

sub␣extract␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$cb␣␣␣=␣$self->parent;

␣␣␣␣unless(␣$self->status->fetch␣)␣{
␣␣␣␣␣␣␣␣error(␣loc(␣"You␣have␣not␣fetched␣'%1'␣yet␣--␣cannot␣extract",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->module)␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
␣␣␣␣
␣␣␣␣###␣can't␣extract␣these,␣so␣just␣use␣the␣basedir␣for␣the␣file
␣␣␣␣if(␣$self->is_autobundle␣)␣{
␣␣␣␣
␣␣␣␣␣␣␣␣###␣this␣is␣expected␣to␣be␣set␣after␣an␣extract␣call
␣␣␣␣␣␣␣␣$self->get_installer_type;
␣␣␣␣
␣␣␣␣␣␣␣␣return␣$self->status->extract(␣dirname(␣$self->status->fetch␣)␣);
␣␣␣␣}
␣␣␣␣
␣␣␣␣return␣$cb->_extract(␣@_,␣module␣=>␣$self␣);
}

=head2␣$type␣=␣$self->get_installer_type([prefer_makefile␣=>␣BOOL])

Gets␣the␣installer␣type␣for␣this␣module.␣This␣may␣either␣be␣C<build>␣or
C<makemaker>.␣If␣C<Module::Build>␣is␣unavailable␣or␣no␣installer␣type
is␣available,␣it␣will␣fall␣back␣to␣C<makemaker>.␣If␣both␣are␣available,
it␣will␣pick␣the␣one␣indicated␣by␣your␣config,␣or␣by␣the
C<prefer_makefile>␣option␣you␣can␣pass␣to␣this␣function.

Returns␣the␣installer␣type␣on␣success,␣and␣false␣on␣error.

=cut

sub␣get_installer_type␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$cb␣␣␣=␣$self->parent;
␣␣␣␣my␣$conf␣=␣$cb->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣($prefer_makefile,$verbose);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣prefer_makefile␣=>␣{␣default␣=>␣$conf->get_conf('prefer_makefile'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣=>␣\$prefer_makefile,␣allow␣=>␣BOOLEANS␣},
␣␣␣␣␣␣␣␣verbose␣␣␣␣␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣=>␣\$verbose␣},␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣my␣$type;
␣␣␣␣
␣␣␣␣###␣autobundles␣use␣their␣own␣installer,␣so␣return␣that
␣␣␣␣if(␣$self->is_autobundle␣)␣{
␣␣␣␣␣␣␣␣$type␣=␣INSTALLER_AUTOBUNDLE;␣␣␣␣␣␣␣␣

␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣$extract␣=␣$self->status->extract();
␣␣␣␣␣␣␣␣unless(␣$extract␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Cannot␣determine␣installer␣type␣of␣unextracted␣module␣'%1'",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->module
␣␣␣␣␣␣␣␣␣␣␣␣));
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣
␣␣␣␣␣␣␣␣###␣check␣if␣it's␣a␣makemaker␣or␣a␣module::build␣type␣dist␣###
␣␣␣␣␣␣␣␣my␣$found_build␣␣␣␣␣=␣-e␣BUILD_PL->(␣$extract␣);
␣␣␣␣␣␣␣␣my␣$found_makefile␣␣=␣-e␣MAKEFILE_PL->(␣$extract␣);
␣␣␣␣
␣␣␣␣␣␣␣␣$type␣=␣INSTALLER_BUILD␣if␣!$prefer_makefile␣&&␣␣$found_build;
␣␣␣␣␣␣␣␣$type␣=␣INSTALLER_BUILD␣if␣␣$found_build␣␣␣␣␣&&␣!$found_makefile;
␣␣␣␣␣␣␣␣$type␣=␣INSTALLER_MM␣␣␣␣if␣␣$prefer_makefile␣&&␣␣$found_makefile;
␣␣␣␣␣␣␣␣$type␣=␣INSTALLER_MM␣␣␣␣if␣␣$found_makefile␣␣&&␣!$found_build;
␣␣␣␣}

␣␣␣␣###␣ok,␣so␣it's␣a␣'build'␣installer,␣but␣you␣don't␣/have/␣module␣build
␣␣␣␣###␣XXX␣duplicated␣from␣CPANPLUS::Selfupdate.␣fix␣somehow?
␣␣␣␣if(␣$type␣and␣$type␣eq␣INSTALLER_BUILD␣and␣(
␣␣␣␣␣␣␣␣not␣CPANPLUS::Dist->has_dist_type(␣INSTALLER_BUILD␣)
␣␣␣␣␣␣␣␣or␣not␣$cb->module_tree(␣INSTALLER_BUILD␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣->is_uptodate(␣version␣=>␣'0.24'␣)
␣␣␣␣)␣)␣{
␣␣␣␣
␣␣␣␣␣␣␣␣###␣XXX␣this␣is␣for␣recording␣purposes␣only.␣We␣*have*␣to␣install
␣␣␣␣␣␣␣␣###␣these␣before␣even␣creating␣a␣dist␣object,␣or␣we'll␣get␣an␣error
␣␣␣␣␣␣␣␣###␣saying␣'no␣such␣dist␣type';
␣␣␣␣␣␣␣␣###␣XXX␣duplicated␣from␣CPANPLUS::Selfupdate.␣fix␣somehow?
␣␣␣␣␣␣␣␣my␣$href␣=␣$self->status->configure_requires␣||␣{};
␣␣␣␣␣␣␣␣my␣$deps␣=␣{␣INSTALLER_BUILD,␣'0.24',␣%$href␣};
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣$self->status->configure_requires(␣$deps␣);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣msg(loc("This␣module␣requires␣'%1'␣and␣'%2'␣to␣be␣installed␣first.␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Adding␣these␣modules␣to␣your␣prerequisites␣list",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣'Module::Build',␣INSTALLER_BUILD
␣␣␣␣␣␣␣␣),␣$verbose␣);␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣


␣␣␣␣###␣ok,␣actually␣we␣found␣neither␣###
␣␣␣␣}␣elsif␣(␣!$type␣)␣{
␣␣␣␣␣␣␣␣error(␣loc(␣"Unable␣to␣find␣'%1'␣or␣'%2'␣for␣'%3';␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Will␣default␣to␣'%4'␣but␣might␣be␣unable␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"to␣install!",␣BUILD_PL->(),␣MAKEFILE_PL->(),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->module,␣INSTALLER_MM␣)␣);
␣␣␣␣␣␣␣␣$type␣=␣INSTALLER_MM;
␣␣␣␣}

␣␣␣␣return␣$self->status->installer_type(␣$type␣)␣if␣$type;
␣␣␣␣return;
}

=pod

=head2␣$dist␣=␣$self->dist([target␣=>␣'prepare|create',␣format␣=>␣DISTRIBUTION_TYPE,␣args␣=>␣{key␣=>␣val}]);

Create␣a␣distribution␣object,␣ready␣to␣be␣installed.
Distribution␣type␣defaults␣to␣your␣config␣settings

The␣optional␣C<args>␣hashref␣is␣passed␣on␣to␣the␣specific␣distribution
types'␣C<create>␣method␣after␣being␣dereferenced.

Returns␣a␣distribution␣object␣on␣success,␣false␣on␣failure.

See␣C<CPANPLUS::Dist>␣for␣details.

=cut

sub␣dist␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$cb␣␣␣=␣$self->parent;
␣␣␣␣my␣$conf␣=␣$cb->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣###␣have␣you␣determined␣your␣installer␣type␣yet?␣if␣not,␣do␣it␣here,
␣␣␣␣###␣we␣need␣the␣info
␣␣␣␣$self->get_installer_type␣unless␣$self->status->installer_type;

␣␣␣␣my($type,$args,$target);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣format␣␣=>␣{␣default␣=>␣$conf->get_conf('dist_type')␣||
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->status->installer_type,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣=>␣\$type␣},
␣␣␣␣␣␣␣␣target␣␣=>␣{␣default␣=>␣TARGET_CREATE,␣store␣=>␣\$target␣},␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣args␣␣␣␣=>␣{␣default␣=>␣{},␣store␣=>␣\$args␣},
␣␣␣␣};

␣␣␣␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣###␣ok,␣check␣for␣$type.␣Do␣we␣have␣it?
␣␣␣␣unless(␣CPANPLUS::Dist->has_dist_type(␣$type␣)␣)␣{

␣␣␣␣␣␣␣␣###␣ok,␣we␣don't␣have␣it.␣Is␣it␣C::D::Build?␣if␣so␣we␣can␣install␣the
␣␣␣␣␣␣␣␣###␣whole␣thing␣now
␣␣␣␣␣␣␣␣###␣XXX␣we␣_could_␣do␣this␣for␣any␣type␣we␣dont␣have␣actually...
␣␣␣␣␣␣␣␣if(␣$type␣eq␣INSTALLER_BUILD␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣msg(loc("Bootstrapping␣installer␣'%1'",␣$type));
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣don't␣propagate␣the␣format,␣it's␣the␣one␣we're␣trying␣to
␣␣␣␣␣␣␣␣␣␣␣␣###␣bootstrap,␣so␣it'll␣be␣an␣infinite␣loop␣if␣we␣do
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣$cb->module_tree(␣$type␣)->install(␣target␣=>␣$target,␣%$args␣)␣or
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Could␣not␣bootstrap␣installer␣'%1'␣--␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"can␣not␣continue",␣$type));
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣re-scan␣for␣available␣modules␣now
␣␣␣␣␣␣␣␣␣␣␣␣CPANPLUS::Dist->rescan_dist_types;
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣unless(␣CPANPLUS::Dist->has_dist_type(␣$type␣)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Newly␣installed␣installer␣type␣'%1'␣should␣be␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"available,␣but␣is␣not!␣--␣aborting",␣$type));
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣msg(loc("Installer␣'%1'␣succesfully␣bootstrapped",␣$type));
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣some␣other␣plugin␣you␣dont␣have.␣Abort
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Installer␣type␣'%1'␣not␣found.␣Please␣verify␣your␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"installation␣--␣aborting",␣$type␣));
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣}

␣␣␣␣###␣make␣sure␣we␣don't␣overwrite␣it,␣just␣in␣case␣we␣came␣
␣␣␣␣###␣back␣from␣a␣->save_state.␣This␣allows␣restoration␣to
␣␣␣␣###␣work␣correctly␣␣␣␣
␣␣␣␣my(␣$dist,␣$dist_cpan␣);
␣␣␣␣
␣␣␣␣unless(␣$dist␣=␣$self->status->dist␣)␣{
␣␣␣␣␣␣␣␣$dist␣=␣$type->new(␣module␣=>␣$self␣)␣or␣return;
␣␣␣␣␣␣␣␣$self->status->dist(␣$dist␣);
␣␣␣␣}
␣␣␣␣
␣␣␣␣unless(␣$dist_cpan␣=␣$self->status->dist_cpan␣)␣{
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣$dist_cpan␣=␣$type␣eq␣$self->status->installer_type
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣$self->status->dist
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣$self->status->installer_type->new(␣module␣=>␣$self␣);␣␣␣␣␣␣␣␣␣␣␣


␣␣␣␣␣␣␣␣$self->status->dist_cpan(␣␣␣$dist_cpan␣);
␣␣␣␣}
␣␣␣␣
␣␣␣␣
␣␣␣␣DIST:␣{
␣␣␣␣␣␣␣␣###␣just␣wanted␣the␣$dist␣object?
␣␣␣␣␣␣␣␣last␣DIST␣if␣$target␣eq␣TARGET_INIT;
␣␣␣␣
␣␣␣␣␣␣␣␣###␣first␣prepare␣the␣dist
␣␣␣␣␣␣␣␣$dist->prepare(␣%$args␣)␣or␣return;
␣␣␣␣␣␣␣␣$self->status->prepared(1);

␣␣␣␣␣␣␣␣###␣you␣just␣wanted␣us␣to␣prepare?
␣␣␣␣␣␣␣␣last␣DIST␣if␣$target␣eq␣TARGET_PREPARE;

␣␣␣␣␣␣␣␣$dist->create(␣%$args␣)␣or␣return;
␣␣␣␣␣␣␣␣$self->status->created(1);
␣␣␣␣}

␣␣␣␣return␣$dist;
}

=pod

=head2␣$bool␣=␣$mod->prepare(␣)
␣
Convenience␣method␣around␣C<install()>␣that␣prepares␣a␣module␣
without␣actually␣building␣it.␣This␣is␣equivalent␣to␣invoking␣C<install>
with␣C<target>␣set␣to␣C<prepare>

Returns␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣prepare␣{␣
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣return␣$self->install(␣@_,␣target␣=>␣TARGET_PREPARE␣);
}

=head2␣$bool␣=␣$mod->create(␣)

Convenience␣method␣around␣C<install()>␣that␣creates␣a␣module.␣
This␣is␣equivalent␣to␣invoking␣C<install>␣with␣C<target>␣set␣to␣
C<create>

Returns␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣create␣{␣
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣return␣$self->install(␣@_,␣target␣=>␣TARGET_CREATE␣);
}

=head2␣$bool␣=␣$mod->test(␣)

Convenience␣wrapper␣around␣C<install()>␣that␣tests␣a␣module,␣without
installing␣it.
It's␣the␣equivalent␣to␣invoking␣C<install()>␣with␣C<target>␣set␣to
C<create>␣and␣C<skiptest>␣set␣to␣C<0>.

Returns␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣test␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣return␣$self->install(␣@_,␣target␣=>␣TARGET_CREATE,␣skiptest␣=>␣0␣);
}

=pod

=head2␣$bool␣=␣$self->install([␣target␣=>␣'init|prepare|create|install',␣format␣=>␣FORMAT_TYPE,␣extractdir␣=>␣DIRECTORY,␣fetchdir␣=>␣DIRECTORY,␣prefer_bin␣=>␣BOOL,␣force␣=>␣BOOL,␣verbose␣=>␣BOOL,␣.....␣]);

Installs␣the␣current␣module.␣This␣includes␣fetching␣it␣and␣extracting
it,␣if␣this␣hasn't␣been␣done␣yet,␣as␣well␣as␣creating␣a␣distribution
object␣for␣it.

This␣means␣you␣can␣pass␣it␣more␣arguments␣than␣described␣above,␣which
will␣be␣passed␣on␣to␣the␣relevant␣methods␣as␣they␣are␣called.

See␣C<CPANPLUS::Internals::Fetch>,␣C<CPANPLUS::Internals::Extract>␣and
C<CPANPLUS::Dist>␣for␣details.

Returns␣true␣on␣success,␣false␣on␣failure.

=cut

sub␣install␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$cb␣␣␣=␣$self->parent;
␣␣␣␣my␣$conf␣=␣$cb->configure_object;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$args;␣my␣$target;␣my␣$format;
␣␣␣␣{␣␣␣###␣so␣we␣can␣use␣the␣rest␣of␣the␣args␣to␣the␣create␣calls␣etc␣###
␣␣␣␣␣␣␣␣local␣$Params::Check::NO_DUPLICATES␣=␣1;
␣␣␣␣␣␣␣␣local␣$Params::Check::ALLOW_UNKNOWN␣=␣1;

␣␣␣␣␣␣␣␣###␣targets␣'dist'␣and␣'test'␣are␣now␣completely␣ignored␣###
␣␣␣␣␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣match␣this␣allow␣list␣with␣Dist->_resolve_prereqs
␣␣␣␣␣␣␣␣␣␣␣␣target␣␣␣␣␣=>␣{␣default␣=>␣TARGET_INSTALL,␣store␣=>␣\$target,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣allow␣␣␣=>␣[TARGET_PREPARE,␣TARGET_CREATE,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣TARGET_INSTALL,␣TARGET_INIT␣]␣},
␣␣␣␣␣␣␣␣␣␣␣␣force␣␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('force'),␣},
␣␣␣␣␣␣␣␣␣␣␣␣verbose␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),␣},
␣␣␣␣␣␣␣␣␣␣␣␣format␣␣␣␣␣=>␣{␣default␣=>␣$conf->get_conf('dist_type'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$format␣},
␣␣␣␣␣␣␣␣};

␣␣␣␣␣␣␣␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;
␣␣␣␣}


␣␣␣␣###␣if␣this␣target␣isn't␣'install',␣we␣will␣need␣to␣at␣least␣'create'␣
␣␣␣␣###␣every␣prereq,␣so␣it␣can␣build
␣␣␣␣###␣XXX␣prereq_target␣of␣'prepare'␣will␣do␣weird␣things␣here,␣and␣is
␣␣␣␣###␣not␣supported.
␣␣␣␣$args->{'prereq_target'}␣||=␣TARGET_CREATE␣if␣$target␣ne␣TARGET_INSTALL;

␣␣␣␣###␣check␣if␣it's␣already␣upto␣date␣###
␣␣␣␣if(␣$target␣eq␣TARGET_INSTALL␣and␣!$args->{'force'}␣and
␣␣␣␣␣␣␣␣!$self->package_is_perl_core()␣and␣␣␣␣␣␣␣␣␣#␣separate␣rules␣apply
␣␣␣␣␣␣␣␣(␣$self->status->installed()␣or␣$self->is_uptodate␣)␣and
␣␣␣␣␣␣␣␣!INSTALL_VIA_PACKAGE_MANAGER->($format)
␣␣␣␣)␣{
␣␣␣␣␣␣␣␣msg(loc("Module␣'%1'␣already␣up␣to␣date,␣won't␣install␣without␣force",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->module),␣$args->{'verbose'}␣);
␣␣␣␣␣␣␣␣return␣$self->status->installed(1);
␣␣␣␣}

␣␣␣␣#␣if␣it's␣a␣non-installable␣core␣package,␣abort␣the␣install.
␣␣␣␣if(␣$self->package_is_perl_core()␣)␣{
␣␣␣␣␣␣␣␣#␣if␣the␣installed␣is␣newer,␣say␣so.
␣␣␣␣␣␣␣␣if(␣$self->installed_version␣>␣$self->version␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("The␣core␣Perl␣%1␣module␣'%2'␣(%3)␣is␣more␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"recent␣than␣the␣latest␣release␣on␣CPAN␣(%4).␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Aborting␣install.",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$],␣$self->module,␣$self->installed_version,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->version␣)␣);
␣␣␣␣␣␣␣␣#␣if␣the␣installed␣matches,␣say␣so.
␣␣␣␣␣␣␣␣}␣elsif(␣$self->installed_version␣==␣$self->version␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("The␣core␣Perl␣%1␣module␣'%2'␣(%3)␣can␣only␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"be␣installed␣by␣Perl␣itself.␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Aborting␣install.",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$],␣$self->module,␣$self->installed_version␣)␣);
␣␣␣␣␣␣␣␣#␣otherwise,␣the␣installed␣is␣older;␣say␣so.
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("The␣core␣Perl␣%1␣module␣'%2'␣can␣only␣be␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"upgraded␣from␣%3␣to␣%4␣by␣Perl␣itself␣(%5).␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Aborting␣install.",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$],␣$self->module,␣$self->installed_version,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->version,␣$self->package␣)␣);
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣return;
␣␣␣␣
␣␣␣␣###␣it␣might␣be␣a␣known␣3rd␣party␣module
␣␣␣␣}␣elsif␣(␣$self->is_third_party␣)␣{
␣␣␣␣␣␣␣␣my␣$info␣=␣$self->third_party_information;
␣␣␣␣␣␣␣␣error(loc(
␣␣␣␣␣␣␣␣␣␣␣␣"%1␣is␣a␣known␣third-party␣module.\n\n".
␣␣␣␣␣␣␣␣␣␣␣␣"As␣it␣isn't␣available␣on␣the␣CPAN,␣CPANPLUS␣can't␣install␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣"it␣automatically.␣Therefore␣you␣need␣to␣install␣it␣manually␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣"before␣proceeding.\n\n".
␣␣␣␣␣␣␣␣␣␣␣␣"%2␣is␣part␣of␣%3,␣published␣by␣%4,␣and␣should␣be␣available␣".
␣␣␣␣␣␣␣␣␣␣␣␣"for␣download␣at␣the␣following␣address:\n\t%5",
␣␣␣␣␣␣␣␣␣␣␣␣$self->name,␣$self->name,␣$info->{name},␣$info->{author},
␣␣␣␣␣␣␣␣␣␣␣␣$info->{url}
␣␣␣␣␣␣␣␣));
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣###␣fetch␣it␣if␣need␣be␣###
␣␣␣␣unless(␣$self->status->fetch␣)␣{
␣␣␣␣␣␣␣␣my␣$params;
␣␣␣␣␣␣␣␣for␣(qw[prefer_bin␣fetchdir])␣{
␣␣␣␣␣␣␣␣␣␣␣␣$params->{$_}␣=␣$args->{$_}␣if␣exists␣$args->{$_};
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣for␣(qw[force␣verbose])␣{
␣␣␣␣␣␣␣␣␣␣␣␣$params->{$_}␣=␣$args->{$_}␣if␣defined␣$args->{$_};
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$self->fetch(␣%$params␣)␣or␣return;
␣␣␣␣}

␣␣␣␣###␣extract␣it␣if␣need␣be␣###
␣␣␣␣unless(␣$self->status->extract␣)␣{
␣␣␣␣␣␣␣␣my␣$params;
␣␣␣␣␣␣␣␣for␣(qw[prefer_bin␣extractdir])␣{
␣␣␣␣␣␣␣␣␣␣␣␣$params->{$_}␣=␣$args->{$_}␣if␣exists␣$args->{$_};
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣for␣(qw[force␣verbose])␣{
␣␣␣␣␣␣␣␣␣␣␣␣$params->{$_}␣=␣$args->{$_}␣if␣defined␣$args->{$_};
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$self->extract(␣%$params␣)␣or␣return;
␣␣␣␣}

␣␣␣␣$format␣||=␣$self->status->installer_type;

␣␣␣␣unless(␣$format␣)␣{
␣␣␣␣␣␣␣␣error(␣loc(␣"Don't␣know␣what␣installer␣to␣use;␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Couldn't␣find␣either␣'%1'␣or␣'%2'␣in␣the␣extraction␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"directory␣'%3'␣--␣will␣be␣unable␣to␣install",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣BUILD_PL->(),␣MAKEFILE_PL->(),␣$self->status->extract␣)␣);

␣␣␣␣␣␣␣␣$self->status->installed(0);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}


␣␣␣␣###␣do␣SIGNATURE␣checks?␣###
␣␣␣␣###␣XXX␣check␣status␣and␣not␣recheck␣EVERY␣time?
␣␣␣␣if(␣$conf->get_conf('signature')␣)␣{
␣␣␣␣␣␣␣␣unless(␣$self->check_signature(␣verbose␣=>␣$args->{verbose}␣)␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(␣loc(␣"Signature␣check␣failed␣for␣module␣'%1'␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"--␣Not␣trusting␣this␣module,␣aborting␣install",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->module␣)␣);
␣␣␣␣␣␣␣␣␣␣␣␣$self->status->signature(0);
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣send␣out␣test␣report␣on␣broken␣sig
␣␣␣␣␣␣␣␣␣␣␣␣if(␣$conf->get_conf('cpantest')␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$cb->_send_report(␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣module␣␣=>␣$self,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣failed␣␣=>␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣buffer␣␣=>␣CPANPLUS::Error->stack_as_string,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣$args->{verbose},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣force␣␣␣=>␣$args->{force},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣or␣error(loc("Failed␣to␣send␣test␣report␣for␣'%1'",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->module␣)␣);
␣␣␣␣␣␣␣␣␣␣␣␣}␣␣
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣return;

␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣###␣signature␣OK␣###
␣␣␣␣␣␣␣␣␣␣␣␣$self->status->signature(1);
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣###␣a␣target␣of␣'create'␣basically␣means␣not␣to␣run␣make␣test␣###
␣␣␣␣###␣eh,␣no␣it␣/doesn't/..␣skiptest␣=>␣1␣means␣skiptest␣=>␣1.
␣␣␣␣#$args->{'skiptest'}␣=␣1␣if␣$target␣eq␣'create';

␣␣␣␣###␣bundle␣rules␣apply␣###
␣␣␣␣if(␣$self->is_bundle␣)␣{
␣␣␣␣␣␣␣␣###␣check␣what␣we␣need␣to␣install␣###
␣␣␣␣␣␣␣␣my␣@prereqs␣=␣$self->bundle_modules();
␣␣␣␣␣␣␣␣unless(␣@prereqs␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(␣loc(␣"Bundle␣'%1'␣does␣not␣specify␣any␣modules␣to␣install",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->module␣)␣);

␣␣␣␣␣␣␣␣␣␣␣␣###␣XXX␣mark␣an␣error␣here?␣###
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣my␣$dist␣=␣$self->dist(␣format␣␣=>␣$format,␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣target␣␣=>␣$target,␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣args␣␣␣␣=>␣$args␣);
␣␣␣␣unless(␣$dist␣)␣{
␣␣␣␣␣␣␣␣error(␣loc(␣"Unable␣to␣create␣a␣new␣distribution␣object␣for␣'%1'␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"--␣cannot␣continue",␣$self->module␣)␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣return␣1␣if␣$target␣ne␣TARGET_INSTALL;

␣␣␣␣my␣$ok␣=␣$dist->install(␣%$args␣)␣?␣1␣:␣0;

␣␣␣␣$self->status->installed($ok);

␣␣␣␣return␣1␣if␣$ok;
␣␣␣␣return;
}

=pod␣@list␣=␣$self->bundle_modules()

Returns␣a␣list␣of␣module␣objects␣the␣Bundle␣specifies.

This␣requires␣you␣to␣have␣extracted␣the␣bundle␣already,␣using␣the
C<extract()>␣method.

Returns␣false␣on␣error.

=cut

sub␣bundle_modules␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$cb␣␣␣=␣$self->parent;

␣␣␣␣unless(␣$self->is_bundle␣)␣{
␣␣␣␣␣␣␣␣error(␣loc("'%1'␣is␣not␣a␣bundle",␣$self->module␣)␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣my␣@files;
␣␣␣␣
␣␣␣␣###␣autobundles␣are␣special␣files␣generated␣by␣CPANPLUS.␣If␣we␣can
␣␣␣␣###␣read␣the␣file,␣we␣can␣determine␣the␣prereqs
␣␣␣␣if(␣$self->is_autobundle␣)␣{
␣␣␣␣␣␣␣␣my␣$where;
␣␣␣␣␣␣␣␣unless(␣$where␣=␣$self->status->fetch␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Don't␣know␣where␣'%1'␣was␣fetched␣to",␣$self->package));
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣push␣@files,␣$where
␣␣␣␣
␣␣␣␣###␣regular␣bundle::*␣upload
␣␣␣␣}␣else␣{␣␣␣␣
␣␣␣␣␣␣␣␣my␣$dir;
␣␣␣␣␣␣␣␣unless(␣$dir␣=␣$self->status->extract␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Don't␣know␣where␣'%1'␣was␣extracted␣to",␣$self->module));
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣find(␣{
␣␣␣␣␣␣␣␣␣␣␣␣wanted␣␣␣=>␣sub␣{␣push␣@files,␣File::Spec->rel2abs($_)␣if␣/\.pm/i␣},
␣␣␣␣␣␣␣␣␣␣␣␣no_chdir␣=>␣1,
␣␣␣␣␣␣␣␣},␣$dir␣);
␣␣␣␣}

␣␣␣␣my␣$prereqs␣=␣{};␣my␣@list;␣my␣$seen␣=␣{};
␣␣␣␣for␣my␣$file␣(␣@files␣)␣{
␣␣␣␣␣␣␣␣my␣$fh␣=␣FileHandle->new($file)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣or(␣error(loc("Could␣not␣open␣'%1'␣for␣reading:␣%2",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$file,$!)),␣next␣);

␣␣␣␣␣␣␣␣my␣$flag;
␣␣␣␣␣␣␣␣while(␣local␣$_␣=␣<$fh>␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣###␣quick␣hack␣to␣read␣past␣the␣header␣of␣the␣file␣###
␣␣␣␣␣␣␣␣␣␣␣␣last␣if␣$flag␣&&␣m|^=head|i;

␣␣␣␣␣␣␣␣␣␣␣␣###␣from␣perldoc␣cpan:
␣␣␣␣␣␣␣␣␣␣␣␣###␣=head1␣CONTENTS
␣␣␣␣␣␣␣␣␣␣␣␣###␣In␣this␣pod␣section␣each␣line␣obeys␣the␣format
␣␣␣␣␣␣␣␣␣␣␣␣###␣Module_Name␣[Version_String]␣[-␣optional␣text]
␣␣␣␣␣␣␣␣␣␣␣␣$flag␣=␣1␣if␣m|^=head1␣CONTENTS|i;

␣␣␣␣␣␣␣␣␣␣␣␣if␣($flag␣&&␣/^(?!=)(\S+)\s*(\S+)?/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$module␣␣=␣$1;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$version␣=␣$cb->_version_to_number(␣version␣=>␣$2␣);

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$obj␣=␣$cb->module_tree($module);

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣unless(␣$obj␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Cannot␣find␣bundled␣module␣'%1'",␣$module),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣loc("--␣it␣does␣not␣seem␣to␣exist")␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣make␣sure␣we␣list␣no␣duplicates␣###
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣unless(␣$seen->{␣$obj->module␣}++␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@list,␣$obj;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$prereqs->{␣$module␣}␣=
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$cb->_version_to_number(␣version␣=>␣$version␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣###␣store␣the␣prereqs␣we␣just␣found␣###
␣␣␣␣$self->status->prereqs(␣$prereqs␣);

␣␣␣␣return␣@list;
}

=pod

=head2␣$text␣=␣$self->readme

Fetches␣the␣readme␣belonging␣to␣this␣module␣and␣stores␣it␣under
C<<␣$obj->status->readme␣>>.␣Returns␣the␣readme␣as␣a␣string␣on
success␣and␣returns␣false␣on␣failure.

=cut

sub␣readme␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->parent->configure_object;␣␣␣␣

␣␣␣␣###␣did␣we␣already␣dl␣the␣readme␣once?␣###
␣␣␣␣return␣$self->status->readme()␣if␣$self->status->readme();

␣␣␣␣###␣this␣should␣be␣core␣###
␣␣␣␣return␣unless␣can_load(␣modules␣␣␣␣␣=>␣{␣FileHandle␣=>␣'0.0'␣},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣###␣get␣a␣clone␣of␣the␣current␣object,␣with␣a␣fresh␣status␣###
␣␣␣␣my␣$obj␣␣=␣$self->clone␣or␣return;

␣␣␣␣###␣munge␣the␣package␣name
␣␣␣␣my␣$pkg␣=␣README->(␣$obj␣);
␣␣␣␣$obj->package($pkg);

␣␣␣␣my␣$file;
␣␣␣␣{␣␣␣###␣disable␣checksum␣fetches␣on␣readme␣downloads
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my␣$tmp␣=␣$conf->get_conf(␣'md5'␣);
␣␣␣␣␣␣␣␣$conf->set_conf(␣md5␣=>␣0␣);
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣$file␣=␣$obj->fetch;

␣␣␣␣␣␣␣␣$conf->set_conf(␣md5␣=>␣$tmp␣);

␣␣␣␣␣␣␣␣return␣unless␣$file;
␣␣␣␣}

␣␣␣␣###␣read␣the␣file␣into␣a␣scalar,␣to␣store␣in␣the␣original␣object␣###
␣␣␣␣my␣$fh␣=␣new␣FileHandle;
␣␣␣␣unless(␣$fh->open($file)␣)␣{
␣␣␣␣␣␣␣␣error(␣loc(␣"Could␣not␣open␣file␣'%1':␣%2",␣$file,␣$!␣)␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣my␣$in␣=␣do{␣local␣$/;␣<$fh>␣};
␣␣␣␣$fh->close;

␣␣␣␣return␣$self->status->readme(␣$in␣);
}

=pod

=head2␣$version␣=␣$self->installed_version()

Returns␣the␣currently␣installed␣version␣of␣this␣module,␣if␣any.

=head2␣$where␣=␣$self->installed_file()

Returns␣the␣location␣of␣the␣currently␣installed␣file␣of␣this␣module,
if␣any.

=head2␣$dir␣=␣$self->installed_dir()

Returns␣the␣directory␣(or␣more␣accurately,␣the␣C<@INC>␣handle)␣from
which␣this␣module␣was␣loaded,␣if␣any.

=head2␣$bool␣=␣$self->is_uptodate([version␣=>␣VERSION_NUMBER])

Returns␣a␣boolean␣indicating␣if␣this␣module␣is␣uptodate␣or␣not.

=cut

###␣uptodate/installed␣functions
{␣␣␣my␣$map␣=␣{␣␣␣␣␣␣␣␣␣␣␣␣␣#␣hashkey,␣␣␣␣␣␣alternate␣rv
␣␣␣␣␣␣␣␣installed_version␣␣␣=>␣['version',␣␣0␣],
␣␣␣␣␣␣␣␣installed_file␣␣␣␣␣␣=>␣['file',␣␣␣␣␣''],
␣␣␣␣␣␣␣␣installed_dir␣␣␣␣␣␣␣=>␣['dir',␣␣␣␣␣␣''],
␣␣␣␣␣␣␣␣is_uptodate␣␣␣␣␣␣␣␣␣=>␣['uptodate',␣0␣],
␣␣␣␣};

␣␣␣␣while(␣my($method,␣$aref)␣=␣each␣%$map␣)␣{
␣␣␣␣␣␣␣␣my($key,$alt_rv)␣=␣@$aref;

␣␣␣␣␣␣␣␣no␣strict␣'refs';
␣␣␣␣␣␣␣␣*$method␣=␣sub␣{
␣␣␣␣␣␣␣␣␣␣␣␣###␣never␣use␣the␣@INC␣hooks␣to␣find␣installed␣versions␣of
␣␣␣␣␣␣␣␣␣␣␣␣###␣modules␣--␣they're␣just␣there␣in␣case␣they're␣not␣on␣the
␣␣␣␣␣␣␣␣␣␣␣␣###␣perl␣install,␣but␣the␣user␣shouldn't␣trust␣them␣for␣*other*
␣␣␣␣␣␣␣␣␣␣␣␣###␣modules!
␣␣␣␣␣␣␣␣␣␣␣␣###␣XXX␣CPANPLUS::inc␣is␣now␣obsolete,␣so␣this␣should␣not
␣␣␣␣␣␣␣␣␣␣␣␣###␣be␣needed␣anymore
␣␣␣␣␣␣␣␣␣␣␣␣#local␣@INC␣=␣CPANPLUS::inc->original_inc;

␣␣␣␣␣␣␣␣␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣###␣make␣sure␣check_install␣is␣not␣looking␣in␣%INC,␣as
␣␣␣␣␣␣␣␣␣␣␣␣###␣that␣may␣contain␣some␣of␣our␣sneakily␣loaded␣modules
␣␣␣␣␣␣␣␣␣␣␣␣###␣that␣aren't␣installed␣as␣such.␣--␣kane
␣␣␣␣␣␣␣␣␣␣␣␣local␣$Module::Load::Conditional::CHECK_INC_HASH␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣###␣this␣should␣all␣that␣is␣required␣for␣deprecated␣core␣modules
␣␣␣␣␣␣␣␣␣␣␣␣local␣$Module::Load::Conditional::DEPRECATED␣=␣1;
␣␣␣␣␣␣␣␣␣␣␣␣my␣$href␣=␣check_install(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣module␣␣=>␣$self->module,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣version␣=>␣$self->version,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣@_,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣␣␣␣␣␣␣␣␣return␣$href->{$key}␣||␣$alt_rv;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
}



=pod

=head2␣$href␣=␣$self->details()

Returns␣a␣hashref␣with␣key/value␣pairs␣offering␣more␣information␣about
a␣particular␣module.␣For␣example,␣for␣C<Time::HiRes>␣it␣might␣look␣like
this:

␣␣␣␣Author␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣Jarkko␣Hietaniemi␣(jhi@iki.fi)
␣␣␣␣Description␣␣␣␣␣␣␣␣␣␣␣␣␣High␣resolution␣time,␣sleep,␣and␣alarm
␣␣␣␣Development␣Stage␣␣␣␣␣␣␣Released
␣␣␣␣Installed␣File␣␣␣␣␣␣␣␣␣␣/usr/local/perl/lib/Time/Hires.pm
␣␣␣␣Interface␣Style␣␣␣␣␣␣␣␣␣plain␣Functions,␣no␣references␣used
␣␣␣␣Language␣Used␣␣␣␣␣␣␣␣␣␣␣C␣and␣perl,␣a␣C␣compiler␣will␣be␣needed
␣␣␣␣Package␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣Time-HiRes-1.65.tar.gz
␣␣␣␣Public␣License␣␣␣␣␣␣␣␣␣␣Unknown
␣␣␣␣Support␣Level␣␣␣␣␣␣␣␣␣␣␣Developer
␣␣␣␣Version␣Installed␣␣␣␣␣␣␣1.52
␣␣␣␣Version␣on␣CPAN␣␣␣␣␣␣␣␣␣1.65

=cut

sub␣details␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->parent->configure_object();
␣␣␣␣my␣$cb␣␣␣=␣$self->parent;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣$res␣=␣{
␣␣␣␣␣␣␣␣Author␣␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣loc("%1␣(%2)",␣␣␣$self->author->author(),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->author->email()␣),
␣␣␣␣␣␣␣␣Package␣␣␣␣␣␣␣␣␣␣␣␣␣=>␣$self->package,
␣␣␣␣␣␣␣␣Description␣␣␣␣␣␣␣␣␣=>␣$self->description␣␣␣␣␣||␣loc('None␣given'),
␣␣␣␣␣␣␣␣'Version␣on␣CPAN'␣␣␣=>␣$self->version,
␣␣␣␣};

␣␣␣␣###␣check␣if␣we␣have␣the␣module␣installed
␣␣␣␣###␣if␣so,␣add␣version␣have␣and␣version␣on␣cpan
␣␣␣␣$res->{'Version␣Installed'}␣=␣$self->installed_version
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣$self->installed_version;
␣␣␣␣$res->{'Installed␣File'}␣=␣$self->installed_file␣if␣$self->installed_file;

␣␣␣␣my␣$i␣=␣0;
␣␣␣␣for␣my␣$item(␣split␣'',␣$self->dslip␣)␣{
␣␣␣␣␣␣␣␣$res->{␣$cb->_dslip_defs->[$i]->[0]␣}␣=
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$cb->_dslip_defs->[$i]->[1]->{$item}␣||␣loc('Unknown');
␣␣␣␣␣␣␣␣$i++;
␣␣␣␣}

␣␣␣␣return␣$res;
}

=head2␣@list␣=␣$self->contains()

Returns␣a␣list␣of␣module␣objects␣that␣represent␣the␣modules␣also␣
present␣in␣the␣package␣of␣this␣module.

For␣example,␣for␣C<Archive::Tar>␣this␣might␣return:

␣␣␣␣Archive::Tar
␣␣␣␣Archive::Tar::Constant
␣␣␣␣Archive::Tar::File

=cut

sub␣contains␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$cb␣␣␣=␣$self->parent;
␣␣␣␣my␣$pkg␣␣=␣$self->package;

␣␣␣␣my␣@mods␣=␣$cb->search(␣type␣=>␣'package',␣allow␣=>␣[qr/^$pkg$/]␣);
␣␣␣␣
␣␣␣␣return␣@mods;
}

=pod

=head2␣@list_of_hrefs␣=␣$self->fetch_report()

This␣function␣queries␣the␣CPAN␣testers␣database␣at
I<http://testers.cpan.org/>␣for␣test␣results␣of␣specified␣module
objects,␣module␣names␣or␣distributions.

Look␣at␣L<CPANPLUS::Internals::Report::_query_report()>␣for␣details␣on
the␣options␣you␣can␣pass␣and␣the␣return␣value␣to␣expect.

=cut

sub␣fetch_report␣{
␣␣␣␣my␣$self␣␣␣␣=␣shift;
␣␣␣␣my␣$cb␣␣␣␣␣␣=␣$self->parent;

␣␣␣␣return␣$cb->_query_report(␣@_,␣module␣=>␣$self␣);
}

=pod

=head2␣$bool␣=␣$self->uninstall([type␣=>␣[all|man|prog])

This␣function␣uninstalls␣the␣specified␣module␣object.

You␣can␣install␣2␣types␣of␣files,␣either␣C<man>␣pages␣or␣C<prog>ram
files.␣Alternately␣you␣can␣specify␣C<all>␣to␣uninstall␣both␣(which
is␣the␣default).

Returns␣true␣on␣success␣and␣false␣on␣failure.

Do␣note␣that␣this␣does␣an␣uninstall␣via␣the␣so-called␣C<.packlist>,
so␣if␣you␣used␣a␣module␣installer␣like␣say,␣C<ports>␣or␣C<apt>,␣you
should␣not␣use␣this,␣but␣use␣your␣package␣manager␣instead.

=cut

sub␣uninstall␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$conf␣=␣$self->parent->configure_object();
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣($type,$verbose);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣type␣␣␣␣=>␣{␣default␣=>␣'all',␣allow␣=>␣[qw|man␣prog␣all|],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$type␣},
␣␣␣␣␣␣␣␣verbose␣=>␣{␣default␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣=>␣\$verbose␣},
␣␣␣␣␣␣␣␣force␣␣␣=>␣{␣default␣=>␣$conf->get_conf('force')␣},
␣␣␣␣};

␣␣␣␣###␣XXX␣add␣a␣warning␣here␣if␣your␣default␣install␣dist␣isn't
␣␣␣␣###␣makefile␣or␣build␣--␣that␣means␣you␣are␣using␣a␣package␣manager
␣␣␣␣###␣and␣this␣will␣not␣do␣what␣you␣think!

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣if(␣$conf->get_conf('dist_type')␣and␣(
␣␣␣␣␣␣␣␣($conf->get_conf('dist_type')␣ne␣INSTALLER_BUILD)␣or
␣␣␣␣␣␣␣␣($conf->get_conf('dist_type')␣ne␣INSTALLER_MM))
␣␣␣␣)␣{
␣␣␣␣␣␣␣␣msg(loc("You␣have␣a␣default␣installer␣type␣set␣(%1)␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"--␣you␣should␣probably␣use␣that␣package␣manager␣to␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"uninstall␣modules",␣$conf->get_conf('dist_type')),␣$verbose);
␣␣␣␣}

␣␣␣␣###␣check␣if␣we␣even␣have␣the␣module␣installed␣--␣no␣point␣in␣continuing
␣␣␣␣###␣otherwise
␣␣␣␣unless(␣$self->installed_version␣)␣{
␣␣␣␣␣␣␣␣error(␣loc(␣"Module␣'%1'␣is␣not␣installed,␣so␣cannot␣uninstall",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->module␣)␣);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣nothing␣to␣uninstall␣###
␣␣␣␣my␣$files␣␣␣=␣$self->files(␣type␣=>␣$type␣)␣␣␣␣␣␣␣␣␣␣␣␣␣or␣return;
␣␣␣␣my␣$dirs␣␣␣␣=␣$self->directory_tree(␣type␣=>␣$type␣)␣␣␣␣or␣return;
␣␣␣␣my␣$sudo␣␣␣␣=␣$conf->get_program('sudo');

␣␣␣␣###␣just␣in␣case␣there's␣no␣file;␣M::B␣doensn't␣provide␣.packlists␣yet␣###
␣␣␣␣my␣$pack␣␣␣␣=␣$self->packlist;
␣␣␣␣$pack␣␣␣␣␣␣␣=␣$pack->[0]->packlist_file()␣if␣$pack;

␣␣␣␣###␣first␣remove␣the␣files,␣then␣the␣dirs␣if␣they␣are␣empty␣###
␣␣␣␣my␣$flag␣=␣0;
␣␣␣␣for␣my␣$file(␣@$files,␣$pack␣)␣{
␣␣␣␣␣␣␣␣next␣unless␣defined␣$file␣&&␣-f␣$file;

␣␣␣␣␣␣␣␣msg(loc("Unlinking␣'%1'",␣$file),␣$verbose);

␣␣␣␣␣␣␣␣my␣@cmd␣=␣($^X,␣"-eunlink+q[$file]");
␣␣␣␣␣␣␣␣unshift␣@cmd,␣$sudo␣if␣$sudo;

␣␣␣␣␣␣␣␣my␣$buffer;
␣␣␣␣␣␣␣␣unless␣(␣run(␣␣␣command␣=>␣\@cmd,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣$verbose,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣buffer␣␣=>␣\$buffer␣)
␣␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Failed␣to␣unlink␣'%1':␣'%2'",$file,␣$buffer));
␣␣␣␣␣␣␣␣␣␣␣␣$flag++;
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣for␣my␣$dir␣(␣sort␣@$dirs␣)␣{
␣␣␣␣␣␣␣␣local␣*DIR;
␣␣␣␣␣␣␣␣opendir␣DIR,␣$dir␣or␣next;
␣␣␣␣␣␣␣␣my␣@count␣=␣readdir(DIR);
␣␣␣␣␣␣␣␣close␣DIR;

␣␣␣␣␣␣␣␣next␣unless␣@count␣==␣2;␣␣␣␣#␣.␣and␣..

␣␣␣␣␣␣␣␣msg(loc("Removing␣'%1'",␣$dir),␣$verbose);

␣␣␣␣␣␣␣␣###␣this␣fails␣on␣my␣win2k␣machines..␣it␣indeed␣leaves␣the
␣␣␣␣␣␣␣␣###␣dir,␣but␣it's␣not␣a␣critical␣error,␣since␣the␣files␣have
␣␣␣␣␣␣␣␣###␣been␣removed.␣--kane
␣␣␣␣␣␣␣␣#unless(␣rmdir␣$dir␣)␣{
␣␣␣␣␣␣␣␣#␣␣␣␣error(␣loc(␣"Could␣not␣remove␣'%1':␣%2",␣$dir,␣$!␣)␣)
␣␣␣␣␣␣␣␣#␣␣␣␣␣␣␣␣unless␣$^O␣eq␣'MSWin32';
␣␣␣␣␣␣␣␣#}
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my␣@cmd␣=␣($^X,␣"-e",␣"rmdir␣q[$dir]");
␣␣␣␣␣␣␣␣unshift␣@cmd,␣$sudo␣if␣$sudo;
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣my␣$buffer;
␣␣␣␣␣␣␣␣unless␣(␣run(␣␣␣command␣=>␣\@cmd,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣=>␣$verbose,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣buffer␣␣=>␣\$buffer␣)
␣␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣error(loc("Failed␣to␣rmdir␣'%1':␣%2",$dir,$buffer));
␣␣␣␣␣␣␣␣␣␣␣␣$flag++;
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣$self->status->uninstall(!$flag);
␣␣␣␣$self->status->installed(␣$flag␣?␣1␣:␣undef);

␣␣␣␣return␣!$flag;
}

=pod

=head2␣@modobj␣=␣$self->distributions()

Returns␣a␣list␣of␣module␣objects␣representing␣all␣releases␣for␣this
module␣on␣success,␣false␣on␣failure.

=cut

sub␣distributions␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣@list␣=␣$self->author->distributions(␣%hash,␣module␣=>␣$self␣)␣or␣return;

␣␣␣␣###␣it's␣another␣release␣then␣by␣the␣same␣author␣###
␣␣␣␣return␣grep␣{␣$_->package_name␣eq␣$self->package_name␣}␣@list;
}

=pod

=head2␣@list␣=␣$self->files␣()

Returns␣a␣list␣of␣files␣used␣by␣this␣module,␣if␣it␣is␣installed.

=head2␣@list␣=␣$self->directory_tree␣()

Returns␣a␣list␣of␣directories␣used␣by␣this␣module.

=head2␣@list␣=␣$self->packlist␣()

Returns␣the␣C<ExtUtils::Packlist>␣object␣for␣this␣module.

=head2␣@list␣=␣$self->validate␣()

Returns␣a␣list␣of␣files␣that␣are␣missing␣for␣this␣modules,␣but
are␣present␣in␣the␣.packlist␣file.

=cut

for␣my␣$sub␣(qw[files␣directory_tree␣packlist␣validate])␣{
␣␣␣␣no␣strict␣'refs';
␣␣␣␣*$sub␣=␣sub␣{
␣␣␣␣␣␣␣␣return␣shift->_extutils_installed(␣@_,␣method␣=>␣$sub␣);
␣␣␣␣}
}

###␣generic␣method␣to␣call␣an␣ExtUtils::Installed␣method␣###
sub␣_extutils_installed␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$cb␣␣␣=␣$self->parent;
␣␣␣␣my␣$conf␣=␣$cb->configure_object;
␣␣␣␣my␣$home␣=␣$cb->_home_dir;␣␣␣␣␣␣␣␣␣␣#␣may␣be␣needed␣to␣fix␣up␣prefixes
␣␣␣␣my␣%hash␣=␣@_;

␣␣␣␣my␣($verbose,$type,$method);
␣␣␣␣my␣$tmpl␣=␣{
␣␣␣␣␣␣␣␣verbose␣=>␣{␣␣␣␣default␣␣␣␣␣=>␣$conf->get_conf('verbose'),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣␣=>␣\$verbose,␣},
␣␣␣␣␣␣␣␣type␣␣␣␣=>␣{␣␣␣␣default␣␣␣␣␣=>␣'all',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣allow␣␣␣␣␣␣␣=>␣[qw|prog␣man␣all|],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣␣=>␣\$type,␣},
␣␣␣␣␣␣␣␣method␣␣=>␣{␣␣␣␣required␣␣␣␣=>␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣store␣␣␣␣␣␣␣=>␣\$method,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣allow␣␣␣␣␣␣␣=>␣[qw|files␣directory_tree␣packlist
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣validate|],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣},
␣␣␣␣};

␣␣␣␣my␣$args␣=␣check(␣$tmpl,␣\%hash␣)␣or␣return;

␣␣␣␣###␣old␣versions␣of␣cygwin␣+␣perl␣<␣5.8␣are␣buggy␣here.␣bail␣out␣if␣we
␣␣␣␣###␣find␣we're␣being␣used␣by␣them
␣␣␣␣{␣␣␣my␣$err␣=␣ON_OLD_CYGWIN;
␣␣␣␣␣␣␣␣if($err)␣{␣error($err);␣return␣};
␣␣␣␣}

␣␣␣␣return␣unless␣can_load(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣modules␣␣␣␣␣=>␣{␣'ExtUtils::Installed'␣=>␣'0.0'␣},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣verbose␣␣␣␣␣=>␣$verbose,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣my␣@config_names␣=␣(
␣␣␣␣␣␣␣␣###␣lib
␣␣␣␣␣␣␣␣{␣␣␣lib␣␣␣␣␣=>␣'privlib',␣␣␣␣␣␣␣#␣perl-only
␣␣␣␣␣␣␣␣␣␣␣␣arch␣␣␣␣=>␣'archlib',␣␣␣␣␣␣␣#␣compiled␣code
␣␣␣␣␣␣␣␣␣␣␣␣prefix␣␣=>␣'prefix',␣␣␣␣␣␣␣␣#␣prefix␣to␣both
␣␣␣␣␣␣␣␣},
␣␣␣␣␣␣␣␣###␣site
␣␣␣␣␣␣␣␣{␣␣␣lib␣␣␣␣␣␣=>␣'sitelib',
␣␣␣␣␣␣␣␣␣␣␣␣arch␣␣␣␣␣=>␣'sitearch',
␣␣␣␣␣␣␣␣␣␣␣␣prefix␣␣␣=>␣'siteprefix',
␣␣␣␣␣␣␣␣},
␣␣␣␣␣␣␣␣###␣vendor
␣␣␣␣␣␣␣␣{␣␣␣lib␣␣␣␣␣=>␣'vendorlib',
␣␣␣␣␣␣␣␣␣␣␣␣arch␣␣␣␣=>␣'vendorarch',
␣␣␣␣␣␣␣␣␣␣␣␣prefix␣␣=>␣'vendorprefix',
␣␣␣␣␣␣␣␣},
␣␣␣␣);

␣␣␣␣###␣search␣in␣your␣regular␣@INC,␣and␣anything␣you␣added␣to␣your␣config.
␣␣␣␣###␣this␣lets␣EU::Installed␣find␣.packlists␣that␣are␣*not*␣in␣the␣standard
␣␣␣␣###␣compiled␣in␣@INC␣path.␣Requires␣EU::I␣1.42␣or␣up.␣this␣addresses␣#33438
␣␣␣␣###␣make␣sure␣the␣archname␣path␣is␣also␣added,␣as␣that's␣where␣the␣.packlist
␣␣␣␣###␣files␣are␣written
␣␣␣␣my␣@libs;
␣␣␣␣for␣my␣$lib␣(␣@{␣$conf->get_conf('lib')␣}␣)␣{
␣␣␣␣␣␣␣␣require␣Config;
␣␣
␣␣␣␣␣␣␣␣###␣and␣just␣the␣standard␣dir
␣␣␣␣␣␣␣␣push␣@libs,␣$lib;
␣␣
␣␣␣␣␣␣␣␣###␣figure␣out␣what␣an␣MM␣prefix␣expands␣to.␣Basically,␣it's␣the
␣␣␣␣␣␣␣␣###␣site␣install␣target␣from␣%Config,␣ie:␣/opt/lib/perl5/site_perl/5.8.8␣
␣␣␣␣␣␣␣␣###␣minus␣the␣site␣wide␣prefix,␣ie:␣/opt
␣␣␣␣␣␣␣␣###␣this␣lets␣users␣add␣the␣dir␣they␣have␣set␣as␣their␣EU::MM␣PREFIX
␣␣␣␣␣␣␣␣###␣to␣our␣'lib'␣config␣and␣it␣Just␣Works
␣␣␣␣␣␣␣␣###␣the␣arch␣specific␣dir,␣ie:
␣␣␣␣␣␣␣␣###␣/opt/lib/perl5/site_perl/5.8.8/darwin-2level␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣XXX␣is␣this␣the␣right␣thing␣to␣do?
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣###␣we␣add␣all␣6␣dir␣combos␣for␣prefixes:
␣␣␣␣␣␣␣␣###␣/foo/lib
␣␣␣␣␣␣␣␣###␣/foo/lib/arch
␣␣␣␣␣␣␣␣###␣/foo/site/lib
␣␣␣␣␣␣␣␣###␣/foo/site/lib/arch
␣␣␣␣␣␣␣␣###␣/foo/vendor/lib
␣␣␣␣␣␣␣␣###␣/foo/vendor/lib/arch
␣␣␣␣␣␣␣␣for␣my␣$href␣(␣@config_names␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣for␣my␣$key␣(␣qw[lib␣arch]␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣look␣up␣the␣config␣value␣--␣use␣EXP␣for␣the␣EXPANDED
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣version,␣so␣no␣~␣etc␣are␣found␣in␣there
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$dir␣␣␣␣␣=␣$Config::Config{␣$href->{␣$key␣}␣.'exp'␣}␣or␣next;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$prefix␣␣=␣$Config::Config{␣$href->{prefix}␣};

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣prefix␣may␣be␣relative␣to␣home,␣and␣contain␣a␣~
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣if␣so,␣fix␣it␣up.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$prefix␣␣␣␣␣=~␣s/^~/$home/;

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣remove␣the␣prefix␣from␣it,␣so␣we␣can␣append␣to␣our␣$lib
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$dir␣␣␣␣␣␣␣␣=~␣s/^\Q$prefix\E//;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣###␣do␣the␣appending
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@libs,␣File::Spec->catdir(␣$lib,␣$dir␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣␣␣␣␣␣␣␣

␣␣␣␣my␣$inst;␣␣␣␣
␣␣␣␣unless(␣$inst␣=␣ExtUtils::Installed->new(␣extra_libs␣=>␣\@libs␣)␣)␣{
␣␣␣␣␣␣␣␣error(␣loc("Could␣not␣create␣an␣'%1'␣object",␣'ExtUtils::Installed'␣)␣);

␣␣␣␣␣␣␣␣###␣in␣case␣it's␣being␣used␣directly...␣###
␣␣␣␣␣␣␣␣return;
␣␣␣␣}


␣␣␣␣{␣␣␣###␣EU::Installed␣can␣die␣=/
␣␣␣␣␣␣␣␣my␣@files;
␣␣␣␣␣␣␣␣eval␣{␣@files␣=␣$inst->$method(␣$self->module,␣$type␣)␣};

␣␣␣␣␣␣␣␣if(␣$@␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣chomp␣$@;
␣␣␣␣␣␣␣␣␣␣␣␣error(␣loc("Could␣not␣get␣'%1'␣for␣'%2':␣%3",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$method,␣$self->module,␣$@␣)␣);
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣return␣wantarray␣?␣@files␣:␣\@files;
␣␣␣␣}
}

=head2␣$bool␣=␣$self->add_to_includepath;

Adds␣the␣current␣modules␣path␣to␣C<@INC>␣and␣C<$PERL5LIB>.␣This␣allows
you␣to␣add␣the␣module␣from␣its␣build␣dir␣to␣your␣path.

You␣can␣reset␣C<@INC>␣and␣C<$PERL5LIB>␣to␣its␣original␣state␣when␣you
started␣the␣program,␣by␣calling:

␣␣␣␣$self->parent->flush('lib');
␣␣␣␣
=cut

sub␣add_to_includepath␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$cb␣␣␣=␣$self->parent;
␣␣␣␣
␣␣␣␣if(␣my␣$dir␣=␣$self->status->extract␣)␣{
␣␣␣␣␣␣␣␣
␣␣␣␣␣␣␣␣␣␣␣␣$cb->_add_to_includepath(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣directories␣=>␣[
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣File::Spec->catdir(BLIB->($dir),␣LIB),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣File::Spec->catdir(BLIB->($dir),␣ARCH),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣BLIB->($dir),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣]
␣␣␣␣␣␣␣␣␣␣␣␣)␣or␣return;
␣␣␣␣␣␣␣␣
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣error(loc(␣␣"No␣extract␣dir␣registered␣for␣'%1'␣--␣can␣not␣add␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"add␣builddir␣to␣search␣path!",␣$self->module␣));
␣␣␣␣␣␣␣␣return;
␣␣␣␣}

␣␣␣␣return␣1;

}

=pod

=head2␣$path␣=␣$self->best_path_to_module_build();

B<OBSOLETE>

If␣a␣newer␣version␣of␣Module::Build␣is␣found␣in␣your␣path,␣it␣will
return␣this␣C<special>␣path.␣If␣the␣newest␣version␣of␣C<Module::Build>
is␣found␣in␣your␣regular␣C<@INC>,␣the␣method␣will␣return␣false.␣This
indicates␣you␣do␣not␣need␣to␣add␣a␣special␣directory␣to␣your␣C<@INC>.

Note␣that␣this␣is␣only␣relevant␣if␣you're␣building␣your␣own
C<CPANPLUS::Dist::*>␣plugin␣--␣the␣built-in␣dist␣types␣already␣have
this␣taken␣care␣of.

=cut

###␣make␣sure␣we're␣always␣running␣'perl␣Build.PL'␣and␣friends
###␣against␣the␣highest␣version␣of␣module::build␣available
sub␣best_path_to_module_build␣{
␣␣␣␣my␣$self␣=␣shift;

␣␣␣␣###␣Since␣M::B␣will␣actually␣shell␣out␣and␣run␣the␣Build.PL,␣we␣must
␣␣␣␣###␣make␣sure␣it␣refinds␣the␣proper␣version␣of␣M::B␣in␣the␣path.
␣␣␣␣###␣that␣may␣be␣either␣in␣our␣cp::inc␣or␣in␣site_perl,␣or␣even␣a
␣␣␣␣###␣new␣M::B␣being␣installed.
␣␣␣␣###␣don't␣add␣anything␣else␣here,␣as␣that␣might␣screw␣up␣prereq␣checks

␣␣␣␣###␣XXX␣this␣might␣be␣needed␣for␣Dist::MM␣too,␣if␣a␣makefile.pl␣is
␣␣␣␣###	masquerading␣as␣a␣Build.PL

␣␣␣␣###␣did␣we␣find␣the␣most␣recent␣module::build␣in␣our␣installer␣path?

␣␣␣␣###␣XXX␣can't␣do␣changes␣to␣@INC,␣they're␣being␣ignored␣by
␣␣␣␣###␣new_from_context␣when␣writing␣a␣Build␣script.␣see␣ticket:
␣␣␣␣###␣#8826␣Module::Build␣ignores␣changes␣to␣@INC␣when␣writing␣Build
␣␣␣␣###␣from␣new_from_context
␣␣␣␣###␣XXX␣applied␣schwern's␣patches␣(as␣seen␣on␣CPANPLUS::Devel␣10/12/04)
␣␣␣␣###␣and␣upped␣the␣version␣to␣0.26061␣of␣the␣bundled␣version,␣and␣things
␣␣␣␣###␣work␣again

␣␣␣␣###␣this␣functionality␣is␣now␣obsolete␣--␣prereqs␣should␣be␣installed
␣␣␣␣###␣and␣we␣no␣longer␣use␣the␣CPANPLUS::inc␣magic..␣so␣comment␣this␣out.
#␣␣␣␣␣require␣Module::Build;
#␣␣␣␣␣if(␣CPANPLUS::inc->path_to('Module::Build')␣and␣(
#␣␣␣␣␣␣␣␣␣CPANPLUS::inc->path_to('Module::Build')␣eq
#␣␣␣␣␣␣␣␣␣CPANPLUS::inc->installer_path␣)
#␣␣␣␣␣)␣{
#␣
#␣␣␣␣␣␣␣␣␣###␣if␣the␣module␣being␣installed␣is␣*not*␣Module::Build
#␣␣␣␣␣␣␣␣␣###␣itself␣--␣as␣that␣would␣undoubtedly␣be␣newer␣--␣add
#␣␣␣␣␣␣␣␣␣###␣the␣path␣to␣the␣installers␣to␣@INC
#␣␣␣␣␣␣␣␣␣###␣if␣it␣IS␣module::build␣itself,␣add␣'lib'␣to␣its␣path,
#␣␣␣␣␣␣␣␣␣###␣as␣the␣Build.PL␣would␣do␣as␣well,␣but␣the␣API␣doesn't.
#␣␣␣␣␣␣␣␣␣###␣this␣makes␣self␣updates␣possible
#␣␣␣␣␣␣␣␣␣return␣$self->module␣eq␣'Module::Build'
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣'lib'
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣CPANPLUS::inc->installer_path;
#␣␣␣␣␣}

␣␣␣␣###␣otherwise,␣the␣path␣was␣found␣through␣a␣'normal'␣way␣of
␣␣␣␣###␣scanning␣@INC.
␣␣␣␣return;
}

=pod

=head1␣BUG␣REPORTS

Please␣report␣bugs␣or␣other␣issues␣to␣E<lt>bug-cpanplus@rt.cpan.org<gt>.

=head1␣AUTHOR

This␣module␣by␣Jos␣Boumans␣E<lt>kane@cpan.orgE<gt>.

=head1␣COPYRIGHT

The␣CPAN++␣interface␣(of␣which␣this␣module␣is␣a␣part␣of)␣is␣copyright␣(c)␣
2001␣-␣2007,␣Jos␣Boumans␣E<lt>kane@cpan.orgE<gt>.␣All␣rights␣reserved.

This␣library␣is␣free␣software;␣you␣may␣redistribute␣and/or␣modify␣it␣
under␣the␣same␣terms␣as␣Perl␣itself.

=cut

#␣Local␣variables:
#␣c-indentation-style:␣bsd
#␣c-basic-offset:␣4
#␣indent-tabs-mode:␣nil
#␣End:
#␣vim:␣expandtab␣shiftwidth=4:

1;

#␣-*-␣mode:␣perl;␣perl-indent-level:␣2;␣-*-
#␣Memoize.pm
#
#␣Transparent␣memoization␣of␣idempotent␣functions
#
#␣Copyright␣1998,␣1999,␣2000,␣2001␣M-J.␣Dominus.
#␣You␣may␣copy␣and␣distribute␣this␣program␣under␣the
#␣same␣terms␣as␣Perl␣itself.␣␣If␣in␣doubt,␣
#␣write␣to␣mjd-perl-memoize+@plover.com␣for␣a␣license.
#
#␣Version␣1.01␣$Revision:␣1.18␣$␣$Date:␣2001/06/24␣17:16:47␣$

package␣Memoize;
$VERSION␣=␣'1.01_03';

#␣Compile-time␣constants
sub␣SCALAR␣()␣{␣0␣}␣
sub␣LIST␣()␣{␣1␣}␣


#
#␣Usage␣memoize(functionname/ref,
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{␣NORMALIZER␣=>␣coderef,␣INSTALL␣=>␣name,
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣LIST_CACHE␣=>␣descriptor,␣SCALAR_CACHE␣=>␣descriptor␣}
#

use␣Carp;
use␣Exporter;
use␣vars␣qw($DEBUG);
use␣Config;␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣Dammit.
@ISA␣=␣qw(Exporter);
@EXPORT␣=␣qw(memoize);
@EXPORT_OK␣=␣qw(unmemoize␣flush_cache);
use␣strict;

my␣%memotable;
my␣%revmemotable;
my␣@CONTEXT_TAGS␣=␣qw(MERGE␣TIE␣MEMORY␣FAULT␣HASH);
my␣%IS_CACHE_TAG␣=␣map␣{($_␣=>␣1)}␣@CONTEXT_TAGS;

#␣Raise␣an␣error␣if␣the␣user␣tries␣to␣specify␣one␣of␣thesepackage␣as␣a
#␣tie␣for␣LIST_CACHE

my␣%scalar_only␣=␣map␣{($_␣=>␣1)}␣qw(DB_File␣GDBM_File␣SDBM_File␣ODBM_File␣NDBM_File);

sub␣memoize␣{
␣␣my␣$fn␣=␣shift;
␣␣my␣%options␣=␣@_;
␣␣my␣$options␣=␣\%options;
␣␣
␣␣unless␣(defined($fn)␣&&␣
	␣␣(ref␣$fn␣eq␣'CODE'␣||␣ref␣$fn␣eq␣''))␣{
␣␣␣␣croak␣"Usage:␣memoize␣'functionname'|coderef␣{OPTIONS}";
␣␣}

␣␣my␣$uppack␣=␣caller;		#␣TCL␣me␣Elmo!
␣␣my␣$cref;			#␣Code␣reference␣to␣original␣function
␣␣my␣$name␣=␣(ref␣$fn␣?␣undef␣:␣$fn);

␣␣#␣Convert␣function␣names␣to␣code␣references
␣␣$cref␣=␣&_make_cref($fn,␣$uppack);

␣␣#␣Locate␣function␣prototype,␣if␣any
␣␣my␣$proto␣=␣prototype␣$cref;
␣␣if␣(defined␣$proto)␣{␣$proto␣=␣"($proto)"␣}
␣␣else␣{␣$proto␣=␣""␣}

␣␣#␣I␣would␣like␣to␣get␣rid␣of␣the␣eval,␣but␣there␣seems␣not␣to␣be␣any
␣␣#␣other␣way␣to␣set␣the␣prototype␣properly.␣␣The␣switch␣here␣for
␣␣#␣'usethreads'␣works␣around␣a␣bug␣in␣threadperl␣having␣to␣do␣with
␣␣#␣magic␣goto.␣␣It␣would␣be␣better␣to␣fix␣the␣bug␣and␣use␣the␣magic
␣␣#␣goto␣version␣everywhere.
␣␣my␣$wrapper␣=␣
␣␣␣␣␣␣$Config{usethreads}␣
␣␣␣␣␣␣␣␣?␣eval␣"sub␣$proto␣{␣&_memoizer(\$cref,␣\@_);␣}"␣
␣␣␣␣␣␣␣␣:␣eval␣"sub␣$proto␣{␣unshift␣\@_,␣\$cref;␣goto␣&_memoizer;␣}";

␣␣my␣$normalizer␣=␣$options{NORMALIZER};
␣␣if␣(defined␣$normalizer␣␣&&␣!␣ref␣$normalizer)␣{
␣␣␣␣$normalizer␣=␣_make_cref($normalizer,␣$uppack);
␣␣}
␣␣
␣␣my␣$install_name;
␣␣if␣(defined␣$options->{INSTALL})␣{
␣␣␣␣#␣INSTALL␣=>␣name
␣␣␣␣$install_name␣=␣$options->{INSTALL};
␣␣}␣elsif␣(!␣exists␣$options->{INSTALL})␣{
␣␣␣␣#␣No␣INSTALL␣option␣provided;␣use␣original␣name␣if␣possible
␣␣␣␣$install_name␣=␣$name;
␣␣}␣else␣{
␣␣␣␣#␣INSTALL␣=>␣undef␣␣means␣don't␣install
␣␣}

␣␣if␣(defined␣$install_name)␣{
␣␣␣␣$install_name␣=␣$uppack␣.␣'::'␣.␣$install_name
	unless␣$install_name␣=~␣/::/;
␣␣␣␣no␣strict;
␣␣␣␣local($^W)␣=␣0;	␣␣␣␣␣␣␣#␣``Subroutine␣$install_name␣redefined␣at␣...''
␣␣␣␣*{$install_name}␣=␣$wrapper;␣#␣Install␣memoized␣version
␣␣}

␣␣$revmemotable{$wrapper}␣=␣""␣.␣$cref;␣#␣Turn␣code␣ref␣into␣hash␣key

␣␣#␣These␣will␣be␣the␣caches
␣␣my␣%caches;
␣␣for␣my␣$context␣(qw(SCALAR␣LIST))␣{
␣␣␣␣#␣suppress␣subsequent␣'uninitialized␣value'␣warnings
␣␣␣␣$options{"${context}_CACHE"}␣||=␣'';␣

␣␣␣␣my␣$cache_opt␣=␣$options{"${context}_CACHE"};
␣␣␣␣my␣@cache_opt_args;
␣␣␣␣if␣(ref␣$cache_opt)␣{
␣␣␣␣␣␣@cache_opt_args␣=␣@$cache_opt;
␣␣␣␣␣␣$cache_opt␣=␣shift␣@cache_opt_args;
␣␣␣␣}
␣␣␣␣if␣($cache_opt␣eq␣'FAULT')␣{␣#␣no␣cache
␣␣␣␣␣␣$caches{$context}␣=␣undef;
␣␣␣␣}␣elsif␣($cache_opt␣eq␣'HASH')␣{␣#␣user-supplied␣hash
␣␣␣␣␣␣my␣$cache␣=␣$cache_opt_args[0];
␣␣␣␣␣␣my␣$package␣=␣ref(tied␣%$cache);
␣␣␣␣␣␣if␣($context␣eq␣'LIST'␣&&␣$scalar_only{$package})␣{
␣␣␣␣␣␣␣␣croak("You␣can't␣use␣$package␣for␣LIST_CACHE␣because␣it␣can␣only␣store␣scalars");
␣␣␣␣␣␣}
␣␣␣␣␣␣$caches{$context}␣=␣$cache;
␣␣␣␣}␣elsif␣($cache_opt␣eq␣''␣||␣␣$IS_CACHE_TAG{$cache_opt})␣{
␣␣␣␣␣␣#␣default␣is␣that␣we␣make␣up␣an␣in-memory␣hash
␣␣␣␣␣␣$caches{$context}␣=␣{};
␣␣␣␣␣␣#␣(this␣might␣get␣tied␣later,␣or␣MERGEd␣away)
␣␣␣␣}␣else␣{
␣␣␣␣␣␣croak␣"Unrecognized␣option␣to␣`${context}_CACHE':␣`$cache_opt'␣should␣be␣one␣of␣(@CONTEXT_TAGS);␣aborting";
␣␣␣␣}
␣␣}

␣␣#␣Perhaps␣I␣should␣check␣here␣that␣you␣didn't␣supply␣*both*␣merge
␣␣#␣options.␣␣But␣if␣you␣did,␣it␣does␣do␣something␣reasonable:␣They
␣␣#␣both␣get␣merged␣to␣the␣same␣in-memory␣hash.
␣␣if␣($options{SCALAR_CACHE}␣eq␣'MERGE')␣{
␣␣␣␣$caches{SCALAR}␣=␣$caches{LIST};
␣␣}␣elsif␣($options{LIST_CACHE}␣eq␣'MERGE')␣{
␣␣␣␣$caches{LIST}␣=␣$caches{SCALAR};
␣␣}

␣␣#␣Now␣deal␣with␣the␣TIE␣options
␣␣{
␣␣␣␣my␣$context;
␣␣␣␣foreach␣$context␣(qw(SCALAR␣LIST))␣{
␣␣␣␣␣␣#␣If␣the␣relevant␣option␣wasn't␣`TIE',␣this␣call␣does␣nothing.
␣␣␣␣␣␣_my_tie($context,␣$caches{$context},␣$options);␣␣#␣Croaks␣on␣failure
␣␣␣␣}
␣␣}
␣␣
␣␣#␣We␣should␣put␣some␣more␣stuff␣in␣here␣eventually.
␣␣#␣We've␣been␣saying␣that␣for␣serveral␣versions␣now.
␣␣#␣And␣you␣know␣what?␣␣More␣stuff␣keeps␣going␣in!
␣␣$memotable{$cref}␣=␣
␣␣{
␣␣␣␣O␣=>␣$options,␣␣#␣Short␣keys␣here␣for␣things␣we␣need␣to␣access␣frequently
␣␣␣␣N␣=>␣$normalizer,
␣␣␣␣U␣=>␣$cref,
␣␣␣␣MEMOIZED␣=>␣$wrapper,
␣␣␣␣PACKAGE␣=>␣$uppack,
␣␣␣␣NAME␣=>␣$install_name,
␣␣␣␣S␣=>␣$caches{SCALAR},
␣␣␣␣L␣=>␣$caches{LIST},
␣␣};

␣␣$wrapper			#␣Return␣just␣memoized␣version
}

#␣This␣function␣tries␣to␣load␣a␣tied␣hash␣class␣and␣tie␣the␣hash␣to␣it.
sub␣_my_tie␣{
␣␣my␣($context,␣$hash,␣$options)␣=␣@_;
␣␣my␣$fullopt␣=␣$options->{"${context}_CACHE"};

␣␣#␣We␣already␣checked␣to␣make␣sure␣that␣this␣works.
␣␣my␣$shortopt␣=␣(ref␣$fullopt)␣?␣$fullopt->[0]␣:␣$fullopt;
␣␣
␣␣return␣unless␣defined␣$shortopt␣&&␣$shortopt␣eq␣'TIE';
␣␣carp("TIE␣option␣to␣memoize()␣is␣deprecated;␣use␣HASH␣instead")
␣␣␣␣␣␣if␣$^W;

␣␣my␣@args␣=␣ref␣$fullopt␣?␣@$fullopt␣:␣();
␣␣shift␣@args;
␣␣my␣$module␣=␣shift␣@args;
␣␣if␣($context␣eq␣'LIST'␣&&␣$scalar_only{$module})␣{
␣␣␣␣croak("You␣can't␣use␣$module␣for␣LIST_CACHE␣because␣it␣can␣only␣store␣scalars");
␣␣}
␣␣my␣$modulefile␣=␣$module␣.␣'.pm';
␣␣$modulefile␣=~␣s{::}{/}g;
␣␣eval␣{␣require␣$modulefile␣};
␣␣if␣($@)␣{
␣␣␣␣croak␣"Memoize:␣Couldn't␣load␣hash␣tie␣module␣`$module':␣$@;␣aborting";
␣␣}
␣␣my␣$rc␣=␣(tie␣%$hash␣=>␣$module,␣@args);
␣␣unless␣($rc)␣{
␣␣␣␣croak␣"Memoize:␣Couldn't␣tie␣hash␣to␣`$module':␣$!;␣aborting";
␣␣}
␣␣1;
}

sub␣flush_cache␣{
␣␣my␣$func␣=␣_make_cref($_[0],␣scalar␣caller);
␣␣my␣$info␣=␣$memotable{$revmemotable{$func}};
␣␣die␣"$func␣not␣memoized"␣unless␣defined␣$info;
␣␣for␣my␣$context␣(qw(S␣L))␣{
␣␣␣␣my␣$cache␣=␣$info->{$context};
␣␣␣␣if␣(tied␣%$cache␣&&␣!␣(tied␣%$cache)->can('CLEAR'))␣{
␣␣␣␣␣␣my␣$funcname␣=␣defined($info->{NAME})␣?␣
␣␣␣␣␣␣␣␣␣␣"function␣$info->{NAME}"␣:␣"anonymous␣function␣$func";
␣␣␣␣␣␣my␣$context␣=␣{S␣=>␣'scalar',␣L␣=>␣'list'}->{$context};
␣␣␣␣␣␣croak␣"Tied␣cache␣hash␣for␣$context-context␣$funcname␣does␣not␣support␣flushing";
␣␣␣␣}␣else␣{
␣␣␣␣␣␣%$cache␣=␣();
␣␣␣␣}
␣␣}
}

#␣This␣is␣the␣function␣that␣manages␣the␣memo␣tables.
sub␣_memoizer␣{
␣␣my␣$orig␣=␣shift;		#␣stringized␣version␣of␣ref␣to␣original␣func.
␣␣my␣$info␣=␣$memotable{$orig};
␣␣my␣$normalizer␣=␣$info->{N};
␣␣
␣␣my␣$argstr;
␣␣my␣$context␣=␣(wantarray()␣?␣LIST␣:␣SCALAR);

␣␣if␣(defined␣$normalizer)␣{␣
␣␣␣␣no␣strict;
␣␣␣␣if␣($context␣==␣SCALAR)␣{
␣␣␣␣␣␣$argstr␣=␣&{$normalizer}(@_);
␣␣␣␣}␣elsif␣($context␣==␣LIST)␣{
␣␣␣␣␣␣($argstr)␣=␣&{$normalizer}(@_);
␣␣␣␣}␣else␣{
␣␣␣␣␣␣croak␣"Internal␣error␣\#41;␣context␣was␣neither␣LIST␣nor␣SCALAR\n";
␣␣␣␣}
␣␣}␣else␣{␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣Default␣normalizer
␣␣␣␣local␣$^W␣=␣0;
␣␣␣␣$argstr␣=␣join␣chr(28),@_;␣␣
␣␣}

␣␣if␣($context␣==␣SCALAR)␣{
␣␣␣␣my␣$cache␣=␣$info->{S};
␣␣␣␣_crap_out($info->{NAME},␣'scalar')␣unless␣$cache;
␣␣␣␣if␣(exists␣$cache->{$argstr})␣{␣
␣␣␣␣␣␣return␣$cache->{$argstr};
␣␣␣␣}␣else␣{
␣␣␣␣␣␣my␣$val␣=␣&{$info->{U}}(@_);
␣␣␣␣␣␣#␣Scalars␣are␣considered␣to␣be␣lists;␣store␣appropriately
␣␣␣␣␣␣if␣($info->{O}{SCALAR_CACHE}␣eq␣'MERGE')␣{
	$cache->{$argstr}␣=␣[$val];
␣␣␣␣␣␣}␣else␣{
	$cache->{$argstr}␣=␣$val;
␣␣␣␣␣␣}
␣␣␣␣␣␣$val;
␣␣␣␣}
␣␣}␣elsif␣($context␣==␣LIST)␣{
␣␣␣␣my␣$cache␣=␣$info->{L};
␣␣␣␣_crap_out($info->{NAME},␣'list')␣unless␣$cache;
␣␣␣␣if␣(exists␣$cache->{$argstr})␣{
␣␣␣␣␣␣my␣$val␣=␣$cache->{$argstr};
␣␣␣␣␣␣#␣If␣LISTCONTEXT=>MERGE,␣then␣the␣function␣never␣returns␣lists,
␣␣␣␣␣␣#␣so␣we␣have␣a␣scalar␣value␣cached,␣so␣just␣return␣it␣straightaway:
␣␣␣␣␣␣return␣($val)␣if␣$info->{O}{LIST_CACHE}␣eq␣'MERGE';
␣␣␣␣␣␣#␣Maybe␣in␣a␣later␣version␣we␣can␣use␣a␣faster␣test.

␣␣␣␣␣␣#␣Otherwise,␣we␣cached␣an␣array␣containing␣the␣returned␣list:
␣␣␣␣␣␣return␣@$val;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣@q␣=␣&{$info->{U}}(@_);
␣␣␣␣␣␣␣␣$cache->{$argstr}␣=␣$info->{O}{LIST_CACHE}␣eq␣'MERGE'␣?␣$q␣[0]␣:␣\@q;
␣␣␣␣␣␣␣␣@q;
␣␣␣␣}
␣␣}␣else␣{
␣␣␣␣croak␣"Internal␣error␣\#42;␣context␣was␣neither␣LIST␣nor␣SCALAR\n";
␣␣}
}

sub␣unmemoize␣{
␣␣my␣$f␣=␣shift;
␣␣my␣$uppack␣=␣caller;
␣␣my␣$cref␣=␣_make_cref($f,␣$uppack);

␣␣unless␣(exists␣$revmemotable{$cref})␣{
␣␣␣␣croak␣"Could␣not␣unmemoize␣function␣`$f',␣because␣it␣was␣not␣memoized␣to␣begin␣with";
␣␣}
␣␣
␣␣my␣$tabent␣=␣$memotable{$revmemotable{$cref}};
␣␣unless␣(defined␣$tabent)␣{
␣␣␣␣croak␣"Could␣not␣figure␣out␣how␣to␣unmemoize␣function␣`$f'";
␣␣}
␣␣my␣$name␣=␣$tabent->{NAME};
␣␣if␣(defined␣$name)␣{
␣␣␣␣no␣strict;
␣␣␣␣local($^W)␣=␣0;	␣␣␣␣␣␣␣#␣``Subroutine␣$install_name␣redefined␣at␣...''
␣␣␣␣*{$name}␣=␣$tabent->{U};␣#␣Replace␣with␣original␣function
␣␣}
␣␣undef␣$memotable{$revmemotable{$cref}};
␣␣undef␣$revmemotable{$cref};

␣␣#␣This␣removes␣the␣last␣reference␣to␣the␣(possibly␣tied)␣memo␣tables
␣␣#␣my␣($old_function,␣$memotabs)␣=␣@{$tabent}{'U','S','L'};
␣␣#␣undef␣$tabent;␣

#␣␣#␣Untie␣the␣memo␣tables␣if␣they␣were␣tied.
#␣␣my␣$i;
#␣␣for␣$i␣(0,1)␣{
#␣␣␣␣if␣(tied␣%{$memotabs->[$i]})␣{
#␣␣␣␣␣␣warn␣"Untying␣hash␣#$i\n";
#␣␣␣␣␣␣untie␣%{$memotabs->[$i]};
#␣␣␣␣}
#␣␣}

␣␣$tabent->{U};
}

sub␣_make_cref␣{
␣␣my␣$fn␣=␣shift;
␣␣my␣$uppack␣=␣shift;
␣␣my␣$cref;
␣␣my␣$name;

␣␣if␣(ref␣$fn␣eq␣'CODE')␣{
␣␣␣␣$cref␣=␣$fn;
␣␣}␣elsif␣(!␣ref␣$fn)␣{
␣␣␣␣if␣($fn␣=~␣/::/)␣{
␣␣␣␣␣␣$name␣=␣$fn;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣$name␣=␣$uppack␣.␣'::'␣.␣$fn;
␣␣␣␣}
␣␣␣␣no␣strict;
␣␣␣␣if␣(defined␣$name␣and␣!defined(&$name))␣{
␣␣␣␣␣␣croak␣"Cannot␣operate␣on␣nonexistent␣function␣`$fn'";
␣␣␣␣}
#␣␣␣␣$cref␣=␣\&$name;
␣␣␣␣$cref␣=␣*{$name}{CODE};
␣␣}␣else␣{
␣␣␣␣my␣$parent␣=␣(caller(1))[3];␣#␣Function␣that␣called␣_make_cref
␣␣␣␣croak␣"Usage:␣argument␣1␣to␣`$parent'␣must␣be␣a␣function␣name␣or␣reference.\n";
␣␣}
␣␣$DEBUG␣and␣warn␣"${name}($fn)␣=>␣$cref␣in␣_make_cref\n";
␣␣$cref;
}

sub␣_crap_out␣{
␣␣my␣($funcname,␣$context)␣=␣@_;
␣␣if␣(defined␣$funcname)␣{
␣␣␣␣croak␣"Function␣`$funcname'␣called␣in␣forbidden␣$context␣context;␣faulting";
␣␣}␣else␣{
␣␣␣␣croak␣"Anonymous␣function␣called␣in␣forbidden␣$context␣context;␣faulting";
␣␣}
}

1;





=head1␣NAME

Memoize␣-␣Make␣functions␣faster␣by␣trading␣space␣for␣time

=head1␣SYNOPSIS

␣␣␣␣␣␣␣␣#␣This␣is␣the␣documentation␣for␣Memoize␣1.01
	use␣Memoize;
	memoize('slow_function');
	slow_function(arguments);␣␣␣␣#␣Is␣faster␣than␣it␣was␣before


This␣is␣normally␣all␣you␣need␣to␣know.␣␣However,␣many␣options␣are␣available:

	memoize(function,␣options...);

Options␣include:

	NORMALIZER␣=>␣function
	INSTALL␣=>␣new_name

	SCALAR_CACHE␣=>␣'MEMORY'
␣␣␣␣␣␣␣␣SCALAR_CACHE␣=>␣['HASH',␣\%cache_hash␣]
	SCALAR_CACHE␣=>␣'FAULT'
	SCALAR_CACHE␣=>␣'MERGE'

	LIST_CACHE␣=>␣'MEMORY'
␣␣␣␣␣␣␣␣LIST_CACHE␣=>␣['HASH',␣\%cache_hash␣]
	LIST_CACHE␣=>␣'FAULT'
	LIST_CACHE␣=>␣'MERGE'

=head1␣DESCRIPTION

`Memoizing'␣a␣function␣makes␣it␣faster␣by␣trading␣space␣for␣time.␣␣It
does␣this␣by␣caching␣the␣return␣values␣of␣the␣function␣in␣a␣table.
If␣you␣call␣the␣function␣again␣with␣the␣same␣arguments,␣C<memoize>
jumps␣in␣and␣gives␣you␣the␣value␣out␣of␣the␣table,␣instead␣of␣letting
the␣function␣compute␣the␣value␣all␣over␣again.

Here␣is␣an␣extreme␣example.␣␣Consider␣the␣Fibonacci␣sequence,␣defined
by␣the␣following␣function:

	#␣Compute␣Fibonacci␣numbers
	sub␣fib␣{
	␣␣my␣$n␣=␣shift;
	␣␣return␣$n␣if␣$n␣<␣2;
	␣␣fib($n-1)␣+␣fib($n-2);
	}

This␣function␣is␣very␣slow.␣␣Why?␣␣To␣compute␣fib(14),␣it␣first␣wants
to␣compute␣fib(13)␣and␣fib(12),␣and␣add␣the␣results.␣␣But␣to␣compute
fib(13),␣it␣first␣has␣to␣compute␣fib(12)␣and␣fib(11),␣and␣then␣it
comes␣back␣and␣computes␣fib(12)␣all␣over␣again␣even␣though␣the␣answer
is␣the␣same.␣␣And␣both␣of␣the␣times␣that␣it␣wants␣to␣compute␣fib(12),
it␣has␣to␣compute␣fib(11)␣from␣scratch,␣and␣then␣it␣has␣to␣do␣it
again␣each␣time␣it␣wants␣to␣compute␣fib(13).␣␣This␣function␣does␣so
much␣recomputing␣of␣old␣results␣that␣it␣takes␣a␣really␣long␣time␣to
run---fib(14)␣makes␣1,200␣extra␣recursive␣calls␣to␣itself,␣to␣compute
and␣recompute␣things␣that␣it␣already␣computed.

This␣function␣is␣a␣good␣candidate␣for␣memoization.␣␣If␣you␣memoize␣the
`fib'␣function␣above,␣it␣will␣compute␣fib(14)␣exactly␣once,␣the␣first
time␣it␣needs␣to,␣and␣then␣save␣the␣result␣in␣a␣table.␣␣Then␣if␣you
ask␣for␣fib(14)␣again,␣it␣gives␣you␣the␣result␣out␣of␣the␣table.
While␣computing␣fib(14),␣instead␣of␣computing␣fib(12)␣twice,␣it␣does
it␣once;␣the␣second␣time␣it␣needs␣the␣value␣it␣gets␣it␣from␣the␣table.
It␣doesn't␣compute␣fib(11)␣four␣times;␣it␣computes␣it␣once,␣getting␣it
from␣the␣table␣the␣next␣three␣times.␣␣Instead␣of␣making␣1,200
recursive␣calls␣to␣`fib',␣it␣makes␣15.␣␣This␣makes␣the␣function␣about
150␣times␣faster.

You␣could␣do␣the␣memoization␣yourself,␣by␣rewriting␣the␣function,␣like
this:

	#␣Compute␣Fibonacci␣numbers,␣memoized␣version
	{␣my␣@fib;
␣␣	␣␣sub␣fib␣{
	␣␣␣␣my␣$n␣=␣shift;
	␣␣␣␣return␣$fib[$n]␣if␣defined␣$fib[$n];
	␣␣␣␣return␣$fib[$n]␣=␣$n␣if␣$n␣<␣2;
	␣␣␣␣$fib[$n]␣=␣fib($n-1)␣+␣fib($n-2);
	␣␣}
␣␣␣␣␣␣␣␣}

Or␣you␣could␣use␣this␣module,␣like␣this:

	use␣Memoize;
	memoize('fib');

	#␣Rest␣of␣the␣fib␣function␣just␣like␣the␣original␣version.

This␣makes␣it␣easy␣to␣turn␣memoizing␣on␣and␣off.

Here's␣an␣even␣simpler␣example:␣I␣wrote␣a␣simple␣ray␣tracer;␣the
program␣would␣look␣in␣a␣certain␣direction,␣figure␣out␣what␣it␣was
looking␣at,␣and␣then␣convert␣the␣`color'␣value␣(typically␣a␣string
like␣`red')␣of␣that␣object␣to␣a␣red,␣green,␣and␣blue␣pixel␣value,␣like
this:

␣␣␣␣for␣($direction␣=␣0;␣$direction␣<␣300;␣$direction++)␣{
␣␣␣␣␣␣#␣Figure␣out␣which␣object␣is␣in␣direction␣$direction
␣␣␣␣␣␣$color␣=␣$object->{color};
␣␣␣␣␣␣($r,␣$g,␣$b)␣=␣@{&ColorToRGB($color)};
␣␣␣␣␣␣...
␣␣␣␣}

Since␣there␣are␣relatively␣few␣objects␣in␣a␣picture,␣there␣are␣only␣a
few␣colors,␣which␣get␣looked␣up␣over␣and␣over␣again.␣␣Memoizing
C<ColorToRGB>␣sped␣up␣the␣program␣by␣several␣percent.

=head1␣DETAILS

This␣module␣exports␣exactly␣one␣function,␣C<memoize>.␣␣The␣rest␣of␣the
functions␣in␣this␣package␣are␣None␣of␣Your␣Business.

You␣should␣say

	memoize(function)

where␣C<function>␣is␣the␣name␣of␣the␣function␣you␣want␣to␣memoize,␣or
a␣reference␣to␣it.␣␣C<memoize>␣returns␣a␣reference␣to␣the␣new,
memoized␣version␣of␣the␣function,␣or␣C<undef>␣on␣a␣non-fatal␣error.
At␣present,␣there␣are␣no␣non-fatal␣errors,␣but␣there␣might␣be␣some␣in
the␣future.

If␣C<function>␣was␣the␣name␣of␣a␣function,␣then␣C<memoize>␣hides␣the
old␣version␣and␣installs␣the␣new␣memoized␣version␣under␣the␣old␣name,
so␣that␣C<&function(...)>␣actually␣invokes␣the␣memoized␣version.

=head1␣OPTIONS

There␣are␣some␣optional␣options␣you␣can␣pass␣to␣C<memoize>␣to␣change
the␣way␣it␣behaves␣a␣little.␣␣To␣supply␣options,␣invoke␣C<memoize>
like␣this:

	memoize(function,␣NORMALIZER␣=>␣function,
			␣␣INSTALL␣=>␣newname,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣SCALAR_CACHE␣=>␣option,
	␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣LIST_CACHE␣=>␣option
			␣);

Each␣of␣these␣options␣is␣optional;␣you␣can␣include␣some,␣all,␣or␣none
of␣them.

=head2␣INSTALL

If␣you␣supply␣a␣function␣name␣with␣C<INSTALL>,␣memoize␣will␣install
the␣new,␣memoized␣version␣of␣the␣function␣under␣the␣name␣you␣give.
For␣example,␣

	memoize('fib',␣INSTALL␣=>␣'fastfib')

installs␣the␣memoized␣version␣of␣C<fib>␣as␣C<fastfib>;␣without␣the
C<INSTALL>␣option␣it␣would␣have␣replaced␣the␣old␣C<fib>␣with␣the
memoized␣version.␣␣

To␣prevent␣C<memoize>␣from␣installing␣the␣memoized␣version␣anywhere,␣use
C<INSTALL␣=E<gt>␣undef>.

=head2␣NORMALIZER

Suppose␣your␣function␣looks␣like␣this:

	#␣Typical␣call:␣f('aha!',␣A␣=>␣11,␣B␣=>␣12);
	sub␣f␣{
	␣␣my␣$a␣=␣shift;
	␣␣my␣%hash␣=␣@_;
	␣␣$hash{B}␣||=␣2;␣␣#␣B␣defaults␣to␣2
	␣␣$hash{C}␣||=␣7;␣␣#␣C␣defaults␣to␣7

	␣␣#␣Do␣something␣with␣$a,␣%hash
	}

Now,␣the␣following␣calls␣to␣your␣function␣are␣all␣completely␣equivalent:

	f(OUCH);
	f(OUCH,␣B␣=>␣2);
	f(OUCH,␣C␣=>␣7);
	f(OUCH,␣B␣=>␣2,␣C␣=>␣7);
	f(OUCH,␣C␣=>␣7,␣B␣=>␣2);
	(etc.)

However,␣unless␣you␣tell␣C<Memoize>␣that␣these␣calls␣are␣equivalent,
it␣will␣not␣know␣that,␣and␣it␣will␣compute␣the␣values␣for␣these
invocations␣of␣your␣function␣separately,␣and␣store␣them␣separately.

To␣prevent␣this,␣supply␣a␣C<NORMALIZER>␣function␣that␣turns␣the
program␣arguments␣into␣a␣string␣in␣a␣way␣that␣equivalent␣arguments
turn␣into␣the␣same␣string.␣␣A␣C<NORMALIZER>␣function␣for␣C<f>␣above
might␣look␣like␣this:

	sub␣normalize_f␣{
	␣␣my␣$a␣=␣shift;
	␣␣my␣%hash␣=␣@_;
	␣␣$hash{B}␣||=␣2;
	␣␣$hash{C}␣||=␣7;

	␣␣join(',',␣$a,␣map␣($_␣=>␣$hash{$_})␣sort␣keys␣%hash);
	}

Each␣of␣the␣argument␣lists␣above␣comes␣out␣of␣the␣C<normalize_f>
function␣looking␣exactly␣the␣same,␣like␣this:

	OUCH,B,2,C,7

You␣would␣tell␣C<Memoize>␣to␣use␣this␣normalizer␣this␣way:

	memoize('f',␣NORMALIZER␣=>␣'normalize_f');

C<memoize>␣knows␣that␣if␣the␣normalized␣version␣of␣the␣arguments␣is
the␣same␣for␣two␣argument␣lists,␣then␣it␣can␣safely␣look␣up␣the␣value
that␣it␣computed␣for␣one␣argument␣list␣and␣return␣it␣as␣the␣result␣of
calling␣the␣function␣with␣the␣other␣argument␣list,␣even␣if␣the
argument␣lists␣look␣different.

The␣default␣normalizer␣just␣concatenates␣the␣arguments␣with␣character
28␣in␣between.␣␣(In␣ASCII,␣this␣is␣called␣FS␣or␣control-\.)␣␣This
always␣works␣correctly␣for␣functions␣with␣only␣one␣string␣argument,
and␣also␣when␣the␣arguments␣never␣contain␣character␣28.␣␣However,␣it
can␣confuse␣certain␣argument␣lists:

	normalizer("a\034",␣"b")
	normalizer("a",␣"\034b")
	normalizer("a\034\034b")

for␣example.

Since␣hash␣keys␣are␣strings,␣the␣default␣normalizer␣will␣not
distinguish␣between␣C<undef>␣and␣the␣empty␣string.␣␣It␣also␣won't␣work
when␣the␣function's␣arguments␣are␣references.␣␣For␣example,␣consider␣a
function␣C<g>␣which␣gets␣two␣arguments:␣A␣number,␣and␣a␣reference␣to
an␣array␣of␣numbers:

	g(13,␣[1,2,3,4,5,6,7]);

The␣default␣normalizer␣will␣turn␣this␣into␣something␣like
C<"13\034ARRAY(0x436c1f)">.␣␣That␣would␣be␣all␣right,␣except␣that␣a
subsequent␣array␣of␣numbers␣might␣be␣stored␣at␣a␣different␣location
even␣though␣it␣contains␣the␣same␣data.␣␣If␣this␣happens,␣C<Memoize>
will␣think␣that␣the␣arguments␣are␣different,␣even␣though␣they␣are
equivalent.␣␣In␣this␣case,␣a␣normalizer␣like␣this␣is␣appropriate:

	sub␣normalize␣{␣join␣'␣',␣$_[0],␣@{$_[1]}␣}

For␣the␣example␣above,␣this␣produces␣the␣key␣"13␣1␣2␣3␣4␣5␣6␣7".

Another␣use␣for␣normalizers␣is␣when␣the␣function␣depends␣on␣data␣other
than␣those␣in␣its␣arguments.␣␣Suppose␣you␣have␣a␣function␣which
returns␣a␣value␣which␣depends␣on␣the␣current␣hour␣of␣the␣day:

	sub␣on_duty␣{
␣␣␣␣␣␣␣␣␣␣my␣($problem_type)␣=␣@_;
	␣␣my␣$hour␣=␣(localtime)[2];
␣␣␣␣␣␣␣␣␣␣open␣my␣$fh,␣"$DIR/$problem_type"␣or␣die...;
␣␣␣␣␣␣␣␣␣␣my␣$line;
␣␣␣␣␣␣␣␣␣␣while␣($hour--␣>␣0)
␣␣␣␣␣␣␣␣␣␣␣␣$line␣=␣<$fh>;
␣␣␣␣␣␣␣␣␣␣}␣
	␣␣return␣$line;
	}

At␣10:23,␣this␣function␣generates␣the␣10th␣line␣of␣a␣data␣file;␣at
3:45␣PM␣it␣generates␣the␣15th␣line␣instead.␣␣By␣default,␣C<Memoize>
will␣only␣see␣the␣$problem_type␣argument.␣␣To␣fix␣this,␣include␣the
current␣hour␣in␣the␣normalizer:

␣␣␣␣␣␣␣␣sub␣normalize␣{␣join␣'␣',␣(localtime)[2],␣@_␣}

The␣calling␣context␣of␣the␣function␣(scalar␣or␣list␣context)␣is
propagated␣to␣the␣normalizer.␣␣This␣means␣that␣if␣the␣memoized
function␣will␣treat␣its␣arguments␣differently␣in␣list␣context␣than␣it
would␣in␣scalar␣context,␣you␣can␣have␣the␣normalizer␣function␣select
its␣behavior␣based␣on␣the␣results␣of␣C<wantarray>.␣␣Even␣if␣called␣in
a␣list␣context,␣a␣normalizer␣should␣still␣return␣a␣single␣string.

=head2␣C<SCALAR_CACHE>,␣C<LIST_CACHE>

Normally,␣C<Memoize>␣caches␣your␣function's␣return␣values␣into␣an
ordinary␣Perl␣hash␣variable.␣␣However,␣you␣might␣like␣to␣have␣the
values␣cached␣on␣the␣disk,␣so␣that␣they␣persist␣from␣one␣run␣of␣your
program␣to␣the␣next,␣or␣you␣might␣like␣to␣associate␣some␣other
interesting␣semantics␣with␣the␣cached␣values.

There's␣a␣slight␣complication␣under␣the␣hood␣of␣C<Memoize>:␣There␣are
actually␣I<two>␣caches,␣one␣for␣scalar␣values␣and␣one␣for␣list␣values.
When␣your␣function␣is␣called␣in␣scalar␣context,␣its␣return␣value␣is
cached␣in␣one␣hash,␣and␣when␣your␣function␣is␣called␣in␣list␣context,
its␣value␣is␣cached␣in␣the␣other␣hash.␣␣You␣can␣control␣the␣caching
behavior␣of␣both␣contexts␣independently␣with␣these␣options.

The␣argument␣to␣C<LIST_CACHE>␣or␣C<SCALAR_CACHE>␣must␣either␣be␣one␣of
the␣following␣four␣strings:

	MEMORY
	FAULT
	MERGE
␣␣␣␣␣␣␣␣HASH

or␣else␣it␣must␣be␣a␣reference␣to␣a␣list␣whose␣first␣element␣is␣one␣of
these␣four␣strings,␣such␣as␣C<[HASH,␣arguments...]>.

=over␣4

=item␣C<MEMORY>

C<MEMORY>␣means␣that␣return␣values␣from␣the␣function␣will␣be␣cached␣in
an␣ordinary␣Perl␣hash␣variable.␣␣The␣hash␣variable␣will␣not␣persist
after␣the␣program␣exits.␣␣This␣is␣the␣default.

=item␣C<HASH>

C<HASH>␣allows␣you␣to␣specify␣that␣a␣particular␣hash␣that␣you␣supply
will␣be␣used␣as␣the␣cache.␣␣You␣can␣tie␣this␣hash␣beforehand␣to␣give
it␣any␣behavior␣you␣want.

A␣tied␣hash␣can␣have␣any␣semantics␣at␣all.␣␣It␣is␣typically␣tied␣to␣an
on-disk␣database,␣so␣that␣cached␣values␣are␣stored␣in␣the␣database␣and
retrieved␣from␣it␣again␣when␣needed,␣and␣the␣disk␣file␣typically
persists␣after␣your␣program␣has␣exited.␣␣See␣C<perltie>␣for␣more
complete␣details␣about␣C<tie>.

A␣typical␣example␣is:

␣␣␣␣␣␣␣␣use␣DB_File;
␣␣␣␣␣␣␣␣tie␣my␣%cache␣=>␣'DB_File',␣$filename,␣O_RDWR|O_CREAT,␣0666;
␣␣␣␣␣␣␣␣memoize␣'function',␣SCALAR_CACHE␣=>␣[HASH␣=>␣\%cache];

This␣has␣the␣effect␣of␣storing␣the␣cache␣in␣a␣C<DB_File>␣database
whose␣name␣is␣in␣C<$filename>.␣␣The␣cache␣will␣persist␣after␣the
program␣has␣exited.␣␣Next␣time␣the␣program␣runs,␣it␣will␣find␣the
cache␣already␣populated␣from␣the␣previous␣run␣of␣the␣program.␣␣Or␣you
can␣forcibly␣populate␣the␣cache␣by␣constructing␣a␣batch␣program␣that
runs␣in␣the␣background␣and␣populates␣the␣cache␣file.␣␣Then␣when␣you
come␣to␣run␣your␣real␣program␣the␣memoized␣function␣will␣be␣fast
because␣all␣its␣results␣have␣been␣precomputed.

=item␣C<TIE>

This␣option␣is␣no␣longer␣supported.␣␣It␣is␣still␣documented␣only␣to
aid␣in␣the␣debugging␣of␣old␣programs␣that␣use␣it.␣␣Old␣programs␣should
be␣converted␣to␣use␣the␣C<HASH>␣option␣instead.

␣␣␣␣␣␣␣␣memoize␣...␣[TIE,␣PACKAGE,␣ARGS...]

is␣merely␣a␣shortcut␣for

␣␣␣␣␣␣␣␣require␣PACKAGE;
	{␣my␣%cache;
␣␣␣␣␣␣␣␣␣␣tie␣%cache,␣PACKAGE,␣ARGS...;
	}
␣␣␣␣␣␣␣␣memoize␣...␣[HASH␣=>␣\%cache];

=item␣C<FAULT>

C<FAULT>␣means␣that␣you␣never␣expect␣to␣call␣the␣function␣in␣scalar
(or␣list)␣context,␣and␣that␣if␣C<Memoize>␣detects␣such␣a␣call,␣it
should␣abort␣the␣program.␣␣The␣error␣message␣is␣one␣of

	`foo'␣function␣called␣in␣forbidden␣list␣context␣at␣line␣...
	`foo'␣function␣called␣in␣forbidden␣scalar␣context␣at␣line␣...

=item␣C<MERGE>

C<MERGE>␣normally␣means␣the␣function␣does␣not␣distinguish␣between␣list
and␣sclar␣context,␣and␣that␣return␣values␣in␣both␣contexts␣should␣be
stored␣together.␣␣C<LIST_CACHE␣=E<gt>␣MERGE>␣means␣that␣list␣context
return␣values␣should␣be␣stored␣in␣the␣same␣hash␣that␣is␣used␣for
scalar␣context␣returns,␣and␣C<SCALAR_CACHE␣=E<gt>␣MERGE>␣means␣the
same,␣mutatis␣mutandis.␣␣It␣is␣an␣error␣to␣specify␣C<MERGE>␣for␣both,
but␣it␣probably␣does␣something␣useful.

Consider␣this␣function:

	sub␣pi␣{␣3;␣}

Normally,␣the␣following␣code␣will␣result␣in␣two␣calls␣to␣C<pi>:

␣␣␣␣$x␣=␣pi();
␣␣␣␣($y)␣=␣pi();
␣␣␣␣$z␣=␣pi();

The␣first␣call␣caches␣the␣value␣C<3>␣in␣the␣scalar␣cache;␣the␣second
caches␣the␣list␣C<(3)>␣in␣the␣list␣cache.␣␣The␣third␣call␣doesn't␣call
the␣real␣C<pi>␣function;␣it␣gets␣the␣value␣from␣the␣scalar␣cache.

Obviously,␣the␣second␣call␣to␣C<pi>␣is␣a␣waste␣of␣time,␣and␣storing
its␣return␣value␣is␣a␣waste␣of␣space.␣␣Specifying␣C<LIST_CACHE␣=E<gt>
MERGE>␣will␣make␣C<memoize>␣use␣the␣same␣cache␣for␣scalar␣and␣list
context␣return␣values,␣so␣that␣the␣second␣call␣uses␣the␣scalar␣cache
that␣was␣populated␣by␣the␣first␣call.␣␣C<pi>␣ends␣up␣being␣called␣only
once,␣and␣both␣subsequent␣calls␣return␣C<3>␣from␣the␣cache,␣regardless
of␣the␣calling␣context.

Another␣use␣for␣C<MERGE>␣is␣when␣you␣want␣both␣kinds␣of␣return␣values
stored␣in␣the␣same␣disk␣file;␣this␣saves␣you␣from␣having␣to␣deal␣with
two␣disk␣files␣instead␣of␣one.␣␣You␣can␣use␣a␣normalizer␣function␣to
keep␣the␣two␣sets␣of␣return␣values␣separate.␣␣For␣example:

␣␣␣␣␣␣␣␣tie␣my␣%cache␣=>␣'MLDBM',␣'DB_File',␣$filename,␣...;

	memoize␣'myfunc',
	␣␣NORMALIZER␣=>␣'n',
	␣␣SCALAR_CACHE␣=>␣[HASH␣=>␣\%cache],
	␣␣LIST_CACHE␣=>␣MERGE,
	;

	sub␣n␣{
	␣␣my␣$context␣=␣wantarray()␣?␣'L'␣:␣'S';
	␣␣#␣...␣now␣compute␣the␣hash␣key␣from␣the␣arguments␣...
	␣␣$hashkey␣=␣"$context:$hashkey";
	}

This␣normalizer␣function␣will␣store␣scalar␣context␣return␣values␣in
the␣disk␣file␣under␣keys␣that␣begin␣with␣C<S:>,␣and␣list␣context
return␣values␣under␣keys␣that␣begin␣with␣C<L:>.

=back

=head1␣OTHER␣FACILITIES

=head2␣C<unmemoize>

There's␣an␣C<unmemoize>␣function␣that␣you␣can␣import␣if␣you␣want␣to.
Why␣would␣you␣want␣to?␣␣Here's␣an␣example:␣Suppose␣you␣have␣your␣cache
tied␣to␣a␣DBM␣file,␣and␣you␣want␣to␣make␣sure␣that␣the␣cache␣is
written␣out␣to␣disk␣if␣someone␣interrupts␣the␣program.␣␣If␣the␣program
exits␣normally,␣this␣will␣happen␣anyway,␣but␣if␣someone␣types
control-C␣or␣something␣then␣the␣program␣will␣terminate␣immediately
without␣synchronizing␣the␣database.␣␣So␣what␣you␣can␣do␣instead␣is

␣␣␣␣$SIG{INT}␣=␣sub␣{␣unmemoize␣'function'␣};

C<unmemoize>␣accepts␣a␣reference␣to,␣or␣the␣name␣of␣a␣previously
memoized␣function,␣and␣undoes␣whatever␣it␣did␣to␣provide␣the␣memoized
version␣in␣the␣first␣place,␣including␣making␣the␣name␣refer␣to␣the
unmemoized␣version␣if␣appropriate.␣␣It␣returns␣a␣reference␣to␣the
unmemoized␣version␣of␣the␣function.

If␣you␣ask␣it␣to␣unmemoize␣a␣function␣that␣was␣never␣memoized,␣it
croaks.

=head2␣C<flush_cache>

C<flush_cache(function)>␣will␣flush␣out␣the␣caches,␣discarding␣I<all>
the␣cached␣data.␣␣The␣argument␣may␣be␣a␣function␣name␣or␣a␣reference
to␣a␣function.␣␣For␣finer␣control␣over␣when␣data␣is␣discarded␣or
expired,␣see␣the␣documentation␣for␣C<Memoize::Expire>,␣included␣in
this␣package.

Note␣that␣if␣the␣cache␣is␣a␣tied␣hash,␣C<flush_cache>␣will␣attempt␣to
invoke␣the␣C<CLEAR>␣method␣on␣the␣hash.␣␣If␣there␣is␣no␣C<CLEAR>
method,␣this␣will␣cause␣a␣run-time␣error.

An␣alternative␣approach␣to␣cache␣flushing␣is␣to␣use␣the␣C<HASH>␣option
(see␣above)␣to␣request␣that␣C<Memoize>␣use␣a␣particular␣hash␣variable
as␣its␣cache.␣␣Then␣you␣can␣examine␣or␣modify␣the␣hash␣at␣any␣time␣in
any␣way␣you␣desire.␣␣You␣may␣flush␣the␣cache␣by␣using␣C<%hash␣=␣()>.␣

=head1␣CAVEATS

Memoization␣is␣not␣a␣cure-all:

=over␣4

=item␣*

Do␣not␣memoize␣a␣function␣whose␣behavior␣depends␣on␣program
state␣other␣than␣its␣own␣arguments,␣such␣as␣global␣variables,␣the␣time
of␣day,␣or␣file␣input.␣␣These␣functions␣will␣not␣produce␣correct
results␣when␣memoized.␣␣For␣a␣particularly␣easy␣example:

	sub␣f␣{
	␣␣time;
	}

This␣function␣takes␣no␣arguments,␣and␣as␣far␣as␣C<Memoize>␣is
concerned,␣it␣always␣returns␣the␣same␣result.␣␣C<Memoize>␣is␣wrong,␣of
course,␣and␣the␣memoized␣version␣of␣this␣function␣will␣call␣C<time>␣once
to␣get␣the␣current␣time,␣and␣it␣will␣return␣that␣same␣time
every␣time␣you␣call␣it␣after␣that.

=item␣*

Do␣not␣memoize␣a␣function␣with␣side␣effects.

	sub␣f␣{
	␣␣my␣($a,␣$b)␣=␣@_;
␣␣␣␣␣␣␣␣␣␣my␣$s␣=␣$a␣+␣$b;
	␣␣print␣"$a␣+␣$b␣=␣$s.\n";
	}

This␣function␣accepts␣two␣arguments,␣adds␣them,␣and␣prints␣their␣sum.
Its␣return␣value␣is␣the␣numuber␣of␣characters␣it␣printed,␣but␣you
probably␣didn't␣care␣about␣that.␣␣But␣C<Memoize>␣doesn't␣understand
that.␣␣If␣you␣memoize␣this␣function,␣you␣will␣get␣the␣result␣you
expect␣the␣first␣time␣you␣ask␣it␣to␣print␣the␣sum␣of␣2␣and␣3,␣but
subsequent␣calls␣will␣return␣1␣(the␣return␣value␣of
C<print>)␣without␣actually␣printing␣anything.

=item␣*

Do␣not␣memoize␣a␣function␣that␣returns␣a␣data␣structure␣that␣is
modified␣by␣its␣caller.

Consider␣these␣functions:␣␣C<getusers>␣returns␣a␣list␣of␣users␣somehow,
and␣then␣C<main>␣throws␣away␣the␣first␣user␣on␣the␣list␣and␣prints␣the
rest:

	sub␣main␣{
	␣␣my␣$userlist␣=␣getusers();
	␣␣shift␣@$userlist;
	␣␣foreach␣$u␣(@$userlist)␣{
	␣␣␣␣print␣"User␣$u\n";
	␣␣}
	}

	sub␣getusers␣{
	␣␣my␣@users;
	␣␣#␣Do␣something␣to␣get␣a␣list␣of␣users;
	␣␣\@users;␣␣#␣Return␣reference␣to␣list.
	}

If␣you␣memoize␣C<getusers>␣here,␣it␣will␣work␣right␣exactly␣once.␣␣The
reference␣to␣the␣users␣list␣will␣be␣stored␣in␣the␣memo␣table.␣␣C<main>
will␣discard␣the␣first␣element␣from␣the␣referenced␣list.␣␣The␣next
time␣you␣invoke␣C<main>,␣C<Memoize>␣will␣not␣call␣C<getusers>;␣it␣will
just␣return␣the␣same␣reference␣to␣the␣same␣list␣it␣got␣last␣time.␣␣But
this␣time␣the␣list␣has␣already␣had␣its␣head␣removed;␣C<main>␣will
erroneously␣remove␣another␣element␣from␣it.␣␣The␣list␣will␣get␣shorter
and␣shorter␣every␣time␣you␣call␣C<main>.

Similarly,␣this:

	$u1␣=␣getusers();␣␣␣␣
	$u2␣=␣getusers();␣␣␣␣
	pop␣@$u1;

will␣modify␣$u2␣as␣well␣as␣$u1,␣because␣both␣variables␣are␣references
to␣the␣same␣array.␣␣Had␣C<getusers>␣not␣been␣memoized,␣$u1␣and␣$u2
would␣have␣referred␣to␣different␣arrays.

=item␣*␣

Do␣not␣memoize␣a␣very␣simple␣function.

Recently␣someone␣mentioned␣to␣me␣that␣the␣Memoize␣module␣made␣his
program␣run␣slower␣instead␣of␣faster.␣␣It␣turned␣out␣that␣he␣was
memoizing␣the␣following␣function:

␣␣␣␣sub␣square␣{
␣␣␣␣␣␣$_[0]␣*␣$_[0];
␣␣␣␣}

I␣pointed␣out␣that␣C<Memoize>␣uses␣a␣hash,␣and␣that␣looking␣up␣a
number␣in␣the␣hash␣is␣necessarily␣going␣to␣take␣a␣lot␣longer␣than␣a
single␣multiplication.␣␣There␣really␣is␣no␣way␣to␣speed␣up␣the
C<square>␣function.

Memoization␣is␣not␣magical.

=back

=head1␣PERSISTENT␣CACHE␣SUPPORT

You␣can␣tie␣the␣cache␣tables␣to␣any␣sort␣of␣tied␣hash␣that␣you␣want
to,␣as␣long␣as␣it␣supports␣C<TIEHASH>,␣C<FETCH>,␣C<STORE>,␣and
C<EXISTS>.␣␣For␣example,

␣␣␣␣␣␣␣␣tie␣my␣%cache␣=>␣'GDBM_File',␣$filename,␣O_RDWR|O_CREAT,␣0666;
␣␣␣␣␣␣␣␣memoize␣'function',␣SCALAR_CACHE␣=>␣[HASH␣=>␣\%cache];

works␣just␣fine.␣␣For␣some␣storage␣methods,␣you␣need␣a␣little␣glue.

C<SDBM_File>␣doesn't␣supply␣an␣C<EXISTS>␣method,␣so␣included␣in␣this
package␣is␣a␣glue␣module␣called␣C<Memoize::SDBM_File>␣which␣does
provide␣one.␣␣Use␣this␣instead␣of␣plain␣C<SDBM_File>␣to␣store␣your
cache␣table␣on␣disk␣in␣an␣C<SDBM_File>␣database:

␣␣␣␣␣␣␣␣tie␣my␣%cache␣=>␣'Memoize::SDBM_File',␣$filename,␣O_RDWR|O_CREAT,␣0666;
␣␣␣␣␣␣␣␣memoize␣'function',␣SCALAR_CACHE␣=>␣[HASH␣=>␣\%cache];

C<NDBM_File>␣has␣the␣same␣problem␣and␣the␣same␣solution.␣␣(Use
C<Memoize::NDBM_File␣instead␣of␣plain␣NDBM_File.>)

C<Storable>␣isn't␣a␣tied␣hash␣class␣at␣all.␣␣You␣can␣use␣it␣to␣store␣a
hash␣to␣disk␣and␣retrieve␣it␣again,␣but␣you␣can't␣modify␣the␣hash␣while
it's␣on␣the␣disk.␣␣So␣if␣you␣want␣to␣store␣your␣cache␣table␣in␣a
C<Storable>␣database,␣use␣C<Memoize::Storable>,␣which␣puts␣a␣hashlike
front-end␣onto␣C<Storable>.␣␣The␣hash␣table␣is␣actually␣kept␣in
memory,␣and␣is␣loaded␣from␣your␣C<Storable>␣file␣at␣the␣time␣you
memoize␣the␣function,␣and␣stored␣back␣at␣the␣time␣you␣unmemoize␣the
function␣(or␣when␣your␣program␣exits):

␣␣␣␣␣␣␣␣tie␣my␣%cache␣=>␣'Memoize::Storable',␣$filename;
	memoize␣'function',␣SCALAR_CACHE␣=>␣[HASH␣=>␣\%cache];

␣␣␣␣␣␣␣␣tie␣my␣%cache␣=>␣'Memoize::Storable',␣$filename,␣'nstore';
	memoize␣'function',␣SCALAR_CACHE␣=>␣[HASH␣=>␣\%cache];

Include␣the␣`nstore'␣option␣to␣have␣the␣C<Storable>␣database␣written
in␣`network␣order'.␣␣(See␣L<Storable>␣for␣more␣details␣about␣this.)

The␣C<flush_cache()>␣function␣will␣raise␣a␣run-time␣error␣unless␣the
tied␣package␣provides␣a␣C<CLEAR>␣method.

=head1␣EXPIRATION␣SUPPORT

See␣Memoize::Expire,␣which␣is␣a␣plug-in␣module␣that␣adds␣expiration
functionality␣to␣Memoize.␣␣If␣you␣don't␣like␣the␣kinds␣of␣policies
that␣Memoize::Expire␣implements,␣it␣is␣easy␣to␣write␣your␣own␣plug-in
module␣to␣implement␣whatever␣policy␣you␣desire.␣␣Memoize␣comes␣with
several␣examples.␣␣An␣expiration␣manager␣that␣implements␣a␣LRU␣policy
is␣available␣on␣CPAN␣as␣Memoize::ExpireLRU.

=head1␣BUGS

The␣test␣suite␣is␣much␣better,␣but␣always␣needs␣improvement.

There␣is␣some␣problem␣with␣the␣way␣C<goto␣&f>␣works␣under␣threaded
Perl,␣perhaps␣because␣of␣the␣lexical␣scoping␣of␣C<@_>.␣␣This␣is␣a␣bug
in␣Perl,␣and␣until␣it␣is␣resolved,␣memoized␣functions␣will␣see␣a
slightly␣different␣C<caller()>␣and␣will␣perform␣a␣little␣more␣slowly
on␣threaded␣perls␣than␣unthreaded␣perls.

Some␣versions␣of␣C<DB_File>␣won't␣let␣you␣store␣data␣under␣a␣key␣of
length␣0.␣␣That␣means␣that␣if␣you␣have␣a␣function␣C<f>␣which␣you
memoized␣and␣the␣cache␣is␣in␣a␣C<DB_File>␣database,␣then␣the␣value␣of
C<f()>␣(C<f>␣called␣with␣no␣arguments)␣will␣not␣be␣memoized.␣␣If␣this
is␣a␣big␣problem,␣you␣can␣supply␣a␣normalizer␣function␣that␣prepends
C<"x">␣to␣every␣key.

=head1␣MAILING␣LIST

To␣join␣a␣very␣low-traffic␣mailing␣list␣for␣announcements␣about
C<Memoize>,␣send␣an␣empty␣note␣to␣C<mjd-perl-memoize-request@plover.com>.

=head1␣AUTHOR

Mark-Jason␣Dominus␣(C<mjd-perl-memoize+@plover.com>),␣Plover␣Systems␣co.

See␣the␣C<Memoize.pm>␣Page␣at␣http://www.plover.com/~mjd/perl/Memoize/
for␣news␣and␣upgrades.␣␣Near␣this␣page,␣at
http://www.plover.com/~mjd/perl/MiniMemoize/␣there␣is␣an␣article␣about
memoization␣and␣about␣the␣internals␣of␣Memoize␣that␣appeared␣in␣The
Perl␣Journal,␣issue␣#13.␣␣(This␣article␣is␣also␣included␣in␣the
Memoize␣distribution␣as␣`article.html'.)

The␣author's␣book␣I<Higher␣Order␣Perl>␣(2005,␣ISBN␣1558607013,␣published
by␣Morgan␣Kaufmann)␣discusses␣memoization␣(and␣many␣other␣fascinating
topics)␣in␣tremendous␣detail.␣It␣will␣also␣be␣available␣on-line␣for␣free.
For␣more␣information,␣visit␣http://perl.plover.com/book/␣.

To␣join␣a␣mailing␣list␣for␣announcements␣about␣C<Memoize>,␣send␣an
empty␣message␣to␣C<mjd-perl-memoize-request@plover.com>.␣␣This␣mailing
list␣is␣for␣announcements␣only␣and␣has␣extremely␣low␣traffic---about
two␣messages␣per␣year.

=head1␣COPYRIGHT␣AND␣LICENSE

Copyright␣1998,␣1999,␣2000,␣2001␣␣by␣Mark␣Jason␣Dominus

This␣library␣is␣free␣software;␣you␣may␣redistribute␣it␣and/or␣modify
it␣under␣the␣same␣terms␣as␣Perl␣itself.

=head1␣THANK␣YOU

Many␣thanks␣to␣Jonathan␣Roy␣for␣bug␣reports␣and␣suggestions,␣to
Michael␣Schwern␣for␣other␣bug␣reports␣and␣patches,␣to␣Mike␣Cariaso␣for
helping␣me␣to␣figure␣out␣the␣Right␣Thing␣to␣Do␣About␣Expiration,␣to
Joshua␣Gerth,␣Joshua␣Chamas,␣Jonathan␣Roy␣(again),␣Mark␣D.␣Anderson,
and␣Andrew␣Johnson␣for␣more␣suggestions␣about␣expiration,␣to␣Brent
Powers␣for␣the␣Memoize::ExpireLRU␣module,␣to␣Ariel␣Scolnicov␣for
delightful␣messages␣about␣the␣Fibonacci␣function,␣to␣Dion␣Almaer␣for
thought-provoking␣suggestions␣about␣the␣default␣normalizer,␣to␣Walt
Mankowski␣and␣Kurt␣Starsinic␣for␣much␣help␣investigating␣problems
under␣threaded␣Perl,␣to␣Alex␣Dudkevich␣for␣reporting␣the␣bug␣in
prototyped␣functions␣and␣for␣checking␣my␣patch,␣to␣Tony␣Bass␣for␣many
helpful␣suggestions,␣to␣Jonathan␣Roy␣(again)␣for␣finding␣a␣use␣for
C<unmemoize()>,␣to␣Philippe␣Verdret␣for␣enlightening␣discussion␣of
C<Hook::PrePostCall>,␣to␣Nat␣Torkington␣for␣advice␣I␣ignored,␣to␣Chris
Nandor␣for␣portability␣advice,␣to␣Randal␣Schwartz␣for␣suggesting␣the
'C<flush_cache>␣function,␣and␣to␣Jenda␣Krynicky␣for␣being␣a␣light␣in
the␣world.

Special␣thanks␣to␣Jarkko␣Hietaniemi,␣the␣5.8.0␣pumpking,␣for␣including
this␣module␣in␣the␣core␣and␣for␣his␣patient␣and␣helpful␣guidance
during␣the␣integration␣process.

=cut
package␣CPAN::Shell;
use␣strict;

#␣-*-␣Mode:␣cperl;␣coding:␣utf-8;␣cperl-indent-level:␣4␣-*-
#␣vim:␣ts=4␣sts=4␣sw=4:

use␣vars␣qw(
␣␣␣␣␣␣␣␣␣␣␣␣$ADVANCED_QUERY
␣␣␣␣␣␣␣␣␣␣␣␣$AUTOLOAD
␣␣␣␣␣␣␣␣␣␣␣␣$COLOR_REGISTERED
␣␣␣␣␣␣␣␣␣␣␣␣$Help
␣␣␣␣␣␣␣␣␣␣␣␣$autoload_recursion
␣␣␣␣␣␣␣␣␣␣␣␣$reload
␣␣␣␣␣␣␣␣␣␣␣␣@ISA
␣␣␣␣␣␣␣␣␣␣␣␣@relo
␣␣␣␣␣␣␣␣␣␣␣␣$VERSION
␣␣␣␣␣␣␣␣␣␣␣);
@relo␣=␣␣␣␣␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Author.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/CacheMgr.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Complete.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Debug.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/DeferredCode.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Distribution.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Distroprefs.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Distrostatus.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Exception/RecursiveDependency.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Exception/yaml_not_installed.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/FirstTime.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/FTP.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/FTP/netrc.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/HandleConfig.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Index.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/InfoObj.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Kwalify.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/LWP/UserAgent.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Module.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Prompt.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Queue.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Reporter/Config.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Reporter/History.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Reporter/PrereqCheck.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Reporter.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Shell.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/SQLite.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Tarzip.pm",
␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN/Version.pm",
␣␣␣␣␣␣␣␣␣␣␣␣);
$VERSION␣=␣"5.5001";
#␣record␣the␣initial␣timestamp␣for␣reload.
$reload␣=␣{␣map␣{$INC{$_}␣?␣($_,(stat␣$INC{$_})[9])␣:␣()}␣@relo␣};
@CPAN::Shell::ISA␣=␣qw(CPAN::Debug);
use␣Cwd␣qw(chdir);
use␣Carp␣();
$COLOR_REGISTERED␣||=␣0;
$Help␣=␣{
␣␣␣␣␣␣␣␣␣'?'␣=>␣\"help",
␣␣␣␣␣␣␣␣␣'!'␣=>␣"eval␣the␣rest␣of␣the␣line␣as␣perl",
␣␣␣␣␣␣␣␣␣a␣=>␣"whois␣author",
␣␣␣␣␣␣␣␣␣autobundle␣=>␣"write␣inventory␣into␣a␣bundle␣file",
␣␣␣␣␣␣␣␣␣b␣=>␣"info␣about␣bundle",
␣␣␣␣␣␣␣␣␣bye␣=>␣\"quit",
␣␣␣␣␣␣␣␣␣clean␣=>␣"clean␣up␣a␣distribution's␣build␣directory",
␣␣␣␣␣␣␣␣␣#␣cvs_import
␣␣␣␣␣␣␣␣␣d␣=>␣"info␣about␣a␣distribution",
␣␣␣␣␣␣␣␣␣#␣dump
␣␣␣␣␣␣␣␣␣exit␣=>␣\"quit",
␣␣␣␣␣␣␣␣␣failed␣=>␣"list␣all␣failed␣actions␣within␣current␣session",
␣␣␣␣␣␣␣␣␣fforce␣=>␣"redo␣a␣command␣from␣scratch",
␣␣␣␣␣␣␣␣␣force␣=>␣"redo␣a␣command",
␣␣␣␣␣␣␣␣␣get␣=>␣"download␣a␣distribution",
␣␣␣␣␣␣␣␣␣h␣=>␣\"help",
␣␣␣␣␣␣␣␣␣help␣=>␣"overview␣over␣commands;␣'help␣...'␣explains␣specific␣commands",
␣␣␣␣␣␣␣␣␣hosts␣=>␣"statistics␣about␣recently␣used␣hosts",
␣␣␣␣␣␣␣␣␣i␣=>␣"info␣about␣authors/bundles/distributions/modules",
␣␣␣␣␣␣␣␣␣install␣=>␣"install␣a␣distribution",
␣␣␣␣␣␣␣␣␣install_tested␣=>␣"install␣all␣distributions␣tested␣OK",
␣␣␣␣␣␣␣␣␣is_tested␣=>␣"list␣all␣distributions␣tested␣OK",
␣␣␣␣␣␣␣␣␣look␣=>␣"open␣a␣subshell␣in␣a␣distribution's␣directory",
␣␣␣␣␣␣␣␣␣ls␣=>␣"list␣distributions␣matching␣a␣fileglob",
␣␣␣␣␣␣␣␣␣m␣=>␣"info␣about␣a␣module",
␣␣␣␣␣␣␣␣␣make␣=>␣"make/build␣a␣distribution",
␣␣␣␣␣␣␣␣␣mkmyconfig␣=>␣"write␣current␣config␣into␣a␣CPAN/MyConfig.pm␣file",
␣␣␣␣␣␣␣␣␣notest␣=>␣"run␣a␣(usually␣install)␣command␣but␣leave␣out␣the␣test␣phase",
␣␣␣␣␣␣␣␣␣o␣=>␣"'o␣conf␣...'␣for␣config␣stuff;␣'o␣debug␣...'␣for␣debugging",
␣␣␣␣␣␣␣␣␣perldoc␣=>␣"try␣to␣get␣a␣manpage␣for␣a␣module",
␣␣␣␣␣␣␣␣␣q␣=>␣\"quit",
␣␣␣␣␣␣␣␣␣quit␣=>␣"leave␣the␣cpan␣shell",
␣␣␣␣␣␣␣␣␣r␣=>␣"review␣upgradable␣modules",
␣␣␣␣␣␣␣␣␣readme␣=>␣"display␣the␣README␣of␣a␣distro␣with␣a␣pager",
␣␣␣␣␣␣␣␣␣recent␣=>␣"show␣recent␣uploads␣to␣the␣CPAN",
␣␣␣␣␣␣␣␣␣#␣recompile
␣␣␣␣␣␣␣␣␣reload␣=>␣"'reload␣cpan'␣or␣'reload␣index'",
␣␣␣␣␣␣␣␣␣report␣=>␣"test␣a␣distribution␣and␣send␣a␣test␣report␣to␣cpantesters",
␣␣␣␣␣␣␣␣␣reports␣=>␣"info␣about␣reported␣tests␣from␣cpantesters",
␣␣␣␣␣␣␣␣␣#␣scripts
␣␣␣␣␣␣␣␣␣#␣smoke
␣␣␣␣␣␣␣␣␣test␣=>␣"test␣a␣distribution",
␣␣␣␣␣␣␣␣␣u␣=>␣"display␣uninstalled␣modules",
␣␣␣␣␣␣␣␣␣upgrade␣=>␣"combine␣'r'␣command␣with␣immediate␣installation",
␣␣␣␣␣␣␣␣};
{
␣␣␣␣$autoload_recursion␣␣␣||=␣0;

␣␣␣␣#->␣sub␣CPAN::Shell::AUTOLOAD␣;
␣␣␣␣sub␣AUTOLOAD␣{␣##␣no␣critic
␣␣␣␣␣␣␣␣$autoload_recursion++;
␣␣␣␣␣␣␣␣my($l)␣=␣$AUTOLOAD;
␣␣␣␣␣␣␣␣my␣$class␣=␣shift(@_);
␣␣␣␣␣␣␣␣#␣warn␣"autoload[$l]␣class[$class]";
␣␣␣␣␣␣␣␣$l␣=~␣s/.*:://;
␣␣␣␣␣␣␣␣if␣($CPAN::Signal)␣{
␣␣␣␣␣␣␣␣␣␣␣␣warn␣"Refusing␣to␣autoload␣'$l'␣while␣signal␣pending";
␣␣␣␣␣␣␣␣␣␣␣␣$autoload_recursion--;
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣($autoload_recursion␣>␣1)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$fullcommand␣=␣join␣"␣",␣map␣{␣"'$_'"␣}␣$l,␣@_;
␣␣␣␣␣␣␣␣␣␣␣␣warn␣"Refusing␣to␣autoload␣$fullcommand␣in␣recursion\n";
␣␣␣␣␣␣␣␣␣␣␣␣$autoload_recursion--;
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣($l␣=~␣/^w/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣#␣XXX␣needs␣to␣be␣reconsidered
␣␣␣␣␣␣␣␣␣␣␣␣if␣($CPAN::META->has_inst('CPAN::WAIT'))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CPAN::WAIT->$l(@_);
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn(qq{
Commands␣starting␣with␣"w"␣require␣CPAN::WAIT␣to␣be␣installed.
Please␣consider␣installing␣CPAN::WAIT␣to␣use␣the␣fulltext␣index.
For␣this␣you␣just␣need␣to␣type
␣␣␣␣install␣CPAN::WAIT
});
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn(qq{Unknown␣shell␣command␣'$l'.␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{Type␣?␣for␣help.
});
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$autoload_recursion--;
␣␣␣␣}
}


#->␣sub␣CPAN::Shell::h␣;
sub␣h␣{
␣␣␣␣my($class,$about)␣=␣@_;
␣␣␣␣if␣(defined␣$about)␣{
␣␣␣␣␣␣␣␣my␣$help;
␣␣␣␣␣␣␣␣if␣(exists␣$Help->{$about})␣{
␣␣␣␣␣␣␣␣␣␣␣␣if␣(ref␣$Help->{$about})␣{␣#␣aliases
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$about␣=␣${$Help->{$about}};
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$help␣=␣$Help->{$about};
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$help␣=␣"No␣help␣available";
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("$about\:␣$help\n");
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣$filler␣=␣"␣"␣x␣(80␣-␣28␣-␣length($CPAN::VERSION));
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{
Display␣Information␣$filler␣(ver␣$CPAN::VERSION)
␣command␣␣argument␣␣␣␣␣␣␣␣␣␣description
␣a,b,d,m␣␣WORD␣or␣/REGEXP/␣␣about␣authors,␣bundles,␣distributions,␣modules
␣i␣␣␣␣␣␣␣␣WORD␣or␣/REGEXP/␣␣about␣any␣of␣the␣above
␣ls␣␣␣␣␣␣␣AUTHOR␣or␣GLOB␣␣␣␣about␣files␣in␣the␣author's␣directory
␣␣␣␣(with␣WORD␣being␣a␣module,␣bundle␣or␣author␣name␣or␣a␣distribution
␣␣␣␣name␣of␣the␣form␣AUTHOR/DISTRIBUTION)

Download,␣Test,␣Make,␣Install...
␣get␣␣␣␣␣␣download␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣clean␣␣␣␣make␣clean
␣make␣␣␣␣␣make␣(implies␣get)␣␣␣␣␣␣␣␣␣␣␣look␣␣␣␣␣open␣subshell␣in␣dist␣directory
␣test␣␣␣␣␣make␣test␣(implies␣make)␣␣␣␣␣readme␣␣␣display␣these␣README␣files
␣install␣␣make␣install␣(implies␣test)␣␣perldoc␣␣display␣POD␣documentation

Upgrade
␣r␣␣␣␣␣␣␣␣WORDs␣or␣/REGEXP/␣or␣NONE␣␣␣␣report␣updates␣for␣some/matching/all␣modules
␣upgrade␣␣WORDs␣or␣/REGEXP/␣or␣NONE␣␣␣␣upgrade␣some/matching/all␣modules

Pragmas
␣force␣␣CMD␣␣␣␣try␣hard␣to␣do␣command␣␣fforce␣CMD␣␣␣␣try␣harder
␣notest␣CMD␣␣␣␣skip␣testing

Other
␣h,?␣␣␣␣␣␣␣␣␣␣␣display␣this␣menu␣␣␣␣␣␣␣!␣perl-code␣␣␣eval␣a␣perl␣command
␣o␣conf␣[opt]␣␣set␣and␣query␣options␣␣␣q␣␣␣␣␣␣␣␣␣␣␣␣␣quit␣the␣cpan␣shell
␣reload␣cpan␣␣␣load␣CPAN.pm␣again␣␣␣␣␣␣reload␣index␣␣load␣newer␣indices
␣autobundle␣␣␣␣Snapshot␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣recent␣␣␣␣␣␣␣␣latest␣CPAN␣uploads});
}
}

*help␣=␣\&h;

#->␣sub␣CPAN::Shell::a␣;
sub␣a␣{
␣␣my($self,@arg)␣=␣@_;
␣␣#␣authors␣are␣always␣UPPERCASE
␣␣for␣(@arg)␣{
␣␣␣␣$_␣=␣uc␣$_␣unless␣/=/;
␣␣}
␣␣$CPAN::Frontend->myprint($self->format_result('Author',@arg));
}

#->␣sub␣CPAN::Shell::globls␣;
sub␣globls␣{
␣␣␣␣my($self,$s,$pragmas)␣=␣@_;
␣␣␣␣#␣ls␣is␣really␣very␣different,␣but␣we␣had␣it␣once␣as␣an␣ordinary
␣␣␣␣#␣command␣in␣the␣Shell␣(upto␣rev.␣321)␣and␣we␣could␣not␣handle
␣␣␣␣#␣force␣well␣then
␣␣␣␣my(@accept,@preexpand);
␣␣␣␣if␣($s␣=~␣/[\*\?\/]/)␣{
␣␣␣␣␣␣␣␣if␣($CPAN::META->has_inst("Text::Glob"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣if␣(my($au,$pathglob)␣=␣$s␣=~␣m|(.*?)/(.*)|)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$rau␣=␣Text::Glob::glob_to_regex(uc␣$au);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CPAN::Shell->debug("au[$au]pathglob[$pathglob]rau[$rau]")
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@preexpand,␣map␣{␣$_->id␣.␣"/"␣.␣$pathglob␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CPAN::Shell->expand_by_method('CPAN::Author',['id'],"/$rau/");
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$rau␣=␣Text::Glob::glob_to_regex(uc␣$s);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@preexpand,␣map␣{␣$_->id␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CPAN::Shell->expand_by_method('CPAN::Author',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣['id'],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"/$rau/");
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Text::Glob␣not␣installed,␣cannot␣proceed");
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣push␣@preexpand,␣uc␣$s;
␣␣␣␣}
␣␣␣␣for␣(@preexpand)␣{
␣␣␣␣␣␣␣␣unless␣(/^[A-Z0-9\-]+(\/|$)/i)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("ls␣command␣rejects␣argument␣$_:␣not␣an␣author\n");
␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣push␣@accept,␣$_;
␣␣␣␣}
␣␣␣␣my␣$silent␣=␣@accept>1;
␣␣␣␣my␣$last_alpha␣=␣"";
␣␣␣␣my␣@results;
␣␣␣␣for␣my␣$a␣(@accept)␣{
␣␣␣␣␣␣␣␣my($author,$pathglob);
␣␣␣␣␣␣␣␣if␣($a␣=~␣m|(.*?)/(.*)|)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$a2␣=␣$1;
␣␣␣␣␣␣␣␣␣␣␣␣$pathglob␣=␣$2;
␣␣␣␣␣␣␣␣␣␣␣␣$author␣=␣CPAN::Shell->expand_by_method('CPAN::Author',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣['id'],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$a2)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣or␣$CPAN::Frontend->mydie("No␣author␣found␣for␣$a2\n");
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$author␣=␣CPAN::Shell->expand_by_method('CPAN::Author',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣['id'],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$a)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣or␣$CPAN::Frontend->mydie("No␣author␣found␣for␣$a\n");
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣($silent)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$alpha␣=␣substr␣$author->id,␣0,␣1;
␣␣␣␣␣␣␣␣␣␣␣␣my␣$ad;
␣␣␣␣␣␣␣␣␣␣␣␣if␣($alpha␣eq␣$last_alpha)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$ad␣=␣"";
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$ad␣=␣"[$alpha]";
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$last_alpha␣=␣$alpha;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint($ad);
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣for␣my␣$pragma␣(@$pragmas)␣{
␣␣␣␣␣␣␣␣␣␣␣␣if␣($author->can($pragma))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$author->$pragma();
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣CPAN->debug("author[$author]pathglob[$pathglob]silent[$silent]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣push␣@results,␣$author->ls($pathglob,$silent);␣#␣silent␣if
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣more␣than␣one
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣author
␣␣␣␣␣␣␣␣for␣my␣$pragma␣(@$pragmas)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$unpragma␣=␣"un$pragma";
␣␣␣␣␣␣␣␣␣␣␣␣if␣($author->can($unpragma))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$author->$unpragma();
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣@results;
}

#->␣sub␣CPAN::Shell::local_bundles␣;
sub␣local_bundles␣{
␣␣␣␣my($self,@which)␣=␣@_;
␣␣␣␣my($incdir,$bdir,$dh);
␣␣␣␣foreach␣$incdir␣($CPAN::Config->{'cpan_home'},@INC)␣{
␣␣␣␣␣␣␣␣my␣@bbase␣=␣"Bundle";
␣␣␣␣␣␣␣␣while␣(my␣$bbase␣=␣shift␣@bbase)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$bdir␣=␣File::Spec->catdir($incdir,split␣/::/,␣$bbase);
␣␣␣␣␣␣␣␣␣␣␣␣CPAN->debug("bdir[$bdir]\@bbase[@bbase]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣␣␣␣␣if␣($dh␣=␣DirHandle->new($bdir))␣{␣#␣may␣fail
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my($entry);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣for␣$entry␣($dh->read)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣if␣$entry␣=~␣/^\./;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣$entry␣=~␣/^\w+(\.pm)?(?!\n)\Z/;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(-d␣File::Spec->catdir($bdir,$entry))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@bbase,␣"$bbase\::$entry";
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣$entry␣=~␣s/\.pm(?!\n)\Z//;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::META->instance('CPAN::Bundle',"$bbase\::$entry");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣}
}

#->␣sub␣CPAN::Shell::b␣;
sub␣b␣{
␣␣␣␣my($self,@which)␣=␣@_;
␣␣␣␣CPAN->debug("which[@which]")␣if␣$CPAN::DEBUG;
␣␣␣␣$self->local_bundles;
␣␣␣␣$CPAN::Frontend->myprint($self->format_result('Bundle',@which));
}

#->␣sub␣CPAN::Shell::d␣;
sub␣d␣{␣$CPAN::Frontend->myprint(shift->format_result('Distribution',@_));}

#->␣sub␣CPAN::Shell::m␣;
sub␣m␣{␣#␣emacs␣confused␣here␣};␣sub␣mimimimimi␣{␣#␣emacs␣in␣sync␣here
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣@m␣=␣@_;
␣␣␣␣for␣(@m)␣{
␣␣␣␣␣␣␣␣if␣(m|(?:\w+/)*\w+\.pm$|)␣{␣#␣same␣regexp␣in␣expandany
␣␣␣␣␣␣␣␣␣␣␣␣s/.pm$//;
␣␣␣␣␣␣␣␣␣␣␣␣s|/|::|g;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣$CPAN::Frontend->myprint($self->format_result('Module',@m));
}

#->␣sub␣CPAN::Shell::i␣;
sub␣i␣{
␣␣␣␣my($self)␣=␣shift;
␣␣␣␣my(@args)␣=␣@_;
␣␣␣␣@args␣=␣'/./'␣unless␣@args;
␣␣␣␣my(@result);
␣␣␣␣for␣my␣$type␣(qw/Bundle␣Distribution␣Module/)␣{
␣␣␣␣␣␣␣␣push␣@result,␣$self->expand($type,@args);
␣␣␣␣}
␣␣␣␣#␣Authors␣are␣always␣uppercase.
␣␣␣␣push␣@result,␣$self->expand("Author",␣map␣{␣uc␣$_␣}␣@args);

␣␣␣␣my␣$result␣=␣@result␣==␣1␣?
␣␣␣␣␣␣␣␣$result[0]->as_string␣:
␣␣␣␣␣␣␣␣␣␣␣␣@result␣==␣0␣?
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"No␣objects␣found␣of␣any␣type␣for␣argument␣@args\n"␣:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣join("",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(map␣{$_->as_glimpse}␣@result),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣scalar␣@result,␣"␣items␣found\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣$CPAN::Frontend->myprint($result);
}

#->␣sub␣CPAN::Shell::o␣;

#␣CPAN::Shell::o␣and␣CPAN::HandleConfig::edit␣are␣closely␣related.␣'o
#␣conf'␣calls␣through␣to␣CPAN::HandleConfig::edit.␣'o␣conf'␣should
#␣probably␣have␣been␣called␣'set'␣and␣'o␣debug'␣maybe␣'set␣debug'␣or
#␣'debug';␣'o␣conf␣ARGS'␣calls␣->edit␣in␣CPAN/HandleConfig.pm
sub␣o␣{
␣␣␣␣my($self,$o_type,@o_what)␣=␣@_;
␣␣␣␣$o_type␣||=␣"";
␣␣␣␣CPAN->debug("o_type[$o_type]␣o_what[".join("␣|␣",@o_what)."]\n");
␣␣␣␣if␣($o_type␣eq␣'conf')␣{
␣␣␣␣␣␣␣␣my($cfilter);
␣␣␣␣␣␣␣␣($cfilter)␣=␣$o_what[0]␣=~␣m|^/(.*)/$|␣if␣@o_what;
␣␣␣␣␣␣␣␣if␣(!@o_what␣or␣$cfilter)␣{␣#␣print␣all␣things,␣"o␣conf"
␣␣␣␣␣␣␣␣␣␣␣␣$cfilter␣||=␣"";
␣␣␣␣␣␣␣␣␣␣␣␣my␣$qrfilter␣=␣eval␣'qr/$cfilter/';
␣␣␣␣␣␣␣␣␣␣␣␣my($k,$v);
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("\$CPAN::Config␣options␣from␣");
␣␣␣␣␣␣␣␣␣␣␣␣my␣@from;
␣␣␣␣␣␣␣␣␣␣␣␣if␣(exists␣$INC{'CPAN/Config.pm'})␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@from,␣$INC{'CPAN/Config.pm'};
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣if␣(exists␣$INC{'CPAN/MyConfig.pm'})␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@from,␣$INC{'CPAN/MyConfig.pm'};
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(join␣"␣and␣",␣map␣{"'$_'"}␣@from);
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(":\n");
␣␣␣␣␣␣␣␣␣␣␣␣for␣$k␣(sort␣keys␣%CPAN::HandleConfig::can)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣$k␣=~␣/$qrfilter/;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$v␣=␣$CPAN::HandleConfig::can{$k};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(sprintf␣"␣␣␣␣%-18s␣[%s]\n",␣$k,␣$v);
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("\n");
␣␣␣␣␣␣␣␣␣␣␣␣for␣$k␣(sort␣keys␣%CPAN::HandleConfig::keys)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣$k␣=~␣/$qrfilter/;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CPAN::HandleConfig->prettyprint($k);
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("\n");
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣if␣(CPAN::HandleConfig->edit(@o_what))␣{
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{Type␣'o␣conf'␣to␣view␣all␣configuration␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{items\n\n});
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣elsif␣($o_type␣eq␣'debug')␣{
␣␣␣␣␣␣␣␣my(%valid);
␣␣␣␣␣␣␣␣@o_what␣=␣()␣if␣defined␣$o_what[0]␣&&␣$o_what[0]␣=~␣/help/i;
␣␣␣␣␣␣␣␣if␣(@o_what)␣{
␣␣␣␣␣␣␣␣␣␣␣␣while␣(@o_what)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my($what)␣=␣shift␣@o_what;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($what␣=~␣s/^-//␣&&␣exists␣$CPAN::DEBUG{$what})␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::DEBUG␣&=␣$CPAN::DEBUG␣^␣$CPAN::DEBUG{$what};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(␣exists␣$CPAN::DEBUG{$what}␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::DEBUG␣|=␣$CPAN::DEBUG{$what};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣($what␣=~␣/^\d/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::DEBUG␣=␣$what;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣(lc␣$what␣eq␣'all')␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my($max)␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣for␣(values␣%CPAN::DEBUG)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$max␣+=␣$_;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::DEBUG␣=␣$max;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my($known)␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣for␣(keys␣%CPAN::DEBUG)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣lc($_)␣eq␣lc($what);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::DEBUG␣|=␣$CPAN::DEBUG{$_};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$known␣=␣1;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("unknown␣argument␣[$what]\n")
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣unless␣$known;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$raw␣=␣"Valid␣options␣for␣debug␣are␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣join(",␣",sort(keys␣%CPAN::DEBUG),␣'all').
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{␣or␣a␣number.␣Completion␣works␣on␣the␣options.␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{Case␣is␣ignored.};
␣␣␣␣␣␣␣␣␣␣␣␣require␣Text::Wrap;
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(Text::Wrap::fill("","",$raw));
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("\n\n");
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣($CPAN::DEBUG)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("Options␣set␣for␣debugging␣($CPAN::DEBUG):\n");
␣␣␣␣␣␣␣␣␣␣␣␣my($k,$v);
␣␣␣␣␣␣␣␣␣␣␣␣for␣$k␣(sort␣{$CPAN::DEBUG{$a}␣<=>␣$CPAN::DEBUG{$b}}␣keys␣%CPAN::DEBUG)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$v␣=␣$CPAN::DEBUG{$k};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(sprintf␣"␣␣␣␣%-14s(%s)\n",␣$k,␣$v)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣$v␣&␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("Debugging␣turned␣off␣completely.\n");
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{
Known␣options:
␣␣conf␣␣␣␣set␣or␣get␣configuration␣variables
␣␣debug␣␣␣set␣or␣get␣debugging␣options
});
␣␣␣␣}
}

#␣CPAN::Shell::paintdots_onreload
sub␣paintdots_onreload␣{
␣␣␣␣my($ref)␣=␣shift;
␣␣␣␣sub␣{
␣␣␣␣␣␣␣␣if␣(␣$_[0]␣=~␣/[Ss]ubroutine␣([\w:]+)␣redefined/␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my($subr)␣=␣$1;
␣␣␣␣␣␣␣␣␣␣␣␣++$$ref;
␣␣␣␣␣␣␣␣␣␣␣␣local($|)␣=␣1;
␣␣␣␣␣␣␣␣␣␣␣␣#␣$CPAN::Frontend->myprint(".($subr)");
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(".");
␣␣␣␣␣␣␣␣␣␣␣␣if␣($subr␣=~␣/\bshell\b/i)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣warn␣"debug[$_[0]]";

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣It␣would␣be␣nice␣if␣we␣could␣detect␣that␣a
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣subroutine␣has␣actually␣changed,␣but␣for␣now␣we
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣practically␣always␣set␣the␣GOTOSHELL␣global

␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::GOTOSHELL=1;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣warn␣@_;
␣␣␣␣};
}

#->␣sub␣CPAN::Shell::hosts␣;
sub␣hosts␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣my␣$fullstats␣=␣CPAN::FTP->_ftp_statistics();
␣␣␣␣my␣$history␣=␣$fullstats->{history}␣||␣[];
␣␣␣␣my␣%S;␣#␣statistics
␣␣␣␣while␣(my␣$last␣=␣pop␣@$history)␣{
␣␣␣␣␣␣␣␣my␣$attempts␣=␣$last->{attempts}␣or␣next;
␣␣␣␣␣␣␣␣my␣$start;
␣␣␣␣␣␣␣␣if␣(@$attempts)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$start␣=␣$attempts->[-1]{start};
␣␣␣␣␣␣␣␣␣␣␣␣if␣($#$attempts␣>␣0)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣for␣my␣$i␣(0..$#$attempts-1)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$url␣=␣$attempts->[$i]{url}␣or␣next;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$S{no}{$url}++;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$start␣=␣$last->{start};
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣next␣unless␣$last->{thesiteurl};␣#␣C-C?␣bad␣filenames?
␣␣␣␣␣␣␣␣$S{start}␣=␣$start;
␣␣␣␣␣␣␣␣$S{end}␣||=␣$last->{end};
␣␣␣␣␣␣␣␣my␣$dltime␣=␣$last->{end}␣-␣$start;
␣␣␣␣␣␣␣␣my␣$dlsize␣=␣$last->{filesize}␣||␣0;
␣␣␣␣␣␣␣␣my␣$url␣=␣ref␣$last->{thesiteurl}␣?␣$last->{thesiteurl}->text␣:␣$last->{thesiteurl};
␣␣␣␣␣␣␣␣my␣$s␣=␣$S{ok}{$url}␣||=␣{};
␣␣␣␣␣␣␣␣$s->{n}++;
␣␣␣␣␣␣␣␣$s->{dlsize}␣||=␣0;
␣␣␣␣␣␣␣␣$s->{dlsize}␣+=␣$dlsize/1024;
␣␣␣␣␣␣␣␣$s->{dltime}␣||=␣0;
␣␣␣␣␣␣␣␣$s->{dltime}␣+=␣$dltime;
␣␣␣␣}
␣␣␣␣my␣$res;
␣␣␣␣for␣my␣$url␣(keys␣%{$S{ok}})␣{
␣␣␣␣␣␣␣␣next␣if␣$S{ok}{$url}{dltime}␣==␣0;␣#␣div␣by␣zero
␣␣␣␣␣␣␣␣push␣@{$res->{ok}},␣[@{$S{ok}{$url}}{qw(n␣dlsize␣dltime)},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$S{ok}{$url}{dlsize}/$S{ok}{$url}{dltime},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$url,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣];
␣␣␣␣}
␣␣␣␣for␣my␣$url␣(keys␣%{$S{no}})␣{
␣␣␣␣␣␣␣␣push␣@{$res->{no}},␣[$S{no}{$url},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$url,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣];
␣␣␣␣}
␣␣␣␣my␣$R␣=␣"";␣#␣report
␣␣␣␣if␣($S{start}␣&&␣$S{end})␣{
␣␣␣␣␣␣␣␣$R␣.=␣sprintf␣"Log␣starts:␣%s\n",␣$S{start}␣?␣scalar(localtime␣$S{start})␣:␣"unknown";
␣␣␣␣␣␣␣␣$R␣.=␣sprintf␣"Log␣ends␣␣:␣%s\n",␣$S{end}␣␣␣?␣scalar(localtime␣$S{end})␣␣␣:␣"unknown";
␣␣␣␣}
␣␣␣␣if␣($res->{ok}␣&&␣@{$res->{ok}})␣{
␣␣␣␣␣␣␣␣$R␣.=␣sprintf␣"\nSuccessful␣downloads:
␣␣␣N␣␣␣␣␣␣␣kB␣␣secs␣␣␣␣␣␣kB/s␣url\n";
␣␣␣␣␣␣␣␣my␣$i␣=␣20;
␣␣␣␣␣␣␣␣for␣(sort␣{␣$b->[3]␣<=>␣$a->[3]␣}␣@{$res->{ok}})␣{
␣␣␣␣␣␣␣␣␣␣␣␣$R␣.=␣sprintf␣"%4d␣%8d␣%5d␣%9.1f␣%s\n",␣@$_;
␣␣␣␣␣␣␣␣␣␣␣␣last␣if␣--$i<=0;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣if␣($res->{no}␣&&␣@{$res->{no}})␣{
␣␣␣␣␣␣␣␣$R␣.=␣sprintf␣"\nUnsuccessful␣downloads:\n";
␣␣␣␣␣␣␣␣my␣$i␣=␣20;
␣␣␣␣␣␣␣␣for␣(sort␣{␣$b->[0]␣<=>␣$a->[0]␣}␣@{$res->{no}})␣{
␣␣␣␣␣␣␣␣␣␣␣␣$R␣.=␣sprintf␣"%4d␣%s\n",␣@$_;
␣␣␣␣␣␣␣␣␣␣␣␣last␣if␣--$i<=0;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣$CPAN::Frontend->myprint($R);
}

#␣here␣is␣where␣'reload␣cpan'␣is␣done
#->␣sub␣CPAN::Shell::reload␣;
sub␣reload␣{
␣␣␣␣my($self,$command,@arg)␣=␣@_;
␣␣␣␣$command␣||=␣"";
␣␣␣␣$self->debug("self[$self]command[$command]arg[@arg]")␣if␣$CPAN::DEBUG;
␣␣␣␣if␣($command␣=~␣/^cpan$/i)␣{
␣␣␣␣␣␣␣␣my␣$redef␣=␣0;
␣␣␣␣␣␣␣␣chdir␣$CPAN::iCwd␣if␣$CPAN::iCwd;␣#␣may␣fail
␣␣␣␣␣␣␣␣my␣$failed;
␣␣␣␣␣␣MFILE:␣for␣my␣$f␣(@relo)␣{
␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣exists␣$INC{$f};
␣␣␣␣␣␣␣␣␣␣␣␣my␣$p␣=␣$f;
␣␣␣␣␣␣␣␣␣␣␣␣$p␣=~␣s/\.pm$//;
␣␣␣␣␣␣␣␣␣␣␣␣$p␣=~␣s|/|::|g;
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("($p");
␣␣␣␣␣␣␣␣␣␣␣␣local($SIG{__WARN__})␣=␣paintdots_onreload(\$redef);
␣␣␣␣␣␣␣␣␣␣␣␣$self->_reload_this($f)␣or␣$failed++;
␣␣␣␣␣␣␣␣␣␣␣␣my␣$v␣=␣eval␣"$p\::->VERSION";
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("v$v)");
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("\n$redef␣subroutines␣redefined\n");
␣␣␣␣␣␣␣␣if␣($failed)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$errors␣=␣$failed␣==␣1␣?␣"error"␣:␣"errors";
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("\n$failed␣$errors␣during␣reload.␣You␣better␣quit␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"this␣session.\n");
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣elsif␣($command␣=~␣/^index$/i)␣{
␣␣␣␣␣␣CPAN::Index->force_reload;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{cpan␣␣␣␣␣re-evals␣the␣CPAN␣modules
index␣␣␣␣re-reads␣the␣index␣files\n});
␣␣␣␣}
}

#␣reload␣means␣only␣load␣again␣what␣we␣have␣loaded␣before
#->␣sub␣CPAN::Shell::_reload_this␣;
sub␣_reload_this␣{
␣␣␣␣my($self,$f,$args)␣=␣@_;
␣␣␣␣CPAN->debug("f[$f]")␣if␣$CPAN::DEBUG;
␣␣␣␣return␣1␣unless␣$INC{$f};␣#␣we␣never␣loaded␣this,␣so␣we␣do␣not
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣reload␣but␣say␣OK
␣␣␣␣my␣$pwd␣=␣CPAN::anycwd();
␣␣␣␣CPAN->debug("pwd[$pwd]")␣if␣$CPAN::DEBUG;
␣␣␣␣my($file);
␣␣␣␣for␣my␣$inc␣(@INC)␣{
␣␣␣␣␣␣␣␣$file␣=␣File::Spec->catfile($inc,split␣/\//,␣$f);
␣␣␣␣␣␣␣␣last␣if␣-f␣$file;
␣␣␣␣␣␣␣␣$file␣=␣"";
␣␣␣␣}
␣␣␣␣CPAN->debug("file[$file]")␣if␣$CPAN::DEBUG;
␣␣␣␣my␣@inc␣=␣@INC;
␣␣␣␣unless␣($file␣&&␣-f␣$file)␣{
␣␣␣␣␣␣␣␣#␣this␣thingie␣is␣not␣in␣the␣INC␣path,␣maybe␣CPAN/MyConfig.pm?
␣␣␣␣␣␣␣␣$file␣=␣$INC{$f};
␣␣␣␣␣␣␣␣unless␣(CPAN->has_inst("File::Basename"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣@inc␣=␣File::Basename::dirname($file);
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣#␣do␣we␣ever␣need␣this?
␣␣␣␣␣␣␣␣␣␣␣␣@inc␣=␣substr($file,0,-length($f)-1);␣#␣bring␣in␣back␣to␣me!
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣CPAN->debug("file[$file]inc[@inc]")␣if␣$CPAN::DEBUG;
␣␣␣␣unless␣(-f␣$file)␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("Found␣no␣file␣to␣reload␣for␣'$f'\n");
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
␣␣␣␣my␣$mtime␣=␣(stat␣$file)[9];
␣␣␣␣$reload->{$f}␣||=␣-1;
␣␣␣␣my␣$must_reload␣=␣$mtime␣!=␣$reload->{$f};
␣␣␣␣$args␣||=␣{};
␣␣␣␣$must_reload␣||=␣$args->{reloforce};␣#␣o␣conf␣defaults␣needs␣this
␣␣␣␣if␣($must_reload)␣{
␣␣␣␣␣␣␣␣my␣$fh␣=␣FileHandle->new($file)␣or
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Could␣not␣open␣$file:␣$!");
␣␣␣␣␣␣␣␣local($/);
␣␣␣␣␣␣␣␣local␣$^W␣=␣1;
␣␣␣␣␣␣␣␣my␣$content␣=␣<$fh>;
␣␣␣␣␣␣␣␣CPAN->debug(sprintf("reload␣file[%s]␣content[%s...]",$file,substr($content,0,128)))
␣␣␣␣␣␣␣␣␣␣␣␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣delete␣$INC{$f};
␣␣␣␣␣␣␣␣local␣@INC␣=␣@inc;
␣␣␣␣␣␣␣␣eval␣"require␣'$f'";
␣␣␣␣␣␣␣␣if␣($@)␣{
␣␣␣␣␣␣␣␣␣␣␣␣warn␣$@;
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$reload->{$f}␣=␣$mtime;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("__unchanged__");
␣␣␣␣}
␣␣␣␣return␣1;
}

#->␣sub␣CPAN::Shell::mkmyconfig␣;
sub␣mkmyconfig␣{
␣␣␣␣my($self,␣$cpanpm,␣%args)␣=␣@_;
␣␣␣␣require␣CPAN::FirstTime;
␣␣␣␣my␣$home␣=␣CPAN::HandleConfig::home();
␣␣␣␣$cpanpm␣=␣$INC{'CPAN/MyConfig.pm'}␣||
␣␣␣␣␣␣␣␣File::Spec->catfile(split␣/\//,␣"$home/.cpan/CPAN/MyConfig.pm");
␣␣␣␣File::Path::mkpath(File::Basename::dirname($cpanpm))␣unless␣-e␣$cpanpm;
␣␣␣␣CPAN::HandleConfig::require_myconfig_or_config();
␣␣␣␣$CPAN::Config␣||=␣{};
␣␣␣␣$CPAN::Config␣=␣{
␣␣␣␣␣␣␣␣%$CPAN::Config,
␣␣␣␣␣␣␣␣build_dir␣␣␣␣␣␣␣␣␣␣␣=>␣␣undef,
␣␣␣␣␣␣␣␣cpan_home␣␣␣␣␣␣␣␣␣␣␣=>␣␣undef,
␣␣␣␣␣␣␣␣keep_source_where␣␣␣=>␣␣undef,
␣␣␣␣␣␣␣␣histfile␣␣␣␣␣␣␣␣␣␣␣␣=>␣␣undef,
␣␣␣␣};
␣␣␣␣CPAN::FirstTime::init($cpanpm,␣%args);
}

#->␣sub␣CPAN::Shell::_binary_extensions␣;
sub␣_binary_extensions␣{
␣␣␣␣my($self)␣=␣shift␣@_;
␣␣␣␣my(@result,$module,%seen,%need,$headerdone);
␣␣␣␣for␣$module␣($self->expand('Module','/./'))␣{
␣␣␣␣␣␣␣␣my␣$file␣␣=␣$module->cpan_file;
␣␣␣␣␣␣␣␣next␣if␣$file␣eq␣"N/A";
␣␣␣␣␣␣␣␣next␣if␣$file␣=~␣/^Contact␣Author/;
␣␣␣␣␣␣␣␣my␣$dist␣=␣$CPAN::META->instance('CPAN::Distribution',$file);
␣␣␣␣␣␣␣␣next␣if␣$dist->isa_perl;
␣␣␣␣␣␣␣␣next␣unless␣$module->xs_file;
␣␣␣␣␣␣␣␣local($|)␣=␣1;
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(".");
␣␣␣␣␣␣␣␣push␣@result,␣$module;
␣␣␣␣}
#␣␣␣␣print␣join␣"␣|␣",␣@result;
␣␣␣␣$CPAN::Frontend->myprint("\n");
␣␣␣␣return␣@result;
}

#->␣sub␣CPAN::Shell::recompile␣;
sub␣recompile␣{
␣␣␣␣my($self)␣=␣shift␣@_;
␣␣␣␣my($module,@module,$cpan_file,%dist);
␣␣␣␣@module␣=␣$self->_binary_extensions();
␣␣␣␣for␣$module␣(@module)␣{␣#␣we␣force␣now␣and␣compile␣later,␣so␣we
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣don't␣do␣it␣twice
␣␣␣␣␣␣␣␣$cpan_file␣=␣$module->cpan_file;
␣␣␣␣␣␣␣␣my␣$pack␣=␣$CPAN::META->instance('CPAN::Distribution',$cpan_file);
␣␣␣␣␣␣␣␣$pack->force;
␣␣␣␣␣␣␣␣$dist{$cpan_file}++;
␣␣␣␣}
␣␣␣␣for␣$cpan_file␣(sort␣keys␣%dist)␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("␣␣CPAN:␣Recompiling␣$cpan_file\n\n");
␣␣␣␣␣␣␣␣my␣$pack␣=␣$CPAN::META->instance('CPAN::Distribution',$cpan_file);
␣␣␣␣␣␣␣␣$pack->install;
␣␣␣␣␣␣␣␣$CPAN::Signal␣=␣0;␣#␣it's␣tempting␣to␣reset␣Signal,␣so␣we␣can
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣stop␣a␣package␣from␣recompiling,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣e.g.␣IO-1.12␣when␣we␣have␣perl5.003_10
␣␣␣␣}
}

#->␣sub␣CPAN::Shell::scripts␣;
sub␣scripts␣{
␣␣␣␣my($self,␣$arg)␣=␣@_;
␣␣␣␣$CPAN::Frontend->mywarn(">>>>␣experimental␣command,␣currently␣unsupported␣<<<<\n\n");

␣␣␣␣for␣my␣$req␣(qw(␣HTML::LinkExtor␣Sort::Versions␣List::Util␣))␣{
␣␣␣␣␣␣␣␣unless␣($CPAN::META->has_inst($req))␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("␣␣$req␣not␣available\n");
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣my␣$p␣=␣HTML::LinkExtor->new();
␣␣␣␣my␣$indexfile␣=␣"/home/ftp/pub/PAUSE/scripts/new/index.html";
␣␣␣␣unless␣(-f␣$indexfile)␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("found␣no␣indexfile[$indexfile]\n");
␣␣␣␣}
␣␣␣␣$p->parse_file($indexfile);
␣␣␣␣my␣@hrefs;
␣␣␣␣my␣$qrarg;
␣␣␣␣if␣($arg␣=~␣s|^/(.+)/$|$1|)␣{
␣␣␣␣␣␣␣␣$qrarg␣=␣eval␣'qr/$arg/';␣#␣hide␣construct␣from␣5.004
␣␣␣␣}
␣␣␣␣for␣my␣$l␣($p->links)␣{
␣␣␣␣␣␣␣␣my␣$tag␣=␣shift␣@$l;
␣␣␣␣␣␣␣␣next␣unless␣$tag␣eq␣"a";
␣␣␣␣␣␣␣␣my␣%att␣=␣@$l;
␣␣␣␣␣␣␣␣my␣$href␣=␣$att{href};
␣␣␣␣␣␣␣␣next␣unless␣$href␣=~␣s|^\.\./authors/id/./../||;
␣␣␣␣␣␣␣␣if␣($arg)␣{
␣␣␣␣␣␣␣␣␣␣␣␣if␣($qrarg)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($href␣=~␣$qrarg)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@hrefs,␣$href;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($href␣=~␣/\Q$arg\E/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@hrefs,␣$href;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣push␣@hrefs,␣$href;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣#␣now␣filter␣for␣the␣latest␣version␣if␣there␣is␣more␣than␣one␣of␣a␣name
␣␣␣␣my␣%stems;
␣␣␣␣for␣(sort␣@hrefs)␣{
␣␣␣␣␣␣␣␣my␣$href␣=␣$_;
␣␣␣␣␣␣␣␣s/-v?\d.*//;
␣␣␣␣␣␣␣␣my␣$stem␣=␣$_;
␣␣␣␣␣␣␣␣$stems{$stem}␣||=␣[];
␣␣␣␣␣␣␣␣push␣@{$stems{$stem}},␣$href;
␣␣␣␣}
␣␣␣␣for␣(sort␣keys␣%stems)␣{
␣␣␣␣␣␣␣␣my␣$highest;
␣␣␣␣␣␣␣␣if␣(@{$stems{$_}}␣>␣1)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$highest␣=␣List::Util::reduce␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣Sort::Versions::versioncmp($a,$b)␣>␣0␣?␣$a␣:␣$b
␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣@{$stems{$_}};
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$highest␣=␣$stems{$_}[0];
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("$highest\n");
␣␣␣␣}
}

#->␣sub␣CPAN::Shell::report␣;
sub␣report␣{
␣␣␣␣my($self,@args)␣=␣@_;
␣␣␣␣unless␣($CPAN::META->has_inst("CPAN::Reporter"))␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("CPAN::Reporter␣not␣installed;␣cannot␣continue");
␣␣␣␣}
␣␣␣␣local␣$CPAN::Config->{test_report}␣=␣1;
␣␣␣␣$self->force("test",@args);␣#␣force␣is␣there␣so␣that␣the␣test␣be
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣re-run␣(as␣documented)
}

#␣compare␣with␣is_tested
#->␣sub␣CPAN::Shell::install_tested
sub␣install_tested␣{
␣␣␣␣my($self,@some)␣=␣@_;
␣␣␣␣$CPAN::Frontend->mywarn("install_tested()␣must␣not␣be␣called␣with␣arguments.\n"),
␣␣␣␣␣␣␣␣return␣if␣@some;
␣␣␣␣CPAN::Index->reload;

␣␣␣␣for␣my␣$b␣(reverse␣$CPAN::META->_list_sorted_descending_is_tested)␣{
␣␣␣␣␣␣␣␣my␣$yaml␣=␣"$b.yml";
␣␣␣␣␣␣␣␣unless␣(-f␣$yaml)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("No␣YAML␣file␣for␣$b␣available,␣skipping\n");
␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣my␣$yaml_content␣=␣CPAN->_yaml_loadfile($yaml);
␣␣␣␣␣␣␣␣my␣$id␣=␣$yaml_content->[0]{distribution}{ID};
␣␣␣␣␣␣␣␣unless␣($id)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("No␣ID␣found␣in␣'$yaml',␣skipping\n");
␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣my␣$do␣=␣CPAN::Shell->expandany($id);
␣␣␣␣␣␣␣␣unless␣($do)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("Could␣not␣expand␣ID␣'$id',␣skipping\n");
␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣unless␣($do->{build_dir})␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("Distro␣'$id'␣has␣no␣build_dir,␣skipping\n");
␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣unless␣($do->{build_dir}␣eq␣$b)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("Distro␣'$id'␣has␣build_dir␣'$do->{build_dir}'␣but␣expected␣'$b',␣skipping\n");
␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣push␣@some,␣$do;
␣␣␣␣}

␣␣␣␣$CPAN::Frontend->mywarn("No␣tested␣distributions␣found.\n"),
␣␣␣␣␣␣␣␣return␣unless␣@some;

␣␣␣␣@some␣=␣grep␣{␣$_->{make_test}␣&&␣!␣$_->{make_test}->failed␣}␣@some;
␣␣␣␣$CPAN::Frontend->mywarn("No␣distributions␣tested␣with␣this␣build␣of␣perl␣found.\n"),
␣␣␣␣␣␣␣␣return␣unless␣@some;

␣␣␣␣#␣@some␣=␣grep␣{␣not␣$_->uptodate␣}␣@some;
␣␣␣␣#␣$CPAN::Frontend->mywarn("No␣non-uptodate␣distributions␣tested␣with␣this␣build␣of␣perl␣found.\n"),
␣␣␣␣#␣␣␣␣␣return␣unless␣@some;

␣␣␣␣CPAN->debug("some[@some]");
␣␣␣␣for␣my␣$d␣(@some)␣{
␣␣␣␣␣␣␣␣my␣$id␣=␣$d->can("pretty_id")␣?␣$d->pretty_id␣:␣$d->id;
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("install_tested:␣Running␣for␣$id\n");
␣␣␣␣␣␣␣␣$CPAN::Frontend->mysleep(1);
␣␣␣␣␣␣␣␣$self->install($d);
␣␣␣␣}
}

#->␣sub␣CPAN::Shell::upgrade␣;
sub␣upgrade␣{
␣␣␣␣my($self,@args)␣=␣@_;
␣␣␣␣$self->install($self->r(@args));
}

#->␣sub␣CPAN::Shell::_u_r_common␣;
sub␣_u_r_common␣{
␣␣␣␣my($self)␣=␣shift␣@_;
␣␣␣␣my($what)␣=␣shift␣@_;
␣␣␣␣CPAN->debug("self[$self]␣what[$what]␣args[@_]")␣if␣$CPAN::DEBUG;
␣␣␣␣Carp::croak␣"Usage:␣\$obj->_u_r_common(a|r|u)"␣unless
␣␣␣␣␣␣␣␣␣␣$what␣&&␣$what␣=~␣/^[aru]$/;
␣␣␣␣my(@args)␣=␣@_;
␣␣␣␣@args␣=␣'/./'␣unless␣@args;
␣␣␣␣my(@result,$module,%seen,%need,$headerdone,
␣␣␣␣␣␣␣$version_undefs,$version_zeroes,
␣␣␣␣␣␣␣@version_undefs,@version_zeroes);
␣␣␣␣$version_undefs␣=␣$version_zeroes␣=␣0;
␣␣␣␣my␣$sprintf␣=␣"%s%-25s%s␣%9s␣%9s␣␣%s\n";
␣␣␣␣my␣@expand␣=␣$self->expand('Module',@args);
␣␣␣␣if␣($CPAN::DEBUG)␣{␣#␣Looks␣like␣noise␣to␣me,␣was␣very␣useful␣for␣debugging
␣␣␣␣␣␣␣␣␣␣␣␣␣#␣for␣metadata␣cache
␣␣␣␣␣␣␣␣my␣$expand␣=␣scalar␣@expand;
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(sprintf␣"%d␣matches␣in␣the␣database,␣time[%d]\n",␣$expand,␣time);
␣␣␣␣}
␣␣␣␣my␣@sexpand;
␣␣␣␣if␣($]␣<␣5.008)␣{
␣␣␣␣␣␣␣␣#␣hard␣to␣believe␣that␣the␣more␣complex␣sorting␣can␣lead␣to
␣␣␣␣␣␣␣␣#␣stack␣curruptions␣on␣older␣perl
␣␣␣␣␣␣␣␣@sexpand␣=␣sort␣{$a->id␣cmp␣$b->id}␣@expand;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣@sexpand␣=␣map␣{
␣␣␣␣␣␣␣␣␣␣␣␣$_->[1]
␣␣␣␣␣␣␣␣}␣sort␣{
␣␣␣␣␣␣␣␣␣␣␣␣$b->[0]␣<=>␣$a->[0]
␣␣␣␣␣␣␣␣␣␣␣␣||
␣␣␣␣␣␣␣␣␣␣␣␣$a->[1]{ID}␣cmp␣$b->[1]{ID},
␣␣␣␣␣␣␣␣}␣map␣{
␣␣␣␣␣␣␣␣␣␣␣␣[$_->_is_representative_module,
␣␣␣␣␣␣␣␣␣␣␣␣␣$_
␣␣␣␣␣␣␣␣␣␣␣␣]
␣␣␣␣␣␣␣␣}␣@expand;
␣␣␣␣}
␣␣␣␣if␣($CPAN::DEBUG)␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(sprintf␣"sorted␣at␣time[%d]\n",␣time);
␣␣␣␣␣␣␣␣sleep␣1;
␣␣␣␣}
␣␣MODULE:␣for␣$module␣(@sexpand)␣{
␣␣␣␣␣␣␣␣my␣$file␣␣=␣$module->cpan_file;
␣␣␣␣␣␣␣␣next␣MODULE␣unless␣defined␣$file;␣#␣??
␣␣␣␣␣␣␣␣$file␣=~␣s!^./../!!;
␣␣␣␣␣␣␣␣my($latest)␣=␣$module->cpan_version;
␣␣␣␣␣␣␣␣my($inst_file)␣=␣$module->inst_file;
␣␣␣␣␣␣␣␣CPAN->debug("file[$file]latest[$latest]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣my($have);
␣␣␣␣␣␣␣␣return␣if␣$CPAN::Signal;
␣␣␣␣␣␣␣␣my($next_MODULE);
␣␣␣␣␣␣␣␣eval␣{␣#␣version.pm␣involved!
␣␣␣␣␣␣␣␣␣␣␣␣if␣($inst_file)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($what␣eq␣"a")␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$have␣=␣$module->inst_version;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣($what␣eq␣"r")␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$have␣=␣$module->inst_version;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣local($^W)␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($have␣eq␣"undef")␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$version_undefs++;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@version_undefs,␣$module->as_glimpse;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣(CPAN::Version->vcmp($have,0)==0)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$version_zeroes++;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@version_zeroes,␣$module->as_glimpse;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣++$next_MODULE␣unless␣CPAN::Version->vgt($latest,␣$have);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣to␣be␣pedantic␣we␣should␣probably␣say:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣␣␣␣&&␣!($have␣eq␣"undef"␣&&␣$latest␣ne␣"undef"␣&&␣$latest␣gt␣"");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣to␣catch␣the␣case␣where␣CPAN␣has␣a␣version␣0␣and␣we␣have␣a␣version␣undef
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣($what␣eq␣"u")␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣++$next_MODULE;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($what␣eq␣"a")␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣++$next_MODULE;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣($what␣eq␣"r")␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣++$next_MODULE;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣($what␣eq␣"u")␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$have␣=␣"-";
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣next␣MODULE␣if␣$next_MODULE;
␣␣␣␣␣␣␣␣if␣($@)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(sprintf("Error␣while␣comparing␣cpan/installed␣versions␣of␣'%s':
INST_FILE:␣%s
INST_VERSION:␣%s␣%s
CPAN_VERSION:␣%s␣%s
",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$module->id,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$inst_file␣||␣"",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(defined␣$have␣?␣$have␣:␣"[UNDEFINED]"),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(ref␣$have␣?␣ref␣$have␣:␣""),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$latest,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(ref␣$latest␣?␣ref␣$latest␣:␣""),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣));
␣␣␣␣␣␣␣␣␣␣␣␣next␣MODULE;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣return␣if␣$CPAN::Signal;␣#␣this␣is␣sometimes␣lengthy
␣␣␣␣␣␣␣␣$seen{$file}␣||=␣0;
␣␣␣␣␣␣␣␣if␣($what␣eq␣"a")␣{
␣␣␣␣␣␣␣␣␣␣␣␣push␣@result,␣sprintf␣"%s␣%s\n",␣$module->id,␣$have;
␣␣␣␣␣␣␣␣}␣elsif␣($what␣eq␣"r")␣{
␣␣␣␣␣␣␣␣␣␣␣␣push␣@result,␣$module->id;
␣␣␣␣␣␣␣␣␣␣␣␣next␣MODULE␣if␣$seen{$file}++;
␣␣␣␣␣␣␣␣}␣elsif␣($what␣eq␣"u")␣{
␣␣␣␣␣␣␣␣␣␣␣␣push␣@result,␣$module->id;
␣␣␣␣␣␣␣␣␣␣␣␣next␣MODULE␣if␣$seen{$file}++;
␣␣␣␣␣␣␣␣␣␣␣␣next␣MODULE␣if␣$file␣=~␣/^Contact/;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣unless␣($headerdone++)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("\n");
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(sprintf(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$sprintf,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Package␣namespace",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"installed",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"latest",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"in␣CPAN␣file"
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣));
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣my␣$color_on␣=␣"";
␣␣␣␣␣␣␣␣my␣$color_off␣=␣"";
␣␣␣␣␣␣␣␣if␣(
␣␣␣␣␣␣␣␣␣␣␣␣$COLOR_REGISTERED
␣␣␣␣␣␣␣␣␣␣␣␣&&
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::META->has_inst("Term::ANSIColor")
␣␣␣␣␣␣␣␣␣␣␣␣&&
␣␣␣␣␣␣␣␣␣␣␣␣$module->description
␣␣␣␣␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$color_on␣=␣Term::ANSIColor::color("green");
␣␣␣␣␣␣␣␣␣␣␣␣$color_off␣=␣Term::ANSIColor::color("reset");
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(sprintf␣$sprintf,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$color_on,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$module->id,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$color_off,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$have,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$latest,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$file);
␣␣␣␣␣␣␣␣$need{$module->id}++;
␣␣␣␣}
␣␣␣␣unless␣(%need)␣{
␣␣␣␣␣␣␣␣if␣($what␣eq␣"u")␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("No␣modules␣found␣for␣@args\n");
␣␣␣␣␣␣␣␣}␣elsif␣($what␣eq␣"r")␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("All␣modules␣are␣up␣to␣date␣for␣@args\n");
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣if␣($what␣eq␣"r")␣{
␣␣␣␣␣␣␣␣if␣($version_zeroes)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$s_has␣=␣$version_zeroes␣>␣1␣?␣"s␣have"␣:␣"␣has";
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{$version_zeroes␣installed␣module$s_has␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{a␣version␣number␣of␣0\n});
␣␣␣␣␣␣␣␣␣␣␣␣if␣($CPAN::Config->{show_zero_versions})␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣local␣$"␣=␣"\t";
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{␣␣they␣are\n\t@version_zeroes\n});
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{(use␣'o␣conf␣show_zero_versions␣0'␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{to␣hide␣them)\n});
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{(use␣'o␣conf␣show_zero_versions␣1'␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{to␣show␣them)\n});
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣($version_undefs)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$s_has␣=␣$version_undefs␣>␣1␣?␣"s␣have"␣:␣"␣has";
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{$version_undefs␣installed␣module$s_has␣no␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{parsable␣version␣number\n});
␣␣␣␣␣␣␣␣␣␣␣␣if␣($CPAN::Config->{show_unparsable_versions})␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣local␣$"␣=␣"\t";
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{␣␣they␣are\n\t@version_undefs\n});
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{(use␣'o␣conf␣show_unparsable_versions␣0'␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{to␣hide␣them)\n});
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{(use␣'o␣conf␣show_unparsable_versions␣1'␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{to␣show␣them)\n});
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣@result;
}

#->␣sub␣CPAN::Shell::r␣;
sub␣r␣{
␣␣␣␣shift->_u_r_common("r",@_);
}

#->␣sub␣CPAN::Shell::u␣;
sub␣u␣{
␣␣␣␣shift->_u_r_common("u",@_);
}

#->␣sub␣CPAN::Shell::failed␣;
sub␣failed␣{
␣␣␣␣my($self,$only_id,$silent)␣=␣@_;
␣␣␣␣my␣@failed;
␣␣DIST:␣for␣my␣$d␣($CPAN::META->all_objects("CPAN::Distribution"))␣{
␣␣␣␣␣␣␣␣my␣$failed␣=␣"";
␣␣␣␣␣␣NAY:␣for␣my␣$nosayer␣(␣#␣order␣matters!
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"unwrapped",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"writemakefile",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"signature_verify",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"make",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"make_test",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"install",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"make_clean",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣exists␣$d->{$nosayer};
␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣defined␣$d->{$nosayer};
␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣UNIVERSAL::can($d->{$nosayer},"failed")␣?
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$d->{$nosayer}->failed␣:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$d->{$nosayer}␣=~␣/^NO/
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣next␣NAY␣if␣$only_id␣&&␣$only_id␣!=␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣UNIVERSAL::can($d->{$nosayer},"commandid")
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$d->{$nosayer}->commandid
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::CurrentCommandId
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣$failed␣=␣$nosayer;
␣␣␣␣␣␣␣␣␣␣␣␣last;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣next␣DIST␣unless␣$failed;
␣␣␣␣␣␣␣␣my␣$id␣=␣$d->id;
␣␣␣␣␣␣␣␣$id␣=~␣s|^./../||;
␣␣␣␣␣␣␣␣#$print␣.=␣sprintf(
␣␣␣␣␣␣␣␣#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"␣␣%-45s:␣%s␣%s\n",
␣␣␣␣␣␣␣␣push␣@failed,
␣␣␣␣␣␣␣␣␣␣␣␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣UNIVERSAL::can($d->{$failed},"failed")␣?
␣␣␣␣␣␣␣␣␣␣␣␣␣[
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$d->{$failed}->commandid,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$id,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$failed,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$d->{$failed}->text,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$d->{$failed}{TIME}||0,
␣␣␣␣␣␣␣␣␣␣␣␣␣]␣:
␣␣␣␣␣␣␣␣␣␣␣␣␣[
␣␣␣␣␣␣␣␣␣␣␣␣␣␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$id,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$failed,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$d->{$failed},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣0,
␣␣␣␣␣␣␣␣␣␣␣␣␣]
␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣}
␣␣␣␣my␣$scope;
␣␣␣␣if␣($only_id)␣{
␣␣␣␣␣␣␣␣$scope␣=␣"this␣command";
␣␣␣␣}␣elsif␣($CPAN::Index::HAVE_REANIMATED)␣{
␣␣␣␣␣␣␣␣$scope␣=␣"this␣or␣a␣previous␣session";
␣␣␣␣␣␣␣␣#␣it␣might␣be␣nice␣to␣have␣a␣section␣for␣previous␣session␣and
␣␣␣␣␣␣␣␣#␣a␣second␣for␣this
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣$scope␣=␣"this␣session";
␣␣␣␣}
␣␣␣␣if␣(@failed)␣{
␣␣␣␣␣␣␣␣my␣$print;
␣␣␣␣␣␣␣␣my␣$debug␣=␣0;
␣␣␣␣␣␣␣␣if␣($debug)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$print␣=␣join␣"",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣map␣{␣sprintf␣"%5d␣%-45s:␣%s␣%s\n",␣@$_␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣sort␣{␣$a->[0]␣<=>␣$b->[0]␣}␣@failed;
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$print␣=␣join␣"",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣map␣{␣sprintf␣"␣%-45s:␣%s␣%s\n",␣@$_[1..3]␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣sort␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$a->[0]␣<=>␣$b->[0]
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣||
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$a->[4]␣<=>␣$b->[4]
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣@failed;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("Failed␣during␣$scope:\n$print");
␣␣␣␣}␣elsif␣(!$only_id␣||␣!$silent)␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("Nothing␣failed␣in␣$scope\n");
␣␣␣␣}
}

#␣XXX␣intentionally␣undocumented␣because␣completely␣bogus,␣unportable,
#␣useless,␣etc.

#->␣sub␣CPAN::Shell::status␣;
sub␣status␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣require␣Devel::Size;
␣␣␣␣my␣$ps␣=␣FileHandle->new;
␣␣␣␣open␣$ps,␣"/proc/$$/status";
␣␣␣␣my␣$vm␣=␣0;
␣␣␣␣while␣(<$ps>)␣{
␣␣␣␣␣␣␣␣next␣unless␣/VmSize:\s+(\d+)/;
␣␣␣␣␣␣␣␣$vm␣=␣$1;
␣␣␣␣␣␣␣␣last;
␣␣␣␣}
␣␣␣␣$CPAN::Frontend->mywarn(sprintf(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"%-27s␣%6d\n%-27s␣%6d\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"vm",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$vm,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"CPAN::META",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣Devel::Size::total_size($CPAN::META)/1024,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣));
␣␣␣␣for␣my␣$k␣(sort␣keys␣%$CPAN::META)␣{
␣␣␣␣␣␣␣␣next␣unless␣substr($k,0,4)␣eq␣"read";
␣␣␣␣␣␣␣␣warn␣sprintf␣"␣%-26s␣%6d\n",␣$k,␣Devel::Size::total_size($CPAN::META->{$k})/1024;
␣␣␣␣␣␣␣␣for␣my␣$k2␣(sort␣keys␣%{$CPAN::META->{$k}})␣{
␣␣␣␣␣␣␣␣␣␣␣␣warn␣sprintf␣"␣␣%-25s␣%6d␣(keys:␣%6d)\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$k2,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣Devel::Size::total_size($CPAN::META->{$k}{$k2})/1024,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣scalar␣keys␣%{$CPAN::META->{$k}{$k2}};
␣␣␣␣␣␣␣␣}
␣␣␣␣}
}

#␣compare␣with␣install_tested
#->␣sub␣CPAN::Shell::is_tested
sub␣is_tested␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣CPAN::Index->reload;
␣␣␣␣for␣my␣$b␣(reverse␣$CPAN::META->_list_sorted_descending_is_tested)␣{
␣␣␣␣␣␣␣␣my␣$time;
␣␣␣␣␣␣␣␣if␣($CPAN::META->{is_tested}{$b})␣{
␣␣␣␣␣␣␣␣␣␣␣␣$time␣=␣scalar(localtime␣$CPAN::META->{is_tested}{$b});
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$time␣=␣scalar␣localtime;
␣␣␣␣␣␣␣␣␣␣␣␣$time␣=~␣s/\S/?/g;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(sprintf␣"%s␣%s\n",␣$time,␣$b);
␣␣␣␣}
}

#->␣sub␣CPAN::Shell::autobundle␣;
sub␣autobundle␣{
␣␣␣␣my($self)␣=␣shift;
␣␣␣␣CPAN::HandleConfig->load␣unless␣$CPAN::Config_loaded++;
␣␣␣␣my(@bundle)␣=␣$self->_u_r_common("a",@_);
␣␣␣␣my($todir)␣=␣File::Spec->catdir($CPAN::Config->{'cpan_home'},"Bundle");
␣␣␣␣File::Path::mkpath($todir);
␣␣␣␣unless␣(-d␣$todir)␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("Couldn't␣mkdir␣$todir␣for␣some␣reason\n");
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
␣␣␣␣my($y,$m,$d)␣=␣␣(localtime)[5,4,3];
␣␣␣␣$y+=1900;
␣␣␣␣$m++;
␣␣␣␣my($c)␣=␣0;
␣␣␣␣my($me)␣=␣sprintf␣"Snapshot_%04d_%02d_%02d_%02d",␣$y,␣$m,␣$d,␣$c;
␣␣␣␣my($to)␣=␣File::Spec->catfile($todir,"$me.pm");
␣␣␣␣while␣(-f␣$to)␣{
␣␣␣␣␣␣␣␣$me␣=␣sprintf␣"Snapshot_%04d_%02d_%02d_%02d",␣$y,␣$m,␣$d,␣++$c;
␣␣␣␣␣␣␣␣$to␣=␣File::Spec->catfile($todir,"$me.pm");
␣␣␣␣}
␣␣␣␣my($fh)␣=␣FileHandle->new(">$to")␣or␣Carp::croak␣"Can't␣open␣>$to:␣$!";
␣␣␣␣$fh->print(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"package␣Bundle::$me;\n\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"\$","VERSION␣=␣'0.01';\n\n",␣#␣hide␣from␣perl-reversion
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"1;\n\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"__END__\n\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"=head1␣NAME\n\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Bundle::$me␣-␣Snapshot␣of␣installation␣on␣",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$Config::Config{'myhostname'},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"␣on␣",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣scalar(localtime),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"\n\n=head1␣SYNOPSIS\n\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"perl␣-MCPAN␣-e␣'install␣Bundle::$me'\n\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"=head1␣CONTENTS\n\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣join("\n",␣@bundle),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"\n\n=head1␣CONFIGURATION\n\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣Config->myconfig,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"\n\n=head1␣AUTHOR\n\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"This␣Bundle␣has␣been␣generated␣automatically␣",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"by␣the␣autobundle␣routine␣in␣CPAN.pm.\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣$fh->close;
␣␣␣␣$CPAN::Frontend->myprint("\nWrote␣bundle␣file
␣␣␣␣$to\n\n");
}

#->␣sub␣CPAN::Shell::expandany␣;
sub␣expandany␣{
␣␣␣␣my($self,$s)␣=␣@_;
␣␣␣␣CPAN->debug("s[$s]")␣if␣$CPAN::DEBUG;
␣␣␣␣my␣$module_as_path␣=␣"";
␣␣␣␣if␣($s␣=~␣m|(?:\w+/)*\w+\.pm$|)␣{␣#␣same␣regexp␣in␣sub␣m
␣␣␣␣␣␣␣␣$module_as_path␣=␣$s;
␣␣␣␣␣␣␣␣$module_as_path␣=~␣s/.pm$//;
␣␣␣␣␣␣␣␣$module_as_path␣=~␣s|/|::|g;
␣␣␣␣}
␣␣␣␣if␣($module_as_path)␣{
␣␣␣␣␣␣␣␣if␣($module_as_path␣=~␣m|^Bundle::|)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$self->local_bundles;
␣␣␣␣␣␣␣␣␣␣␣␣return␣$self->expand('Bundle',$module_as_path);
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣return␣$self->expand('Module',$module_as_path)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣$CPAN::META->exists('CPAN::Module',$module_as_path);
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣elsif␣($s␣=~␣m|/|␣or␣substr($s,-1,1)␣eq␣".")␣{␣#␣looks␣like␣a␣file␣or␣a␣directory
␣␣␣␣␣␣␣␣$s␣=␣CPAN::Distribution->normalize($s);
␣␣␣␣␣␣␣␣return␣$CPAN::META->instance('CPAN::Distribution',$s);
␣␣␣␣␣␣␣␣#␣Distributions␣spring␣into␣existence,␣not␣expand
␣␣␣␣}␣elsif␣($s␣=~␣m|^Bundle::|)␣{
␣␣␣␣␣␣␣␣$self->local_bundles;␣#␣scanning␣so␣late␣for␣bundles␣seems
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣both␣attractive␣and␣crumpy:␣always
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣current␣state␣but␣easy␣to␣forget
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣somewhere
␣␣␣␣␣␣␣␣return␣$self->expand('Bundle',$s);
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣return␣$self->expand('Module',$s)
␣␣␣␣␣␣␣␣␣␣␣␣if␣$CPAN::META->exists('CPAN::Module',$s);
␣␣␣␣}
␣␣␣␣return;
}

#->␣sub␣CPAN::Shell::expand␣;
sub␣expand␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my($type,@args)␣=␣@_;
␣␣␣␣CPAN->debug("type[$type]args[@args]")␣if␣$CPAN::DEBUG;
␣␣␣␣my␣$class␣=␣"CPAN::$type";
␣␣␣␣my␣$methods␣=␣['id'];
␣␣␣␣for␣my␣$meth␣(qw(name))␣{
␣␣␣␣␣␣␣␣next␣unless␣$class->can($meth);
␣␣␣␣␣␣␣␣push␣@$methods,␣$meth;
␣␣␣␣}
␣␣␣␣$self->expand_by_method($class,$methods,@args);
}

#->␣sub␣CPAN::Shell::expand_by_method␣;
sub␣expand_by_method␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my($class,$methods,@args)␣=␣@_;
␣␣␣␣my($arg,@m);
␣␣␣␣for␣$arg␣(@args)␣{
␣␣␣␣␣␣␣␣my($regex,$command);
␣␣␣␣␣␣␣␣if␣($arg␣=~␣m|^/(.*)/$|)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$regex␣=␣$1;
#␣FIXME:␣␣there␣seem␣to␣be␣some␣='s␣in␣the␣author␣data,␣which␣trigger
#␣␣␣␣␣␣␣␣␣a␣failure␣here.␣␣This␣needs␣to␣be␣contemplated.
#␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣($arg␣=~␣m/=/)␣{
#␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$command␣=␣1;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣my␣$obj;
␣␣␣␣␣␣␣␣CPAN->debug(sprintf␣"class[%s]regex[%s]command[%s]",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$class,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣defined␣$regex␣?␣$regex␣:␣"UNDEFINED",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣defined␣$command␣?␣$command␣:␣"UNDEFINED",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣if␣(defined␣$regex)␣{
␣␣␣␣␣␣␣␣␣␣␣␣if␣(CPAN::_sqlite_running())␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CPAN::Index->reload;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::SQLite->search($class,␣$regex);
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣for␣$obj␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::META->all_objects($class)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣unless␣($obj␣&&␣UNIVERSAL::can($obj,"id")␣&&␣$obj->id)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣BUG,␣we␣got␣an␣empty␣object␣somewhere
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣require␣Data::Dumper;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CPAN->debug(sprintf(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Bug␣in␣CPAN:␣Empty␣id␣on␣obj[%s][%s]",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣Data::Dumper::Dumper($obj)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣))␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣for␣my␣$method␣(@$methods)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$match␣=␣eval␣{$obj->$method()␣=~␣/$regex/i};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($@)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my($err)␣=␣$@␣=~␣/^(.+)␣at␣.+?␣line␣\d+\.$/;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$err␣||=␣$@;␣#␣if␣we␣were␣too␣restrictive␣above
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("$err\n");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣($match)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@m,␣$obj;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣last;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣elsif␣($command)␣{
␣␣␣␣␣␣␣␣␣␣␣␣die␣"equal␣sign␣in␣command␣disabled␣(immature␣interface),␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"you␣can␣set
␣!␣\$CPAN::Shell::ADVANCED_QUERY=1
to␣enable␣it.␣But␣please␣note,␣this␣is␣HIGHLY␣EXPERIMENTAL␣code
that␣may␣go␣away␣anytime.\n"
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣unless␣$ADVANCED_QUERY;
␣␣␣␣␣␣␣␣␣␣␣␣my($method,$criterion)␣=␣$arg␣=~␣/(.+?)=(.+)/;
␣␣␣␣␣␣␣␣␣␣␣␣my($matchcrit)␣=␣$criterion␣=~␣m/^~(.+)/;
␣␣␣␣␣␣␣␣␣␣␣␣for␣my␣$self␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣sort
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣{$a->id␣cmp␣$b->id}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::META->all_objects($class)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$lhs␣=␣$self->$method()␣or␣next;␣#␣()␣for␣5.00503
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($matchcrit)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@m,␣$self␣if␣$lhs␣=~␣m/$matchcrit/;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@m,␣$self␣if␣$lhs␣eq␣$criterion;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣my($xarg)␣=␣$arg;
␣␣␣␣␣␣␣␣␣␣␣␣if␣(␣$class␣eq␣'CPAN::Bundle'␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$xarg␣=~␣s/^(Bundle::)?(.*)/Bundle::$2/;
␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣($class␣eq␣"CPAN::Distribution")␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$xarg␣=␣CPAN::Distribution->normalize($arg);
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$xarg␣=~␣s/:+/::/g;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣if␣($CPAN::META->exists($class,$xarg))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj␣=␣$CPAN::META->instance($class,$xarg);
␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣($CPAN::META->exists($class,$arg))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj␣=␣$CPAN::META->instance($class,$arg);
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣push␣@m,␣$obj;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣@m␣=␣sort␣{$a->id␣cmp␣$b->id}␣@m;
␣␣␣␣if␣(␣$CPAN::DEBUG␣)␣{
␣␣␣␣␣␣␣␣my␣$wantarray␣=␣wantarray;
␣␣␣␣␣␣␣␣my␣$join_m␣=␣join␣",",␣map␣{$_->id}␣@m;
␣␣␣␣␣␣␣␣#␣$self->debug("wantarray[$wantarray]join_m[$join_m]");
␣␣␣␣␣␣␣␣my␣$count␣=␣scalar␣@m;
␣␣␣␣␣␣␣␣$self->debug("class[$class]wantarray[$wantarray]count␣m[$count]");
␣␣␣␣}
␣␣␣␣return␣wantarray␣?␣@m␣:␣$m[0];
}

#->␣sub␣CPAN::Shell::format_result␣;
sub␣format_result␣{
␣␣␣␣my($self)␣=␣shift;
␣␣␣␣my($type,@args)␣=␣@_;
␣␣␣␣@args␣=␣'/./'␣unless␣@args;
␣␣␣␣my(@result)␣=␣$self->expand($type,@args);
␣␣␣␣my␣$result␣=␣@result␣==␣1␣?
␣␣␣␣␣␣␣␣$result[0]->as_string␣:
␣␣␣␣␣␣␣␣␣␣␣␣@result␣==␣0␣?
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"No␣objects␣of␣type␣$type␣found␣for␣argument␣@args\n"␣:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣join("",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(map␣{$_->as_glimpse}␣@result),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣scalar␣@result,␣"␣items␣found\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣$result;
}

#->␣sub␣CPAN::Shell::report_fh␣;
{
␣␣␣␣my␣$installation_report_fh;
␣␣␣␣my␣$previously_noticed␣=␣0;

␣␣␣␣sub␣report_fh␣{
␣␣␣␣␣␣␣␣return␣$installation_report_fh␣if␣$installation_report_fh;
␣␣␣␣␣␣␣␣if␣($CPAN::META->has_usable("File::Temp"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣$installation_report_fh
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣=␣File::Temp->new(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣dir␣␣␣␣␣␣=>␣File::Spec->tmpdir,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣template␣=>␣'cpan_install_XXXX',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣suffix␣␣␣=>␣'.txt',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣unlink␣␣␣=>␣0,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣unless␣(␣$installation_report_fh␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣warn("Couldn't␣open␣installation␣report␣file;␣"␣.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"no␣report␣file␣will␣be␣generated."
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣unless␣$previously_noticed++;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
}


#␣The␣only␣reason␣for␣this␣method␣is␣currently␣to␣have␣a␣reliable
#␣debugging␣utility␣that␣reveals␣which␣output␣is␣going␣through␣which
#␣channel.␣No,␣I␣don't␣like␣the␣colors␣;-)

#␣to␣turn␣colordebugging␣on,␣write
#␣cpan>␣o␣conf␣colorize_output␣1

#->␣sub␣CPAN::Shell::colorize_output␣;
{
␣␣␣␣my␣$print_ornamented_have_warned␣=␣0;
␣␣␣␣sub␣colorize_output␣{
␣␣␣␣␣␣␣␣my␣$colorize_output␣=␣$CPAN::Config->{colorize_output};
␣␣␣␣␣␣␣␣if␣($colorize_output␣&&␣!$CPAN::META->has_inst("Term::ANSIColor"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣unless␣($print_ornamented_have_warned++)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣no␣myprint/mywarn␣within␣myprint/mywarn!
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣warn␣"Colorize_output␣is␣set␣to␣true␣but␣Term::ANSIColor␣is␣not
installed.␣To␣activate␣colorized␣output,␣please␣install␣Term::ANSIColor.\n\n";
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$colorize_output␣=␣0;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣return␣$colorize_output;
␣␣␣␣}
}


#->␣sub␣CPAN::Shell::print_ornamented␣;
sub␣print_ornamented␣{
␣␣␣␣my($self,$what,$ornament)␣=␣@_;
␣␣␣␣return␣unless␣defined␣$what;

␣␣␣␣local␣$|␣=␣1;␣#␣Flush␣immediately
␣␣␣␣if␣(␣$CPAN::Be_Silent␣)␣{
␣␣␣␣␣␣␣␣print␣{report_fh()}␣$what;
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
␣␣␣␣my␣$swhat␣=␣"$what";␣#␣stringify␣if␣it␣is␣an␣object
␣␣␣␣if␣($CPAN::Config->{term_is_latin})␣{
␣␣␣␣␣␣␣␣#␣note:␣deprecated,␣need␣to␣switch␣to␣$LANG␣and␣$LC_*
␣␣␣␣␣␣␣␣#␣courtesy␣jhi:
␣␣␣␣␣␣␣␣$swhat
␣␣␣␣␣␣␣␣␣␣␣␣=~␣s{([\xC0-\xDF])([\x80-\xBF])}{chr(ord($1)<<6&0xC0|ord($2)&0x3F)}eg;␣#};
␣␣␣␣}
␣␣␣␣if␣($self->colorize_output)␣{
␣␣␣␣␣␣␣␣if␣(␣$CPAN::DEBUG␣&&␣$swhat␣=~␣/^Debug\(/␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣#␣if␣you␣want␣to␣have␣this␣configurable,␣please␣file␣a␣bugreport
␣␣␣␣␣␣␣␣␣␣␣␣$ornament␣=␣$CPAN::Config->{colorize_debug}␣||␣"black␣on_cyan";
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣my␣$color_on␣=␣eval␣{␣Term::ANSIColor::color($ornament)␣}␣||␣"";
␣␣␣␣␣␣␣␣if␣($@)␣{
␣␣␣␣␣␣␣␣␣␣␣␣print␣"Term::ANSIColor␣rejects␣color[$ornament]:␣$@\n
Please␣choose␣a␣different␣color␣(Hint:␣try␣'o␣conf␣init␣/color/')\n";
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣#␣GGOLDBACH/Test-GreaterVersion-0.008␣broke␣without␣this
␣␣␣␣␣␣␣␣#␣$trailer␣construct.␣We␣want␣the␣newline␣be␣the␣last␣thing␣if
␣␣␣␣␣␣␣␣#␣there␣is␣a␣newline␣at␣the␣end␣ensuring␣that␣the␣next␣line␣is
␣␣␣␣␣␣␣␣#␣empty␣for␣other␣players
␣␣␣␣␣␣␣␣my␣$trailer␣=␣"";
␣␣␣␣␣␣␣␣$trailer␣=␣$1␣if␣$swhat␣=~␣s/([\r\n]+)\z//;
␣␣␣␣␣␣␣␣print␣$color_on,
␣␣␣␣␣␣␣␣␣␣␣␣$swhat,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣Term::ANSIColor::color("reset"),
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$trailer;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣print␣$swhat;
␣␣␣␣}
}

#->␣sub␣CPAN::Shell::myprint␣;

#␣where␣is␣myprint/mywarn/Frontend/etc.␣documented?␣Where␣to␣use␣what?
#␣I␣think,␣we␣send␣everything␣to␣STDOUT␣and␣use␣print␣for␣normal/good
#␣news␣and␣warn␣for␣news␣that␣need␣more␣attention.␣Yes,␣this␣is␣our
#␣working␣contract␣for␣now.
sub␣myprint␣{
␣␣␣␣my($self,$what)␣=␣@_;
␣␣␣␣$self->print_ornamented($what,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Config->{colorize_print}||'bold␣blue␣on_white',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
}

my␣%already_printed;
#->␣sub␣CPAN::Shell::mywarnonce␣;
sub␣myprintonce␣{
␣␣␣␣my($self,$what)␣=␣@_;
␣␣␣␣$self->myprint($what)␣unless␣$already_printed{$what}++;
}

sub␣optprint␣{
␣␣␣␣my($self,$category,$what)␣=␣@_;
␣␣␣␣my␣$vname␣=␣$category␣.␣"_verbosity";
␣␣␣␣CPAN::HandleConfig->load␣unless␣$CPAN::Config_loaded++;
␣␣␣␣if␣(!$CPAN::Config->{$vname}
␣␣␣␣␣␣␣␣||␣$CPAN::Config->{$vname}␣=~␣/^v/
␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint($what);
␣␣␣␣}
}

#->␣sub␣CPAN::Shell::myexit␣;
sub␣myexit␣{
␣␣␣␣my($self,$what)␣=␣@_;
␣␣␣␣$self->myprint($what);
␣␣␣␣exit;
}

#->␣sub␣CPAN::Shell::mywarn␣;
sub␣mywarn␣{
␣␣␣␣my($self,$what)␣=␣@_;
␣␣␣␣$self->print_ornamented($what,␣$CPAN::Config->{colorize_warn}||'bold␣red␣on_white');
}

my␣%already_warned;
#->␣sub␣CPAN::Shell::mywarnonce␣;
sub␣mywarnonce␣{
␣␣␣␣my($self,$what)␣=␣@_;
␣␣␣␣$self->mywarn($what)␣unless␣$already_warned{$what}++;
}

#␣only␣to␣be␣used␣for␣shell␣commands
#->␣sub␣CPAN::Shell::mydie␣;
sub␣mydie␣{
␣␣␣␣my($self,$what)␣=␣@_;
␣␣␣␣$self->mywarn($what);

␣␣␣␣#␣If␣it␣is␣the␣shell,␣we␣want␣the␣following␣die␣to␣be␣silent,
␣␣␣␣#␣but␣if␣it␣is␣not␣the␣shell,␣we␣would␣need␣a␣'die␣$what'.␣We␣need
␣␣␣␣#␣to␣take␣care␣that␣only␣shell␣commands␣use␣mydie.␣Is␣this
␣␣␣␣#␣possible?

␣␣␣␣die␣"\n";
}

#␣sub␣CPAN::Shell::colorable_makemaker_prompt␣;
sub␣colorable_makemaker_prompt␣{
␣␣␣␣my($foo,$bar)␣=␣@_;
␣␣␣␣if␣(CPAN::Shell->colorize_output)␣{
␣␣␣␣␣␣␣␣my␣$ornament␣=␣$CPAN::Config->{colorize_print}||'bold␣blue␣on_white';
␣␣␣␣␣␣␣␣my␣$color_on␣=␣eval␣{␣Term::ANSIColor::color($ornament);␣}␣||␣"";
␣␣␣␣␣␣␣␣print␣$color_on;
␣␣␣␣}
␣␣␣␣my␣$ans␣=␣ExtUtils::MakeMaker::prompt($foo,$bar);
␣␣␣␣if␣(CPAN::Shell->colorize_output)␣{
␣␣␣␣␣␣␣␣print␣Term::ANSIColor::color('reset');
␣␣␣␣}
␣␣␣␣return␣$ans;
}

#␣use␣this␣only␣for␣unrecoverable␣errors!
#->␣sub␣CPAN::Shell::unrecoverable_error␣;
sub␣unrecoverable_error␣{
␣␣␣␣my($self,$what)␣=␣@_;
␣␣␣␣my␣@lines␣=␣split␣/\n/,␣$what;
␣␣␣␣my␣$longest␣=␣0;
␣␣␣␣for␣my␣$l␣(@lines)␣{
␣␣␣␣␣␣␣␣$longest␣=␣length␣$l␣if␣length␣$l␣>␣$longest;
␣␣␣␣}
␣␣␣␣$longest␣=␣62␣if␣$longest␣>␣62;
␣␣␣␣for␣my␣$l␣(@lines)␣{
␣␣␣␣␣␣␣␣if␣($l␣=~␣/^\s*$/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$l␣=␣"\n";
␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$l␣=␣"==>␣$l";
␣␣␣␣␣␣␣␣if␣(length␣$l␣<␣66)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$l␣=␣pack␣"A66␣A*",␣$l,␣"<==";
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$l␣.=␣"\n";
␣␣␣␣}
␣␣␣␣unshift␣@lines,␣"\n";
␣␣␣␣$self->mydie(join␣"",␣@lines);
}

#->␣sub␣CPAN::Shell::mysleep␣;
sub␣mysleep␣{
␣␣␣␣my($self,␣$sleep)␣=␣@_;
␣␣␣␣if␣(CPAN->has_inst("Time::HiRes"))␣{
␣␣␣␣␣␣␣␣Time::HiRes::sleep($sleep);
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣sleep($sleep␣<␣1␣?␣1␣:␣int($sleep␣+␣0.5));
␣␣␣␣}
}

#->␣sub␣CPAN::Shell::setup_output␣;
sub␣setup_output␣{
␣␣␣␣return␣if␣-t␣STDOUT;
␣␣␣␣my␣$odef␣=␣select␣STDERR;
␣␣␣␣$|␣=␣1;
␣␣␣␣select␣STDOUT;
␣␣␣␣$|␣=␣1;
␣␣␣␣select␣$odef;
}

#->␣sub␣CPAN::Shell::rematein␣;
#␣RE-adme||MA-ke||TE-st||IN-stall␣:␣nearly␣everything␣runs␣through␣here
sub␣rematein␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣#␣this␣variable␣was␣global␣and␣disturbed␣programmers,␣so␣localize:
␣␣␣␣local␣$CPAN::Distrostatus::something_has_failed_at;
␣␣␣␣my($meth,@some)␣=␣@_;
␣␣␣␣my␣@pragma;
␣␣␣␣while($meth␣=~␣/^(ff?orce|notest)$/)␣{
␣␣␣␣␣␣␣␣push␣@pragma,␣$meth;
␣␣␣␣␣␣␣␣$meth␣=␣shift␣@some␣or
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Pragma␣$pragma[-1]␣used␣without␣method:␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"cannot␣continue");
␣␣␣␣}
␣␣␣␣setup_output();
␣␣␣␣CPAN->debug("pragma[@pragma]meth[$meth]some[@some]")␣if␣$CPAN::DEBUG;

␣␣␣␣#␣Here␣is␣the␣place␣to␣set␣"test_count"␣on␣all␣involved␣parties␣to
␣␣␣␣#␣0.␣We␣then␣can␣pass␣this␣counter␣on␣to␣the␣involved
␣␣␣␣#␣distributions␣and␣those␣can␣refuse␣to␣test␣if␣test_count␣>␣X.␣In
␣␣␣␣#␣the␣first␣stab␣at␣it␣we␣could␣use␣a␣1␣for␣"X".

␣␣␣␣#␣But␣when␣do␣I␣reset␣the␣distributions␣to␣start␣with␣0␣again?
␣␣␣␣#␣Jost␣suggested␣to␣have␣a␣random␣or␣cycling␣interaction␣ID␣that
␣␣␣␣#␣we␣pass␣through.␣But␣the␣ID␣is␣something␣that␣is␣just␣left␣lying
␣␣␣␣#␣around␣in␣addition␣to␣the␣counter,␣so␣I'd␣prefer␣to␣set␣the
␣␣␣␣#␣counter␣to␣0␣now,␣and␣repeat␣at␣the␣end␣of␣the␣loop.␣But␣what
␣␣␣␣#␣about␣dependencies?␣They␣appear␣later␣and␣are␣not␣reset,␣they
␣␣␣␣#␣enter␣the␣queue␣but␣not␣its␣copy.␣How␣do␣they␣get␣a␣sensible
␣␣␣␣#␣test_count?

␣␣␣␣#␣With␣configure_requires,␣"get"␣is␣vulnerable␣in␣recursion.

␣␣␣␣my␣$needs_recursion_protection␣=␣"get|make|test|install";

␣␣␣␣#␣construct␣the␣queue
␣␣␣␣my($s,@s,@qcopy);
␣␣STHING:␣foreach␣$s␣(@some)␣{
␣␣␣␣␣␣␣␣my␣$obj;
␣␣␣␣␣␣␣␣if␣(ref␣$s)␣{
␣␣␣␣␣␣␣␣␣␣␣␣CPAN->debug("s␣is␣an␣object[$s]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣␣␣␣␣$obj␣=␣$s;
␣␣␣␣␣␣␣␣}␣elsif␣($s␣=~␣m|[\$\@\%]|)␣{␣#␣looks␣like␣a␣perl␣variable
␣␣␣␣␣␣␣␣}␣elsif␣($s␣=~␣m|^/|)␣{␣#␣looks␣like␣a␣regexp
␣␣␣␣␣␣␣␣␣␣␣␣if␣(substr($s,-1,1)␣eq␣".")␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj␣=␣CPAN::Shell->expandany($s);
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣@obj;
␣␣␣␣␣␣␣␣␣␣␣␣CLASS:␣for␣my␣$class␣(qw(Distribution␣Bundle␣Module))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(@obj␣=␣$self->expand($class,$s))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣last␣CLASS;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(@obj)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(1==@obj)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj␣=␣$obj[0];
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("Sorry,␣$meth␣with␣a␣regular␣expression␣is␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"only␣supported␣when␣unambiguous.\nRejecting␣argument␣'$s'\n");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mysleep(2);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣STHING;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣elsif␣($meth␣eq␣"ls")␣{
␣␣␣␣␣␣␣␣␣␣␣␣$self->globls($s,\@pragma);
␣␣␣␣␣␣␣␣␣␣␣␣next␣STHING;
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣CPAN->debug("calling␣expandany␣[$s]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣␣␣␣␣$obj␣=␣CPAN::Shell->expandany($s);
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣(0)␣{
␣␣␣␣␣␣␣␣}␣elsif␣(ref␣$obj)␣{
␣␣␣␣␣␣␣␣␣␣␣␣if␣($meth␣=~␣/^($needs_recursion_protection)$/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣it␣would␣be␣silly␣to␣check␣for␣recursion␣for␣look␣or␣dump
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣(we␣are␣in␣CPAN::Shell::rematein)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CPAN->debug("Going␣to␣test␣against␣recursion")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣eval␣{␣␣$obj->color_cmd_tmps(0,1);␣};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($@)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(ref␣$@
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣and␣$@->isa("CPAN::Exception::RecursiveDependency"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn($@);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(0)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣require␣Carp;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣Carp::confess(sprintf␣"DEBUG:␣\$\@[%s]ref[%s]",␣$@,␣ref␣$@);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣die;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣CPAN::Queue->queue_item(qmod␣=>␣$obj->id,␣reqtype␣=>␣"c");
␣␣␣␣␣␣␣␣␣␣␣␣push␣@qcopy,␣$obj;
␣␣␣␣␣␣␣␣}␣elsif␣($CPAN::META->exists('CPAN::Author',uc($s)))␣{
␣␣␣␣␣␣␣␣␣␣␣␣$obj␣=␣$CPAN::META->instance('CPAN::Author',uc($s));
␣␣␣␣␣␣␣␣␣␣␣␣if␣($meth␣=~␣/^(dump|ls|reports)$/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj->$meth();
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣join␣"",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Don't␣be␣silly,␣you␣can't␣$meth␣",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj->fullname,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"␣;-)\n"
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mysleep(2);
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣elsif␣($s␣=~␣m|[\$\@\%]|␣&&␣$meth␣eq␣"dump")␣{
␣␣␣␣␣␣␣␣␣␣␣␣CPAN::InfoObj->dump($s);
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣->mywarn(qq{Warning:␣Cannot␣$meth␣$s,␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{don't␣know␣what␣it␣is.
Try␣the␣command

␣␣␣␣i␣/$s/

to␣find␣objects␣with␣matching␣identifiers.
});
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mysleep(2);
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣#␣queuerunner␣(please␣be␣warned:␣when␣I␣started␣to␣change␣the
␣␣␣␣#␣queue␣to␣hold␣objects␣instead␣of␣names,␣I␣made␣one␣or␣two
␣␣␣␣#␣mistakes␣and␣never␣found␣which.␣I␣reverted␣back␣instead)
␣␣QITEM:␣while␣(my␣$q␣=␣CPAN::Queue->first)␣{
␣␣␣␣␣␣␣␣my␣$obj;
␣␣␣␣␣␣␣␣my␣$s␣=␣$q->as_string;
␣␣␣␣␣␣␣␣my␣$reqtype␣=␣$q->reqtype␣||␣"";
␣␣␣␣␣␣␣␣$obj␣=␣CPAN::Shell->expandany($s);
␣␣␣␣␣␣␣␣unless␣($obj)␣{
␣␣␣␣␣␣␣␣␣␣␣␣#␣don't␣know␣how␣this␣can␣happen,␣maybe␣we␣should␣panic,
␣␣␣␣␣␣␣␣␣␣␣␣#␣but␣maybe␣we␣get␣a␣solution␣from␣the␣first␣user␣who␣hits
␣␣␣␣␣␣␣␣␣␣␣␣#␣this␣unfortunate␣exception?
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("Warning:␣Could␣not␣expand␣string␣'$s'␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"to␣an␣object.␣Skipping.\n");
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mysleep(5);
␣␣␣␣␣␣␣␣␣␣␣␣CPAN::Queue->delete_first($s);
␣␣␣␣␣␣␣␣␣␣␣␣next␣QITEM;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$obj->{reqtype}␣||=␣"";
␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣#␣force␣debugging␣because␣CPAN::SQLite␣somehow␣delivers␣us
␣␣␣␣␣␣␣␣␣␣␣␣#␣an␣empty␣object;

␣␣␣␣␣␣␣␣␣␣␣␣#␣local␣$CPAN::DEBUG␣=␣1024;␣#␣Shell;␣probably␣fixed␣now

␣␣␣␣␣␣␣␣␣␣␣␣CPAN->debug("s[$s]obj-reqtype[$obj->{reqtype}]".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"q-reqtype[$reqtype]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣($obj->{reqtype})␣{
␣␣␣␣␣␣␣␣␣␣␣␣if␣($obj->{reqtype}␣eq␣"b"␣&&␣$reqtype␣=~␣/^[rc]$/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj->{reqtype}␣=␣$reqtype;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣exists␣$obj->{install}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣&&
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣UNIVERSAL::can($obj->{install},"failed")␣?
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj->{install}->failed␣:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj->{install}␣=~␣/^NO/
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣delete␣$obj->{install};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣("Promoting␣$obj->{ID}␣from␣'build_requires'␣to␣'requires'");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$obj->{reqtype}␣=␣$reqtype;
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣for␣my␣$pragma␣(@pragma)␣{
␣␣␣␣␣␣␣␣␣␣␣␣if␣($pragma
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣&&
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj->can($pragma))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj->$pragma($meth);
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣(UNIVERSAL::can($obj,␣'called_for'))␣{
␣␣␣␣␣␣␣␣␣␣␣␣$obj->called_for($s);
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣CPAN->debug(qq{pragma[@pragma]meth[$meth]}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{ID[$obj->{ID}]})␣if␣$CPAN::DEBUG;

␣␣␣␣␣␣␣␣push␣@qcopy,␣$obj;
␣␣␣␣␣␣␣␣if␣($meth␣=~␣/^(report)$/)␣{␣#␣they␣came␣here␣with␣a␣pragma?
␣␣␣␣␣␣␣␣␣␣␣␣$self->$meth($obj);
␣␣␣␣␣␣␣␣}␣elsif␣(!␣UNIVERSAL::can($obj,$meth))␣{
␣␣␣␣␣␣␣␣␣␣␣␣#␣Must␣never␣happen
␣␣␣␣␣␣␣␣␣␣␣␣my␣$serialized␣=␣"";
␣␣␣␣␣␣␣␣␣␣␣␣if␣(0)␣{
␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣($CPAN::META->has_inst("YAML::Syck"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$serialized␣=␣YAML::Syck::Dump($obj);
␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣($CPAN::META->has_inst("YAML"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$serialized␣=␣YAML::Dump($obj);
␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣($CPAN::META->has_inst("Data::Dumper"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$serialized␣=␣Data::Dumper::Dumper($obj);
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣require␣overload;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$serialized␣=␣overload::StrVal($obj);
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣CPAN->debug("Going␣to␣panic.␣meth[$meth]s[$s]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Panic:␣obj[$serialized]␣cannot␣meth[$meth]");
␣␣␣␣␣␣␣␣}␣elsif␣($obj->$meth())␣{
␣␣␣␣␣␣␣␣␣␣␣␣CPAN::Queue->delete($s);
␣␣␣␣␣␣␣␣␣␣␣␣CPAN->debug("From␣queue␣deleted.␣meth[$meth]s[$s]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣CPAN->debug("Failed.␣pragma[@pragma]meth[$meth]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣$obj->undelay;
␣␣␣␣␣␣␣␣for␣my␣$pragma␣(@pragma)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$unpragma␣=␣"un$pragma";
␣␣␣␣␣␣␣␣␣␣␣␣if␣($obj->can($unpragma))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$obj->$unpragma();
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣($CPAN::Config->{halt_on_failure}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣&&
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣CPAN::Distrostatus::something_has_just_failed()
␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("Stopping:␣'$meth'␣failed␣for␣'$s'.\n");
␣␣␣␣␣␣␣␣␣␣␣␣CPAN::Queue->nullify_queue;
␣␣␣␣␣␣␣␣␣␣␣␣last␣QITEM;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣CPAN::Queue->delete_first($s);
␣␣␣␣}
␣␣␣␣if␣($meth␣=~␣/^($needs_recursion_protection)$/)␣{
␣␣␣␣␣␣␣␣for␣my␣$obj␣(@qcopy)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$obj->color_cmd_tmps(0,0);
␣␣␣␣␣␣␣␣}
␣␣␣␣}
}

#->␣sub␣CPAN::Shell::recent␣;
sub␣recent␣{
␣␣my($self)␣=␣@_;
␣␣if␣($CPAN::META->has_inst("XML::LibXML"))␣{
␣␣␣␣␣␣my␣$url␣=␣$CPAN::Defaultrecent;
␣␣␣␣␣␣$CPAN::Frontend->myprint("Going␣to␣fetch␣'$url'\n");
␣␣␣␣␣␣unless␣($CPAN::META->has_usable("LWP"))␣{
␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("LWP␣not␣installed;␣cannot␣continue");
␣␣␣␣␣␣}
␣␣␣␣␣␣CPAN::LWP::UserAgent->config;
␣␣␣␣␣␣my␣$Ua;
␣␣␣␣␣␣eval␣{␣$Ua␣=␣CPAN::LWP::UserAgent->new;␣};
␣␣␣␣␣␣if␣($@)␣{
␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("CPAN::LWP::UserAgent->new␣dies␣with␣$@\n");
␣␣␣␣␣␣}
␣␣␣␣␣␣my␣$resp␣=␣$Ua->get($url);
␣␣␣␣␣␣unless␣($resp->is_success)␣{
␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie(sprintf␣"Could␣not␣download␣'%s':␣%s\n",␣$url,␣$resp->code);
␣␣␣␣␣␣}
␣␣␣␣␣␣$CPAN::Frontend->myprint("DONE\n\n");
␣␣␣␣␣␣my␣$xml␣=␣XML::LibXML->new->parse_string($resp->content);
␣␣␣␣␣␣if␣(0)␣{
␣␣␣␣␣␣␣␣␣␣my␣$s␣=␣$xml->serialize(2);
␣␣␣␣␣␣␣␣␣␣$s␣=~␣s/\n\s*\n/\n/g;
␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint($s);
␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣}
␣␣␣␣␣␣my␣@distros;
␣␣␣␣␣␣if␣($url␣=~␣/winnipeg/)␣{
␣␣␣␣␣␣␣␣␣␣my␣$pubdate␣=␣$xml->findvalue("/rss/channel/pubDate");
␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("␣␣␣␣pubDate:␣$pubdate\n\n");
␣␣␣␣␣␣␣␣␣␣for␣my␣$eitem␣($xml->findnodes("/rss/channel/item"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$distro␣=␣$eitem->findvalue("enclosure/\@url");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$distro␣=~␣s|.*?/authors/id/./../||;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$size␣␣␣=␣$eitem->findvalue("enclosure/\@length");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$desc␣␣␣=␣$eitem->findvalue("description");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$desc␣=~␣s/.+?␣-␣//;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("$distro␣[$size␣b]\n␣␣␣␣$desc\n");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@distros,␣$distro;
␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣}␣elsif␣($url␣=~␣/search.*uploads.rdf/)␣{
␣␣␣␣␣␣␣␣␣␣#␣xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
␣␣␣␣␣␣␣␣␣␣#␣xmlns="http://purl.org/rss/1.0/"
␣␣␣␣␣␣␣␣␣␣#␣xmlns:taxo="http://purl.org/rss/1.0/modules/taxonomy/"
␣␣␣␣␣␣␣␣␣␣#␣xmlns:dc="http://purl.org/dc/elements/1.1/"
␣␣␣␣␣␣␣␣␣␣#␣xmlns:syn="http://purl.org/rss/1.0/modules/syndication/"
␣␣␣␣␣␣␣␣␣␣#␣xmlns:admin="http://webns.net/mvcb/"


␣␣␣␣␣␣␣␣␣␣my␣$dc_date␣=␣$xml->findvalue("//*[local-name(.)␣=␣'RDF']/*[local-name(.)␣=␣'channel']/*[local-name(.)␣=␣'date']");
␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("␣␣␣␣dc:date:␣$dc_date\n\n");
␣␣␣␣␣␣␣␣␣␣my␣$finish_eitem␣=␣0;
␣␣␣␣␣␣␣␣␣␣local␣$SIG{INT}␣=␣sub␣{␣$finish_eitem␣=␣1␣};
␣␣␣␣␣␣␣␣EITEM:␣for␣my␣$eitem␣($xml->findnodes("//*[local-name(.)␣=␣'RDF']/*[local-name(.)␣=␣'item']"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$distro␣=␣$eitem->findvalue("\@rdf:about");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$distro␣=~␣s|.*~||;␣#␣remove␣up␣to␣the␣tilde␣before␣the␣name
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$distro␣=~␣s|/$||;␣#␣remove␣trailing␣slash
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$distro␣=~␣s|([^/]+)|\U$1\E|;␣#␣upcase␣the␣name
␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$author␣=␣uc␣$1␣or␣die␣"distro[$distro]␣without␣author,␣cannot␣continue";
␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$desc␣␣␣=␣$eitem->findvalue("*[local-name(.)␣=␣'description']");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$i␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣SUBDIRTEST:␣while␣()␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣last␣SUBDIRTEST␣if␣++$i␣>=␣6;␣#␣half␣a␣dozen␣must␣do!
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(my␣@ret␣=␣$self->globls("$distro*"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣@ret␣=␣grep␣{$_->[2]␣!~␣/meta/}␣@ret;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣@ret␣=␣grep␣{length␣$_->[2]}␣@ret;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(@ret)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$distro␣=␣"$author/$ret[0][2]";
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣last␣SUBDIRTEST;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$distro␣=~␣s|/|/*/|;␣#␣allow␣it␣to␣reside␣in␣a␣subdirectory
␣␣␣␣␣␣␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣EITEM␣if␣$distro␣=~␣m|\*|;␣#␣did␣not␣find␣the␣thing
␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("____$desc\n");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@distros,␣$distro;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣last␣EITEM␣if␣$finish_eitem;
␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣}
␣␣␣␣␣␣return␣\@distros;
␣␣}␣else␣{
␣␣␣␣␣␣#␣deprecated␣old␣version
␣␣␣␣␣␣$CPAN::Frontend->mydie("no␣XML::LibXML␣installed,␣cannot␣continue\n");
␣␣}
}

#->␣sub␣CPAN::Shell::smoke␣;
sub␣smoke␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣my␣$distros␣=␣$self->recent;
␣␣DISTRO:␣for␣my␣$distro␣(@$distros)␣{
␣␣␣␣␣␣␣␣next␣if␣$distro␣=~␣m|/Bundle-|;␣#␣XXX␣crude␣heuristic␣to␣skip␣bundles
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(sprintf␣"Going␣to␣download␣and␣test␣'$distro'\n");
␣␣␣␣␣␣␣␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$skip␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣local␣$SIG{INT}␣=␣sub␣{␣$skip␣=␣1␣};
␣␣␣␣␣␣␣␣␣␣␣␣for␣(0..9)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(sprintf␣"\r%2d␣(Hit␣^C␣to␣skip)",␣10-$_);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣sleep␣1;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($skip)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("␣skipped\n");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣DISTRO;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("\r␣␣\n");␣#␣leave␣the␣dirty␣line␣with␣a␣newline
␣␣␣␣␣␣␣␣$self->test($distro);
␣␣␣␣}
}

{
␣␣␣␣#␣set␣up␣the␣dispatching␣methods
␣␣␣␣no␣strict␣"refs";
␣␣␣␣for␣my␣$command␣(qw(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣clean
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣cvs_import
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣dump
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣force
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣fforce
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣get
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣install
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣look
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣ls
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣make
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣notest
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣perldoc
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣readme
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣reports
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣test
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣))␣{
␣␣␣␣␣␣␣␣*$command␣=␣sub␣{␣shift->rematein($command,␣@_);␣};
␣␣␣␣}
}

1;
#␣-*-␣Mode:␣cperl;␣coding:␣utf-8;␣cperl-indent-level:␣4␣-*-
#␣vim:␣ts=4␣sts=4␣sw=4:
package␣CPAN::LWP::UserAgent;
use␣strict;
use␣vars␣qw(@ISA␣$USER␣$PASSWD␣$SETUPDONE);
#␣we␣delay␣requiring␣LWP::UserAgent␣and␣setting␣up␣inheritance␣until␣we␣need␣it

$CPAN::LWP::UserAgent::VERSION␣=␣$CPAN::LWP::UserAgent::VERSION␣=␣"1.94";

sub␣config␣{
␣␣␣␣return␣if␣$SETUPDONE;
␣␣␣␣if␣($CPAN::META->has_usable('LWP::UserAgent'))␣{
␣␣␣␣␣␣␣␣require␣LWP::UserAgent;
␣␣␣␣␣␣␣␣@ISA␣=␣qw(Exporter␣LWP::UserAgent);␣##␣no␣critic
␣␣␣␣␣␣␣␣$SETUPDONE++;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("␣␣LWP::UserAgent␣not␣available\n");
␣␣␣␣}
}

sub␣get_basic_credentials␣{
␣␣␣␣my($self,␣$realm,␣$uri,␣$proxy)␣=␣@_;
␣␣␣␣if␣($USER␣&&␣$PASSWD)␣{
␣␣␣␣␣␣␣␣return␣($USER,␣$PASSWD);
␣␣␣␣}
␣␣␣␣if␣(␣$proxy␣)␣{
␣␣␣␣␣␣␣␣($USER,$PASSWD)␣=␣$self->get_proxy_credentials();
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣($USER,$PASSWD)␣=␣$self->get_non_proxy_credentials();
␣␣␣␣}
␣␣␣␣return($USER,$PASSWD);
}

sub␣get_proxy_credentials␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣($user,␣$password);
␣␣␣␣if␣(␣defined␣$CPAN::Config->{proxy_user}␣)␣{
␣␣␣␣␣␣␣␣$user␣=␣$CPAN::Config->{proxy_user};
␣␣␣␣␣␣␣␣$password␣=␣$CPAN::Config->{proxy_pass}␣||␣"";
␣␣␣␣␣␣␣␣return␣($user,␣$password);
␣␣␣␣}
␣␣␣␣my␣$username_prompt␣=␣"\nProxy␣authentication␣needed!
␣(Note:␣to␣permanently␣configure␣username␣and␣password␣run
␣␣␣o␣conf␣proxy_user␣your_username
␣␣␣o␣conf␣proxy_pass␣your_password
␣␣␣␣␣)\nUsername:";
␣␣␣␣($user,␣$password)␣=
␣␣␣␣␣␣␣␣_get_username_and_password_from_user($username_prompt);
␣␣␣␣return␣($user,$password);
}

sub␣get_non_proxy_credentials␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣($user,$password);
␣␣␣␣if␣(␣defined␣$CPAN::Config->{username}␣)␣{
␣␣␣␣␣␣␣␣$user␣=␣$CPAN::Config->{username};
␣␣␣␣␣␣␣␣$password␣=␣$CPAN::Config->{password}␣||␣"";
␣␣␣␣␣␣␣␣return␣($user,␣$password);
␣␣␣␣}
␣␣␣␣my␣$username_prompt␣=␣"\nAuthentication␣needed!
␣␣␣␣␣(Note:␣to␣permanently␣configure␣username␣and␣password␣run
␣␣␣␣␣␣␣o␣conf␣username␣your_username
␣␣␣␣␣␣␣o␣conf␣password␣your_password
␣␣␣␣␣)\nUsername:";

␣␣␣␣($user,␣$password)␣=
␣␣␣␣␣␣␣␣_get_username_and_password_from_user($username_prompt);
␣␣␣␣return␣($user,$password);
}

sub␣_get_username_and_password_from_user␣{
␣␣␣␣my␣$username_message␣=␣shift;
␣␣␣␣my␣($username,$password);

␣␣␣␣ExtUtils::MakeMaker->import(qw(prompt));
␣␣␣␣$username␣=␣prompt($username_message);
␣␣␣␣␣␣␣␣if␣($CPAN::META->has_inst("Term::ReadKey"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣Term::ReadKey::ReadMode("noecho");
␣␣␣␣␣␣␣␣}
␣␣␣␣else␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn(
␣␣␣␣␣␣␣␣␣␣␣␣"Warning:␣Term::ReadKey␣seems␣not␣to␣be␣available,␣your␣password␣will␣be␣echoed␣to␣the␣terminal!\n"
␣␣␣␣␣␣␣␣);
␣␣␣␣}
␣␣␣␣$password␣=␣prompt("Password:");

␣␣␣␣␣␣␣␣if␣($CPAN::META->has_inst("Term::ReadKey"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣Term::ReadKey::ReadMode("restore");
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("\n\n");
␣␣␣␣return␣($username,$password);
}

#␣mirror():␣Its␣purpose␣is␣to␣deal␣with␣proxy␣authentication.␣When␣we
#␣call␣SUPER::mirror,␣we␣relly␣call␣the␣mirror␣method␣in
#␣LWP::UserAgent.␣LWP::UserAgent␣will␣then␣call
#␣$self->get_basic_credentials␣or␣some␣equivalent␣and␣this␣will␣be
#␣$self->dispatched␣to␣our␣own␣get_basic_credentials␣method.

#␣Our␣own␣get_basic_credentials␣sets␣$USER␣and␣$PASSWD,␣two␣globals.

#␣407␣stands␣for␣HTTP_PROXY_AUTHENTICATION_REQUIRED.␣Which␣means
#␣although␣we␣have␣gone␣through␣our␣get_basic_credentials,␣the␣proxy
#␣server␣refuses␣to␣connect.␣This␣could␣be␣a␣case␣where␣the␣username␣or
#␣password␣has␣changed␣in␣the␣meantime,␣so␣I'm␣trying␣once␣again␣without
#␣$USER␣and␣$PASSWD␣to␣give␣the␣get_basic_credentials␣routine␣another
#␣chance␣to␣set␣$USER␣and␣$PASSWD.

#␣mirror():␣Its␣purpose␣is␣to␣deal␣with␣proxy␣authentication.␣When␣we
#␣call␣SUPER::mirror,␣we␣relly␣call␣the␣mirror␣method␣in
#␣LWP::UserAgent.␣LWP::UserAgent␣will␣then␣call
#␣$self->get_basic_credentials␣or␣some␣equivalent␣and␣this␣will␣be
#␣$self->dispatched␣to␣our␣own␣get_basic_credentials␣method.

#␣Our␣own␣get_basic_credentials␣sets␣$USER␣and␣$PASSWD,␣two␣globals.

#␣407␣stands␣for␣HTTP_PROXY_AUTHENTICATION_REQUIRED.␣Which␣means
#␣although␣we␣have␣gone␣through␣our␣get_basic_credentials,␣the␣proxy
#␣server␣refuses␣to␣connect.␣This␣could␣be␣a␣case␣where␣the␣username␣or
#␣password␣has␣changed␣in␣the␣meantime,␣so␣I'm␣trying␣once␣again␣without
#␣$USER␣and␣$PASSWD␣to␣give␣the␣get_basic_credentials␣routine␣another
#␣chance␣to␣set␣$USER␣and␣$PASSWD.

sub␣mirror␣{
␣␣␣␣my($self,$url,$aslocal)␣=␣@_;
␣␣␣␣my␣$result␣=␣$self->SUPER::mirror($url,$aslocal);
␣␣␣␣if␣($result->code␣==␣407)␣{
␣␣␣␣␣␣␣␣undef␣$USER;
␣␣␣␣␣␣␣␣undef␣$PASSWD;
␣␣␣␣␣␣␣␣$result␣=␣$self->SUPER::mirror($url,$aslocal);
␣␣␣␣}
␣␣␣␣$result;
}

1;
=head1␣NAME

CPAN::Kwalify␣-␣Interface␣between␣CPAN.pm␣and␣Kwalify.pm

=head1␣SYNOPSIS

␣␣use␣CPAN::Kwalify;
␣␣validate($schema_name,␣$data,␣$file,␣$doc);

=head1␣DESCRIPTION

=over

=item␣_validate($schema_name,␣$data,␣$file,␣$doc)

$schema_name␣is␣the␣name␣of␣a␣supported␣schema.␣Currently␣only
C<distroprefs>␣is␣supported.␣$data␣is␣the␣data␣to␣be␣validated.␣$file
is␣the␣absolute␣path␣to␣the␣file␣the␣data␣are␣coming␣from.␣$doc␣is␣the
index␣of␣the␣document␣within␣$doc␣that␣is␣to␣be␣validated.␣The␣last
two␣arguments␣are␣only␣there␣for␣better␣error␣reporting.

Relies␣on␣being␣called␣from␣within␣CPAN.pm.

Dies␣if␣something␣fails.␣Does␣not␣return␣anything␣useful.

=item␣yaml($schema_name)

Returns␣the␣YAML␣text␣of␣that␣schema.␣Dies␣if␣something␣fails.

=back

=head1␣AUTHOR

Andreas␣Koenig␣C<<␣<andk@cpan.org>␣>>

=head1␣LICENSE

This␣program␣is␣free␣software;␣you␣can␣redistribute␣it␣and/or
modify␣it␣under␣the␣same␣terms␣as␣Perl␣itself.

See␣L<http://www.perl.com/perl/misc/Artistic.html>



=cut


use␣strict;

package␣CPAN::Kwalify;
use␣vars␣qw($VERSION␣$VAR1);
$VERSION␣=␣"5.50";

use␣File::Spec␣();

my␣%vcache␣=␣();

my␣$schema_loaded␣=␣{};

sub␣_validate␣{
␣␣␣␣my($schema_name,$data,$abs,$y)␣=␣@_;
␣␣␣␣my␣$yaml_module␣=␣CPAN->_yaml_module;
␣␣␣␣if␣(
␣␣␣␣␣␣␣␣$CPAN::META->has_inst($yaml_module)
␣␣␣␣␣␣␣␣&&
␣␣␣␣␣␣␣␣$CPAN::META->has_inst("Kwalify")
␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣my␣$load␣=␣UNIVERSAL::can($yaml_module,"Load");
␣␣␣␣␣␣␣␣unless␣($schema_loaded->{$schema_name})␣{
␣␣␣␣␣␣␣␣␣␣␣␣eval␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$schema_yaml␣=␣yaml($schema_name);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$schema_loaded->{$schema_name}␣=␣$load->($schema_yaml);
␣␣␣␣␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣␣␣␣␣if␣($@)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣we␣know␣that␣YAML.pm␣0.62␣cannot␣parse␣the␣schema,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣so␣we␣try␣a␣fallback
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$content␣=␣do␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$path␣=␣__FILE__;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$path␣=~␣s/\.pm$//;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$path␣=␣File::Spec->catfile($path,␣"$schema_name.dd");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣local␣*FH;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣open␣FH,␣$path␣or␣die␣"Could␣not␣open␣'$path':␣$!";
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣local␣$/;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣<FH>;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$VAR1␣=␣undef;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣eval␣$content;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣(my␣$err␣=␣$@)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣die␣"parsing␣of␣'$schema_name.dd'␣failed:␣$err";
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$schema_loaded->{$schema_name}␣=␣$VAR1;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣if␣(my␣$schema␣=␣$schema_loaded->{$schema_name})␣{
␣␣␣␣␣␣␣␣my␣$mtime␣=␣(stat␣$abs)[9];
␣␣␣␣␣␣␣␣for␣my␣$k␣(keys␣%{$vcache{$abs}})␣{
␣␣␣␣␣␣␣␣␣␣␣␣delete␣$vcache{$abs}{$k}␣unless␣$k␣eq␣$mtime;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣return␣if␣$vcache{$abs}{$mtime}{$y}++;
␣␣␣␣␣␣␣␣eval␣{␣Kwalify::validate($schema,␣$data)␣};
␣␣␣␣␣␣␣␣if␣(my␣$err␣=␣$@)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$info␣=␣{};␣yaml($schema_name,␣info␣=>␣$info);
␣␣␣␣␣␣␣␣␣␣␣␣die␣"validation␣of␣distropref␣'$abs'[$y]␣against␣schema␣'$info->{path}'␣failed:␣$err";
␣␣␣␣␣␣␣␣}
␣␣␣␣}
}

sub␣_clear_cache␣{
␣␣␣␣%vcache␣=␣();
}

sub␣yaml␣{
␣␣␣␣my($schema_name,␣%opt)␣=␣@_;
␣␣␣␣my␣$content␣=␣do␣{
␣␣␣␣␣␣␣␣my␣$path␣=␣__FILE__;
␣␣␣␣␣␣␣␣$path␣=~␣s/\.pm$//;
␣␣␣␣␣␣␣␣$path␣=␣File::Spec->catfile($path,␣"$schema_name.yml");
␣␣␣␣␣␣␣␣if␣($opt{info})␣{
␣␣␣␣␣␣␣␣␣␣␣␣$opt{info}{path}␣=␣$path;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣local␣*FH;
␣␣␣␣␣␣␣␣open␣FH,␣$path␣or␣die␣"Could␣not␣open␣'$path':␣$!";
␣␣␣␣␣␣␣␣local␣$/;
␣␣␣␣␣␣␣␣<FH>;
␣␣␣␣};
␣␣␣␣return␣$content;
}

1;

#␣Local␣Variables:
#␣mode:␣cperl
#␣cperl-indent-level:␣4
#␣End:

#␣-*-␣Mode:␣cperl;␣coding:␣utf-8;␣cperl-indent-level:␣4␣-*-
#␣vim:␣ts=4␣sts=4␣sw=4:
package␣CPAN::Mirrors;
use␣strict;
use␣vars␣qw($VERSION␣$urllist␣$silent);
$VERSION␣=␣"1.77";

use␣Carp;
use␣FileHandle;
use␣Fcntl␣":flock";

sub␣new␣{
␣␣␣␣my␣($class,␣$file)␣=␣@_;
␣␣␣␣my␣$self␣=␣bless␣{␣
␣␣␣␣␣␣␣␣mirrors␣=>␣[],␣
␣␣␣␣␣␣␣␣geography␣=>␣{},
␣␣␣␣},␣$class;

␣␣␣␣my␣$handle␣=␣FileHandle->new;
␣␣␣␣$handle->open($file)␣
␣␣␣␣␣␣␣␣or␣croak␣"Couldn't␣open␣$file:␣$!";
␣␣␣␣flock␣$handle,␣LOCK_SH;
␣␣␣␣$self->_parse($file,$handle);
␣␣␣␣flock␣$handle,␣LOCK_UN;
␣␣␣␣$handle->close;

␣␣␣␣#␣populate␣continents␣&␣countries

␣␣␣␣return␣$self
}

sub␣continents␣{
␣␣␣␣my␣($self)␣=␣@_;
␣␣␣␣return␣keys␣%{$self->{geography}};
}

sub␣countries␣{
␣␣␣␣my␣($self,␣@continents)␣=␣@_;
␣␣␣␣@continents␣=␣$self->continents␣unless␣@continents;
␣␣␣␣my␣@countries;
␣␣␣␣for␣my␣$c␣(@continents)␣{
␣␣␣␣␣␣␣␣push␣@countries,␣keys␣%{␣$self->{geography}{$c}␣};
␣␣␣␣}
␣␣␣␣return␣@countries;
}

sub␣mirrors␣{
␣␣␣␣my␣($self,␣@countries)␣=␣@_;
␣␣␣␣return␣@{$self->{mirrors}}␣unless␣@countries;
␣␣␣␣my␣%wanted␣=␣map␣{␣$_␣=>␣1␣}␣@countries;
␣␣␣␣my␣@found;
␣␣␣␣for␣my␣$m␣(@{$self->{mirrors}})␣{
␣␣␣␣␣␣␣␣push␣@found,␣$m␣if␣exists␣$wanted{$m->country};
␣␣␣␣}
␣␣␣␣return␣@found;
}

sub␣best_mirrors␣{
␣␣␣␣my␣($self,␣%args)␣=␣@_;
␣␣␣␣my␣$how_many␣=␣$args{how_many}␣||␣1;
␣␣␣␣my␣$callback␣=␣$args{callback};
␣␣␣␣my␣$verbose␣=␣$args{verbose};
␣␣␣␣my␣$conts␣=␣$args{continents}␣||␣[];
␣␣␣␣$conts␣=␣[$conts]␣unless␣ref␣$conts;

␣␣␣␣my␣$seen␣=␣{};

␣␣␣␣if␣(␣!␣@$conts␣)␣{
␣␣␣␣␣␣␣␣print␣"Searching␣for␣the␣best␣continent␣...\n"␣if␣$verbose;
␣␣␣␣␣␣␣␣my␣@best␣=␣$self->_find_best_continent($seen,␣$verbose,␣$callback);

␣␣␣␣␣␣␣␣#␣how␣many␣continents␣to␣find␣enough␣mirrors?␣We␣should␣scan
␣␣␣␣␣␣␣␣#␣more␣than␣we␣need␣--␣arbitrarily,␣we'll␣say␣x2
␣␣␣␣␣␣␣␣my␣$count␣=␣0;
␣␣␣␣␣␣␣␣for␣my␣$c␣(␣@best␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣push␣@$conts,␣$c;
␣␣␣␣␣␣␣␣␣␣␣␣$count␣+=␣$self->mirrors(␣$self->countries($c)␣);
␣␣␣␣␣␣␣␣␣␣␣␣last␣if␣$count␣>=␣2␣*␣$how_many;
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣print␣"Scanning␣"␣.␣join(",␣",␣@$conts)␣.␣"␣...\n"␣if␣$verbose;

␣␣␣␣my␣@timings;
␣␣␣␣for␣my␣$m␣($self->mirrors($self->countries(@$conts)))␣{
␣␣␣␣␣␣␣␣next␣unless␣$m->ftp;
␣␣␣␣␣␣␣␣my␣$hostname␣=␣$m->hostname;
␣␣␣␣␣␣␣␣if␣(␣$seen->{$hostname}␣␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣push␣@timings,␣$seen->{$hostname}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣defined␣$seen->{$hostname}[1];
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$ping␣=␣$m->ping;
␣␣␣␣␣␣␣␣␣␣␣␣next␣unless␣defined␣$ping;
␣␣␣␣␣␣␣␣␣␣␣␣push␣@timings,␣[$m,␣$ping];
␣␣␣␣␣␣␣␣␣␣␣␣$callback->($m,$ping)␣if␣$callback;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣return␣unless␣@timings;
␣␣␣␣$how_many␣=␣@timings␣if␣$how_many␣>␣@timings;
␣␣␣␣my␣@best␣=
␣␣␣␣␣␣␣␣map␣␣{␣$_->[0]␣}
␣␣␣␣␣␣␣␣sort␣{␣$a->[1]␣<=>␣$b->[1]␣}␣@timings;

␣␣␣␣return␣wantarray␣?␣@best[0␣..␣$how_many-1]␣:␣$best[0];
}

sub␣_find_best_continent␣{
␣␣␣␣my␣($self,␣$seen,␣$verbose,␣$callback)␣=␣@_;

␣␣␣␣my␣%median;
␣␣␣␣CONT:␣for␣my␣$c␣(␣$self->continents␣)␣{
␣␣␣␣␣␣␣␣my␣@mirrors␣=␣$self->mirrors(␣$self->countries($c)␣);
␣␣␣␣␣␣␣␣next␣CONT␣unless␣@mirrors;
␣␣␣␣␣␣␣␣my␣$sample␣=␣9;
␣␣␣␣␣␣␣␣my␣$n␣=␣(@mirrors␣<␣$sample)␣?␣@mirrors␣:␣$sample;
␣␣␣␣␣␣␣␣my␣@tests;
␣␣␣␣␣␣␣␣RANDOM:␣while␣(␣@mirrors␣&&␣@tests␣<␣$n␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$m␣=␣splice(␣@mirrors,␣int(rand(@mirrors)),␣1␣);
␣␣␣␣␣␣␣␣␣␣␣␣my␣$ping␣=␣$m->ping;
␣␣␣␣␣␣␣␣␣␣␣␣$callback->($m,$ping)␣if␣$callback;
␣␣␣␣␣␣␣␣␣␣␣␣#␣record␣undef␣so␣we␣don't␣try␣again
␣␣␣␣␣␣␣␣␣␣␣␣$seen->{$m->hostname}␣=␣[$m,␣$ping];
␣␣␣␣␣␣␣␣␣␣␣␣next␣RANDOM␣unless␣defined␣$ping;
␣␣␣␣␣␣␣␣␣␣␣␣push␣@tests,␣$ping;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣next␣CONT␣unless␣@tests;
␣␣␣␣␣␣␣␣@tests␣=␣sort␣{␣$a␣<=>␣$b␣}␣@tests;
␣␣␣␣␣␣␣␣if␣(␣@tests␣==␣1␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$median{$c}␣=␣$tests[0];
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣elsif␣(␣@tests␣%␣2␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$median{$c}␣=␣$tests[␣int(@tests␣/␣2)␣];
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$mid_high␣=␣int(@tests/2);
␣␣␣␣␣␣␣␣␣␣␣␣$median{$c}␣=␣($tests[$mid_high-1]␣+␣$tests[$mid_high])/2;
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣my␣@best_cont␣=␣sort␣{␣$median{$a}␣<=>␣$median{$b}␣}␣keys␣%median␣;

␣␣␣␣if␣(␣$verbose␣)␣{
␣␣␣␣␣␣␣␣print␣"Median␣result␣by␣continent:\n";
␣␣␣␣␣␣␣␣for␣my␣$c␣(␣@best_cont␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣printf(␣"␣␣%d␣ms␣␣%s\n",␣int($median{$c}*1000+.5),␣$c␣);
␣␣␣␣␣␣␣␣}
␣␣␣␣}

␣␣␣␣return␣wantarray␣?␣@best_cont␣:␣$best_cont[0];
}

#␣Adapted␣from␣Parse::CPAN::MirroredBy␣by␣Adam␣Kennedy
sub␣_parse␣{
␣␣␣␣my␣($self,␣$file,␣$handle)␣=␣@_;
␣␣␣␣my␣$output␣=␣$self->{mirrors};
␣␣␣␣my␣$geo␣=␣$self->{geography};

␣␣␣␣local␣$/␣=␣"\012";
␣␣␣␣my␣$line␣=␣0;
␣␣␣␣my␣$mirror␣=␣undef;
␣␣␣␣while␣(␣1␣)␣{
␣␣␣␣␣␣␣␣#␣Next␣line
␣␣␣␣␣␣␣␣my␣$string␣=␣<$handle>;
␣␣␣␣␣␣␣␣last␣if␣!␣defined␣$string;
␣␣␣␣␣␣␣␣$line␣=␣$line␣+␣1;

␣␣␣␣␣␣␣␣#␣Remove␣the␣useless␣lines
␣␣␣␣␣␣␣␣chomp(␣$string␣);
␣␣␣␣␣␣␣␣next␣if␣$string␣=~␣/^\s*$/;
␣␣␣␣␣␣␣␣next␣if␣$string␣=~␣/^\s*#/;

␣␣␣␣␣␣␣␣#␣Hostname␣or␣property?
␣␣␣␣␣␣␣␣if␣(␣$string␣=~␣/^\s/␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣#␣Property
␣␣␣␣␣␣␣␣␣␣␣␣unless␣(␣$string␣=~␣/^\s+(\w+)\s+=\s+\"(.*)\"$/␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣croak("Invalid␣property␣on␣line␣$line");
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣my␣($prop,␣$value)␣=␣($1,$2);
␣␣␣␣␣␣␣␣␣␣␣␣$mirror␣||=␣{};
␣␣␣␣␣␣␣␣␣␣␣␣if␣(␣$prop␣eq␣'dst_location'␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣(@location,$continent,$country);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣@location␣=␣(split␣/\s*,\s*/,␣$value)␣
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣and␣($continent,␣$country)␣=␣@location[-1,-2];
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$continent␣=~␣s/\s\(.*//;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$continent␣=~␣s/\W+$//;␣#␣if␣Jarkko␣doesn't␣know␣latitude/longitude
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$geo->{$continent}{$country}␣=␣1␣if␣$continent␣&&␣$country;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mirror->{continent}␣=␣$continent␣||␣"unknown";
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mirror->{country}␣=␣$country␣||␣"unknown";
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣elsif␣(␣$prop␣eq␣'dst_http'␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mirror->{http}␣=␣$value;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣elsif␣(␣$prop␣eq␣'dst_ftp'␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mirror->{ftp}␣=␣$value;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣elsif␣(␣$prop␣eq␣'dst_rsync'␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mirror->{rsync}␣=␣$value;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$prop␣=~␣s/^dst_//;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$mirror->{$prop}␣=␣$value;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣#␣Hostname
␣␣␣␣␣␣␣␣␣␣␣␣unless␣(␣$string␣=~␣/^([\w\.-]+)\:\s*$/␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣croak("Invalid␣host␣name␣on␣line␣$line");
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣my␣$current␣=␣$mirror;
␣␣␣␣␣␣␣␣␣␣␣␣$mirror␣␣␣␣␣=␣{␣hostname␣=>␣"$1"␣};
␣␣␣␣␣␣␣␣␣␣␣␣if␣(␣$current␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@$output,␣CPAN::Mirrored::By->new($current);
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣if␣(␣$mirror␣)␣{
␣␣␣␣␣␣␣␣push␣@$output,␣CPAN::Mirrored::By->new($mirror);
␣␣␣␣}

␣␣␣␣return;
}

#--------------------------------------------------------------------------#

package␣CPAN::Mirrored::By;
use␣strict;
use␣Net::Ping␣␣␣();

sub␣new␣{
␣␣␣␣my($self,$arg)␣=␣@_;
␣␣␣␣$arg␣||=␣{};
␣␣␣␣bless␣$arg,␣$self;
}
sub␣hostname␣{␣shift->{hostname}␣}
sub␣continent␣{␣shift->{continent}␣}
sub␣country␣{␣shift->{country}␣}
sub␣http␣{␣shift->{http}␣||␣''␣}
sub␣ftp␣{␣shift->{ftp}␣||␣''␣}
sub␣rsync␣{␣shift->{rsync}␣||␣''␣}

sub␣url␣{␣
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣return␣$self->{ftp}␣||␣$self->{http};
}

sub␣ping␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$ping␣=␣Net::Ping->new("tcp",1);
␣␣␣␣my␣($proto)␣=␣$self->url␣=~␣m{^([^:]+)};
␣␣␣␣my␣$port␣=␣$proto␣eq␣'http'␣?␣80␣:␣21;
␣␣␣␣return␣unless␣$port;
␣␣␣␣$ping->port_number($port);
␣␣␣␣$ping->hires(1);
␣␣␣␣my␣($alive,$rtt)␣=␣$ping->ping($self->hostname);
␣␣␣␣return␣$alive␣?␣$rtt␣:␣undef;
}


1;

#␣-*-␣Mode:␣cperl;␣coding:␣utf-8;␣cperl-indent-level:␣4␣-*-
#␣vim:␣ts=4␣sts=4␣sw=4:
package␣CPAN::Prompt;
use␣overload␣'""'␣=>␣"as_string";
use␣vars␣qw($prompt);
use␣vars␣qw(
␣␣␣␣␣␣␣␣␣␣␣␣$VERSION
);
$VERSION␣=␣"5.5";


$prompt␣=␣"cpan>␣";
$CPAN::CurrentCommandId␣||=␣0;
sub␣new␣{
␣␣␣␣bless␣{},␣shift;
}
sub␣as_string␣{
␣␣␣␣my␣$word␣=␣"cpan";
␣␣␣␣unless␣($CPAN::META->{LOCK})␣{
␣␣␣␣␣␣␣␣$word␣=␣"nolock_cpan";
␣␣␣␣}
␣␣␣␣if␣($CPAN::Config->{commandnumber_in_prompt})␣{
␣␣␣␣␣␣␣␣sprintf␣"$word\[%d]>␣",␣$CPAN::CurrentCommandId;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣"$word>␣";
␣␣␣␣}
}

1;
#␣-*-␣Mode:␣cperl;␣coding:␣utf-8;␣cperl-indent-level:␣4␣-*-
#␣vim:␣ts=4␣sts=4␣sw=4:
package␣CPAN::InfoObj;
use␣strict;

use␣CPAN::Debug;
@CPAN::InfoObj::ISA␣=␣qw(CPAN::Debug);

use␣Cwd␣qw(chdir);

use␣vars␣qw(
␣␣␣␣␣␣␣␣␣␣␣␣$VERSION
);
$VERSION␣=␣"5.5";

sub␣ro␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣exists␣$self->{RO}␣and␣return␣$self->{RO};
}

#->␣sub␣CPAN::InfoObj::cpan_userid
sub␣cpan_userid␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$ro␣=␣$self->ro;
␣␣␣␣if␣($ro)␣{
␣␣␣␣␣␣␣␣return␣$ro->{CPAN_USERID}␣||␣"N/A";
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣$self->debug("ID[$self->{ID}]");
␣␣␣␣␣␣␣␣#␣N/A␣for␣bundles␣found␣locally
␣␣␣␣␣␣␣␣return␣"N/A";
␣␣␣␣}
}

sub␣id␣{␣shift->{ID};␣}

#->␣sub␣CPAN::InfoObj::new␣;
sub␣new␣{
␣␣␣␣my␣$this␣=␣bless␣{},␣shift;
␣␣␣␣%$this␣=␣@_;
␣␣␣␣$this
}

#␣The␣set␣method␣may␣only␣be␣used␣by␣code␣that␣reads␣index␣data␣or
#␣otherwise␣"objective"␣data␣from␣the␣outside␣world.␣All␣session
#␣related␣material␣may␣do␣anything␣else␣with␣instance␣variables␣but
#␣must␣not␣touch␣the␣hash␣under␣the␣RO␣attribute.␣The␣reason␣is␣that
#␣the␣RO␣hash␣gets␣written␣to␣Metadata␣file␣and␣is␣thus␣persistent.

#->␣sub␣CPAN::InfoObj::safe_chdir␣;
sub␣safe_chdir␣{
␣␣my($self,$todir)␣=␣@_;
␣␣#␣we␣die␣if␣we␣cannot␣chdir␣and␣we␣are␣debuggable
␣␣Carp::confess("safe_chdir␣called␣without␣todir␣argument")
␣␣␣␣␣␣␣␣unless␣defined␣$todir␣and␣length␣$todir;
␣␣if␣(chdir␣$todir)␣{
␣␣␣␣$self->debug(sprintf␣"changed␣directory␣to␣%s",␣CPAN::anycwd())
␣␣␣␣␣␣␣␣if␣$CPAN::DEBUG;
␣␣}␣else␣{
␣␣␣␣if␣(-e␣$todir)␣{
␣␣␣␣␣␣␣␣unless␣(-x␣$todir)␣{
␣␣␣␣␣␣␣␣␣␣␣␣unless␣(chmod␣0755,␣$todir)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$cwd␣=␣CPAN::anycwd();
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("I␣have␣neither␣the␣-x␣permission␣nor␣the␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"permission␣to␣change␣the␣permission;␣cannot␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"chdir␣to␣'$todir'\n");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mysleep(5);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie(qq{Could␣not␣chdir␣from␣cwd[$cwd]␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{to␣todir[$todir]:␣$!});
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Directory␣'$todir'␣has␣gone.␣Cannot␣continue.\n");
␣␣␣␣}
␣␣␣␣if␣(chdir␣$todir)␣{
␣␣␣␣␣␣$self->debug(sprintf␣"changed␣directory␣to␣%s",␣CPAN::anycwd())
␣␣␣␣␣␣␣␣␣␣if␣$CPAN::DEBUG;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣my␣$cwd␣=␣CPAN::anycwd();
␣␣␣␣␣␣$CPAN::Frontend->mydie(qq{Could␣not␣chdir␣from␣cwd[$cwd]␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{to␣todir[$todir]␣(a␣chmod␣has␣been␣issued):␣$!});
␣␣␣␣}
␣␣}
}

#->␣sub␣CPAN::InfoObj::set␣;
sub␣set␣{
␣␣␣␣my($self,%att)␣=␣@_;
␣␣␣␣my␣$class␣=␣ref␣$self;

␣␣␣␣#␣This␣must␣be␣||=,␣not␣||,␣because␣only␣if␣we␣write␣an␣empty
␣␣␣␣#␣reference,␣only␣then␣the␣set␣method␣will␣write␣into␣the␣readonly
␣␣␣␣#␣area.␣But␣for␣Distributions␣that␣spring␣into␣existence,␣maybe
␣␣␣␣#␣because␣of␣a␣typo,␣we␣do␣not␣like␣it␣that␣they␣are␣written␣into
␣␣␣␣#␣the␣readonly␣area␣and␣made␣permanent␣(at␣least␣for␣a␣while)␣and
␣␣␣␣#␣that␣is␣why␣we␣do␣not␣"allow"␣other␣places␣to␣call␣->set.
␣␣␣␣unless␣($self->id)␣{
␣␣␣␣␣␣␣␣CPAN->debug("Bug?␣Empty␣ID,␣rejecting");
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
␣␣␣␣my␣$ro␣=␣$self->{RO}␣=
␣␣␣␣␣␣␣␣$CPAN::META->{readonly}{$class}{$self->id}␣||=␣{};

␣␣␣␣while␣(my($k,$v)␣=␣each␣%att)␣{
␣␣␣␣␣␣␣␣$ro->{$k}␣=␣$v;
␣␣␣␣}
}

#->␣sub␣CPAN::InfoObj::as_glimpse␣;
sub␣as_glimpse␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣my(@m);
␣␣␣␣my␣$class␣=␣ref($self);
␣␣␣␣$class␣=~␣s/^CPAN:://;
␣␣␣␣my␣$id␣=␣$self->can("pretty_id")␣?␣$self->pretty_id␣:␣$self->{ID};
␣␣␣␣push␣@m,␣sprintf␣"%-15s␣%s\n",␣$class,␣$id;
␣␣␣␣join␣"",␣@m;
}

#->␣sub␣CPAN::InfoObj::as_string␣;
sub␣as_string␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣my(@m);
␣␣␣␣my␣$class␣=␣ref($self);
␣␣␣␣$class␣=~␣s/^CPAN:://;
␣␣␣␣push␣@m,␣$class,␣"␣id␣=␣$self->{ID}\n";
␣␣␣␣my␣$ro;
␣␣␣␣unless␣($ro␣=␣$self->ro)␣{
␣␣␣␣␣␣␣␣if␣(substr($self->{ID},-1,1)␣eq␣".")␣{␣#␣directory
␣␣␣␣␣␣␣␣␣␣␣␣$ro␣=␣+{};
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("Unknown␣object␣$self->{ID}\n");
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mysleep(5);
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣for␣(sort␣keys␣%$ro)␣{
␣␣␣␣␣␣␣␣#␣next␣if␣m/^(ID|RO)$/;
␣␣␣␣␣␣␣␣my␣$extra␣=␣"";
␣␣␣␣␣␣␣␣if␣($_␣eq␣"CPAN_USERID")␣{
␣␣␣␣␣␣␣␣␣␣␣␣$extra␣.=␣"␣(";
␣␣␣␣␣␣␣␣␣␣␣␣$extra␣.=␣$self->fullname;
␣␣␣␣␣␣␣␣␣␣␣␣my␣$email;␣#␣old␣perls!
␣␣␣␣␣␣␣␣␣␣␣␣if␣($email␣=␣$CPAN::META->instance("CPAN::Author",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->cpan_userid
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)->email)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$extra␣.=␣"␣<$email>";
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$extra␣.=␣"␣<no␣email>";
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$extra␣.=␣")";
␣␣␣␣␣␣␣␣}␣elsif␣($_␣eq␣"FULLNAME")␣{␣#␣potential␣UTF-8␣conversion
␣␣␣␣␣␣␣␣␣␣␣␣push␣@m,␣sprintf␣"␣␣␣␣%-12s␣%s\n",␣$_,␣$self->fullname;
␣␣␣␣␣␣␣␣␣␣␣␣next;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣next␣unless␣defined␣$ro->{$_};
␣␣␣␣␣␣␣␣push␣@m,␣sprintf␣"␣␣␣␣%-12s␣%s%s\n",␣$_,␣$ro->{$_},␣$extra;
␣␣␣␣}
␣␣KEY:␣for␣(sort␣keys␣%$self)␣{
␣␣␣␣␣␣␣␣next␣if␣m/^(ID|RO)$/;
␣␣␣␣␣␣␣␣unless␣(defined␣$self->{$_})␣{
␣␣␣␣␣␣␣␣␣␣␣␣delete␣$self->{$_};
␣␣␣␣␣␣␣␣␣␣␣␣next␣KEY;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣(ref($self->{$_})␣eq␣"ARRAY")␣{
␣␣␣␣␣␣␣␣␣␣␣␣push␣@m,␣sprintf␣"␣␣␣␣%-12s␣%s\n",␣$_,␣"@{$self->{$_}}";
␣␣␣␣␣␣␣␣}␣elsif␣(ref($self->{$_})␣eq␣"HASH")␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$value;
␣␣␣␣␣␣␣␣␣␣␣␣if␣(/^CONTAINSMODS$/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$value␣=␣join("␣",sort␣keys␣%{$self->{$_}});
␣␣␣␣␣␣␣␣␣␣␣␣}␣elsif␣(/^prereq_pm$/)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣@value;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$v␣=␣$self->{$_};
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣for␣my␣$x␣(sort␣keys␣%$v)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣@svalue;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣for␣my␣$y␣(sort␣keys␣%{$v->{$x}})␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@svalue,␣"$y=>$v->{$x}{$y}";
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@value,␣"$x\:"␣.␣join␣",",␣@svalue␣if␣@svalue;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$value␣=␣join␣";",␣@value;
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$value␣=␣$self->{$_};
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣push␣@m,␣sprintf(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"␣␣␣␣%-12s␣%s\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$_,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$value,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣push␣@m,␣sprintf␣"␣␣␣␣%-12s␣%s\n",␣$_,␣$self->{$_};
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣join␣"",␣@m,␣"\n";
}

#->␣sub␣CPAN::InfoObj::fullname␣;
sub␣fullname␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣$CPAN::META->instance("CPAN::Author",$self->cpan_userid)->fullname;
}

#->␣sub␣CPAN::InfoObj::dump␣;
sub␣dump␣{
␣␣␣␣my($self,␣$what)␣=␣@_;
␣␣␣␣unless␣($CPAN::META->has_inst("Data::Dumper"))␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("dump␣command␣requires␣Data::Dumper␣installed");
␣␣␣␣}
␣␣␣␣local␣$Data::Dumper::Sortkeys;
␣␣␣␣$Data::Dumper::Sortkeys␣=␣1;
␣␣␣␣my␣$out␣=␣Data::Dumper::Dumper($what␣?␣eval␣$what␣:␣$self);
␣␣␣␣if␣(length␣$out␣>␣100000)␣{
␣␣␣␣␣␣␣␣my␣$fh_pager␣=␣FileHandle->new;
␣␣␣␣␣␣␣␣local($SIG{PIPE})␣=␣"IGNORE";
␣␣␣␣␣␣␣␣my␣$pager␣=␣$CPAN::Config->{'pager'}␣||␣"cat";
␣␣␣␣␣␣␣␣$fh_pager->open("|$pager")
␣␣␣␣␣␣␣␣␣␣␣␣or␣die␣"Could␣not␣open␣pager␣$pager\:␣$!";
␣␣␣␣␣␣␣␣$fh_pager->print($out);
␣␣␣␣␣␣␣␣close␣$fh_pager;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint($out);
␣␣␣␣}
}

1;
#␣-*-␣Mode:␣cperl;␣coding:␣utf-8;␣cperl-indent-level:␣4␣-*-
package␣CPAN::Tarzip;
use␣strict;
use␣vars␣qw($VERSION␣@ISA␣$BUGHUNTING);
use␣CPAN::Debug;
use␣File::Basename␣qw(basename);
$VERSION␣=␣"5.5011";
#␣module␣is␣internal␣to␣CPAN.pm

@ISA␣=␣qw(CPAN::Debug);␣##␣no␣critic
$BUGHUNTING␣||=␣0;␣#␣released␣code␣must␣have␣turned␣off

#␣it's␣ok␣if␣file␣doesn't␣exist,␣it␣just␣matters␣if␣it␣is␣.gz␣or␣.bz2
sub␣new␣{
␣␣␣␣my($class,$file)␣=␣@_;
␣␣␣␣$CPAN::Frontend->mydie("CPAN::Tarzip->new␣called␣without␣arg")␣unless␣defined␣$file;
␣␣␣␣my␣$me␣=␣{␣FILE␣=>␣$file␣};
␣␣␣␣if␣($file␣=~␣/\.(bz2|gz|zip|tbz|tgz)$/i)␣{
␣␣␣␣␣␣␣␣$me->{ISCOMPRESSED}␣=␣1;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣$me->{ISCOMPRESSED}␣=␣0;
␣␣␣␣}
␣␣␣␣if␣(0)␣{
␣␣␣␣}␣elsif␣($file␣=~␣/\.(?:bz2|tbz)$/i)␣{
␣␣␣␣␣␣␣␣unless␣($me->{UNGZIPPRG}␣=␣$CPAN::Config->{bzip2})␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$bzip2␣=␣_my_which("bzip2");
␣␣␣␣␣␣␣␣␣␣␣␣if␣($bzip2)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$me->{UNGZIPPRG}␣=␣$bzip2;
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie(qq{
CPAN.pm␣needs␣the␣external␣program␣bzip2␣in␣order␣to␣handle␣'$file'.
Please␣install␣it␣now␣and␣run␣'o␣conf␣init␣bzip2'␣from␣the
CPAN␣shell␣prompt␣to␣register␣it␣as␣external␣program.
});
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣$me->{UNGZIPPRG}␣=␣_my_which("gzip");
␣␣␣␣}
␣␣␣␣$me->{TARPRG}␣=␣_my_which("tar")␣||␣_my_which("gtar");
␣␣␣␣bless␣$me,␣$class;
}

sub␣_my_which␣{
␣␣␣␣my($what)␣=␣@_;
␣␣␣␣if␣($CPAN::Config->{$what})␣{
␣␣␣␣␣␣␣␣return␣$CPAN::Config->{$what};
␣␣␣␣}
␣␣␣␣if␣($CPAN::META->has_inst("File::Which"))␣{
␣␣␣␣␣␣␣␣return␣File::Which::which($what);
␣␣␣␣}
␣␣␣␣my␣@cand␣=␣MM->maybe_command($what);
␣␣␣␣return␣$cand[0]␣if␣@cand;
␣␣␣␣require␣File::Spec;
␣␣␣␣my␣$component;
␣␣PATH_COMPONENT:␣foreach␣$component␣(File::Spec->path())␣{
␣␣␣␣␣␣␣␣next␣unless␣defined($component)␣&&␣$component;
␣␣␣␣␣␣␣␣my($abs)␣=␣File::Spec->catfile($component,$what);
␣␣␣␣␣␣␣␣if␣(MM->maybe_command($abs))␣{
␣␣␣␣␣␣␣␣␣␣␣␣return␣$abs;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣return;
}

sub␣gzip␣{
␣␣␣␣my($self,$read)␣=␣@_;
␣␣␣␣my␣$write␣=␣$self->{FILE};
␣␣␣␣if␣($CPAN::META->has_inst("Compress::Zlib"))␣{
␣␣␣␣␣␣␣␣my($buffer,$fhw);
␣␣␣␣␣␣␣␣$fhw␣=␣FileHandle->new($read)
␣␣␣␣␣␣␣␣␣␣␣␣or␣$CPAN::Frontend->mydie("Could␣not␣open␣$read:␣$!");
␣␣␣␣␣␣␣␣my␣$cwd␣=␣`pwd`;
␣␣␣␣␣␣␣␣my␣$gz␣=␣Compress::Zlib::gzopen($write,␣"wb")
␣␣␣␣␣␣␣␣␣␣␣␣or␣$CPAN::Frontend->mydie("Cannot␣gzopen␣$write:␣$!␣(pwd␣is␣$cwd)\n");
␣␣␣␣␣␣␣␣$gz->gzwrite($buffer)
␣␣␣␣␣␣␣␣␣␣␣␣while␣read($fhw,$buffer,4096)␣>␣0␣;
␣␣␣␣␣␣␣␣$gz->gzclose()␣;
␣␣␣␣␣␣␣␣$fhw->close;
␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣$command␣=␣CPAN::HandleConfig->safe_quote($self->{UNGZIPPRG});
␣␣␣␣␣␣␣␣system(qq{$command␣-c␣"$read"␣>␣"$write"})==0;
␣␣␣␣}
}


sub␣gunzip␣{
␣␣␣␣my($self,$write)␣=␣@_;
␣␣␣␣my␣$read␣=␣$self->{FILE};
␣␣␣␣if␣($CPAN::META->has_inst("Compress::Zlib"))␣{
␣␣␣␣␣␣␣␣my($buffer,$fhw);
␣␣␣␣␣␣␣␣$fhw␣=␣FileHandle->new(">$write")
␣␣␣␣␣␣␣␣␣␣␣␣or␣$CPAN::Frontend->mydie("Could␣not␣open␣>$write:␣$!");
␣␣␣␣␣␣␣␣my␣$gz␣=␣Compress::Zlib::gzopen($read,␣"rb")
␣␣␣␣␣␣␣␣␣␣␣␣or␣$CPAN::Frontend->mydie("Cannot␣gzopen␣$read:␣$!\n");
␣␣␣␣␣␣␣␣$fhw->print($buffer)
␣␣␣␣␣␣␣␣while␣$gz->gzread($buffer)␣>␣0␣;
␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Error␣reading␣from␣$read:␣$!\n")
␣␣␣␣␣␣␣␣␣␣␣␣if␣$gz->gzerror␣!=␣Compress::Zlib::Z_STREAM_END();
␣␣␣␣␣␣␣␣$gz->gzclose()␣;
␣␣␣␣␣␣␣␣$fhw->close;
␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣$command␣=␣CPAN::HandleConfig->safe_quote($self->{UNGZIPPRG});
␣␣␣␣␣␣␣␣system(qq{$command␣-dc␣"$read"␣>␣"$write"})==0;
␣␣␣␣}
}


sub␣gtest␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣return␣$self->{GTEST}␣if␣exists␣$self->{GTEST};
␣␣␣␣defined␣$self->{FILE}␣or␣$CPAN::Frontend->mydie("gtest␣called␣but␣no␣FILE␣specified");
␣␣␣␣my␣$read␣=␣$self->{FILE};
␣␣␣␣my␣$success;
␣␣␣␣if␣($read=~/\.(?:bz2|tbz)$/␣&&␣$CPAN::META->has_inst("Compress::Bzip2"))␣{
␣␣␣␣␣␣␣␣my($buffer,$len);
␣␣␣␣␣␣␣␣$len␣=␣0;
␣␣␣␣␣␣␣␣my␣$gz␣=␣Compress::Bzip2::bzopen($read,␣"rb")
␣␣␣␣␣␣␣␣␣␣␣␣or␣$CPAN::Frontend->mydie(sprintf("Cannot␣gzopen␣%s:␣%s\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$read,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$Compress::Bzip2::bzerrno));
␣␣␣␣␣␣␣␣while␣($gz->bzread($buffer)␣>␣0␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$len␣+=␣length($buffer);
␣␣␣␣␣␣␣␣␣␣␣␣$buffer␣=␣"";
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣my␣$err␣=␣$gz->bzerror;
␣␣␣␣␣␣␣␣$success␣=␣!␣$err␣||␣$err␣==␣Compress::Bzip2::BZ_STREAM_END();
␣␣␣␣␣␣␣␣if␣($len␣==␣-s␣$read)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$success␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣CPAN->debug("hit␣an␣uncompressed␣file")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$gz->gzclose();
␣␣␣␣␣␣␣␣CPAN->debug("err[$err]success[$success]")␣if␣$CPAN::DEBUG;
␣␣␣␣}␣elsif␣(␣$read=~/\.(?:gz|tgz)$/␣&&␣$CPAN::META->has_inst("Compress::Zlib")␣)␣{
␣␣␣␣␣␣␣␣#␣After␣I␣had␣reread␣the␣documentation␣in␣zlib.h,␣I␣discovered␣that
␣␣␣␣␣␣␣␣#␣uncompressed␣files␣do␣not␣lead␣to␣an␣gzerror␣(anymore?).
␣␣␣␣␣␣␣␣my($buffer,$len);
␣␣␣␣␣␣␣␣$len␣=␣0;
␣␣␣␣␣␣␣␣my␣$gz␣=␣Compress::Zlib::gzopen($read,␣"rb")
␣␣␣␣␣␣␣␣␣␣␣␣or␣$CPAN::Frontend->mydie(sprintf("Cannot␣gzopen␣%s:␣%s\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$read,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$Compress::Zlib::gzerrno));
␣␣␣␣␣␣␣␣while␣($gz->gzread($buffer)␣>␣0␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$len␣+=␣length($buffer);
␣␣␣␣␣␣␣␣␣␣␣␣$buffer␣=␣"";
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣my␣$err␣=␣$gz->gzerror;
␣␣␣␣␣␣␣␣$success␣=␣!␣$err␣||␣$err␣==␣Compress::Zlib::Z_STREAM_END();
␣␣␣␣␣␣␣␣if␣($len␣==␣-s␣$read)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$success␣=␣0;
␣␣␣␣␣␣␣␣␣␣␣␣CPAN->debug("hit␣an␣uncompressed␣file")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$gz->gzclose();
␣␣␣␣␣␣␣␣CPAN->debug("err[$err]success[$success]")␣if␣$CPAN::DEBUG;
␣␣␣␣}␣elsif␣(!$self->{ISCOMPRESSED})␣{
␣␣␣␣␣␣␣␣$success␣=␣0;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣$command␣=␣CPAN::HandleConfig->safe_quote($self->{UNGZIPPRG});
␣␣␣␣␣␣␣␣$success␣=␣0==system(qq{$command␣-qdt␣"$read"});
␣␣␣␣}
␣␣␣␣return␣$self->{GTEST}␣=␣$success;
}


sub␣TIEHANDLE␣{
␣␣␣␣my($class,$file)␣=␣@_;
␣␣␣␣my␣$ret;
␣␣␣␣$class->debug("file[$file]");
␣␣␣␣my␣$self␣=␣$class->new($file);
␣␣␣␣if␣(0)␣{
␣␣␣␣}␣elsif␣(!$self->gtest)␣{
␣␣␣␣␣␣␣␣my␣$fh␣=␣FileHandle->new($file)
␣␣␣␣␣␣␣␣␣␣␣␣or␣$CPAN::Frontend->mydie("Could␣not␣open␣file[$file]:␣$!");
␣␣␣␣␣␣␣␣binmode␣$fh;
␣␣␣␣␣␣␣␣$self->{FH}␣=␣$fh;
␣␣␣␣␣␣␣␣$class->debug("via␣uncompressed␣FH");
␣␣␣␣}␣elsif␣($file␣=~␣/\.(?:bz2|tbz)$/␣&&␣$CPAN::META->has_inst("Compress::Bzip2"))␣{
␣␣␣␣␣␣␣␣my␣$gz␣=␣Compress::Bzip2::bzopen($file,"rb")␣or
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Could␣not␣bzopen␣$file");
␣␣␣␣␣␣␣␣$self->{GZ}␣=␣$gz;
␣␣␣␣␣␣␣␣$class->debug("via␣Compress::Bzip2");
␣␣␣␣}␣elsif␣($file␣=~/\.(?:gz|tgz)$/␣&&␣$CPAN::META->has_inst("Compress::Zlib"))␣{
␣␣␣␣␣␣␣␣my␣$gz␣=␣Compress::Zlib::gzopen($file,"rb")␣or
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Could␣not␣gzopen␣$file");
␣␣␣␣␣␣␣␣$self->{GZ}␣=␣$gz;
␣␣␣␣␣␣␣␣$class->debug("via␣Compress::Zlib");
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣$gzip␣=␣CPAN::HandleConfig->safe_quote($self->{UNGZIPPRG});
␣␣␣␣␣␣␣␣my␣$pipe␣=␣"$gzip␣-dc␣$file␣|";
␣␣␣␣␣␣␣␣my␣$fh␣=␣FileHandle->new($pipe)␣or␣$CPAN::Frontend->mydie("Could␣not␣pipe[$pipe]:␣$!");
␣␣␣␣␣␣␣␣binmode␣$fh;
␣␣␣␣␣␣␣␣$self->{FH}␣=␣$fh;
␣␣␣␣␣␣␣␣$class->debug("via␣external␣$gzip");
␣␣␣␣}
␣␣␣␣$self;
}


sub␣READLINE␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣if␣(exists␣$self->{GZ})␣{
␣␣␣␣␣␣␣␣my␣$gz␣=␣$self->{GZ};
␣␣␣␣␣␣␣␣my($line,$bytesread);
␣␣␣␣␣␣␣␣$bytesread␣=␣$gz->gzreadline($line);
␣␣␣␣␣␣␣␣return␣undef␣if␣$bytesread␣<=␣0;
␣␣␣␣␣␣␣␣return␣$line;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣$fh␣=␣$self->{FH};
␣␣␣␣␣␣␣␣return␣scalar␣<$fh>;
␣␣␣␣}
}


sub␣READ␣{
␣␣␣␣my($self,$ref,$length,$offset)␣=␣@_;
␣␣␣␣$CPAN::Frontend->mydie("read␣with␣offset␣not␣implemented")␣if␣defined␣$offset;
␣␣␣␣if␣(exists␣$self->{GZ})␣{
␣␣␣␣␣␣␣␣my␣$gz␣=␣$self->{GZ};
␣␣␣␣␣␣␣␣my␣$byteread␣=␣$gz->gzread($$ref,$length);#␣30eaf79e8b446ef52464b5422da328a8
␣␣␣␣␣␣␣␣return␣$byteread;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣$fh␣=␣$self->{FH};
␣␣␣␣␣␣␣␣return␣read($fh,$$ref,$length);
␣␣␣␣}
}


sub␣DESTROY␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣if␣(exists␣$self->{GZ})␣{
␣␣␣␣␣␣␣␣my␣$gz␣=␣$self->{GZ};
␣␣␣␣␣␣␣␣$gz->gzclose()␣if␣defined␣$gz;␣#␣hard␣to␣say␣if␣it␣is␣allowed
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣to␣be␣undef␣ever.␣AK,␣2000-09
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣$fh␣=␣$self->{FH};
␣␣␣␣␣␣␣␣$fh->close␣if␣defined␣$fh;
␣␣␣␣}
␣␣␣␣undef␣$self;
}

sub␣untar␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣my␣$file␣=␣$self->{FILE};
␣␣␣␣my($prefer)␣=␣0;

␣␣␣␣my␣$exttar␣=␣$self->{TARPRG}␣||␣"";
␣␣␣␣$exttar␣=␣""␣if␣$exttar␣=~␣/^\s+$/;␣#␣user␣refuses␣to␣use␣it
␣␣␣␣my␣$extgzip␣=␣$self->{UNGZIPPRG}␣||␣"";
␣␣␣␣$extgzip␣=␣""␣if␣$extgzip␣=~␣/^\s+$/;␣#␣user␣refuses␣to␣use␣it

␣␣␣␣if␣(0)␣{␣#␣makes␣changing␣order␣easier
␣␣␣␣}␣elsif␣($BUGHUNTING)␣{
␣␣␣␣␣␣␣␣$prefer=2;
␣␣␣␣}␣elsif␣($exttar␣&&␣$extgzip␣&&␣$file␣=~␣/\.(?:bz2|tbz)$/i)␣{
␣␣␣␣␣␣␣␣#␣until␣Archive::Tar␣handles␣bzip2
␣␣␣␣␣␣␣␣$prefer␣=␣1;
␣␣␣␣}␣elsif␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::META->has_usable("Archive::Tar")
␣␣␣␣␣␣␣␣␣␣␣␣␣&&
␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::META->has_inst("Compress::Zlib")␣)␣{
␣␣␣␣␣␣␣␣$prefer␣=␣2;
␣␣␣␣}␣elsif␣($exttar␣&&␣$extgzip)␣{
␣␣␣␣␣␣␣␣#␣no␣modules␣and␣not␣bz2
␣␣␣␣␣␣␣␣$prefer␣=␣1;
␣␣␣␣␣␣␣␣#␣but␣solaris␣binary␣tar␣is␣a␣problem
␣␣␣␣␣␣␣␣if␣($^O␣eq␣'solaris'␣&&␣qx($exttar␣--version␣2>/dev/null)␣!~␣/gnu/i)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn(<<␣'END_WARN');

WARNING:␣Many␣CPAN␣distributions␣were␣archived␣with␣GNU␣tar␣and␣some␣of
them␣may␣be␣incompatible␣with␣Solaris␣tar.␣␣We␣respectfully␣suggest␣you
configure␣CPAN␣to␣use␣a␣GNU␣tar␣instead␣("o␣conf␣init␣tar")␣or␣install
a␣recent␣Archive::Tar␣instead;

END_WARN
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣my␣$foundtar␣=␣$exttar␣?␣"'$exttar'"␣:␣"nothing";
␣␣␣␣␣␣␣␣my␣$foundzip␣=␣$extgzip␣?␣"'$extgzip'"␣:␣$foundtar␣?␣"nothing"␣:␣"also␣nothing";
␣␣␣␣␣␣␣␣my␣$foundAT;
␣␣␣␣␣␣␣␣if␣($CPAN::META->has_usable("Archive::Tar"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣$foundAT␣=␣sprintf␣"'%s'",␣"Archive::Tar::"->VERSION;
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$foundAT␣=␣"nothing";
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣my␣$foundCZ;
␣␣␣␣␣␣␣␣if␣($CPAN::META->has_inst("Compress::Zlib"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣$foundCZ␣=␣sprintf␣"'%s'",␣"Compress::Zlib::"->VERSION;
␣␣␣␣␣␣␣␣}␣elsif␣($foundAT)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$foundCZ␣=␣"nothing";
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$foundCZ␣=␣"also␣nothing";
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie(qq{

CPAN.pm␣needs␣either␣the␣external␣programs␣tar␣and␣gzip␣-or-␣both
modules␣Archive::Tar␣and␣Compress::Zlib␣installed.

For␣tar␣I␣found␣$foundtar,␣for␣gzip␣$foundzip.

For␣Archive::Tar␣I␣found␣$foundAT,␣for␣Compress::Zlib␣$foundCZ;

Can't␣continue␣cutting␣file␣'$file'.
});
␣␣␣␣}
␣␣␣␣my␣$tar_verb␣=␣"v";
␣␣␣␣if␣(defined␣$CPAN::Config->{tar_verbosity})␣{
␣␣␣␣␣␣␣␣$tar_verb␣=␣$CPAN::Config->{tar_verbosity}␣eq␣"none"␣?␣""␣:
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Config->{tar_verbosity};
␣␣␣␣}
␣␣␣␣if␣($prefer==1)␣{␣#␣1␣=>␣external␣gzip+tar
␣␣␣␣␣␣␣␣my($system);
␣␣␣␣␣␣␣␣my␣$is_compressed␣=␣$self->gtest();
␣␣␣␣␣␣␣␣my␣$tarcommand␣=␣CPAN::HandleConfig->safe_quote($exttar);
␣␣␣␣␣␣␣␣if␣($is_compressed)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$command␣=␣CPAN::HandleConfig->safe_quote($extgzip);
␣␣␣␣␣␣␣␣␣␣␣␣$system␣=␣qq{$command␣-dc␣}.
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣qq{<␣"$file"␣|␣$tarcommand␣x${tar_verb}f␣-};
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$system␣=␣qq{$tarcommand␣x${tar_verb}f␣"$file"};
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣(system($system)␣!=␣0)␣{
␣␣␣␣␣␣␣␣␣␣␣␣#␣people␣find␣the␣most␣curious␣tar␣binaries␣that␣cannot␣handle
␣␣␣␣␣␣␣␣␣␣␣␣#␣pipes
␣␣␣␣␣␣␣␣␣␣␣␣if␣($is_compressed)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣(my␣$ungzf␣=␣$file)␣=~␣s/\.gz(?!\n)\Z//;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$ungzf␣=␣basename␣$ungzf;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣my␣$ct␣=␣CPAN::Tarzip->new($file);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($ct->gunzip($ungzf))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{Uncompressed␣$file␣successfully\n});
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie(qq{Couldn\'t␣uncompress␣$file\n});
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$file␣=␣$ungzf;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$system␣=␣qq{$tarcommand␣x${tar_verb}f␣"$file"};
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{Using␣Tar:$system:\n});
␣␣␣␣␣␣␣␣␣␣␣␣if␣(system($system)==0)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint(qq{Untarred␣$file␣successfully\n});
␣␣␣␣␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie(qq{Couldn\'t␣untar␣$file\n});
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣elsif␣($prefer==2)␣{␣#␣2␣=>␣modules
␣␣␣␣␣␣␣␣unless␣($CPAN::META->has_usable("Archive::Tar"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Archive::Tar␣not␣installed,␣please␣install␣it␣to␣continue");
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣#␣Make␣sure␣AT␣does␣not␣use␣uid/gid/permissions␣in␣the␣archive
␣␣␣␣␣␣␣␣#␣This␣leaves␣it␣to␣the␣user's␣umask␣instead
␣␣␣␣␣␣␣␣local␣$Archive::Tar::CHMOD␣=␣1;
␣␣␣␣␣␣␣␣local␣$Archive::Tar::SAME_PERMISSIONS␣=␣0;
␣␣␣␣␣␣␣␣#␣Make␣sure␣AT␣leaves␣current␣user␣as␣owner
␣␣␣␣␣␣␣␣local␣$Archive::Tar::CHOWN␣=␣0;
␣␣␣␣␣␣␣␣my␣$tar␣=␣Archive::Tar->new($file,1);
␣␣␣␣␣␣␣␣my␣$af;␣#␣archive␣file
␣␣␣␣␣␣␣␣my␣@af;
␣␣␣␣␣␣␣␣if␣($BUGHUNTING)␣{
␣␣␣␣␣␣␣␣␣␣␣␣#␣RCS␣1.337␣had␣this␣code,␣it␣turned␣out␣unacceptable␣slow␣but
␣␣␣␣␣␣␣␣␣␣␣␣#␣it␣revealed␣a␣bug␣in␣Archive::Tar.␣Code␣is␣only␣here␣to␣hunt
␣␣␣␣␣␣␣␣␣␣␣␣#␣the␣bug␣again.␣It␣should␣never␣be␣enabled␣in␣published␣code.
␣␣␣␣␣␣␣␣␣␣␣␣#␣GDGraph3d-0.53␣was␣an␣interesting␣case␣according␣to␣Larry
␣␣␣␣␣␣␣␣␣␣␣␣#␣Virden.
␣␣␣␣␣␣␣␣␣␣␣␣warn(">>>Bughunting␣code␣enabled<<<␣"␣x␣20);
␣␣␣␣␣␣␣␣␣␣␣␣for␣$af␣($tar->list_files)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($af␣=~␣m!^(/|\.\./)!)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("ALERT:␣Archive␣contains␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"illegal␣member␣[$af]");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("$af\n");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$tar->extract($af);␣#␣slow␣but␣effective␣for␣finding␣the␣bug
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣if␣$CPAN::Signal;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣for␣$af␣($tar->list_files)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($af␣=~␣m!^(/|\.\./)!)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("ALERT:␣Archive␣contains␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"illegal␣member␣[$af]");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣if␣($tar_verb␣eq␣"v"␣||␣$tar_verb␣eq␣"vv")␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("$af\n");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣push␣@af,␣$af;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣if␣$CPAN::Signal;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$tar->extract(@af)␣or
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Could␣not␣untar␣with␣Archive::Tar.");
␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣Mac::BuildTools::convert_files([$tar->list_files],␣1)
␣␣␣␣␣␣␣␣␣␣␣␣if␣($^O␣eq␣'MacOS');

␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}
}

sub␣unzip␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣my␣$file␣=␣$self->{FILE};
␣␣␣␣if␣($CPAN::META->has_inst("Archive::Zip"))␣{
␣␣␣␣␣␣␣␣#␣blueprint␣of␣the␣code␣from␣Archive::Zip::Tree::extractTree();
␣␣␣␣␣␣␣␣my␣$zip␣=␣Archive::Zip->new();
␣␣␣␣␣␣␣␣my␣$status;
␣␣␣␣␣␣␣␣$status␣=␣$zip->read($file);
␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Read␣of␣file[$file]␣failed\n")
␣␣␣␣␣␣␣␣␣␣␣␣if␣$status␣!=␣Archive::Zip::AZ_OK();
␣␣␣␣␣␣␣␣$CPAN::META->debug("Successfully␣read␣file[$file]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣my␣@members␣=␣$zip->members();
␣␣␣␣␣␣␣␣for␣my␣$member␣(␣@members␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$af␣=␣$member->fileName();
␣␣␣␣␣␣␣␣␣␣␣␣if␣($af␣=~␣m!^(/|\.\./)!)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("ALERT:␣Archive␣contains␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"illegal␣member␣[$af]");
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$status␣=␣$member->extractToFileNamed(␣$af␣);
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::META->debug("af[$af]status[$status]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Extracting␣of␣file[$af]␣from␣zipfile[$file]␣failed\n")␣if
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$status␣!=␣Archive::Zip::AZ_OK();
␣␣␣␣␣␣␣␣␣␣␣␣return␣if␣$CPAN::Signal;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣}␣elsif␣(␣my␣$unzip␣=␣$CPAN::Config->{unzip}␣␣)␣{
␣␣␣␣␣␣␣␣my␣@system␣=␣($unzip,␣$file);
␣␣␣␣␣␣␣␣return␣system(@system)␣==␣0;
␣␣␣␣}
␣␣␣␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie(<<"END");

Can't␣unzip␣'$file':

You␣have␣not␣configured␣an␣'unzip'␣program␣and␣do␣not␣have␣Archive::Zip
installed.␣␣Please␣either␣install␣Archive::Zip␣or␣else␣configure␣'unzip'
by␣running␣the␣command␣'o␣conf␣init␣unzip'␣from␣the␣CPAN␣shell␣prompt.

END
␣␣␣␣}
}

1;

package␣CPAN::Version;

use␣strict;
use␣vars␣qw($VERSION);
$VERSION␣=␣"5.5";

#␣CPAN::Version::vcmp␣courtesy␣Jost␣Krieger
sub␣vcmp␣{
␣␣␣␣my($self,$l,$r)␣=␣@_;
␣␣␣␣local($^W)␣=␣0;
␣␣␣␣CPAN->debug("l[$l]␣r[$r]")␣if␣$CPAN::DEBUG;

␣␣␣␣return␣0␣if␣$l␣eq␣$r;␣#␣short␣circuit␣for␣quicker␣success

␣␣␣␣for␣($l,$r)␣{
␣␣␣␣␣␣␣␣s/_//g;
␣␣␣␣}
␣␣␣␣CPAN->debug("l[$l]␣r[$r]")␣if␣$CPAN::DEBUG;
␣␣␣␣for␣($l,$r)␣{
␣␣␣␣␣␣␣␣next␣unless␣tr/.//␣>␣1␣||␣/^v/;
␣␣␣␣␣␣␣␣s/^v?/v/;
␣␣␣␣␣␣␣␣1␣while␣s/\.0+(\d)/.$1/;␣#␣remove␣leading␣zeroes␣per␣group
␣␣␣␣}
␣␣␣␣CPAN->debug("l[$l]␣r[$r]")␣if␣$CPAN::DEBUG;
␣␣␣␣if␣($l=~/^v/␣<=>␣$r=~/^v/)␣{
␣␣␣␣␣␣␣␣for␣($l,$r)␣{
␣␣␣␣␣␣␣␣␣␣␣␣next␣if␣/^v/;
␣␣␣␣␣␣␣␣␣␣␣␣$_␣=␣$self->float2vv($_);
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣CPAN->debug("l[$l]␣r[$r]")␣if␣$CPAN::DEBUG;
␣␣␣␣my␣$lvstring␣=␣"v0";
␣␣␣␣my␣$rvstring␣=␣"v0";
␣␣␣␣if␣($]␣>=␣5.006
␣␣␣␣␣&&␣$l␣=~␣/^v/
␣␣␣␣␣&&␣$r␣=~␣/^v/)␣{
␣␣␣␣␣␣␣␣$lvstring␣=␣$self->vstring($l);
␣␣␣␣␣␣␣␣$rvstring␣=␣$self->vstring($r);
␣␣␣␣␣␣␣␣CPAN->debug(sprintf␣"lv[%vd]␣rv[%vd]",␣$lvstring,␣$rvstring)␣if␣$CPAN::DEBUG;
␣␣␣␣}

␣␣␣␣return␣(
␣␣␣␣␣␣␣␣␣␣␣␣($l␣ne␣"undef")␣<=>␣($r␣ne␣"undef")
␣␣␣␣␣␣␣␣␣␣␣␣||
␣␣␣␣␣␣␣␣␣␣␣␣$lvstring␣cmp␣$rvstring
␣␣␣␣␣␣␣␣␣␣␣␣||
␣␣␣␣␣␣␣␣␣␣␣␣$l␣<=>␣$r
␣␣␣␣␣␣␣␣␣␣␣␣||
␣␣␣␣␣␣␣␣␣␣␣␣$l␣cmp␣$r
␣␣␣␣);
}

sub␣vgt␣{
␣␣␣␣my($self,$l,$r)␣=␣@_;
␣␣␣␣$self->vcmp($l,$r)␣>␣0;
}

sub␣vlt␣{
␣␣␣␣my($self,$l,$r)␣=␣@_;
␣␣␣␣0␣+␣($self->vcmp($l,$r)␣<␣0);
}

sub␣vge␣{
␣␣␣␣my($self,$l,$r)␣=␣@_;
␣␣␣␣$self->vcmp($l,$r)␣>=␣0;
}

sub␣vle␣{
␣␣␣␣my($self,$l,$r)␣=␣@_;
␣␣␣␣0␣+␣($self->vcmp($l,$r)␣<=␣0);
}

sub␣vstring␣{
␣␣␣␣my($self,$n)␣=␣@_;
␣␣␣␣$n␣=~␣s/^v//␣or␣die␣"CPAN::Version::vstring()␣called␣with␣invalid␣arg␣[$n]";
␣␣␣␣pack␣"U*",␣split␣/\./,␣$n;
}

#␣vv␣=>␣visible␣vstring
sub␣float2vv␣{
␣␣␣␣my($self,$n)␣=␣@_;
␣␣␣␣my($rev)␣=␣int($n);
␣␣␣␣$rev␣||=␣0;
␣␣␣␣my($mantissa)␣=␣$n␣=~␣/\.(\d{1,12})/;␣#␣limit␣to␣12␣digits␣to␣limit
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣architecture␣influence
␣␣␣␣$mantissa␣||=␣0;
␣␣␣␣$mantissa␣.=␣"0"␣while␣length($mantissa)%3;
␣␣␣␣my␣$ret␣=␣"v"␣.␣$rev;
␣␣␣␣while␣($mantissa)␣{
␣␣␣␣␣␣␣␣$mantissa␣=~␣s/(\d{1,3})//␣or
␣␣␣␣␣␣␣␣␣␣␣␣die␣"Panic:␣length>0␣but␣not␣a␣digit?␣mantissa[$mantissa]";
␣␣␣␣␣␣␣␣$ret␣.=␣".".int($1);
␣␣␣␣}
␣␣␣␣#␣warn␣"n[$n]ret[$ret]";
␣␣␣␣$ret␣=~␣s/(\.0)+/.0/;␣#␣v1.0.0␣=>␣v1.0
␣␣␣␣$ret;
}

sub␣readable␣{
␣␣␣␣my($self,$n)␣=␣@_;
␣␣␣␣$n␣=~␣/^([\w\-\+\.]+)/;

␣␣␣␣return␣$1␣if␣defined␣$1␣&&␣length($1)>0;
␣␣␣␣#␣if␣the␣first␣user␣reaches␣version␣v43,␣he␣will␣be␣treated␣as␣"+".
␣␣␣␣#␣We'll␣have␣to␣decide␣about␣a␣new␣rule␣here␣then,␣depending␣on␣what
␣␣␣␣#␣will␣be␣the␣prevailing␣versioning␣behavior␣then.

␣␣␣␣if␣($]␣<␣5.006)␣{␣#␣or␣whenever␣v-strings␣were␣introduced
␣␣␣␣␣␣␣␣#␣we␣get␣them␣wrong␣anyway,␣whatever␣we␣do,␣because␣5.005␣will
␣␣␣␣␣␣␣␣#␣have␣already␣interpreted␣0.2.4␣to␣be␣"0.24".␣So␣even␣if␣he
␣␣␣␣␣␣␣␣#␣indexer␣sends␣us␣something␣like␣"v0.2.4"␣we␣compare␣wrongly.

␣␣␣␣␣␣␣␣#␣And␣if␣they␣say␣v1.2,␣then␣the␣old␣perl␣takes␣it␣as␣"v12"

␣␣␣␣␣␣␣␣if␣(defined␣$CPAN::Frontend)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("Suspicious␣version␣string␣seen␣[$n]\n");
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣warn("Suspicious␣version␣string␣seen␣[$n]\n");
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣return␣$n;
␣␣␣␣}
␣␣␣␣my␣$better␣=␣sprintf␣"v%vd",␣$n;
␣␣␣␣CPAN->debug("n[$n]␣better[$better]")␣if␣$CPAN::DEBUG;
␣␣␣␣return␣$better;
}

1;

package␣CPAN::Distribution;
use␣strict;
use␣Cwd␣qw(chdir);
use␣CPAN::Distroprefs;
use␣CPAN::InfoObj;
@CPAN::Distribution::ISA␣=␣qw(CPAN::InfoObj);
use␣vars␣qw($VERSION);
$VERSION␣=␣"1.9456_01";

#␣Accessors
sub␣cpan_comment␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$ro␣=␣$self->ro␣or␣return;
␣␣␣␣$ro->{CPAN_COMMENT}
}

#->␣CPAN::Distribution::undelay
sub␣undelay␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣for␣my␣$delayer␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"configure_requires_later",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"configure_requires_later_for",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"later",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"later_for",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣delete␣$self->{$delayer};
␣␣␣␣}
}

#->␣CPAN::Distribution::is_dot_dist
sub␣is_dot_dist␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣return␣substr($self->id,-1,1)␣eq␣".";
}

#␣add␣the␣A/AN/␣stuff
#->␣CPAN::Distribution::normalize
sub␣normalize␣{
␣␣␣␣my($self,$s)␣=␣@_;
␣␣␣␣$s␣=␣$self->id␣unless␣defined␣$s;
␣␣␣␣if␣(substr($s,-1,1)␣eq␣".")␣{
␣␣␣␣␣␣␣␣#␣using␣a␣global␣because␣we␣are␣sometimes␣called␣as␣static␣method
␣␣␣␣␣␣␣␣if␣(!$CPAN::META->{LOCK}
␣␣␣␣␣␣␣␣␣␣␣␣&&␣!$CPAN::Have_warned->{"$s␣is␣unlocked"}++
␣␣␣␣␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("You␣are␣visiting␣the␣local␣directory
␣␣'$s'
␣␣without␣lock,␣take␣care␣that␣concurrent␣processes␣do␣not␣do␣likewise.\n");
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mysleep(1);
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣($s␣eq␣".")␣{
␣␣␣␣␣␣␣␣␣␣␣␣$s␣=␣"$CPAN::iCwd/.";
␣␣␣␣␣␣␣␣}␣elsif␣(File::Spec->file_name_is_absolute($s))␣{
␣␣␣␣␣␣␣␣}␣elsif␣(File::Spec->can("rel2abs"))␣{
␣␣␣␣␣␣␣␣␣␣␣␣$s␣=␣File::Spec->rel2abs($s);
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Your␣File::Spec␣is␣too␣old,␣please␣upgrade␣File::Spec");
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣CPAN->debug("s[$s]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣unless␣($CPAN::META->exists("CPAN::Distribution",␣$s))␣{
␣␣␣␣␣␣␣␣␣␣␣␣for␣($CPAN::META->instance("CPAN::Distribution",␣$s))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$_->{build_dir}␣=␣$s;
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$_->{archived}␣=␣"local_directory";
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$_->{unwrapped}␣=␣CPAN::Distrostatus->new("YES␣--␣local_directory");
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣}
␣␣␣␣}␣elsif␣(
␣␣␣␣␣␣␣␣$s␣=~␣tr|/||␣==␣1
␣␣␣␣␣␣␣␣or
␣␣␣␣␣␣␣␣$s␣!~␣m|[A-Z]/[A-Z-]{2}/[A-Z-]{2,}/|
␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣return␣$s␣if␣$s␣=~␣m:^N/A|^Contact␣Author:␣;
␣␣␣␣␣␣␣␣$s␣=~␣s|^(.)(.)([^/]*/)(.+)$|$1/$1$2/$1$2$3$4|;
␣␣␣␣␣␣␣␣CPAN->debug("s[$s]")␣if␣$CPAN::DEBUG;
␣␣␣␣}
␣␣␣␣$s;
}

#->␣sub␣CPAN::Distribution::author␣;
sub␣author␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣my($authorid);
␣␣␣␣if␣(substr($self->id,-1,1)␣eq␣".")␣{
␣␣␣␣␣␣␣␣$authorid␣=␣"LOCAL";
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣($authorid)␣=␣$self->pretty_id␣=~␣/^([\w\-]+)/;
␣␣␣␣}
␣␣␣␣CPAN::Shell->expand("Author",$authorid);
}

#␣tries␣to␣get␣the␣yaml␣from␣CPAN␣instead␣of␣the␣distro␣itself:
#␣EXPERIMENTAL,␣UNDOCUMENTED␣AND␣UNTESTED,␣for␣Tels
sub␣fast_yaml␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣my␣$meta␣=␣$self->pretty_id;
␣␣␣␣$meta␣=~␣s/\.(tar.gz|tgz|zip|tar.bz2)/.meta/;
␣␣␣␣my(@ls)␣=␣CPAN::Shell->globls($meta);
␣␣␣␣my␣$norm␣=␣$self->normalize($meta);

␣␣␣␣my($local_file);
␣␣␣␣my($local_wanted)␣=
␣␣␣␣␣␣␣␣File::Spec->catfile(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Config->{keep_source_where},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"authors",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"id",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣split(/\//,$norm)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣$self->debug("Doing␣localize")␣if␣$CPAN::DEBUG;
␣␣␣␣unless␣($local_file␣=
␣␣␣␣␣␣␣␣␣␣␣␣CPAN::FTP->localize("authors/id/$norm",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$local_wanted))␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Giving␣up␣on␣downloading␣yaml␣file␣'$local_wanted'\n");
␣␣␣␣}
␣␣␣␣my␣$yaml␣=␣CPAN->_yaml_loadfile($local_file)->[0];
}

#->␣sub␣CPAN::Distribution::cpan_userid
sub␣cpan_userid␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣if␣($self->{ID}␣=~␣m{[A-Z]/[A-Z\-]{2}/([A-Z\-]+)/})␣{
␣␣␣␣␣␣␣␣return␣$1;
␣␣␣␣}
␣␣␣␣return␣$self->SUPER::cpan_userid;
}

#->␣sub␣CPAN::Distribution::pretty_id
sub␣pretty_id␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$id␣=␣$self->id;
␣␣␣␣return␣$id␣unless␣$id␣=~␣m|^./../|;
␣␣␣␣substr($id,5);
}

#->␣sub␣CPAN::Distribution::base_id
sub␣base_id␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣my␣$id␣=␣$self->pretty_id();
␣␣␣␣my␣$base_id␣=␣File::Basename::basename($id);
␣␣␣␣$base_id␣=~␣s{\.(?:tar\.(bz2|gz|Z)|t(?:gz|bz)|zip)$}{}i;
␣␣␣␣return␣$base_id;
}

#->␣sub␣CPAN::Distribution::tested_ok_but_not_installed
sub␣tested_ok_but_not_installed␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣return␣(
␣␣␣␣␣␣␣␣␣␣␣$self->{make_test}
␣␣␣␣␣␣␣␣&&␣$self->{build_dir}
␣␣␣␣␣␣␣␣&&␣(UNIVERSAL::can($self->{make_test},"failed")␣?
␣␣␣␣␣␣␣␣␣␣␣␣␣!␣$self->{make_test}->failed␣:
␣␣␣␣␣␣␣␣␣␣␣␣␣$self->{make_test}␣=~␣/^YES/
␣␣␣␣␣␣␣␣␣␣␣␣)
␣␣␣␣␣␣␣␣&&␣(
␣␣␣␣␣␣␣␣␣␣␣␣!$self->{install}
␣␣␣␣␣␣␣␣␣␣␣␣||
␣␣␣␣␣␣␣␣␣␣␣␣$self->{install}->failed
␣␣␣␣␣␣␣␣␣␣␣)
␣␣␣␣);␣
}


#␣mark␣as␣dirty/clean␣for␣the␣sake␣of␣recursion␣detection.␣$color=1
#␣means␣"in␣use",␣$color=0␣means␣"not␣in␣use␣anymore".␣$color=2␣means
#␣we␣have␣determined␣prereqs␣now␣and␣thus␣insist␣on␣passing␣this
#␣through␣(at␣least)␣once␣again.

#->␣sub␣CPAN::Distribution::color_cmd_tmps␣;
sub␣color_cmd_tmps␣{
␣␣␣␣my($self)␣=␣shift;
␣␣␣␣my($depth)␣=␣shift␣||␣0;
␣␣␣␣my($color)␣=␣shift␣||␣0;
␣␣␣␣my($ancestors)␣=␣shift␣||␣[];
␣␣␣␣#␣a␣distribution␣needs␣to␣recurse␣into␣its␣prereq_pms
␣␣␣␣$self->debug("color_cmd_tmps[$depth,$color,@$ancestors]")␣if␣$CPAN::DEBUG;

␣␣␣␣return␣if␣exists␣$self->{incommandcolor}
␣␣␣␣␣␣␣␣&&␣$color==1
␣␣␣␣␣␣␣␣&&␣$self->{incommandcolor}==$color;
␣␣␣␣if␣($depth>=$CPAN::MAX_RECURSION)␣{
␣␣␣␣␣␣␣␣die(CPAN::Exception::RecursiveDependency->new($ancestors));
␣␣␣␣}
␣␣␣␣#␣warn␣"color_cmd_tmps␣$depth␣$color␣"␣.␣$self->id;␣#␣sleep␣1;
␣␣␣␣my␣$prereq_pm␣=␣$self->prereq_pm;
␣␣␣␣if␣(defined␣$prereq_pm)␣{
␣␣␣␣␣␣PREREQ:␣for␣my␣$pre␣(keys␣%{$prereq_pm->{requires}||{}},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣keys␣%{$prereq_pm->{build_requires}||{}})␣{
␣␣␣␣␣␣␣␣␣␣␣␣next␣PREREQ␣if␣$pre␣eq␣"perl";
␣␣␣␣␣␣␣␣␣␣␣␣my␣$premo;
␣␣␣␣␣␣␣␣␣␣␣␣unless␣($premo␣=␣CPAN::Shell->expand("Module",$pre))␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn("prerequisite␣module[$pre]␣not␣known\n");
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mysleep(2);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣next␣PREREQ;
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣$premo->color_cmd_tmps($depth+1,$color,[@$ancestors,␣$self->id]);
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣if␣($color==0)␣{
␣␣␣␣␣␣␣␣delete␣$self->{sponsored_mods};

␣␣␣␣␣␣␣␣#␣as␣we␣are␣at␣the␣end␣of␣a␣command,␣we'll␣give␣up␣this
␣␣␣␣␣␣␣␣#␣reminder␣of␣a␣broken␣test.␣Other␣commands␣may␣test␣this␣guy
␣␣␣␣␣␣␣␣#␣again.␣Maybe␣'badtestcnt'␣should␣be␣renamed␣to
␣␣␣␣␣␣␣␣#␣'make_test_failed_within_command'?
␣␣␣␣␣␣␣␣delete␣$self->{badtestcnt};
␣␣␣␣}
␣␣␣␣$self->{incommandcolor}␣=␣$color;
}

#->␣sub␣CPAN::Distribution::as_string␣;
sub␣as_string␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣$self->containsmods;
␣␣␣␣$self->upload_date;
␣␣␣␣$self->SUPER::as_string(@_);
}

#->␣sub␣CPAN::Distribution::containsmods␣;
sub␣containsmods␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣return␣keys␣%{$self->{CONTAINSMODS}}␣if␣exists␣$self->{CONTAINSMODS};
␣␣␣␣my␣$dist_id␣=␣$self->{ID};
␣␣␣␣for␣my␣$mod␣($CPAN::META->all_objects("CPAN::Module"))␣{
␣␣␣␣␣␣␣␣my␣$mod_file␣=␣$mod->cpan_file␣or␣next;
␣␣␣␣␣␣␣␣my␣$mod_id␣=␣$mod->{ID}␣or␣next;
␣␣␣␣␣␣␣␣#␣warn␣"mod_file[$mod_file]␣dist_id[$dist_id]␣mod_id[$mod_id]";
␣␣␣␣␣␣␣␣#␣sleep␣1;
␣␣␣␣␣␣␣␣if␣($CPAN::Signal)␣{
␣␣␣␣␣␣␣␣␣␣␣␣delete␣$self->{CONTAINSMODS};
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$self->{CONTAINSMODS}{$mod_id}␣=␣undef␣if␣$mod_file␣eq␣$dist_id;
␣␣␣␣}
␣␣␣␣keys␣%{$self->{CONTAINSMODS}||={}};
}

#->␣sub␣CPAN::Distribution::upload_date␣;
sub␣upload_date␣{
␣␣␣␣my␣$self␣=␣shift;
␣␣␣␣return␣$self->{UPLOAD_DATE}␣if␣exists␣$self->{UPLOAD_DATE};
␣␣␣␣my(@local_wanted)␣=␣split(/\//,$self->id);
␣␣␣␣my␣$filename␣=␣pop␣@local_wanted;
␣␣␣␣push␣@local_wanted,␣"CHECKSUMS";
␣␣␣␣my␣$author␣=␣CPAN::Shell->expand("Author",$self->cpan_userid);
␣␣␣␣return␣unless␣$author;
␣␣␣␣my␣@dl␣=␣$author->dir_listing(\@local_wanted,0,$CPAN::Config->{show_upload_date});
␣␣␣␣return␣unless␣@dl;
␣␣␣␣my($dirent)␣=␣grep␣{␣$_->[2]␣eq␣$filename␣}␣@dl;
␣␣␣␣#␣warn␣sprintf␣"dirent[%s]id[%s]",␣$dirent,␣$self->id;
␣␣␣␣return␣unless␣$dirent->[1];
␣␣␣␣return␣$self->{UPLOAD_DATE}␣=␣$dirent->[1];
}

#->␣sub␣CPAN::Distribution::uptodate␣;
sub␣uptodate␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣my␣$c;
␣␣␣␣foreach␣$c␣($self->containsmods)␣{
␣␣␣␣␣␣␣␣my␣$obj␣=␣CPAN::Shell->expandany($c);
␣␣␣␣␣␣␣␣unless␣($obj->uptodate)␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$id␣=␣$self->pretty_id;
␣␣␣␣␣␣␣␣␣␣␣␣$self->debug("$id␣not␣uptodate␣due␣to␣$c")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣␣␣␣␣return␣0;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣return␣1;
}

#->␣sub␣CPAN::Distribution::called_for␣;
sub␣called_for␣{
␣␣␣␣my($self,$id)␣=␣@_;
␣␣␣␣$self->{CALLED_FOR}␣=␣$id␣if␣defined␣$id;
␣␣␣␣return␣$self->{CALLED_FOR};
}

#->␣sub␣CPAN::Distribution::get␣;
sub␣get␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣$self->debug("checking␣goto␣id[$self->{ID}]")␣if␣$CPAN::DEBUG;
␣␣␣␣if␣(my␣$goto␣=␣$self->prefs->{goto})␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn
␣␣␣␣␣␣␣␣␣␣␣␣(sprintf(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"delegating␣to␣'%s'␣as␣specified␣in␣prefs␣file␣'%s'␣doc␣%d\n",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$goto,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->{prefs_file},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->{prefs_file_doc},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣));
␣␣␣␣␣␣␣␣return␣$self->goto($goto);
␣␣␣␣}
␣␣␣␣local␣$ENV{PERL5LIB}␣=␣defined($ENV{PERL5LIB})
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣?␣$ENV{PERL5LIB}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣:␣($ENV{PERLLIB}␣||␣"");
␣␣␣␣local␣$ENV{PERL5OPT}␣=␣defined␣$ENV{PERL5OPT}␣?␣$ENV{PERL5OPT}␣:␣"";
␣␣␣␣$CPAN::META->set_perl5lib;
␣␣␣␣local␣$ENV{MAKEFLAGS};␣#␣protect␣us␣from␣outer␣make␣calls

␣␣EXCUSE:␣{
␣␣␣␣␣␣␣␣my␣@e;
␣␣␣␣␣␣␣␣my␣$goodbye_message;
␣␣␣␣␣␣␣␣$self->debug("checking␣disabled␣id[$self->{ID}]")␣if␣$CPAN::DEBUG;
␣␣␣␣␣␣␣␣if␣($self->prefs->{disabled}␣&&␣!␣$self->{force_update})␣{
␣␣␣␣␣␣␣␣␣␣␣␣my␣$why␣=␣sprintf(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"Disabled␣via␣prefs␣file␣'%s'␣doc␣%d",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->{prefs_file},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->{prefs_file_doc},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣push␣@e,␣$why;
␣␣␣␣␣␣␣␣␣␣␣␣$self->{unwrapped}␣=␣CPAN::Distrostatus->new("NO␣$why");
␣␣␣␣␣␣␣␣␣␣␣␣$goodbye_message␣=␣"[disabled]␣--␣NA␣$why";
␣␣␣␣␣␣␣␣␣␣␣␣#␣note:␣not␣intended␣to␣be␣persistent␣but␣at␣least␣visible
␣␣␣␣␣␣␣␣␣␣␣␣#␣during␣this␣session
␣␣␣␣␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣␣␣␣␣if␣(exists␣$self->{build_dir}␣&&␣-d␣$self->{build_dir}
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣&&␣($self->{modulebuild}||$self->{writemakefile})
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣this␣deserves␣print,␣not␣warn:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->myprint("␣␣Has␣already␣been␣unwrapped␣into␣directory␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"$self->{build_dir}\n"
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣return␣1;
␣␣␣␣␣␣␣␣␣␣␣␣}

␣␣␣␣␣␣␣␣␣␣␣␣#␣although␣we␣talk␣about␣'force'␣we␣shall␣not␣test␣on
␣␣␣␣␣␣␣␣␣␣␣␣#␣force␣directly.␣New␣model␣of␣force␣tries␣to␣refrain␣from
␣␣␣␣␣␣␣␣␣␣␣␣#␣direct␣checking␣of␣force.
␣␣␣␣␣␣␣␣␣␣␣␣exists␣$self->{unwrapped}␣and␣(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣UNIVERSAL::can($self->{unwrapped},"failed")␣?
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->{unwrapped}->failed␣:
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->{unwrapped}␣=~␣/^NO/
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣and␣push␣@e,␣"Unwrapping␣had␣some␣problem,␣won't␣try␣again␣without␣force";
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣if␣(@e)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Frontend->mywarn(join␣"",␣map␣{"$_\n"}␣@e);
␣␣␣␣␣␣␣␣␣␣␣␣if␣($goodbye_message)␣{
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$self->goodbye($goodbye_message);
␣␣␣␣␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣}
␣␣␣␣my␣$sub_wd␣=␣CPAN::anycwd();␣#␣for␣cleaning␣up␣as␣good␣as␣possible

␣␣␣␣my($local_file);
␣␣␣␣unless␣($self->{build_dir}␣&&␣-d␣$self->{build_dir})␣{
␣␣␣␣␣␣␣␣$self->get_file_onto_local_disk;
␣␣␣␣␣␣␣␣return␣if␣$CPAN::Signal;
␣␣␣␣␣␣␣␣$self->check_integrity;
␣␣␣␣␣␣␣␣return␣if␣$CPAN::Signal;
␣␣␣␣␣␣␣␣(my␣$packagedir,$local_file)␣=␣$self->run_preps_on_packagedir;
␣␣␣␣␣␣␣␣if␣(exists␣$self->{writemakefile}␣&&␣ref␣$self->{writemakefile}
␣␣␣␣␣␣␣␣␣␣␣&&␣$self->{writemakefile}->can("failed")␣&&
␣␣␣␣␣␣␣␣␣␣␣$self->{writemakefile}->failed)␣{
␣␣␣␣␣␣␣␣␣␣␣␣return;
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$packagedir␣||=␣$self->{build_dir};
␣␣␣␣␣␣␣␣$self->{build_dir}␣=␣$packagedir;
␣␣␣␣}

␣␣␣␣if␣($CPAN::Signal)␣{
␣␣␣␣␣␣␣␣$self->safe_chdir($sub_wd);
␣␣␣␣␣␣␣␣return;
␣␣␣␣}
␣␣␣␣return␣$self->choose_MM_or_MB($local_file);
}

#->␣CPAN::Distribution::get_file_onto_local_disk
sub␣get_file_onto_local_disk␣{
␣␣␣␣my($self)␣=␣@_;

␣␣␣␣return␣if␣$self->is_dot_dist;
␣␣␣␣my($local_file);
␣␣␣␣my($local_wanted)␣=
␣␣␣␣␣␣␣␣File::Spec->catfile(
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$CPAN::Config->{keep_source_where},
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"authors",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"id",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣split(/\//,$self->id)
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣$self->debug("Doing␣localize")␣if␣$CPAN::DEBUG;
␣␣␣␣unless␣($local_file␣=
␣␣␣␣␣␣␣␣␣␣␣␣CPAN::FTP->localize("authors/id/$self->{ID}",
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣$local_wanted))␣{
␣␣␣␣␣␣␣␣my␣$note␣=␣"";
␣␣␣␣␣␣␣␣if␣($CPAN::Index::DATE_OF_02)␣{
␣␣␣␣␣␣␣␣␣␣␣␣$note␣=␣"Note:␣Current␣database␣in␣memory␣was␣generated␣".
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣"on␣$CPAN::Index::DATE_OF_02\n";
␣␣␣␣␣␣␣␣}
␣␣␣␣␣␣␣␣$CPAN::Frontend->mydie("Giving␣up␣on␣'$local_wanted'\n$note");
␣␣␣␣}

␣␣␣␣$self->debug("local_wanted[$local_wanted]local_file[$local_file]")␣if␣$CPAN::DEBUG;
␣␣␣␣$self->{localfile}␣=␣$local_file;
}


#->␣CPAN::Distribution::check_integrity
sub␣check_integrity␣{
␣␣␣␣my($self)␣=␣@_;

␣␣␣␣return␣if␣$self->is_dot_dist;
␣␣␣␣if␣($CPAN::META->has_inst("Digest::SHA"))␣{
␣␣␣␣␣␣␣␣$self->debug("Digest::SHA␣is␣installed,␣verifying");
␣␣␣␣␣␣␣␣$self->verifyCHECKSUM;
␣␣␣␣}␣else␣{
␣␣␣␣␣␣␣␣$self->debug("Digest::SHA␣is␣NOT␣installed");
␣␣␣␣}
}

#->␣CPAN::Distribution::run_preps_on_packagedir
sub␣run_preps_on_packagedir␣{
␣␣␣␣my($self)␣=␣@_;
␣␣␣␣return␣if␣$self->is_dot_dist;

␣␣␣␣$CPAN::META->{cachemgr}␣||=␣CPAN::CacheMgr->new();␣#␣unsafe␣meta␣access,␣ok
␣␣␣␣my␣$builddir␣=␣$CPAN::META->{cachemgr}->dir;␣#␣unsafe␣meta␣access,␣ok
␣␣␣␣$self->safe_chdir($builddir);
␣␣␣␣$self->debug("Removing␣tmp-$$")␣if␣$CPAN::DEBUG;
␣␣␣␣File::Path::rmtree("tmp-$$");
␣␣␣␣unless␣(mkdir␣"tmp-$$",␣0755)␣{
␣␣␣␣␣␣␣␣$CPAN::Frontend->unrecoverable_error(<<EOF);
Couldn't␣mkdir␣'$builddir/tmp-$$':␣$!

Cannot␣continue:␣Please␣find␣the␣reason␣why␣I␣cannot␣make␣the
directory
$builddir/tmp-$$
and␣fix␣the␣problem,␣then␣retry.

EOF
----------
Range: (6471565,6489353) (17788)
<<'=back';

=over␣2

=item␣auto_commit

Normally␣CPAN.pm␣keeps␣config␣variables␣in␣memory␣and␣changes␣need␣to
be␣saved␣in␣a␣separate␣'o␣conf␣commit'␣command␣to␣make␣them␣permanent
between␣sessions.␣If␣you␣set␣the␣'auto_commit'␣option␣to␣true,␣changes
to␣a␣config␣variable␣are␣always␣automatically␣committed␣to␣disk.

Always␣commit␣changes␣to␣config␣variables␣to␣disk?

=item␣build_cache

CPAN.pm␣can␣limit␣the␣size␣of␣the␣disk␣area␣for␣keeping␣the␣build
directories␣with␣all␣the␣intermediate␣files.

Cache␣size␣for␣build␣directory␣(in␣MB)?

=item␣build_dir

Directory␣where␣the␣build␣process␣takes␣place?

=item␣build_dir_reuse

Until␣version␣1.88␣CPAN.pm␣never␣trusted␣the␣contents␣of␣the␣build_dir
directory␣between␣sessions.␣Since␣1.88_58␣CPAN.pm␣has␣a␣YAML-based
mechanism␣that␣makes␣it␣possible␣to␣share␣the␣contents␣of␣the
build_dir/␣directory␣between␣different␣sessions␣with␣the␣same␣version
of␣perl.␣People␣who␣prefer␣to␣test␣things␣several␣days␣before
installing␣will␣like␣this␣feature␣because␣it␣safes␣a␣lot␣of␣time.

If␣you␣say␣yes␣to␣the␣following␣question,␣CPAN␣will␣try␣to␣store
enough␣information␣about␣the␣build␣process␣so␣that␣it␣can␣pick␣up␣in
future␣sessions␣at␣the␣same␣state␣of␣affairs␣as␣it␣left␣a␣previous
session.

Store␣and␣re-use␣state␣information␣about␣distributions␣between
CPAN.pm␣sessions?

=item␣build_requires_install_policy

When␣a␣module␣declares␣another␣one␣as␣a␣'build_requires'␣prerequisite
this␣means␣that␣the␣other␣module␣is␣only␣needed␣for␣building␣or
testing␣the␣module␣but␣need␣not␣be␣installed␣permanently.␣In␣this␣case
you␣may␣wish␣to␣install␣that␣other␣module␣nonetheless␣or␣just␣keep␣it
in␣the␣'build_dir'␣directory␣to␣have␣it␣available␣only␣temporarily.
Installing␣saves␣time␣on␣future␣installations␣but␣makes␣the␣perl
installation␣bigger.

You␣can␣choose␣if␣you␣want␣to␣always␣install␣(yes),␣never␣install␣(no)
or␣be␣always␣asked.␣In␣the␣latter␣case␣you␣can␣set␣the␣default␣answer
for␣the␣question␣to␣yes␣(ask/yes)␣or␣no␣(ask/no).

Policy␣on␣installing␣'build_requires'␣modules␣(yes,␣no,␣ask/yes,
ask/no)?

=item␣cache_metadata

To␣considerably␣speed␣up␣the␣initial␣CPAN␣shell␣startup,␣it␣is
possible␣to␣use␣Storable␣to␣create␣a␣cache␣of␣metadata.␣If␣Storable␣is
not␣available,␣the␣normal␣index␣mechanism␣will␣be␣used.

Note:␣this␣mechanism␣is␣not␣used␣when␣use_sqlite␣is␣on␣and␣SQLLite␣is
running.

Cache␣metadata␣(yes/no)?

=item␣check_sigs

CPAN␣packages␣can␣be␣digitally␣signed␣by␣authors␣and␣thus␣verified
with␣the␣security␣provided␣by␣strong␣cryptography.␣The␣exact␣mechanism
is␣defined␣in␣the␣Module::Signature␣module.␣While␣this␣is␣generally
considered␣a␣good␣thing,␣it␣is␣not␣always␣convenient␣to␣the␣end␣user
to␣install␣modules␣that␣are␣signed␣incorrectly␣or␣where␣the␣key␣of␣the
author␣is␣not␣available␣or␣where␣some␣prerequisite␣for
Module::Signature␣has␣a␣bug␣and␣so␣on.

With␣the␣check_sigs␣parameter␣you␣can␣turn␣signature␣checking␣on␣and
off.␣The␣default␣is␣off␣for␣now␣because␣the␣whole␣tool␣chain␣for␣the
functionality␣is␣not␣yet␣considered␣mature␣by␣some.␣The␣author␣of
CPAN.pm␣would␣recommend␣setting␣it␣to␣true␣most␣of␣the␣time␣and
turning␣it␣off␣only␣if␣it␣turns␣out␣to␣be␣annoying.

Note␣that␣if␣you␣do␣not␣have␣Module::Signature␣installed,␣no␣signature
checks␣will␣be␣performed␣at␣all.

Always␣try␣to␣check␣and␣verify␣signatures␣if␣a␣SIGNATURE␣file␣is␣in
the␣package␣and␣Module::Signature␣is␣installed␣(yes/no)?

=item␣colorize_output

When␣you␣have␣Term::ANSIColor␣installed,␣you␣can␣turn␣on␣colorized
output␣to␣have␣some␣visual␣differences␣between␣normal␣CPAN.pm␣output,
warnings,␣debugging␣output,␣and␣the␣output␣of␣the␣modules␣being
installed.␣Set␣your␣favorite␣colors␣after␣some␣experimenting␣with␣the
Term::ANSIColor␣module.

Do␣you␣want␣to␣turn␣on␣colored␣output?

=item␣colorize_print

Color␣for␣normal␣output?

=item␣colorize_warn

Color␣for␣warnings?

=item␣colorize_debug

Color␣for␣debugging␣messages?

=item␣commandnumber_in_prompt

The␣prompt␣of␣the␣cpan␣shell␣can␣contain␣the␣current␣command␣number
for␣easier␣tracking␣of␣the␣session␣or␣be␣a␣plain␣string.

Do␣you␣want␣the␣command␣number␣in␣the␣prompt␣(yes/no)?

=item␣connect_to_internet_ok

If␣you␣have␣never␣defined␣your␣own␣C<urllist>␣in␣your␣configuration
then␣C<CPAN.pm>␣will␣be␣hesitant␣to␣use␣the␣built␣in␣default␣sites␣for
downloading.␣It␣will␣ask␣you␣once␣per␣session␣if␣a␣connection␣to␣the
internet␣is␣OK␣and␣only␣if␣you␣say␣yes,␣it␣will␣try␣to␣connect.␣But␣to
avoid␣this␣question,␣you␣can␣choose␣your␣favorite␣download␣sites␣once
and␣get␣away␣with␣it.␣Or,␣if␣you␣have␣no␣favorite␣download␣sites
answer␣yes␣to␣the␣following␣question.

If␣no␣urllist␣has␣been␣chosen␣yet,␣would␣you␣prefer␣CPAN.pm␣to␣connect
to␣the␣built-in␣default␣sites␣without␣asking?␣(yes/no)?

=item␣ftp_passive

Shall␣we␣always␣set␣the␣FTP_PASSIVE␣environment␣variable␣when␣dealing
with␣ftp␣download␣(yes/no)?

=item␣ftpstats_period

Statistics␣about␣downloads␣are␣truncated␣by␣size␣and␣period
simultaneously.

How␣many␣days␣shall␣we␣keep␣statistics␣about␣downloads?

=item␣ftpstats_size

Statistics␣about␣downloads␣are␣truncated␣by␣size␣and␣period
simultaneously.

How␣many␣items␣shall␣we␣keep␣in␣the␣statistics␣about␣downloads?

=item␣getcwd

CPAN.pm␣changes␣the␣current␣working␣directory␣often␣and␣needs␣to
determine␣its␣own␣current␣working␣directory.␣Per␣default␣it␣uses
Cwd::cwd␣but␣if␣this␣doesn't␣work␣on␣your␣system␣for␣some␣reason,
alternatives␣can␣be␣configured␣according␣to␣the␣following␣table:

␣␣␣␣cwd␣␣␣␣␣␣␣␣␣Cwd::cwd
␣␣␣␣getcwd␣␣␣␣␣␣Cwd::getcwd
␣␣␣␣fastcwd␣␣␣␣␣Cwd::fastcwd
␣␣␣␣backtickcwd␣external␣command␣cwd

Preferred␣method␣for␣determining␣the␣current␣working␣directory?

=item␣halt_on_failure

Normaly,␣CPAN.pm␣continues␣processing␣the␣full␣list␣of␣targets␣and
dependencies,␣even␣if␣one␣of␣them␣fails.␣␣However,␣you␣can␣specify␣
that␣CPAN␣should␣halt␣after␣the␣first␣failure.␣

Do␣you␣want␣to␣halt␣on␣failure␣(yes/no)?

=item␣histfile

If␣you␣have␣one␣of␣the␣readline␣packages␣(Term::ReadLine::Perl,
Term::ReadLine::Gnu,␣possibly␣others)␣installed,␣the␣interactive␣CPAN
shell␣will␣have␣history␣support.␣The␣next␣two␣questions␣deal␣with␣the
filename␣of␣the␣history␣file␣and␣with␣its␣size.␣If␣you␣do␣not␣want␣to
set␣this␣variable,␣please␣hit␣SPACE␣RETURN␣to␣the␣following␣question.

File␣to␣save␣your␣history?

=item␣histsize

Number␣of␣lines␣to␣save?

=item␣inactivity_timeout

Sometimes␣you␣may␣wish␣to␣leave␣the␣processes␣run␣by␣CPAN␣alone
without␣caring␣about␣them.␣Because␣the␣Makefile.PL␣or␣the␣Build.PL
sometimes␣contains␣question␣you're␣expected␣to␣answer,␣you␣can␣set␣a
timer␣that␣will␣kill␣a␣'perl␣Makefile.PL'␣process␣after␣the␣specified
time␣in␣seconds.

If␣you␣set␣this␣value␣to␣0,␣these␣processes␣will␣wait␣forever.␣This␣is
the␣default␣and␣recommended␣setting.

Timeout␣for␣inactivity␣during␣{Makefile,Build}.PL?

=item␣index_expire

The␣CPAN␣indexes␣are␣usually␣rebuilt␣once␣or␣twice␣per␣hour,␣but␣the
typical␣CPAN␣mirror␣mirrors␣only␣once␣or␣twice␣per␣day.␣Depending␣on
the␣quality␣of␣your␣mirror␣and␣your␣desire␣to␣be␣on␣the␣bleeding␣edge,
you␣may␣want␣to␣set␣the␣following␣value␣to␣more␣or␣less␣than␣one␣day
(which␣is␣the␣default).␣It␣determines␣after␣how␣many␣days␣CPAN.pm
downloads␣new␣indexes.

Let␣the␣index␣expire␣after␣how␣many␣days?

=item␣inhibit_startup_message

When␣the␣CPAN␣shell␣is␣started␣it␣normally␣displays␣a␣greeting␣message
that␣contains␣the␣running␣version␣and␣the␣status␣of␣readline␣support.

Do␣you␣want␣to␣turn␣this␣message␣off?

=item␣keep_source_where

Unless␣you␣are␣accessing␣the␣CPAN␣on␣your␣filesystem␣via␣a␣file:␣URL,
CPAN.pm␣needs␣to␣keep␣the␣source␣files␣it␣downloads␣somewhere.␣Please
supply␣a␣directory␣where␣the␣downloaded␣files␣are␣to␣be␣kept.

Download␣target␣directory?

=item␣load_module_verbosity

When␣CPAN.pm␣loads␣a␣module␣it␣needs␣for␣some␣optional␣feature,␣it
usually␣reports␣about␣module␣name␣and␣version.␣Choose␣'v'␣to␣get␣this
message,␣'none'␣to␣suppress␣it.

Verbosity␣level␣for␣loading␣modules␣(none␣or␣v)?

=item␣makepl_arg

Every␣Makefile.PL␣is␣run␣by␣perl␣in␣a␣separate␣process.␣Likewise␣we
run␣'make'␣and␣'make␣install'␣in␣separate␣processes.␣If␣you␣have
any␣parameters␣(e.g.␣PREFIX,␣UNINST␣or␣the␣like)␣you␣want␣to
pass␣to␣the␣calls,␣please␣specify␣them␣here.

If␣you␣don't␣understand␣this␣question,␣just␣press␣ENTER.

Typical␣frequently␣used␣settings:

␣␣␣␣PREFIX=~/perl␣␣␣␣#␣non-root␣users␣(please␣see␣manual␣for␣more␣hints)

Parameters␣for␣the␣'perl␣Makefile.PL'␣command?

=item␣make_arg

Parameters␣for␣the␣'make'␣command?␣Typical␣frequently␣used␣setting:

␣␣␣␣-j3␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣dual␣processor␣system␣(on␣GNU␣make)

Your␣choice:

=item␣make_install_arg

Parameters␣for␣the␣'make␣install'␣command?
Typical␣frequently␣used␣setting:

␣␣␣␣UNINST=1␣␣␣␣␣␣␣␣␣#␣to␣always␣uninstall␣potentially␣conflicting␣files

Your␣choice:

=item␣make_install_make_command

Do␣you␣want␣to␣use␣a␣different␣make␣command␣for␣'make␣install'?
Cautious␣people␣will␣probably␣prefer:

␣␣␣␣su␣root␣-c␣make
␣or
␣␣␣␣sudo␣make
␣or
␣␣␣␣/path1/to/sudo␣-u␣admin_account␣/path2/to/make

or␣some␣such.␣Your␣choice:

=item␣mbuildpl_arg

A␣Build.PL␣is␣run␣by␣perl␣in␣a␣separate␣process.␣Likewise␣we␣run
'./Build'␣and␣'./Build␣install'␣in␣separate␣processes.␣If␣you␣have␣any
parameters␣you␣want␣to␣pass␣to␣the␣calls,␣please␣specify␣them␣here.

Typical␣frequently␣used␣settings:

␣␣␣␣--install_base␣/home/xxx␣␣␣␣␣␣␣␣␣␣␣␣␣#␣different␣installation␣directory

Parameters␣for␣the␣'perl␣Build.PL'␣command?

=item␣mbuild_arg

Parameters␣for␣the␣'./Build'␣command?␣Setting␣might␣be:

␣␣␣␣--extra_linker_flags␣-L/usr/foo/lib␣␣#␣non-standard␣library␣location

Your␣choice:

=item␣mbuild_install_arg

Parameters␣for␣the␣'./Build␣install'␣command?␣Typical␣frequently␣used
setting:

␣␣␣␣--uninst␣1␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣#␣uninstall␣conflicting␣files

Your␣choice:

=item␣mbuild_install_build_command

Do␣you␣want␣to␣use␣a␣different␣command␣for␣'./Build␣install'?␣Sudo
users␣will␣probably␣prefer:

␣␣␣␣su␣root␣-c␣./Build
␣or
␣␣␣␣sudo␣./Build
␣or
␣␣␣␣/path1/to/sudo␣-u␣admin_account␣./Build

or␣some␣such.␣Your␣choice:

=item␣pager

What␣is␣your␣favorite␣pager␣program?

=item␣prefer_installer

When␣you␣have␣Module::Build␣installed␣and␣a␣module␣comes␣with␣both␣a
Makefile.PL␣and␣a␣Build.PL,␣which␣shall␣have␣precedence?

The␣main␣two␣standard␣installer␣modules␣are␣the␣old␣and␣well
established␣ExtUtils::MakeMaker␣(for␣short:␣EUMM)␣which␣uses␣the
Makefile.PL.␣And␣the␣next␣generation␣installer␣Module::Build␣(MB)
which␣works␣with␣the␣Build.PL␣(and␣often␣comes␣with␣a␣Makefile.PL
too).␣If␣a␣module␣comes␣only␣with␣one␣of␣the␣two␣we␣will␣use␣that␣one
but␣if␣both␣are␣supplied␣then␣a␣decision␣must␣be␣made␣between␣EUMM␣and
MB.␣See␣also␣http://rt.cpan.org/Ticket/Display.html?id=29235␣for␣a
discussion␣about␣the␣right␣default.

Or,␣as␣a␣third␣option␣you␣can␣choose␣RAND␣which␣will␣make␣a␣random
decision␣(something␣regular␣CPAN␣testers␣will␣enjoy).

In␣case␣you␣can␣choose␣between␣running␣a␣Makefile.PL␣or␣a␣Build.PL,
which␣installer␣would␣you␣prefer␣(EUMM␣or␣MB␣or␣RAND)?

=item␣prefs_dir

CPAN.pm␣can␣store␣customized␣build␣environments␣based␣on␣regular
expressions␣for␣distribution␣names.␣These␣are␣YAML␣files␣where␣the
default␣options␣for␣CPAN.pm␣and␣the␣environment␣can␣be␣overridden␣and
dialog␣sequences␣can␣be␣stored␣that␣can␣later␣be␣executed␣by␣an
Expect.pm␣object.␣The␣CPAN.pm␣distribution␣comes␣with␣some␣prefab␣YAML
files␣that␣cover␣sample␣distributions␣that␣can␣be␣used␣as␣blueprints
to␣store␣one␣own␣prefs.␣Please␣check␣out␣the␣distroprefs/␣directory␣of
the␣CPAN.pm␣distribution␣to␣get␣a␣quick␣start␣into␣the␣prefs␣system.

Directory␣where␣to␣store␣default␣options/environment/dialogs␣for
building␣modules␣that␣need␣some␣customization?

=item␣prerequisites_policy

The␣CPAN␣module␣can␣detect␣when␣a␣module␣which␣you␣are␣trying␣to␣build
depends␣on␣prerequisites.␣If␣this␣happens,␣it␣can␣build␣the
prerequisites␣for␣you␣automatically␣('follow'),␣ask␣you␣for
confirmation␣('ask'),␣or␣just␣ignore␣them␣('ignore').␣␣Choosing
'follow'␣also␣sets␣PERL_AUTOINSTALL␣and␣PERL_EXTUTILS_AUTOINSTALL␣for
"--defaultdeps"␣if␣not␣already␣set.

Please␣set␣your␣policy␣to␣one␣of␣the␣three␣values.

Policy␣on␣building␣prerequisites␣(follow,␣ask␣or␣ignore)?

=item␣randomize_urllist

CPAN.pm␣can␣introduce␣some␣randomness␣when␣using␣hosts␣for␣download
that␣are␣configured␣in␣the␣urllist␣parameter.␣Enter␣a␣numeric␣value
between␣0␣and␣1␣to␣indicate␣how␣often␣you␣want␣to␣let␣CPAN.pm␣try␣a
random␣host␣from␣the␣urllist.␣A␣value␣of␣one␣specifies␣to␣always␣use␣a
random␣host␣as␣the␣first␣try.␣A␣value␣of␣zero␣means␣no␣randomness␣at
all.␣Anything␣in␣between␣specifies␣how␣often,␣on␣average,␣a␣random
host␣should␣be␣tried␣first.

Randomize␣parameter

=item␣scan_cache

By␣default,␣each␣time␣the␣CPAN␣module␣is␣started,␣cache␣scanning␣is
performed␣to␣keep␣the␣cache␣size␣in␣sync.␣To␣prevent␣this,␣answer
'never'.

Perform␣cache␣scanning␣(atstart␣or␣never)?

=item␣shell

What␣is␣your␣favorite␣shell?

=item␣show_unparsable_versions

During␣the␣'r'␣command␣CPAN.pm␣finds␣modules␣without␣version␣number.
When␣the␣command␣finishes,␣it␣prints␣a␣report␣about␣this.␣If␣you
want␣this␣report␣to␣be␣very␣verbose,␣say␣yes␣to␣the␣following
variable.

Show␣all␣individual␣modules␣that␣have␣no␣$VERSION?

=item␣show_upload_date

The␣'d'␣and␣the␣'m'␣command␣normally␣only␣show␣you␣information␣they
have␣in␣their␣in-memory␣database␣and␣thus␣will␣never␣connect␣to␣the
internet.␣If␣you␣set␣the␣'show_upload_date'␣variable␣to␣true,␣'m'␣and
'd'␣will␣additionally␣show␣you␣the␣upload␣date␣of␣the␣module␣or
distribution.␣Per␣default␣this␣feature␣is␣off␣because␣it␣may␣require␣a
net␣connection␣to␣get␣at␣the␣upload␣date.

Always␣try␣to␣show␣upload␣date␣with␣'d'␣and␣'m'␣command␣(yes/no)?

=item␣show_zero_versions

During␣the␣'r'␣command␣CPAN.pm␣finds␣modules␣with␣a␣version␣number␣of
zero.␣When␣the␣command␣finishes,␣it␣prints␣a␣report␣about␣this.␣If␣you
want␣this␣report␣to␣be␣very␣verbose,␣say␣yes␣to␣the␣following
variable.

Show␣all␣individual␣modules␣that␣have␣a␣$VERSION␣of␣zero?

=item␣tar_verbosity

When␣CPAN.pm␣uses␣the␣tar␣command,␣which␣switch␣for␣the␣verbosity
shall␣be␣used?␣Choose␣'none'␣for␣quiet␣operation,␣'v'␣for␣file
name␣listing,␣'vv'␣for␣full␣listing.

Tar␣command␣verbosity␣level␣(none␣or␣v␣or␣vv)?

=item␣term_is_latin

The␣next␣option␣deals␣with␣the␣charset␣(aka␣character␣set)␣your
terminal␣supports.␣In␣general,␣CPAN␣is␣English␣speaking␣territory,␣so
the␣charset␣does␣not␣matter␣much␣but␣some␣CPAN␣have␣names␣that␣are
outside␣the␣ASCII␣range.␣If␣your␣terminal␣supports␣UTF-8,␣you␣should
say␣no␣to␣the␣next␣question.␣If␣it␣expects␣ISO-8859-1␣(also␣known␣as
LATIN1)␣then␣you␣should␣say␣yes.␣If␣it␣supports␣neither,␣your␣answer
does␣not␣matter␣because␣you␣will␣not␣be␣able␣to␣read␣the␣names␣of␣some
authors␣anyway.␣If␣you␣answer␣no,␣names␣will␣be␣output␣in␣UTF-8.

Your␣terminal␣expects␣ISO-8859-1␣(yes/no)?

=item␣term_ornaments

When␣using␣Term::ReadLine,␣you␣can␣turn␣ornaments␣on␣so␣that␣your
input␣stands␣out␣against␣the␣output␣from␣CPAN.pm.

Do␣you␣want␣to␣turn␣ornaments␣on?

=item␣test_report

The␣goal␣of␣the␣CPAN␣Testers␣project␣(http://testers.cpan.org/)␣is␣to
test␣as␣many␣CPAN␣packages␣as␣possible␣on␣as␣many␣platforms␣as
possible.␣␣This␣provides␣valuable␣feedback␣to␣module␣authors␣and
potential␣users␣to␣identify␣bugs␣or␣platform␣compatibility␣issues␣and
improves␣the␣overall␣quality␣and␣value␣of␣CPAN.

One␣way␣you␣can␣contribute␣is␣to␣send␣test␣results␣for␣each␣module
that␣you␣install.␣␣If␣you␣install␣the␣CPAN::Reporter␣module,␣you␣have
the␣option␣to␣automatically␣generate␣and␣email␣test␣reports␣to␣CPAN
Testers␣whenever␣you␣run␣tests␣on␣a␣CPAN␣package.

See␣the␣CPAN::Reporter␣documentation␣for␣additional␣details␣and
configuration␣settings.␣␣If␣your␣firewall␣blocks␣outgoing␣email,
you␣will␣need␣to␣configure␣CPAN::Reporter␣before␣sending␣reports.

Email␣test␣reports␣if␣CPAN::Reporter␣is␣installed␣(yes/no)?

=item␣perl5lib_verbosity

When␣CPAN.pm␣extends␣@INC␣via␣PERL5LIB,␣it␣prints␣a␣list␣of
directories␣added␣(or␣a␣summary␣of␣how␣many␣directories␣are
added).␣␣Choose␣'v'␣to␣get␣this␣message,␣'none'␣to␣suppress␣it.

Verbosity␣level␣for␣PERL5LIB␣changes␣(none␣or␣v)?

=item␣trust_test_report_history

When␣a␣distribution␣has␣already␣been␣tested␣by␣CPAN::Reporter␣on
this␣machine,␣CPAN␣can␣skip␣the␣test␣phase␣and␣just␣rely␣on␣the
test␣report␣history␣instead.

Note␣that␣this␣will␣not␣apply␣to␣distributions␣that␣failed␣tests
because␣of␣missing␣dependencies.␣␣Also,␣tests␣can␣be␣run
regardless␣of␣the␣history␣using␣"force".

Do␣you␣want␣to␣rely␣on␣the␣test␣report␣history␣(yes/no)?

=item␣use_sqlite

CPAN::SQLite␣is␣a␣layer␣between␣the␣index␣files␣that␣are␣downloaded
from␣the␣CPAN␣and␣CPAN.pm␣that␣speeds␣up␣metadata␣queries␣and␣reduces
memory␣consumption␣of␣CPAN.pm␣considerably.

Use␣CPAN::SQLite␣if␣available?␣(yes/no)?

=item␣version_timeout

This␣timeout␣prevents␣CPAN␣from␣hanging␣when␣trying␣to␣parse␣a
pathologically␣coded␣$VERSION␣from␣a␣module.

The␣default␣is␣15␣seconds.␣␣If␣you␣set␣this␣value␣to␣0,␣no␣timeout
will␣occur,␣but␣this␣is␣not␣recommended.

Timeout␣for␣parsing␣module␣versions?

=item␣yaml_load_code

Both␣YAML.pm␣and␣YAML::Syck␣are␣capable␣of␣deserialising␣code.␣As␣this
requires␣a␣string␣eval,␣which␣might␣be␣a␣security␣risk,␣you␣can␣use
this␣option␣to␣enable␣or␣disable␣the␣deserialisation␣of␣code␣via
CPAN::DeferredCode.␣(Note:␣This␣does␣not␣work␣under␣perl␣5.6)

Do␣you␣want␣to␣enable␣code␣deserialisation␣(yes/no)?

=item␣yaml_module

At␣the␣time␣of␣this␣writing␣(2009-03)␣there␣are␣three␣YAML
implementations␣working:␣YAML,␣YAML::Syck,␣and␣YAML::XS.␣The␣latter
two␣are␣faster␣but␣need␣a␣C␣compiler␣installed␣on␣your␣system.␣There
may␣be␣more␣alternative␣YAML␣conforming␣modules.␣When␣I␣tried␣two
other␣players,␣YAML::Tiny␣and␣YAML::Perl,␣they␣seemed␣not␣powerful
enough␣to␣work␣with␣CPAN.pm.␣This␣may␣have␣changed␣in␣the␣meantime.

Which␣YAML␣implementation␣would␣you␣prefer?

=back
----------
Range: (6552759,6559390) (6631)
}


=pod

=head1␣NAME

Log::Message␣-␣A␣generic␣message␣storing␣mechanism;

=head1␣SYNOPSIS

␣␣␣␣use␣Log::Message␣private␣=>␣0,␣config␣=>␣'/our/cf_file';

␣␣␣␣my␣$log␣=␣Log::Message->new(␣␣␣␣private␣=>␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣level␣␣␣=>␣'log',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣config␣␣=>␣'/my/cf_file',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣$log->store('this␣is␣my␣first␣message');

␣␣␣␣$log->store(␣␣␣␣message␣=>␣'message␣#2',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣tag␣␣␣␣␣=>␣'MY_TAG',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣level␣␣␣=>␣'carp',
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣extra␣␣␣=>␣['this␣is␣an␣argument␣to␣the␣handler'],
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣my␣@last_five_items␣=␣$log->retrieve(5);

␣␣␣␣my␣@items␣=␣$log->retrieve(␣tag␣␣␣␣␣=>␣qr/my_tag/i,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣message␣=>␣qr/\d/,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣remove␣␣=>␣1,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣);

␣␣␣␣my␣@items␣=␣$log->final(␣level␣=>␣qr/carp/,␣amount␣=>␣2␣);

␣␣␣␣my␣$first_error␣=␣$log->first()

␣␣␣␣#␣croak␣with␣the␣last␣error␣on␣the␣stack
␣␣␣␣$log->final->croak;

␣␣␣␣#␣empty␣the␣stack
␣␣␣␣$log->flush();


=head1␣DESCRIPTION

Log::Message␣is␣a␣generic␣message␣storage␣mechanism.
It␣allows␣you␣to␣store␣messages␣on␣a␣stack␣--␣either␣shared␣or␣private
--␣and␣assign␣meta-data␣to␣it.
Some␣meta-data␣will␣automatically␣be␣added␣for␣you,␣like␣a␣timestamp
and␣a␣stack␣trace,␣but␣some␣can␣be␣filled␣in␣by␣the␣user,␣like␣a␣tag
by␣which␣to␣identify␣it␣or␣group␣it,␣and␣a␣level␣at␣which␣to␣handle
the␣message␣(for␣example,␣log␣it,␣or␣die␣with␣it)

Log::Message␣also␣provides␣a␣powerful␣way␣of␣searching␣through␣items
by␣regexes␣on␣messages,␣tags␣and␣level.

=head1␣Hierarchy

There␣are␣4␣modules␣of␣interest␣when␣dealing␣with␣the␣Log::Message::*
modules:

=over␣4

=item␣Log::Message

Log::Message␣provides␣a␣few␣methods␣to␣manipulate␣the␣stack␣it␣keeps.
It␣has␣the␣option␣of␣keeping␣either␣a␣private␣or␣a␣public␣stack.
More␣on␣this␣below.

=item␣Log::Message::Item

These␣are␣individual␣message␣items,␣which␣are␣objects␣that␣contain
the␣user␣message␣as␣well␣as␣the␣meta-data␣described␣above.
See␣the␣L<Log::Message::Item>␣manpage␣to␣see␣how␣to␣extract␣this␣
meta-data␣and␣how␣to␣work␣with␣the␣Item␣objects.
You␣should␣never␣need␣to␣create␣your␣own␣Item␣objects,␣but␣knowing
about␣their␣methods␣and␣accessors␣is␣important␣if␣you␣want␣to␣write
your␣own␣handlers.␣(See␣below)

=item␣Log::Message::Handlers

These␣are␣a␣collection␣of␣handlers␣that␣will␣be␣called␣for␣a␣level
that␣is␣used␣on␣a␣L<Log::Message::Item>␣object.
For␣example,␣if␣a␣message␣is␣logged␣with␣the␣'carp'␣level,␣the␣'carp'
handler␣from␣L<Log::Message::Handlers>␣will␣be␣called.
See␣the␣L<Log::Message::Handlers>␣manpage␣for␣more␣explanation␣about␣how
handlers␣work,␣which␣one␣are␣available␣and␣how␣to␣create␣your␣own.

=item␣Log::Message::Config

Per␣Log::Message␣object,␣there␣is␣a␣configuration␣required␣that␣will
fill␣in␣defaults␣if␣the␣user␣did␣not␣specify␣arguments␣to␣override
them␣(like␣for␣example␣what␣tag␣will␣be␣set␣if␣none␣was␣provided),
L<Log::Message::Config>␣handles␣the␣creation␣of␣these␣configurations.

Configuration␣can␣be␣specified␣in␣4␣ways:

=over␣4

=item␣*

As␣a␣configuration␣file␣when␣you␣C<use␣Log::Message>

=item␣*

As␣arguments␣when␣you␣C<use␣Log::Message>

=item␣*

As␣a␣configuration␣file␣when␣you␣create␣a␣new␣L<Log::Message>␣object.
(The␣config␣will␣then␣only␣apply␣to␣that␣object␣if␣you␣marked␣it␣as
private)

=item␣*

As␣arguments␣when␣you␣create␣a␣new␣Log::Message␣object.

You␣should␣never␣need␣to␣use␣the␣L<Log::Message::Config>␣module␣yourself,
as␣this␣is␣transparently␣done␣by␣L<Log::Message>,␣but␣its␣manpage␣does
provide␣an␣explanation␣of␣how␣you␣can␣create␣a␣config␣file.

=back

=back

=head1␣Options

When␣using␣Log::Message,␣or␣creating␣a␣new␣Log::Message␣object,␣you␣can
supply␣various␣options␣to␣alter␣its␣behaviour.
Of␣course,␣there␣are␣sensible␣defaults␣should␣you␣choose␣to␣omit␣these
options.

Below␣an␣explanation␣of␣all␣the␣options␣and␣how␣they␣work.

=over␣4

=item␣config

The␣path␣to␣a␣configuration␣file␣to␣be␣read.
See␣the␣manpage␣of␣L<Log::Message::Config>␣for␣the␣required␣format

These␣options␣will␣be␣overridden␣by␣any␣explicit␣arguments␣passed.

=item␣private

Whether␣to␣create,␣by␣default,␣private␣or␣shared␣objects.
If␣you␣choose␣to␣create␣shared␣objects,␣all␣Log::Message␣objects␣will
use␣the␣same␣stack.

This␣means␣that␣even␣though␣every␣module␣may␣make␣its␣own␣$log␣object
they␣will␣still␣be␣sharing␣the␣same␣error␣stack␣on␣which␣they␣are
putting␣errors␣and␣from␣which␣they␣are␣retrieving.

This␣can␣be␣useful␣in␣big␣projects.

If␣you␣choose␣to␣create␣a␣private␣object,␣then␣the␣stack␣will␣of
course␣be␣private␣to␣this␣object,␣but␣it␣will␣still␣fall␣back␣to␣the
shared␣config␣should␣no␣private␣config␣or␣overriding␣arguments␣be
provided.

=item␣verbose

Log::Message␣makes␣use␣of␣another␣module␣to␣validate␣its␣arguments,
which␣is␣called␣L<Params::Check>,␣which␣is␣a␣lightweight,␣yet␣
powerful␣input␣checker␣and␣parser.␣(See␣the␣L<Params::Check>␣
manpage␣for␣details).

The␣verbose␣setting␣will␣control␣whether␣this␣module␣will
generate␣warnings␣if␣something␣improper␣is␣passed␣as␣input,␣or␣merely
silently␣returns␣undef,␣at␣which␣point␣Log::Message␣will␣generate␣a
warning.

It's␣best␣to␣just␣leave␣this␣at␣its␣default␣value,␣which␣is␣'1'

=item␣tag

The␣tag␣to␣add␣to␣messages␣if␣none␣was␣provided.␣If␣neither␣your
config,␣nor␣any␣specific␣arguments␣supply␣a␣tag,␣then␣Log::Message␣will
set␣it␣to␣'NONE'

Tags␣are␣useful␣for␣searching␣on␣or␣grouping␣by.␣For␣example,␣you
could␣tag␣all␣the␣messages␣you␣want␣to␣go␣to␣the␣user␣as␣'USER␣ERROR'
and␣all␣those␣that␣are␣only␣debug␣information␣with␣'DEBUG'.

At␣the␣end␣of␣your␣program,␣you␣could␣then␣print␣all␣the␣ones␣tagged
'USER␣ERROR'␣to␣STDOUT,␣and␣those␣marked␣'DEBUG'␣to␣a␣log␣file.

=item␣level

C<level>␣describes␣what␣action␣to␣take␣when␣a␣message␣is␣logged.␣Just
like␣C<tag>,␣Log::Message␣will␣provide␣a␣default␣(which␣is␣'log')␣if
neither␣your␣config␣file,␣nor␣any␣explicit␣arguments␣are␣given␣to
override␣it.

See␣the␣Log::Message::Handlers␣manpage␣to␣see␣what␣handlers␣are
available␣by␣default␣and␣what␣they␣do,␣as␣well␣as␣to␣how␣to␣add␣your
own␣handlers.

=item␣remove

This␣indicates␣whether␣or␣not␣to␣automatically␣remove␣the␣messages
from␣the␣stack␣when␣you've␣retrieved␣them.
The␣default␣setting␣provided␣by␣Log::Message␣is␣'0':␣do␣not␣remove.

=item␣chrono

This␣indicates␣whether␣messages␣should␣always␣be␣fetched␣in
chronological␣order␣or␣not.
This␣simply␣means␣that␣you␣can␣choose␣whether,␣when␣retrieving␣items,
the␣item␣most␣recently␣added␣should␣be␣returned␣first,␣or␣the␣one␣that
had␣been␣added␣most␣long␣ago.

The␣default␣is␣to␣return␣the␣newest␣ones␣first

=back

=cut
----------

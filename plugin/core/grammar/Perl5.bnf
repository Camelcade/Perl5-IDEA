/*
 * Copyright 2015-2019 Alexandr Evstigneev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
{
  elementTypeHolderClass="com.perl5.lang.perl.lexer.PerlElementTypesGenerated"
  parserClass="com.perl5.lang.perl.parser.PerlParserGenerated"
  extends="com.perl5.lang.perl.psi.impl.PerlCompositeElementImpl"

  psiClassPrefix="PsiPerl"
  psiImplClassSuffix="Impl"
  psiPackage="com.perl5.lang.perl.psi"
  psiImplPackage="com.perl5.lang.perl.psi.impl"

  elementTypeHolderClass="com.perl5.lang.perl.lexer.PerlElementTypes"

  tokenTypeClass="com.perl5.lang.perl.parser.elementTypes.PerlTokenType"
  elementTypeClass="com.perl5.lang.perl.parser.elementTypes.PerlElementType"

  elementTypeFactory="com.perl5.lang.perl.parser.elementTypes.PerlElementTypeFactory.getElementType"
  tokenTypeFactory="com.perl5.lang.perl.parser.elementTypes.PerlElementTypeFactory.getTokenType"

  parserUtilClass="com.perl5.lang.perl.parser.PerlParserUtil"

  tokens=[
    COMMENT_LINE='COMMENT_LINE'
    COMMENT_BLOCK='COMMENT_BLOCK'
    POD='POD'

    SIGIL_ARRAY='$@'
    SIGIL_SCALAR='$$'
    SIGIL_SCALAR_INDEX='$#'
    SIGIL_GLOB='$*'
    SIGIL_HASH='$%'
    SIGIL_CODE='$&'

	LEFT_BRACE_SCALAR='${'
	LEFT_BRACE_ARRAY='@{'
	LEFT_BRACE_HASH='%{'
	LEFT_BRACE_GLOB='*{'
	LEFT_BRACE_CODE='&{'

	RIGHT_BRACE_SCALAR='$}'
	RIGHT_BRACE_ARRAY='@}'
	RIGHT_BRACE_HASH='%}'
	RIGHT_BRACE_GLOB='*}'
	RIGHT_BRACE_CODE='&}'

	// postfix deref
	DEREF_SCALAR='->$*'
	DEREF_SCALAR_INDEX='->$#*'
	DEREF_ARRAY='->@*'
	DEREF_HASH='->%*'
	DEREF_GLOB='->**'
	DEREF_CODE='->&*'

    // generated tokens
    SCALAR_NAME='SCALAR_NAME'
    ARRAY_NAME='ARRAY_NAME'
    HASH_NAME='HASH_NAME'
    GLOB_NAME='GLOB_NAME'

    HEREDOC_END='HEREDOC_END'
    HEREDOC_END_INDENTABLE='HEREDOC_END_INDENTABLE'

    FORMAT='FORMAT'
    FORMAT_TERMINATOR='.'

    VERSION_ELEMENT='VERSION_ELEMENT'

    NUMBER_VERSION='NUMBER_VERSION'
    NUMBER='NUMBER'
    NUMBER_SIMPLE='NUMBER_SIMPLE' // fixme get rid of

    RESERVED_IF='if'
    RESERVED_UNLESS='unless'
    RESERVED_ELSIF='elsif'
    RESERVED_ELSE='else'
    RESERVED_GIVEN='given'
    RESERVED_WHILE='while'
    RESERVED_UNTIL='until'
    RESERVED_FOR='for'
    RESERVED_FOREACH='foreach'

    RESERVED_CONTINUE='continue'
    RESERVED_WHEN='when'
    RESERVED_DEFAULT='default'

    RESERVED_FORMAT='format'
    RESERVED_SUB='sub'
    RESERVED_PACKAGE='package'
    RESERVED_USE='use'
    RESERVED_NO='no'
    RESERVED_REQUIRE='require'

    RESERVED_PRINT='print'
    RESERVED_PRINTF='printf'
    RESERVED_SAY='say'

    RESERVED_MAP='map'
    RESERVED_GREP='grep'
    RESERVED_SORT='sort'

    RESERVED_SCALAR='scalar';
    RESERVED_EACH='each'
    RESERVED_KEYS='keys'
    RESERVED_VALUES='values'
    RESERVED_DELETE='delete'
    RESERVED_SPLICE='splice'

    RESERVED_DEFINED='defined'
    RESERVED_WANTARRAY='wantarray'
    RESERvED_BLESS='bless'

    RESERVED_POP='pop'
    RESERVED_SHIFT='shift'

    RESERVED_PUSH='push'
    RESERVED_UNSHIFT='unshift'

    RESERVED_REF='ref'
    RESERVED_SPLIT='split'
    RESERVED_JOIN='join'
    RESERVED_LENGTH='length'
    RESERVED_EXISTS='exists'

    RESERVED_UNDEF='undef'

    RESERVED_QW='qw'

    RESERVED_QQ='qq'
    RESERVED_Q='q'
    RESERVED_QX='qx'

    RESERVED_TR='tr'
    RESERVED_Y='y'

    RESERVED_S='s'
    RESERVED_QR='qr'
    RESERVED_M='m'

    RESERVED_FINALLY = 'finally';
    RESERVED_TRY = 'try';
    RESERVED_TRYCATCH = 'TryCatch::';
    RESERVED_CATCH = 'catch';
    RESERVED_CATCH_WITH = 'catch_with';
    RESERVED_EXCEPT = 'except';
    RESERVED_OTHERWISE = 'otherwise';
    RESERVED_CONTINUATION = 'continuation';

    RESERVED_SWITCH='switch'
    RESERVED_CASE='case'

    RESERVED_MY='my'
    RESERVED_OUR='our'
    RESERVED_STATE='state'
    RESERVED_LOCAL='local'

    RESERVED_DO='do'
    RESERVED_EVAL='eval'

    RESERVED_GOTO='goto'
    RESERVED_REDO='redo'
    RESERVED_NEXT='next'
    RESERVED_LAST='last'

    RESERVED_RETURN='return'
    RESERVED_EXIT='exit'


    RESERVED_METHOD='method'
    RESERVED_FUNC='func'

    // Operators



    OPERATOR_X='x'

    OPERATOR_CMP_NUMERIC='<=>'
    OPERATOR_LT_NUMERIC='<'
    OPERATOR_GT_NUMERIC='>'

    OPERATOR_DEREFERENCE='->'
    FAT_COMMA='=>'
    COMMA=','

    OPERATOR_HELLIP='...'
    OPERATOR_NYI='nyi'
    OPERATOR_FLIP_FLOP='..'
    OPERATOR_CONCAT='.'

    OPERATOR_PLUS_PLUS='++'
    OPERATOR_MINUS_MINUS='--'
    OPERATOR_POW='**'

    OPERATOR_RE='=~'
    OPERATOR_NOT_RE='!~'

    OPERATOR_HEREDOC='heredoc<<'
    OPERATOR_SHIFT_LEFT='<<'
    OPERATOR_SHIFT_RIGHT='>>'

    OPERATOR_AND='&&'
    OPERATOR_OR='||'
    OPERATOR_OR_DEFINED='//'
    OPERATOR_NOT='!'

    OPERATOR_ASSIGN='='

    QUESTION='?'
    COLON=':'

    OPERATOR_REFERENCE='\\'

    OPERATOR_DIV='/'
    OPERATOR_MUL='*'
    OPERATOR_MOD='%'

    OPERATOR_PLUS='+'
    OPERATOR_MINUS='-'

    OPERATOR_BITWISE_NOT='~'
    OPERATOR_BITWISE_AND='&'
    OPERATOR_BITWISE_OR='|'
    OPERATOR_BITWISE_XOR='^'

    OPERATOR_AND_LP='and'
    OPERATOR_OR_LP='or'
    OPERATOR_XOR_LP='xor'
    OPERATOR_NOT_LP='not'

    OPERATOR_LT_STR='lt'
    OPERATOR_GT_STR='gt'
    OPERATOR_LE_STR='le'
    OPERATOR_GE_STR='ge'
    OPERATOR_CMP_STR='cmp'
    OPERATOR_EQ_STR='eq'
    OPERATOR_NE_STR='ne'

    // synthetic tokens
    OPERATOR_POW_ASSIGN='**='
    OPERATOR_PLUS_ASSIGN='+='
    OPERATOR_MINUS_ASSIGN='-='
    OPERATOR_MUL_ASSIGN='*='
    OPERATOR_DIV_ASSIGN='/='
    OPERATOR_MOD_ASSIGN='%='
    OPERATOR_CONCAT_ASSIGN='.='
    OPERATOR_X_ASSIGN='x='
    OPERATOR_BITWISE_AND_ASSIGN='&='
    OPERATOR_BITWISE_OR_ASSIGN='|='
    OPERATOR_BITWISE_XOR_ASSIGN='^='
    OPERATOR_SHIFT_LEFT_ASSIGN='<<='
    OPERATOR_SHIFT_RIGHT_ASSIGN='>>='
    OPERATOR_AND_ASSIGN='&&='
    OPERATOR_OR_ASSIGN='||='
    OPERATOR_OR_DEFINED_ASSIGN='//='

    OPERATOR_GE_NUMERIC='>='
    OPERATOR_LE_NUMERIC='<='
    OPERATOR_EQ_NUMERIC='=='
    OPERATOR_NE_NUMERIC='!='
    OPERATOR_SMARTMATCH='~~'
// end of synthetic operators

    OPERATOR_FILETEST='-t'

    // single mid-quote. e evaluatable s///e;
    REGEX_QUOTE='r/'
    REGEX_QUOTE_E='re/'
    REGEX_TOKEN='regex'

    // paired mid-quote. e for evaluatable s{}{}e;
    REGEX_QUOTE_OPEN='r{'
    REGEX_QUOTE_OPEN_E='re{' // block should be interpolated as a perl script

    REGEX_QUOTE_CLOSE='r}'
    REGEX_MODIFIER='/m'

/*
	REGEX_LEFT_BRACKET = '[['
	REGEX_RIGHT_BRACKET = ']]'
	REGEX_LEFT_PAREN = '(('
	REGEX_RIGHT_PAREN = '))'
	REGEX_LEFT_BRACE = '{{'
	REGEX_RIGHT_BRACE = '}}'
	REGEX_POSIX_LEFT_BRACKET = '[:'
	REGEX_POSIX_RIGHT_BRACKET = ':]'
	REGEX_POSIX_CLASS_NAME = ':name:'
	REGEX_CHAR_CLASS="\w"
*/

    STRING_CONTENT='STRING_CONTENT'
    STRING_CONTENT_QQ='STRING_CONTENT_QQ'
    STRING_CONTENT_XQ='STRING_CONTENT_XQ'


    TAG='TAG'
    TAG_END='__END__'
    TAG_DATA='__DATA__'
    TAG_PACKAGE='__PACKAGE__'

    LEFT_ANGLE='LEFT_ANGLE'
    RIGHT_ANGLE='RIGHT_ANGLE'

    TYPE_ARRAYREF="ArrayRef"
    TYPE_HASHREF="HashRef"

    LEFT_BRACKET='['
    RIGHT_BRACKET=']'

    LEFT_PAREN='('
    RIGHT_PAREN=')'

	// abstract token to make code blocks
    LEFT_BRACE_CODE_START='code{'

    LEFT_BRACE='{'
    RIGHT_BRACE='}'

    SEMICOLON=';';

    QUOTE_DOUBLE='QUOTE_DOUBLE'
    QUOTE_DOUBLE_OPEN='QUOTE_DOUBLE_OPEN'
    QUOTE_DOUBLE_CLOSE='QUOTE_DOUBLE_CLOSE'

    QUOTE_SINGLE='QUOTE_SINGLE'
    QUOTE_SINGLE_OPEN='QUOTE_SINGLE_OPEN'
    QUOTE_SINGLE_CLOSE='QUOTE_SINGLE_CLOSE'

    QUOTE_TICK='QUOTE_TICK'
    QUOTE_TICK_OPEN='QUOTE_TICK_OPEN'
    QUOTE_TICK_CLOSE='QUOTE_TICK_CLOSE'

    // custom tokens
    IDENTIFIER='IDENTIFIER'
	SUB_NAME='subname'

    BUILTIN_LIST='list'
    BUILTIN_UNARY='unary'
    CUSTOM_UNARY='unary_custom'
    BUILTIN_ARGUMENTLESS='argumentless'

	ATTRIBUTE_IDENTIFIER='ATTRIBUTE_IDENTIFIER'

    SUB_PROTOTYPE_TOKEN='SUB_PROTOTYPE_TOKEN'

    PACKAGE='package::name'
    QUALIFYING_PACKAGE='package::name::'

    HANDLE='HANDLE'
    BLOCK_NAME='BLOCK_NAME'

    ANNOTATION_DEPRECATED_KEY='#@deprecated'
    ANNOTATION_RETURNS_KEY='#@returns'
    ANNOTATION_OVERRIDE_KEY='#@override'
    ANNOTATION_METHOD_KEY='#@method'
    ANNOTATION_ABSTRACT_KEY='#@abstract'
    ANNOTATION_INJECT_KEY='#@inject'
    ANNOTATION_TYPE_KEY='#@type'
    ANNOTATION_NOINSPECTION_KEY='#@noinspection'
    ANNOTATION_UNKNOWN_KEY='#@unknown'
  ]

    extends(".+expr")=expr
    name(".+expr")="expression"
    extends("number_constant")=expr

    implements("next_expr|last_expr|redo_expr")="com.perl5.lang.perl.psi.PerlFlowControlExpr"

    implements("bless_expr")="com.perl5.lang.perl.psi.PerlBlessExpr"
    implements("trycatch_expr")="com.perl5.lang.perl.psi.PerlTryCatchExpr"
    implements("try_expr")="com.perl5.lang.perl.psi.PerlTryExpr"
    implements("catch_expr|continuation_expr")="com.perl5.lang.perl.psi.PerlCatchExpr"

    implements("return_expr")="com.perl5.lang.perl.psi.PerlReturnExpr"
    implements("defined_expr")="com.perl5.lang.perl.psi.PerlImplicitScalarExpr"

    implements("condition_expr|foreach_iterator|sub_signature|func_signature_content|method_signature_content|for_init|for_condition|for_mutator")="com.perl5.lang.perl.psi.PerlStatement"

	implements(".+_cast_expr")="com.perl5.lang.perl.psi.PerlCastExpression"
	mixin(".+_cast_expr")="com.perl5.lang.perl.psi.mixins.PerlCastExpressionMixin"

	implements("assign_expr")="com.perl5.lang.perl.psi.PerlAssignExpression"

	extends(".*statement_modifier")=statement_modifier
	implements("statement_modifier")="com.perl5.lang.perl.psi.PerlStatementModifier"

	extends(".*_signature_content")=sub_signature
	implements("sub_signature|variable_declaration_lexical")="com.perl5.lang.perl.psi.PerlLexicalVariableDeclarationMarker"

    extends("heredoc_opener|anon_array|anon_hash")=expr
//    extends("glob_slot")=expr

    mixin("package_expr")="com.perl5.lang.perl.psi.mixins.PerlPackageExpression"

    extends("string_list")=expr
    mixin("string_list")="com.perl5.lang.perl.psi.mixins.PerlStringListMixin"

    implements("replacement_regex")="com.perl5.lang.perl.psi.PerlReplacementRegex"
    implements("match_regex|compile_regex")="com.perl5.lang.perl.psi.PerlSimpleRegex"
    extends("replacement_regex|compile_regex|match_regex|tr_regex")=expr

    mixin("perl_regex")="com.perl5.lang.perl.psi.mixins.Perl5RegexpMixin"

    extends("heredoc_opener|tag_scalar")=expr

    extends("string_sq|string_dq|string_xq|string_bare")=expr
    implements("string_sq|string_dq|string_xq|string_bare")="com.perl5.lang.perl.psi.PerlString"
    mixin("string_sq|string_dq|string_xq")="com.perl5.lang.perl.psi.mixins.PerlStringMixin"
    mixin("string_bare")="com.perl5.lang.perl.psi.mixins.PerlStringBareMixin"

    extends("nested_call")=sub_call_expr
    implements("nested_call")="com.perl5.lang.perl.psi.PerlNestedCall"

    implements("sub_call_expr|named_list_expr|unary_list_expr")="com.perl5.lang.perl.psi.PerlMethodContainer"

    mixin("statement")="com.perl5.lang.perl.psi.mixins.PerlStatementMixin"

	mixin("call_arguments")="com.perl5.lang.perl.psi.mixins.PerlCallArguments"
	extends("parenthesised_call_arguments")=call_arguments

	implements("named_block|conditional_block|unconditional_block")="com.perl5.lang.perl.psi.properties.PerlStatementsContainer"

	implements("label_declaration")="com.perl5.lang.perl.psi.PerlLabelDeclaration"
	extends("label_declaration")="com.perl5.lang.perl.psi.mixins.PerlLabelDeclarationMixin"

	implements("block")="com.perl5.lang.perl.psi.PerlBlock"

    implements("block_compound")="com.perl5.lang.perl.psi.PerlBlockCompound"
    implements("for_compound")="com.perl5.lang.perl.psi.PerlForCompound"
    implements("foreach_compound")="com.perl5.lang.perl.psi.PerlForeachCompound"
    implements("while_compound|until_compound")="com.perl5.lang.perl.psi.PerlWhileUntilCompound"
    implements("if_compound|unless_compound")="com.perl5.lang.perl.psi.PerlIfUnlessCompound"
    implements("when_compound")="com.perl5.lang.perl.psi.properties.PerlConvertableCompoundSimple"
    implements("given_compound|default_compound")="com.perl5.lang.perl.psi.properties.PerlCompound";
    implements("trycatch_compound")="com.perl5.lang.perl.psi.PerlTryCatchCompound"

    implements("heredoc_opener")="com.perl5.lang.perl.psi.PerlHeredocOpener"
    mixin("heredoc_opener")="com.perl5.lang.perl.psi.mixins.PerlHeredocOpenerMixin"

    implements("deref_expr")="com.perl5.lang.perl.psi.PerlDerefExpression"
    mixin("deref_expr")="com.perl5.lang.perl.psi.mixins.PerlDerefExpressionMixin"

    mixin("parenthesised_expr")="com.perl5.lang.perl.psi.mixins.PerlParenthesizedExpressionMixin"

    extends("variable_declaration_global|variable_declaration_lexical|variable_declaration_local")=expr
    implements("variable_declaration_lexical|variable_declaration_local|variable_declaration_global")="com.perl5.lang.perl.psi.PerlVariableDeclarationExpr"
    mixin("variable_declaration_lexical|variable_declaration_local|variable_declaration_global")="com.perl5.lang.perl.psi.mixins.PerlVariableDeclarationExprMixin"

    extends("code_variable")=expr

    extends("array_slice|hash_slice|array_element|hash_element|glob_slot")=expr

    stubClass("variable_declaration_element")="com.perl5.lang.perl.psi.stubs.variables.PerlVariableDeclarationStub"
    mixin("variable_declaration_element")="com.perl5.lang.perl.psi.mixins.PerlVariableDeclarationElementMixin"
    implements("variable_declaration_element")="com.perl5.lang.perl.psi.PerlVariableDeclarationElement"

    extends("array_index_variable|scalar_variable|array_variable|hash_variable|glob_variable")=expr
    mixin("code_variable|scalar_variable|array_variable|hash_variable|array_index_variable")="com.perl5.lang.perl.psi.mixins.PerlVariableMixin"
    implements("code_variable|scalar_variable|array_variable|hash_variable|array_index_variable")="com.perl5.lang.perl.psi.PerlVariable"

	mixin("label_expr")="com.perl5.lang.perl.psi.impl.PerlCompositeElementWithReference"

    stubClass("namespace_definition")="com.perl5.lang.perl.psi.stubs.namespaces.PerlNamespaceDefinitionStub"
    mixin("namespace_definition")="com.perl5.lang.perl.psi.mixins.PerlNamespaceDefinitionMixin"
    implements("namespace_definition")="com.perl5.lang.perl.psi.PerlNamespaceDefinitionWithIdentifier"

    stubClass("method_definition")="com.perl5.lang.perl.psi.stubs.subsdefinitions.PerlSubDefinitionStub"
    mixin("method_definition")="com.perl5.lang.perl.psi.mixins.PerlMethodDefinitionMixin"
    implements("method_definition")="com.perl5.lang.perl.psi.PerlMethodDefinition"

    stubClass("func_definition")="com.perl5.lang.perl.psi.stubs.subsdefinitions.PerlSubDefinitionStub"
    mixin("func_definition")="com.perl5.lang.perl.psi.mixins.PerlFuncDefinitionMixin"
    implements("func_definition")="com.perl5.lang.perl.psi.PerlSubDefinitionElement"

    stubClass("sub_definition")="com.perl5.lang.perl.psi.stubs.subsdefinitions.PerlSubDefinitionStub"
    mixin("sub_definition")="com.perl5.lang.perl.psi.mixins.PerlSubDefinitionMixin"
    implements("sub_definition")="com.perl5.lang.perl.psi.PerlSubDefinitionElement"

    stubClass("sub_declaration")="com.perl5.lang.perl.psi.stubs.subsdeclarations.PerlSubDeclarationStub"
    mixin("sub_declaration")="com.perl5.lang.perl.psi.mixins.PerlSubDeclarationBase"
    implements("sub_declaration")="com.perl5.lang.perl.psi.PerlSubDeclarationElement"
    extends("sub_declaration")=statement

    stubClass("glob_variable")="com.perl5.lang.perl.psi.stubs.globs.PerlGlobStub"
    mixin("glob_variable")="com.perl5.lang.perl.psi.mixins.PerlGlobVariableMixin"
    implements("glob_variable")="com.perl5.lang.perl.psi.PerlGlobVariable"

    mixin("require_expr")="com.perl5.lang.perl.psi.mixins.PerlRequireExprMixin"
    implements("require_expr")="com.perl5.lang.perl.psi.PerlRequireExpr"
    stubClass("require_expr")="com.perl5.lang.perl.psi.stubs.imports.runtime.PerlRuntimeImportStub"

	implements("grep_expr")="com.perl5.lang.perl.psi.PerlGrepExpr"
	implements("map_expr")="com.perl5.lang.perl.psi.PerlMapExpr"
	implements("sort_expr")="com.perl5.lang.perl.psi.PerlSortExpr"
	implements("eval_expr")="com.perl5.lang.perl.psi.PerlEvalExpr"
	implements("sub_expr")="com.perl5.lang.perl.psi.PerlSubExpr"

    mixin("do_expr")="com.perl5.lang.perl.psi.mixins.PerlDoExprMixin"
    implements("do_expr")="com.perl5.lang.perl.psi.PerlDoExpr"
    stubClass("do_expr")="com.perl5.lang.perl.psi.stubs.imports.runtime.PerlRuntimeImportStub"

    mixin("method")="com.perl5.lang.perl.psi.mixins.PerlMethodMixin";
    implements("method")="com.perl5.lang.perl.psi.PerlMethodCall";

    implements("namespace_content")="com.perl5.lang.perl.psi.properties.PerlStatementsContainer"

    implements("annotation_type|annotation_returns")="com.perl5.lang.perl.psi.PerlAnnotationWithValue"
    implements("annotation_.*")="com.perl5.lang.perl.psi.PerlAnnotation"
    mixin("annotation_inject")="com.perl5.lang.perl.psi.mixins.PerlAnnotationInjectMixin"
 }

///////////////////////////// main code structure //////////////////////////////////////////////////////////////////////
root ::= <<parseFileContent>> file_items
// invoked by parser
private file_items ::= file_item*

private file_item ::= !<<eof>>
{
	namespace_definition
	| label_declaration [statement_item]
    | statement_item
}

private statement_item ::=
        <<parseSemicolon>> +
        | nyi_statement
        | <<parseParserExtensionStatement>>
        | compound_statement
        | format_definition
        | <<parseUse>>
        | <<parseNo>>
        | statement
        | block_compound  // put it after statement to handle anon hashes before it.
        | annotation
		| POD
		| '__DATA__'
		| '__END__'
		| <<parseBadCharacters>> // Fallback for bad characters

// invoked from PerlUseVarsDeclarationsParser
private use_vars_declarations ::= {variable_declaration_element|glob_variable|code_variable}*

namespace_definition ::= namespace_definition_name (normal_block | <<parseSemicolon>> <<parseNamespaceContent>>) {pin=1 recoverWhile=recover_statement}
private namespace_definition_name ::= 'package' any_package [perl_version] {pin=1 recoverWhile=recover_statement}
namespace_content ::= real_namespace_content
private real_namespace_content ::= {!'package' file_item} *  {extends=normal_block recoverWhile=recover_statement} //

private parse_block ::= <<consumeTokens 'LP_CODE_BLOCK'>> | <<consumeTokens 'LP_CODE_BLOCK_WITH_TRYCATCH'>> | normal_block
private normal_block ::= <<block braced_block_content>> // !-> pin disabled for dereference of anon hash; probably this slows us down
// used in com.perl5.lang.perl.parser.PerlLazyBlockParser
private braceless_block ::= <<block file_items>>
meta block ::= <<x1>>
private braced_block_content ::= '{' block_content '}' {pin=1}
private block_content ::= file_item * {recoverWhile=recover_statement}

nyi_statement ::= 'nyi'
format_definition ::=  'format' [SUB_NAME] '=' [FORMAT] FORMAT_TERMINATOR {pin=1}

private compound_statement ::=
    sub_definition
    | named_block
    | if_compound
    | unless_compound
    | given_compound
    | while_compound
    | until_compound
    | for_or_foreach
    | when_compound
    | default_compound
    | method_definition
    | func_definition
    | trycatch_compound
    | switch_compound
    | cases_sequence


named_block ::= BLOCK_NAME parse_block

if_compound ::=  'if' conditional_block if_compound_elsif * [if_compound_else]  {pin=1}
unless_compound ::=  'unless' conditional_block if_compound_elsif * [if_compound_else]  {pin=1}
private if_compound_elsif ::= [POD]  'elsif' conditional_block  {pin=2}
private if_compound_else ::= [POD]  'else' unconditional_block {pin=2}
unconditional_block ::= parse_block

/*
 Hybrid parsing for try/catch/finally.
 Following syntaxes supported:
 - https://metacpan.org/pod/Try::Catch
 - https://metacpan.org/pod/Try::Tiny
 - https://metacpan.org/pod/Exception::Class::TryCatch
 - https://metacpan.org/pod/TryCatch
 - https://metacpan.org/pod/Error
 - https://metacpan.org/pod/Dancer::Exception
 */
trycatch_compound ::= 'TryCatch::' <<try_expr parse_block>> [<<catch_expr parse_block>>]

trycatch_expr ::= <<try_expr sub_expr_simple>> (<<catch_expr sub_expr_simple>>|finally_expr|except_expr|otherwise_expr|continuation_expr)*
meta try_expr ::= 'try' <<x1>> {pin=1}
meta catch_expr ::= 'catch' [catch_condition] <<x1>> {pin=1}
catch_condition ::= catch_condition_parenthesised | catch_condition_with
private catch_condition_parenthesised ::= '(' catch_condition_content ')' {pin=1}
private catch_condition_with ::= 'package::name' 'catch_with' {pin=2}
private catch_condition_content ::= [catch_condition_type] variable_declaration_element [where_clause]
private where_clause ::= expr
private catch_condition_type ::=  [type_constraints]
type_constraints ::= any_package ['[' expr ']']

finally_expr ::= 'finally' sub_expr_simple {pin=1}
except_expr ::= 'except' sub_expr_simple {pin=1}
otherwise_expr ::= 'otherwise' sub_expr_simple {pin=1}
continuation_expr ::= 'continuation' sub_expr_simple {pin=1}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

conditional_block ::= parse_conditional_block
private parse_conditional_block ::= condition_expr parse_block {pin=1}
condition_expr ::= parse_parenthesised_expr

given_compound ::=  'given' parse_conditional_block  {pin=1}
when_compound ::=  'when' parse_conditional_block  {pin=1}
default_compound ::=  'default' parse_block {pin=1}

while_compound ::=  'while' parse_conditional_block [[POD] continue_block]  {pin=1}
until_compound ::=  'until' parse_conditional_block [[POD] continue_block]  {pin=1}

continue_block ::= continue_block_opener parse_block {pin=1}
private continue_block_opener ::= 'continue' &'{'

block_compound ::= parse_block_compound
private parse_block_compound ::= parse_block [[POD] continue_block]

// for/foreach
// fixme why the heck there is no parsing error on "for" and there is a error on "use", both pinned
// fixme add recover
private for_or_foreach ::= for_compound|foreach_compound

for_compound ::= {'for'|'foreach'} for_iterator parse_block {pin=2}
private for_iterator ::= '(' [for_init]  ';' [for_condition] ';' [for_mutator] ')' {pin=3}
for_init ::= expr {recoverWhile=recover_parenthesised}
for_condition ::= expr {recoverWhile=recover_parenthesised}
for_mutator ::= expr {recoverWhile=recover_parenthesised}

foreach_compound ::= {'for'|'foreach'} [ foreach_iterator ] condition_expr parse_block_compound {pin=1} // foreach works as a fallback
foreach_iterator ::= variable_declaration | variable


statement ::= sub_declaration | statement_body <<statementSemi>>

private statement_body ::= normal_statement {recoverWhile=recover_statement}

private normal_statement ::= expr [<<parseStatementModifier>>] {pin=1}
//private normal_statement_body ::= expr {recoverWhile=recover_statement}

// fixme adjust parsing of this thing to avoid duplicates
sub_definition ::=  ['my'|'our'|'state'] 'sub' sub_names_token sub_definition_parameters parse_block
sub_declaration ::=  ['my'|'our'|'state'] 'sub' sub_names_token sub_declaration_parameters <<statementSemi>>
private sub_declaration_parameters ::= sub_definition_parameters {recoverWhile=recover_statement}

private sub_names_token ::= [QUALIFYING_PACKAGE] SUB_NAME

private sub_definition_parameters ::=
  sub_attributes [sub_signature_in_parens] |
  [sub_prototype_or_signature] [sub_attributes]
private sub_prototype_or_signature ::= '(' sub_prototype_or_signature_content ')' {pin=1}
private sub_prototype_or_signature_content ::= sub_signature |sub_prototype
private sub_signature_in_parens ::= '(' [sub_signature] ')' {pin=1}

private sub_prototype ::= SUB_PROTOTYPE_TOKEN*

/************************************* Sub signatures *****************************************************************/
sub_signature ::= sub_signature_element (',' sub_signature_element) *
private sub_signature_element ::= signature_left_side ['=' [parse_scalar_expr]]
private signature_left_side ::= variable_declaration_element | sub_signature_element_ignore
sub_signature_element_ignore ::= '$$' | '$@' | '$%'

/************************************* Sub signatures *****************************************************************/

private sub_attributes ::= <<attributes <<parse_sub_attributes>>>>
private parse_sub_attributes ::= ':' attribute ([':'] attribute)*  {pin=1}
private var_attributes ::= <<attributes <<parse_var_attributes>>>>
private parse_var_attributes ::= ':' attribute ([':'] attribute)*  // {pin=1} pin disable because of $something ? my $var : $other;
meta attributes ::= <<x1>>
attribute ::= ATTRIBUTE_IDENTIFIER [quoted_sq_string]

last_expr ::=  'last' [lnr_param] {pin=1}
next_expr ::=  'next' [lnr_param] {pin=1}
redo_expr ::=  'redo' [lnr_param] {pin=1}
goto_expr ::=  'goto' [goto_param] {pin=1}

return_expr ::=  'return' [parse_list_expr] {pin=1}
exit_expr ::= 'exit' [parse_scalar_expr] {pin=1}
scalar_expr ::= 'scalar' single_argument_expr {pin=1}
keys_expr ::= 'keys' single_argument_expr {pin=1}
values_expr ::= 'values' single_argument_expr {pin=1}
each_expr ::= 'each' single_argument_expr {pin=1}
defined_expr ::= 'defined' [unary_expr] {pin=1}
wantarray_expr ::= 'wantarray'
delete_expr ::= 'delete' unary_expr {pin=1}
splice_expr ::= 'splice' parse_list_expr {pin=1}
bless_expr ::= 'bless' parse_list_expr {pin=1}

array_unshift_expr ::= 'unshift' list_call_arguments {pin=1 implements="com.perl5.lang.perl.psi.PerlUnshiftPushExpr"}
array_push_expr ::= 'push' list_call_arguments {pin=1 implements="com.perl5.lang.perl.psi.PerlUnshiftPushExpr"}
array_shift_expr ::= 'shift' optional_unary_call_arguments {pin=1 implements="com.perl5.lang.perl.psi.PerlShiftPopExpr"}
array_pop_expr ::= 'pop' optional_unary_call_arguments {pin=1 implements="com.perl5.lang.perl.psi.PerlShiftPopExpr"}

private lnr_param ::= label_expr | expr // fixme scalar_expr ?
private goto_param ::= label_expr | code_primitive  !'(' | expr


statement_modifier ::=
    if_statement_modifier
    | unless_statement_modifier
    | while_statement_modifier
    | until_statement_modifier
    | for_statement_modifier
    | when_statement_modifier

if_statement_modifier ::=    'if' expr {pin=1 name="Postfix if"}
unless_statement_modifier ::=    'unless' expr {pin=1 name="Postfix unless"}
while_statement_modifier ::=    'while' expr {pin=1 name="Postfix while"}
until_statement_modifier ::=    'until' expr {pin=1 name="Postfix until"}
for_statement_modifier ::=    {'for'|'foreach'} expr  {pin=1 name="Postfix for"}
when_statement_modifier ::=    'when' expr {pin=1 name="Postfix when"}

private parse_use_statement ::=  'use' <<parseUseParameters use_no_parameters>> <<statementSemi>> {pin=1}
private parse_no_statement ::=  'no' use_no_parameters <<statementSemi>> {pin=1}

private use_no_parameters ::= use_module_parameters | use_version_parameters {recoverWhile=recover_statement}
private use_module_parameters ::= any_package [perl_version [comma]] [expr];
private use_version_parameters ::= perl_version;

undef_expr ::=  'undef' (undef_params | '(' undef_params ')') ? {pin=1}
private undef_params ::= deref_expr | variable

require_expr ::=  'require' (any_package| perl_version | parse_scalar_expr)  {pin=1}// multiline string is possible too

private any_package ::= 'package::name' | '__PACKAGE__'

private recover_statement ::= <<recoverStatement>>

// expression
expr ::=
    lp_or_xor_expr          // 0
    | lp_and_expr           // 1
    | lp_not_expr           // 2
    | comma_sequence_expr   // 3 for list
    | assign_or_flow_expr   // 4
    | ternary_expr          // 5
    | flipflop_expr         // 6
    | or_expr               // 7
    | and_expr              // 8
    | bitwise_or_xor_expr   // 9
    | bitwise_and_expr      // 10
    | equal_expr            // 11
    | compare_expr          // 12
    | shift_expr            // 13  for unary
    | add_expr              // 14
    | mul_expr              // 15
    | regex_expr            // 16
    | op_5_expr             // 17
    | pow_expr              // 18
    | op_3_expr             // 19
    | deref_expr            // 20 for a single argument
    | term_expr             // 21

// above list operators
private parse_list_expr ::= <<parseExpressionLevel 2>>

// List expression elements
private parse_scalar_expr ::= <<parseExpressionLevel 3>>

// Unary expression argument
private unary_expr ::= <<parseExpressionLevel 12>>
private optional_unary_expr ::= [unary_expr]

private single_argument_expr ::= <<parseExpressionLevel 19>>

// ordered for best performance of perltidy
term_expr ::=
    scalar_or_element
    | string
    | number_constant
    | variable_declaration_lexical
    | list_or_list_element
    | array_or_slice
    | match_regex
    | return_expr
    | scalar_expr
    | keys_expr
    | values_expr
    | each_expr
    | defined_expr
    | delete_expr
    | splice_expr
    | bless_expr
    | array_shift_expr
    | array_unshift_expr
    | array_push_expr
    | array_pop_expr
    | wantarray_expr
    | exit_expr
    | hash_variable
    | hash_cast_expr
    | array_index_variable
    | scalar_index_cast_expr
    | anon_array
    | undef_expr
    | print_expr
    | replacement_regex
    | sub_expr_full
    | eval_expr
    | do_expr
    | anon_hash
    | variable_declaration_local
    | sort_expr
    | grep_expr
    | map_expr
    | continue_expr

    | glob_or_element
    | tag_scalar
    | variable_declaration_global
    | compile_regex
    | tr_regex
    | file_read_expr
    | require_expr
    | perl_handle_expr
    | <<parseParserExtensionTerm>>

    | trycatch_expr

    | sub_call_expr
    | code_primitive
    | package_expr

package_expr ::= any_package
continue_expr ::= 'continue' ['(' ')'] {pin=1}
grep_expr ::=  'grep' grep_map_arguments {pin=1}
map_expr ::=  'map' grep_map_arguments {pin=1}

private grep_map_arguments ::=
    '(' grep_map_arguments_ ')' !'['
    | grep_map_arguments_

private grep_map_arguments_ ::=
    parse_block [comma] grep_map_sort_tail
    | parse_scalar_expr comma grep_map_sort_tail
    | expr

private grep_map_sort_tail ::= parse_list_expr

sort_expr ::=  'sort' sort_arguments {pin=1}
private sort_arguments ::=
    '(' sort_arguments_ ')' !'['
    | sort_arguments_

private sort_arguments_ ::=
    sub_expr_simple [comma] grep_map_sort_tail
    | sorter grep_map_sort_tail
    | grep_map_sort_tail

private sorter ::= scalar_variable | normal_method

private list_or_list_element ::= parenthesised_expr [array_element]
parenthesised_expr ::= parse_parenthesised_expr
private parse_parenthesised_expr ::= <<parse_parenthesized_expression parenthesised_expr_content>>
private meta parse_parenthesized_expression ::= '(' <<x1>> ')' {pin=1 name="Parenthesised expression"}
private parenthesised_expr_content ::= [expr] {recoverWhile=recover_parenthesised}
private recover_parenthesised ::= !(')' | '{' | '}' | <<checkSemicolon>> )

deref_expr ::= expr (<<parseArrowSmart>> nested_element_variation) + //{pin(".*")=1}

private op_3_expr ::= pref_pp_expr | suff_pp_expr
pref_pp_expr ::= ('++'|'--') expr
suff_pp_expr ::= expr ('++'|'--')

pow_expr ::= expr ('**' expr)+ { rightAssociative=true }

private op_5_expr ::= ref_expr | prefix_unary_expr
ref_expr ::= '\\' expr { rightAssociative=true }
prefix_unary_expr ::= {'~' | '!' | '+' | '-'} expr { rightAssociative=true }
regex_expr ::= expr ('=~'|'!~') expr
mul_expr ::= expr ({'*'|'/'|'%'|'x'} expr)+
add_expr ::= expr ({'+'|'-'|'.'} expr)+
shift_expr ::= expr ({'<<'|'>>'} expr)+
compare_expr ::= expr ({'>='|'<='|'>'|'<'|'ge'|'le'|'gt'|'lt'}) expr
equal_expr ::= expr {'=='|'!='|'<=>'|'eq'|'ne'|'cmp'|'~~'} expr
bitwise_and_expr ::= expr ('&' expr)+
bitwise_or_xor_expr ::= expr ({'|'|'^'} expr)+
and_expr ::= expr ( '&&' expr)+
or_expr ::= expr ( {'||'|'//'} expr)+
flipflop_expr ::= expr ('..'|'...') expr
ternary_expr ::= expr '?' parse_scalar_expr ':' parse_scalar_expr { rightAssociative=true }

private assign_or_flow_expr ::=
    assign_expr
    | last_expr
    | next_expr
    | goto_expr
    | redo_expr

// fixme do we need to collapse tokens?
assign_expr ::= expr ({'**='|'+='|'-='|'*='|'/='|'%='|'.='|'x='|'&='|'|='|'^='|'<<='|'>>='|'&&='|'||='|'//='|'='} expr ) + { rightAssociative=true }
comma_sequence_expr ::= expr <<parseCommaSequence>> // fixme implement pinnning
lp_not_expr ::= 'not' expr { rightAssociative=true }
lp_and_expr ::= expr ('and' expr)+
lp_or_xor_expr ::= expr ({'or'|'xor'} expr)+

print_expr ::=  ('print'|'printf'|'say') ( <<parenthesised_call_arguments [print_arguments] >> | [print_arguments] ) {pin=1}
private print_arguments ::= perl_handle expr | expr

private sub_expr_full ::= <<sub_expr parse_sub_expr_full>>
private parse_sub_expr_full ::= 'sub' sub_definition_parameters parse_block

private sub_expr_simple ::= <<sub_expr parse_block>>

meta sub_expr ::=  <<x1>>  // fixme make sure that this one checked after definition and declaration

file_read_expr ::= LEFT_ANGLE perl_handle_expr RIGHT_ANGLE


////////////////////////// regular expressions /////////////////////////////////////////////////////////////////////////
// pinning quotes leads to bug with replacement block
compile_regex ::=   'qr' match_regex_body {pin=1}
match_regex ::=   ['m'] match_regex_body
private match_regex_body ::= regex_match REGEX_QUOTE_CLOSE [perl_regex_modifiers]

replacement_regex ::=
     's'
    regex_match
    regex_replace
    'r}'
    [perl_regex_modifiers]
    {pin=1}

private regex_match ::= 'r{' [<<consumeTokens 'LP_REGEX'>>|<<consumeTokens 'LP_REGEX_X'>>|<<consumeTokens 'LP_REGEX_XX'>>|perl_regex]
private regex_replace ::= regex_replace_regex | regex_replace_code

private regex_replace_regex ::= {'r/' | 'r}' 'r{' } [<<consumeTokens 'LP_REGEX_REPLACEMENT'>>|perl_regex]
private regex_replace_code ::= {'re/' | 'r}' 're{' } [regex_code]
private regex_code ::= <<consumeTokens 'LP_CODE_BLOCK'>> | <<block file_item*>>

perl_regex_modifiers ::= '/m' +
perl_regex ::= perl_regex_item *
private perl_regex_item ::=
	'regex' |
//	'\w'	|
//	custom_char_class |
        block_compound |
	interpolated_constructs

//custom_char_class ::= '[[' custom_char_class_body ']]' {pin=1}
//private custom_char_class_body ::= ['^'] regex_char_class_body_item * {recoverWhile=recover_char_class_body}
//private regex_char_class_body_item ::= char_range | '\w' | <<remapToken 'OPERATOR_MINUS, REGEX_CHAR_CLASS'>> | posix_char_class | interpolated_constructs
//private recover_char_class_body ::= !('\w'| ']]' | '$@' | '$$' | '$#' | 'r}' | '-')
//char_range ::= '\w' '-' '\w'
//posix_char_class ::= '[:' ['^'] [':name:'] ':]' {pin=1}

tr_regex ::=  ('tr'|'y') tr_search tr_replacement [tr_modifiers] {pin=1}
private tr_search ::= 'r{' [tr_searchlist] {pin=1}
tr_searchlist ::= STRING_CONTENT
private tr_replacement ::= {'r/' | 'r}' 'r{'} [tr_replacementlist] 'r}' {pin=1}
tr_replacementlist ::= STRING_CONTENT
tr_modifiers ::= '/m' +

////////////////////////// end of regular expressions //////////////////////////////////////////////////////////////////

do_expr ::=  'do' do_argument {pin=1}
private do_argument ::= parenthesised_expr | parse_block | expr

eval_expr ::=  'eval' [eval_argument] {pin=1}
private eval_argument ::= parenthesised_expr | sub_expr_simple | expr

private variable_declaration ::=
    variable_declaration_global
    | variable_declaration_lexical
    | variable_declaration_local

// @todo attributes support
variable_declaration_local ::=  'local' [any_package]  local_variable_declaration_variation {pin=1}
variable_declaration_lexical ::=  ('my' | 'state') [any_package] variable_declaration_variation [var_attributes] {pin=1}
variable_declaration_global ::=  'our' [any_package] variable_declaration_variation [var_attributes] {pin=1}


private local_variable_declaration_variation ::= local_parenthesised_declaration | local_variable_declaration_argument
private local_parenthesised_declaration ::= '(' local_variable_declaration_argument (comma + local_variable_declaration_argument ) * comma * ')' {pin=1}
private local_variable_declaration_argument ::= strict_variable_declaration_argument | parse_scalar_expr

private variable_declaration_variation ::= variable_parenthesised_declaration | variable_declaration_argument
private variable_parenthesised_declaration ::= '(' variable_parenthesised_declaration_contents ')' {pin=1}
private variable_parenthesised_declaration_contents ::= strict_variable_declaration_argument (comma + strict_variable_declaration_argument ) * comma*

private strict_variable_declaration_argument ::= strict_variable_declaration_wrapper |  undef_expr
private variable_declaration_argument ::= variable_declaration_element |  undef_expr

private strict_variable_declaration_wrapper ::= variable_declaration_element !('{' | '[' | '->' )
variable_declaration_element ::= '\\'? lexical_variable

/////////////////////////////////// REFERENCES /////////////////////////////////////////////////////////////////////////
anon_array ::= '[' [expr] ']' //{pin=1}
anon_hash ::= '{' [expr] '}' <<validateAnonHashSuffix>>  // fixme pin here after solving problem with code block and prototypes

//////////////////////////// END OF REFERENCES /////////////////////////////////////////////////////////////////////////

// fixme it's not a variable, its variable expression
private variable ::= scalar_or_element | array_or_slice | hash_variable | hash_cast_expr | glob_or_element

private array_primitive ::=
    array_variable
    | array_cast_expr
    | string_list


private array_or_slice ::= array_primitive [array_slice|hash_slice]
left array_slice ::= array_index
left hash_slice ::= hash_index

array_cast_expr ::= '$@' array_cast_target
private array_cast_target ::= {<<block array_braced_cast_target>> | scalar_primitive}
private array_braced_cast_target ::= '@{' block_content '@}' {pin=1}

hash_cast_expr ::= '$%' hash_cast_target
private hash_cast_target ::= {<<block hash_braced_cast_target >> | scalar_primitive}
private hash_braced_cast_target ::= '%{' block_content '%}' {pin=1}

private scalar_primitive ::=
    scalar_variable
    | scalar_cast_expr
    | undef_expr  // shouldn't it be in term ? (check declarations)

// |'$}'|'@}'|'%}'|'*}'|'&}'
scalar_cast_expr ::= '$$' scalar_cast_target
scalar_index_cast_expr ::= '$#' scalar_cast_target
private scalar_cast_target ::= {<<block scalar_braced_cast_target>> | scalar_primitive}
private scalar_braced_cast_target ::= '${' block_content '$}' {pin=1}

private scalar_or_element ::= scalar_primitive [array_element|hash_element]

left array_element ::= array_index
left hash_element ::= hash_index

private glob_or_element ::= glob_primitive [glob_slot]
private glob_primitive ::=
    glob_variable
    | glob_cast_expr

glob_cast_expr ::= '$*' glob_cast_target
private glob_cast_target ::= {<<block glob_braced_cast_target>> | scalar_primitive}
private glob_braced_cast_target ::= '*{' block_content '*}' {pin=1}

left glob_slot ::= hash_index

private code_primitive ::= code_variable | code_cast_expr
code_cast_expr ::= '$&' code_cast_target
private code_cast_target ::= {<<block code_braced_cast_target>> | scalar_primitive}
private code_braced_cast_target ::= '&{' block_content '&}' {pin=1}


// extended nested element for using in ()
private nested_element_variation ::=
	<<parseNestedElementVariation>>
    | hash_index
    | array_index
    | regular_nested_call
    | default_parenthesised_call_arguments
    | scalar_call
    | post_deref_expr
    | post_deref_glob_expr
    | post_deref_array_slice_expr
    | post_deref_hash_slice_expr

post_deref_expr ::= '->$*'|'->$#*'|'->@*'|'->%*'|'->**'|'->&*'	{name="Postderef"}
post_deref_glob_expr ::= '$*' hash_index 						{name="Glob expr"}
post_deref_array_slice_expr ::= '$@' {hash_index|array_index}	{name="Array slice"}
post_deref_hash_slice_expr ::= '$%' {hash_index|array_index}	{name="Hash slice"}

hash_index ::= '{' hash_index_content '}' {pin=1}
private hash_index_content ::= expr {recoverWhile=recover_braced_expression}
private recover_braced_expression ::= !'}'
array_index ::= '[' array_index_content ']' {pin=1}
private array_index_content ::= expr {recoverWhile=recover_bracketed_expression}
private recover_bracketed_expression ::= !']'

///////////////////////////////////// CALLABLE /////////////////////////////////////////////////////////////////////////
meta method ::= <<x1>>
// deprecated, remove after moving to poly-named elements
meta nested_call ::= <<nested_call_inner <<x1>> <<x2>>>>	// reused by mk_accessor and so on
private meta nested_call_inner ::= <<method <<x1>>>> [<<parenthesised_call_arguments <<x2>>>>]
meta call_arguments ::= <<x1>>
private default_parenthesised_call_arguments ::= <<parenthesised_call_arguments optional_expression>>
meta parenthesised_call_arguments ::= <<parse_parenthesized_expression <<x1>>>> !'['
private optional_expression ::= [expr]
private meta any_call_arguments ::= <<parenthesised_call_arguments <<x1>>>> | <<call_arguments <<x1>>>>
private list_call_arguments ::= <<any_call_arguments parse_list_expr>>
private optional_unary_call_arguments ::= [<<parenthesised_call_arguments optional_unary_expr>> | <<call_arguments <<unary_expr>>>>]

private regular_nested_call ::= <<nested_call regular_nested_call_tokens optional_expression>>
private regular_nested_call_tokens ::= [QUALIFYING_PACKAGE] SUB_NAME
scalar_call ::= scalar_or_element [default_parenthesised_call_arguments]

sub_call_expr ::=
 	<<leftward_call method_tokens>> |
 	named_unary_call |
 	argumentless_call |
 	<<rightward_call method_tokens>>

private argumentless_call ::= <<method 'argumentless'>>

private named_unary_call ::= <<method named_unary_calee>> [<<call_arguments unary_expr>>]
private named_unary_calee ::= 'unary' | 'unary_custom' | '-t'

private meta rightward_call ::= <<method <<x1>>>> [<<call_arguments parse_call_arguments>>]
private meta leftward_call ::= {<<method <<x1>>>>|code_primitive} default_parenthesised_call_arguments

//// fixme this should depend on prototype
private parse_call_arguments ::=
    <<parseHashSmart>>
    | sub_expr_simple [[comma] parse_list_expr]
    | parse_list_expr

private normal_method ::= <<method method_tokens>>
// the rest are fallback
private method_tokens ::= 'list' | 'unary' | 'unary_custom'| 'argumentless' |
  QUALIFYING_PACKAGE SUB_NAME |
  SUB_NAME [PACKAGE] |
  'method' | 'func' |
  'finally' | 'try' | 'catch' |
  'switch' | 'case'



////////////////////////////////END OF CALLABLE ////////////////////////////////////////////////////////////////////////

label_declaration ::= <<parseLabelDeclaration>> // custom faster method
label_expr ::= IDENTIFIER|SUB_NAME !'('
private perl_version ::= <<parsePerlVersion>>
private perl_handle ::=  perl_handle_expr | parse_block | scalar_variable !('{'|'['|<<isOperatorToken>>)
perl_handle_expr ::= HANDLE

//////////////////////////////////// constants /////////////////////////////////////////////////////////////////////////

tag_scalar ::= TAG

number_constant ::= NUMBER | NUMBER_VERSION | NUMBER_SIMPLE

private string ::= string_bare | string_sq | string_dq | string_xq | heredoc_opener

string_dq ::= [ 'qq'] quoted_qq_string
private quoted_qq_string ::= QUOTE_DOUBLE_OPEN [<<consumeTokens 'LP_STRING_QQ'>> | qq_string_content ] QUOTE_DOUBLE_CLOSE {pin=1}
private qq_string_content ::= (STRING_CONTENT_QQ | interpolated_constructs)+

string_xq ::= [ 'qx'] quoted_xq_string
private quoted_xq_string ::= QUOTE_TICK_OPEN [<<consumeTokens 'LP_STRING_QX'>> | xq_string_content] QUOTE_TICK_CLOSE {pin=1}
private xq_string_content ::= (STRING_CONTENT_XQ | interpolated_constructs)+

private interpolated_constructs ::= deref_expr

string_bare ::= STRING_CONTENT

string_sq ::= [ 'q'] quoted_sq_string
string_list ::=  'qw' qw_string {pin=1}
private qw_string ::= QUOTE_SINGLE_OPEN [parse_qw_string_content] QUOTE_SINGLE_CLOSE {pin=1}
private parse_qw_string_content ::= <<isUseVars>> <<mapUseVars qw_string_content>>+|qw_string_content
private qw_string_content ::= <<consumeTokens 'LP_STRING_QW'>>|string_bare+
private quoted_sq_string ::= QUOTE_SINGLE_OPEN [smart_sq_string_content] QUOTE_SINGLE_CLOSE {pin=1}
private smart_sq_string_content ::= <<isUseVars>> <<mapUseVars sq_string_content_element>>+ | sq_string_content
private sq_string_content ::= sq_string_content_element +
private sq_string_content_element ::= <<consumeTokens 'LP_STRING_Q'>> |STRING_CONTENT

heredoc_opener ::= 'heredoc<<' ( '\\' string_bare | string ){pin=1}

///////////////////////////////////// variables ////////////////////////////////////////////////////////////////////////
private lexical_variable ::= scalar_variable | array_variable | hash_variable

array_index_variable ::= '$#' {SCALAR_NAME | '${' SCALAR_NAME '$}'}
scalar_variable ::= '$$' {SCALAR_NAME | '${' SCALAR_NAME '$}'}
array_variable ::= '$@' {ARRAY_NAME | '@{' ARRAY_NAME '@}'}
hash_variable ::= '$%' {HASH_NAME | '%{' HASH_NAME '%}'}
code_variable ::= '$&' {normal_method | '&{' normal_method '&}'}
glob_variable ::= '$*' {GLOB_NAME | '*{' GLOB_NAME '*}'}

private comma ::= ',' | '=>'


/********************************************** Extensions for Method::Signatures *************************************/
// we can make this smareter and use keywords from settings or import opitions; We can't pin here because MooseX method works othewise
method_definition ::= 'method' sub_names_token [method_signature] [sub_attributes] parse_block
func_definition ::= 'func' sub_names_token [func_signature] [sub_attributes] parse_block

// not sure that we need a wrapper for signatures
private method_signature ::= '(' method_signature_content ')' {pin=1}
method_signature_content ::= [method_signature_invocant] [variable_parenthesised_declaration_contents] {recoverWhile=recover_signature_content}
method_signature_invocant ::= <<scalarDeclarationWrapper>> ':'
private func_signature ::= '(' func_signature_content ')' {pin=1}
func_signature_content ::= [variable_parenthesised_declaration_contents] {recoverWhile=recover_signature_content}
private recover_signature_content ::= !(')'|'{')

/********************************************** Extensions for Moose **************************************************/

/******************************************* Annotations **************************************************************/
private annotation ::=
	annotation_abstract
	| annotation_deprecated
	| annotation_method
	| annotation_override
	| annotation_returns
	| annotation_type
	| annotation_inject
	| annotation_noinspection
	| '#@unknown'

annotation_abstract ::= '#@abstract' {pin=1}
annotation_deprecated ::= '#@deprecated' {pin=1}
annotation_method ::=  '#@method' {pin=1}
annotation_override ::=  '#@override' {pin=1}
annotation_returns ::=  '#@returns' annotation_type_param {pin=1}
private annotation_type_param ::=
  '*' |
  arrayref_type |
  hashref_type |
  any_package

arrayref_type ::= 'ArrayRef' '[' annotation_type_param ']' {pin=1}
hashref_type ::= 'HashRef' '[' annotation_type_param ']' {pin=1}

annotation_type ::=  '#@type' annotation_type_param {pin=1}
annotation_inject ::=  '#@inject' string_bare {pin=1}
annotation_noinspection ::=  '#@noinspection' string_bare {pin=1}
/******************************************* End of annotations *******************************************************/

/******************************************* Lazy parsable elements *******************************************************/
lp_string_qq ::= qq_string_content {extraRoot=true}
lp_string_q ::= sq_string_content {extraRoot=true}
lp_string_qx ::= xq_string_content{extraRoot=true}
lp_string_qw ::= qw_string_content{extraRoot=true}

lp_regex ::= perl_regex {extraRoot=true}
lp_regex_x ::= perl_regex {extraRoot=true}
lp_regex_xx ::= perl_regex {extraRoot=true}
lp_regex_replacement ::= perl_regex {extraRoot=true}

lp_code_block ::= normal_block | braceless_block {extraRoot=true}
lp_code_block_with_trycatch ::= normal_block | braceless_block {extraRoot=true}
parsable_string_use_vars ::= use_vars_declarations {extraRoot=true}
comment_annotation ::= annotation {extraRoot=true}
heredoc ::= sq_string_content {extraRoot=true}
heredoc_qq ::= qq_string_content {extraRoot=true}
heredoc_qx ::= xq_string_content{extraRoot=true}
/******************************************* End of Lazy parsable elements *******************************************************/

/**********************************************************  switch.pm ******************************************************************/
switch_compound ::= 'switch' switch_condition normal_block {pin=1}
switch_condition ::= '(' parse_scalar_expr ')'
private cases_sequence ::= case_compound + [case_default]
case_compound ::= 'case' case_condition normal_block {pin=1}
case_condition ::= '(' parse_scalar_expr ')' | normal_block | string | number_constant | anon_array | match_regex | compile_regex
case_default ::= if_compound_else
/******************************************************* end of switch.pm ***************************************************************/

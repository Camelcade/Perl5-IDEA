/*
Copyright 2015 Alexandr Evstigneev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
{
  elementTypeHolderClass="com.perl5.lang.perl.lexer.PerlElementTypesGenerated"
  parserClass="com.perl5.lang.perl.parser.PerlParserGenerated"
  extends="com.perl5.lang.perl.psi.impl.PerlCompositeElementImpl"

  psiClassPrefix="PsiPerl"
  psiImplClassSuffix="Impl"
  psiPackage="com.perl5.lang.perl.psi"
  psiImplPackage="com.perl5.lang.perl.psi.impl"

  elementTypeHolderClass="com.perl5.lang.perl.lexer.PerlElementTypes"

  tokenTypeClass="com.perl5.lang.perl.parser.elementTypes.PerlTokenType"
  elementTypeClass="com.perl5.lang.perl.parser.elementTypes.PerlElementType"

  elementTypeFactory="com.perl5.lang.perl.parser.elementTypes.PerlElementTypeFactory.getElementType"
  tokenTypeFactory="com.perl5.lang.perl.parser.elementTypes.PerlElementTypeFactory.getTokenType"

  parserUtilClass="com.perl5.lang.perl.parser.PerlParserUtil"

  tokens=[
    COMMENT_LINE='COMMENT_LINE'
    COMMENT_ANNOTATION='COMMENT_ANNOTATION'
    COMMENT_BLOCK='COMMENT_BLOCK'
    POD='POD'

    SIGIL_ARRAY='$@'
    SIGIL_SCALAR='$$'
    SIGIL_SCALAR_INDEX='$#'
    SIGIL_GLOB='$*'
    SIGIL_HASH='$%'
    SIGIL_CODE='$&'

	LEFT_BRACE_SCALAR='${'
	LEFT_BRACE_ARRAY='@{'
	LEFT_BRACE_HASH='%{'
	LEFT_BRACE_GLOB='*{'
	LEFT_BRACE_CODE='&{'

	RIGHT_BRACE_SCALAR='$}'
	RIGHT_BRACE_ARRAY='@}'
	RIGHT_BRACE_HASH='%}'
	RIGHT_BRACE_GLOB='*}'
	RIGHT_BRACE_CODE='&}'

	// postfix deref
	DEREF_SCALAR='->$*'
	DEREF_SCALAR_INDEX='->$#*'
	DEREF_ARRAY='->@*'
	DEREF_HASH='->%*'
	DEREF_GLOB='->**'
	DEREF_CODE='->&*'

    // generated tokens
    SCALAR_NAME='SCALAR_NAME'
    ARRAY_NAME='ARRAY_NAME'
    HASH_NAME='HASH_NAME'
    GLOB_NAME='GLOB_NAME'

    HEREDOC='HEREDOC'
    HEREDOC_QQ='HEREDOC_QQ'
    HEREDOC_QX='HEREDOC_QX'
    HEREDOC_END='HEREDOC_END'

    FORMAT='FORMAT'
    FORMAT_TERMINATOR='.'

    VERSION_ELEMENT='VERSION_ELEMENT'

    NUMBER_VERSION='NUMBER_VERSION'
    NUMBER='NUMBER'
    NUMBER_SIMPLE='NUMBER_SIMPLE' // fixme get rid of

    RESERVED_IF='if'
    RESERVED_UNLESS='unless'
    RESERVED_ELSIF='elsif'
    RESERVED_ELSE='else'
    RESERVED_GIVEN='given'
    RESERVED_WHILE='while'
    RESERVED_UNTIL='until'
    RESERVED_FOR='for'
    RESERVED_FOREACH='foreach'
    RESERVED_CONTINUE='continue'
    RESERVED_WHEN='when'
    RESERVED_DEFAULT='default'

    RESERVED_FORMAT='format'
    RESERVED_SUB='sub'
    RESERVED_PACKAGE='package'
    RESERVED_USE='use'
    RESERVED_NO='no'
    RESERVED_REQUIRE='require'

    RESERVED_PRINT='print'
    RESERVED_PRINTF='printf'
    RESERVED_SAY='say'

    RESERVED_MAP='map'
    RESERVED_GREP='grep'
    RESERVED_SORT='sort'

    RESERVED_UNDEF='undef'

    RESERVED_QW='qw'

    RESERVED_QQ='qq'
    RESERVED_Q='q'
    RESERVED_QX='qx'

    RESERVED_TR='tr'
    RESERVED_Y='y'

    RESERVED_S='s'
    RESERVED_QR='qr'
    RESERVED_M='m'

	RESERVED_FINALLY = 'finally';
	RESERVED_TRY = 'try';
	RESERVED_CATCH = 'catch';

    RESERVED_MY='my'
    RESERVED_OUR='our'
    RESERVED_STATE='state'
    RESERVED_LOCAL='local'

    RESERVED_DO='do'
    RESERVED_EVAL='eval'

    RESERVED_GOTO='goto'
    RESERVED_REDO='redo'
    RESERVED_NEXT='next'
    RESERVED_LAST='last'

	RESERVED_RETURN='return'

	RESERVED_METHOD='method'
	RESERVED_FUNC='func'

    // Operators



    OPERATOR_X='x'

    OPERATOR_CMP_NUMERIC='<=>'
    OPERATOR_LT_NUMERIC='<'
    OPERATOR_GT_NUMERIC='>'

    OPERATOR_DEREFERENCE='->'
    FAT_COMMA='=>'
    COMMA=','

    OPERATOR_HELLIP='...'
    OPERATOR_NYI='nyi'
    OPERATOR_FLIP_FLOP='..'
    OPERATOR_CONCAT='.'

    OPERATOR_PLUS_PLUS='++'
    OPERATOR_MINUS_MINUS='--'
    OPERATOR_POW='**'

    OPERATOR_RE='=~'
    OPERATOR_NOT_RE='!~'

    OPERATOR_HEREDOC='heredoc<<'
    OPERATOR_SHIFT_LEFT='<<'
    OPERATOR_SHIFT_RIGHT='>>'

    OPERATOR_AND='&&'
    OPERATOR_OR='||'
    OPERATOR_OR_DEFINED='//'
    OPERATOR_NOT='!'

    OPERATOR_ASSIGN='='

    QUESTION='?'
    COLON=':'

    OPERATOR_REFERENCE='\\'

    OPERATOR_DIV='/'
    OPERATOR_MUL='*'
    OPERATOR_MOD='%'

    OPERATOR_PLUS='+'
    OPERATOR_MINUS='-'

    OPERATOR_BITWISE_NOT='~'
    OPERATOR_BITWISE_AND='&'
    OPERATOR_BITWISE_OR='|'
    OPERATOR_BITWISE_XOR='^'

    OPERATOR_AND_LP='and'
    OPERATOR_OR_LP='or'
    OPERATOR_XOR_LP='xor'
    OPERATOR_NOT_LP='not'

    OPERATOR_LT_STR='lt'
    OPERATOR_GT_STR='gt'
    OPERATOR_LE_STR='le'
    OPERATOR_GE_STR='ge'
    OPERATOR_CMP_STR='cmp'
    OPERATOR_EQ_STR='eq'
    OPERATOR_NE_STR='ne'

    // synthetic tokens
    OPERATOR_POW_ASSIGN='**='
    OPERATOR_PLUS_ASSIGN='+='
    OPERATOR_MINUS_ASSIGN='-='
    OPERATOR_MUL_ASSIGN='*='
    OPERATOR_DIV_ASSIGN='/='
    OPERATOR_MOD_ASSIGN='%='
    OPERATOR_CONCAT_ASSIGN='.='
    OPERATOR_X_ASSIGN='x='
    OPERATOR_BITWISE_AND_ASSIGN='&='
    OPERATOR_BITWISE_OR_ASSIGN='|='
    OPERATOR_BITWISE_XOR_ASSIGN='^='
    OPERATOR_SHIFT_LEFT_ASSIGN='<<='
    OPERATOR_SHIFT_RIGHT_ASSIGN='>>='
    OPERATOR_AND_ASSIGN='&&='
    OPERATOR_OR_ASSIGN='||='
    OPERATOR_OR_DEFINED_ASSIGN='//='

    OPERATOR_GE_NUMERIC='>='
    OPERATOR_LE_NUMERIC='<='
    OPERATOR_EQ_NUMERIC='=='
    OPERATOR_NE_NUMERIC='!='
    OPERATOR_SMARTMATCH='~~'
// end of synthetic operators

    OPERATOR_FILETEST='-t'

    // single mid-quote. e evaluatable s///e;
    REGEX_QUOTE='r/'
    REGEX_QUOTE_E='re/'
    REGEX_TOKEN='regex'

    // paired mid-quote. e for evaluatable s{}{}e;
    REGEX_QUOTE_OPEN='r{'
    REGEX_QUOTE_OPEN_E='re{' // block should be interpolated as a perl script

    REGEX_QUOTE_CLOSE='r}'
    REGEX_MODIFIER='/m'

	REGEX_LEFT_BRACKET = '[['
	REGEX_RIGHT_BRACKET = ']]'
	REGEX_LEFT_PAREN = '(('
	REGEX_RIGHT_PAREN = '))'
	REGEX_LEFT_BRACE = '{{'
	REGEX_RIGHT_BRACE = '}}'
	REGEX_POSIX_LEFT_BRACKET = '[:'
	REGEX_POSIX_RIGHT_BRACKET = ':]'
	REGEX_POSIX_CLASS_NAME = ':name:'
	REGEX_CHAR_CLASS="\w"

	LP_STRING_Q="LP_STRING_Q"
	LP_STRING_QQ="LP_STRING_QQ"
	LP_STRING_XQ="LP_STRING_QX"
	LP_STRING_QW="LP_STRING_QW"

	LP_REGEX="LP_REGEX"
	LP_REGEX_X="LP_REGEX_X"
	LP_REGEX_REPLACEMENT="LP_REGEX_REPLACEMENT"

	LP_CODE_BLOCK="LAZY_PARSABLE_BLOCK"

    STRING_CONTENT='STRING_CONTENT'
    STRING_CONTENT_QQ='STRING_CONTENT_QQ'
    STRING_CONTENT_XQ='STRING_CONTENT_XQ'

    PARSABLE_STRING_USE_VARS = 'PARSABLE_STRING_USE_VARS'

    TAG='TAG'
    TAG_END='TAG_END'
    TAG_DATA='TAG_DATA'

    LEFT_ANGLE='LEFT_ANGLE'
    RIGHT_ANGLE='RIGHT_ANGLE'

    LEFT_BRACKET='['
    RIGHT_BRACKET=']'

    LEFT_PAREN='('
    RIGHT_PAREN=')'

	// abstract token to make code blocks
    LEFT_BRACE_CODE_START='code{'

    LEFT_BRACE='{'
    RIGHT_BRACE='}'

    SEMICOLON=';';

    QUOTE_DOUBLE='QUOTE_DOUBLE'
    QUOTE_DOUBLE_OPEN='QUOTE_DOUBLE_OPEN'
    QUOTE_DOUBLE_CLOSE='QUOTE_DOUBLE_CLOSE'

    QUOTE_SINGLE='QUOTE_SINGLE'
    QUOTE_SINGLE_OPEN='QUOTE_SINGLE_OPEN'
    QUOTE_SINGLE_CLOSE='QUOTE_SINGLE_CLOSE'

    QUOTE_TICK='QUOTE_TICK'
    QUOTE_TICK_OPEN='QUOTE_TICK_OPEN'
    QUOTE_TICK_CLOSE='QUOTE_TICK_CLOSE'

    // custom tokens
    IDENTIFIER='IDENTIFIER'
	SUB_NAME='subname'

    BUILTIN_LIST='list'
    BUILTIN_UNARY='unary'
    BUILTIN_ARGUMENTLESS='argumentless'

	ATTRIBUTE_IDENTIFIER='ATTRIBUTE_IDENTIFIER'

    SUB_PROTOTYPE_TOKEN='SUB_PROTOTYPE_TOKEN'

    PACKAGE='package::name'
    QUALIFYING_PACKAGE='package::name::'
    PACKAGE_PRAGMA_CONSTANT='constant'
    PACKAGE_PRAGMA_VARS='vars'

    HANDLE='HANDLE'
    BLOCK_NAME='BLOCK_NAME'

    ANNOTATION_DEPRECATED_KEY='#@deprecated'
    ANNOTATION_RETURNS_KEY='#@returns'
    ANNOTATION_OVERRIDE_KEY='#@override'
    ANNOTATION_METHOD_KEY='#@method'
    ANNOTATION_ABSTRACT_KEY='#@abstract'
    ANNOTATION_INJECT_KEY='#@inject'
    ANNOTATION_TYPE_KEY='#@type'
    ANNOTATION_NOINSPECTION_KEY='#@noinspection'
    ANNOTATION_UNKNOWN_KEY='#@unknown'
  ]

    extends(".+expr")=expr
    name(".+expr")="expression"

	implements(".+_cast_expr")="com.perl5.lang.perl.psi.PerlCastExpression"
	mixin(".+_cast_expr")="com.perl5.lang.perl.psi.mixins.PerlCastExpressionMixin"

	implements("assign_expr")="com.perl5.lang.perl.psi.PerlAssignExpression"
	mixin("assign_expr")="com.perl5.lang.perl.psi.mixins.PerlAssignExpressionImplMixin"

	extends(".*statement_modifier")=statement_modifier

	extends(".*_signature_content")=sub_signature

    extends("heredoc_opener|anon_array|anon_hash")=expr
//    extends("glob_slot")=expr
    extends("number_constant")=expr

    extends("string_list")=expr
    mixin("string_list")="com.perl5.lang.perl.psi.mixins.PerlStringListImplMixin"

    extends("replacement_regex|compile_regex|match_regex|tr_regex")=expr

    mixin("perl_regex")="com.perl5.lang.perl.psi.mixins.Perl5RegexpMixin"

    extends("heredoc_opener|tag_scalar")=expr

    extends("string_sq|string_dq|string_xq|string_bare")=expr
    implements("string_sq|string_dq|string_xq|string_bare")="com.perl5.lang.perl.psi.PerlString"
    mixin("string_sq|string_dq|string_xq")="com.perl5.lang.perl.psi.mixins.PerlStringImplMixin"
    mixin("string_bare")="com.perl5.lang.perl.psi.mixins.PerlStringBareImplMixin"

    extends("nested_call")=sub_call_expr

    implements("nested_call|sub_call_expr|named_list_expr|unary_list_expr")="com.perl5.lang.perl.psi.PerlMethodContainer"

    mixin("use_statement")="com.perl5.lang.perl.psi.mixins.PerlUseStatementImplMixin"
    implements("use_statement")="com.perl5.lang.perl.psi.PerlUseStatement"
    stubClass("use_statement")="com.perl5.lang.perl.idea.stubs.imports.PerlUseStatementStub"

    mixin("no_statement")="com.perl5.lang.perl.psi.mixins.PerlNoStatementImplMixin"
    implements("no_statement")="com.perl5.lang.perl.psi.PerlNoStatement"
    stubClass("no_statement")="com.perl5.lang.perl.idea.stubs.imports.PerlUseStatementStub"

    implements("constant_definition")="com.perl5.lang.perl.psi.PerlConstantDefinition"
    mixin("constant_definition")="com.perl5.lang.perl.psi.mixins.PerlConstantDefinitionMixin"
    stubClass("constant_definition")="com.perl5.lang.perl.idea.stubs.subsdefinitions.PerlSubDefinitionStub"

	mixin("call_arguments")="com.perl5.lang.perl.psi.mixins.PerlCallArgumentsMixin"
	extends("parenthesised_call_arguments")=call_arguments

    extends("use_statement.*")=statement
    extends("no_statement")=statement
    extends("condition_statement|condition_statement_while|for_list_statement|for_iterator_statement")=statement

	implements("named_block|conditional_block|unconditional_block")="com.perl5.lang.perl.psi.properties.PerlStatementsContainer"

	implements("label_declaration")="com.perl5.lang.perl.psi.PerlLabelDeclaration"
	extends("label_declaration")="com.perl5.lang.perl.psi.mixins.PerlLabelDeclarationImplMixin"

	implements("block")="com.perl5.lang.perl.psi.PerlBlock"
	implements("for_compound")="com.perl5.lang.perl.psi.PerlForCompound"
	implements("foreach_compound")="com.perl5.lang.perl.psi.PerlForeachCompound"
	implements("while_compound")="com.perl5.lang.perl.psi.PerlWhileCompound"
	implements("until_compound")="com.perl5.lang.perl.psi.PerlUntilCompound"

    implements("conditional_block_while|.*_compound")="com.perl5.lang.perl.psi.properties.PerlLexicalScope";
    mixin("conditional_block_while|block|.*_compound")="com.perl5.lang.perl.psi.mixins.PerlLexicalScopeMemberMixin"

    implements("heredoc_opener")="com.perl5.lang.perl.psi.PerlHeredocOpener"
    mixin("heredoc_opener")="com.perl5.lang.perl.psi.mixins.PerlHeredocOpenerMixin"

    implements("deref_expr")="com.perl5.lang.perl.psi.PerlDerefExpression"
    mixin("deref_expr")="com.perl5.lang.perl.psi.mixins.PerlDerefExpressionMixin"

    extends("use_vars_statement")=statement
    implements("use_vars_statement")="com.perl5.lang.perl.psi.IPerlUseVars"
    mixin("use_vars_statement")="com.perl5.lang.perl.psi.mixins.PerlUseVarsMixin"

    extends("variable_declaration_global|variable_declaration_lexical|variable_declaration_local")=expr
    implements("variable_declaration_lexical|variable_declaration_local|variable_declaration_global")="com.perl5.lang.perl.psi.PerlVariableDeclaration"
    mixin("variable_declaration_lexical|variable_declaration_local|variable_declaration_global")="com.perl5.lang.perl.psi.mixins.PerlVariableDeclarationMixin"

    extends("code_variable")=expr

    extends("array_slice|hash_slice|array_element|hash_element|glob_slot")=expr

    stubClass("variable_declaration_wrapper")="com.perl5.lang.perl.idea.stubs.variables.PerlVariableStub"
    mixin("variable_declaration_wrapper")="com.perl5.lang.perl.psi.mixins.PerlVariableDeclarationWrapperMixin"
    implements("variable_declaration_wrapper")="com.perl5.lang.perl.psi.PerlVariableDeclarationWrapper"

    extends("array_index_variable|scalar_variable|array_variable|hash_variable|glob_variable")=expr
    mixin("code_variable|scalar_variable|array_variable|hash_variable|array_index_variable")="com.perl5.lang.perl.psi.mixins.PerlVariableImplMixin"
    implements("code_variable|scalar_variable|array_variable|hash_variable|array_index_variable")="com.perl5.lang.perl.psi.PerlVariable"

	mixin("label_expr")="com.perl5.lang.perl.psi.impl.PerlCompositeElementWithReference"

    stubClass("namespace_definition")="com.perl5.lang.perl.idea.stubs.namespaces.PerlNamespaceDefinitionStub"
    mixin("namespace_definition")="com.perl5.lang.perl.psi.mixins.PerlNamespaceDefinitionImplMixin"
    implements("namespace_definition")="com.perl5.lang.perl.psi.PerlNamespaceDefinition"

    stubClass("method_definition")="com.perl5.lang.perl.idea.stubs.subsdefinitions.PerlSubDefinitionStub"
    mixin("method_definition")="com.perl5.lang.perl.psi.mixins.PerlMethodDefinitionImplMixin"
    implements("method_definition")="com.perl5.lang.perl.psi.PerlMethodDefinition"

    stubClass("func_definition")="com.perl5.lang.perl.idea.stubs.subsdefinitions.PerlSubDefinitionStub"
    mixin("func_definition")="com.perl5.lang.perl.psi.mixins.PerlFuncDefinitionImplMixin"
    implements("func_definition")="com.perl5.lang.perl.psi.PerlFuncDefinition"

    stubClass("sub_definition")="com.perl5.lang.perl.idea.stubs.subsdefinitions.PerlSubDefinitionStub"
    mixin("sub_definition")="com.perl5.lang.perl.psi.mixins.PerlSubDefinitionImplMixin"
    implements("sub_definition")="com.perl5.lang.perl.psi.PerlSubDefinition"

    stubClass("sub_declaration")="com.perl5.lang.perl.idea.stubs.subsdeclarations.PerlSubDeclarationStub"
    mixin("sub_declaration")="com.perl5.lang.perl.psi.mixins.PerlSubDeclarationImplMixin"
    implements("sub_declaration")="com.perl5.lang.perl.psi.PerlSubDeclaration"
    extends("sub_declaration")=statement

    stubClass("glob_variable")="com.perl5.lang.perl.idea.stubs.globs.PerlGlobStub"
    mixin("glob_variable")="com.perl5.lang.perl.psi.mixins.PerlGlobVariableImplMixin"
    implements("glob_variable")="com.perl5.lang.perl.psi.PerlGlobVariable"

    mixin("require_expr")="com.perl5.lang.perl.psi.mixins.PerlRequireExprImplMixin"
    implements("require_expr")="com.perl5.lang.perl.psi.PerlRequireExpr"
    stubClass("require_expr")="com.perl5.lang.perl.idea.stubs.imports.runtime.PerlRuntimeImportStub"

	implements("grep_expr")="com.perl5.lang.perl.psi.PerlGrepExpr"
	implements("map_expr")="com.perl5.lang.perl.psi.PerlMapExpr"
	implements("sort_expr")="com.perl5.lang.perl.psi.PerlSortExpr"
	implements("eval_expr")="com.perl5.lang.perl.psi.PerlEvalExpr"
	implements("sub_expr")="com.perl5.lang.perl.psi.PerlSubExpr"

    mixin("do_expr")="com.perl5.lang.perl.psi.mixins.PerlDoExprImplMixin"
    implements("do_expr")="com.perl5.lang.perl.psi.PerlDoExpr"
    stubClass("do_expr")="com.perl5.lang.perl.idea.stubs.imports.runtime.PerlRuntimeImportStub"

    mixin("method")="com.perl5.lang.perl.psi.mixins.PerlMethodImplMixin";
    implements("method")="com.perl5.lang.perl.psi.PerlMethod";

    implements("namespace_content")="com.perl5.lang.perl.psi.properties.PerlStatementsContainer"

    implements("annotation_returns|annotation_type")="com.perl5.lang.perl.psi.PerlAnnotationWithType"
    implements("annotation_.*")="com.perl5.lang.perl.psi.PerlAnnotation"
    mixin("annotation_inject")="com.perl5.lang.perl.psi.mixins.PerlAnnotationInjectMixin"
 }

///////////////////////////// main code structure //////////////////////////////////////////////////////////////////////
root ::= <<parseFileContent>> file_items
// invoked by parser
private file_items ::= file_item*

private file_item ::= !<<eof>>
{
	namespace_definition
	| label_declaration [statement_item]
    | statement_item
}

private statement_item ::=
        <<parseSemicolon>> +
        | nyi_statement
        | <<parseParserExtensionStatement>>
        | compound_statement
        | format_definition
        | statement
        | block_compound  // put it after statement to handle anon hashes before it.
        | annotation
		| POD
		| TAG_END
		| TAG_DATA
		| <<parseBadCharacters>> // Fallback for bad characters

// invoked from PerlUseVarsDeclarationsParser
private use_vars_declarations ::= {variable_declaration_wrapper|glob_variable|code_variable}*

namespace_definition ::= namespace_definition_name (normal_block | <<parseSemicolon>> <<parseNamespaceContent>>) {pin=1 recoverWhile=recover_statement}
private namespace_definition_name ::= 'package' any_package [perl_version] {pin=1 recoverWhile=recover_statement}
namespace_content ::= real_namespace_content
private real_namespace_content ::= {!'package' file_item} *  {extends=normal_block recoverWhile=recover_statement} //

private parse_block ::= LP_CODE_BLOCK | normal_block
private normal_block ::= <<block braced_block_content>> // !-> pin disabled for dereference of anon hash; probably this slows us down
meta block ::= <<x1>>
private braced_block_content ::= '{' block_content '}' {pin=1}
private block_content ::= file_item * {recoverWhile=recover_statement}

nyi_statement ::= 'nyi'
format_definition ::=  'format' [SUB_NAME] '=' [FORMAT] FORMAT_TERMINATOR {pin=1}

private compound_statement ::=
    sub_definition
    | named_block
    | if_compound
    | unless_compound
    | given_compound
    | while_compound
    | until_compound
    | for_compound
    | foreach_compound
    | when_compound
    | default_compound
    | method_definition
    | func_definition

named_block ::= BLOCK_NAME parse_block

if_compound ::=  'if' conditional_block if_compound_elsif * [if_compound_else]  {pin=1}
unless_compound ::=  'unless' conditional_block if_compound_elsif * [if_compound_else]  {pin=1}
private if_compound_elsif ::= [POD]  'elsif' conditional_block  {pin=2}
private if_compound_else ::= [POD]  'else' unconditional_block {pin=2}
unconditional_block ::= parse_block

///////////////////////////////////////// hybrid parsing for Try::Tiny and TryCatch ////////////////////////////////////
trycatch_expr ::= try_expr (catch_expr|finally_expr)* [expr]
try_expr ::= 'try' (parse_block|expr) {pin=1}
catch_expr ::= 'catch' [catch_condition] (parse_block|expr) {pin=1}
catch_condition ::= '(' catch_condition_content ')' {pin=1}
private catch_condition_content ::= [catch_condition_type] variable_declaration_wrapper [expr]
private catch_condition_type ::=  [type_constraints]
type_constraints ::= any_package ['[' expr ']']

finally_expr ::= 'finally' (parse_block|expr) {pin=1}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

conditional_block ::= condition_statement parse_block {pin=1 name="Conditional block"}
condition_statement ::= '(' condition_statement_expr ')' {pin=1 name="Condition"}

conditional_block_while ::= condition_statement_while parse_block {pin=1 name="Conditional block"}
condition_statement_while ::= '(' [condition_statement_expr] ')' {pin=1 name="Condition"}
private condition_statement_expr ::= expr {recoverWhile=recover_condition_statement_expr}
private recover_condition_statement_expr ::= !('{'|')')

given_compound ::=  'given' conditional_block  {pin=1}
when_compound ::=  'when' conditional_block  {pin=1}
default_compound ::=  'default' parse_block {pin=1}

while_compound ::=  'while' conditional_block_while [ [POD] continue_block]  {pin=1}
until_compound ::=  'until' conditional_block [[POD] continue_block]  {pin=1}

continue_block ::= 'continue' parse_block {pin=1}

private block_compound ::= parse_block [[POD] continue_block]


// for/foreach
// fixme why the heck there is no parsing error on "for" and there is a error on "use", both pinned
for_compound ::=  'for' for_arguments {pin=1}
foreach_compound ::=  'foreach' for_arguments  {pin=1}
private for_arguments ::=
    for_iterator parse_block
    | for_list_statement block_compound

for_iterator ::= '(' [for_iterator_statement]  ';' [for_iterator_statement] ';' [for_iterator_statement] ')' {pin=3}
for_iterator_statement ::= expr {recoverWhile=recover_parenthesised}

// @todo only single variable or variable definition may be here
for_list_statement ::= [ variable_declaration | variable ] for_list_epxr
for_list_epxr ::= '(' for_list_expr_content ')' {pin=1}
private for_list_expr_content ::= list_expr {recoverWhile=recover_parenthesised}


statement ::=
    use_statements
    | no_statements
    | sub_declaration
	| statement_body <<statementSemi>>

private statement_body ::= normal_statement {recoverWhile=recover_statement}

private normal_statement ::= expr [<<parseStatementModifier>>] {pin=1}
//private normal_statement_body ::= expr {recoverWhile=recover_statement}

// fixme adjust parsing of this thing to avoid duplicates
sub_definition ::=  'sub' sub_names_token sub_definition_parameters parse_block
sub_declaration ::=  'sub' sub_names_token sub_declaration_parameters <<statementSemi>>
private sub_declaration_parameters ::= sub_definition_parameters {recoverWhile=recover_statement}

private sub_names_token ::= [QUALIFYING_PACKAGE] SUB_NAME

private sub_definition_parameters ::= [sub_prototype_or_signature] [sub_attributes]
private sub_prototype_or_signature ::= '(' sub_prototype_or_signature_content ')' {pin=1}
private sub_prototype_or_signature_content ::= sub_signature |sub_prototype

private sub_prototype ::= SUB_PROTOTYPE_TOKEN*

/************************************* Sub signatures *****************************************************************/
sub_signature ::= sub_signature_element (',' sub_signature_element) *
private sub_signature_element ::= signature_left_side ['=' [scalar_expr]]
private signature_left_side ::= variable_declaration_wrapper | sub_signature_element_ignore
sub_signature_element_ignore ::= '$$' | '$@' | '$%'

/************************************* Sub signatures *****************************************************************/

private sub_attributes ::= ':' attribute ([':'] attribute)*  {pin=1}
private var_attributes ::= ':' attribute ([':'] attribute)*  // {pin=1} pin disable because of $something ? my $var : $other;
attribute ::= ATTRIBUTE_IDENTIFIER [quoted_sq_string]

last_expr ::=  'last' [lnr_param] {pin=1}
next_expr ::=  'next' [lnr_param] {pin=1}
redo_expr ::=  'redo' [lnr_param] {pin=1}
goto_expr ::=  'goto' [goto_param] {pin=1}

return_expr ::=  'return' [list_expr] {pin=1}

private lnr_param ::= label_expr | expr // fixme scalar_expr ?
private goto_param ::= label_expr | code_cast_expr | code_variable | expr


statement_modifier ::=
    if_statement_modifier
    | unless_statement_modifier
    | while_statement_modifier
    | until_statement_modifier
    | for_statement_modifier
    | foreach_statement_modifier
    | when_statement_modifier

if_statement_modifier ::=    'if' expr {pin=1 name="Postfix if"}
unless_statement_modifier ::=    'unless' expr {pin=1 name="Postfix unless"}
while_statement_modifier ::=    'while' expr {pin=1 name="Postfix while"}
until_statement_modifier ::=    'until' expr {pin=1 name="Postfix until"}
for_statement_modifier ::=    'for' expr  {pin=1 name="Postfix for"}
foreach_statement_modifier ::=    'foreach' expr {pin=1 name="Postfix foreach"}
when_statement_modifier ::=    'when' expr {pin=1 name="Postfix when"}

private use_statements ::= // fixme these shold be recovered otherwise, cause it has no statement modifiers
  use_statement_constant
  | use_vars_statement
  | use_statement

private no_statements ::= // fixme these shold be recovered otherwise, cause it has no statement modifiers
  no_statement

use_statement ::=  'use' use_no_parameters <<statementSemi>> {pin=1}
no_statement ::=  'no' use_no_parameters <<statementSemi>> {pin=1}

private use_no_parameters ::= use_module_parameters | use_version_parameters {recoverWhile=recover_statement}
private use_module_parameters ::= any_package [perl_version [comma]] [expr];
private use_version_parameters ::= perl_version;

// other name to extend declaration, not variable
use_vars_statement ::=  'use' 'vars' use_vars_parameters <<statementSemi>> {pin=2}
private use_vars_parameters ::= [perl_version] [<<parseUseVarsParameters>>] {recoverWhile=recover_statement}

use_statement_constant ::=  'use' 'constant' use_constant_parameters <<statementSemi>> {pin=2}
private use_constant_parameters ::= [perl_version] [use_constant_variants] {recoverWhile=recover_statement}
private use_constant_variants ::=
  constants_block
  | single_constant_definition
  | expr

constants_block ::= '{' [constants_block_content] '}' {pin=1}
private constants_block_content ::= constant_block_content_element (comma constant_block_content_element) * [comma+] {recoverWhile=recover_constants_block}
private recover_constants_block ::= !('}')
private constant_block_content_element ::= constant_definition | scalar_expr {recoverWhile=recover_single_constant_definition}
private recover_single_constant_definition ::= !('}'|comma|';')

private single_constant_definition ::= constant_definition {recoverWhile=recover_statement}

constant_definition ::= string comma scalar_expr

undef_expr ::=  'undef' (undef_params | '(' undef_params ')') ? {pin=1}
private undef_params ::= deref_expr | variable

require_expr ::=  'require' (any_package| perl_version | scalar_expr)  {pin=1}// multiline string is possible too

private any_package ::= 'package::name'|'constant'|'vars'

private recover_statement ::= <<recoverStatement>>

// expression
expr ::=
    lp_or_xor_expr          // 0
    | lp_and_expr           // 1
    | lp_not_expr           // 2
    | comma_sequence_expr   // 3 for list
    | assign_or_flow_expr   // 4
    | trenar_expr           // 5
    | flipflop_expr         // 6
    | or_expr               // 7
    | and_expr              // 8
    | bitwise_or_xor_expr   // 9
    | bitwise_and_expr      // 10
    | equal_expr            // 11
    | compare_expr          // 12
    | shift_expr            // 13  for unary
    | add_expr              // 14
    | mul_expr              // 15
    | regex_expr            // 16
    | op_5_expr             // 17
    | pow_expr              // 18
    | op_3_expr             // 19
    | deref_expr            // 20
    | term_expr             // 21

// above list operators
private list_expr ::= <<parseExpressionLevel 2>>

// List expression elements
private scalar_expr ::= <<parseExpressionLevel 3>>

// Unary expression argument
private unary_expr ::= <<parseExpressionLevel 12>>

// ordered for best performance of perltidy
term_expr ::=
    scalar_or_element
    | string
    | number_constant
    | variable_declaration_lexical
    | list_or_list_element
    | array_or_slice
    | match_regex
    | return_expr
    | hash_variable
    | hash_cast_expr
    | array_index_variable
	| scalar_index_cast_expr
    | anon_array
    | undef_expr
    | print_expr
	| replacement_regex
    | sub_expr
    | eval_expr
    | do_expr
	| anon_hash
    | variable_declaration_local
    | sort_expr
    | grep_expr
    | map_expr

    | glob_or_element
    | tag_scalar
    | variable_declaration_global
    | compile_regex
	| tr_regex
    | file_read_expr
    | require_expr
    | perl_handle_expr
	| <<parseParserExtensionTerm>>

    | trycatch_expr
    | catch_expr	// fallback for keyword
    | finally_expr // fallback for keyword

    | sub_call_expr
    | code_primitive
	| package_expr

package_expr ::= PACKAGE

grep_expr ::=  'grep' grep_map_arguments {pin=1}
map_expr ::=  'map' grep_map_arguments {pin=1}

private grep_map_arguments ::=
    '(' grep_map_arguments_ ')' !'['
    | grep_map_arguments_

private grep_map_arguments_ ::=
    parse_block [comma] grep_map_sort_tail
    | scalar_expr comma grep_map_sort_tail
    | expr

private grep_map_sort_tail ::= list_expr

sort_expr ::=  'sort' sort_arguments {pin=1}
private sort_arguments ::=
    '(' sort_arguments_ ')' !'['
    | sort_arguments_

private sort_arguments_ ::=
    parse_block [comma] grep_map_sort_tail
    | sorter grep_map_sort_tail
    | grep_map_sort_tail

private sorter ::= scalar_variable | normal_method

private list_or_list_element ::= parenthesised_expr [array_element]
parenthesised_expr ::= <<parse_parenthesized_expression parenthesised_expr_content>>
private meta parse_parenthesized_expression ::= '(' <<x1>> ')' {pin=1 name="Parenthesised expression"}
private parenthesised_expr_content ::= [expr] {recoverWhile=recover_parenthesised}
private recover_parenthesised ::= !(')' | '{' | '}' | <<checkSemicolon>> )

deref_expr ::= expr (<<parseArrowSmart>> nested_element_variation) + //{pin(".*")=1}

private op_3_expr ::= pref_pp_expr | pref_mm_expr | suff_pp_expr
pref_pp_expr ::= '++' expr
pref_mm_expr ::= '--' expr

suff_pp_expr ::= expr ('++'|'--')

pow_expr ::= expr ('**' expr)+ { rightAssociative=true }

private op_5_expr ::= ref_expr | prefix_unary_expr
ref_expr ::= '\\' expr { rightAssociative=true }
prefix_unary_expr ::= {'~' | '!' | '+' | '-'} expr { rightAssociative=true }
regex_expr ::= expr ('=~'|'!~') expr
mul_expr ::= expr ({'*'|'/'|'%'|'x'} expr)+
add_expr ::= expr ({'+'|'-'|'.'} expr)+
shift_expr ::= expr ({'<<'|'>>'} expr)+
compare_expr ::= expr ({'>='|'<='|'>'|'<'|'ge'|'le'|'gt'|'lt'}) expr
equal_expr ::= expr {'=='|'!='|'<=>'|'eq'|'ne'|'cmp'|'~~'} expr
bitwise_and_expr ::= expr ('&' expr)+
bitwise_or_xor_expr ::= expr ({'|'|'^'} expr)+
and_expr ::= expr ( '&&' expr)+
or_expr ::= expr ( {'||'|'//'} expr)+
flipflop_expr ::= expr ('..'|'...') expr
trenar_expr ::= expr '?' scalar_expr ':' scalar_expr { rightAssociative=true }

private assign_or_flow_expr ::=
    assign_expr
    | last_expr
    | next_expr
    | goto_expr
    | redo_expr

// fixme do we need to collapse tokens?
assign_expr ::= expr ({'**='|'+='|'-='|'*='|'/='|'%='|'.='|'x='|'&='|'|='|'^='|'<<='|'>>='|'&&='|'||='|'//='|'='} expr ) + { rightAssociative=true }
comma_sequence_expr ::= expr <<parseCommaSequence>> // fixme implement pinnning
lp_not_expr ::= 'not' expr { rightAssociative=true }
lp_and_expr ::= expr ('and' expr)+
lp_or_xor_expr ::= expr ({'or'|'xor'} expr)+

print_expr ::=  ('print'|'printf'|'say') ( '(' [print_arguments] ')' | [print_arguments] ) {pin=1}
private print_arguments ::= perl_handle expr | expr

sub_expr ::=  'sub' sub_definition_parameters parse_block  // fixme make sure that this one checked after definition and declaration

file_read_expr ::= LEFT_ANGLE perl_handle_expr RIGHT_ANGLE


////////////////////////// regular expressions /////////////////////////////////////////////////////////////////////////
// pinning quotes leads to bug with replacement block
compile_regex ::=   'qr' match_regex_body {pin=1}
match_regex ::=   ['m'] match_regex_body
private match_regex_body ::= regex_match REGEX_QUOTE_CLOSE [perl_regex_modifiers]

replacement_regex ::=
     's'
    regex_match
    regex_replace
    'r}'
    [perl_regex_modifiers]
    {pin=1}

private regex_match ::= 'r{' [LP_REGEX|LP_REGEX_X|perl_regex]
private regex_replace ::= regex_replace_regex | regex_replace_code

private regex_replace_regex ::= {'r/' | 'r}' 'r{' } [LP_REGEX_REPLACEMENT|perl_regex]
private regex_replace_code ::= {'re/' | 'r}' 're{' } [regex_code]
private regex_code ::= LP_CODE_BLOCK | file_item+

perl_regex_modifiers ::= '/m' +
perl_regex ::= perl_regex_item +
private perl_regex_item ::=
	'regex' |
	'\w'	|
	custom_char_class |
	interpolated_constructs

custom_char_class ::= '[[' custom_char_class_body ']]' {pin=1}
private custom_char_class_body ::= ['^'] regex_char_class_body_item * {recoverWhile=recover_char_class_body}
private regex_char_class_body_item ::= char_range | '\w' | <<remapToken 'OPERATOR_MINUS, REGEX_CHAR_CLASS'>> | posix_char_class | interpolated_constructs
private recover_char_class_body ::= !('\w'| ']]' | '$@' | '$$' | '$#' | 'r}' | '-')
char_range ::= '\w' '-' '\w'
posix_char_class ::= '[:' ['^'] [':name:'] ':]' {pin=1}

tr_regex ::=  ('tr'|'y') tr_search tr_replacement [tr_modifiers] {pin=1}
private tr_search ::= 'r{' [tr_searchlist] {pin=1}
tr_searchlist ::= STRING_CONTENT
private tr_replacement ::= {'r/' | 'r}' 'r{'} [tr_replacementlist] 'r}' {pin=1}
tr_replacementlist ::= STRING_CONTENT
tr_modifiers ::= '/m' +

////////////////////////// end of regular expressions //////////////////////////////////////////////////////////////////

do_expr ::=  'do' eval_argument {pin=1}
eval_expr ::=  'eval' [eval_argument] {pin=1}
private eval_argument ::= parenthesised_expr | parse_block | expr

private variable_declaration ::=
    variable_declaration_global
    | variable_declaration_lexical
    | variable_declaration_local

// @todo attributes support
variable_declaration_local ::=  'local' [any_package]  local_variable_declaration_variation {pin=1}
variable_declaration_lexical ::=  ('my' | 'state') [any_package] variable_declaration_variation [var_attributes] {pin=1}
variable_declaration_global ::=  'our' [any_package] variable_declaration_variation [var_attributes] {pin=1}


private local_variable_declaration_variation ::= local_parenthesised_declaration | local_variable_declaration_argument
private local_parenthesised_declaration ::= '(' local_variable_declaration_argument (comma + local_variable_declaration_argument ) * comma * ')' {pin=1}
private local_variable_declaration_argument ::= strict_variable_declaration_argument | scalar_expr

private variable_declaration_variation ::= variable_parenthesised_declaration | variable_declaration_argument
private variable_parenthesised_declaration ::= '(' variable_parenthesised_declaration_contents ')' {pin=1}
private variable_parenthesised_declaration_contents ::= strict_variable_declaration_argument (comma + strict_variable_declaration_argument ) * comma*

private strict_variable_declaration_argument ::= strict_variable_declaration_wrapper |  'undef'
private variable_declaration_argument ::= variable_declaration_wrapper |  'undef'

private strict_variable_declaration_wrapper ::= variable_declaration_wrapper !('{' | '[' | '->' )
variable_declaration_wrapper ::= lexical_variable

/////////////////////////////////// REFERENCES /////////////////////////////////////////////////////////////////////////
anon_array ::= '[' [expr] ']' //{pin=1}
anon_hash ::= '{' [expr] '}' <<validateAnonHashSuffix>>  // fixme pin here after solving problem with code block and prototypes

//////////////////////////// END OF REFERENCES /////////////////////////////////////////////////////////////////////////

// fixme it's not a variable, its variable expression
private variable ::= scalar_or_element | array_or_slice | hash_variable | hash_cast_expr | glob_or_element

private array_primitive ::=
    array_variable
    | array_cast_expr
    | string_list


private array_or_slice ::= array_primitive [array_slice|hash_slice]
left array_slice ::= array_index
left hash_slice ::= hash_index

array_cast_expr ::= '$@' array_cast_target
private array_cast_target ::= {<<block array_braced_cast_target>> | scalar_primitive}
private array_braced_cast_target ::= '@{' block_content '@}' {pin=1}

hash_cast_expr ::= '$%' hash_cast_target
private hash_cast_target ::= {<<block hash_braced_cast_target >> | scalar_primitive}
private hash_braced_cast_target ::= '%{' block_content '%}' {pin=1}

private scalar_primitive ::=
    scalar_variable
    | scalar_cast_expr
    | undef_expr  // shouldn't it be in term ? (check declarations)

// |'$}'|'@}'|'%}'|'*}'|'&}'
scalar_cast_expr ::= '$$' scalar_cast_target
scalar_index_cast_expr ::= '$#' scalar_cast_target
private scalar_cast_target ::= {<<block scalar_braced_cast_target>> | scalar_primitive}
private scalar_braced_cast_target ::= '${' block_content '$}' {pin=1}

private scalar_or_element ::= scalar_primitive [array_element|hash_element]

left array_element ::= array_index
left hash_element ::= hash_index

private glob_or_element ::= glob_primitive [glob_slot]
private glob_primitive ::=
    glob_variable
    | glob_cast_expr

glob_cast_expr ::= '$*' glob_cast_target
private glob_cast_target ::= {<<block glob_braced_cast_target>> | scalar_primitive}
private glob_braced_cast_target ::= '*{' block_content '*}' {pin=1}

left glob_slot ::= hash_index

private code_primitive ::= code_variable | code_cast_expr
code_cast_expr ::= '$&' code_cast_target
private code_cast_target ::= {<<block code_braced_cast_target>> | scalar_primitive}
private code_braced_cast_target ::= '&{' block_content '&}' {pin=1}


// extended nested element for using in ()
private nested_element_variation ::=
	<<parseNestedElementVariation>>
    | hash_index
    | array_index
    | regular_nested_call
    | default_parenthesised_call_arguments
    | scalar_call
    | post_deref_expr
    | post_deref_glob_expr
    | post_deref_array_slice_expr
    | post_deref_hash_slice_expr

post_deref_expr ::= '->$*'|'->$#*'|'->@*'|'->%*'|'->**'|'->&*'	{name="Postderef"}
post_deref_glob_expr ::= '$*' hash_index 						{name="Glob expr"}
post_deref_array_slice_expr ::= '$@' {hash_index|array_index}	{name="Array slice"}
post_deref_hash_slice_expr ::= '$%' {hash_index|array_index}	{name="Hash slice"}

hash_index ::= '{' hash_index_content '}' {pin=1}
private hash_index_content ::= expr {recoverWhile=recover_braced_expression}
private recover_braced_expression ::= !'}'
array_index ::= '[' array_index_content ']' {pin=1}
private array_index_content ::= expr {recoverWhile=recover_bracketed_expression}
private recover_bracketed_expression ::= !']'

///////////////////////////////////// CALLABLE /////////////////////////////////////////////////////////////////////////
meta method ::= <<x1>>
meta nested_call ::= <<method <<x1>>>> [<<parenthesised_call_arguments <<x2>>>>]	// reused by mk_accessor and so on
meta call_arguments ::= <<x1>>
private default_parenthesised_call_arguments ::= <<parenthesised_call_arguments optional_expression>>
meta parenthesised_call_arguments ::= <<parse_parenthesized_expression <<x1>>>> !'['
private optional_expression ::= [expr]

private regular_nested_call ::= <<nested_call regular_nested_call_tokens optional_expression>>
private regular_nested_call_tokens ::= [QUALIFYING_PACKAGE] SUB_NAME
scalar_call ::= scalar_or_element [default_parenthesised_call_arguments]

sub_call_expr ::=
 	<<leftward_call method_tokens>> |
 	named_unary_call |
 	argumentless_call |
 	<<rightward_call method_tokens>>

private argumentless_call ::= <<method 'argumentless'>>

private named_unary_call ::= <<method named_unary_calee>> [<<call_arguments unary_expr>>]
private named_unary_calee ::= 'unary' | '-t'

private meta rightward_call ::= <<method <<x1>>>> [<<call_arguments parse_call_arguments>>]
private meta leftward_call ::= {<<method <<x1>>>>|code_primitive} default_parenthesised_call_arguments

//// fixme this should depend on prototype
private parse_call_arguments ::=
    anon_hash comma list_expr
    | parse_block [[comma] list_expr]
    | list_expr

private normal_method ::= <<method method_tokens>>
// the rest are fallback
private method_tokens ::= 'list' | 'unary' | 'argumentless' | [QUALIFYING_PACKAGE] SUB_NAME [PACKAGE] | 'method' | 'func' | 'finally' | 'try' | 'catch'


////////////////////////////////END OF CALLABLE ////////////////////////////////////////////////////////////////////////

label_declaration ::= <<parseLabelDeclaration>> // custom faster method
label_expr ::= IDENTIFIER|SUB_NAME
private perl_version ::= <<parsePerlVersion>>
private perl_handle ::=  perl_handle_expr | parse_block | scalar_variable !('{'|'['|<<isOperatorToken>>)
perl_handle_expr ::= HANDLE

//////////////////////////////////// constants /////////////////////////////////////////////////////////////////////////

tag_scalar ::= TAG

number_constant ::= NUMBER | NUMBER_VERSION | NUMBER_SIMPLE

private string ::= string_bare | string_sq | string_dq | string_xq | heredoc_opener

string_dq ::= [ 'qq'] quoted_qq_string
private quoted_qq_string ::= QUOTE_DOUBLE_OPEN [LP_STRING_QQ | qq_string_content ] QUOTE_DOUBLE_CLOSE {pin=1}
private qq_string_content ::= (STRING_CONTENT_QQ | interpolated_constructs)+

string_xq ::= [ 'qx'] quoted_xq_string
private quoted_xq_string ::= QUOTE_TICK_OPEN [LP_STRING_XQ | xq_string_content] QUOTE_TICK_CLOSE {pin=1}
private xq_string_content ::= (STRING_CONTENT_XQ | interpolated_constructs)+

private interpolated_constructs ::= deref_expr

string_bare ::= <<parseAndWrapStringContent>>

string_sq ::= [ 'q'] quoted_sq_string
string_list ::=  'qw' quoted_sq_string
private quoted_sq_string ::= QUOTE_SINGLE_OPEN [smart_sq_string_content] QUOTE_SINGLE_CLOSE {pin=1}
private smart_sq_string_content ::= <<isUseVars>> <<mapUseVars sq_string_content_element>>+ | sq_string_content
private sq_string_content ::= sq_string_content_element +
private sq_string_content_element ::= LP_STRING_Q |LP_STRING_QW|STRING_CONTENT

heredoc_opener ::= 'heredoc<<' ( '\\' string_bare | string ){pin=1}

///////////////////////////////////// variables ////////////////////////////////////////////////////////////////////////
private lexical_variable ::= scalar_variable | array_variable | hash_variable

array_index_variable ::= '$#' {SCALAR_NAME | '${' SCALAR_NAME '$}'}
scalar_variable ::= '$$' {SCALAR_NAME | '${' SCALAR_NAME '$}'}
array_variable ::= '$@' {ARRAY_NAME | '@{' ARRAY_NAME '@}'}
hash_variable ::= '$%' {HASH_NAME | '%{' HASH_NAME '%}'}
code_variable ::= '$&' {normal_method | '&{' normal_method '&}'}
glob_variable ::= '$*' {GLOB_NAME | '*{' GLOB_NAME '*}'}

private comma ::= ',' | '=>'


/********************************************** Extensions for Method::Signatures *************************************/
// we can make this smareter and use keywords from settings or import opitions; We can't pin here because MooseX method works othewise
method_definition ::= 'method' sub_names_token [method_signature] [sub_attributes] parse_block
func_definition ::= 'func' sub_names_token [func_signature] [sub_attributes] parse_block

// not sure that we need a wrapper for signatures
private method_signature ::= '(' method_signature_content ')' {pin=1}
method_signature_content ::= [method_signature_invocant] [variable_parenthesised_declaration_contents] {recoverWhile=recover_signature_content}
method_signature_invocant ::= <<scalarDeclarationWrapper>> ':'
private func_signature ::= '(' func_signature_content ')' {pin=1}
func_signature_content ::= [variable_parenthesised_declaration_contents] {recoverWhile=recover_signature_content}
private recover_signature_content ::= !(')'|'{')

/********************************************** Extensions for Moose **************************************************/

/******************************************* Annotations **************************************************************/
private annotation ::=
	annotation_abstract
	| annotation_deprecated
	| annotation_method
	| annotation_override
	| annotation_returns
	| annotation_type
	| annotation_inject
	| annotation_noinspection
	| '#@unknown'

annotation_abstract ::= '#@abstract' {pin=1}
annotation_deprecated ::= '#@deprecated' {pin=1}
annotation_method ::=  '#@method' {pin=1}
annotation_override ::=  '#@override' {pin=1}
annotation_returns ::=  '#@returns' any_package {pin=1}
annotation_type ::=  '#@type' any_package {pin=1}
annotation_inject ::=  '#@inject' string_bare {pin=1}
annotation_noinspection ::=  '#@noinspection' string_bare {pin=1}



/******************************************* End of annotations *******************************************************/

/*
 * Copyright 2015-2021 Alexandr Evstigneev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

buildscript {
  dependencies{
    classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.1'
    classpath 'org.apache.httpcomponents:httpmime:4.5.11'
    classpath 'org.eclipse.jgit:org.eclipse.jgit:5.5.1.201910021850-r'
  }
}

plugins {
  id "org.jetbrains.intellij" version "$intellijGradlePluginVersion"
  id 'jacoco'
  id 'org.jetbrains.grammarkit' version "$grammarKitGradlePluginVersion"
  id 'idea'
  id 'com.github.kt3k.coveralls' version "$coverallsGradlePluginVersion"
  id "org.sonarqube" version "$sonarQubeGradlePluginVersion"
}

repositories {
  mavenCentral()
}

def isCI = System.getenv("CI")

Set pluginProjectsNames = [
  "plugin",
  "lang.tt2",
  "lang.mojo",
  "lang.embedded",
  "lang.mason.framework",
  "lang.mason.htmlmason",
  "lang.mason.mason2"
]

def pluginProjects = allprojects.findAll {
  return pluginProjectsNames.contains(it.name)
}

allprojects {
  apply plugin: 'org.jetbrains.grammarkit'

  apply plugin: 'jacoco'

  apply plugin: 'java'
  sourceCompatibility = javaVersion
  targetCompatibility = javaTargetVersion
  tasks.withType(JavaCompile) { options.encoding = 'UTF-8' }

  project.ext {
    genRoot = project.file('gen')
  }

  sourceSets {
    main {
      java.srcDirs files(project.file('src'), project.genRoot)
      resources.srcDir project.file('resources')
    }
    test {
      java.srcDir project.file('test')
      resources.srcDirs project.file('testData')
    }
  }

  apply plugin: 'idea'
  idea {
    module {
      generatedSourceDirs += project.genRoot
    }
  }

  apply plugin: 'org.jetbrains.intellij'
  repositories {
    mavenCentral()
  }
  version = pluginBranch ? "${pluginVersion}${pluginBranch}${pluginBuild}" :
            "${pluginVersion}${platformBranch}${pluginBuild}"

  def isPlugin = pluginProjectsNames.contains(project.name)
  def isRoot = project == rootProject

  jar { onlyIf { isPlugin || isRoot } }
  buildPlugin { onlyIf { isPlugin } }
  prepareSandbox { onlyIf { isPlugin || isRoot } }
  prepareTestingSandbox { onlyIf { isPlugin } }
  patchPluginXml { onlyIf { isPlugin } }
  buildSearchableOptions { onlyIf { isPlugin } }
  publishPlugin{
    onlyIf {isPlugin}
    token = project.findProperty('jbToken') ?: ''
  }

  intellij {
    version.set("${platformVersion}${platformBranch}${platformBuild}")
    updateSinceUntilBuild.set(true)

    if (project.hasProperty('idea_sandbox')) {
      sandboxDirectory "${project.buildDir}/${project.idea_sandbox}"
    }
  }

  test {
    maxHeapSize = "2048m"

    outputs.upToDateWhen { false }
    if (project.hasProperty("overwrite")) {
      systemProperty "idea.tests.overwrite.data", "true"
    }

    if (project.hasProperty("youtrack.token")) {
      systemProperty "youtrack.token", project.getProperty("youtrack.token")
    }

    useJUnit {
      if (project.hasProperty("runtest")) {
        include '**/' + project.property('runtest') + '.class'
      }

      if (project.hasProperty("perf")) {
        includeCategories 'categories.Performance'
      }
      else {
        excludeCategories 'categories.Performance'
      }

      if (!project.hasProperty("includeHeavy")){
        excludeCategories 'categories.Heavy'
      }
    }
    testLogging {
      exceptionFormat = 'full'
      showStandardStreams = true
    }
    jacoco {
      enabled = isCI || project.hasProperty("with_coverage")
    }
    if( isCI ){
      testLogging {
        events 'passed', 'skipped', 'failed', 'standardOut', 'standardError'
        exceptionFormat "full"
      }
    }
  }

  it.afterEvaluate {
    coveralls.sourceDirs += it.sourceSets.main.java.srcDirs
  }
}

pluginProjects.forEach {
  def description = it.file(descriptionFile)
  def changes = it.file(changesFile)
  it.patchPluginXml {
    inputs.files(description, changes)
    pluginDescription.set(description.text)
    changeNotes.set(changes.text)
  }

  def projectModules = it.subprojects
  it.jar {
    from projectModules.sourceSets.main.output
  }
}

apply plugin: 'idea'
idea {
  project {
    jdkName = javaVersion
    languageLevel = javaVersion
  }
}

task jacocoMerge(type: JacocoMerge) {
  dependsOn(allprojects.jacocoTestReport.dependsOn)
  mustRunAfter(allprojects.jacocoTestReport.mustRunAfter)
  destinationFile = file("${buildDir}/jacoco/test.exec")
  executionData = files(allprojects.jacocoTestReport.executionData)
    .filter { f -> f.exists() }
}

task jacocoRootReport(type: JacocoReport, group: 'Coverage reports') {
  description = 'Generates an aggregate report from all projects'
  dependsOn jacocoMerge

  additionalSourceDirs.setFrom files(allprojects.sourceSets.main.allSource.srcDirs)
  sourceDirectories.setFrom files(allprojects.sourceSets.main.allSource.srcDirs)
  classDirectories.setFrom files(allprojects.sourceSets.main.output)
  executionData jacocoMerge.destinationFile

  reports {
    html.enabled = true // human readable
    xml.enabled = true // required by coveralls
    csv.enabled = false
  }
}

def coverageReportFile = "$buildDir/reports/jacoco/jacocoRootReport/jacocoRootReport.xml"
apply plugin: 'org.sonarqube'
sonarqube {
  properties {
    property "sonar.projectKey", "Camelcade_Perl5-IDEA"
    property "sonar.organization", "camelcade"
    property "sonar.host.url", "https://sonarcloud.io"
    property 'sonar.coverage.jacoco.xmlReportPaths', coverageReportFile
  }
}
tasks.sonarqube {
  dependsOn jacocoRootReport
}

apply plugin: 'com.github.kt3k.coveralls'
coveralls {
  jacocoReportPath = coverageReportFile
}

tasks.coveralls {
  group = 'Coverage reports'
  description = 'Uploads the aggregated coverage report to Coveralls'
  dependsOn jacocoRootReport
}

intellij {
  def pluginList = [intelliLangPlugin,
                    project(':plugin'),
                    project(':lang.tt2'),
                    project(':lang.mojo'),
                    project(':lang.embedded'),
                    project(':lang.mason.framework'),
                    project(':lang.mason.htmlmason'),
                    project(':lang.mason.mason2'),
  ]

  if(!isCI){
    pluginList.add("PsiViewer:$psiViewerVersion")
  }

  def runWith = project.hasProperty("runWith") ? project.property("runWith") : ""

  if( runWith == 'CL') {
    type.set('CL')
    version.set(clionVersion)
  }
  else if( runWith == 'PC') {
    type.set('PC')
    version.set(pycharmVersion)
  }
  else if( runWith == 'PY') {
    type.set('PY')
    version.set(pycharmVersion)
    pluginList.addAll(['Docker', 'remote-run'])
  }
  else{
    type.set('IU')
    pluginList.addAll(['coverage', 'Docker', 'remote-run'])
  }
  if (project.hasProperty('idea_path')) {
    alternativeIdePath = project.idea_path
  }

  plugins = pluginList
}

runIde {
  project.properties.each{ key, val ->
    if( key.startsWith("pass.")){
      def passedKey = key.substring(5)
      println("Passing $passedKey => $val")
      systemProperty(passedKey, val)
    }
  }
  if (project.hasProperty("traverseUI")) {
    args("traverseUI", "$project.rootDir.canonicalPath/resources/search/searchableOptions.xml")
  }
  jvmArgs("-Xmx2048m")
}

task publishAllPlugins {
  pluginProjects.each { dependsOn("${it.name}:publishPlugin") }
}

/*
 * Copyright 2015-2021 Alexandr Evstigneev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

buildscript {
  dependencies{
    classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.1'
    classpath 'org.apache.httpcomponents:httpmime:4.5.11'
    classpath 'org.eclipse.jgit:org.eclipse.jgit:5.5.1.201910021850-r'
  }
}

plugins {
  id "org.jetbrains.intellij" version "$intellijGradlePluginVersion"
  id 'jacoco'
  id 'org.jetbrains.grammarkit' version "$grammarKitGradlePluginVersion"
  id 'idea'
  id 'com.github.kt3k.coveralls' version "$coverallsGradlePluginVersion"
  id "org.sonarqube" version "$sonarQubeGradlePluginVersion"
}

repositories {
  mavenCentral()
}

def isCI = System.getenv("CI")
def withCoverage = Boolean.valueOf(System.getenv('WITH_COVERAGE')) || project.hasProperty("with_coverage")

Set pluginProjectsNames = [
  "plugin",
  "lang.tt2",
  "lang.mojo",
  "lang.embedded",
  "lang.mason.framework",
  "lang.mason.htmlmason",
  "lang.mason.mason2"
]

def pluginProjects = allprojects.findAll {
  return pluginProjectsNames.contains(it.name)
}

allprojects {
  apply plugin: 'org.jetbrains.grammarkit'

  apply plugin: 'jacoco'

  apply plugin: 'java'
  sourceCompatibility = javaVersion
  targetCompatibility = javaTargetVersion
  tasks.withType(JavaCompile) { options.encoding = 'UTF-8' }

  project.ext {
    genRoot = project.file('src/main/gen')
  }

  sourceSets {
    main {
      java.srcDirs += project.genRoot
    }
  }

  apply plugin: 'idea'
  idea {
    module {
      generatedSourceDirs += project.genRoot
    }
  }

  apply plugin: 'org.jetbrains.intellij'
  repositories {
    mavenCentral()
  }
  version = pluginBranch ? "${pluginVersion}${pluginBranch}${pluginBuild}" :
            "${pluginVersion}${platformBranch}${pluginBuild}"

  def isPlugin = pluginProjectsNames.contains(project.name)
  def isRoot = project == rootProject

  jar { onlyIf { isPlugin || isRoot } }
  buildPlugin { onlyIf { isPlugin } }
  prepareSandbox { onlyIf { isPlugin || isRoot } }
  prepareTestingSandbox { onlyIf { isPlugin } }
  patchPluginXml { onlyIf { isPlugin } }
  buildSearchableOptions { onlyIf { isPlugin } }
  publishPlugin {
    onlyIf { isPlugin }
    if (project.hasProperty('eap')) {
      channels = ['EAP']
    }
    token = project.findProperty('jbToken') ?: ''
  }
  verifyPlugin {
    onlyIf { isPlugin }
  }

  intellij {
    version.set("${platformVersion}${platformBranch}${platformBuild}")
    updateSinceUntilBuild.set(true)

    if (project.hasProperty('idea_sandbox')) {
      sandboxDirectory "${project.buildDir}/${project.idea_sandbox}"
    }
  }

  test {
    maxHeapSize = "2048m"

    outputs.upToDateWhen { false }
    if (project.hasProperty("overwrite")) {
      systemProperty "idea.tests.overwrite.data", "true"
    }

    if (project.hasProperty("youtrack.token")) {
      systemProperty "youtrack.token", project.getProperty("youtrack.token")
    }

    def envPerlVersion = System.getenv("PERL_TEST_VERSION")
    systemProperty("perl.test.version", envPerlVersion != null ? envPerlVersion: project.getProperty("perl.test.version"))

    if (project.hasProperty("idea.split.test.logs")) {
      systemProperty "idea.split.test.logs", "true"
      systemProperty "idea.single.test.log.max.length", "100_000_000"
    }

    useJUnit {
      if (project.hasProperty("runtest")) {
        include '**/' + project.property('runtest') + '.class'
      }

      if (!project.hasProperty("includeHeavy")){
        excludeCategories 'categories.Heavy'
      }
    }
    testLogging {
      exceptionFormat = 'full'
      showStandardStreams = true
    }
    jacoco {
      enabled = withCoverage
      includeNoLocationClasses = true
      jacoco.excludes = ['jdk.internal.*']
    }
    if( isCI ){
      testLogging {
        events 'passed', 'skipped', 'failed', 'standardOut', 'standardError'
        exceptionFormat "full"
      }
    }
  }

  it.afterEvaluate {
    coveralls.sourceDirs += it.sourceSets.main.java.srcDirs
  }
}

pluginProjects.forEach {
  def description = it.file(descriptionFile)
  def changes = it.file(changesFile)
  it.patchPluginXml {
    inputs.files(description, changes)
    pluginDescription.set(description.text)
    changeNotes.set(changes.text)
  }

  def projectModules = it.subprojects
  it.jar {
    from projectModules.sourceSets.main.output
  }
}

apply plugin: 'idea'
idea {
  project {
    jdkName = javaVersion
    languageLevel = javaVersion
  }
}

tasks.register('jacocoRootReport', JacocoReport) {
  group = 'verification'
  description = 'Generates an aggregate report from all projects'

  dependsOn(allprojects.jacocoTestReport.dependsOn)
  mustRunAfter(allprojects.jacocoTestReport.mustRunAfter)
  executionData(files(allprojects.jacocoTestReport.executionData).filter { f -> f.exists() })

  additionalSourceDirs.setFrom files(allprojects.sourceSets.main.allSource.srcDirs)
  sourceDirectories.setFrom files(allprojects.sourceSets.main.allSource.srcDirs)
  classDirectories.setFrom files(allprojects.sourceSets.main.output)

  reports {
    html.getRequired().set(true) // human readable
    xml.getRequired().set(true) // required by coveralls
    csv.getRequired().set(false)
  }
}

def coverageReportFile = "$buildDir/reports/jacoco/jacocoRootReport/jacocoRootReport.xml"
apply plugin: 'org.sonarqube'
sonarqube {
  properties {
    property "sonar.projectKey", "Camelcade_Perl5-IDEA"
    property "sonar.organization", "camelcade"
    property "sonar.host.url", "https://sonarcloud.io"
    property 'sonar.coverage.jacoco.xmlReportPaths', coverageReportFile
  }
}

apply plugin: 'com.github.kt3k.coveralls'
coveralls {
  jacocoReportPath = coverageReportFile
}

tasks.coveralls {
  group = 'verification'
  description = 'Uploads the aggregated coverage report to Coveralls'
  dependsOn jacocoRootReport
}

intellij {
  def pluginList = [intelliLangPlugin,
                    project(':plugin'),
                    project(':lang.tt2'),
                    project(':lang.mojo'),
                    project(':lang.embedded'),
                    project(':lang.mason.framework'),
                    project(':lang.mason.htmlmason'),
                    project(':lang.mason.mason2'),
  ]

  if(!isCI){
    pluginList.add("PsiViewer:$psiViewerVersion")
  }

  def runWith = project.hasProperty("runWith") ? project.property("runWith") : ""

  if( runWith == 'CL') {
    type.set('CL')
    version.set(clionVersion)
  }
  else if( runWith == 'PC') {
    type.set('PC')
    version.set(pycharmVersion)
  }
  else if( runWith == 'PY') {
    type.set('PY')
    version.set(pycharmVersion)
    pluginList.addAll(['Docker', remoteRunPlugin])
  }
  else{
    type.set('IU')
    pluginList.addAll([coveragePlugin, 'Docker', remoteRunPlugin])
  }
  if (project.hasProperty('idea_path')) {
    alternativeIdePath = project.idea_path
  }

  plugins = pluginList
}

runIde {
  project.properties.each{ key, val ->
    if( key.startsWith("pass.")){
      def passedKey = key.substring(5)
      println("Passing $passedKey => $val")
      systemProperty(passedKey, val)
    }
  }
  if (project.hasProperty("traverseUI")) {
    args("traverseUI", "$project.rootDir.canonicalPath/resources/search/searchableOptions.xml")
  }
  jvmArgs("-Xmx2048m")
}

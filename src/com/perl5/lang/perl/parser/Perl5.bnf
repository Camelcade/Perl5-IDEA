/*
Copyright 2015 Alexandr Evstigneev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
{
  parserClass="com.perl5.lang.perl.parser.PerlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="PsiPerl"
  psiImplClassSuffix="Impl"
  psiPackage="com.perl5.lang.perl.psi"
  psiImplPackage="com.perl5.lang.perl.psi.impl"

  elementTypeHolderClass="com.perl5.lang.perl.lexer.PerlElementTypes"

  tokenTypeClass="com.perl5.lang.perl.PerlTokenType"
  elementTypeClass="com.perl5.lang.perl.PerlElementType"

  elementTypeFactory="com.perl5.lang.perl.parser.PerlElementTypeFactory.getElementType"
  tokenTypeFactory="com.perl5.lang.perl.parser.PerlElementTypeFactory.getTokenType"

  parserUtilClass="com.perl5.lang.perl.parser.PerlParserUtil"
  psiImplUtilClass="com.perl5.lang.perl.psi.utils.PerlPsiImplUtil"

  tokens=[
    COMMENT_LINE="COMMENT_LINE"
    COMMENT_BLOCK="COMMENT_BLOCK"
    POD="PERL_POD"

    SIGIL_ARRAY="SIGIL_ARRAY"
    SIGIL_SCALAR="SIGIL_SCALAR"
    SIGIL_SCALAR_INDEX="SIGIL_SCALAR_INDEX"

    // synthetic sigils
    SIGIL_GLOB="SIGIL_GLOB"
    SIGIL_HASH="SIGIL_HASH"
    SIGIL_CODE="SIGIL_CODE"

    ANNOTATION_PREFIX="ANNOTATION_PREFIX"

    ANNOTATION_UNKNOWN_KEY="ANNOTATION_UNKNOWN"
    ANNOTATION_DEPRECATED_KEY="ANNOTATION_DEPRECATED"
    ANNOTATION_RETURNS_KEY="ANNOTATION_RETURNS"
    ANNOTATION_OVERRIDE_KEY="ANNOTATION_OVERRIDE"
    ANNOTATION_METHOD_KEY="ANNOTATION_METHOD"
    ANNOTATION_ABSTRACT_KEY="ANNOTATION_ABSTRACT"

    // generated tokens
    VARIABLE_NAME="VARIABLE_NAME"
    SUB="SUB"

    HEREDOC="HEREDOC"
    HEREDOC_QQ="HEREDOC_QQ"
    HEREDOC_QX="HEREDOC_QX"
    HEREDOC_END="HEREDOC_END"
    HEREDOC_PSEUDO_QUOTE="HEREDOC_PSEUDO_QUOTE"

    FORMAT="FORMAT"
    FORMAT_TERMINATOR="."

    VERSION_ELEMENT="VERSION_ELEMENT"

    NUMBER_VERSION="NUMBER_VERSION"
    NUMBER="NUMBER"
    NUMBER_SIMPLE="NUMBER_SIMPLE"

    RESERVED_IF="if"
    RESERVED_UNLESS="unless"
    RESERVED_ELSIF="elsif"
    RESERVED_ELSE="else"
    RESERVED_GIVEN="given"
    RESERVED_WHILE="while"
    RESERVED_UNTIL="until"
    RESERVED_FOR="for"
    RESERVED_FOREACH="foreach"
    RESERVED_CONTINUE="continue"
    RESERVED_WHEN="when"
    RESERVED_DEFAULT="default"

    RESERVED_FORMAT="format"
    RESERVED_SUB="sub"
    RESERVED_PACKAGE="package"
    RESERVED_USE="use"
    RESERVED_NO="no"
    RESERVED_REQUIRE="require"

    RESERVED_PRINT="print"
    RESERVED_PRINTF="printf"
    RESERVED_SAY="say"

    RESERVED_MAP="map"
    RESERVED_GREP="grep"
    RESERVED_SORT="sort"

    RESERVED_UNDEF="undef"

    RESERVED_QW="qw"

    RESERVED_QQ="qq"
    RESERVED_Q="q"
    RESERVED_QX="qx"

    RESERVED_TR="tr"
    RESERVED_Y="y"

    RESERVED_S="s"
    RESERVED_QR="qr"
    RESERVED_M="m"

    RESERVED_MY="my"
    RESERVED_OUR="our"
    RESERVED_STATE="state"
    RESERVED_LOCAL="local"

    RESERVED_DO="do"
    RESERVED_EVAL="eval"

    RESERVED_GOTO="goto"
    RESERVED_REDO="redo"
    RESERVED_NEXT="next"
    RESERVED_LAST="last"

	RESERVED_RETURN="return"

	RESERVED_METHOD="method"
	RESERVED_FUNC="func"

    // Operators

    OPERATOR_X="x"

    OPERATOR_CMP_NUMERIC="<=>"
    OPERATOR_LT_NUMERIC="<"
    OPERATOR_GT_NUMERIC=">"

    OPERATOR_DEREFERENCE="->"
    OPERATOR_COMMA_ARROW="=>"
    OPERATOR_COMMA=","

    OPERATOR_HELLIP="..."
    OPERATOR_FLIP_FLOP=".."
    OPERATOR_CONCAT="."

    OPERATOR_PLUS_PLUS="++"
    OPERATOR_MINUS_MINUS="--"
    OPERATOR_POW="**"

    OPERATOR_RE="=~"
    OPERATOR_NOT_RE="!~"

    OPERATOR_HEREDOC="<<"
    OPERATOR_SHIFT_LEFT="<<"
    OPERATOR_SHIFT_RIGHT=">>"

    OPERATOR_AND="&&"
    OPERATOR_OR="||"
    OPERATOR_OR_DEFINED="//"
    OPERATOR_NOT="!"

    OPERATOR_ASSIGN="="

    QUESTION="?"
    COLON=":"

    OPERATOR_REFERENCE="\\"

    OPERATOR_DIV="/"
    OPERATOR_MUL="*"
    OPERATOR_MOD="%"

    OPERATOR_PLUS="+"
    OPERATOR_PLUS_UNARY="PLUS_UNARY"

    OPERATOR_MINUS="-"
    OPERATOR_MINUS_UNARY="MINUS_UNARY"

    OPERATOR_BITWISE_NOT="~"
    OPERATOR_BITWISE_AND="&"
    OPERATOR_BITWISE_OR="|"
    OPERATOR_BITWISE_XOR="^"

    OPERATOR_AND_LP="and"
    OPERATOR_OR_LP="or"
    OPERATOR_XOR_LP="xor"
    OPERATOR_NOT_LP="not"

    OPERATOR_LT_STR="lt"
    OPERATOR_GT_STR="gt"
    OPERATOR_LE_STR="le"
    OPERATOR_GE_STR="ge"
    OPERATOR_CMP_STR="cmp"
    OPERATOR_EQ_STR="eq"
    OPERATOR_NE_STR="ne"

    // synthetic tokens
    OPERATOR_POW_ASSIGN="**="
    OPERATOR_PLUS_ASSIGN="+="
    OPERATOR_MINUS_ASSIGN="-="
    OPERATOR_MUL_ASSIGN="*="
    OPERATOR_DIV_ASSIGN="/="
    OPERATOR_MOD_ASSIGN="%="
    OPERATOR_CONCAT_ASSIGN=".="
    OPERATOR_X_ASSIGN="x="
    OPERATOR_BITWISE_AND_ASSIGN="&="
    OPERATOR_BITWISE_OR_ASSIGN="|="
    OPERATOR_BITWISE_XOR_ASSIGN="^="
    OPERATOR_SHIFT_LEFT_ASSIGN="<<="
    OPERATOR_SHIFT_RIGHT_ASSIGN=">>="
    OPERATOR_AND_ASSIGN="&&="
    OPERATOR_OR_ASSIGN="||="
    OPERATOR_OR_DEFINED_ASSIGN="//="

    OPERATOR_GE_NUMERIC=">="
    OPERATOR_LE_NUMERIC="<="
    OPERATOR_EQ_NUMERIC="=="
    OPERATOR_NE_NUMERIC="!="
    OPERATOR_SMARTMATCH="~~"
// end of synthetic operators

    OPERATOR_FILETEST="OPERATOR_FILETEST"

    // single mid-quote. e evaluatable s///e;
    REGEX_QUOTE="REGEX_QUOTE"
    REGEX_QUOTE_E="REGEX_QUOTE_E"

    // paired mid-quote. e for evaluatable s{}{}e;
    REGEX_QUOTE_OPEN="REGEX_QUOTE_OPEN"
    REGEX_QUOTE_OPEN_X="REGEX_QUOTE_OPEN_X" // extended regex, spaces and newlines must be escaped
    REGEX_QUOTE_OPEN_E="REGEX_QUOTE_OPEN_E" // block should be interpolated as a perl script

    REGEX_QUOTE_CLOSE="REGEX_QUOTE_CLOSE"

    REGEX_MODIFIER="REGEX_MODIFIER"
    REGEX_TOKEN="REGEX_TOKEN"

    STRING_CONTENT="STRING_CONTENT"   // moved to stub

    PARSABLE_STRING_USE_VARS = "PARSABLE_STRING_USE_VARS"

    TAG="TAG"

    LEFT_ANGLE='LEFT_ANGLE'
    RIGHT_ANGLE='RIGHT_ANGLE'

    LEFT_BRACKET='LEFT_BRACKET'
    RIGHT_BRACKET='RIGHT_BRACKET'

    LEFT_PAREN="LEFT_PAREN"
    RIGHT_PAREN="RIGHT_PAREN"

    LEFT_BRACE='LEFT_BRACE'
    RIGHT_BRACE='RIGHT_BRACE'

    SEMICOLON=";";

    QUOTE_DOUBLE="QUOTE_DOUBLE"
    QUOTE_DOUBLE_OPEN="QUOTE_DOUBLE_OPEN"
    QUOTE_DOUBLE_CLOSE="QUOTE_DOUBLE_CLOSE"

    QUOTE_SINGLE="QUOTE_SINGLE"
    QUOTE_SINGLE_OPEN="QUOTE_SINGLE_OPEN"
    QUOTE_SINGLE_CLOSE="QUOTE_SINGLE_CLOSE"

    QUOTE_TICK="QUOTE_TICK"
    QUOTE_TICK_OPEN="QUOTE_TICK_OPEN"
    QUOTE_TICK_CLOSE="QUOTE_TICK_CLOSE"

    // custom tokens
    IDENTIFIER="IDENTIFIER"
    PACKAGE_IDENTIFIER="PACKAGE_IDENTIFIER"
    PACKAGE_CORE_IDENTIFIER="PACKAGE_CORE_IDENTIFIER"

    SUB_PROTOTYPE_TOKEN="SUB_PROTOTYPE_TOKEN"

    PACKAGE="PACKAGE"
    PACKAGE_PRAGMA_CONSTANT="PACKAGE_PRAGMA_CONSTANT"
    PACKAGE_PRAGMA_VARS="PACKAGE_PRAGMA_VARS"

    HANDLE="HANDLE"
    BLOCK_NAME="BLOCK_NAME"
    LABEL="LABEL"

    // inline HTML support
    EMBED_MARKER="EMBED_MARKER"
    EMBED_MARKER_OPEN="EMBED_MARKER_OPEN"   // for braces match
    EMBED_MARKER_CLOSE="EMBED_MARKER_CLOSE" // for braces match
    EMBED_MARKER_SEMICOLON="EMBED_MARKER_SEMICOLON" // this is for implicit semicolon in Mojolicious
    TEMPLATE_BLOCK_HTML="TEMPLATE_BLOCK_HTML"
  ]

    extends(".*expr")=expr
    name(".*expr")="expression"

	implements(".+_cast_expr")="com.perl5.lang.perl.psi.PerlCastExpression"
	mixin(".+_cast_expr")="com.perl5.lang.perl.psi.mixins.PerlCastExpressionMixin"

	extends(".*statement_modifier")=statement_modifier

	extends(".*_signature_content")=sub_signature_content

    extends("heredoc_opener|anon_array|anon_hash|anon_sub")=expr
    extends("string_list|number_constant")=expr
    extends("replacement_regex|compile_regex|match_regex|tr_regex")=expr

    extends("anon_array_element|heredoc_opener|tag_scalar")=expr

    extends("string_sq|string_dq|string_xq|string_bare")=expr
    implements("string_sq|string_dq|string_xq|string_bare")="com.perl5.lang.perl.psi.PerlString"
    mixin("string_sq|string_dq|string_xq")="com.perl5.lang.perl.psi.mixins.PerlStringImplMixin"
    mixin("string_bare")="com.perl5.lang.perl.psi.mixins.PerlStringBareImplMixin"

    implements("constant_name")="com.perl5.lang.perl.psi.PerlConstant"
    mixin("constant_name")="com.perl5.lang.perl.psi.mixins.PerlConstantImplMixin"
    stubClass("constant_name")="com.perl5.lang.perl.idea.stubs.subsdefinitions.constants.PerlConstantStub"

    extends("nested_call")=sub_call_expr

    implements("nested_call|sub_call_expr|named_list_expr|unary_list_expr")="com.perl5.lang.perl.psi.PerlMethodContainer"
	mixin("named_list_expr")="com.perl5.lang.perl.psi.mixins.PerlMethodContainerMixIn"

    extends("annotation_.*")=annotation
    implements("annotation_returns.*")="com.perl5.lang.perl.psi.properties.PerlNamespaceElementContainer"
    methods("annotation_returns.*")=[getNamespaceElement]

    mixin("use_statement")="com.perl5.lang.perl.psi.mixins.PerlUseStatementImplMixin"
    implements("use_statement")="com.perl5.lang.perl.psi.PerlUseStatement"
    stubClass("use_statement")="com.perl5.lang.perl.idea.stubs.imports.PerlUseStatementStub"

    implements("constant_definition")="com.perl5.lang.perl.psi.IPerlConstantDefinition"
    mixin("constant_definition")="com.perl5.lang.perl.psi.mixins.PerlConstantDefinitionMixin"

    extends("use_statement.*")=statement
    extends("no_statement")=statement
    extends("condition_statement|condition_statement_while|for_list_statement|for_iterator_statement")=statement

    implements("conditional_block_while|block|.*_compound")="com.perl5.lang.perl.psi.properties.PerlLexicalScope";
    mixin("conditional_block_while|block|.*_compound")="com.perl5.lang.perl.psi.mixins.PerlLexicalScopeMemberMixin"

    implements("heredoc_opener")="com.perl5.lang.perl.psi.PerlHeredocOpener"
    mixin("heredoc_opener")="com.perl5.lang.perl.psi.mixins.PerlHeredocOpenerMixin"

    implements("deref_expr")="com.perl5.lang.perl.psi.PerlDerefExpression"
    mixin("deref_expr")="com.perl5.lang.perl.psi.mixins.PerlDerefExpressionMixin"

    extends("use_vars_statement")=statement
    implements("use_vars_statement")="com.perl5.lang.perl.psi.IPerlUseVars"
    mixin("use_vars_statement")="com.perl5.lang.perl.psi.mixins.PerlUseVarsMixin"

    extends("variable_declaration_global|variable_declaration_lexical|variable_declaration_local")=expr
    implements("variable_declaration_lexical|variable_declaration_local|variable_declaration_global")="com.perl5.lang.perl.psi.PerlVariableDeclaration"
    mixin("variable_declaration_lexical|variable_declaration_local|variable_declaration_global")="com.perl5.lang.perl.psi.mixins.PerlVariableDeclarationMixin"

    extends("code_variable")=expr

    extends("array_array_slice|array_hash_slice|scalar_array_element|scalar_hash_element")=expr

    stubClass("variable_declaration_wrapper")="com.perl5.lang.perl.idea.stubs.variables.PerlVariableStub"
    mixin("variable_declaration_wrapper")="com.perl5.lang.perl.psi.mixins.PerlVariableDeclarationWrapperMixin"
    implements("variable_declaration_wrapper")="com.perl5.lang.perl.psi.PerlVariableDeclarationWrapper"

    extends("array_index_variable|scalar_variable|array_variable|hash_variable|glob_variable")=expr
    mixin("code_variable|scalar_variable|array_variable|hash_variable|array_index_variable")="com.perl5.lang.perl.psi.mixins.PerlVariableImplMixin"
    implements("code_variable|scalar_variable|array_variable|hash_variable|array_index_variable")="com.perl5.lang.perl.psi.PerlVariable"


    stubClass("namespace_definition")="com.perl5.lang.perl.idea.stubs.namespaces.PerlNamespaceDefinitionStub"
    mixin("namespace_definition")="com.perl5.lang.perl.psi.mixins.PerlNamespaceDefinitionImplMixin"
    implements("namespace_definition")="com.perl5.lang.perl.psi.PerlNamespaceDefinition"

    stubClass("method_definition")="com.perl5.lang.perl.idea.stubs.subsdefinitions.method.PerlMethodDefinitionStub"
    mixin("method_definition")="com.perl5.lang.perl.psi.mixins.PerlMethodDefinitionImplMixin"
    implements("method_definition")="com.perl5.lang.perl.psi.PerlMethodDefinition"

    stubClass("func_definition")="com.perl5.lang.perl.idea.stubs.subsdefinitions.func.PerlFuncDefinitionStub"
    mixin("func_definition")="com.perl5.lang.perl.psi.mixins.PerlFuncDefinitionImplMixin"
    implements("func_definition")="com.perl5.lang.perl.psi.PerlFuncDefinition"

    stubClass("sub_definition")="com.perl5.lang.perl.idea.stubs.subsdefinitions.PerlSubDefinitionStub"
    mixin("sub_definition")="com.perl5.lang.perl.psi.mixins.PerlSubDefinitionImplMixin"
    implements("sub_definition")="com.perl5.lang.perl.psi.PerlSubDefinition"

    stubClass("sub_declaration")="com.perl5.lang.perl.idea.stubs.subsdeclarations.PerlSubDeclarationStub"
    mixin("sub_declaration")="com.perl5.lang.perl.psi.mixins.PerlSubDeclarationImplMixin"
    implements("sub_declaration")="com.perl5.lang.perl.psi.PerlSubDeclaration"

    stubClass("glob_variable")="com.perl5.lang.perl.idea.stubs.globs.PerlGlobStub"
    mixin("glob_variable")="com.perl5.lang.perl.psi.mixins.PerlGlobVariableImplMixin"
    implements("glob_variable")="com.perl5.lang.perl.psi.PerlGlobVariable"

    mixin("require_expr")="com.perl5.lang.perl.psi.mixins.PerlRequireExprImplMixin"
    implements("require_expr")="com.perl5.lang.perl.psi.PerlRequireExpr"
    stubClass("require_expr")="com.perl5.lang.perl.idea.stubs.imports.runtime.PerlRuntimeImportStub"

    mixin("do_expr")="com.perl5.lang.perl.psi.mixins.PerlDoExprImplMixin"
    implements("do_expr")="com.perl5.lang.perl.psi.PerlDoExpr"
    stubClass("do_expr")="com.perl5.lang.perl.idea.stubs.imports.runtime.PerlRuntimeImportStub"

    mixin("method")="com.perl5.lang.perl.psi.mixins.PerlMethodImplMixin";
    implements("method")="com.perl5.lang.perl.psi.PerlMethod";
 }

///////////////////////////// main code structure //////////////////////////////////////////////////////////////////////
root ::= file_item *

private file_item ::= !<<eof>> {semicolon_any | <<parseHeredocContent>> | namespace_definition | namespace_item }

namespace_definition ::= namespace_definition_name (block | semicolon_any namespace_content)
private namespace_definition_name ::= [namespace_annotations] [PACKAGE_CORE_IDENTIFIER] RESERVED_PACKAGE <<mergePackageName>> [perl_version] {pin=3 recoverWhile=recover_namespace_definition}
private namespace_annotations ::= annotation_deprecated
private recover_namespace_definition ::= !(semicolon_any | LEFT_BRACE)
namespace_content ::= namespace_item *  {extends=block recoverWhile=recover_namespace}

// todo count opening braces
private recover_namespace ::= !( [PACKAGE_CORE_IDENTIFIER] RESERVED_PACKAGE | RIGHT_BRACE )

block ::= LEFT_BRACE block_content RIGHT_BRACE {pin=1} // !OPERATOR_DEREFERENCE  pin disabled for dereference of anon hash; probably this slows us down
private block_content ::= file_item * {recoverWhile=recover_block}
private recover_block ::= !(RIGHT_BRACE)

private namespace_item ::=
    [label_declaration] (
        semicolon_any +
        | nyi_statement
        | <<parseParserExtensions>>
        | compound_statement
        | format_definition
        | statement
        | block_compound  // put it after statement to handle anon hashes before it.
        | annotation
		| POD
		| <<parseBadCharacters>> // Fallback for bad characters
     )

nyi_statement ::= OPERATOR_HELLIP
format_definition ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_FORMAT [IDENTIFIER] OPERATOR_ASSIGN [FORMAT] FORMAT_TERMINATOR {pin=2}

private compound_statement ::=
    sub_definition
    | named_block
    | if_compound
    | unless_compound
    | given_compound
    | while_compound
    | until_compound
    | for_compound
    | foreach_compound
    | when_compound
    | default_compound

named_block ::= BLOCK_NAME block

if_compound ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_IF conditional_block if_compound_elsif * [if_compound_else]  {pin=2}
unless_compound ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_UNLESS conditional_block if_compound_elsif * [if_compound_else]  {pin=2}
private if_compound_elsif ::= [POD] [PACKAGE_CORE_IDENTIFIER] RESERVED_ELSIF conditional_block  {pin=3}
private if_compound_else ::= [POD] [PACKAGE_CORE_IDENTIFIER] RESERVED_ELSE unconditional_block {pin=3}
unconditional_block ::= block

conditional_block ::= condition_statement block {pin=1 name="Conditional block"}
condition_statement ::= LEFT_PAREN condition_statement_expr RIGHT_PAREN {pin=1 name="Condition"}

conditional_block_while ::= condition_statement_while block {pin=1 name="Conditional block"}
condition_statement_while ::= LEFT_PAREN [condition_statement_expr] RIGHT_PAREN {pin=1 name="Condition"}
private condition_statement_expr ::= expr {recoverWhile=recover_condition_statement_expr}
private recover_condition_statement_expr ::= !(LEFT_BRACE|RIGHT_PAREN)

given_compound ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_GIVEN conditional_block  {pin=2}
when_compound ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_WHEN conditional_block  {pin=2}
default_compound ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_DEFAULT block {pin=2}

while_compound ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_WHILE conditional_block_while [continue_block]  {pin=2}
until_compound ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_UNTIL conditional_block [continue_block]  {pin=2}

continue_block ::= [POD] [PACKAGE_CORE_IDENTIFIER] RESERVED_CONTINUE block {pin=3}

private block_compound ::= block [continue_block]


// for/foreach
// fixme why the heck there is no parsing error on "for" and there is a error on "use", both pinned
for_compound ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_FOR for_arguments {pin=2}
foreach_compound ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_FOREACH for_arguments  {pin=2}
private for_arguments ::=
    for_iterator block
    | for_list_statement block_compound

for_iterator ::= LEFT_PAREN [for_iterator_statement]  SEMICOLON [for_iterator_statement] SEMICOLON [for_iterator_statement] RIGHT_PAREN {pin=3}
for_iterator_statement ::= expr {recoverWhile=recover_parenthesised}

// @todo only single variable or variable definition may be here
for_list_statement ::= [ variable_declaration | variable ] for_list_epxr
for_list_epxr ::= LEFT_PAREN for_list_expr_content RIGHT_PAREN {pin=1}
private for_list_expr_content ::= list_expr {recoverWhile=recover_parenthesised}


statement ::= statement_body <<statementSemi>>
private statement_body ::=
    use_statements
    | no_statements
    | sub_declaration
    | normal_statement
    {recoverWhile=recover_statement}

private normal_statement ::= expr [<<parseStatementModifier>>] {pin=1}
//private normal_statement_body ::= expr {recoverWhile=recover_statement}

// fixme we can't pin this because we need to distinct declaration and definition
sub_definition ::= [annotations] [PACKAGE_CORE_IDENTIFIER] RESERVED_SUB canonical_sub_name sub_definition_parameters block

private sub_definition_parameters ::= [sub_prototype_or_signature] [sub_attributes]
private sub_prototype_or_signature ::= sub_signature |sub_prototype

sub_declaration ::= [annotations] [PACKAGE_CORE_IDENTIFIER] RESERVED_SUB canonical_sub_name sub_declaration_parameters
private sub_declaration_parameters ::= [sub_prototype] [sub_attributes]

private canonical_sub_name ::= [namespace_canonical] sub_definition_name

private sub_definition_name ::= <<parseSubDefinitionName>>

// todo implement parsing
private sub_prototype ::= LEFT_PAREN [sub_prototype_content] RIGHT_PAREN {pin=1}
private sub_prototype_content ::= <<parseSubPrototype>>

/************************************* Sub signatures *****************************************************************/
private sub_signature ::= LEFT_PAREN sub_signature_content RIGHT_PAREN //{pin=1} pinning is temporary disabled in favor of protos
sub_signature_content ::=
	<<cancelProtoLikeSignature>>
	{
		sub_signature_element (OPERATOR_COMMA sub_signature_element)* [OPERATOR_COMMA sub_signature_element_slurpy]
		| [sub_signature_element_slurpy]
	}
//	{recoverWhile=recover_signature_content}
private sub_signature_element ::= sub_signature_element_ignore	| sub_signature_scalar
private sub_signature_element_slurpy ::= <<arrayDeclarationWrapper>> | <<hashDeclarationWrapper>>

// fixme this is side-effect of detecting var names in lexer
sub_signature_element_ignore ::= SIGIL_SCALAR [<<checkAssignIdentifier>> [scalar_expr]] &(OPERATOR_COMMA|RIGHT_PAREN)
private sub_signature_scalar ::= <<scalarDeclarationWrapper>> [OPERATOR_ASSIGN scalar_expr]

private recover_signature_content ::= !(RIGHT_PAREN|LEFT_BRACE)
/************************************* Sub signatures *****************************************************************/

private sub_attributes ::= COLON attribute ([COLON] attribute)*  {pin=1}
private var_attributes ::= COLON attribute ([COLON] attribute)*  // {pin=1} pin disable because of $something ? my $var : $other;
attribute ::= IDENTIFIER [string_sq_parsed]

last_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_LAST [lnr_param] {pin=2}
next_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_NEXT [lnr_param] {pin=2}
redo_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_REDO [lnr_param] {pin=2}
goto_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_GOTO [goto_param] {pin=2}

return_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_RETURN [list_expr] {pin=2}

private lnr_param ::= <<convertIdentifier LABEL>> | expr // fixme scalar_expr ?
private goto_param ::= <<convertIdentifier LABEL>> | OPERATOR_BITWISE_AND <<convertIdentifier SUB>> | expr // fixme same, scalar expr?


statement_modifier ::=
    if_statement_modifier
    | unless_statement_modifier
    | while_statement_modifier
    | until_statement_modifier
    | for_statement_modifier
    | foreach_statement_modifier
    | when_statement_modifier

if_statement_modifier ::=  [PACKAGE_CORE_IDENTIFIER]  RESERVED_IF expr {pin=2 name="Postfix if"}
unless_statement_modifier ::=  [PACKAGE_CORE_IDENTIFIER]  RESERVED_UNLESS expr {pin=2 name="Postfix unless"}
while_statement_modifier ::=  [PACKAGE_CORE_IDENTIFIER]  RESERVED_WHILE expr {pin=2 name="Postfix while"}
until_statement_modifier ::=  [PACKAGE_CORE_IDENTIFIER]  RESERVED_UNTIL expr {pin=2 name="Postfix until"}
for_statement_modifier ::=  [PACKAGE_CORE_IDENTIFIER]  RESERVED_FOR expr  {pin=2 name="Postfix for"}
foreach_statement_modifier ::=  [PACKAGE_CORE_IDENTIFIER]  RESERVED_FOREACH expr {pin=2 name="Postfix foreach"}
when_statement_modifier ::=  [PACKAGE_CORE_IDENTIFIER]  RESERVED_WHEN expr {pin=2 name="Postfix when"}

private use_statements ::= // fixme these shold be recovered otherwise, cause it has no statement modifiers
  use_statement_constant
  | use_vars_statement
  | use_statement

private no_statements ::= // fixme these shold be recovered otherwise, cause it has no statement modifiers
  no_statement

use_statement ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_USE use_no_parameters {pin=2}
no_statement ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_NO use_no_parameters {pin=2}

private use_no_parameters ::= use_module_parameters | use_version_parameters
private use_module_parameters ::= <<mergePackageName>> [perl_version [comma]] [<<parseStringifiedExpression>>];
private use_version_parameters ::= perl_version;

use_statement_constant ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_USE <<checkAndCollapseToken PACKAGE PACKAGE_PRAGMA_CONSTANT>> [perl_version] [use_constant_parameters] {pin=3}
private use_constant_parameters ::=
  constant_definition
  | constants_block
  | expr

// other name to extend declaration, not variable
use_vars_statement ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_USE <<checkAndCollapseToken PACKAGE PACKAGE_PRAGMA_VARS>> [perl_version] [<<parseUseVarsParameters>>] {pin=3}

constants_block ::= LEFT_BRACE [constants_block_content] RIGHT_BRACE {pin=1}
private constants_block_content ::= constant_block_content_element (comma constant_block_content_element) * [comma+] {recoverWhile=recover_block}
private constant_block_content_element ::= constant_definition | scalar_expr
constant_definition ::= <<parseConstantDefinition>> comma scalar_expr
constant_name ::= STRING_CONTENT

undef_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_UNDEF (undef_params | LEFT_PAREN undef_params RIGHT_PAREN) ? {pin=2}
private undef_params ::=
    deref_expr
    | variable

require_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_REQUIRE (<<mergeRequirePackageName>> | perl_version | scalar_expr)  {pin=2}// multiline string is possible too

private recover_statement ::= <<recoverStatement>>

// expression
expr ::=
    lp_or_xor_expr          // 0
    | lp_and_expr           // 1
    | lp_not_expr           // 2
    | named_list_expr       // 3
    | comma_sequence_expr   // 4
//    | comma_expr            // 4
    | assign_or_flow_expr   // 5
    | trenar_expr           // 6
    | flipflop_expr         // 7
    | or_expr               // 8
    | and_expr              // 9
    | bitwise_or_xor_expr   // 10
    | bitwise_and_expr      // 11
    | equal_expr            // 12
    | compare_expr          // 13
    | named_unary_expr      // 14
    | shift_expr            // 15
    | add_expr              // 16
    | mul_expr              // 17
    | regex_expr            // 18
    | op_5_expr             // 19
    | pow_expr              // 20
    | op_3_expr             // 21
    | deref_expr            // 22
    | term_expr             // 23

// above list operators
private list_expr ::= <<parseExpressionLevel 3>>

// List expression elements
private scalar_expr ::= <<parseExpressionLevel 4>>

// Unary expression argument
private unary_expr ::= <<parseExpressionLevel 14>>

// used in local declaration, fixme legacy
private immutable_expr ::= <<parseExpressionLevel 21>>

named_unary_expr ::= { OPERATOR_FILETEST | <<isUnaryOperator>> method } [unary_expr]
named_list_expr ::= <<parseListExpression>>

term_expr ::=
    variable_declaration
    | <<parseListOrListElement>> // fixme this must be in array with qw
    | scalar_constant
    | do_expr
    | sub_expr
    | eval_expr
    | grep_expr
    | return_expr
    | map_expr
    | sort_expr
    | regex_term
    | file_read_expr
    | print_expr
    | require_expr
    | undef_expr
    | perl_handle_expr
    | sub_call_expr
    | reference_value_expr
    | variable_expr
    | namespace_expr


grep_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_GREP grep_map_arguments {pin=2}
map_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_MAP grep_map_arguments {pin=2}

private grep_map_arguments ::=
    LEFT_PAREN grep_map_arguments_ RIGHT_PAREN !LEFT_BRACKET
    | grep_map_arguments_

private grep_map_arguments_ ::=
    block [comma] grep_map_sort_tail
    | scalar_expr comma grep_map_sort_tail
    | expr

private grep_map_sort_tail ::= file_read_forced_expr | list_expr

sort_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_SORT sort_arguments {pin=2}
private sort_arguments ::=
    LEFT_PAREN sort_arguments_ RIGHT_PAREN !LEFT_BRACKET
    | sort_arguments_

private sort_arguments_ ::=
    scalar_variable grep_map_sort_tail
    | block [comma] grep_map_sort_tail
    | callable grep_map_sort_tail
    | grep_map_sort_tail

private variable_expr ::= variable | array_index_variable

namespace_expr ::= <<mergePackageName>>
parenthesised_expr ::= LEFT_PAREN parenthesised_expr_content RIGHT_PAREN {pin=1 name="Parenthesised expression"}
private parenthesised_expr_content ::= [expr] {recoverWhile=recover_parenthesised}
private recover_parenthesised ::= !(RIGHT_PAREN | LEFT_BRACE | RIGHT_BRACE | semicolon_any )

deref_expr ::= expr (<<parseArrowSmart>> nested_element_variation) + //{pin(".*")=1}

private op_3_expr ::= pref_pp_expr | prefix_minus_as_string_expr | pref_mm_expr | suff_pp_expr
pref_pp_expr ::= OPERATOR_PLUS_PLUS expr
pref_mm_expr ::= OPERATOR_MINUS_MINUS expr

suff_pp_expr ::= expr (OPERATOR_PLUS_PLUS|OPERATOR_MINUS_MINUS)

pow_expr ::= expr (pow_operator expr)+ { rightAssociative=true }
private pow_operator ::= <<checkAndCollapseToken OPERATOR_POW OPERATOR_MUL OPERATOR_MUL>> !OPERATOR_ASSIGN

private op_5_expr ::= ref_expr | prefix_minus_as_string_expr | prefix_unary_expr
ref_expr ::= OPERATOR_REFERENCE referencable_expr { rightAssociative=true }
prefix_unary_expr ::= operator_prefix_unary expr { rightAssociative=true }
prefix_minus_as_string_expr ::= <<parseMinusBareword>>
private operator_prefix_unary ::= (
	OPERATOR_BITWISE_NOT
	| OPERATOR_NOT
	| <<checkAndConvertToken OPERATOR_PLUS_UNARY OPERATOR_PLUS>>
	| <<checkAndConvertToken OPERATOR_MINUS_UNARY OPERATOR_MINUS>>
	) !OPERATOR_ASSIGN // not sure we need !OPERATOR_ASSIGN

regex_expr ::= expr (OPERATOR_RE|OPERATOR_NOT_RE) expr

mul_expr ::= expr (operator_mul expr)+
private operator_mul ::= (OPERATOR_MUL !OPERATOR_MUL |OPERATOR_DIV|OPERATOR_MOD|OPERATOR_X) !OPERATOR_ASSIGN

add_expr ::= expr (operator_add expr)+
private operator_add ::= (OPERATOR_PLUS|OPERATOR_MINUS|OPERATOR_CONCAT) !OPERATOR_ASSIGN

shift_expr ::= expr (operator_shift expr)+
private operator_shift ::= (OPERATOR_SHIFT_LEFT|OPERATOR_SHIFT_RIGHT) !OPERATOR_ASSIGN

compare_expr ::= expr (operator_compare) expr
private operator_compare ::=
    <<checkAndCollapseToken OPERATOR_GE_NUMERIC OPERATOR_GT_NUMERIC OPERATOR_ASSIGN>>   // >=
    |<<checkAndCollapseToken OPERATOR_LE_NUMERIC OPERATOR_LT_NUMERIC OPERATOR_ASSIGN>>  // <=
    |OPERATOR_GT_NUMERIC
    |OPERATOR_LT_NUMERIC

    |OPERATOR_GE_STR
    |OPERATOR_LE_STR
    |OPERATOR_LT_STR
    |OPERATOR_GT_STR

equal_expr ::= expr operator_equal expr
private operator_equal ::=
    <<checkAndCollapseToken OPERATOR_EQ_NUMERIC OPERATOR_ASSIGN OPERATOR_ASSIGN>> // ==
    |<<checkAndCollapseToken OPERATOR_NE_NUMERIC OPERATOR_NOT OPERATOR_ASSIGN>>  // !=
    |OPERATOR_CMP_NUMERIC
    |OPERATOR_EQ_STR
    |OPERATOR_NE_STR
    |OPERATOR_CMP_STR
    |<<checkAndCollapseToken OPERATOR_SMARTMATCH OPERATOR_BITWISE_NOT OPERATOR_BITWISE_NOT>> // ~~

bitwise_and_expr ::= expr (OPERATOR_BITWISE_AND !OPERATOR_ASSIGN expr)+

bitwise_or_xor_expr ::= expr ( operator_bitwise_or_xor expr)+
private operator_bitwise_or_xor ::= (OPERATOR_BITWISE_OR|OPERATOR_BITWISE_XOR) !OPERATOR_ASSIGN

and_expr ::= expr ( operator_and expr)+
private operator_and ::= OPERATOR_AND !OPERATOR_ASSIGN

or_expr ::= expr ( operator_or_or_defined expr)+
private operator_or_or_defined ::= (OPERATOR_OR|OPERATOR_OR_DEFINED) !OPERATOR_ASSIGN

flipflop_expr ::= expr (OPERATOR_FLIP_FLOP|OPERATOR_HELLIP) expr
trenar_expr ::= expr QUESTION scalar_expr COLON scalar_expr { rightAssociative=true }

private assign_or_flow_expr ::=
    assign_expr
    | last_expr
    | next_expr
    | goto_expr
    | redo_expr

// fixme do we need to collapse tokens?
assign_expr ::= expr (operator_assign expr ) + { rightAssociative=true }

private operator_assign ::=
    <<checkAndCollapseToken OPERATOR_POW_ASSIGN OPERATOR_MUL OPERATOR_MUL OPERATOR_ASSIGN>>  // **=
    |<<checkAndCollapseToken OPERATOR_PLUS_ASSIGN OPERATOR_PLUS OPERATOR_ASSIGN>>      // +=
    |<<checkAndCollapseToken OPERATOR_MINUS_ASSIGN OPERATOR_MINUS OPERATOR_ASSIGN>>     // -=
    |<<checkAndCollapseToken OPERATOR_MUL_ASSIGN OPERATOR_MUL OPERATOR_ASSIGN>>       // *=
    |<<checkAndCollapseToken OPERATOR_DIV_ASSIGN OPERATOR_DIV OPERATOR_ASSIGN>>       // /=
    |<<checkAndCollapseToken OPERATOR_MOD_ASSIGN OPERATOR_MOD OPERATOR_ASSIGN>>       // %=
    |<<checkAndCollapseToken OPERATOR_CONCAT_ASSIGN OPERATOR_CONCAT OPERATOR_ASSIGN>>    // .=
    |<<checkAndCollapseToken OPERATOR_X_ASSIGN OPERATOR_X OPERATOR_ASSIGN>>         // x=
    |<<checkAndCollapseToken OPERATOR_BITWISE_AND_ASSIGN OPERATOR_BITWISE_AND OPERATOR_ASSIGN>>   // &=
    |<<checkAndCollapseToken OPERATOR_BITWISE_OR_ASSIGN OPERATOR_BITWISE_OR OPERATOR_ASSIGN>>    // |=
    |<<checkAndCollapseToken OPERATOR_BITWISE_XOR_ASSIGN OPERATOR_BITWISE_XOR OPERATOR_ASSIGN>>   // ^=
    |<<checkAndCollapseToken OPERATOR_SHIFT_LEFT_ASSIGN OPERATOR_SHIFT_LEFT OPERATOR_ASSIGN>>    //  <<=
    |<<checkAndCollapseToken OPERATOR_SHIFT_RIGHT_ASSIGN OPERATOR_SHIFT_RIGHT OPERATOR_ASSIGN>>   //  >>=
    |<<checkAndCollapseToken OPERATOR_AND_ASSIGN OPERATOR_AND OPERATOR_ASSIGN>>           //  &&=
    |<<checkAndCollapseToken OPERATOR_OR_ASSIGN OPERATOR_OR OPERATOR_ASSIGN>>            //  ||=
    |<<checkAndCollapseToken OPERATOR_OR_DEFINED_ASSIGN OPERATOR_OR_DEFINED OPERATOR_ASSIGN>>    //  //=
    |OPERATOR_ASSIGN !OPERATOR_ASSIGN

comma_sequence_expr ::= expr <<parseCommaSequence>> // fixme implement pinnning

lp_not_expr ::= OPERATOR_NOT_LP expr { rightAssociative=true }
lp_and_expr ::= expr (OPERATOR_AND_LP expr)+

lp_or_xor_expr ::= expr ((OPERATOR_OR_LP|OPERATOR_XOR_LP) expr)+

print_expr ::= [PACKAGE_CORE_IDENTIFIER] (RESERVED_PRINT|RESERVED_PRINTF|RESERVED_SAY) ( LEFT_PAREN [print_arguments] RIGHT_PAREN | [print_arguments] ) {pin=2}
private print_arguments ::= [print_handle] expr | expr
print_handle ::=  <<parsePrintHandle>> | perl_handle

sub_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_SUB sub_definition_parameters block  // fixme make sure that this one checked after definition and declaration

sub_call_expr ::= leftward_call_expr | rightward_call_expr

private leftward_call_expr ::= callable LEFT_PAREN [call_arguments] RIGHT_PAREN !LEFT_BRACKET
private rightward_call_expr ::= callable [call_arguments]

//// fixme this should depend on prototype
call_arguments ::=
    anon_hash comma list_expr
    | block [[comma] list_expr]
    | list_expr

file_read_expr ::= <<checkFileReadToken>> [read_handle | <<parseFileHandleAsString>> ] <<checkAndConvertToken RIGHT_ANGLE OPERATOR_GT_NUMERIC>>
// this one is used to force parsing, like list_epxr after map, grep or sort; Not sure if we need this after implementing chckFileReadToken
file_read_forced_expr ::= <<checkAndConvertToken LEFT_ANGLE OPERATOR_LT_NUMERIC>> [read_handle | <<parseFileHandleAsString>> ] <<checkAndConvertToken RIGHT_ANGLE OPERATOR_GT_NUMERIC>>

read_handle ::= <<parseReadHandle>>

////////////////////////// regular expressions /////////////////////////////////////////////////////////////////////////
private regex_term ::=
    compile_regex
    | replacement_regex
    | tr_regex
    | match_regex

// pinning quotes leads to bug with replacement block
compile_regex ::= [PACKAGE_CORE_IDENTIFIER]  RESERVED_QR match_regex_body {pin=2}
match_regex ::= [PACKAGE_CORE_IDENTIFIER]  [RESERVED_M] match_regex_body
private match_regex_body ::= regex_match REGEX_QUOTE_CLOSE [perl_regex_modifiers]

replacement_regex ::=
    [PACKAGE_CORE_IDENTIFIER] RESERVED_S
    regex_match
    replacement_replace
    REGEX_QUOTE_CLOSE
    [perl_regex_modifiers]
    {pin=2}

private regex_match ::=
  REGEX_QUOTE_OPEN [perl_regex]
  | REGEX_QUOTE_OPEN_X [perl_regex_ex]
private replacement_replace ::= replacement_replace_regex | replacement_replace_code

private replacement_replace_regex ::= {REGEX_QUOTE | REGEX_QUOTE_CLOSE REGEX_QUOTE_OPEN} [perl_regex]
private replacement_replace_code ::= {REGEX_QUOTE_E | REGEX_QUOTE_CLOSE REGEX_QUOTE_OPEN_E} [regex_code]

private regex_code ::= file_item+ {recoverWhile=recover_regex_code}
private recover_regex_code ::= !(REGEX_QUOTE_CLOSE)

perl_regex_modifiers ::= REGEX_MODIFIER +
perl_regex ::= <<parseRegexContent false>>
private perl_regex_items ::= perl_regex_item +

private perl_regex_item ::=
  interpolated_constructs
  | <<convertRegexToken>>

perl_regex_ex ::= <<parseRegexContent true>> {extends=perl_regex}
private perl_regex_ex_items ::= perl_regex_item_ex +

private perl_regex_item_ex ::=
  interpolated_constructs
  | <<convertRegexTokenEx>>

tr_regex ::= [PACKAGE_CORE_IDENTIFIER] (RESERVED_TR|RESERVED_Y) tr_search tr_replacement [tr_modifiers] {pin=2}
private tr_search ::= REGEX_QUOTE_OPEN [tr_searchlist] {pin=1}
tr_searchlist ::= STRING_CONTENT
private tr_replacement ::= {REGEX_QUOTE | REGEX_QUOTE_CLOSE REGEX_QUOTE_OPEN} [tr_replacementlist] REGEX_QUOTE_CLOSE {pin=1}
tr_replacementlist ::= STRING_CONTENT
tr_modifiers ::= REGEX_MODIFIER +

////////////////////////// end of regular expressions //////////////////////////////////////////////////////////////////

do_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_DO eval_argument {pin=2}
eval_expr ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_EVAL [eval_argument] {pin=2}
private eval_argument ::= parenthesised_expr | block | expr

private variable_declaration ::=
    variable_declaration_global
    | variable_declaration_lexical
    | variable_declaration_local

// @todo attributes support
variable_declaration_local ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_LOCAL [<<mergePackageName>>]  local_variable_declaration_variation {pin=2}
variable_declaration_lexical ::= [PACKAGE_CORE_IDENTIFIER] (RESERVED_MY | RESERVED_STATE) [<<mergePackageName>>] variable_declaration_variation [var_attributes] {pin=2}
variable_declaration_global ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_OUR [<<mergePackageName>>] variable_declaration_variation [var_attributes] {pin=2}

private local_variable_declaration_variation ::= local_parenthesised_declaration | local_variable_declaration_argument
private local_parenthesised_declaration ::= LEFT_PAREN local_variable_declaration_argument (comma + local_variable_declaration_argument ) * comma * RIGHT_PAREN {pin=1}
private local_variable_declaration_argument ::= strict_variable_declaration_argument | scalar_expr

private variable_declaration_variation ::= variable_parenthesised_declaration | variable_declaration_argument
private variable_parenthesised_declaration ::= LEFT_PAREN variable_parenthesised_declaration_contents RIGHT_PAREN {pin=1}
private variable_parenthesised_declaration_contents ::= strict_variable_declaration_argument (comma + strict_variable_declaration_argument ) * comma*

private strict_variable_declaration_argument ::= strict_variable_declaration_wrapper | [PACKAGE_CORE_IDENTIFIER] RESERVED_UNDEF
private variable_declaration_argument ::= variable_declaration_wrapper | [PACKAGE_CORE_IDENTIFIER] RESERVED_UNDEF

private strict_variable_declaration_wrapper ::= variable_declaration_wrapper !(LEFT_BRACE | LEFT_BRACKET | OPERATOR_DEREFERENCE )
variable_declaration_wrapper ::= lexical_variable

/////////////////////////////////// REFERENCES /////////////////////////////////////////////////////////////////////////
// most of the references created by \ operator, but some - don't
private reference_value_expr ::=
    anon_array
    | anon_hash
    | anon_sub

anon_array ::= LEFT_BRACKET [expr] RIGHT_BRACKET //{pin=1}
anon_hash ::= LEFT_BRACE [expr] RIGHT_BRACE <<validateAnonHashSuffix>>  // fixme pin here after solving problem with code block and prototypes
anon_sub ::= [PACKAGE_CORE_IDENTIFIER] RESERVED_SUB block

//////////////////////////// END OF REFERENCES /////////////////////////////////////////////////////////////////////////

// fixme it's not a variable, its variable expression
private variable ::= scalar | array | hash | glob

private array ::= <<parseArrayOrSlice>>

private array_primitive ::=
    array_variable
    | array_cast_expr
    | string_list
array_array_slice ::= array_primitive array_index
array_hash_slice ::= array_primitive hash_index

array_cast_expr ::= SIGIL_ARRAY cast_target

private hash ::=
    hash_variable
    | hash_cast_expr

hash_cast_expr ::= <<parseAmbiguousSigil OPERATOR_MOD SIGIL_HASH>> cast_target

private scalar ::= <<parseScalarOrElement>>

private scalar_primitive ::=
    scalar_variable
    | scalar_cast_expr
    | undef_expr  // shouldn't it be in term ? (check declarations)
    | scalar_index_cast_expr

scalar_cast_expr ::= SIGIL_SCALAR cast_target

scalar_index_cast_expr ::= SIGIL_SCALAR_INDEX cast_target

private cast_target ::= braced_cast | scalar_primitive
private braced_cast ::= LEFT_BRACE <<parseBracedCastContent>> RIGHT_BRACE {pin=1} // fixme this is a hack; is code inside?


scalar_array_element ::= scalar_primitive array_index
scalar_hash_element ::= scalar_primitive hash_index
anon_array_element ::= parenthesised_expr array_index

private glob ::= <<parseGlobOrElement>>
private glob_primitive ::=
    glob_variable
    | glob_cast_expr

glob_cast_expr ::= <<parseAmbiguousSigil OPERATOR_MUL SIGIL_GLOB>> cast_target

glob_slot ::= glob_primitive hash_index

// extended nested element for using in ()
private nested_element_variation ::=
    hash_index
    | array_index
    | nested_call
    | nested_call_arguments    // function call like $var->()
    | scalar_call

nested_call ::= method [method_call_arguments]
scalar_call ::= scalar [method_call_arguments]
private method_call_arguments ::= LEFT_PAREN [<<parseSimpleCallArguments>>] RIGHT_PAREN
nested_call_arguments ::= method_call_arguments

hash_index ::= <<parseHashIndex>>
array_index ::= <<parseArrayIndex>>

///////////////////////////////////// CALLABLE /////////////////////////////////////////////////////////////////////////

private callable ::= method | code // being used in parseFunctionCall
private referencable_expr ::= code | scalar_expr

private code ::=
    <<parseAmbiguousSigil OPERATOR_BITWISE_AND SIGIL_CODE>> method
    | code_variable
    | code_cast_expr

code_cast_expr ::= <<parseAmbiguousSigil OPERATOR_BITWISE_AND SIGIL_CODE>> cast_target

////////////////////////////////END OF CALLABLE ////////////////////////////////////////////////////////////////////////

label_declaration ::= <<parseLabelDeclaration>> // do we need to change tokentype?
private perl_version ::= <<parsePerlVersion>>
private perl_handle ::=  block | scalar_variable !(<<isOperatorToken>>)
perl_handle_expr ::= HANDLE

//////////////////////////////////// constants /////////////////////////////////////////////////////////////////////////

private scalar_constant ::=
    number_constant
    | tag_scalar
    | string

tag_scalar ::= TAG

number_constant ::=
    NUMBER
    | NUMBER_VERSION
    | NUMBER_SIMPLE

private string ::= string_bare | string_sq | string_dq | string_xq | heredoc_opener

string_dq ::=
  [[PACKAGE_CORE_IDENTIFIER] RESERVED_QQ] string_dq_parsed
  | <<parseNetstedInterpolatedString QUOTE_DOUBLE>>

private string_dq_parsed ::= QUOTE_DOUBLE_OPEN [<<parseInterpolatedStringContent>>] QUOTE_DOUBLE_CLOSE {pin=1}

string_xq ::=
  [[PACKAGE_CORE_IDENTIFIER] RESERVED_QX] string_xq_parsed
  | <<parseNetstedInterpolatedString QUOTE_TICK>>

private string_xq_parsed ::= QUOTE_TICK_OPEN [<<parseInterpolatedStringContent>>] QUOTE_TICK_CLOSE {pin=1}

string_bare ::= <<parseAndWrapStringContent>>

string_sq ::=
  [[PACKAGE_CORE_IDENTIFIER] RESERVED_Q] <<parseSQString>>
  | <<parseNestedSQString>> // nested sq string

private string_sq_parsed ::= QUOTE_SINGLE_OPEN <<parseAndWrapStringContent>>* QUOTE_SINGLE_CLOSE {pin=1}
private string_content_qq ::= string_content_element +
private string_content_element ::=
  <<parseInterpolatedConstructs>>
  | <<convertToStringContent>>

// these constructs are for regular strings
private interpolated_constructs ::=
  scalar
  | array
  | array_index_variable

private use_vars_interpolated_constructs ::=
    scalar_variable
    | array_variable
    | hash_variable
    | glob_variable
    | code_variable

heredoc_opener ::= OPERATOR_HEREDOC string {pin=1}

string_list ::= [[PACKAGE_CORE_IDENTIFIER] RESERVED_QW] <<parseSQString>>

///////////////////////////////////// variables ////////////////////////////////////////////////////////////////////////
private lexical_variable ::= scalar_variable | array_variable | hash_variable

array_index_variable ::= SIGIL_SCALAR_INDEX variable_body
scalar_variable ::= SIGIL_SCALAR variable_body
array_variable ::= SIGIL_ARRAY variable_body
hash_variable ::= <<parseAmbiguousSigil OPERATOR_MOD SIGIL_HASH>> variable_body

//fixme probably this should not be here
code_variable ::= <<parseAmbiguousSigil OPERATOR_BITWISE_AND SIGIL_CODE>> variable_body

glob_variable ::= <<parseAmbiguousSigil OPERATOR_MUL SIGIL_GLOB>> variable_body

private variable_body ::= <<parseVariableName>>

private comma ::= OPERATOR_COMMA | OPERATOR_COMMA_ARROW
method ::= <<parseMethod>>

/******************************************** PERL SUBS ANNOTATIONS ***************************************************/
private annotations ::= annotation+ //{recoverWhile=recover_sub_annotation}
annotation ::=
    annotation_unknown
    | annotation_abstract
    | annotation_deprecated
    | annotation_method
    | annotation_returns_ref
    | annotation_returns_arrayref
    | annotation_returns_hashref
    | annotation_override
    | annotation_incomplete

annotation_unknown ::= ANNOTATION_PREFIX ANNOTATION_UNKNOWN_KEY
annotation_abstract ::= ANNOTATION_PREFIX ANNOTATION_ABSTRACT_KEY
annotation_deprecated ::= ANNOTATION_PREFIX ANNOTATION_DEPRECATED_KEY
annotation_method ::= ANNOTATION_PREFIX ANNOTATION_METHOD_KEY
annotation_override ::= ANNOTATION_PREFIX ANNOTATION_OVERRIDE_KEY
annotation_returns_ref ::= ANNOTATION_PREFIX ANNOTATION_RETURNS_KEY <<mergePackageName>>
annotation_returns_arrayref ::= ANNOTATION_PREFIX ANNOTATION_RETURNS_KEY namespace_element_bracketed
annotation_returns_hashref ::= ANNOTATION_PREFIX ANNOTATION_RETURNS_KEY namespace_element_braced
annotation_incomplete ::= ANNOTATION_PREFIX <<parseIncompleteAnnotation>> {pin=1}

//private recover_sub_annotation ::= !(RESERVED_SUB|ANNOTATION_PREFIX)

private namespace_element_bracketed ::= LEFT_BRACKET <<mergePackageName>> RIGHT_BRACKET {name="[Package::Name]"}
private namespace_element_braced ::= LEFT_BRACE <<mergePackageName>> RIGHT_BRACE {name="{Package::Name}"}

/******************************************** PERL SUBS ANNOTATIONS ***************************************************/
private namespace_canonical ::= <<convertPackageIdentifier>>
private semicolon_any ::= SEMICOLON | EMBED_MARKER_SEMICOLON

/********************************************** Extensions for Method::Signatures *************************************/
// we can make this smareter and use keywords from settings or import opitions; We can't pin here because MooseX method works othewise
method_definition ::= [annotations] <<checkAndConvertToken RESERVED_SUB RESERVED_METHOD>> sub_definition_name [method_signature] [sub_attributes] block
func_definition ::= [annotations] <<checkAndConvertToken RESERVED_SUB RESERVED_FUNC>> sub_definition_name [func_signature] [sub_attributes] block

// not sure that we need a wrapper for signatures
private method_signature ::= LEFT_PAREN method_signature_content RIGHT_PAREN {pin=1}
method_signature_content ::= [method_signature_invocant] [variable_parenthesised_declaration_contents] {recoverWhile=recover_signature_content}
method_signature_invocant ::= <<scalarDeclarationWrapper>> COLON
private func_signature ::= LEFT_PAREN func_signature_content RIGHT_PAREN {pin=1}
func_signature_content ::= [variable_parenthesised_declaration_contents] {recoverWhile=recover_signature_content}

/********************************************** Extensions for Moose **************************************************/

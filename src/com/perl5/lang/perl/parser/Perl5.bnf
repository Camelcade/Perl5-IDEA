{
  parserClass="com.perl5.lang.perl.parser.PerlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Perl"
  psiImplClassSuffix="Impl"
  psiPackage="com.perl5.lang.perl.psi"
  psiImplPackage="com.perl5.lang.perl.psi.impl"

  elementTypeHolderClass="com.perl5.lang.perl.lexer.PerlElementTypes"
  elementTypeClass="com.perl5.lang.perl.PerlElementType"
  tokenTypeClass="com.perl5.lang.perl.PerlTokenType"

  tokens=[
    PERL_COMMENT="PERL_COMMENT"
    PERL_COMMENT_BLOCK="PERL_COMMENT_BLOCK"
    PERL_POD="PERL_POD"

    PERL_SIGIL_ARRAY="@"
    PERL_SIGIL_HASH="%"
    PERL_SIGIL_SCALAR="$"

    PERL_MULTILINE_MARKER="PERL_MULTILINE_MARKER"
    PERL_MULTILINE_MARKER_HTML="PERL_MULTILINE_MARKER_HTML"
    PERL_MULTILINE_MARKER_XHTML="PERL_MULTILINE_MARKER_XHTML"
    PERL_MULTILINE_MARKER_XML="PERL_MULTILINE_MARKER_XML"

    PERL_STRING_MULTILINE="PERL_STRING_MULTILINE"

    PERL_STRING="PERL_STRING"

    PERL_VERSION="PERL_VERSION"
    PERL_NUMBER="PERL_NUMBER"
    PERL_SCALAR="PERL_SCALAR"
    PERL_ARRAY="PERL_ARRAY"
    PERL_HASH="PERL_HASH"
    PERL_GLOB="PERL_GLOB"

    PERL_FUNCTION="PERL_FUNCTION"
    PERL_PACKAGE="PERL_PACKAGE"
    PERL_OPERATOR="PERL_OPERATOR"

    PERL_DEREFERENCE='->'
    PERL_DEPACKAGE='::'
    PERL_COMMA=','
    PERL_LBRACK='['
    PERL_RBRACK=']'
    PERL_LPAREN='('
    PERL_RPAREN=')'
    PERL_LBRACE='{'
    PERL_RBRACE='}'
    PERL_SEMI=';';
  ]

    extends(".*expr")=expr

    psiImplUtilClass="com.perl5.lang.perl.psi.impl.PerlPsiImpUtil"
}

perlFile ::= block_item*

block_item ::= package_definition | package_item

package_item ::=
    eval
    | function_definition
    | package_use
    | package_no
    | package_require
    | if_block
    | block
    | code_line ';'
    | PERL_POD
    | PERL_COMMENT
    | PERL_COMMENT_BLOCK

// package
package_definition ::= 'package' package_bare PERL_VERSION ? (block | ';' package_item * )

// sub
function_definition ::= function_definition_named | function_definition_anon

function_definition_named ::= 'sub' PERL_FUNCTION block ';' ? {
    mixin="com.perl5.lang.perl.psi.impl.PerlFunctionDefinitionNamedUtil"
}
function_definition_anon ::= 'sub' block ';'

// variable definition
variable_definition ::= my_definition | our_definition | local_definition
my_definition ::= 'my' variable_definition_arguments
our_definition ::= 'our' variable_definition_arguments
local_definition ::= 'local' variable_definition_arguments
variable_definition_arguments ::= ( package_bare ? variable | '(' variables ')' )

// use and no
package_use ::= 'use' package_use_arguments ';'
package_no ::= 'no' package_use_arguments ';'

package_use_arguments ::=
    package_bare PERL_VERSION expr ?
    | package_bare expr ?
    | PERL_VERSION;

// require
package_require ::= 'require' (package_bare | PERL_VERSION | string) ';' // multiline string is possible too

// eval
eval ::= 'eval' (block | scalar) ';'

// if
if_postfix ::= ('if' | 'unless') expr

if_block ::= ('if' | 'unless') if_branch_conditional if_block_elsif * if_block_else ?
if_block_elsif ::= 'elsif' if_branch_conditional
if_block_else  ::= 'else' block
if_branch_conditional ::= '(' expr ')' block

block ::= '{' code_lines ? '}';
code_lines ::= code_line (';' code_line )*
code_line ::= expr if_postfix ?

//code_line ::= expr (';' multiline_string ?) ? // multiline needs special treatment


// expression
expr ::=
    op_24_expr
    | op_23_expr
    | op_22_expr
    | op_21_expr
    | op_20_expr
    | op_19_expr
    | op_18_expr
    | op_17_expr
    | op_16_expr
    | op_15_expr
    | op_14_expr
    | op_13_expr
    | op_12_expr
    | op_11_expr
    | op_10_expr
    | op_9_expr
    | op_8_expr
    | op_7_expr
    | op_6_expr
    | op_5_expr
    | op_4_expr
    | op_3_expr
    | op_2_expr
    | op_1_expr

op_1_expr ::= term | call_leftward | variable_definition // not sure about var definition
op_2_expr ::= expr '->' expr
private op_3_expr ::= op_3_pref_expr | op_3_suff_expr
op_3_pref_expr ::= ('++'|'--') expr
op_3_suff_expr ::= expr ('++'|'--')
op_4_expr ::= expr ('**' expr)+ { rightAssociative=true }
op_5_expr ::= ('\' | '~'| '!'| '+' | '-') expr { rightAssociative=true }
op_6_expr ::= expr ('=~'|'!~') expr
op_7_expr ::= expr ('*'|'/'|'%'|'x') expr
op_8_expr ::= expr ('+'|'-'|'.') expr
op_9_expr ::= expr ('<<'|'>>') expr
op_10_expr ::= ('not'|'defined'|'ref'|'exists'|'scalar') expr
op_11_expr ::= expr ('>='|'<='|'<'|'>'|'lt'|'gt'|'le'|'ge') expr
op_12_expr ::= expr ('=='|'!='|'<=>'|'eq'|'ne'|'cmp'|'~~') expr
op_13_expr ::= expr '&' expr
op_14_expr ::= expr ('|'|'^') expr
op_15_expr ::= expr '&&' expr
op_16_expr ::= expr ('||'|'//') expr
op_17_expr ::= expr ('..'|'...') expr
op_18_expr ::= expr '?' expr ':' expr { rightAssociative=true }
op_19_expr ::= expr ('=' | '**='|'+='|'-='| '*='|'/='|'x='| '&='|'|='|'.='| '<<='|'>>='|'%='| '&&='|'||='|'^='| '//=') expr { rightAssociative=true }
op_20_expr ::= expr	(',' | '=>') expr
op_21_expr ::= call_rightward
op_22_expr ::= 'not' expr { rightAssociative=true }
op_23_expr ::= expr 'and' expr
op_24_expr ::= expr ('or'|'xor') expr

term ::=
    '(' expr ')'
    | array
    | hash
    | scalar

call_leftward ::=
    calee '(' expr ? ')'
    | scalar '(' expr ? ')'
    | scalar '->' '(' expr ? ')'
call_rightward ::= calee expr ?

calee ::=
    package_method
    | package_function
    | object_method
    | PERL_FUNCTION

package_method ::= package_bare '->' PERL_FUNCTION
package_function ::= package_bare '::' PERL_FUNCTION
object_method ::= scalar '->' PERL_FUNCTION

array ::=
    array_safe '[' expr ']'              // array slice
    | array_safe '{' expr '}'              // hash slice
    | array_safe
    | '(' ')'                       // empty array

private array_safe ::=
    PERL_SIGIL_ARRAY '{' expr '}'   // scalar dereference
    | PERL_ARRAY                    // array as is


hash ::=
    PERL_SIGIL_HASH '{' expr '}'   // hash dereference
    | PERL_HASH                    // hash as is

scalar ::=
    scalar_safe '->'? '[' expr ']'      // array element
    | scalar_safe '->'? '{' expr '}'    // hash element
    | scalar_safe                       // scalar or deref scalar
    | '[' expr ']'                      // anonymous array
    | '{' expr '}'                      // anonymous hash
    |  multiline_marker                 // deferred string
    | PERL_STRING                       // string
    | PERL_NUMBER                       // raw number

private scalar_safe ::=
    PERL_SIGIL_SCALAR '{' expr '}'       // scalar dereference
    | PERL_SCALAR                          // scalar as is

// Multiline
multiline_string ::= PERL_STRING_MULTILINE PERL_MULTILINE_MARKER

private multiline_marker ::= PERL_MULTILINE_MARKER
    | PERL_MULTILINE_MARKER_HTML
    | PERL_MULTILINE_MARKER_XHTML
    | PERL_MULTILINE_MARKER_XML

private variables ::= variable (',' variable ) *
private variable ::= PERL_SCALAR | PERL_ARRAY | PERL_HASH

// assigning package
package_bare ::= PERL_PACKAGE  {   mixin="com.perl5.lang.perl.psi.impl.PerlNamedElementImpl"
        implements="com.perl5.lang.perl.psi.PerlNamedElement"
        methods=[getName setName getNameIdentifier]
    }


{
  parserClass="com.perl5.lang.perl.parser.PerlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

//  generate=[tokens="yes" psi="yes" tokenAccessors="yes"]

  psiClassPrefix="Perl"
  psiImplClassSuffix="Impl"
  psiPackage="com.perl5.lang.perl.psi"
  psiImplPackage="com.perl5.lang.perl.psi.impl"

  elementTypeHolderClass="com.perl5.lang.perl.lexer.PerlElementTypes"
  elementTypeClass="com.perl5.lang.perl.PerlElementType"
  tokenTypeClass="com.perl5.lang.perl.PerlTokenType"

  parserUtilClass="com.perl5.lang.perl.parser.PerlParserUitl"
  psiImplUtilClass="com.perl5.lang.perl.psi.impl.PerlPsiImpUtil"

  //elementTypeFactory="com.perl5.lang.perl.psi.PerlElementFactory.getCompositeType"
//  tokenTypeFactory="com.perl5.lang.perl.psi.PerlElementFactory.getCompositeType"

  tokens=[
    PERL_COMMENT="PERL_COMMENT"
    PERL_COMMENT_BLOCK="PERL_COMMENT_BLOCK"
    PERL_POD="PERL_POD"

    PERL_SIGIL_ARRAY="@"
    PERL_SIGIL_HASH="%"
    PERL_SIGIL_SCALAR="$"

    PERL_SCALAR="PERL_SCALAR"
    PERL_ARRAY="PERL_ARRAY"
    PERL_HASH="PERL_HASH"
    PERL_GLOB="PERL_GLOB"

    PERL_STRING_MULTILINE="PERL_STRING_MULTILINE" // should be string content too
    PERL_STRING_MULTILINE_END="PERL_STRING_MULTILINE_END"

    PERL_VERSION="PERL_VERSION"
    PERL_NUMBER_VERSION="PERL_NUMBER_VERSION"
    PERL_NUMBER="PERL_NUMBER"

    PERL_KEYWORD="PERL_KEYWORD"

    PERL_OPERATOR="PERL_OPERATOR"
    PERL_OPERATOR_UNARY="PERL_OPERATOR_UNARY"
    PERL_OPERATOR_FILETEST="PERL_OPERATOR_FILETEST"

    PERL_REGEX_QUOTE="PERL_REGEX_QUOTE"
    PERL_REGEX_MODIFIER="PERL_REGEX_MODIFIER"
    PERL_REGEX_TOKEN="PERL_REGEX_TOKEN"

    PERL_STRING="PERL_STRING"
    PERL_STRING_CONTENT="PERL_STRING_CONTENT"

    PERL_BAREWORD="PERL_BAREWORD"
    PERL_TAG="PERL_TAG"

    PERL_COMMA=','
    PERL_ARROW_COMMA='=>'
    PERL_DEREFERENCE='->'
    PERL_DEPACKAGE='::'
    PERL_COLON=":"
    PERL_LBRACK='['
    PERL_RBRACK=']'
    PERL_LPAREN='('
    PERL_RPAREN=')'
    PERL_LBRACE='{'
    PERL_RBRACE='}'
    PERL_LANGLE='<'
    PERL_RANGLE='>'
    PERL_SEMI=';';
    PERL_QUOTE="\""

    // custom tokens
    PERL_PACKAGE="PERL_PACKAGE"
    PERL_FUNCTION="PERL_FUNCTION"
    PERL_HANDLE="PERL_HANDLE"
    PERL_BLOCK_NAME="PERL_BLOCK_NAME"
  ]

    extends(".*expr")=expr
 }

///////////////////////////// main code structure //////////////////////////////////////////////////////////////////////
private perlFile ::= <<parseFile>> <<eof>>

private file_items ::= file_item*

private block_safe ::= <<parseBlock>>
block ::= "{" file_items "}" {pin=1} // should not be used anywhere, injected by block_safe

private file_item ::= namespace | namespace_element
private namespace_element ::= (sub_definition | named_block | compound_statement | statement ) PERL_SEMI*

// package keyword
namespace ::= 'package' <<parsePerlPackage>> {pin=1}
private namespace_content ::= namespace_element * // injected and wrapped by parsePackageContents

named_block ::= PERL_BLOCK_NAME block_safe

// declarations
private compound_statement ::=
    [label_declaration] (
        block_compound
        | if_compound
        | unless_compound
        | given_compound
        | while_compound
        | until_compound
        | for_compound
        | foreach_compound
     )

if_compound ::= 'if' compound_conditional_block if_compound_elsif * [if_compound_else]
unless_compound ::= 'unless' compound_conditional_block if_compound_elsif * [if_compound_else]
private if_compound_elsif ::= 'elsif' compound_conditional_block
private if_compound_else  ::= 'else' block_safe

private compound_conditional_block ::= '(' expr ')' block_safe

given_compound ::= 'given' compound_conditional_block

while_compound ::= 'while' compound_conditional_block [compound_continue_block]
until_compound ::= 'until' compound_conditional_block [compound_continue_block]

private compound_continue_block ::= 'continue' block_safe

block_compound ::= block_safe [compound_continue_block]


// for/foreach
for_compound ::= 'for' for_compound_arguments
foreach_compound ::= 'foreach' for_compound_arguments
private for_compound_arguments ::= for_compound_arguments_iteration | for_compound_arguments_list

private for_compound_arguments_iteration ::= '(' [expr]  PERL_SEMI [expr] PERL_SEMI [expr] ')' block_safe

// @todo only single variable or variable definition may be here
private for_compound_arguments_list ::=
    [ variable_declaration | variable ] '(' expr ')' block_compound

private statement ::= statement_variation [statement_modifier] (<<statementSemi>>|<<eof>>) //{recoverWhile=recover_statement}

private statement_variation ::=
    use_statement
    | no_statement
    | undef_statement
    | last_statement
    | next_statement
    | redo_statement
    | sub_declaration
    | expr

sub_definition ::= 'sub' <<parseSubDefinition>>

private sub_definition_parameters ::=
    sub_prototype [sub_attributes]
    | sub_attributes [sub_signature]
    | sub_signature

sub_declaration ::= 'sub' <<parseSubDeclaration>>
private sub_declaration_parameters ::=  [sub_prototype] [sub_attributes]

private sub_prototype ::= "(" <<parseSubPrototype>> ")"
private sub_signature ::= "(" <<parseSubSignature>> ")"
private sub_attributes ::= ":" <<parseSubAttributes>>


last_statement ::= 'last' [lnr_param] {pin=1}
next_statement ::= 'next' [lnr_param] {pin=1}
redo_statement ::= 'redo' [lnr_param] {pin=1}
private lnr_param ::= label | expr


private statement_modifier ::=
    if_statement_modifier
    | unless_statement_modifier
    | while_statement_modifier
    | until_statement_modifier
    | for_statement_modifier
    | foreach_statement_modifier
    | when_statement_modifier

if_statement_modifier ::= 'if' expr {pin=1}
unless_statement_modifier ::=  'unless' expr {pin=1}
while_statement_modifier ::=  'while' expr {pin=1}
until_statement_modifier ::=  'until' expr {pin=1}
for_statement_modifier ::=  'for' expr  {pin=1}   // actually @LIST
foreach_statement_modifier ::=  'foreach' expr {pin=1} // actually @LIST
when_statement_modifier ::= 'when' expr {pin=1}


use_statement ::= 'use' <<parseUseStatement>> {pin=1}
no_statement ::= 'no' <<parseNoStatement>> {pin=1}

undef_statement ::= "undef" variable {pin=1}

require_term ::= 'require' (perl_package | perl_version | string)  {pin=1} // multiline string is possible too

//private recover_statement ::= !(PERL_SEMI  | <<eof>>)
//private recover_block ::= !(PERL_RBRACE | <<eof>>)

// expression
expr ::=
    lp_or_xor_expr
    | lp_and_expr
    | lp_not_expr
    | rightward_call_expr
    | comma_expr
    | assign_expr
    | trenar_expr
    | flipflop_expr
    | or_expr
    | and_expr
    | bitwise_or_xor_expr
    | bitwise_and_expr
    | equal_expr
    | compare_expr
    | op_10_expr
    | shift_expr
    | add_expr
    | mul_expr
    | regex_expr
    | op_5_expr
    | pow_expr
    | op_3_expr
    | deref_expr
    | term_expr

term_expr ::=
    variable
    | variable_declaration
    | PERL_OPERATOR_UNARY "(" [expr] ")" // named operators as functions
    | "(" [expr] ")"
    | scalar_primitive
    | do_term
    | eval_term
    | regex_term
    | file_read_term
    | reference_value
    | print_term
    | open_term
    | grep_term
    | sort_term
    | map_term
    | require_term
    | function_call

deref_expr ::= expr <<parseArrowSmart>> nested_element_expr

private op_3_expr ::= pref_pp_expr | suff_pp_expr
pref_pp_expr ::= ('++'|'--') expr
suff_pp_expr ::= expr ('++'|'--')

pow_expr ::= expr ('**' expr)+ { rightAssociative=true }

private op_5_expr ::= ref_expr | bareword_expr| prefix_unary_expr
ref_expr ::= '\' expr { rightAssociative=true }
bareword_expr ::= <<parseBarewordStringMinus>>
prefix_unary_expr ::= ('~'| '!'| '+' | '-') expr { rightAssociative=true }

regex_expr ::= expr ('=~'|'!~') expr
mul_expr ::= expr ('*'|'/'|'%'|'x') expr
add_expr ::= expr ('+'|'-'|'.') expr
shift_expr ::= expr ('<<'|'>>') expr

private op_10_expr ::= named_unary_expr | filetest_expr
named_unary_expr ::= PERL_OPERATOR_UNARY !"(" expr
filetest_expr ::= PERL_OPERATOR_FILETEST (<<parseBarewordHandle>> | expr )

compare_expr ::= expr ('>='|'<='|'<'|'>'|'lt'|'gt'|'le'|'ge') expr
equal_expr ::= expr ('=='|'!='|'<=>'|'eq'|'ne'|'cmp'|'~~') expr
bitwise_and_expr ::= expr '&' expr
bitwise_or_xor_expr ::= expr ('|'|'^') expr
and_expr ::= expr '&&' expr
or_expr ::= expr ('||'|'//') expr
flipflop_expr ::= expr ('..'|'...') expr
trenar_expr ::= expr '?' expr ':' expr { rightAssociative=true }
assign_expr ::= expr ('=' | '**='|'+='|'-='| '*='|'/='|'x='| '&='|'|='|'.='| '<<='|'>>='|'%='| '&&='|'||='|'^='| '//=') expr { rightAssociative=true }

comma_expr ::= expr (','|'=>') [scalar_expr]

rightward_call_expr ::= callable !"(" [<<parseExpressionLevel 3>>]
lp_not_expr ::= 'not' expr { rightAssociative=true }
lp_and_expr ::= expr 'and' expr
lp_or_xor_expr ::= expr ('or'|'xor') expr

private scalar_expr ::= <<parseExpressionLevel 4>>

private print_term ::= ("print"|"say") ( "(" [print_arguments] ")" | [print_arguments] ) {pin=1}
private print_arguments ::= perl_handle expr | expr

private open_term ::= ("open") ( "(" open_arguments ")" | open_arguments ) {pin=1}
private open_arguments ::=
    open_handle [                       // open FILEHANDLE
        "," (
            open_mode "," (
                open_ref                // open FILEHANDLE,MODE,REFERENCE
                | open_file ["," expr]  // open FILEHANDLE,MODE,EXPR,LIST ?
            )
            | open_file                 // open FILEHANDLE,EXPR
        )
    ]
open_handle ::= variable_declaration | perl_handle
open_mode ::= scalar_expr
open_ref ::= ref_expr
open_file ::= perl_handle | scalar_expr

sort_term ::= 'sort' sort_op_arguments
private sort_op_arguments ::=
    <<parseBarewordFunction>> expr
    | block_safe expr
    | expr

grep_term ::= 'grep' grep_map_arguments
map_term ::= 'map' grep_map_arguments
private grep_map_arguments ::=
    "(" grep_map_arguments_variations ")"
    | grep_map_arguments_variations

private grep_map_arguments_variations ::=
    block_safe expr
    | scalar_expr "," expr

private function_call ::= callable "(" [expr] ")"

file_read_term ::= '<' [perl_handle] '>'

////////////////////////// regular expressions /////////////////////////////////////////////////////////////////////////
private regex_term ::=
    compile_regex
    | replacement_regex
    | tr_regex
    | match_regex

compile_regex ::= 'qr' match_regex_body
match_regex ::= ['m'] match_regex_body
private match_regex_body ::= PERL_REGEX_QUOTE [perl_regex] PERL_REGEX_QUOTE [perl_regex_modifiers]
replacement_regex ::= 's' PERL_REGEX_QUOTE [perl_regex] PERL_REGEX_QUOTE regex_replacement [perl_regex_modifiers]

private regex_replacement ::=
    PERL_REGEX_QUOTE [perl_regex] PERL_REGEX_QUOTE
    | [perl_regex] PERL_REGEX_QUOTE

perl_regex_modifiers ::= PERL_REGEX_MODIFIER +
perl_regex ::= PERL_REGEX_TOKEN + // here we should make a trick

tr_regex ::= ('tr'|'y') PERL_REGEX_QUOTE tr_searchlist PERL_REGEX_QUOTE [PERL_REGEX_QUOTE] tr_replacementlist PERL_REGEX_QUOTE [tr_modifiers]
tr_searchlist ::= PERL_STRING_CONTENT
tr_replacementlist ::= PERL_STRING_CONTENT

tr_modifiers ::= PERL_REGEX_MODIFIER +
////////////////////////// end of regular expressions //////////////////////////////////////////////////////////////////

do_term ::= "do" block_safe
eval_term ::= "eval" block_safe

private variable_declaration ::=
    variable_declaration_global
    | variable_declaration_lexical
    | variable_declaration_local

// @todo attributes support
// @todo local variables supports hash/aray elements
variable_declaration_local ::= 'local' [perl_package]  variable_definition_variation
variable_declaration_lexical ::= ('my' | 'state') [perl_package] variable_definition_variation
variable_declaration_global ::= 'our' [perl_package] variable_definition_variation

private variable_definition_variation ::=
    '(' variable (',' variable ) * ')'
    | variable

/////////////////////////////////// REFERENCES /////////////////////////////////////////////////////////////////////////
// most of the references created by \ operator, but some - don't
reference_value ::=
    anon_array_ref
    | anon_hash_ref
    | code_ref
    | glob_item_ref

private anon_array_ref ::= '[' [expr] ']'
private anon_hash_ref ::= '{' [expr] '}'
private code_ref ::= "sub" block_safe
private glob_item_ref ::= PERL_GLOB "{" glob_item_ref_variant "}"
private glob_item_ref_variant ::=
    "SCALAR"
    | "ARRAY"
    | "HASH"
    | "CODE"
    | "IO"
    | "GLOB"
    | "FORMAT"
    | "NAME"
    | "PACKAGE"

//////////////////////////// END OF REFERENCES /////////////////////////////////////////////////////////////////////////

private variable ::= scalar | array | hash | PERL_GLOB

private array ::=
    array_primitive '[' expr ']'              // array slice
    | array_primitive '{' expr '}'              // hash slice
    | array_primitive

private hash ::=
    PERL_SIGIL_HASH '{' expr '}'   // hash dereference w braces
    | PERL_SIGIL_HASH scalar_expr       // scalar dereference wo braces
    | PERL_HASH                    // hash as is

private scalar ::=
    PERL_SCALAR nested_element    // hash or array item
    | PERL_SCALAR
    | PERL_SIGIL_SCALAR "{" PERL_BAREWORD "}"
    | "(" expr ")" nested_element
    | 'undef'

private nested_element ::=
    "{" PERL_BAREWORD  "}"
    | "{" expr  "}"
    | "[" expr "]"

// extended nested element for using in ()
private nested_element_expr ::=
    nested_element
    | "(" [expr] ")"    // function call like $var->()
    | scalar_call
    | function_call
    | rightward_call_expr

scalar_call ::= PERL_SCALAR "(" [expr] ")"

///////////////////////////////////// CALLABLE /////////////////////////////////////////////////////////////////////////

callable ::=
    referencable_method
    | <<guessBarewordCallable>>

private referencable_method ::= '&'
    (
        <<guessBarewordCallable>>
        | {expr}
        | scalar
    )

////////////////////////////////END OF CALLABLE ////////////////////////////////////////////////////////////////////////


// primitives
private scalar_primitive ::=
    PERL_NUMBER
    | PERL_TAG  // __PACKAGE__ etc.
    | string

private array_primitive ::=
    string_list
    | PERL_SIGIL_ARRAY '{' expr '}'   // scalar dereference
    | PERL_SIGIL_ARRAY scalar_expr       // scalar dereference
    | PERL_ARRAY                    // array as is

private string ::= string_quoted | multiline_marker | <<parseBarewordString>>
private string_quoted ::= ['qq' | 'qx' | 'q'] PERL_QUOTE <<parseBarewordString>> PERL_QUOTE
private multiline_marker ::= '<<' (string | <<parseBarewordString>>)

private string_list ::= 'qw' PERL_QUOTE <<parseBarewordString>> * PERL_QUOTE

label_declaration ::= label ":" // do we need to change tokentype?
label ::= PERL_BAREWORD
private perl_version ::= <<parseVersion>>
private perl_package ::= <<parseBarewordPackage>>
private perl_handle ::= <<parseBarewordHandle>> | PERL_SCALAR !PERL_OPERATOR | "{" scalar "}"

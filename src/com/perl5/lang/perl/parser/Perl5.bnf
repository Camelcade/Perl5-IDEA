{
  parserClass="com.perl5.lang.perl.parser.PerlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

//  generate=[tokens="yes" psi="yes" tokenAccessors="yes"]

  psiClassPrefix="Perl"
  psiImplClassSuffix="Impl"
  psiPackage="com.perl5.lang.perl.psi"
  psiImplPackage="com.perl5.lang.perl.psi.impl"

  elementTypeHolderClass="com.perl5.lang.perl.lexer.PerlElementTypes"
  elementTypeClass="com.perl5.lang.perl.PerlElementType"
  tokenTypeClass="com.perl5.lang.perl.PerlTokenType"

  parserUtilClass="com.perl5.lang.perl.parser.PerlParserUitl"
  psiImplUtilClass="com.perl5.lang.perl.psi.impl.PerlPsiImpUtil"

  //elementTypeFactory="com.perl5.lang.perl.psi.PerlElementFactory.getCompositeType"
//  tokenTypeFactory="com.perl5.lang.perl.psi.PerlElementFactory.getCompositeType"

  tokens=[
    PERL_COMMENT="PERL_COMMENT"
    PERL_COMMENT_BLOCK="PERL_COMMENT_BLOCK"
    PERL_POD="PERL_POD"

    PERL_SIGIL_ARRAY="@"
    PERL_SIGIL_HASH="%"
    PERL_SIGIL_SCALAR="$"

    PERL_SCALAR="PERL_SCALAR"
    PERL_ARRAY="PERL_ARRAY"
    PERL_HASH="PERL_HASH"
    PERL_GLOB="PERL_GLOB"

    PERL_STRING_MULTILINE="PERL_STRING_MULTILINE" // should be string content too
    PERL_STRING_MULTILINE_END="PERL_STRING_MULTILINE_END"

    PERL_VERSION="PERL_VERSION"
    PERL_NUMBER_VERSION="PERL_NUMBER_VERSION"
    PERL_NUMBER="PERL_NUMBER"

    PERL_KEYWORD="PERL_KEYWORD"
    PERL_FILEHANDLE="PERL_FILEHANDLE"

    PERL_OPERATOR="PERL_OPERATOR"
    PERL_OPERATOR_UNARY="PERL_OPERATOR_UNARY"
    PERL_OPERATOR_FILETEST="PERL_OPERATOR_FILETEST"

    PERL_REGEX_QUOTE="PERL_REGEX_QUOTE"
    PERL_REGEX_MODIFIER="PERL_REGEX_MODIFIER"
    PERL_REGEX_TOKEN="PERL_REGEX_TOKEN"

    PERL_STRING="PERL_STRING"
    PERL_STRING_CONTENT="PERL_STRING_CONTENT"

    PERL_BAREWORD="PERL_BAREWORD"
    PERL_TAG="PERL_TAG"

    PERL_COMMA=','
    PERL_ARROW_COMMA='=>'
    PERL_DEREFERENCE='->'
    PERL_DEPACKAGE='::'
    PERL_COLON=":"
    PERL_LBRACK='['
    PERL_RBRACK=']'
    PERL_LPAREN='('
    PERL_RPAREN=')'
    PERL_LBRACE='{'
    PERL_RBRACE='}'
    PERL_LANGLE='<'
    PERL_RANGLE='>'
    PERL_SEMI=';';
    PERL_QUOTE="\""

    // custom tokens
    PERL_PACKAGE="PERL_PACKAGE"
    PERL_FUNCTION="PERL_FUNCTION"
    PERL_HADLE="PERL_HANDLE"
  ]

    extends(".*expr")=expr
 }

///////////////////////////// main code structure //////////////////////////////////////////////////////////////////////
private perlFile ::= <<parseFile>> <<eof>>

private file_items ::= file_item*

private block_safe ::= <<parseBlock>>
block ::= "{" file_items "}" {pin=1} // should not be used anywhere, injected by block_safe


private file_item ::= package_namespace | package_namespace_item
private package_namespace_item ::= sub_definition | compound_statement PERL_SEMI ? | statement

// package keyword
package_namespace ::= 'package' <<parsePerlPackage>> {pin=1}
private package_plain ::= package_namespace_item * // injected and wrapped by parsePackageContents

// declarations
compound_statement ::=
    label_declaration ? (
        block_compound
        | if_compound
        | unless_compound
        | given_compound
        | while_compound
        | until_compound
        | for_compound
        | foreach_compound
     )

if_compound ::= 'if' compound_conditional_block if_compound_elsif * if_compound_else ?
unless_compound ::= 'unless' compound_conditional_block if_compound_elsif * if_compound_else ?
private if_compound_elsif ::= 'elsif' compound_conditional_block
private if_compound_else  ::= 'else' block_safe

private compound_conditional_block ::= '(' expr ')' block_safe

given_compound ::= 'given' compound_conditional_block

while_compound ::= 'while' compound_conditional_block compound_continue_block ?
until_compound ::= 'until' compound_conditional_block compound_continue_block ?

private compound_continue_block ::= 'continue' block_safe

block_compound ::= block_safe compound_continue_block ?


// for/foreach
for_compound ::= 'for' for_compound_arguments
foreach_compound ::= 'foreach' for_compound_arguments
private for_compound_arguments ::= for_compound_arguments_iteration | for_compound_arguments_list

private for_compound_arguments_iteration ::= '(' expr ? PERL_SEMI expr ? PERL_SEMI expr ? ')' block_safe

// @todo only single variable or variable definition may be here
private for_compound_arguments_list ::=
    (variable_declaration | variable ) ? '(' expr ')' block_compound


private statement ::= statement_variation statement_modifier ? (<<statementSemi>>|<<eof>>) //{recoverWhile=recover_statement}

private statement_variation ::=
    use_statement
    | no_statement
    | undef_statement
    | last_statement
    | next_statement
    | redo_statement
    | require_statement
    | sub_declaration
    | expr

sub_definition ::= 'sub' <<parseSubDefinition>>

private sub_definition_parameters ::=
    sub_prototype sub_attributes ?
    | sub_attributes sub_signature ?
    | sub_signature

sub_declaration ::= 'sub' <<parseSubDeclaration>>
private sub_declaration_parameters ::=  sub_prototype ? sub_attributes ?

private sub_prototype ::= "(" <<parseSubPrototype>> ")"
private sub_signature ::= "(" <<parseSubSignature>> ")"
private sub_attributes ::= ":" <<parseSubAttributes>>


last_statement ::= 'last' lnr_param ?
next_statement ::= 'next' lnr_param ?
redo_statement ::= 'redo' lnr_param ?
private lnr_param ::= label | expr


private statement_modifier ::=
    if_statement_modifier
    | unless_statement_modifier
    | while_statement_modifier
    | until_statement_modifier
    | for_statement_modifier
    | foreach_statement_modifier
    | when_statement_modifier

if_statement_modifier ::= 'if' expr {pin=1}
unless_statement_modifier ::=  'unless' expr {pin=1}
while_statement_modifier ::=  'while' expr {pin=1}
until_statement_modifier ::=  'until' expr {pin=1}
for_statement_modifier ::=  'for' expr  {pin=1}   // actually @LIST
foreach_statement_modifier ::=  'foreach' expr {pin=1} // actually @LIST
when_statement_modifier ::= 'when' expr {pin=1}


use_statement ::= 'use' <<parseUseStatement>> {pin=1}
no_statement ::= 'no' <<parseNoStatement>> {pin=1}

undef_statement ::= "undef" variable {pin=1}

require_statement ::= 'require' (perl_package | perl_version | string)  {pin=1} // multiline string is possible too

//private recover_statement ::= !(PERL_SEMI | PERL_RBRACE | <<eof>>)
//private recover_block ::= !(PERL_RBRACE | <<eof>>)

// expression
expr ::=
    op_24_expr
    | op_23_expr
    | op_22_expr
    | op_21_expr
    | op_20_expr
    | op_19_expr
    | op_18_expr
    | op_17_expr
    | op_16_expr
    | op_15_expr
    | op_14_expr
    | op_13_expr
    | op_12_expr
    | op_11_expr
    | op_10_expr
    | op_9_expr
    | op_8_expr
    | op_7_expr
    | op_6_expr
    | op_5_expr
    | op_4_expr
    | op_3_expr
    | op_2_expr
    | op_1_expr

op_1_expr ::= term
op_2_expr ::= expr '->' ? nested_element    //  @todo this arrow should be optional only after } or ], need function to parse this, too may variants

private op_3_expr ::= op_3_pref_expr | op_3_suff_expr
op_3_pref_expr ::= ('++'|'--') expr
op_3_suff_expr ::= expr ('++'|'--')

op_4_expr ::= expr ('**' expr)+ { rightAssociative=true }

private op_5_expr ::= op_5_ref_expr | op_5_other_expr // !PERL_BAREWORD - removed cause !function
op_5_ref_expr ::= '\' expr { rightAssociative=true }
op_5_other_expr ::= ('~'| '!'| '+' | '-') expr { rightAssociative=true }

op_6_expr ::= expr ('=~'|'!~') expr
op_7_expr ::= expr ('*'|'/'|'%'|'x') expr
op_8_expr ::= expr ('+'|'-'|'.') !PERL_BAREWORD expr
op_9_expr ::= expr ('<<'|'>>') expr

op_10_expr ::= op_10_expr_unary | op_10_expr_filetest
private op_10_expr_unary ::= PERL_OPERATOR_UNARY !"(" expr
private op_10_expr_filetest ::= PERL_OPERATOR_FILETEST (<<parseBarewordHandle>> | expr )

op_11_expr ::= expr ('>='|'<='|'<'|'>'|'lt'|'gt'|'le'|'ge') expr
op_12_expr ::= expr ('=='|'!='|'<=>'|'eq'|'ne'|'cmp'|'~~') expr
op_13_expr ::= expr '&' expr
op_14_expr ::= expr ('|'|'^') expr
op_15_expr ::= expr '&&' expr
op_16_expr ::= expr ('||'|'//') expr
op_17_expr ::= expr ('..'|'...') expr
op_18_expr ::= expr '?' expr ':' expr { rightAssociative=true }
op_19_expr ::= expr ('=' | '**='|'+='|'-='| '*='|'/='|'x='| '&='|'|='|'.='| '<<='|'>>='|'%='| '&&='|'||='|'^='| '//=') expr { rightAssociative=true }

op_20_expr ::= expr (','|'=>') scalar_expr ?

op_21_expr ::= callable !"(" <<parseExpressionLevel 3>> ?
op_22_expr ::= 'not' expr { rightAssociative=true }
op_23_expr ::= expr 'and' expr
op_24_expr ::= expr ('or'|'xor') expr

private scalar_expr ::= <<parseExpressionLevel 4>>

private term ::=
    variable
    | variable_declaration
    | PERL_OPERATOR_UNARY "(" expr ? ")" // named operators as functions
    | "(" expr ? ")"
    | scalar_primitive
    | do_term
    | eval_term
    | regex_term
    | file_read_term
    | reference_value
    | print_term
    | open_term
    | grep_term
    | sort_term
    | map_term
    | function_call


private print_term ::= ("print"|"say") ( "(" print_arguments ? ")" | print_arguments ? ) {pin=1}
private print_arguments ::= perl_handle expr | expr

private open_term ::= ("open") ( "(" open_arguments ")" | open_arguments ) {pin=1}
private open_arguments ::=
    open_handle [                       // open FILEHANDLE
        "," (
            open_mode "," (
                open_ref                // open FILEHANDLE,MODE,REFERENCE
                | open_file ["," expr]  // open FILEHANDLE,MODE,EXPR,LIST ?
            )
            | open_file                 // open FILEHANDLE,EXPR
        )
    ]
open_handle ::= variable_declaration | perl_handle
open_mode ::= scalar_expr
open_ref ::= op_5_ref_expr
open_file ::= perl_handle | scalar_expr

sort_term ::= 'sort' sort_op_arguments
private sort_op_arguments ::=
    <<parseBarewordFunction>> expr
    | block_safe expr
    | expr

grep_term ::= 'grep' grep_map_arguments
map_term ::= 'map'grep_map_arguments
private grep_map_arguments ::=
    block_safe expr
    | scalar_expr expr

private function_call ::= callable "(" expr ? ")"

file_read_term ::= '<' perl_handle ? '>'

////////////////////////// regular expressions /////////////////////////////////////////////////////////////////////////
private regex_term ::=
    compile_regex
    | replacement_regex
    | tr_regex
    | match_regex

compile_regex ::= 'qr' match_regex_body
match_regex ::= 'm'? match_regex_body
private match_regex_body ::= PERL_REGEX_QUOTE perl_regex ? PERL_REGEX_QUOTE perl_regex_modifiers ?
replacement_regex ::= 's' PERL_REGEX_QUOTE perl_regex ? PERL_REGEX_QUOTE regex_replacement perl_regex_modifiers ?

private regex_replacement ::=
    PERL_REGEX_QUOTE perl_regex ? PERL_REGEX_QUOTE
    | perl_regex ? PERL_REGEX_QUOTE

perl_regex_modifiers ::= PERL_REGEX_MODIFIER +
perl_regex ::= PERL_REGEX_TOKEN + // here we should make a trick

tr_regex ::= ('tr'|'y') PERL_REGEX_QUOTE tr_searchlist PERL_REGEX_QUOTE PERL_REGEX_QUOTE ? tr_replacementlist PERL_REGEX_QUOTE tr_modifiers ?
tr_searchlist ::= PERL_STRING_CONTENT
tr_replacementlist ::= PERL_STRING_CONTENT

tr_modifiers ::= PERL_REGEX_MODIFIER +
////////////////////////// end of regular expressions //////////////////////////////////////////////////////////////////

do_term ::= "do" block_safe
eval_term ::= "eval" block_safe

private variable_declaration ::=
    variable_declaration_global
    | variable_declaration_lexical
    | variable_declaration_local

// @todo attributes support
// @todo local variables supports hash/aray elements
variable_declaration_local ::= 'local' perl_package ?  variable_definition_variation
variable_declaration_lexical ::= ('my' | 'state') perl_package ? variable_definition_variation
variable_declaration_global ::= 'our' perl_package ? variable_definition_variation

private variable_definition_variation ::=
    '(' variable (',' variable ) * ')'
    | variable

/////////////////////////////////// REFERENCES /////////////////////////////////////////////////////////////////////////
// most of the references created by \ operator, but some - don't
reference_value ::=
    anon_array_ref
    | anon_hash_ref
    | code_ref
    | glob_item_ref

private anon_array_ref ::= '[' expr ? ']'
private anon_hash_ref ::= '{' expr ? '}'
private code_ref ::= "sub" block_safe
private glob_item_ref ::= PERL_GLOB "{" glob_item_ref_variant "}"
private glob_item_ref_variant ::=
    "SCALAR"
    | "ARRAY"
    | "HASH"
    | "CODE"
    | "IO"
    | "GLOB"
    | "FORMAT"
    | "NAME"
    | "PACKAGE"

//////////////////////////// END OF REFERENCES /////////////////////////////////////////////////////////////////////////

private variable ::= scalar | array | hash | PERL_GLOB

private array ::=
    array_primitive '[' expr ']'              // array slice
    | array_primitive '{' expr '}'              // hash slice
    | array_primitive

private hash ::=
    PERL_SIGIL_HASH '{' expr '}'   // hash dereference w braces
    | PERL_SIGIL_HASH scalar_expr       // scalar dereference wo braces
    | PERL_HASH                    // hash as is

private scalar ::=
    PERL_SCALAR nested_element    // hash or array item
    | PERL_SCALAR
    | PERL_SIGIL_SCALAR "{" PERL_BAREWORD "}"
    | 'undef'

private nested_element ::=
    "{" PERL_BAREWORD  "}"
    | "{" expr  "}"
    | "[" PERL_NUMBER  "]"
    | "[" expr "]"
    | function_call     // @todo this should be handled differently, left token should be a package if it's bareword

///////////////////////////////////// CALLABLE /////////////////////////////////////////////////////////////////////////

callable ::=
    referencable_method
    | <<guessBareword>>

private referencable_method ::= '&'
    (
        <<guessBareword>>
        | {expr}
        | scalar
    )

////////////////////////////////END OF CALLABLE ////////////////////////////////////////////////////////////////////////


// primitives
private scalar_primitive ::=
    PERL_NUMBER
    | PERL_TAG  // __PACKAGE__ etc.
    | string

private array_primitive ::=
    string_list
    | PERL_SIGIL_ARRAY '{' expr '}'   // scalar dereference
    | PERL_SIGIL_ARRAY scalar_expr       // scalar dereference
    | PERL_ARRAY                    // array as is

private string ::= string_quoted | multiline_marker
private string_quoted ::= ('qq' | 'qx' | 'q') ? PERL_QUOTE <<parseBarewordString>> PERL_QUOTE
private multiline_marker ::= '<<' (string | <<parseBarewordString>>)

private string_list ::= 'qw' PERL_QUOTE <<parseBarewordString>> * PERL_QUOTE

label_declaration ::= label ":" // do we need to change tokentype?
label ::= PERL_BAREWORD
private perl_version ::= <<parseVersion>>
private perl_package ::= <<parseBarewordPackage>>
private perl_handle ::= <<parseBarewordHandle>> | PERL_SCALAR !PERL_OPERATOR | "{" scalar "}"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//////////////////// list expressions ////////////////////////////
//
//split_expr ::= 'split' split_arguments
//private split_arguments ::=
//    "(" split_args ")"
//    | split_args
//split_args ::= (scalar_expr | regex_expr ) "," scalar_expr
//
//
//shift_expr ::= ('shift' | 'pop') shift_expr_args ?
//private shift_expr_args ::= list_expr | expr
//
//
//// keys && values
//keys_expr ::= ('keys' | 'values' ) keys_args
//keys_args ::=
//    '(' (hash | array) ')'
//    | (hash | array)
//
//// grep
//
//
//
//
//scalar_nested_element ::= scalar structure_element+
//
//
//private scalar ::=
//    PERL_SIGIL_SCALAR '{' PERL_BAREWORD '}'       // scalar dereference
//    | PERL_SIGIL_SCALAR '{' expr '}'       // scalar dereference
//    | PERL_SCALAR                          // scalar as is
//    | PERL_NUMBER                       // raw number
//    | PERL_GLOB
//    | scalar_anon_array
//    | scalar_anon_hash
//    | scalar_generated_list_item
//    | multiline_marker                  // deferred string
//    | string                            // string
//    | sub_block_anon
//    | referencable_method
//    | 'undef'
//
//private nested_element ::= array_element | hash_element
//private array_element ::= '[' expr ']'
//private hash_element ::= '{' ( expr | PERL_BAREWORD) '}'
//
//
//private scalar_generated_list_item ::= '(' expr ')'[expr]                // generated array element
//
//
//
//private local_variables ::= local_variable (',' local_variables ) *
//private local_variable ::= expr | variable
//
//private variables ::= variable (',' variable ) *
//private variable ::= PERL_SCALAR | PERL_ARRAY | PERL_HASH | PERL_GLOB | "undef"
//
//// custom parsings
//
////private package_bare ::= PERL_BAREWORD ( '::' PERL_BAREWORD ) *
//// {   mixin="com.perl5.lang.perl.psi.impl.PerlNamedElementImpl"
////        implements="com.perl5.lang.perl.psi.PerlNamedElement"
////        methods=[getName setName getNameIdentifier]
////    }
//

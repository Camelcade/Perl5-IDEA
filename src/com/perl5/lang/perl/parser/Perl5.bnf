/*
Copyright 2015 Alexandr Evstigneev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
{
  parserClass="com.perl5.lang.perl.parser.PerlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

//  generate=[tokens="yes" psi="yes" tokenAccessors="yes"]

  psiClassPrefix="Perl"
  psiImplClassSuffix="Impl"
  psiPackage="com.perl5.lang.perl.psi"
  psiImplPackage="com.perl5.lang.perl.psi.impl"

  elementTypeHolderClass="com.perl5.lang.perl.lexer.PerlElementTypes"
  elementTypeClass="com.perl5.lang.perl.PerlElementType"
  tokenTypeClass="com.perl5.lang.perl.PerlTokenType"

  parserUtilClass="com.perl5.lang.perl.parser.PerlParserUitl"
  psiImplUtilClass="com.perl5.lang.perl.psi.impl.PerlPsiImplUtil"

  //elementTypeFactory="com.perl5.lang.perl.psi.PerlElementFactory.getCompositeType"
//  tokenTypeFactory="com.perl5.lang.perl.psi.PerlElementFactory.getCompositeType"

  tokens=[
    PERL_COMMENT="PERL_COMMENT"
    PERL_COMMENT_BLOCK="PERL_COMMENT_BLOCK"
    PERL_POD="PERL_POD"

    PERL_SUB_PROTOTYPE_TOKEN="PERL_SUB_PROTOTYPE_TOKEN"

    PERL_SIGIL_ARRAY="@"
    PERL_SIGIL_HASH="%"
    PERL_SIGIL_SCALAR="$"

    PERL_SIGIL_SCALAR_INDEX="$#"
    PERL_VARIABLE_NAME="PERL_VARIABLE_NAME"

//    PERL_SCALAR_NAME="SCALAR_NAME"
//    PERL_ARRAY_NAME="ARRAY_NAME"
//    PERL_HASH_NAME="HASH_NAME"

//    PERL_ARRAY="ARRAY"
//    PERL_HASH="HASH"
//    PERL_SCALAR="SCALAR"
//    PERL_GLOB="GLOB"
//     PERL_SIGIL="SIGIL"


    PERL_ARRAY_BUILT_IN="ARRAY_BUILT_IN"
    PERL_HASH_BUILT_IN="HASH_BUILT_IN"
    PERL_SCALAR_BUILT_IN="SCALAR_BUILT_IN"
    PERL_GLOB_BUILT_IN="GLOB_BUILT_IN"

//    PERL_SCALAR_INDEX="SCALAR_INDEX"

    PERL_HEREDOC="PERL_HEREDOC" // should be string content too
    PERL_HEREDOC_END="PERL_HEREDOC_END"

    PERL_VERSION="PERL_VERSION"
    PERL_NUMBER_VERSION="PERL_NUMBER_VERSION"
    PERL_NUMBER="PERL_NUMBER"

    PERL_KEYWORD="PERL_KEYWORD"
    PERL_RESERVED="PERL_RESERVED"

    PERL_OPERATOR="PERL_OPERATOR"
    PERL_OPERATOR_NOT="not"
    PERL_OPERATOR_X="x"

    PERL_OPERATOR_UNARY="PERL_OPERATOR_UNARY"
    PERL_OPERATOR_FILETEST="PERL_OPERATOR_FILETEST"

    PERL_REGEX_QUOTE="PERL_REGEX_QUOTE"
    PERL_REGEX_MODIFIER="PERL_REGEX_MODIFIER"
    PERL_REGEX_TOKEN="PERL_REGEX_TOKEN"

//    PERL_STRING="PERL_STRING"
    PERL_STRING_CONTENT="PERL_STRING_CONTENT"

    PERL_TAG="PERL_TAG"

    PERL_COMMA=','
    PERL_ARROW_COMMA='=>'
    PERL_DEREFERENCE='->'
    PERL_DEPACKAGE='::'
    PERL_COLON=":"
    PERL_LBRACK='['
    PERL_RBRACK=']'
    PERL_LPAREN='('
    PERL_RPAREN=')'
    PERL_LBRACE='{'
    PERL_RBRACE='}'
    PERL_LANGLE='<'
    PERL_RANGLE='>'
    PERL_SEMI=';';
    PERL_QUOTE="\""

    // custom tokens
    PERL_FUNCTION_ATTRIBUTE="PERL_FUNCTION_ATTRIBUTE"

    PERL_PACKAGE="PERL_PACKAGE"
    PERL_PACKAGE_BUILT_IN="PERL_PACKAGE_BUILT_IN"
    PERL_PACKAGE_DEPRECATED="PERL_PACKAGE_DEPRECATED"
    PERL_PACKAGE_PRAGMA="PERL_PACKAGE_PRAGMA"

    PERL_FUNCTION="PERL_FUNCTION"
    PERL_FUNCTION_BUILT_IN="PERL_FUNCTION_BUILT_IN"
    PERL_HANDLE="PERL_HANDLE"
    PERL_HANDLE_BUILT_IN="PERL_HANDLE_BUILT_IN"
    PERL_BLOCK_NAME="PERL_BLOCK_NAME"
    PERL_LABEL="PERL_LABEL"

    // inline HTML support
    TEMPLATE_BLOCK_HTML="TEMPLATE_BLOCK_HTML"
    EMBED_MARKER="EMBED_MARKER"

    HEREDOC_SQL="HEREDOC_SQL"
//    TEMPLATE_BLOCK_SQL="TEMPLATE_BLOCK_SQL"
  ]

    extends(".*expr")=expr

    implements("conditional_block|block|block_compound|if_compound|unless_compound|given_compound|while_compound|until_compound|for_compound|foreach_compound|namespace_definition")="com.perl5.lang.perl.psi.PerlLexicalScope";

    implements("variable_declaration_lexical|variable_declaration_local")="com.perl5.lang.perl.psi.PerlVariableDeclaration"
    mixin("variable_declaration_lexical|variable_declaration_local|conditional_block|block|block_compound|if_compound|unless_compound|given_compound|while_compound|until_compound|for_compound|foreach_compound|namespace_definition")="com.perl5.lang.perl.psi.impl.PerlLexicalScopeElementMixin"

    mixin("perl_scalar|perl_array|perl_hash")="com.perl5.lang.perl.psi.impl.PerlVariableImpleMixin"
    implements("perl_scalar|perl_array|perl_hash")="com.perl5.lang.perl.psi.PerlVariable"


    elementTypeFactory("sub_definition|perl_glob")="com.perl5.lang.perl.parser.PerlElementTypeFactory.factory"

    stubClass("sub_definition")="com.perl5.lang.perl.stubs.subs.definitions.PerlSubDefinitionStub"
    mixin("sub_definition")="com.perl5.lang.perl.psi.impl.PerlSubDefinitionImplMixin"
    implements("sub_definition")="com.perl5.lang.perl.psi.PerlPackagedElement,com.perl5.lang.perl.psi.PerlLexicalScope"

    stubClass("perl_glob")="com.perl5.lang.perl.stubs.globs.PerlGlobStub"
    mixin("perl_glob")="com.perl5.lang.perl.psi.impl.PerlPerlGlobImplMixin"
    implements("perl_glob")="com.perl5.lang.perl.psi.PerlPackagedElement,com.perl5.lang.perl.psi.IPerlPerlGlobMixin"

    mixin("variable_name")="com.perl5.lang.perl.psi.impl.PerlVariableNameImplMixin"
    implements("variable_name")="com.perl5.lang.perl.psi.PerlNamedElement"

    mixin("namespace")="com.perl5.lang.perl.psi.impl.PerlNamespaceImplMixin";
    implements("namespace")="com.perl5.lang.perl.psi.PerlNamedElement"

    mixin("user_function")="com.perl5.lang.perl.psi.impl.PerlUserFunctionImplMixin"
    implements("user_function")="com.perl5.lang.perl.psi.PerlPackagedElement,com.perl5.lang.perl.psi.PerlNamedElement"

    mixin("method")="com.perl5.lang.perl.psi.impl.PerlMethodImplMixin";
    mixin("object")="com.perl5.lang.perl.psi.impl.PerlObjectImplMixin"
    mixin("heredoc_opener")="com.perl5.lang.perl.psi.impl.PerlHeredocOpenerImplMixin"
 }

///////////////////////////// main code structure //////////////////////////////////////////////////////////////////////
private perlFile ::= file_items <<eof>>

private file_items ::= PERL_SEMI * file_item * {recoverWhile=recover_block}
private file_item ::= namespace_definition | namespace_element

block ::= "{" file_items "}" {pin=1}

private namespace_element ::= (sub_definition | named_block | compound_statement | statement | PERL_SEMI )

// package keyword
namespace_definition ::= "package" namespace [perl_version] (block | PERL_SEMI namespace_content) {pin=1}
private namespace_content ::= namespace_element *  {recoverWhile=recover_namespace}

named_block ::= PERL_BLOCK_NAME block

// declarations
private compound_statement ::=
    [label_declaration] (
        block_compound
        | if_compound
        | unless_compound
        | given_compound
        | while_compound
        | until_compound
        | for_compound
        | foreach_compound
     )

if_compound ::= 'if' conditional_block if_compound_elsif * [if_compound_else] // {pin=1}
unless_compound ::= 'unless' conditional_block if_compound_elsif * [if_compound_else] // {pin=1}
private if_compound_elsif ::= 'elsif' conditional_block  // {pin=1}
private if_compound_else  ::= 'else' unconditional_block // {pin=1}
unconditional_block ::= block

conditional_block ::= condition block
condition ::= '(' expr ')'

given_compound ::= 'given' conditional_block // {pin=1}

while_compound ::= 'while' conditional_block [compound_continue_block] // {pin=1}
until_compound ::= 'until' conditional_block [compound_continue_block] // {pin=1}

private compound_continue_block ::= 'continue' block

private block_compound ::= block [compound_continue_block]


// for/foreach
for_compound ::= 'for' for_arguments // {pin=1}
foreach_compound ::= 'foreach' for_arguments // {pin=1}
private for_arguments ::=
    for_iterator block
    | for_list block_compound

for_iterator ::= '(' [expr]  PERL_SEMI [expr] PERL_SEMI [expr] ')'

// @todo only single variable or variable definition may be here
for_list ::=
    [ variable_declaration | variable ] '(' expr ')'

statement ::= [label_declaration] statement_variation [statement_modifier] <<statementSemi>> {pin=2 recoverWhile=recover_statement}

private statement_variation ::=
    use_statement
    | no_statement
    | require_statement
    | sub_declaration
    | expr

require_statement ::= require_term &(PERL_RESERVED | ';' | '}')

sub_definition ::= "sub" namespace_method_static sub_definition_parameters ? block

private sub_definition_parameters ::=
    sub_prototype [sub_attributes]
    | sub_attributes [sub_signature]
    | sub_signature

sub_declaration ::= "sub" namespace_method_static sub_declaration_parameters
private sub_declaration_parameters ::=  [sub_prototype] [sub_attributes]

private sub_prototype ::= "(" [<<parseSubPrototype>>] ")"
private sub_signature ::= "(" [<<parseSubSignature>>] ")"
private sub_attributes ::= ":" <<parseSubAttributes>>


last_term ::= 'last' [lnr_param]
next_term ::= 'next' [lnr_param]
redo_term ::= 'redo' [lnr_param]
private lnr_param ::= PERL_LABEL | expr


statement_modifier ::=
    if_statement_modifier
    | unless_statement_modifier
    | while_statement_modifier
    | until_statement_modifier
    | for_statement_modifier
    | foreach_statement_modifier
    | when_statement_modifier

if_statement_modifier ::= 'if' expr
unless_statement_modifier ::=  'unless' expr
while_statement_modifier ::=  'while' expr
until_statement_modifier ::=  'until' expr
for_statement_modifier ::=  'for' expr     // actually @LIST
foreach_statement_modifier ::=  'foreach' expr  // actually @LIST
when_statement_modifier ::= 'when' expr


use_statement ::= 'use' use_no_parameters
no_statement ::= 'no' use_no_parameters
private use_no_parameters ::= use_module_parameters | use_version_parameters
private use_module_parameters ::= namespace [perl_version] [expr];
private use_version_parameters ::= perl_version;


undef_term ::= "undef" (variable | "(" variable ")") ?

require_term ::= 'require' (namespace | perl_version | unary_expr)  // multiline string is possible too

// it looks meaningless now, eats nothing
private recover_statement ::= !(
    PERL_RESERVED | PERL_KEYWORD | PERL_FUNCTION | PERL_FUNCTION_BUILT_IN | PERL_OPERATOR_UNARY | PERL_TAG
    | PERL_PACKAGE | PERL_PACKAGE_BUILT_IN | PERL_PACKAGE_DEPRECATED | PERL_PACKAGE_PRAGMA
    | PERL_RBRACE | PERL_LBRACE | PERL_LANGLE
    | PERL_LBRACK
    | PERL_LPAREN
    | PERL_SEMI
    | PERL_QUOTE
    | PERL_SCALAR_BUILT_IN | PERL_ARRAY_BUILT_IN| PERL_HASH_BUILT_IN| PERL_GLOB_BUILT_IN
    | PERL_HANDLE | PERL_HANDLE_BUILT_IN
    | PERL_SIGIL_SCALAR_INDEX | PERL_SIGIL_SCALAR | PERL_SIGIL_ARRAY | PERL_SIGIL_HASH
    | PERL_NUMBER | PERL_OPERATOR| PERL_OPERATOR_FILETEST
    | PERL_LABEL
    | PERL_BLOCK_NAME
    )
private recover_block ::= !(PERL_RBRACE | <<eof>>)
private recover_namespace ::= !( "package" | '}' | <<eof>>)

// expression
expr ::=
    lp_or_xor_expr
    | lp_and_expr
    | lp_not_expr
    | comma_expr
    | assign_expr
    | trenar_expr
    | flipflop_expr
    | or_expr
    | and_expr
    | bitwise_or_xor_expr
    | bitwise_and_expr
    | equal_expr
    | compare_expr
    | op_10_expr
    | shift_expr
    | add_expr
    | mul_expr
    | regex_expr
    | op_5_expr
    | pow_expr
    | op_3_expr
    | deref_expr
    | term_expr


term_expr ::=
    variable_declaration
    | parenthesised_expr "[" expr "]"
    | parenthesised_expr
    | scalar_constant
    | do_term
    | sub_term
    | eval_term
    | regex_term
    | file_read_term
    | print_term
    | open_term
    | close_term
    | grep_term
    | sort_term
    | map_term
    | require_term
    | undef_term
    | last_term
    | next_term
    | return_term
    | redo_term
    | PERL_OPERATOR_UNARY "(" [expr] ")" !"["   // named operators as functions
    | function_call
    | rightward_call
    | reference_value
    | perl_array_index
    | variable
    | namespace


parenthesised_expr ::= '(' [expr] ')'

return_term ::= "return" [list_expr]

deref_expr ::= expr (<<parseArrowSmart>> nested_element_expr) +

private op_3_expr ::= pref_pp_expr | suff_pp_expr
pref_pp_expr ::= ('++'|'--') expr
suff_pp_expr ::= expr ('++'|'--')

pow_expr ::= expr ('**' expr)+ { rightAssociative=true }

private op_5_expr ::= ref_expr  | prefix_unary_expr
ref_expr ::= '\' referencable_expr { rightAssociative=true }
prefix_unary_expr ::=  ('~'| '!'| '+' | '-') expr { rightAssociative=true }

regex_expr ::= expr ('=~'|'!~') expr

mul_expr ::= expr ('*'|'/'|'%'|PERL_OPERATOR_X) expr
add_expr ::= expr ('+'|'-'|'.') expr
shift_expr ::= expr ('<<'|'>>') expr

private op_10_expr ::= named_unary_expr | filetest_expr
named_unary_expr ::= named_undry_expr_defined | named_unary_expr_normal
private named_undry_expr_defined ::= 'defined' !"(" [unary_expr]
private named_unary_expr_normal ::= PERL_OPERATOR_UNARY !"(" unary_expr

private unary_expr ::= <<parseExpressionLevel 13>>


filetest_expr ::= PERL_OPERATOR_FILETEST [(perl_handle | expr )]

compare_expr ::= expr ('>='|'<='|'<'|'>'|'lt'|'gt'|'le'|'ge') expr
equal_expr ::= expr ('=='|'!='|'<=>'|'eq'|'ne'|'cmp'|'~~') expr
bitwise_and_expr ::= expr '&' expr
bitwise_or_xor_expr ::= expr ('|'|'^') expr
and_expr ::= expr '&&' expr
or_expr ::= expr ('||'|'//') expr
flipflop_expr ::= expr ('..'|'...') expr
trenar_expr ::= expr '?' scalar_expr ':' scalar_expr { rightAssociative=true }
assign_expr ::= expr ('=' | '**='|'+='|'-='| '*='|'/='|'x='| '&='|'|='|'.='| '<<='|'>>='|'%='| '&&='|'||='|'^='| '//=') expr { rightAssociative=true }

private comma_expr ::= comma_sequence_expr | comma_last_expr
comma_last_expr ::= expr comma
comma_sequence_expr ::= expr (comma_any expr) +
private comma_any ::= comma + !(")"|"]"|"}")

lp_not_expr ::= PERL_OPERATOR_NOT expr { rightAssociative=true }
lp_and_expr ::= expr 'and' expr
lp_or_xor_expr ::= expr ('or'|'xor') expr

private scalar_expr ::= <<parseExpressionLevel 3>>
private list_expr ::= <<parseExpressionLevel 2>>

print_term ::= ("print"|"printf"|"say") ( "(" [print_arguments] ")" | [print_arguments] ) // {pin=1}
private print_arguments ::= perl_handle expr | expr

open_term ::= "open" ( "(" open_arguments ")" | open_arguments )
private open_arguments ::=
    open_handle comma open_mode comma open_ref  // open FILEHANDLE,MODE,REFERENCE
    | open_handle comma open_mode comma expr    // open FILEHANDLE,MODE,EXPR,LIST ?
    | open_handle [comma expr]                // open FILEHANDLE, EXPR ?

open_handle ::= variable_declaration | perl_handle
open_mode ::= scalar_expr
open_ref ::= ref_expr

close_term ::= "close" ( "(" close_arguments ")" | close_arguments )
private close_arguments ::= perl_handle

sort_term ::= 'sort' ( '(' sort_op_arguments ')'| sort_op_arguments )
private sort_op_arguments ::=
    PERL_FUNCTION expr
    | block expr
    | scalar_expr expr
    | expr

sub_term ::= 'sub' sub_definition_parameters block

grep_term ::= 'grep' grep_map_arguments
map_term ::= 'map' grep_map_arguments
private grep_map_arguments ::=
    "(" grep_map_arguments_variations ")"
    | grep_map_arguments_variations

private grep_map_arguments_variations ::=
    block expr
    | scalar_expr comma expr

function_call ::= callable "(" [call_arguments] ")" !"["  // avoiding ()[]
rightward_call ::= callable [call_arguments]

call_arguments ::=
    anon_hash [comma list_expr]
    | block [[comma] list_expr]
    | list_expr

file_read_term ::= '<' [perl_handle] '>'

////////////////////////// regular expressions /////////////////////////////////////////////////////////////////////////
private regex_term ::=
    compile_regex
    | replacement_regex
    | tr_regex
    | match_regex

compile_regex ::= 'qr' match_regex_body
match_regex ::= ['m'] match_regex_body
private match_regex_body ::= PERL_REGEX_QUOTE [perl_regex] PERL_REGEX_QUOTE [perl_regex_modifiers]
replacement_regex ::= 's' PERL_REGEX_QUOTE [perl_regex] PERL_REGEX_QUOTE regex_replacement [perl_regex_modifiers]

private regex_replacement ::=
    PERL_REGEX_QUOTE [perl_regex] PERL_REGEX_QUOTE
    | [perl_regex] PERL_REGEX_QUOTE

perl_regex_modifiers ::= PERL_REGEX_MODIFIER +
perl_regex ::= PERL_REGEX_TOKEN + // here we should make a trick

tr_regex ::= ('tr'|'y') PERL_REGEX_QUOTE tr_searchlist PERL_REGEX_QUOTE [PERL_REGEX_QUOTE] tr_replacementlist PERL_REGEX_QUOTE [tr_modifiers]
tr_searchlist ::= PERL_STRING_CONTENT
tr_replacementlist ::= PERL_STRING_CONTENT

tr_modifiers ::= PERL_REGEX_MODIFIER +
////////////////////////// end of regular expressions //////////////////////////////////////////////////////////////////

do_term ::= "do" eval_argument
eval_term ::= "eval" eval_argument
private eval_argument ::= '('expr')' | block | expr

private variable_declaration ::=
    variable_declaration_global
    | variable_declaration_lexical
    | variable_declaration_local

// @todo attributes support
variable_declaration_local ::= 'local' [namespace]  local_variable_declaration_variation
variable_declaration_lexical ::= ('my' | 'state') [namespace] variable_declaration_variation
variable_declaration_global ::= 'our' [namespace] variable_declaration_variation

private local_variable_declaration_variation ::=
    '(' local_variable_declaration_argument (comma + local_variable_declaration_argument ) * comma * ')'
    | local_variable_declaration_argument

private local_variable_declaration_argument ::= lexical_variable_definition_argument | scalar_expr

private variable_declaration_variation ::=
    '(' lexical_variable_definition_argument (comma + lexical_variable_definition_argument ) * comma* ')'
    | lexical_variable_definition_argument

private lexical_variable_definition_argument ::= lexical_variable | "undef"

/////////////////////////////////// REFERENCES /////////////////////////////////////////////////////////////////////////
// most of the references created by \ operator, but some - don't
private reference_value ::=
    anon_array
    | anon_hash
    | code_ref

anon_array ::= '[' [expr] ']'
anon_hash ::= '{' [expr] '}'
code_ref ::= "sub" block

//////////////////////////// END OF REFERENCES /////////////////////////////////////////////////////////////////////////

// fixme it's not a variable, its variable expression
private variable ::= scalar | array | hash | glob

private array ::=
    PERL_SIGIL_ARRAY '{' expr '}'   // scalar dereference
    | array_array_slice              // array slice
    | array_hash_slice              // hash slice
    | array_variable
    | array_constant

array_array_slice ::= array_variable '[' expr ']'
array_hash_slice ::= array_variable '{' expr '}'

private hash ::=
    PERL_SIGIL_HASH '{' expr '}'      // hash dereference w braces
    | hash_variable                    // hash as is

private scalar ::=
    PERL_SIGIL_SCALAR + "{" expr "}"
    | scalar_array_element
    | scalar_hash_element
    | scalar_variable
    | scalar_array_index
    | scalar_constant
    | scalar_anon_array_element
    | undef_term
    | PERL_SIGIL_SCALAR_INDEX PERL_SIGIL_SCALAR * ( '{' expr '}' | scalar_variable )
    | perl_handle_basic

scalar_array_index ::= PERL_SIGIL_SCALAR_INDEX PERL_SIGIL_SCALAR * scalar_variable
scalar_array_element ::= scalar_variable "[" expr "]"
scalar_hash_element ::= scalar_variable ( "{" expr "}" | braced_string )
scalar_anon_array_element ::= "(" expr ")" "["expr"]"

private glob ::=
    "*" "{" expr "}"     // @todo we need to colorize this as glob
    | glob_variable                    // hash as is

private nested_element ::=
    braced_string
    | "{" expr "}"
    | "[" expr "]"

// extended nested element for using in ()
private nested_element_expr ::=
    nested_element
    | "(" [expr] ")"    // function call like $var->()
    | scalar_call
    | function_call
    | rightward_call
    | scalar

scalar_call ::= scalar_variable ["(" [expr] ")"]

///////////////////////////////////// CALLABLE /////////////////////////////////////////////////////////////////////////

private callable ::= method | referencable_method
//<<resetLastCallable>> (
//
//    |
//)

private referencable_expr ::= referencable_method | scalar_expr
private referencable_method ::= '&'
    (
        method
        | "{"method"}"
        | "{"expr"}"
        | scalar
    )

////////////////////////////////END OF CALLABLE ////////////////////////////////////////////////////////////////////////

label_declaration ::= PERL_LABEL ":" // do we need to change tokentype?
private perl_version ::= PERL_NUMBER_VERSION | PERL_NUMBER
private perl_handle ::=  perl_handle_basic | "{" scalar_expr "}" | <<parseExpressionLevel 21>>
private perl_handle_basic ::= PERL_HANDLE | PERL_HANDLE_BUILT_IN

//////////////////////////////////// constants /////////////////////////////////////////////////////////////////////////

private scalar_constant ::=
    PERL_NUMBER
    | PERL_TAG  // __PACKAGE__ etc.
    | string

braced_string ::= "{" PERL_STRING_CONTENT "}"

private array_constant ::=
    string_list

private string ::= string_sq | string_dq | string_xq | heredoc_opener

private string_quoted ::= PERL_QUOTE [PERL_STRING_CONTENT] PERL_QUOTE
string_dq ::=
    "\"" [PERL_STRING_CONTENT] "\""
     | "qq" string_quoted

string_sq ::=
    "'" [PERL_STRING_CONTENT] "'"
    | "q" string_quoted
    | PERL_STRING_CONTENT

string_xq ::=
    "`" [PERL_STRING_CONTENT] "`"
    | "qx" string_quoted

heredoc_opener ::= '<<' ( string_xq | string_dq | string_sq | PERL_STRING_CONTENT )

string_list ::= 'qw' PERL_QUOTE PERL_STRING_CONTENT * PERL_QUOTE

///////////////////////////////////// variables ////////////////////////////////////////////////////////////////////////
private lexical_variable ::= scalar_variable | array_variable | hash_variable

perl_array_index ::= PERL_SIGIL_SCALAR_INDEX PERL_SIGIL_SCALAR * variable_body

private scalar_variable ::= PERL_SCALAR_BUILT_IN | perl_scalar
perl_scalar ::= PERL_SIGIL_SCALAR + variable_body

private array_variable ::= PERL_ARRAY_BUILT_IN | perl_array
perl_array ::= PERL_SIGIL_ARRAY [PERL_SIGIL_SCALAR+] variable_body

private hash_variable ::= PERL_HASH_BUILT_IN | perl_hash
perl_hash ::= PERL_SIGIL_HASH [PERL_SIGIL_SCALAR+] variable_body

private glob_variable ::= PERL_GLOB_BUILT_IN | perl_glob
perl_glob ::= '*' variable_body ["{" glob_slot "}"]
glob_slot ::=
    "SCALAR"
    | "ARRAY"
    | "HASH"
    | "CODE"
    | "IO"
    | "GLOB"
    | "FORMAT"
    | "NAME"
    | "PACKAGE"


private variable_body ::=
    PERL_LBRACE [namespace] variable_name PERL_RBRACE
    | [namespace] variable_name
    | namespace
variable_name ::= PERL_VARIABLE_NAME

private comma ::= PERL_COMMA | PERL_ARROW_COMMA
method ::=
    namespace '->' scalar_variable      // i belive here could be more
    | namespace_method_static   // package::method
    | namespace_method          // package->method
    | object_method             // $object->method actuall it can be not scalar, but scalar expression, but enough for now
    | PERL_FUNCTION_BUILT_IN
    | PERL_KEYWORD

private namespace_method_static ::= [namespace] user_function
private namespace_method ::= [namespace '->'] user_function
private object_method ::= object '->' user_function
object ::= scalar_variable

namespace ::= PERL_PACKAGE | PERL_PACKAGE_BUILT_IN | PERL_PACKAGE_DEPRECATED | PERL_PACKAGE_PRAGMA
user_function ::= PERL_FUNCTION

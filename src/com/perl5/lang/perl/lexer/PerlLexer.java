/*
 * Copyright 2015 Alexandr Evstigneev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* The following code was generated by JFlex 1.4.3 on 03.05.15 13:19 */

package com.perl5.lang.perl.lexer;


import com.intellij.lexer.FlexLexer;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.TokenType;
import com.intellij.psi.tree.IElementType;
import com.intellij.psi.tree.TokenSet;
import com.perl5.lang.embedded.lexer.EmbeddedPerlLexer;
import com.perl5.lang.perl.PerlParserDefinition;
import com.perl5.lang.perl.parser.PerlParserUtil;
import com.perl5.lang.perl.util.PerlSubUtil;

import java.io.IOException;
import java.io.Reader;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class PerlLexer extends PerlLexerGenerated
{
	public static final Pattern IDENTIFIER_PATTERN = Pattern.compile("[_\\p{L}][_\\p{L}\\d]*");
	public static final Pattern BARE_STRING_PATTERN = Pattern.compile("[-+]*[_\\p{L}][_\\p{L}\\d]*");

	// pattern for getting marker
	public static final Pattern HEREDOC_OPENER_PATTERN = Pattern.compile("<<(.+?)");
	public static final Pattern HEREDOC_OPENER_PATTERN_DQ = Pattern.compile("<<(\\s*)(\")(.*?)\"");
	public static final Pattern HEREDOC_OPENER_PATTERN_SQ = Pattern.compile("<<(\\s*)(\')(.*?)\'");
	public static final Pattern HEREDOC_OPENER_PATTERN_XQ = Pattern.compile("<<(\\s*)(`)(.*?)`");
	public static final Pattern VERSION_IDENTIFIER_PATTERN = Pattern.compile("^(v[\\d_]+)");

	public static final Pattern ANNOTATION_PATTERN = Pattern.compile("^(\\p{L}+)(?:(\\s+)(.+)?)?$");
	// fixme this is not dry with package pattern
	public static final Pattern ANNOTATION_PATTERN_PACKAGE = Pattern.compile("^(\\p{L}[\\p{L}_\\d]*(?:::[_\\p{L}\\d]+)*)(.*)$");


	public static final String STRING_DATA = "__DATA__";
	public static final int STRING_DATA_LENGTH = STRING_DATA.length();
	public static final String STRING_END = "__END__";
	public static final int STRING_END_LENGTH = STRING_END.length();

	public static final String TR_MODIFIERS = "cdsr";

	public static final String SPECIAL_VARIABLE_NAMES_OPERATORS = "\\!'|+-/<=>~?";

	public static final TokenSet ALLOWED_WHILE_WAITING_SUB_ATTRIBUTE = TokenSet.create(
			TokenType.NEW_LINE_INDENT
			, TokenType.WHITE_SPACE
			, COMMENT_BLOCK
			, COMMENT_LINE
			, POD

			// for prototype/signature
			, LEFT_PAREN
			, RIGHT_PAREN

			// var name in signature
			, IDENTIFIER

			// namespace allowed in sub name
			, PACKAGE
			, PACKAGE_CORE_IDENTIFIER
			, PACKAGE_IDENTIFIER
			, PACKAGE_PRAGMA_CONSTANT
			, PACKAGE_PRAGMA_VARS

			// comma separated vars and colon starts attribute
			, COLON
			, OPERATOR_COMMA
			, OPERATOR_COMMA_ARROW

			// prototype sybmols
			, SIGIL_SCALAR
			, SIGIL_ARRAY
			, SIGIL_HASH
			, OPERATOR_MOD
			, OPERATOR_MUL
			, OPERATOR_BITWISE_AND
			, LEFT_BRACKET
			, RIGHT_BRACKET
			, OPERATOR_REFERENCE
			, OPERATOR_PLUS
			, SEMICOLON
	);

	// tokens allowed to be between my/our/state and attributes :
	public static final TokenSet ALLOWED_WHILE_WAITING_VAR_ATTRIBUTE = TokenSet.create(
			TokenType.NEW_LINE_INDENT
			, TokenType.WHITE_SPACE
			, COMMENT_BLOCK
			, COMMENT_LINE
			, POD

			// for list declaration
			, LEFT_PAREN
			, RIGHT_PAREN

			// var name
			, IDENTIFIER

			// namespace allowed in our
			, PACKAGE
			, PACKAGE_CORE_IDENTIFIER
			, PACKAGE_IDENTIFIER
			, PACKAGE_PRAGMA_CONSTANT
			, PACKAGE_PRAGMA_VARS

			// comma separated vars and colon starts attribute
			, COLON
			, OPERATOR_COMMA
			, OPERATOR_COMMA_ARROW

			// variables sigils
			, SIGIL_SCALAR
			, SIGIL_ARRAY
			, SIGIL_HASH
			, OPERATOR_MOD

			// variable name may be braced fixme this wont' work for now, see #504
//			, LEFT_BRACE
//			, RIGHT_BRACE
	);

	// tokens allowed to be in attribute
	public static final TokenSet ALLOWED_IN_ATTRIBUTE = TokenSet.create(
			TokenType.NEW_LINE_INDENT
			, TokenType.WHITE_SPACE
			, COMMENT_BLOCK
			, COMMENT_LINE
			, POD

			, IDENTIFIER
			, QUOTE_SINGLE_OPEN
			, QUOTE_SINGLE_CLOSE
			, COLON
			, STRING_CONTENT
	);

	// http://perldoc.perl.org/perldata.html#Identifier-parsing
	// pre-variable name tokens
	public static final TokenSet SIGILS_TOKENS = TokenSet.create(
			SIGIL_ARRAY,
			SIGIL_SCALAR,
			SIGIL_SCALAR_INDEX,
			OPERATOR_BITWISE_AND,    // code sigil
			OPERATOR_MOD,    // hash sigil
			OPERATOR_MUL    // glob sigil
	);
	// we should not check bareword for reserved tokens if following was before
	public static final TokenSet PRE_PACKAGE_TOKENS = TokenSet.create(
			RESERVED_USE,
			RESERVED_NO,
			RESERVED_PACKAGE,
			RESERVED_MY,
			RESERVED_OUR,
			RESERVED_STATE,
			RESERVED_LOCAL
	);
	// prefixes, disables identifier interpretation attempt
	public static final TokenSet IDENTIFIER_NEGATION_PREFIX = TokenSet.orSet(
			PRE_PACKAGE_TOKENS,
			TokenSet.create(
					RESERVED_SUB,            // sub eval
					OPERATOR_DEREFERENCE    // ->identifier
			)
	);
	// operators tokens (except commas)
	public static final TokenSet OPERATORS_TOKENSET = TokenSet.create(
			OPERATOR_CMP_NUMERIC,
			OPERATOR_LT_NUMERIC,
			OPERATOR_GT_NUMERIC,

			OPERATOR_CMP_STR,
			OPERATOR_LE_STR,
			OPERATOR_GE_STR,
			OPERATOR_EQ_STR,
			OPERATOR_NE_STR,
			OPERATOR_LT_STR,
			OPERATOR_GT_STR,

			OPERATOR_HELLIP,
			OPERATOR_FLIP_FLOP,
			OPERATOR_CONCAT,

			OPERATOR_PLUS_PLUS,
			OPERATOR_MINUS_MINUS,
			OPERATOR_POW,

			OPERATOR_RE,
			OPERATOR_NOT_RE,

//			OPERATOR_HEREDOC, // this is an artificial operator, not the real one
			OPERATOR_SHIFT_LEFT,
			OPERATOR_SHIFT_RIGHT,

			OPERATOR_AND,
			OPERATOR_OR,
			OPERATOR_OR_DEFINED,
			OPERATOR_NOT,

			OPERATOR_ASSIGN,

			QUESTION,
			COLON,

			OPERATOR_REFERENCE,

			OPERATOR_DIV,
			OPERATOR_MUL,
			OPERATOR_MOD,
			OPERATOR_PLUS,
			OPERATOR_MINUS,

			OPERATOR_BITWISE_NOT,
			OPERATOR_BITWISE_AND,
			OPERATOR_BITWISE_OR,
			OPERATOR_BITWISE_XOR,

			OPERATOR_AND_LP,
			OPERATOR_OR_LP,
			OPERATOR_XOR_LP,
			OPERATOR_NOT_LP,

			OPERATOR_COMMA,
			OPERATOR_COMMA_ARROW,

			OPERATOR_DEREFERENCE,

			OPERATOR_X,
			OPERATOR_FILETEST
	);
	// tokens which may preceeds .123 and . is a concat
	public static final TokenSet CONCAT_OPERATOR_PREFIX = TokenSet.create(
			IDENTIFIER,
			RIGHT_BRACE,
			RIGHT_PAREN,
			RIGHT_BRACKET,
			PACKAGE_IDENTIFIER,
			QUOTE_SINGLE_CLOSE,
			QUOTE_DOUBLE_CLOSE,
			QUOTE_TICK_CLOSE
	);

	public static final HashSet<String> REGEXP_PREFIX_SUBS = new HashSet<String>(Arrays.asList(
			"scalar",
			"split",
			"return",
			"grep"
	));
	public static final Map<String, IElementType> PRAGMA_TOKENS_MAP = new HashMap<String, IElementType>();

	public static final Map<String, IElementType> RESERVED_TOKEN_TYPES = new HashMap<String, IElementType>();
	public static final Map<String, IElementType> CUSTOM_TOKEN_TYPES = new HashMap<String, IElementType>();
	public static final Map<String, IElementType> namedOperators = new HashMap<String, IElementType>();
	public static final Map<String, IElementType> blockNames = new HashMap<String, IElementType>();
	public static final Map<String, IElementType> tagNames = new HashMap<String, IElementType>();
	public static final TokenSet QUOTE_LIKE_STRING_OPENER_TOKENSET = TokenSet.create(
			RESERVED_QW,
			RESERVED_Q,
			RESERVED_QQ,
			RESERVED_QX
	);
	public static final TokenSet QUOTE_LIKE_REGEX_OPENER_TOKENSET = TokenSet.create(
			RESERVED_S,
			RESERVED_M,
			RESERVED_QR
	);
	public static final TokenSet QUOTE_LIKE_TRANSLATE_OPENER_TOKENSET = TokenSet.create(
			RESERVED_TR,
			RESERVED_Y
	);
	public static final TokenSet QUOTE_LIKE_OPENER_TOKENSET = TokenSet.orSet(
			QUOTE_LIKE_STRING_OPENER_TOKENSET,
			QUOTE_LIKE_REGEX_OPENER_TOKENSET,
			QUOTE_LIKE_TRANSLATE_OPENER_TOKENSET
	);
	static final HashSet<String> PACKAGE_EXCEPTIONS = new HashSet<String>(Arrays.asList(
			"eq",
			"ne",
			"gt",
			"lt",
			"ge",
			"le",

			"qw",
			"qr",
			"qx",
			"qq",
			"tr",
			"m",
			"q",
			"s",
			"y"
	));
	// tokens that preceeds regexp opener or file <FH>
	public static TokenSet BARE_REGEX_PREFIX_TOKENSET =
			TokenSet.andNot(
					TokenSet.orSet(
							OPERATORS_TOKENSET
							, TokenSet.create(
									SEMICOLON,
									COLON,
									LEFT_PAREN,
									LEFT_BRACE,
									LEFT_BRACKET
							)),
					TokenSet.create(
							OPERATOR_PLUS_PLUS,
							OPERATOR_MINUS_MINUS
					)
			);
	public static TokenSet RESERVED_TOKENSET;
	public static TokenSet CUSTOM_TOKENSET;
	public static TokenSet LABEL_TOKENSET;

	static
	{
		PRAGMA_TOKENS_MAP.put("constant", PACKAGE_PRAGMA_CONSTANT);
		PRAGMA_TOKENS_MAP.put("vars", PACKAGE_PRAGMA_VARS);
	}

	static
	{
		// named operators
		namedOperators.put("x", OPERATOR_X);

		namedOperators.put("not", OPERATOR_NOT_LP);
		namedOperators.put("and", OPERATOR_AND_LP);
		namedOperators.put("or", OPERATOR_OR_LP);
		namedOperators.put("xor", OPERATOR_XOR_LP);

		namedOperators.put("lt", OPERATOR_LT_STR);
		namedOperators.put("gt", OPERATOR_GT_STR);
		namedOperators.put("le", OPERATOR_LE_STR);
		namedOperators.put("ge", OPERATOR_GE_STR);
		namedOperators.put("eq", OPERATOR_EQ_STR);
		namedOperators.put("ne", OPERATOR_NE_STR);
		namedOperators.put("cmp", OPERATOR_CMP_STR);

		// block names
		blockNames.put("BEGIN", BLOCK_NAME);
		blockNames.put("UNITCHECK", BLOCK_NAME);
		blockNames.put("CHECK", BLOCK_NAME);
		blockNames.put("INIT", BLOCK_NAME);
		blockNames.put("END", BLOCK_NAME);

		// these added for core packages, not blocks, just subs
		blockNames.put("AUTOLOAD", BLOCK_NAME);
		blockNames.put("DESTROY", BLOCK_NAME);

		PerlParserUtil.addConvertableTokens(blockNames.values().toArray(new IElementType[blockNames.values().size()]));

		// tags
		tagNames.put("__FILE__", TAG);
		tagNames.put("__LINE__", TAG);
		tagNames.put("__PACKAGE__", TAG);
		tagNames.put("__SUB__", TAG);

	}

	/**
	 * HEREDOC proceccing section
	 */

	// last captured heredoc marker
	protected final Stack<PerlHeredocQueueElement> heredocQueue = new Stack<PerlHeredocQueueElement>();

	/**
	 * Quote-like, transliteration and regexps common part
	 */
	public boolean allowSharpQuote = true;
	public boolean isEscaped = false;
	public int sectionsNumber = 0;    // number of sections one or two
	protected int waitingAttributeBraceLevel = 0;
	protected int waitingAttributeBracketLevel = 0;
	protected int waitingAttributeParenLevel = 0;
	// we've parsed my/our/state
	protected boolean waitingVarAttribute = false;
	// we've passed sub
	protected boolean waitingSubAttribute = false;
	// we've passed sub and colon
	protected boolean isAttribute = false;
	protected PerlLexerAdapter evalPerlLexer;
	protected PerlStringLexer myStringLexer;
	protected PerlQStringLexer myQStringLexer;
	protected PerlQQStringLexer myQQStringLexer;
	protected PerlQXStringLexer myQXStringLexer;
	protected PerlQWStringLexer myQWStringLexer;
	Project myProject;
	/**
	 * Regex processor qr{} m{} s{}{}
	 **/
	CharSequence regexCommand = null;

	public PerlLexer(Project project)
	{
		super((Reader) null);
		myProject = project;
	}

	public static void initReservedTokensMap()
	{
		RESERVED_TOKEN_TYPES.clear();
		// reserved
		RESERVED_TOKEN_TYPES.put("if", RESERVED_IF);
		RESERVED_TOKEN_TYPES.put("unless", RESERVED_UNLESS);
		RESERVED_TOKEN_TYPES.put("elsif", RESERVED_ELSIF);
		RESERVED_TOKEN_TYPES.put("else", RESERVED_ELSE);
		RESERVED_TOKEN_TYPES.put("given", RESERVED_GIVEN);
		RESERVED_TOKEN_TYPES.put("when", RESERVED_WHEN);
		RESERVED_TOKEN_TYPES.put("default", RESERVED_DEFAULT);
		RESERVED_TOKEN_TYPES.put("while", RESERVED_WHILE);
		RESERVED_TOKEN_TYPES.put("until", RESERVED_UNTIL);
		RESERVED_TOKEN_TYPES.put("for", RESERVED_FOR);
		RESERVED_TOKEN_TYPES.put("foreach", RESERVED_FOREACH);
		RESERVED_TOKEN_TYPES.put("continue", RESERVED_CONTINUE);

		RESERVED_TOKEN_TYPES.put("format", RESERVED_FORMAT);
		RESERVED_TOKEN_TYPES.put("sub", RESERVED_SUB);
		RESERVED_TOKEN_TYPES.put("package", RESERVED_PACKAGE);
		RESERVED_TOKEN_TYPES.put("use", RESERVED_USE);
		RESERVED_TOKEN_TYPES.put("no", RESERVED_NO);
		RESERVED_TOKEN_TYPES.put("require", RESERVED_REQUIRE);

		RESERVED_TOKEN_TYPES.put("undef", RESERVED_UNDEF);

		RESERVED_TOKEN_TYPES.put("print", RESERVED_PRINT);
		RESERVED_TOKEN_TYPES.put("printf", RESERVED_PRINTF);
		RESERVED_TOKEN_TYPES.put("say", RESERVED_SAY);

		RESERVED_TOKEN_TYPES.put("grep", RESERVED_GREP);
		RESERVED_TOKEN_TYPES.put("map", RESERVED_MAP);
		RESERVED_TOKEN_TYPES.put("sort", RESERVED_SORT);

		RESERVED_TOKEN_TYPES.put("qw", RESERVED_QW);

		RESERVED_TOKEN_TYPES.put("qq", RESERVED_QQ);
		RESERVED_TOKEN_TYPES.put("q", RESERVED_Q);
		RESERVED_TOKEN_TYPES.put("qx", RESERVED_QX);

		RESERVED_TOKEN_TYPES.put("tr", RESERVED_TR);
		RESERVED_TOKEN_TYPES.put("y", RESERVED_Y);

		RESERVED_TOKEN_TYPES.put("s", RESERVED_S);
		RESERVED_TOKEN_TYPES.put("qr", RESERVED_QR);
		RESERVED_TOKEN_TYPES.put("m", RESERVED_M);

		RESERVED_TOKEN_TYPES.put("my", RESERVED_MY);
		RESERVED_TOKEN_TYPES.put("our", RESERVED_OUR);
		RESERVED_TOKEN_TYPES.put("state", RESERVED_STATE);
		RESERVED_TOKEN_TYPES.put("local", RESERVED_LOCAL);

		RESERVED_TOKEN_TYPES.put("do", RESERVED_DO);
		RESERVED_TOKEN_TYPES.put("eval", RESERVED_EVAL);

		RESERVED_TOKEN_TYPES.put("goto", RESERVED_GOTO);
		RESERVED_TOKEN_TYPES.put("redo", RESERVED_REDO);
		RESERVED_TOKEN_TYPES.put("next", RESERVED_NEXT);
		RESERVED_TOKEN_TYPES.put("last", RESERVED_LAST);

		RESERVED_TOKEN_TYPES.put("return", RESERVED_RETURN);
	}

	public static void initReservedTokensSet()
	{
		RESERVED_TOKENSET = TokenSet.create(RESERVED_TOKEN_TYPES.values().toArray(new IElementType[RESERVED_TOKEN_TYPES.values().size()]));
		CUSTOM_TOKENSET = TokenSet.create(CUSTOM_TOKEN_TYPES.values().toArray(new IElementType[CUSTOM_TOKEN_TYPES.values().size()]));

		Set<IElementType> allTextTokens = new HashSet<IElementType>();

		allTextTokens.addAll(namedOperators.values());
		allTextTokens.addAll(blockNames.values());
		allTextTokens.addAll(tagNames.values());

		LABEL_TOKENSET = TokenSet.andNot(
				TokenSet.orSet(
						TokenSet.create(allTextTokens.toArray(new IElementType[allTextTokens.size()])),
						RESERVED_TOKENSET,
						CUSTOM_TOKENSET,
						PerlParserUtil.CONVERTABLE_TOKENS
				),
				TokenSet.orSet(
						QUOTE_LIKE_OPENER_TOKENSET,
						TokenSet.create(RESERVED_SUB)
				)
		);
	}

	/**
	 * Lex current token with specific lexer
	 *
	 * @param tokenLexer lexer to use
	 * @return list of custom tokens
	 */
	public static List<CustomToken> processLexer(FlexLexer tokenLexer)
	{
		ArrayList<CustomToken> result = new ArrayList<CustomToken>();

		try
		{
			IElementType tokenType;
			while ((tokenType = tokenLexer.advance()) != null)
				result.add(new CustomToken(tokenLexer.getTokenStart(), tokenLexer.getTokenEnd(), tokenType));
		} catch (IOException e)
		{
			e.printStackTrace();
		}

		return result;
	}

	public List<CustomToken> lexCurrentToken(FlexLexer tokenLexer)
	{
		tokenLexer.reset(getBuffer(), getTokenStart(), getTokenEnd(), 0);
		return processLexer(tokenLexer);
	}

	// fixme to make this work you must remove final in PerlParserGenerated manually.
	@Override
	public int yystate()
	{
		if (preparsedTokensList.size() > 0)
			return LEX_PREPARSED_ITEMS;
		return super.yystate();
	}

	/**
	 * Lexers perlAdvance method. Parses some thing here, or just invoking generated flex parser
	 *
	 * @return next token type
	 * @throws IOException
	 */
	public IElementType perlAdvance() throws IOException
	{

		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();
		int bufferEnd = getBufferEnd();

		if (bufferEnd == 0 || tokenStart >= bufferEnd)
			return super.perlAdvance();
		else
		{
			int currentState = yystate();
			char currentChar = buffer.charAt(tokenStart);

			// capture heredoc
			if (waitingHereDoc() && (tokenStart == 0 || currentChar == '\n'))
			{
				return captureHereDoc(false);
			}
			// capture format
			else if (currentState == LEX_FORMAT_WAITING && (tokenStart == 0 || buffer.charAt(tokenStart - 1) == '\n'))
			{
				IElementType tokenType = captureFormat();
				if (tokenType != null)    // got something
					return tokenType;
			}
			else if (isOpeningQuoteFor(currentState, currentChar, LEX_QUOTE_LIKE_OPENER_Q, LEX_QUOTE_LIKE_OPENER_QQ, LEX_QUOTE_LIKE_OPENER_QX, LEX_QUOTE_LIKE_OPENER_QW))
				return captureString();
			else if (isOpeningQuoteFor(currentState, currentChar, LEX_REGEX_OPENER))
				return parseRegex(tokenStart);
			else if (isOpeningQuoteFor(currentState, currentChar, LEX_TRANS_OPENER))
				return parseTr();
			else if (currentChar == '\'')
				return captureString(LEX_QUOTE_LIKE_OPENER_Q);
			else if (currentChar == '"')
				return captureString(LEX_QUOTE_LIKE_OPENER_QQ);
			else if (currentChar == '`')
				return captureString(LEX_QUOTE_LIKE_OPENER_QX);
				// capture __DATA__ __END__
				// capture pod
			else if (currentChar == '=' && (tokenStart == 0 || buffer.charAt(tokenStart - 1) == '\n') && bufferEnd > tokenStart + 1 && Character.isLetter(buffer.charAt(tokenStart + 1)))
				return capturePodBlock();
				// capture qw content from qw();
			else if (((tokenStart < bufferEnd - STRING_DATA_LENGTH) && StringUtil.equals(buffer.subSequence(tokenStart, tokenStart + STRING_DATA_LENGTH), STRING_DATA))
					|| ((tokenStart < bufferEnd - STRING_END_LENGTH) && StringUtil.equals(buffer.subSequence(tokenStart, tokenStart + STRING_END_LENGTH), STRING_END))
					)
			{
				setTokenStart(tokenStart);
				setTokenEnd(bufferEnd);
				return COMMENT_BLOCK;
			}
			// capture line comment
			else if (currentChar == '#')
			{
				// comment may end on newline or ?>
				int currentPosition = tokenStart;
				setTokenStart(tokenStart);

				while (currentPosition < bufferEnd && !isLineCommentEnd(currentPosition))
					currentPosition++;

				// catching annotations #@
				if (tokenStart + 1 < bufferEnd && buffer.charAt(tokenStart + 1) == '@')
				{
					if (currentPosition > tokenStart + 2)
						parseAnnotation(buffer.subSequence(tokenStart + 2, currentPosition), tokenStart + 2);

					setTokenEnd(tokenStart + 2);
					return ANNOTATION_PREFIX;
				}

				setTokenEnd(currentPosition);
				return COMMENT_LINE;
			}

		}

		return super.perlAdvance();
	}


	public boolean isOpeningQuoteFor(int currentState, char currentChar, int... states)
	{
		for (int state : states)
			if (state == currentState)
				return !Character.isWhitespace(currentChar)
						&& (currentChar != '#' || allowSharpQuote);

		return false;
	}

	/**
	 * Changes current lexical state and than captures string
	 *
	 * @return string token
	 */
	public IElementType captureString(int newState) throws IOException
	{
		int nextCharOffset = getTokenEnd() + 1;
		PerlTokenHistory tokenHistory = getTokenHistory();
		boolean afterSigil = SIGILS_TOKENS.contains(tokenHistory.getLastTokenType());

		// handles archaic vars like $'var instead of $::var
		if (newState == LEX_QUOTE_LIKE_OPENER_Q && afterSigil && isValidIdentifierCharacter(getSafeCharacterAt(nextCharOffset)))
		{
			setTokenStart(getTokenEnd());
			setTokenEnd(nextCharOffset);
			int adjustResult = adjustUtfIdentifier();
			if (adjustResult == EXT_IDENTIFIER || adjustResult == EXT_PACKAGE)
			{
				return parsePackage();
			}
			else
			{
				return parsePackageCanonical();
			}
		}

		if (afterSigil // this is not a beginning of a string, but variable name
				|| (SIGILS_TOKENS.contains(tokenHistory.getLastUnbracedTokenType()) &&
				tokenHistory.getLastSignificantTokenType() == LEFT_BRACE &&    // isBraced doesn't work here, because tokenEnd is not set yet
				getNextNonSpaceCharacter(nextCharOffset) == '}'
		))
		{
			return super.perlAdvance();
		}

		pushState();
		yybegin(newState);
		return captureString();
	}


	/**
	 * Captures string token from current position according to the current lexical state
	 *
	 * @return string token
	 */
	public IElementType captureString()
	{
		CharSequence buffer = getBuffer();
		int currentPosition = getTokenEnd();
		setTokenStart(currentPosition);
		int bufferEnd = getBufferEnd();

		char openQuote = buffer.charAt(currentPosition);
		char closeQuote = RegexBlock.getQuoteCloseChar(openQuote);
		boolean quotesDiffer = openQuote != closeQuote;

		boolean isEscaped = false;
		int quotesDepth = 0;    // for using with different quotes

		currentPosition++;

		while (currentPosition < bufferEnd)
		{
			char currentChar = buffer.charAt(currentPosition);

			if (!isEscaped && quotesDepth == 0 && currentChar == closeQuote)
				break;

			if (!isEscaped && quotesDiffer)
				if (currentChar == openQuote)
					quotesDepth++;
				else if (currentChar == closeQuote)
					quotesDepth--;

			isEscaped = !isEscaped && currentChar == '\\';

			currentPosition++;
		}

		if (currentPosition < bufferEnd)    // got close quote
			currentPosition++;

		setTokenEnd(currentPosition);

//		System.err.println("Captured string " + yytext() );

		// following block is for lazy parsing of strings, seems works slower
//		IElementType tokenType = getStringTokentType();
//		popState();
//		return tokenType;

		PerlStringLexer stringLexer = getStringLexer();
		popState();
		preparsedTokensList.addAll(lexCurrentToken(stringLexer));
		return getPreParsedToken();
	}


	/**
	 * Lazy getter for StringLexer
	 *
	 * @return string lexer
	 */
	@Deprecated
	protected PerlStringLexer getBareStringLexer()
	{
		if (myStringLexer == null)
			myStringLexer = new PerlStringLexer(myProject);

		return myStringLexer;
	}

	/**
	 * Lazy getter for QStringLexer
	 *
	 * @return string lexer
	 */
	protected PerlQStringLexer getQStringLexer()
	{
		if (myQStringLexer == null)
			myQStringLexer = new PerlQStringLexer();

		return myQStringLexer;
	}

	/**
	 * Lazy getter for QStringLexer
	 *
	 * @return string lexer
	 */
	protected PerlQQStringLexer getQQStringLexer()
	{
		if (myQQStringLexer == null)
			myQQStringLexer = new PerlQQStringLexer(myProject);

		return myQQStringLexer;
	}

	/**
	 * Lazy getter for QStringLexer
	 *
	 * @return string lexer
	 */
	protected PerlQXStringLexer getQXStringLexer()
	{
		if (myQXStringLexer == null)
			myQXStringLexer = new PerlQXStringLexer(myProject);

		return myQXStringLexer;
	}

	/**
	 * Lazy getter for QStringLexer
	 *
	 * @return string lexer
	 */
	protected PerlQWStringLexer getQWStringLexer()
	{
		if (myQWStringLexer == null)
			myQWStringLexer = new PerlQWStringLexer();

		return myQWStringLexer;
	}


	/**
	 * Checks that version is a really version, not a variable name
	 * fixme how about sub v123123 ?
	 *
	 * @return token type
	 */
	@Override
	public IElementType parseVersion()
	{
		if (SIGILS_TOKENS.contains(getTokenHistory().getLastTokenType())
				|| isBraced() && SIGILS_TOKENS.contains(getTokenHistory().getLastUnbracedTokenType())
				)
		{
			CharSequence tokenText = yytext();
			Matcher m = VERSION_IDENTIFIER_PATTERN.matcher(tokenText);
			if (m.find())
			{
				if (m.group(1).length() < tokenText.length())
					yypushback(tokenText.length() - m.group(1).length());
				return IDENTIFIER;
			}

		}
		return NUMBER_VERSION;
	}

	/**
	 * Parses number, handling some specific cases
	 *
	 * @return token type
	 */
	@Override
	public IElementType parseNumber()
	{
		CharSequence tokenText = yytext();
//		System.err.println("For "  + tokenText + "Last significant token is " + getTokenHistory().getLastSignificantTokenType());
		if (tokenText.charAt(0) == '.' && CONCAT_OPERATOR_PREFIX.contains(getTokenHistory().getLastSignificantTokenType())) // It's a $var.123; where . is a concat
		{
			yypushback(tokenText.length() - 1);
			return OPERATOR_CONCAT;
		}
		else if (StringUtil.endsWith(tokenText, "."))
		{
			if (getTokenHistory().getLastUnbracedTokenType() == SIGIL_SCALAR) // $1.$something
			{
				yypushback(1);
				return IDENTIFIER;
			}
			if (getNextCharacter() == '.')    // it's a 1..10
			{
				yypushback(1);
			}
		}
		return NUMBER;
	}

	/**
	 * Parses annotation line and puts result into the pre-parsed buffer
	 *
	 * @param annotationLine - string with annotation after marker
	 */
	void parseAnnotation(CharSequence annotationLine, int baseOffset)
	{
		Matcher m = ANNOTATION_PATTERN.matcher(annotationLine);
		preparsedTokensList.clear();
		CharSequence tailComment;

		if (m.matches())
		{
//			String annotationKey = m.group(1);
			IElementType tokenType = PerlAnnotations.TOKEN_TYPES.get(m.group(1));

			if (tokenType == null)
				tokenType = ANNOTATION_UNKNOWN_KEY;

			preparsedTokensList.add(new CustomToken(baseOffset, baseOffset + m.group(1).length(), tokenType));
			baseOffset += m.group(1).length();

			if (m.group(2) != null)
			{
				preparsedTokensList.add(new CustomToken(baseOffset, baseOffset + m.group(2).length(), TokenType.WHITE_SPACE));
				baseOffset += m.group(2).length();
			}

			if (tokenType == ANNOTATION_RETURNS_KEY && m.group(3) != null)
			{
				// additional parsing
				String annotationRest = m.group(3);
				Matcher pm = ANNOTATION_PATTERN_PACKAGE.matcher(annotationRest);

				if (pm.matches())
				{
					if (pm.group(1) != null && pm.group(1).length() > 0)
					{
						preparsedTokensList.add(new CustomToken(baseOffset, baseOffset + pm.group(1).length(), PACKAGE));
						baseOffset += pm.group(1).length();
					}

					tailComment = pm.group(2);
				}
				else
					tailComment = m.group(3);
			}
			else
				tailComment = m.group(3);
		}
		else
			tailComment = annotationLine;

		if (tailComment != null && tailComment.length() > 0)
			preparsedTokensList.add(new CustomToken(baseOffset, baseOffset + tailComment.length(), COMMENT_LINE));
	}

	/**
	 * Checking if comment is ended. Implemented for overriding in {@link EmbeddedPerlLexer#isLineCommentEnd(int)} }
	 *
	 * @param currentPosition current position to check
	 * @return checking result
	 */
	public boolean isLineCommentEnd(int currentPosition)
	{
		return getBuffer().charAt(currentPosition) == '\n';
	}

	/**
	 * Captures pod block from current position
	 *
	 * @return PERL_POD token type
	 */
	public IElementType capturePodBlock()
	{
		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();
		setTokenStart(tokenStart);
		int bufferEnd = getBufferEnd();

		int currentPosition = tokenStart;
		int linePos = currentPosition;
		int linesNumber = 0;

		while (true)
		{
			while (linePos < bufferEnd && buffer.charAt(linePos) != '\n')
			{
				linePos++;
			}
			if (linePos < bufferEnd && buffer.charAt(linePos) == '\n')
				linePos++;
			CharSequence line = buffer.subSequence(currentPosition, linePos);
			currentPosition = linePos;

			if (linePos == bufferEnd || StringUtil.startsWith(line, "=cut") && linesNumber > 0)
			{
				if (linePos < bufferEnd)
				{
					linePos--;
				}
				setTokenEnd(linePos);
				break;
			}
			linesNumber++;
		}

		return POD;
	}

	public IElementType parseHeredocOpenerBackref()
	{
		CharSequence openToken = yytext();
		int tokenStart = getTokenStart();
		addPreparsedToken(tokenStart + 2, tokenStart + 3, OPERATOR_REFERENCE);
		addPreparsedToken(tokenStart + 3, tokenStart + openToken.length(), STRING_CONTENT);
		heredocQueue.push(new PerlHeredocQueueElement(LEX_HEREDOC_WAITING, openToken.subSequence(3, openToken.length()).toString()));
		pushState();
		yybegin(LEX_HEREDOC_WAITING);
		setTokenEnd(tokenStart + 2);
		return OPERATOR_HEREDOC;
	}

	/**
	 * Processing captured heredoc opener. Stores marker and switches to proper lexical state
	 *
	 * @return PERL_OPERATOR  for << operator
	 */
	public IElementType parseHeredocOpener()
	{
		CharSequence openToken = yytext();
		Matcher m;
		int newState = LEX_HEREDOC_WAITING_QQ;

		if (StringUtil.endsWithChar(openToken, '"'))
		{
			m = HEREDOC_OPENER_PATTERN_DQ.matcher(openToken);
		}
		else if (StringUtil.endsWithChar(openToken, '\''))
		{
			m = HEREDOC_OPENER_PATTERN_SQ.matcher(openToken);
			newState = LEX_HEREDOC_WAITING;
		}
		else if (StringUtil.endsWithChar(openToken, '`'))
		{
			m = HEREDOC_OPENER_PATTERN_XQ.matcher(openToken);
			newState = LEX_HEREDOC_WAITING_QX;
		}
		else
		{
			m = HEREDOC_OPENER_PATTERN.matcher(openToken);
		}

		Character nextCharacter = getNextSignificantCharacter();
		yypushback(openToken.length() - 2);

		if (m.matches())
		{
			preparsedTokensList.clear();
			int currentPosition = getNextTokenStart();

			if (m.groupCount() > 1)    // quoted heredoc
			{
				String heredocMarker = m.group(3);
				heredocQueue.push(new PerlHeredocQueueElement(newState, heredocMarker));

				int elementLength = m.group(1).length();
				if (elementLength > 0)    // got spaces
				{
					addPreparsedToken(currentPosition, currentPosition + elementLength, TokenType.WHITE_SPACE);
				}

				currentPosition += elementLength;

				addPreparsedToken(currentPosition, currentPosition + 1, getOpenQuoteTokenType(m.group(2).charAt(0)));
				currentPosition++;

				if (heredocMarker.length() > 0)
				{
					addPreparsedToken(currentPosition, currentPosition + heredocMarker.length(), STRING_IDENTIFIER);
					currentPosition += heredocMarker.length();
				}

				addPreparsedToken(currentPosition, currentPosition + 1, getCloseQuoteTokenType(m.group(2).charAt(0)));
			}
			else if (m.group(1).matches("\\d+"))    // check if it's numeric shift
			{
				return OPERATOR_SHIFT_LEFT;
			}
			else    // bareword heredoc
			{
				if (nextCharacter != null && nextCharacter.equals('('))    // it's a sub
				{
					return OPERATOR_SHIFT_LEFT;
				}

				String heredocMarker = m.group(1);
				heredocQueue.push(new PerlHeredocQueueElement(newState, heredocMarker));
				preparsedTokensList.add(new CustomToken(currentPosition, currentPosition + heredocMarker.length(), STRING_IDENTIFIER));
			}
		}
		else
		{
			throw new RuntimeException("Unable to parse HEREDOC opener " + openToken);
		}

		pushState();
		yybegin(LEX_HEREDOC_WAITING);    // actual heredoc waiting got from heredocQueue

		return OPERATOR_HEREDOC;
	}

	/**
	 * Captures HereDoc document and returns appropriate token type
	 *
	 * @param afterEmptyCloser - this here-doc being captured after empty closer, e.g. sequentional <<"", <<""
	 * @return Heredoc token type
	 */
	public IElementType captureHereDoc(boolean afterEmptyCloser)
	{
		popState();
		final PerlHeredocQueueElement heredocQueueElement = heredocQueue.remove(0);
		final String heredocMarker = heredocQueueElement.getMarker();
		final int oldState = heredocQueueElement.getState();

		IElementType tokenType = HEREDOC;
		if (oldState == LEX_HEREDOC_WAITING_QQ)
		{
			tokenType = HEREDOC_QQ;
		}
		else if (oldState == LEX_HEREDOC_WAITING_QX)
		{
			tokenType = HEREDOC_QX;
		}

		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();

		if (!afterEmptyCloser)
		{
			addPreparsedToken(tokenStart++, tokenStart, TokenType.NEW_LINE_INDENT);
		}

		int bufferEnd = getBufferEnd();

		int currentPosition = tokenStart;
		int linePos = currentPosition;


		while (true)
		{
			while (linePos < bufferEnd && buffer.charAt(linePos) != '\n' && buffer.charAt(linePos) != '\r')
				linePos++;
			int lineContentsEnd = linePos;

			if (linePos < bufferEnd && buffer.charAt(linePos) == '\r')
				linePos++;
			if (linePos < bufferEnd && buffer.charAt(linePos) == '\n')
				linePos++;

			// reached the end of heredoc and got end marker

			if (heredocMarker.isEmpty() && lineContentsEnd == currentPosition && linePos > lineContentsEnd)
			{
				// non-empty heredoc and got the end
				if (currentPosition > tokenStart)
				{
					addPreparsedToken(tokenStart, currentPosition, tokenType);
				}
				addPreparsedToken(currentPosition, lineContentsEnd + 1, HEREDOC_END);

				if (!heredocQueue.isEmpty() && bufferEnd > lineContentsEnd + 1)
				{
					setTokenEnd(lineContentsEnd + 1);
					return captureHereDoc(true);
				}
				else
				{
					return getPreParsedToken();
				}
			}
			else if (StringUtil.equals(heredocMarker, buffer.subSequence(currentPosition, lineContentsEnd)))
			{
				// non-empty heredoc and got the end
				if (currentPosition > tokenStart)
				{
					addPreparsedToken(tokenStart, currentPosition, tokenType);
				}
				addPreparsedToken(currentPosition, lineContentsEnd, HEREDOC_END);
				return getPreParsedToken();
			}
			// reached the end of file
			else if (linePos == bufferEnd)
			{
				// non-empty heredoc and got the end of file
				if (linePos > tokenStart)
				{
					addPreparsedToken(tokenStart, linePos, tokenType);
				}
				return getPreParsedToken();
			}
			currentPosition = linePos;
		}
	}

	/**
	 * Captures format; fixme refactor with captureHeredoc got common parts
	 *
	 * @return Heredoc token type
	 */
	public IElementType captureFormat()
	{
		popState();
		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();
		setTokenStart(tokenStart);
		int bufferEnd = getBufferEnd();

		int currentPosition = tokenStart;
		int linePos = currentPosition;

		while (true)
		{
			while (linePos < bufferEnd && buffer.charAt(linePos) != '\n' && buffer.charAt(linePos) != '\r')
				linePos++;
			int lineContentsEnd = linePos;

			if (linePos < bufferEnd && buffer.charAt(linePos) == '\r')
				linePos++;
			if (linePos < bufferEnd && buffer.charAt(linePos) == '\n')
				linePos++;

			// reached the end of format and got end marker
			if (lineContentsEnd == currentPosition + 1 && buffer.charAt(currentPosition) == '.')
			{
				preparsedTokensList.clear();
				preparsedTokensList.add(new CustomToken(currentPosition, lineContentsEnd, FORMAT_TERMINATOR));

				// non-empty heredoc and got the end
				if (currentPosition > tokenStart)
				{
					setTokenStart(tokenStart);
					setTokenEnd(currentPosition);
					return FORMAT;
				}
				// empty format and got the end
				else
					return getPreParsedToken();
			}
			// reached the end of file
			else if (linePos == bufferEnd)
			{
				// non-empty format and got the end of file
				if (currentPosition > tokenStart)
				{
					setTokenStart(tokenStart);
					setTokenEnd(currentPosition);
					return FORMAT;
				}
				// empty heredoc and got the end of file
				else
					return null;
			}
			currentPosition = linePos;
		}
	}

	public void reset(CharSequence buf, int start, int end, int initialState)
	{
		super.reset(buf, start, end, initialState);
		resetInternals();
//		System.err.println(String.format("Lexer re-set to %d - %d, %d of %d", start, end, end - start, buf.length()));
	}

	/**
	 * Contains heuristic to detect if we are at term position. Used for regexp and <string>
	 *
	 * @return check result
	 */
	public boolean isTermPosition()
	{
		// todo we should check argumentless prefix sub
		// todo we should check if we are after grep/map/sort block
		// actually, we can't distict somesub / somediv from somesub /regex/;

		PerlTokenHistory tokenHistory = getTokenHistory();
		IElementType lastUnbracedTokenType = tokenHistory.getLastUnbracedTokenType();
		IElementType lastSignificantTokenType = tokenHistory.getLastSignificantTokenType();

		boolean isTermPrefix = BARE_REGEX_PREFIX_TOKENSET.contains(lastSignificantTokenType);
		if (lastSignificantTokenType == OPERATOR_CONCAT)
		{
			PerlTokenHistory.PerlTokenHistoryElement prevElement = tokenHistory.getPreviousToken(tokenHistory.getLastSignificantToken());
			if (prevElement != null && prevElement.getTokenType() == SIGIL_SCALAR)
			{
				isTermPrefix = false;
			}
		}

		return !SIGILS_TOKENS.contains(lastUnbracedTokenType)    // for $/
				&& (
				lastSignificantTokenType == null
						|| RESERVED_TOKENSET.contains(lastSignificantTokenType)
						|| isTermPrefix
						|| getTokenHistory().getLastUnparenTokenType() == IDENTIFIER &&
						REGEXP_PREFIX_SUBS.contains(getTokenHistory().getLastUnparenTokenTextAsString())
		);
	}

	// guess if this is a OPERATOR_DIV or regex opener
	public IElementType guessDiv()
	{
		char nextChar = 0;
		if (isTermPosition()
				// additional hacks for regexps we could add check for (? here
				|| (nextChar = getNextNonSpaceCharacter()) == '\\' // we can div by reference
				|| nextChar == '['    // can't div by anon array
				)
		{
			allowSharpQuote = true;
			isEscaped = false;
			regexCommand = "m";
			sectionsNumber = 1;
			pushState();
			return parseRegex(getTokenStart());
		}
		else
		{
			if (getNextCharacter() == '/')
			{
				setTokenEnd(getNextTokenStart() + 1);
				return OPERATOR_OR_DEFINED;
			}
			else
			{
				return OPERATOR_DIV;
			}
		}
	}

	// fixme how about $x234sdfsdf ?
	public IElementType checkOperatorXSticked()
	{
		yypushback(1);
		if (getTokenHistory().getLastSignificantTokenType() == RESERVED_REQUIRE                            // require x123
				|| IDENTIFIER_NEGATION_PREFIX.contains(getTokenHistory().getLastSignificantTokenType())    // package x123, ->x123, etc.
				|| SIGILS_TOKENS.contains(getTokenHistory().getLastTokenType())                            // $x123
				|| isBraced()                                                        // {x123}
				)
			return IDENTIFIER;
		else if (isCommaArrowAhead())    // we should check for ->
		{
			return STRING_IDENTIFIER;
		}

		yypushback(yylength() - 1);
		return OPERATOR_X;
	}

	public IElementType parseCappedVariableName()
	{
		// fixme fix this according to http://perldoc.perl.org/perlvar.html#The-Syntax-of-Variable-Names
		if (SIGILS_TOKENS.contains(getTokenHistory().getLastUnbracedTokenType()))
		{
			return IDENTIFIER;
		}

		yypushback(yylength() - 1);
		return OPERATOR_BITWISE_XOR;
	}

	/**
	 * Sets up regex parser
	 */
	public void processRegexOpener()
	{
		allowSharpQuote = true;
		isEscaped = false;
		regexCommand = yytext();

		if (StringUtil.equals("s", regexCommand))    // two sections s
		{
			sectionsNumber = 2;
		}
		else                        // one section qr m
		{
			sectionsNumber = 1;
		}

		pushState();
		yybegin(LEX_REGEX_OPENER);
	}

	/**
	 * Parsing tr/y content
	 *
	 * @return first token
	 */
	public IElementType parseTr()
	{
		popState();
		CharSequence buffer = getBuffer();
		int currentOffset = getTokenEnd();
		int bufferEnd = getBufferEnd();

		// search block
		char openQuote = buffer.charAt(currentOffset);
		char closeQuote = RegexBlock.getQuoteCloseChar(openQuote);
		boolean quotesDiffer = openQuote != closeQuote;
		addPreparsedToken(currentOffset++, currentOffset, REGEX_QUOTE_OPEN);

		currentOffset = parseTrBlockContent(currentOffset, openQuote, closeQuote);

		// close quote
		if (currentOffset < bufferEnd)
			addPreparsedToken(currentOffset++, currentOffset, quotesDiffer ? REGEX_QUOTE_CLOSE : REGEX_QUOTE);

		// between blocks
		if (quotesDiffer)
			currentOffset = lexWhiteSpacesAndComments(currentOffset, preparsedTokensList);

		// second block
		if (currentOffset < bufferEnd)
		{
			if (quotesDiffer)
			{
				openQuote = buffer.charAt(currentOffset);
				closeQuote = RegexBlock.getQuoteCloseChar(openQuote);
				addPreparsedToken(currentOffset++, currentOffset, REGEX_QUOTE_OPEN);
			}

			currentOffset = parseTrBlockContent(currentOffset, openQuote, closeQuote);
		}

		// close quote
		if (currentOffset < bufferEnd)
			addPreparsedToken(currentOffset++, currentOffset, REGEX_QUOTE_CLOSE);


		// trans modifiers
		if (currentOffset < bufferEnd)
		{
			int blockStart = currentOffset;
			while (currentOffset < bufferEnd && StringUtil.containsChar(TR_MODIFIERS, buffer.charAt(currentOffset)))
				currentOffset++;

			if (blockStart < currentOffset)
				addPreparsedToken(blockStart, currentOffset, REGEX_MODIFIER);
		}

		return getPreParsedToken();
	}

	/**
	 * Parsing tr block content till close quote
	 *
	 * @param currentOffset start offset
	 * @param closeQuote    close quote character
	 * @return next offset
	 */
	int parseTrBlockContent(int currentOffset, char openQuote, char closeQuote)
	{
		int blockStartOffset = currentOffset;
		CharSequence buffer = getBuffer();
		int bufferEnd = getBufferEnd();
		boolean isEscaped = false;
		boolean isQuoteDiffers = openQuote != closeQuote;
		int quotesLevel = 0;

		while (currentOffset < bufferEnd)
		{
			char currentChar = buffer.charAt(currentOffset);

			if (!isEscaped && quotesLevel == 0 && currentChar == closeQuote)
			{
				if (currentOffset > blockStartOffset)
					addPreparsedToken(blockStartOffset, currentOffset, STRING_CONTENT);
				break;
			}
			if (isQuoteDiffers && !isEscaped)
			{
				if (currentChar == openQuote)
				{
					quotesLevel++;
				}
				else if (currentChar == closeQuote)
				{
					quotesLevel--;
				}
			}

			isEscaped = (currentChar == '\\' && !isEscaped);
			currentOffset++;
		}

		return currentOffset;
	}

	/**
	 * Lexing empty spaces and comments between regex/tr blocks and adding tokens to the target list
	 *
	 * @param currentOffset start offset
	 * @param targetList    target list for CustomTokens
	 * @return new offset
	 */
	protected int lexWhiteSpacesAndComments(int currentOffset, List<CustomToken> targetList)
	{
		CharSequence buffer = getBuffer();
		int bufferEnd = getBufferEnd();
		while (currentOffset < bufferEnd)
		{
			char currentChar = buffer.charAt(currentOffset);

			if (currentChar == '\n')
				targetList.add(getCustomToken(currentOffset++, currentOffset, TokenType.NEW_LINE_INDENT));
			else if (Character.isWhitespace(currentChar))    // white spaces
			{
				int whiteSpaceStart = currentOffset;
				while (currentOffset < bufferEnd && Character.isWhitespace(currentChar = buffer.charAt(currentOffset)) && currentChar != '\n')
					currentOffset++;
				targetList.add(getCustomToken(whiteSpaceStart, currentOffset, TokenType.WHITE_SPACE));
			}
			else if (currentChar == '#')    // line comment
			{
				int commentStart = currentOffset;
				while (currentOffset < bufferEnd && buffer.charAt(currentOffset) != '\n')
					currentOffset++;
				targetList.add(getCustomToken(commentStart, currentOffset, COMMENT_LINE));
			}
			else
				break;
		}

		return currentOffset;
	}


	/**
	 * Parses regexp from the current position (opening delimiter) and preserves tokens in preparsedTokensList
	 * REGEX_MODIFIERS = [msixpodualgcer]
	 *
	 * @return opening delimiter type
	 */
	public IElementType parseRegex(int tokenStart)
	{
		popState();
		CharSequence buffer = getBuffer();
		int bufferEnd = getBufferEnd();

		char openQuote = buffer.charAt(tokenStart);
		addPreparsedToken(tokenStart++, tokenStart, REGEX_QUOTE_OPEN);

		// find block 1
		RegexBlock firstBlock = RegexBlock.parseBlock(buffer, tokenStart, bufferEnd, openQuote, false);

		if (firstBlock == null)
			return getPreParsedToken();

		int currentOffset = firstBlock.getEndOffset();

		// find block 2
		List<CustomToken> betweenBlocks = new ArrayList<CustomToken>();
		RegexBlock secondBLock = null;
		CustomToken secondBlockOpener = null;

		if (sectionsNumber == 2 && currentOffset < bufferEnd)
		{
			if (firstBlock.hasSameQuotes())
				secondBLock = RegexBlock.parseBlock(buffer, currentOffset, bufferEnd, firstBlock.getOpeningQuote(), true);
			else
			{
				currentOffset = lexWhiteSpacesAndComments(currentOffset, betweenBlocks);

				if (currentOffset < bufferEnd)
				{
					// read block
					secondBlockOpener = new CustomToken(currentOffset, currentOffset + 1, REGEX_QUOTE_OPEN);
					secondBLock = RegexBlock.parseBlock(buffer, currentOffset + 1, bufferEnd, buffer.charAt(currentOffset), true);
				}
			}

			if (secondBLock == null)
				return getPreParsedToken();

			currentOffset = secondBLock.getEndOffset();
		}

		// check modifiers for x
		boolean isExtended = false;
		boolean isEvaluated = false;
		List<Character> allowedModifiers = RegexBlock.allowedModifiers.get(regexCommand == null ? null : regexCommand.toString());
		int modifiersEnd = currentOffset;
		ArrayList<CustomToken> modifierTokens = new ArrayList<CustomToken>();

		while (modifiersEnd < bufferEnd)
		{
			if (!allowedModifiers.contains(buffer.charAt(modifiersEnd)))    // unknown modifier
				break;
			else if (buffer.charAt(modifiersEnd) == 'x')    // mark as extended
			{
				if (preparsedTokensList.getFirst().getTokenType() == REGEX_QUOTE_OPEN)
					preparsedTokensList.getFirst().setTokenType(REGEX_QUOTE_OPEN_X);

				isExtended = true;
			}
			else if (buffer.charAt(modifiersEnd) == 'e')    // mark as evaluated
			{
				isEvaluated = true;
				if (secondBlockOpener != null)
					secondBlockOpener.setTokenType(REGEX_QUOTE_OPEN_E);
			}

			modifierTokens.add(new CustomToken(modifiersEnd, modifiersEnd + 1, REGEX_MODIFIER));

			modifiersEnd++;
		}

		// parse block 1
		preparsedTokensList.addAll(firstBlock.tokenize(getBareStringLexer(), isExtended, false));

		if (secondBLock != null)
		{
			// parse spaces
			preparsedTokensList.addAll(betweenBlocks);

			if (secondBlockOpener != null)
				preparsedTokensList.add(secondBlockOpener);
			else if (isEvaluated)
				preparsedTokensList.getLast().setTokenType(REGEX_QUOTE_E);
			else
				preparsedTokensList.getLast().setTokenType(REGEX_QUOTE);


			// parse block 2
			if (isEvaluated)
			{
				if (evalPerlLexer == null)
					evalPerlLexer = new PerlLexerAdapter(myProject);
				preparsedTokensList.addAll(secondBLock.parseEval(evalPerlLexer));
			}
			else
				preparsedTokensList.addAll(secondBLock.tokenize(getBareStringLexer(), false, true));
		}

		// parse modifiers
		preparsedTokensList.addAll(modifierTokens);

		return getPreParsedToken();
	}

	/**
	 * Transliteration processors tr y
	 **/
	public void processTransOpener()
	{
		allowSharpQuote = true;
		pushState();
		yybegin(LEX_TRANS_OPENER);
	}

	/**
	 * Quote-like string procesors
	 **/
	public void processQuoteLikeStringOpener(IElementType tokenType)
	{
		allowSharpQuote = true;
		isEscaped = false;
		pushState();
		if (tokenType == RESERVED_Q)
			yybegin(LEX_QUOTE_LIKE_OPENER_Q);
		else if (tokenType == RESERVED_QQ)
			yybegin(LEX_QUOTE_LIKE_OPENER_QQ);
		else if (tokenType == RESERVED_QX)
			yybegin(LEX_QUOTE_LIKE_OPENER_QX);
		else if (tokenType == RESERVED_QW)
			yybegin(LEX_QUOTE_LIKE_OPENER_QW);
		else
			throw new RuntimeException("Unable to switch state by token " + tokenType);
	}

	public IElementType getOpenQuoteTokenType(char quoteCharacter)
	{
		if (quoteCharacter == '"')
			return QUOTE_DOUBLE_OPEN;
		else if (quoteCharacter == '`')
			return QUOTE_TICK_OPEN;
		else if (quoteCharacter == '\'')
			return QUOTE_SINGLE_OPEN;
		else
			throw new RuntimeException("Unknown open quote type " + quoteCharacter);
	}

	public IElementType getCloseQuoteTokenType(char quoteCharacter)
	{
		if (quoteCharacter == '"')
			return QUOTE_DOUBLE_CLOSE;
		else if (quoteCharacter == '`')
			return QUOTE_TICK_CLOSE;
		else if (quoteCharacter == '\'')
			return QUOTE_SINGLE_CLOSE;
		else
			throw new RuntimeException("Unknown close quote type " + quoteCharacter);
	}


	public PerlStringLexer getStringLexer()
	{
		int currentState = yystate();
		if (currentState == LEX_QUOTE_LIKE_OPENER_Q)
			return getQStringLexer();
		if (currentState == LEX_QUOTE_LIKE_OPENER_QQ)
			return getQQStringLexer();
		if (currentState == LEX_QUOTE_LIKE_OPENER_QX)
			return getQXStringLexer();
		if (currentState == LEX_QUOTE_LIKE_OPENER_QW)
			return getQStringLexer();
//		return getQWStringLexer();

		throw new RuntimeException("Unknown lexical state for string token " + currentState);
	}

	public boolean waitingHereDoc()
	{
		return waitingHereDoc(yystate());
	}

	public boolean waitingHereDoc(int state)
	{
		return state == LEX_HEREDOC_WAITING || state == LEX_HEREDOC_WAITING_QQ || state == LEX_HEREDOC_WAITING_QX;
	}

	/**
	 * Parses IDENTIFIER =>
	 * can be string_content => or ->identifier
	 *
	 * @return token type
	 */
	public IElementType parseBarewordMinus()
	{
		final CharSequence tokenText = yytext();
		boolean startsWithMinus = tokenText.charAt(0) == '-';

		boolean negate = IDENTIFIER_NEGATION_PREFIX.contains(getTokenHistory().getLastSignificantTokenType()) || SIGILS_TOKENS.contains(getTokenHistory().getLastTokenType());

		if (Character.isDigit(tokenText.charAt(0)))
		{
			int endOffset = 1;
			while (Character.isDigit(tokenText.charAt(endOffset)))
				endOffset++;

			yypushback(tokenText.length() - endOffset);
			return NUMBER_SIMPLE;
		}
		else if (!negate && isBraced())
		{
			return IDENTIFIER;
		}
		else if (!negate && isCommaArrowAhead())
		{
			if (startsWithMinus)
			{
				return STRING_CONTENT;
			}
			else
			{
				return STRING_IDENTIFIER;
			}
		}
		else if (StringUtil.startsWith(tokenText, "--"))
		{
			yypushback(tokenText.length() - 2);
			return OPERATOR_MINUS_MINUS;
		}
		else if (startsWithMinus)
		{
			yypushback(tokenText.length() - 1);
			return OPERATOR_MINUS;
		}

		return getIdentifierToken();
	}

	/**
	 * Bareword parser, resolves built-ins and runs additional processings where it's necessary
	 *
	 * @return token type
	 */
	public IElementType getIdentifierToken()
	{
		String tokenText = yytext().toString();
		IElementType tokenType;
		PerlTokenHistory tokenHistory = getTokenHistory();
		IElementType lastSignificantTokenType = tokenHistory.getLastSignificantTokenType();

		boolean isSigilBehind = SIGILS_TOKENS.contains(tokenHistory.getLastTokenType());

		if (isAttribute)
		{
			if (getNextCharacter() == '(')
			{
				pushState();
				yybegin(LEX_QUOTE_LIKE_OPENER_Q);
			}
			return IDENTIFIER;
		}
		else if (!IDENTIFIER_NEGATION_PREFIX.contains(lastSignificantTokenType)
				&& !isSigilBehind    // print $$ if smth
				)
		{

			if ((tokenType = namedOperators.get(tokenText)) != null)
			{
				return tokenType;
			}
			else if (
					(lastSignificantTokenType == OPERATOR_FILETEST && tokenText.equals("_"))    // for -t _
							|| (tokenHistory.getLastUnparenTokenType() == IDENTIFIER
							&& PerlParserUtil.PRE_HANDLE_OPS.contains(tokenHistory.getLastUnparenTokenTextAsString())
							&& !PerlSubUtil.BUILT_IN.contains(tokenText)
							&& isListElementEndAhead()
					))
			{
				return HANDLE;
			}
			else if ((tokenType = RESERVED_TOKEN_TYPES.get(tokenText)) != null)
			{
				return tokenType;
			}
			else if ((tokenType = blockNames.get(tokenText)) != null)
			{
				return tokenType;
			}
			else if ((tokenType = tagNames.get(tokenText)) != null)
			{
				return tokenType;
			}
		}
		else if (lastSignificantTokenType == RESERVED_USE || lastSignificantTokenType == RESERVED_NO) // pragma section
		{
			if (PRAGMA_TOKENS_MAP.containsKey(tokenText))
			{
				return PRAGMA_TOKENS_MAP.get(tokenText);
			}

		}

		if (!isSigilBehind && (tokenType = CUSTOM_TOKEN_TYPES.get(tokenText)) != null)
		{
			return tokenType;
		}

		return IDENTIFIER;
	}

	/**
	 * Splitting ambiguous package to PACKAGE_IDENTIFIER and IDENTIFIER
	 *
	 * @return token type
	 */
	public IElementType parsePackage()
	{
		String tokenText = yytext().toString();

		// check if it's cmp'
		if (tokenText.length() > 4 && tokenText.charAt(3) == '\'' && tokenText.substring(0, 3).equals("cmp"))
		{
			yypushback(tokenText.length() - 3);
			return getIdentifierToken();
		}
		// check if it's qw|qr|qx|qq|tr|ne|eq|gt|lt|ge|le'
		else if (tokenText.length() > 3 && tokenText.charAt(2) == '\'' && PACKAGE_EXCEPTIONS.contains(tokenText.substring(0, 2)))
		{
			yypushback(tokenText.length() - 2);
			return getIdentifierToken();
		}
		// check if it's m|q|s|y'
		else if (tokenText.length() > 2 && tokenText.charAt(1) == '\'' && PACKAGE_EXCEPTIONS.contains(tokenText.substring(0, 1)))
		{
			yypushback(tokenText.length() - 1);
			return getIdentifierToken();
		}

		Matcher m = AMBIGUOUS_PACKAGE_PATTERN.matcher(tokenText);
		if (m.matches())
		{
			String packageIdentifier = m.group(1);
			String identifier = m.group(2);

			preparsedTokensList.clear();
			int packageIdentifierEnd = getTokenStart() + packageIdentifier.length();
			CustomToken barewordToken = new CustomToken(packageIdentifierEnd, getTokenEnd(), IDENTIFIER);
			preparsedTokensList.add(barewordToken);
			setTokenEnd(packageIdentifierEnd);

			IElementType packageTokenType = parsePackageCanonical();

			if (packageTokenType == PACKAGE_CORE_IDENTIFIER && RESERVED_TOKEN_TYPES.containsKey(identifier))
				barewordToken.setTokenType(RESERVED_TOKEN_TYPES.get(identifier));
			return packageTokenType;

		}
		else
			throw new RuntimeException("Inappropriate package name " + tokenText);
	}

	// checks if ahead is comma, semi, close brace
	private boolean isListElementEndAhead()
	{
		int nextPosition = getNextSignificantCharacterPosition(getTokenEnd());
		if (nextPosition > -1)
		{
			CharSequence buffer = getBuffer();
			char nextChar = buffer.charAt(nextPosition);
			if (
					nextChar == ','
							|| nextChar == ';'
							|| nextChar == ')'
							|| nextChar == '='
							&& nextPosition + 1 < getBufferEnd()
							&& buffer.charAt(nextPosition + 1) == '>'
					)
				return true;
		}
		return false;
	}

	// checks if ahead is =>
	private boolean isCommaArrowAhead()
	{
		int nextPosition = getNextSignificantCharacterPosition(getTokenEnd());
		if (nextPosition > -1)
		{
			CharSequence buffer = getBuffer();
			if (
					buffer.charAt(nextPosition) == '='
							&& nextPosition + 1 < getBufferEnd()
							&& buffer.charAt(nextPosition + 1) == '>'
					)
				return true;
		}
		return false;
	}

	@Override
	public IElementType parseOperatorDereference()
	{
		if (getTokenHistory().getLastTokenType() == SIGIL_SCALAR)    // suppose it's a $->
		{
			yypushback(1);
			return IDENTIFIER;
		}
		return OPERATOR_DEREFERENCE;
	}

	/**
	 * Checks if buffer at current offset contains specific string
	 *
	 * @param buffer  CharSequence buffer
	 * @param offset  offset
	 * @param pattern string to search
	 * @return search result
	 */
	public boolean bufferAtString(CharSequence buffer, int offset, CharSequence pattern)
	{
		int patternEnd = offset + pattern.length();
		return getBufferEnd() >= patternEnd && StringUtil.equals(buffer.subSequence(offset, patternEnd), pattern);
	}

	public void registerToken(IElementType tokenType, String tokenText)
	{
		super.registerToken(tokenType, tokenText);

		// fixme refactor this
		if (!PerlParserDefinition.WHITE_SPACE_AND_COMMENTS.contains(tokenType))
			if (yystate() == YYINITIAL && tokenType != SEMICOLON) // to ensure proper highlighting reparsing
				yybegin(LEX_CODE);
	}


	@Override
	public void resetInternals()
	{
		super.resetInternals();
		waitingSubAttribute = false;
		waitingVarAttribute = false;
		resetAttributeCounters();
		heredocQueue.clear();
	}

	@Override
	public IElementType advance() throws IOException
	{
		boolean wasPreparsed = preparsedTokensList.size() > 0;

		IElementType tokenType = super.advance();

		if (!wasPreparsed && preparsedTokensList.isEmpty())
		{
			attributesLogic(tokenType);

			if (tokenType == TokenType.NEW_LINE_INDENT || tokenType == TokenType.WHITE_SPACE)
			{
				allowSharpQuote = false;
			}
			else if (tokenType == SEMICOLON) // fixme this is bad, semi might be in the prototype
			{
				int currentState = yystate();
				if (currentState != LEX_FORMAT_WAITING && currentState != LEX_HEREDOC_WAITING)
				{
					yybegin(YYINITIAL);
				}
/*
				else if (stateStack.size() > 0)
				{
					int i = stateStack.size() - 1;
					while (i >= 0 && waitingHereDoc(stateStack.get(i)))
					{
						i--;
					}
					stateStack.set(i, YYINITIAL);
				}
*/
			}
			else if (tokenType == RESERVED_QW || tokenType == RESERVED_Q || tokenType == RESERVED_QQ || tokenType == RESERVED_QX)
			{
				processQuoteLikeStringOpener(tokenType);
			}
			else if (tokenType == RESERVED_S || tokenType == RESERVED_M || tokenType == RESERVED_QR)
			{
				processRegexOpener();
			}
			else if (tokenType == RESERVED_MY || tokenType == RESERVED_OUR || tokenType == RESERVED_STATE)
			{
				waitingVarAttribute = true;
				resetAttributeCounters();
			}
			else if (tokenType == RESERVED_SUB)
			{
				waitingSubAttribute = true;
				resetAttributeCounters();
			}
			else if (tokenType == RESERVED_TR || tokenType == RESERVED_Y)
			{
				processTransOpener();
			}
			else if (tokenType == RESERVED_FORMAT)
			{
				pushState();
				yybegin(LEX_FORMAT_WAITING);
			}
			else if (tokenType == SIGIL_SCALAR)
			{
				// fixme this is really lame, because $$. is valid operation but won't work here
				// fixme this is fires badly in prototypes and signatures like $$
				char nextChar = getNextCharacter();
				if (StringUtil.containsChar(SPECIAL_VARIABLE_NAMES_OPERATORS, nextChar) &&
						(nextChar != '\'' || !isValidIdentifierCharacter(getSafeCharacterAt(getTokenEnd() + 1)))
						)
				{
					addPreparsedToken(getTokenEnd(), getTokenEnd() + 1, IDENTIFIER);
				}
			}
		}

		return tokenType;
	}

	protected void attributesLogic(IElementType tokenType)
	{
		// stop on extra closing ) ] }
		if (waitingSubAttribute || waitingVarAttribute)
		{
			if (tokenType == LEFT_BRACE)
				waitingAttributeBraceLevel++;
			else if (tokenType == RIGHT_BRACE)
				waitingAttributeBraceLevel--;
			if (tokenType == LEFT_PAREN)
				waitingAttributeParenLevel++;
			else if (tokenType == RIGHT_PAREN)
				waitingAttributeParenLevel--;

			if (waitingSubAttribute)
			{
				if (tokenType == LEFT_BRACKET)
					waitingAttributeBracketLevel++;
				else if (tokenType == RIGHT_BRACKET)
					waitingAttributeBracketLevel--;
			}

			if (waitingAttributeBraceLevel < 0
					|| waitingAttributeParenLevel < 0
					|| waitingAttributeBracketLevel < 0
					)
			{
				waitingSubAttribute = false;
				waitingVarAttribute = false;
			}
		}

		// stop on incorrect token
		if (waitingSubAttribute && !ALLOWED_WHILE_WAITING_SUB_ATTRIBUTE.contains(tokenType))
		{
			waitingSubAttribute = false;
		}

		// stop on incorrect token
		if (waitingVarAttribute && !ALLOWED_WHILE_WAITING_VAR_ATTRIBUTE.contains(tokenType))
		{
			waitingVarAttribute = false;
		}

		// stop on incorrect token
		if (isAttribute && !ALLOWED_IN_ATTRIBUTE.contains(tokenType))
		{
			isAttribute = false;
		}

		// switch to attribute
		if ((waitingVarAttribute || waitingSubAttribute) && tokenType == COLON)
		{
			waitingVarAttribute = false;
			waitingSubAttribute = false;
			isAttribute = true;
		}

	}

	protected void resetAttributeCounters()
	{
		isAttribute = false;
		waitingAttributeBraceLevel = 0;
		waitingAttributeBracketLevel = 0;
		waitingAttributeParenLevel = 0;
	}

	@Override
	public IElementType guessLtNumeric()
	{
		if (isTermPosition())
		{
			return LEFT_ANGLE;
		}
		return OPERATOR_LT_NUMERIC;
	}
}
